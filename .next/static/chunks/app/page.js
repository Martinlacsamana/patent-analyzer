/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["app/page"],{

/***/ "?f848":
/*!************************!*\
  !*** canvas (ignored) ***!
  \************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

/* (ignored) */

/***/ }),

/***/ "?4fe2":
/*!********************!*\
  !*** fs (ignored) ***!
  \********************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

/* (ignored) */

/***/ }),

/***/ "?0b2e":
/*!**********************!*\
  !*** http (ignored) ***!
  \**********************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

/* (ignored) */

/***/ }),

/***/ "?fd26":
/*!***********************!*\
  !*** https (ignored) ***!
  \***********************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

/* (ignored) */

/***/ }),

/***/ "?2b44":
/*!**********************!*\
  !*** zlib (ignored) ***!
  \**********************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

/* (ignored) */

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2FUsers%2Fmartinlacsamana%2FDocuments%2F160%2Fproject%2Fpatent-analyzer%2Fapp%2Fpage.tsx%22%2C%22ids%22%3A%5B%5D%7D&server=false!":
/*!**********************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2FUsers%2Fmartinlacsamana%2FDocuments%2F160%2Fproject%2Fpatent-analyzer%2Fapp%2Fpage.tsx%22%2C%22ids%22%3A%5B%5D%7D&server=false! ***!
  \**********************************************************************************************************************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("Promise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./app/page.tsx */ \"(app-pages-browser)/./app/page.tsx\"));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtZmxpZ2h0LWNsaWVudC1lbnRyeS1sb2FkZXIuanM/bW9kdWxlcz0lN0IlMjJyZXF1ZXN0JTIyJTNBJTIyJTJGVXNlcnMlMkZtYXJ0aW5sYWNzYW1hbmElMkZEb2N1bWVudHMlMkYxNjAlMkZwcm9qZWN0JTJGcGF0ZW50LWFuYWx5emVyJTJGYXBwJTJGcGFnZS50c3glMjIlMkMlMjJpZHMlMjIlM0ElNUIlNUQlN0Qmc2VydmVyPWZhbHNlISIsIm1hcHBpbmdzIjoiQUFBQSxzSkFBOEciLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLz8yODU3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCgvKiB3ZWJwYWNrTW9kZTogXCJlYWdlclwiICovIFwiL1VzZXJzL21hcnRpbmxhY3NhbWFuYS9Eb2N1bWVudHMvMTYwL3Byb2plY3QvcGF0ZW50LWFuYWx5emVyL2FwcC9wYWdlLnRzeFwiKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2FUsers%2Fmartinlacsamana%2FDocuments%2F160%2Fproject%2Fpatent-analyzer%2Fapp%2Fpage.tsx%22%2C%22ids%22%3A%5B%5D%7D&server=false!\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/clsx/dist/clsx.js":
/*!****************************************!*\
  !*** ./node_modules/clsx/dist/clsx.js ***!
  \****************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("function r(e){var o,t,f=\"\";if(\"string\"==typeof e||\"number\"==typeof e)f+=e;else if(\"object\"==typeof e)if(Array.isArray(e)){var n=e.length;for(o=0;o<n;o++)e[o]&&(t=r(e[o]))&&(f&&(f+=\" \"),f+=t)}else for(t in e)e[t]&&(f&&(f+=\" \"),f+=t);return f}function e(){for(var e,o,t=0,f=\"\",n=arguments.length;t<n;t++)(e=arguments[t])&&(o=r(e))&&(f&&(f+=\" \"),f+=o);return f}module.exports=e,module.exports.clsx=e;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jbHN4L2Rpc3QvY2xzeC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxjQUFjLGFBQWEsK0NBQStDLGdEQUFnRCxlQUFlLFFBQVEsSUFBSSwwQ0FBMEMseUNBQXlDLFNBQVMsYUFBYSx3Q0FBd0MsSUFBSSxtREFBbUQsU0FBUyxpQkFBaUIsbUJBQW1CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9jbHN4L2Rpc3QvY2xzeC5qcz83ZDhhIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIHIoZSl7dmFyIG8sdCxmPVwiXCI7aWYoXCJzdHJpbmdcIj09dHlwZW9mIGV8fFwibnVtYmVyXCI9PXR5cGVvZiBlKWYrPWU7ZWxzZSBpZihcIm9iamVjdFwiPT10eXBlb2YgZSlpZihBcnJheS5pc0FycmF5KGUpKXt2YXIgbj1lLmxlbmd0aDtmb3Iobz0wO288bjtvKyspZVtvXSYmKHQ9cihlW29dKSkmJihmJiYoZis9XCIgXCIpLGYrPXQpfWVsc2UgZm9yKHQgaW4gZSllW3RdJiYoZiYmKGYrPVwiIFwiKSxmKz10KTtyZXR1cm4gZn1mdW5jdGlvbiBlKCl7Zm9yKHZhciBlLG8sdD0wLGY9XCJcIixuPWFyZ3VtZW50cy5sZW5ndGg7dDxuO3QrKykoZT1hcmd1bWVudHNbdF0pJiYobz1yKGUpKSYmKGYmJihmKz1cIiBcIiksZis9byk7cmV0dXJuIGZ9bW9kdWxlLmV4cG9ydHM9ZSxtb2R1bGUuZXhwb3J0cy5jbHN4PWU7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/clsx/dist/clsx.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/dequal/dist/index.js":
/*!*******************************************!*\
  !*** ./node_modules/dequal/dist/index.js ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval(__webpack_require__.ts("var has = Object.prototype.hasOwnProperty;\n\nfunction find(iter, tar, key) {\n\tfor (key of iter.keys()) {\n\t\tif (dequal(key, tar)) return key;\n\t}\n}\n\nfunction dequal(foo, bar) {\n\tvar ctor, len, tmp;\n\tif (foo === bar) return true;\n\n\tif (foo && bar && (ctor=foo.constructor) === bar.constructor) {\n\t\tif (ctor === Date) return foo.getTime() === bar.getTime();\n\t\tif (ctor === RegExp) return foo.toString() === bar.toString();\n\n\t\tif (ctor === Array) {\n\t\t\tif ((len=foo.length) === bar.length) {\n\t\t\t\twhile (len-- && dequal(foo[len], bar[len]));\n\t\t\t}\n\t\t\treturn len === -1;\n\t\t}\n\n\t\tif (ctor === Set) {\n\t\t\tif (foo.size !== bar.size) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tfor (len of foo) {\n\t\t\t\ttmp = len;\n\t\t\t\tif (tmp && typeof tmp === 'object') {\n\t\t\t\t\ttmp = find(bar, tmp);\n\t\t\t\t\tif (!tmp) return false;\n\t\t\t\t}\n\t\t\t\tif (!bar.has(tmp)) return false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tif (ctor === Map) {\n\t\t\tif (foo.size !== bar.size) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tfor (len of foo) {\n\t\t\t\ttmp = len[0];\n\t\t\t\tif (tmp && typeof tmp === 'object') {\n\t\t\t\t\ttmp = find(bar, tmp);\n\t\t\t\t\tif (!tmp) return false;\n\t\t\t\t}\n\t\t\t\tif (!dequal(len[1], bar.get(tmp))) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tif (ctor === ArrayBuffer) {\n\t\t\tfoo = new Uint8Array(foo);\n\t\t\tbar = new Uint8Array(bar);\n\t\t} else if (ctor === DataView) {\n\t\t\tif ((len=foo.byteLength) === bar.byteLength) {\n\t\t\t\twhile (len-- && foo.getInt8(len) === bar.getInt8(len));\n\t\t\t}\n\t\t\treturn len === -1;\n\t\t}\n\n\t\tif (ArrayBuffer.isView(foo)) {\n\t\t\tif ((len=foo.byteLength) === bar.byteLength) {\n\t\t\t\twhile (len-- && foo[len] === bar[len]);\n\t\t\t}\n\t\t\treturn len === -1;\n\t\t}\n\n\t\tif (!ctor || typeof foo === 'object') {\n\t\t\tlen = 0;\n\t\t\tfor (ctor in foo) {\n\t\t\t\tif (has.call(foo, ctor) && ++len && !has.call(bar, ctor)) return false;\n\t\t\t\tif (!(ctor in bar) || !dequal(foo[ctor], bar[ctor])) return false;\n\t\t\t}\n\t\t\treturn Object.keys(bar).length === len;\n\t\t}\n\t}\n\n\treturn foo !== foo && bar !== bar;\n}\n\nexports.dequal = dequal;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9kZXF1YWwvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGNBQWMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2RlcXVhbC9kaXN0L2luZGV4LmpzP2I0NDYiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGhhcyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbmZ1bmN0aW9uIGZpbmQoaXRlciwgdGFyLCBrZXkpIHtcblx0Zm9yIChrZXkgb2YgaXRlci5rZXlzKCkpIHtcblx0XHRpZiAoZGVxdWFsKGtleSwgdGFyKSkgcmV0dXJuIGtleTtcblx0fVxufVxuXG5mdW5jdGlvbiBkZXF1YWwoZm9vLCBiYXIpIHtcblx0dmFyIGN0b3IsIGxlbiwgdG1wO1xuXHRpZiAoZm9vID09PSBiYXIpIHJldHVybiB0cnVlO1xuXG5cdGlmIChmb28gJiYgYmFyICYmIChjdG9yPWZvby5jb25zdHJ1Y3RvcikgPT09IGJhci5jb25zdHJ1Y3Rvcikge1xuXHRcdGlmIChjdG9yID09PSBEYXRlKSByZXR1cm4gZm9vLmdldFRpbWUoKSA9PT0gYmFyLmdldFRpbWUoKTtcblx0XHRpZiAoY3RvciA9PT0gUmVnRXhwKSByZXR1cm4gZm9vLnRvU3RyaW5nKCkgPT09IGJhci50b1N0cmluZygpO1xuXG5cdFx0aWYgKGN0b3IgPT09IEFycmF5KSB7XG5cdFx0XHRpZiAoKGxlbj1mb28ubGVuZ3RoKSA9PT0gYmFyLmxlbmd0aCkge1xuXHRcdFx0XHR3aGlsZSAobGVuLS0gJiYgZGVxdWFsKGZvb1tsZW5dLCBiYXJbbGVuXSkpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGxlbiA9PT0gLTE7XG5cdFx0fVxuXG5cdFx0aWYgKGN0b3IgPT09IFNldCkge1xuXHRcdFx0aWYgKGZvby5zaXplICE9PSBiYXIuc2l6ZSkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHRmb3IgKGxlbiBvZiBmb28pIHtcblx0XHRcdFx0dG1wID0gbGVuO1xuXHRcdFx0XHRpZiAodG1wICYmIHR5cGVvZiB0bXAgPT09ICdvYmplY3QnKSB7XG5cdFx0XHRcdFx0dG1wID0gZmluZChiYXIsIHRtcCk7XG5cdFx0XHRcdFx0aWYgKCF0bXApIHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIWJhci5oYXModG1wKSkgcmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0aWYgKGN0b3IgPT09IE1hcCkge1xuXHRcdFx0aWYgKGZvby5zaXplICE9PSBiYXIuc2l6ZSkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHRmb3IgKGxlbiBvZiBmb28pIHtcblx0XHRcdFx0dG1wID0gbGVuWzBdO1xuXHRcdFx0XHRpZiAodG1wICYmIHR5cGVvZiB0bXAgPT09ICdvYmplY3QnKSB7XG5cdFx0XHRcdFx0dG1wID0gZmluZChiYXIsIHRtcCk7XG5cdFx0XHRcdFx0aWYgKCF0bXApIHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIWRlcXVhbChsZW5bMV0sIGJhci5nZXQodG1wKSkpIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdGlmIChjdG9yID09PSBBcnJheUJ1ZmZlcikge1xuXHRcdFx0Zm9vID0gbmV3IFVpbnQ4QXJyYXkoZm9vKTtcblx0XHRcdGJhciA9IG5ldyBVaW50OEFycmF5KGJhcik7XG5cdFx0fSBlbHNlIGlmIChjdG9yID09PSBEYXRhVmlldykge1xuXHRcdFx0aWYgKChsZW49Zm9vLmJ5dGVMZW5ndGgpID09PSBiYXIuYnl0ZUxlbmd0aCkge1xuXHRcdFx0XHR3aGlsZSAobGVuLS0gJiYgZm9vLmdldEludDgobGVuKSA9PT0gYmFyLmdldEludDgobGVuKSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbGVuID09PSAtMTtcblx0XHR9XG5cblx0XHRpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KGZvbykpIHtcblx0XHRcdGlmICgobGVuPWZvby5ieXRlTGVuZ3RoKSA9PT0gYmFyLmJ5dGVMZW5ndGgpIHtcblx0XHRcdFx0d2hpbGUgKGxlbi0tICYmIGZvb1tsZW5dID09PSBiYXJbbGVuXSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbGVuID09PSAtMTtcblx0XHR9XG5cblx0XHRpZiAoIWN0b3IgfHwgdHlwZW9mIGZvbyA9PT0gJ29iamVjdCcpIHtcblx0XHRcdGxlbiA9IDA7XG5cdFx0XHRmb3IgKGN0b3IgaW4gZm9vKSB7XG5cdFx0XHRcdGlmIChoYXMuY2FsbChmb28sIGN0b3IpICYmICsrbGVuICYmICFoYXMuY2FsbChiYXIsIGN0b3IpKSByZXR1cm4gZmFsc2U7XG5cdFx0XHRcdGlmICghKGN0b3IgaW4gYmFyKSB8fCAhZGVxdWFsKGZvb1tjdG9yXSwgYmFyW2N0b3JdKSkgcmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIE9iamVjdC5rZXlzKGJhcikubGVuZ3RoID09PSBsZW47XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGZvbyAhPT0gZm9vICYmIGJhciAhPT0gYmFyO1xufVxuXG5leHBvcnRzLmRlcXVhbCA9IGRlcXVhbDsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/dequal/dist/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lucide-react/dist/esm/createLucideIcon.js":
/*!****************************************************************!*\
  !*** ./node_modules/lucide-react/dist/esm/createLucideIcon.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ createLucideIcon; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _defaultAttributes_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./defaultAttributes.js */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/defaultAttributes.js\");\n/* harmony import */ var _shared_src_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./shared/src/utils.js */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/shared/src/utils.js\");\n/**\n * @license lucide-react v0.372.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */ \n\n\nconst createLucideIcon = (iconName, iconNode)=>{\n    const Component = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)((param, ref)=>{\n        let { color = \"currentColor\", size = 24, strokeWidth = 2, absoluteStrokeWidth, className = \"\", children, ...rest } = param;\n        return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"svg\", {\n            ref,\n            ..._defaultAttributes_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"],\n            width: size,\n            height: size,\n            stroke: color,\n            strokeWidth: absoluteStrokeWidth ? Number(strokeWidth) * 24 / Number(size) : strokeWidth,\n            className: [\n                \"lucide\",\n                \"lucide-\".concat((0,_shared_src_utils_js__WEBPACK_IMPORTED_MODULE_2__.toKebabCase)(iconName)),\n                className\n            ].join(\" \"),\n            ...rest\n        }, [\n            ...iconNode.map((param)=>{\n                let [tag, attrs] = param;\n                return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(tag, attrs);\n            }),\n            ...Array.isArray(children) ? children : [\n                children\n            ]\n        ]);\n    });\n    Component.displayName = \"\".concat(iconName);\n    return Component;\n};\n //# sourceMappingURL=createLucideIcon.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3QvZGlzdC9lc20vY3JlYXRlTHVjaWRlSWNvbi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBdUJNLE1BQUFBLG1CQUFtQixDQUFDQyxVQUFrQkM7SUFDMUMsTUFBTUMsMEJBQVlDLGlEQUFVQSxDQUMxQixRQVVFQztZQVRBLEVBQ0VDLFFBQVEsZ0JBQ1JDLE9BQU8sSUFDUEMsY0FBYyxHQUNkQyxtQkFBQSxFQUNBQyxZQUFZLElBQ1pDLFFBQUEsRUFDQSxHQUFHQyxNQUFBO1FBSUUscUJBQUFDLG9EQUFhQSxDQUNsQixPQUNBO1lBQ0VSO1lBQ0EsR0FBR1MsNkRBQUE7WUFDSEMsT0FBT1I7WUFDUFMsUUFBUVQ7WUFDUlUsUUFBUVg7WUFDUkUsYUFBYUMsc0JBQ1JTLE9BQU9WLGVBQWUsS0FBTVUsT0FBT1gsUUFDcENDO1lBQ0pFLFdBQVc7Z0JBQUM7Z0JBQW9CLFVBQXlCLE9BQXpCUyxpRUFBV0EsQ0FBQ2xCO2dCQUFhUzthQUFXLENBQUFVLElBQUEsQ0FBSztZQUN6RSxHQUFHUixJQUFBO1FBQ0wsR0FDQTtlQUNLVixTQUFTbUIsR0FBQSxDQUFJO29CQUFDLENBQUNDLEtBQUtDLE1BQVc7cUNBQUFWLG9EQUFhQSxDQUFDUyxLQUFLQzs7ZUFDakRDLE1BQU1DLE9BQUEsQ0FBUWQsWUFBWUEsV0FBVztnQkFBQ0E7YUFBUTtTQUNwRDtJQUVKO0lBR1FSLFVBQUF1QixXQUFBLEdBQWMsR0FBVyxPQUFSekI7SUFFcEIsT0FBQUU7QUFDVCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vc3JjL2NyZWF0ZUx1Y2lkZUljb24udHM/MDQ4OCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBmb3J3YXJkUmVmLFxuICBjcmVhdGVFbGVtZW50LFxuICBSZWFjdFNWRyxcbiAgU1ZHUHJvcHMsXG4gIEZvcndhcmRSZWZFeG90aWNDb21wb25lbnQsXG4gIFJlZkF0dHJpYnV0ZXMsXG59IGZyb20gJ3JlYWN0JztcbmltcG9ydCBkZWZhdWx0QXR0cmlidXRlcyBmcm9tICcuL2RlZmF1bHRBdHRyaWJ1dGVzJztcbmltcG9ydCB7IHRvS2ViYWJDYXNlIH0gZnJvbSAnQGx1Y2lkZS9zaGFyZWQnO1xuXG5leHBvcnQgdHlwZSBJY29uTm9kZSA9IFtlbGVtZW50TmFtZToga2V5b2YgUmVhY3RTVkcsIGF0dHJzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+XVtdO1xuXG5leHBvcnQgdHlwZSBTVkdBdHRyaWJ1dGVzID0gUGFydGlhbDxTVkdQcm9wczxTVkdTVkdFbGVtZW50Pj47XG50eXBlIENvbXBvbmVudEF0dHJpYnV0ZXMgPSBSZWZBdHRyaWJ1dGVzPFNWR1NWR0VsZW1lbnQ+ICYgU1ZHQXR0cmlidXRlcztcblxuZXhwb3J0IGludGVyZmFjZSBMdWNpZGVQcm9wcyBleHRlbmRzIENvbXBvbmVudEF0dHJpYnV0ZXMge1xuICBzaXplPzogc3RyaW5nIHwgbnVtYmVyO1xuICBhYnNvbHV0ZVN0cm9rZVdpZHRoPzogYm9vbGVhbjtcbn1cblxuZXhwb3J0IHR5cGUgTHVjaWRlSWNvbiA9IEZvcndhcmRSZWZFeG90aWNDb21wb25lbnQ8THVjaWRlUHJvcHM+O1xuXG5jb25zdCBjcmVhdGVMdWNpZGVJY29uID0gKGljb25OYW1lOiBzdHJpbmcsIGljb25Ob2RlOiBJY29uTm9kZSk6IEx1Y2lkZUljb24gPT4ge1xuICBjb25zdCBDb21wb25lbnQgPSBmb3J3YXJkUmVmPFNWR1NWR0VsZW1lbnQsIEx1Y2lkZVByb3BzPihcbiAgICAoXG4gICAgICB7XG4gICAgICAgIGNvbG9yID0gJ2N1cnJlbnRDb2xvcicsXG4gICAgICAgIHNpemUgPSAyNCxcbiAgICAgICAgc3Ryb2tlV2lkdGggPSAyLFxuICAgICAgICBhYnNvbHV0ZVN0cm9rZVdpZHRoLFxuICAgICAgICBjbGFzc05hbWUgPSAnJyxcbiAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgIC4uLnJlc3RcbiAgICAgIH0sXG4gICAgICByZWYsXG4gICAgKSA9PiB7XG4gICAgICByZXR1cm4gY3JlYXRlRWxlbWVudChcbiAgICAgICAgJ3N2ZycsXG4gICAgICAgIHtcbiAgICAgICAgICByZWYsXG4gICAgICAgICAgLi4uZGVmYXVsdEF0dHJpYnV0ZXMsXG4gICAgICAgICAgd2lkdGg6IHNpemUsXG4gICAgICAgICAgaGVpZ2h0OiBzaXplLFxuICAgICAgICAgIHN0cm9rZTogY29sb3IsXG4gICAgICAgICAgc3Ryb2tlV2lkdGg6IGFic29sdXRlU3Ryb2tlV2lkdGhcbiAgICAgICAgICAgID8gKE51bWJlcihzdHJva2VXaWR0aCkgKiAyNCkgLyBOdW1iZXIoc2l6ZSlcbiAgICAgICAgICAgIDogc3Ryb2tlV2lkdGgsXG4gICAgICAgICAgY2xhc3NOYW1lOiBbJ2x1Y2lkZScsIGBsdWNpZGUtJHt0b0tlYmFiQ2FzZShpY29uTmFtZSl9YCwgY2xhc3NOYW1lXS5qb2luKCcgJyksXG4gICAgICAgICAgLi4ucmVzdCxcbiAgICAgICAgfSxcbiAgICAgICAgW1xuICAgICAgICAgIC4uLmljb25Ob2RlLm1hcCgoW3RhZywgYXR0cnNdKSA9PiBjcmVhdGVFbGVtZW50KHRhZywgYXR0cnMpKSxcbiAgICAgICAgICAuLi4oQXJyYXkuaXNBcnJheShjaGlsZHJlbikgPyBjaGlsZHJlbiA6IFtjaGlsZHJlbl0pLFxuICAgICAgICBdLFxuICAgICAgKTtcbiAgICB9LFxuICApO1xuXG4gIENvbXBvbmVudC5kaXNwbGF5TmFtZSA9IGAke2ljb25OYW1lfWA7XG5cbiAgcmV0dXJuIENvbXBvbmVudDtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGNyZWF0ZUx1Y2lkZUljb247XG4iXSwibmFtZXMiOlsiY3JlYXRlTHVjaWRlSWNvbiIsImljb25OYW1lIiwiaWNvbk5vZGUiLCJDb21wb25lbnQiLCJmb3J3YXJkUmVmIiwicmVmIiwiY29sb3IiLCJzaXplIiwic3Ryb2tlV2lkdGgiLCJhYnNvbHV0ZVN0cm9rZVdpZHRoIiwiY2xhc3NOYW1lIiwiY2hpbGRyZW4iLCJyZXN0IiwiY3JlYXRlRWxlbWVudCIsImRlZmF1bHRBdHRyaWJ1dGVzIiwid2lkdGgiLCJoZWlnaHQiLCJzdHJva2UiLCJOdW1iZXIiLCJ0b0tlYmFiQ2FzZSIsImpvaW4iLCJtYXAiLCJ0YWciLCJhdHRycyIsIkFycmF5IiwiaXNBcnJheSIsImRpc3BsYXlOYW1lIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lucide-react/dist/esm/createLucideIcon.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lucide-react/dist/esm/defaultAttributes.js":
/*!*****************************************************************!*\
  !*** ./node_modules/lucide-react/dist/esm/defaultAttributes.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ defaultAttributes; }\n/* harmony export */ });\n/**\n * @license lucide-react v0.372.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */ var defaultAttributes = {\n    xmlns: \"http://www.w3.org/2000/svg\",\n    width: 24,\n    height: 24,\n    viewBox: \"0 0 24 24\",\n    fill: \"none\",\n    stroke: \"currentColor\",\n    strokeWidth: 2,\n    strokeLinecap: \"round\",\n    strokeLinejoin: \"round\"\n};\n //# sourceMappingURL=defaultAttributes.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3QvZGlzdC9lc20vZGVmYXVsdEF0dHJpYnV0ZXMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0lBQUEsSUFBZUEsb0JBQUE7SUFDYkMsT0FBTztJQUNQQyxPQUFPO0lBQ1BDLFFBQVE7SUFDUkMsU0FBUztJQUNUQyxNQUFNO0lBQ05DLFFBQVE7SUFDUkMsYUFBYTtJQUNiQyxlQUFlO0lBQ2ZDLGdCQUFnQjtBQUNsQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vc3JjL2RlZmF1bHRBdHRyaWJ1dGVzLnRzPzM3MGMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQge1xuICB4bWxuczogJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyxcbiAgd2lkdGg6IDI0LFxuICBoZWlnaHQ6IDI0LFxuICB2aWV3Qm94OiAnMCAwIDI0IDI0JyxcbiAgZmlsbDogJ25vbmUnLFxuICBzdHJva2U6ICdjdXJyZW50Q29sb3InLFxuICBzdHJva2VXaWR0aDogMixcbiAgc3Ryb2tlTGluZWNhcDogJ3JvdW5kJyxcbiAgc3Ryb2tlTGluZWpvaW46ICdyb3VuZCcsXG59O1xuIl0sIm5hbWVzIjpbImRlZmF1bHRBdHRyaWJ1dGVzIiwieG1sbnMiLCJ3aWR0aCIsImhlaWdodCIsInZpZXdCb3giLCJmaWxsIiwic3Ryb2tlIiwic3Ryb2tlV2lkdGgiLCJzdHJva2VMaW5lY2FwIiwic3Ryb2tlTGluZWpvaW4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lucide-react/dist/esm/defaultAttributes.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/download.js":
/*!**************************************************************!*\
  !*** ./node_modules/lucide-react/dist/esm/icons/download.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Download; }\n/* harmony export */ });\n/* harmony import */ var _createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../createLucideIcon.js */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/createLucideIcon.js\");\n/**\n * @license lucide-react v0.372.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */ \nconst Download = (0,_createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"Download\", [\n    [\n        \"path\",\n        {\n            d: \"M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4\",\n            key: \"ih7n3h\"\n        }\n    ],\n    [\n        \"polyline\",\n        {\n            points: \"7 10 12 15 17 10\",\n            key: \"2ggqvy\"\n        }\n    ],\n    [\n        \"line\",\n        {\n            x1: \"12\",\n            x2: \"12\",\n            y1: \"15\",\n            y2: \"3\",\n            key: \"1vk2je\"\n        }\n    ]\n]);\n //# sourceMappingURL=download.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3QvZGlzdC9lc20vaWNvbnMvZG93bmxvYWQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFhTSxNQUFBQSxXQUFXQyxnRUFBZ0JBLENBQUMsWUFBWTtJQUM1QztRQUFDO1FBQVE7WUFBRUMsR0FBRztZQUE2Q0MsS0FBSztRQUFBO0tBQVU7SUFDMUU7UUFBQztRQUFZO1lBQUVDLFFBQVE7WUFBb0JELEtBQUs7UUFBQTtLQUFVO0lBQzFEO1FBQUM7UUFBUTtZQUFFRSxJQUFJO1lBQU1DLElBQUk7WUFBTUMsSUFBSTtZQUFNQyxJQUFJO1lBQUtMLEtBQUs7UUFBQTtLQUFVO0NBQ2xFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi9zcmMvaWNvbnMvZG93bmxvYWQudHM/N2EzZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgY3JlYXRlTHVjaWRlSWNvbiBmcm9tICcuLi9jcmVhdGVMdWNpZGVJY29uJztcblxuLyoqXG4gKiBAY29tcG9uZW50IEBuYW1lIERvd25sb2FkXG4gKiBAZGVzY3JpcHRpb24gTHVjaWRlIFNWRyBpY29uIGNvbXBvbmVudCwgcmVuZGVycyBTVkcgRWxlbWVudCB3aXRoIGNoaWxkcmVuLlxuICpcbiAqIEBwcmV2aWV3ICFbaW1nXShkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUFnZUcxc2JuTTlJbWgwZEhBNkx5OTNkM2N1ZHpNdWIzSm5Mekl3TURBdmMzWm5JZ29nSUhkcFpIUm9QU0l5TkNJS0lDQm9aV2xuYUhROUlqSTBJZ29nSUhacFpYZENiM2c5SWpBZ01DQXlOQ0F5TkNJS0lDQm1hV3hzUFNKdWIyNWxJZ29nSUhOMGNtOXJaVDBpSXpBd01DSWdjM1I1YkdVOUltSmhZMnRuY205MWJtUXRZMjlzYjNJNklDTm1abVk3SUdKdmNtUmxjaTF5WVdScGRYTTZJREp3ZUNJS0lDQnpkSEp2YTJVdGQybGtkR2c5SWpJaUNpQWdjM1J5YjJ0bExXeHBibVZqWVhBOUluSnZkVzVrSWdvZ0lITjBjbTlyWlMxc2FXNWxhbTlwYmowaWNtOTFibVFpQ2o0S0lDQThjR0YwYUNCa1BTSk5NakVnTVRWMk5HRXlJRElnTUNBd0lERXRNaUF5U0RWaE1pQXlJREFnTUNBeExUSXRNbll0TkNJZ0x6NEtJQ0E4Y0c5c2VXeHBibVVnY0c5cGJuUnpQU0kzSURFd0lERXlJREUxSURFM0lERXdJaUF2UGdvZ0lEeHNhVzVsSUhneFBTSXhNaUlnZURJOUlqRXlJaUI1TVQwaU1UVWlJSGt5UFNJeklpQXZQZ284TDNOMlp6NEspIC0gaHR0cHM6Ly9sdWNpZGUuZGV2L2ljb25zL2Rvd25sb2FkXG4gKiBAc2VlIGh0dHBzOi8vbHVjaWRlLmRldi9ndWlkZS9wYWNrYWdlcy9sdWNpZGUtcmVhY3QgLSBEb2N1bWVudGF0aW9uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHByb3BzIC0gTHVjaWRlIGljb25zIHByb3BzIGFuZCBhbnkgdmFsaWQgU1ZHIGF0dHJpYnV0ZVxuICogQHJldHVybnMge0pTWC5FbGVtZW50fSBKU1ggRWxlbWVudFxuICpcbiAqL1xuY29uc3QgRG93bmxvYWQgPSBjcmVhdGVMdWNpZGVJY29uKCdEb3dubG9hZCcsIFtcbiAgWydwYXRoJywgeyBkOiAnTTIxIDE1djRhMiAyIDAgMCAxLTIgMkg1YTIgMiAwIDAgMS0yLTJ2LTQnLCBrZXk6ICdpaDduM2gnIH1dLFxuICBbJ3BvbHlsaW5lJywgeyBwb2ludHM6ICc3IDEwIDEyIDE1IDE3IDEwJywga2V5OiAnMmdncXZ5JyB9XSxcbiAgWydsaW5lJywgeyB4MTogJzEyJywgeDI6ICcxMicsIHkxOiAnMTUnLCB5MjogJzMnLCBrZXk6ICcxdmsyamUnIH1dLFxuXSk7XG5cbmV4cG9ydCBkZWZhdWx0IERvd25sb2FkO1xuIl0sIm5hbWVzIjpbIkRvd25sb2FkIiwiY3JlYXRlTHVjaWRlSWNvbiIsImQiLCJrZXkiLCJwb2ludHMiLCJ4MSIsIngyIiwieTEiLCJ5MiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/download.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/file.js":
/*!**********************************************************!*\
  !*** ./node_modules/lucide-react/dist/esm/icons/file.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ File; }\n/* harmony export */ });\n/* harmony import */ var _createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../createLucideIcon.js */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/createLucideIcon.js\");\n/**\n * @license lucide-react v0.372.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */ \nconst File = (0,_createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"File\", [\n    [\n        \"path\",\n        {\n            d: \"M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z\",\n            key: \"1rqfz7\"\n        }\n    ],\n    [\n        \"path\",\n        {\n            d: \"M14 2v4a2 2 0 0 0 2 2h4\",\n            key: \"tnqrlb\"\n        }\n    ]\n]);\n //# sourceMappingURL=file.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3QvZGlzdC9lc20vaWNvbnMvZmlsZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQWFNLE1BQUFBLE9BQU9DLGdFQUFnQkEsQ0FBQyxRQUFRO0lBQ3BDO1FBQUM7UUFBUTtZQUFFQyxHQUFHO1lBQThEQyxLQUFLO1FBQUE7S0FBVTtJQUMzRjtRQUFDO1FBQVE7WUFBRUQsR0FBRztZQUEyQkMsS0FBSztRQUFBO0tBQVU7Q0FDekQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uL3NyYy9pY29ucy9maWxlLnRzPzdjNjQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGNyZWF0ZUx1Y2lkZUljb24gZnJvbSAnLi4vY3JlYXRlTHVjaWRlSWNvbic7XG5cbi8qKlxuICogQGNvbXBvbmVudCBAbmFtZSBGaWxlXG4gKiBAZGVzY3JpcHRpb24gTHVjaWRlIFNWRyBpY29uIGNvbXBvbmVudCwgcmVuZGVycyBTVkcgRWxlbWVudCB3aXRoIGNoaWxkcmVuLlxuICpcbiAqIEBwcmV2aWV3ICFbaW1nXShkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUFnZUcxc2JuTTlJbWgwZEhBNkx5OTNkM2N1ZHpNdWIzSm5Mekl3TURBdmMzWm5JZ29nSUhkcFpIUm9QU0l5TkNJS0lDQm9aV2xuYUhROUlqSTBJZ29nSUhacFpYZENiM2c5SWpBZ01DQXlOQ0F5TkNJS0lDQm1hV3hzUFNKdWIyNWxJZ29nSUhOMGNtOXJaVDBpSXpBd01DSWdjM1I1YkdVOUltSmhZMnRuY205MWJtUXRZMjlzYjNJNklDTm1abVk3SUdKdmNtUmxjaTF5WVdScGRYTTZJREp3ZUNJS0lDQnpkSEp2YTJVdGQybGtkR2c5SWpJaUNpQWdjM1J5YjJ0bExXeHBibVZqWVhBOUluSnZkVzVrSWdvZ0lITjBjbTlyWlMxc2FXNWxhbTlwYmowaWNtOTFibVFpQ2o0S0lDQThjR0YwYUNCa1BTSk5NVFVnTWtnMllUSWdNaUF3SURBZ01DMHlJREoyTVRaaE1pQXlJREFnTUNBd0lESWdNbWd4TW1FeUlESWdNQ0F3SURBZ01pMHlWamRhSWlBdlBnb2dJRHh3WVhSb0lHUTlJazB4TkNBeWRqUmhNaUF5SURBZ01DQXdJRElnTW1nMElpQXZQZ284TDNOMlp6NEspIC0gaHR0cHM6Ly9sdWNpZGUuZGV2L2ljb25zL2ZpbGVcbiAqIEBzZWUgaHR0cHM6Ly9sdWNpZGUuZGV2L2d1aWRlL3BhY2thZ2VzL2x1Y2lkZS1yZWFjdCAtIERvY3VtZW50YXRpb25cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgLSBMdWNpZGUgaWNvbnMgcHJvcHMgYW5kIGFueSB2YWxpZCBTVkcgYXR0cmlidXRlXG4gKiBAcmV0dXJucyB7SlNYLkVsZW1lbnR9IEpTWCBFbGVtZW50XG4gKlxuICovXG5jb25zdCBGaWxlID0gY3JlYXRlTHVjaWRlSWNvbignRmlsZScsIFtcbiAgWydwYXRoJywgeyBkOiAnTTE1IDJINmEyIDIgMCAwIDAtMiAydjE2YTIgMiAwIDAgMCAyIDJoMTJhMiAyIDAgMCAwIDItMlY3WicsIGtleTogJzFycWZ6NycgfV0sXG4gIFsncGF0aCcsIHsgZDogJ00xNCAydjRhMiAyIDAgMCAwIDIgMmg0Jywga2V5OiAndG5xcmxiJyB9XSxcbl0pO1xuXG5leHBvcnQgZGVmYXVsdCBGaWxlO1xuIl0sIm5hbWVzIjpbIkZpbGUiLCJjcmVhdGVMdWNpZGVJY29uIiwiZCIsImtleSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/file.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/folder.js":
/*!************************************************************!*\
  !*** ./node_modules/lucide-react/dist/esm/icons/folder.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Folder; }\n/* harmony export */ });\n/* harmony import */ var _createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../createLucideIcon.js */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/createLucideIcon.js\");\n/**\n * @license lucide-react v0.372.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */ \nconst Folder = (0,_createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"Folder\", [\n    [\n        \"path\",\n        {\n            d: \"M20 20a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2h-7.9a2 2 0 0 1-1.69-.9L9.6 3.9A2 2 0 0 0 7.93 3H4a2 2 0 0 0-2 2v13a2 2 0 0 0 2 2Z\",\n            key: \"1kt360\"\n        }\n    ]\n]);\n //# sourceMappingURL=folder.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3QvZGlzdC9lc20vaWNvbnMvZm9sZGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBYU0sTUFBQUEsU0FBU0MsZ0VBQWdCQSxDQUFDLFVBQVU7SUFDeEM7UUFDRTtRQUNBO1lBQ0VDLEdBQUc7WUFDSEMsS0FBSztRQUNQO0tBQ0Y7Q0FDRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vLi4vc3JjL2ljb25zL2ZvbGRlci50cz80MTY4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBjcmVhdGVMdWNpZGVJY29uIGZyb20gJy4uL2NyZWF0ZUx1Y2lkZUljb24nO1xuXG4vKipcbiAqIEBjb21wb25lbnQgQG5hbWUgRm9sZGVyXG4gKiBAZGVzY3JpcHRpb24gTHVjaWRlIFNWRyBpY29uIGNvbXBvbmVudCwgcmVuZGVycyBTVkcgRWxlbWVudCB3aXRoIGNoaWxkcmVuLlxuICpcbiAqIEBwcmV2aWV3ICFbaW1nXShkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUFnZUcxc2JuTTlJbWgwZEhBNkx5OTNkM2N1ZHpNdWIzSm5Mekl3TURBdmMzWm5JZ29nSUhkcFpIUm9QU0l5TkNJS0lDQm9aV2xuYUhROUlqSTBJZ29nSUhacFpYZENiM2c5SWpBZ01DQXlOQ0F5TkNJS0lDQm1hV3hzUFNKdWIyNWxJZ29nSUhOMGNtOXJaVDBpSXpBd01DSWdjM1I1YkdVOUltSmhZMnRuY205MWJtUXRZMjlzYjNJNklDTm1abVk3SUdKdmNtUmxjaTF5WVdScGRYTTZJREp3ZUNJS0lDQnpkSEp2YTJVdGQybGtkR2c5SWpJaUNpQWdjM1J5YjJ0bExXeHBibVZqWVhBOUluSnZkVzVrSWdvZ0lITjBjbTlyWlMxc2FXNWxhbTlwYmowaWNtOTFibVFpQ2o0S0lDQThjR0YwYUNCa1BTSk5NakFnTWpCaE1pQXlJREFnTUNBd0lESXRNbFk0WVRJZ01pQXdJREFnTUMweUxUSm9MVGN1T1dFeUlESWdNQ0F3SURFdE1TNDJPUzB1T1V3NUxqWWdNeTQ1UVRJZ01pQXdJREFnTUNBM0xqa3pJRE5JTkdFeUlESWdNQ0F3SURBdE1pQXlkakV6WVRJZ01pQXdJREFnTUNBeUlESmFJaUF2UGdvOEwzTjJaejRLKSAtIGh0dHBzOi8vbHVjaWRlLmRldi9pY29ucy9mb2xkZXJcbiAqIEBzZWUgaHR0cHM6Ly9sdWNpZGUuZGV2L2d1aWRlL3BhY2thZ2VzL2x1Y2lkZS1yZWFjdCAtIERvY3VtZW50YXRpb25cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgLSBMdWNpZGUgaWNvbnMgcHJvcHMgYW5kIGFueSB2YWxpZCBTVkcgYXR0cmlidXRlXG4gKiBAcmV0dXJucyB7SlNYLkVsZW1lbnR9IEpTWCBFbGVtZW50XG4gKlxuICovXG5jb25zdCBGb2xkZXIgPSBjcmVhdGVMdWNpZGVJY29uKCdGb2xkZXInLCBbXG4gIFtcbiAgICAncGF0aCcsXG4gICAge1xuICAgICAgZDogJ00yMCAyMGEyIDIgMCAwIDAgMi0yVjhhMiAyIDAgMCAwLTItMmgtNy45YTIgMiAwIDAgMS0xLjY5LS45TDkuNiAzLjlBMiAyIDAgMCAwIDcuOTMgM0g0YTIgMiAwIDAgMC0yIDJ2MTNhMiAyIDAgMCAwIDIgMlonLFxuICAgICAga2V5OiAnMWt0MzYwJyxcbiAgICB9LFxuICBdLFxuXSk7XG5cbmV4cG9ydCBkZWZhdWx0IEZvbGRlcjtcbiJdLCJuYW1lcyI6WyJGb2xkZXIiLCJjcmVhdGVMdWNpZGVJY29uIiwiZCIsImtleSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/folder.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lucide-react/dist/esm/shared/src/utils.js":
/*!****************************************************************!*\
  !*** ./node_modules/lucide-react/dist/esm/shared/src/utils.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   toKebabCase: function() { return /* binding */ toKebabCase; }\n/* harmony export */ });\n/**\n * @license lucide-react v0.372.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */ const toKebabCase = (string)=>string.replace(/([a-z0-9])([A-Z])/g, \"$1-$2\").toLowerCase();\n //# sourceMappingURL=utils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3QvZGlzdC9lc20vc2hhcmVkL3NyYy91dGlscy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7SUFNYSxNQUFBQSxjQUFjLENBQUNDLFNBQzFCQSxPQUFPQyxPQUFBLENBQVEsc0JBQXNCLFNBQVNDLFdBQVkiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uLy4uLy4uL3NoYXJlZC9zcmMvdXRpbHMudHM/NjdlOCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvbnZlcnRzIHN0cmluZyB0byBLZWJhYkNhc2VcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBBIGtlYmFiaXplZCBzdHJpbmdcbiAqL1xuZXhwb3J0IGNvbnN0IHRvS2ViYWJDYXNlID0gKHN0cmluZzogc3RyaW5nKSA9PlxuICBzdHJpbmcucmVwbGFjZSgvKFthLXowLTldKShbQS1aXSkvZywgJyQxLSQyJykudG9Mb3dlckNhc2UoKTtcbiJdLCJuYW1lcyI6WyJ0b0tlYmFiQ2FzZSIsInN0cmluZyIsInJlcGxhY2UiLCJ0b0xvd2VyQ2FzZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lucide-react/dist/esm/shared/src/utils.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/api/navigation.js":
/*!**************************************************!*\
  !*** ./node_modules/next/dist/api/navigation.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _client_components_navigation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../client/components/navigation */ \"(app-pages-browser)/./node_modules/next/dist/client/components/navigation.js\");\n/* harmony import */ var _client_components_navigation__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_client_components_navigation__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _client_components_navigation__WEBPACK_IMPORTED_MODULE_0__) if(__WEBPACK_IMPORT_KEY__ !== \"default\") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = function(key) { return _client_components_navigation__WEBPACK_IMPORTED_MODULE_0__[key]; }.bind(0, __WEBPACK_IMPORT_KEY__)\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n\n\n//# sourceMappingURL=navigation.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYXBpL25hdmlnYXRpb24uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQWdEOztBQUVoRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2FwaS9uYXZpZ2F0aW9uLmpzPzA2OWYiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0ICogZnJvbSBcIi4uL2NsaWVudC9jb21wb25lbnRzL25hdmlnYXRpb25cIjtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bmF2aWdhdGlvbi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/api/navigation.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/build/polyfills/object-assign.js":
/*!*****************************************************************!*\
  !*** ./node_modules/next/dist/build/polyfills/object-assign.js ***!
  \*****************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar assign = Object.assign.bind(Object);\nmodule.exports = assign;\nmodule.exports[\"default\"] = module.exports;\n\n//# sourceMappingURL=object-assign.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvcG9seWZpbGxzL29iamVjdC1hc3NpZ24uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0EseUJBQXNCOztBQUV0QiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3BvbHlmaWxscy9vYmplY3QtYXNzaWduLmpzP2MyN2EiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgYXNzaWduID0gT2JqZWN0LmFzc2lnbi5iaW5kKE9iamVjdCk7XG5tb2R1bGUuZXhwb3J0cyA9IGFzc2lnbjtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBtb2R1bGUuZXhwb3J0cztcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b2JqZWN0LWFzc2lnbi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/build/polyfills/object-assign.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js":
/*!***********************************************************!*\
  !*** ./node_modules/next/dist/build/polyfills/process.js ***!
  \***********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar _global_process, _global_process1;\nmodule.exports = ((_global_process = __webpack_require__.g.process) == null ? void 0 : _global_process.env) && typeof ((_global_process1 = __webpack_require__.g.process) == null ? void 0 : _global_process1.env) === \"object\" ? __webpack_require__.g.process : __webpack_require__(/*! next/dist/compiled/process */ \"(app-pages-browser)/./node_modules/next/dist/compiled/process/browser.js\");\n\n//# sourceMappingURL=process.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvcG9seWZpbGxzL3Byb2Nlc3MuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLHFDQUFxQyxxQkFBTSxpRkFBaUYscUJBQU0sa0VBQWtFLHFCQUFNLFdBQVcsbUJBQU8sQ0FBQyw0R0FBNEI7O0FBRXpQIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvcG9seWZpbGxzL3Byb2Nlc3MuanM/YTdkMSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfZ2xvYmFsX3Byb2Nlc3MsIF9nbG9iYWxfcHJvY2VzczE7XG5tb2R1bGUuZXhwb3J0cyA9ICgoX2dsb2JhbF9wcm9jZXNzID0gZ2xvYmFsLnByb2Nlc3MpID09IG51bGwgPyB2b2lkIDAgOiBfZ2xvYmFsX3Byb2Nlc3MuZW52KSAmJiB0eXBlb2YgKChfZ2xvYmFsX3Byb2Nlc3MxID0gZ2xvYmFsLnByb2Nlc3MpID09IG51bGwgPyB2b2lkIDAgOiBfZ2xvYmFsX3Byb2Nlc3MxLmVudikgPT09IFwib2JqZWN0XCIgPyBnbG9iYWwucHJvY2VzcyA6IHJlcXVpcmUoXCJuZXh0L2Rpc3QvY29tcGlsZWQvcHJvY2Vzc1wiKTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJvY2Vzcy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/buffer/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/next/dist/compiled/buffer/index.js ***!
  \*********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var __dirname = \"/\";\n(function(){var e={675:function(e,r){\"use strict\";r.byteLength=byteLength;r.toByteArray=toByteArray;r.fromByteArray=fromByteArray;var t=[];var f=[];var n=typeof Uint8Array!==\"undefined\"?Uint8Array:Array;var i=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";for(var o=0,u=i.length;o<u;++o){t[o]=i[o];f[i.charCodeAt(o)]=o}f[\"-\".charCodeAt(0)]=62;f[\"_\".charCodeAt(0)]=63;function getLens(e){var r=e.length;if(r%4>0){throw new Error(\"Invalid string. Length must be a multiple of 4\")}var t=e.indexOf(\"=\");if(t===-1)t=r;var f=t===r?0:4-t%4;return[t,f]}function byteLength(e){var r=getLens(e);var t=r[0];var f=r[1];return(t+f)*3/4-f}function _byteLength(e,r,t){return(r+t)*3/4-t}function toByteArray(e){var r;var t=getLens(e);var i=t[0];var o=t[1];var u=new n(_byteLength(e,i,o));var a=0;var s=o>0?i-4:i;var h;for(h=0;h<s;h+=4){r=f[e.charCodeAt(h)]<<18|f[e.charCodeAt(h+1)]<<12|f[e.charCodeAt(h+2)]<<6|f[e.charCodeAt(h+3)];u[a++]=r>>16&255;u[a++]=r>>8&255;u[a++]=r&255}if(o===2){r=f[e.charCodeAt(h)]<<2|f[e.charCodeAt(h+1)]>>4;u[a++]=r&255}if(o===1){r=f[e.charCodeAt(h)]<<10|f[e.charCodeAt(h+1)]<<4|f[e.charCodeAt(h+2)]>>2;u[a++]=r>>8&255;u[a++]=r&255}return u}function tripletToBase64(e){return t[e>>18&63]+t[e>>12&63]+t[e>>6&63]+t[e&63]}function encodeChunk(e,r,t){var f;var n=[];for(var i=r;i<t;i+=3){f=(e[i]<<16&16711680)+(e[i+1]<<8&65280)+(e[i+2]&255);n.push(tripletToBase64(f))}return n.join(\"\")}function fromByteArray(e){var r;var f=e.length;var n=f%3;var i=[];var o=16383;for(var u=0,a=f-n;u<a;u+=o){i.push(encodeChunk(e,u,u+o>a?a:u+o))}if(n===1){r=e[f-1];i.push(t[r>>2]+t[r<<4&63]+\"==\")}else if(n===2){r=(e[f-2]<<8)+e[f-1];i.push(t[r>>10]+t[r>>4&63]+t[r<<2&63]+\"=\")}return i.join(\"\")}},72:function(e,r,t){\"use strict\";\n/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */var f=t(675);var n=t(783);var i=typeof Symbol===\"function\"&&typeof Symbol.for===\"function\"?Symbol.for(\"nodejs.util.inspect.custom\"):null;r.Buffer=Buffer;r.SlowBuffer=SlowBuffer;r.INSPECT_MAX_BYTES=50;var o=2147483647;r.kMaxLength=o;Buffer.TYPED_ARRAY_SUPPORT=typedArraySupport();if(!Buffer.TYPED_ARRAY_SUPPORT&&typeof console!==\"undefined\"&&typeof console.error===\"function\"){console.error(\"This browser lacks typed array (Uint8Array) support which is required by \"+\"`buffer` v5.x. Use `buffer` v4.x if you require old browser support.\")}function typedArraySupport(){try{var e=new Uint8Array(1);var r={foo:function(){return 42}};Object.setPrototypeOf(r,Uint8Array.prototype);Object.setPrototypeOf(e,r);return e.foo()===42}catch(e){return false}}Object.defineProperty(Buffer.prototype,\"parent\",{enumerable:true,get:function(){if(!Buffer.isBuffer(this))return undefined;return this.buffer}});Object.defineProperty(Buffer.prototype,\"offset\",{enumerable:true,get:function(){if(!Buffer.isBuffer(this))return undefined;return this.byteOffset}});function createBuffer(e){if(e>o){throw new RangeError('The value \"'+e+'\" is invalid for option \"size\"')}var r=new Uint8Array(e);Object.setPrototypeOf(r,Buffer.prototype);return r}function Buffer(e,r,t){if(typeof e===\"number\"){if(typeof r===\"string\"){throw new TypeError('The \"string\" argument must be of type string. Received type number')}return allocUnsafe(e)}return from(e,r,t)}Buffer.poolSize=8192;function from(e,r,t){if(typeof e===\"string\"){return fromString(e,r)}if(ArrayBuffer.isView(e)){return fromArrayLike(e)}if(e==null){throw new TypeError(\"The first argument must be one of type string, Buffer, ArrayBuffer, Array, \"+\"or Array-like Object. Received type \"+typeof e)}if(isInstance(e,ArrayBuffer)||e&&isInstance(e.buffer,ArrayBuffer)){return fromArrayBuffer(e,r,t)}if(typeof SharedArrayBuffer!==\"undefined\"&&(isInstance(e,SharedArrayBuffer)||e&&isInstance(e.buffer,SharedArrayBuffer))){return fromArrayBuffer(e,r,t)}if(typeof e===\"number\"){throw new TypeError('The \"value\" argument must not be of type number. Received type number')}var f=e.valueOf&&e.valueOf();if(f!=null&&f!==e){return Buffer.from(f,r,t)}var n=fromObject(e);if(n)return n;if(typeof Symbol!==\"undefined\"&&Symbol.toPrimitive!=null&&typeof e[Symbol.toPrimitive]===\"function\"){return Buffer.from(e[Symbol.toPrimitive](\"string\"),r,t)}throw new TypeError(\"The first argument must be one of type string, Buffer, ArrayBuffer, Array, \"+\"or Array-like Object. Received type \"+typeof e)}Buffer.from=function(e,r,t){return from(e,r,t)};Object.setPrototypeOf(Buffer.prototype,Uint8Array.prototype);Object.setPrototypeOf(Buffer,Uint8Array);function assertSize(e){if(typeof e!==\"number\"){throw new TypeError('\"size\" argument must be of type number')}else if(e<0){throw new RangeError('The value \"'+e+'\" is invalid for option \"size\"')}}function alloc(e,r,t){assertSize(e);if(e<=0){return createBuffer(e)}if(r!==undefined){return typeof t===\"string\"?createBuffer(e).fill(r,t):createBuffer(e).fill(r)}return createBuffer(e)}Buffer.alloc=function(e,r,t){return alloc(e,r,t)};function allocUnsafe(e){assertSize(e);return createBuffer(e<0?0:checked(e)|0)}Buffer.allocUnsafe=function(e){return allocUnsafe(e)};Buffer.allocUnsafeSlow=function(e){return allocUnsafe(e)};function fromString(e,r){if(typeof r!==\"string\"||r===\"\"){r=\"utf8\"}if(!Buffer.isEncoding(r)){throw new TypeError(\"Unknown encoding: \"+r)}var t=byteLength(e,r)|0;var f=createBuffer(t);var n=f.write(e,r);if(n!==t){f=f.slice(0,n)}return f}function fromArrayLike(e){var r=e.length<0?0:checked(e.length)|0;var t=createBuffer(r);for(var f=0;f<r;f+=1){t[f]=e[f]&255}return t}function fromArrayBuffer(e,r,t){if(r<0||e.byteLength<r){throw new RangeError('\"offset\" is outside of buffer bounds')}if(e.byteLength<r+(t||0)){throw new RangeError('\"length\" is outside of buffer bounds')}var f;if(r===undefined&&t===undefined){f=new Uint8Array(e)}else if(t===undefined){f=new Uint8Array(e,r)}else{f=new Uint8Array(e,r,t)}Object.setPrototypeOf(f,Buffer.prototype);return f}function fromObject(e){if(Buffer.isBuffer(e)){var r=checked(e.length)|0;var t=createBuffer(r);if(t.length===0){return t}e.copy(t,0,0,r);return t}if(e.length!==undefined){if(typeof e.length!==\"number\"||numberIsNaN(e.length)){return createBuffer(0)}return fromArrayLike(e)}if(e.type===\"Buffer\"&&Array.isArray(e.data)){return fromArrayLike(e.data)}}function checked(e){if(e>=o){throw new RangeError(\"Attempt to allocate Buffer larger than maximum \"+\"size: 0x\"+o.toString(16)+\" bytes\")}return e|0}function SlowBuffer(e){if(+e!=e){e=0}return Buffer.alloc(+e)}Buffer.isBuffer=function isBuffer(e){return e!=null&&e._isBuffer===true&&e!==Buffer.prototype};Buffer.compare=function compare(e,r){if(isInstance(e,Uint8Array))e=Buffer.from(e,e.offset,e.byteLength);if(isInstance(r,Uint8Array))r=Buffer.from(r,r.offset,r.byteLength);if(!Buffer.isBuffer(e)||!Buffer.isBuffer(r)){throw new TypeError('The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array')}if(e===r)return 0;var t=e.length;var f=r.length;for(var n=0,i=Math.min(t,f);n<i;++n){if(e[n]!==r[n]){t=e[n];f=r[n];break}}if(t<f)return-1;if(f<t)return 1;return 0};Buffer.isEncoding=function isEncoding(e){switch(String(e).toLowerCase()){case\"hex\":case\"utf8\":case\"utf-8\":case\"ascii\":case\"latin1\":case\"binary\":case\"base64\":case\"ucs2\":case\"ucs-2\":case\"utf16le\":case\"utf-16le\":return true;default:return false}};Buffer.concat=function concat(e,r){if(!Array.isArray(e)){throw new TypeError('\"list\" argument must be an Array of Buffers')}if(e.length===0){return Buffer.alloc(0)}var t;if(r===undefined){r=0;for(t=0;t<e.length;++t){r+=e[t].length}}var f=Buffer.allocUnsafe(r);var n=0;for(t=0;t<e.length;++t){var i=e[t];if(isInstance(i,Uint8Array)){i=Buffer.from(i)}if(!Buffer.isBuffer(i)){throw new TypeError('\"list\" argument must be an Array of Buffers')}i.copy(f,n);n+=i.length}return f};function byteLength(e,r){if(Buffer.isBuffer(e)){return e.length}if(ArrayBuffer.isView(e)||isInstance(e,ArrayBuffer)){return e.byteLength}if(typeof e!==\"string\"){throw new TypeError('The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. '+\"Received type \"+typeof e)}var t=e.length;var f=arguments.length>2&&arguments[2]===true;if(!f&&t===0)return 0;var n=false;for(;;){switch(r){case\"ascii\":case\"latin1\":case\"binary\":return t;case\"utf8\":case\"utf-8\":return utf8ToBytes(e).length;case\"ucs2\":case\"ucs-2\":case\"utf16le\":case\"utf-16le\":return t*2;case\"hex\":return t>>>1;case\"base64\":return base64ToBytes(e).length;default:if(n){return f?-1:utf8ToBytes(e).length}r=(\"\"+r).toLowerCase();n=true}}}Buffer.byteLength=byteLength;function slowToString(e,r,t){var f=false;if(r===undefined||r<0){r=0}if(r>this.length){return\"\"}if(t===undefined||t>this.length){t=this.length}if(t<=0){return\"\"}t>>>=0;r>>>=0;if(t<=r){return\"\"}if(!e)e=\"utf8\";while(true){switch(e){case\"hex\":return hexSlice(this,r,t);case\"utf8\":case\"utf-8\":return utf8Slice(this,r,t);case\"ascii\":return asciiSlice(this,r,t);case\"latin1\":case\"binary\":return latin1Slice(this,r,t);case\"base64\":return base64Slice(this,r,t);case\"ucs2\":case\"ucs-2\":case\"utf16le\":case\"utf-16le\":return utf16leSlice(this,r,t);default:if(f)throw new TypeError(\"Unknown encoding: \"+e);e=(e+\"\").toLowerCase();f=true}}}Buffer.prototype._isBuffer=true;function swap(e,r,t){var f=e[r];e[r]=e[t];e[t]=f}Buffer.prototype.swap16=function swap16(){var e=this.length;if(e%2!==0){throw new RangeError(\"Buffer size must be a multiple of 16-bits\")}for(var r=0;r<e;r+=2){swap(this,r,r+1)}return this};Buffer.prototype.swap32=function swap32(){var e=this.length;if(e%4!==0){throw new RangeError(\"Buffer size must be a multiple of 32-bits\")}for(var r=0;r<e;r+=4){swap(this,r,r+3);swap(this,r+1,r+2)}return this};Buffer.prototype.swap64=function swap64(){var e=this.length;if(e%8!==0){throw new RangeError(\"Buffer size must be a multiple of 64-bits\")}for(var r=0;r<e;r+=8){swap(this,r,r+7);swap(this,r+1,r+6);swap(this,r+2,r+5);swap(this,r+3,r+4)}return this};Buffer.prototype.toString=function toString(){var e=this.length;if(e===0)return\"\";if(arguments.length===0)return utf8Slice(this,0,e);return slowToString.apply(this,arguments)};Buffer.prototype.toLocaleString=Buffer.prototype.toString;Buffer.prototype.equals=function equals(e){if(!Buffer.isBuffer(e))throw new TypeError(\"Argument must be a Buffer\");if(this===e)return true;return Buffer.compare(this,e)===0};Buffer.prototype.inspect=function inspect(){var e=\"\";var t=r.INSPECT_MAX_BYTES;e=this.toString(\"hex\",0,t).replace(/(.{2})/g,\"$1 \").trim();if(this.length>t)e+=\" ... \";return\"<Buffer \"+e+\">\"};if(i){Buffer.prototype[i]=Buffer.prototype.inspect}Buffer.prototype.compare=function compare(e,r,t,f,n){if(isInstance(e,Uint8Array)){e=Buffer.from(e,e.offset,e.byteLength)}if(!Buffer.isBuffer(e)){throw new TypeError('The \"target\" argument must be one of type Buffer or Uint8Array. '+\"Received type \"+typeof e)}if(r===undefined){r=0}if(t===undefined){t=e?e.length:0}if(f===undefined){f=0}if(n===undefined){n=this.length}if(r<0||t>e.length||f<0||n>this.length){throw new RangeError(\"out of range index\")}if(f>=n&&r>=t){return 0}if(f>=n){return-1}if(r>=t){return 1}r>>>=0;t>>>=0;f>>>=0;n>>>=0;if(this===e)return 0;var i=n-f;var o=t-r;var u=Math.min(i,o);var a=this.slice(f,n);var s=e.slice(r,t);for(var h=0;h<u;++h){if(a[h]!==s[h]){i=a[h];o=s[h];break}}if(i<o)return-1;if(o<i)return 1;return 0};function bidirectionalIndexOf(e,r,t,f,n){if(e.length===0)return-1;if(typeof t===\"string\"){f=t;t=0}else if(t>2147483647){t=2147483647}else if(t<-2147483648){t=-2147483648}t=+t;if(numberIsNaN(t)){t=n?0:e.length-1}if(t<0)t=e.length+t;if(t>=e.length){if(n)return-1;else t=e.length-1}else if(t<0){if(n)t=0;else return-1}if(typeof r===\"string\"){r=Buffer.from(r,f)}if(Buffer.isBuffer(r)){if(r.length===0){return-1}return arrayIndexOf(e,r,t,f,n)}else if(typeof r===\"number\"){r=r&255;if(typeof Uint8Array.prototype.indexOf===\"function\"){if(n){return Uint8Array.prototype.indexOf.call(e,r,t)}else{return Uint8Array.prototype.lastIndexOf.call(e,r,t)}}return arrayIndexOf(e,[r],t,f,n)}throw new TypeError(\"val must be string, number or Buffer\")}function arrayIndexOf(e,r,t,f,n){var i=1;var o=e.length;var u=r.length;if(f!==undefined){f=String(f).toLowerCase();if(f===\"ucs2\"||f===\"ucs-2\"||f===\"utf16le\"||f===\"utf-16le\"){if(e.length<2||r.length<2){return-1}i=2;o/=2;u/=2;t/=2}}function read(e,r){if(i===1){return e[r]}else{return e.readUInt16BE(r*i)}}var a;if(n){var s=-1;for(a=t;a<o;a++){if(read(e,a)===read(r,s===-1?0:a-s)){if(s===-1)s=a;if(a-s+1===u)return s*i}else{if(s!==-1)a-=a-s;s=-1}}}else{if(t+u>o)t=o-u;for(a=t;a>=0;a--){var h=true;for(var c=0;c<u;c++){if(read(e,a+c)!==read(r,c)){h=false;break}}if(h)return a}}return-1}Buffer.prototype.includes=function includes(e,r,t){return this.indexOf(e,r,t)!==-1};Buffer.prototype.indexOf=function indexOf(e,r,t){return bidirectionalIndexOf(this,e,r,t,true)};Buffer.prototype.lastIndexOf=function lastIndexOf(e,r,t){return bidirectionalIndexOf(this,e,r,t,false)};function hexWrite(e,r,t,f){t=Number(t)||0;var n=e.length-t;if(!f){f=n}else{f=Number(f);if(f>n){f=n}}var i=r.length;if(f>i/2){f=i/2}for(var o=0;o<f;++o){var u=parseInt(r.substr(o*2,2),16);if(numberIsNaN(u))return o;e[t+o]=u}return o}function utf8Write(e,r,t,f){return blitBuffer(utf8ToBytes(r,e.length-t),e,t,f)}function asciiWrite(e,r,t,f){return blitBuffer(asciiToBytes(r),e,t,f)}function latin1Write(e,r,t,f){return asciiWrite(e,r,t,f)}function base64Write(e,r,t,f){return blitBuffer(base64ToBytes(r),e,t,f)}function ucs2Write(e,r,t,f){return blitBuffer(utf16leToBytes(r,e.length-t),e,t,f)}Buffer.prototype.write=function write(e,r,t,f){if(r===undefined){f=\"utf8\";t=this.length;r=0}else if(t===undefined&&typeof r===\"string\"){f=r;t=this.length;r=0}else if(isFinite(r)){r=r>>>0;if(isFinite(t)){t=t>>>0;if(f===undefined)f=\"utf8\"}else{f=t;t=undefined}}else{throw new Error(\"Buffer.write(string, encoding, offset[, length]) is no longer supported\")}var n=this.length-r;if(t===undefined||t>n)t=n;if(e.length>0&&(t<0||r<0)||r>this.length){throw new RangeError(\"Attempt to write outside buffer bounds\")}if(!f)f=\"utf8\";var i=false;for(;;){switch(f){case\"hex\":return hexWrite(this,e,r,t);case\"utf8\":case\"utf-8\":return utf8Write(this,e,r,t);case\"ascii\":return asciiWrite(this,e,r,t);case\"latin1\":case\"binary\":return latin1Write(this,e,r,t);case\"base64\":return base64Write(this,e,r,t);case\"ucs2\":case\"ucs-2\":case\"utf16le\":case\"utf-16le\":return ucs2Write(this,e,r,t);default:if(i)throw new TypeError(\"Unknown encoding: \"+f);f=(\"\"+f).toLowerCase();i=true}}};Buffer.prototype.toJSON=function toJSON(){return{type:\"Buffer\",data:Array.prototype.slice.call(this._arr||this,0)}};function base64Slice(e,r,t){if(r===0&&t===e.length){return f.fromByteArray(e)}else{return f.fromByteArray(e.slice(r,t))}}function utf8Slice(e,r,t){t=Math.min(e.length,t);var f=[];var n=r;while(n<t){var i=e[n];var o=null;var u=i>239?4:i>223?3:i>191?2:1;if(n+u<=t){var a,s,h,c;switch(u){case 1:if(i<128){o=i}break;case 2:a=e[n+1];if((a&192)===128){c=(i&31)<<6|a&63;if(c>127){o=c}}break;case 3:a=e[n+1];s=e[n+2];if((a&192)===128&&(s&192)===128){c=(i&15)<<12|(a&63)<<6|s&63;if(c>2047&&(c<55296||c>57343)){o=c}}break;case 4:a=e[n+1];s=e[n+2];h=e[n+3];if((a&192)===128&&(s&192)===128&&(h&192)===128){c=(i&15)<<18|(a&63)<<12|(s&63)<<6|h&63;if(c>65535&&c<1114112){o=c}}}}if(o===null){o=65533;u=1}else if(o>65535){o-=65536;f.push(o>>>10&1023|55296);o=56320|o&1023}f.push(o);n+=u}return decodeCodePointsArray(f)}var u=4096;function decodeCodePointsArray(e){var r=e.length;if(r<=u){return String.fromCharCode.apply(String,e)}var t=\"\";var f=0;while(f<r){t+=String.fromCharCode.apply(String,e.slice(f,f+=u))}return t}function asciiSlice(e,r,t){var f=\"\";t=Math.min(e.length,t);for(var n=r;n<t;++n){f+=String.fromCharCode(e[n]&127)}return f}function latin1Slice(e,r,t){var f=\"\";t=Math.min(e.length,t);for(var n=r;n<t;++n){f+=String.fromCharCode(e[n])}return f}function hexSlice(e,r,t){var f=e.length;if(!r||r<0)r=0;if(!t||t<0||t>f)t=f;var n=\"\";for(var i=r;i<t;++i){n+=s[e[i]]}return n}function utf16leSlice(e,r,t){var f=e.slice(r,t);var n=\"\";for(var i=0;i<f.length;i+=2){n+=String.fromCharCode(f[i]+f[i+1]*256)}return n}Buffer.prototype.slice=function slice(e,r){var t=this.length;e=~~e;r=r===undefined?t:~~r;if(e<0){e+=t;if(e<0)e=0}else if(e>t){e=t}if(r<0){r+=t;if(r<0)r=0}else if(r>t){r=t}if(r<e)r=e;var f=this.subarray(e,r);Object.setPrototypeOf(f,Buffer.prototype);return f};function checkOffset(e,r,t){if(e%1!==0||e<0)throw new RangeError(\"offset is not uint\");if(e+r>t)throw new RangeError(\"Trying to access beyond buffer length\")}Buffer.prototype.readUIntLE=function readUIntLE(e,r,t){e=e>>>0;r=r>>>0;if(!t)checkOffset(e,r,this.length);var f=this[e];var n=1;var i=0;while(++i<r&&(n*=256)){f+=this[e+i]*n}return f};Buffer.prototype.readUIntBE=function readUIntBE(e,r,t){e=e>>>0;r=r>>>0;if(!t){checkOffset(e,r,this.length)}var f=this[e+--r];var n=1;while(r>0&&(n*=256)){f+=this[e+--r]*n}return f};Buffer.prototype.readUInt8=function readUInt8(e,r){e=e>>>0;if(!r)checkOffset(e,1,this.length);return this[e]};Buffer.prototype.readUInt16LE=function readUInt16LE(e,r){e=e>>>0;if(!r)checkOffset(e,2,this.length);return this[e]|this[e+1]<<8};Buffer.prototype.readUInt16BE=function readUInt16BE(e,r){e=e>>>0;if(!r)checkOffset(e,2,this.length);return this[e]<<8|this[e+1]};Buffer.prototype.readUInt32LE=function readUInt32LE(e,r){e=e>>>0;if(!r)checkOffset(e,4,this.length);return(this[e]|this[e+1]<<8|this[e+2]<<16)+this[e+3]*16777216};Buffer.prototype.readUInt32BE=function readUInt32BE(e,r){e=e>>>0;if(!r)checkOffset(e,4,this.length);return this[e]*16777216+(this[e+1]<<16|this[e+2]<<8|this[e+3])};Buffer.prototype.readIntLE=function readIntLE(e,r,t){e=e>>>0;r=r>>>0;if(!t)checkOffset(e,r,this.length);var f=this[e];var n=1;var i=0;while(++i<r&&(n*=256)){f+=this[e+i]*n}n*=128;if(f>=n)f-=Math.pow(2,8*r);return f};Buffer.prototype.readIntBE=function readIntBE(e,r,t){e=e>>>0;r=r>>>0;if(!t)checkOffset(e,r,this.length);var f=r;var n=1;var i=this[e+--f];while(f>0&&(n*=256)){i+=this[e+--f]*n}n*=128;if(i>=n)i-=Math.pow(2,8*r);return i};Buffer.prototype.readInt8=function readInt8(e,r){e=e>>>0;if(!r)checkOffset(e,1,this.length);if(!(this[e]&128))return this[e];return(255-this[e]+1)*-1};Buffer.prototype.readInt16LE=function readInt16LE(e,r){e=e>>>0;if(!r)checkOffset(e,2,this.length);var t=this[e]|this[e+1]<<8;return t&32768?t|4294901760:t};Buffer.prototype.readInt16BE=function readInt16BE(e,r){e=e>>>0;if(!r)checkOffset(e,2,this.length);var t=this[e+1]|this[e]<<8;return t&32768?t|4294901760:t};Buffer.prototype.readInt32LE=function readInt32LE(e,r){e=e>>>0;if(!r)checkOffset(e,4,this.length);return this[e]|this[e+1]<<8|this[e+2]<<16|this[e+3]<<24};Buffer.prototype.readInt32BE=function readInt32BE(e,r){e=e>>>0;if(!r)checkOffset(e,4,this.length);return this[e]<<24|this[e+1]<<16|this[e+2]<<8|this[e+3]};Buffer.prototype.readFloatLE=function readFloatLE(e,r){e=e>>>0;if(!r)checkOffset(e,4,this.length);return n.read(this,e,true,23,4)};Buffer.prototype.readFloatBE=function readFloatBE(e,r){e=e>>>0;if(!r)checkOffset(e,4,this.length);return n.read(this,e,false,23,4)};Buffer.prototype.readDoubleLE=function readDoubleLE(e,r){e=e>>>0;if(!r)checkOffset(e,8,this.length);return n.read(this,e,true,52,8)};Buffer.prototype.readDoubleBE=function readDoubleBE(e,r){e=e>>>0;if(!r)checkOffset(e,8,this.length);return n.read(this,e,false,52,8)};function checkInt(e,r,t,f,n,i){if(!Buffer.isBuffer(e))throw new TypeError('\"buffer\" argument must be a Buffer instance');if(r>n||r<i)throw new RangeError('\"value\" argument is out of bounds');if(t+f>e.length)throw new RangeError(\"Index out of range\")}Buffer.prototype.writeUIntLE=function writeUIntLE(e,r,t,f){e=+e;r=r>>>0;t=t>>>0;if(!f){var n=Math.pow(2,8*t)-1;checkInt(this,e,r,t,n,0)}var i=1;var o=0;this[r]=e&255;while(++o<t&&(i*=256)){this[r+o]=e/i&255}return r+t};Buffer.prototype.writeUIntBE=function writeUIntBE(e,r,t,f){e=+e;r=r>>>0;t=t>>>0;if(!f){var n=Math.pow(2,8*t)-1;checkInt(this,e,r,t,n,0)}var i=t-1;var o=1;this[r+i]=e&255;while(--i>=0&&(o*=256)){this[r+i]=e/o&255}return r+t};Buffer.prototype.writeUInt8=function writeUInt8(e,r,t){e=+e;r=r>>>0;if(!t)checkInt(this,e,r,1,255,0);this[r]=e&255;return r+1};Buffer.prototype.writeUInt16LE=function writeUInt16LE(e,r,t){e=+e;r=r>>>0;if(!t)checkInt(this,e,r,2,65535,0);this[r]=e&255;this[r+1]=e>>>8;return r+2};Buffer.prototype.writeUInt16BE=function writeUInt16BE(e,r,t){e=+e;r=r>>>0;if(!t)checkInt(this,e,r,2,65535,0);this[r]=e>>>8;this[r+1]=e&255;return r+2};Buffer.prototype.writeUInt32LE=function writeUInt32LE(e,r,t){e=+e;r=r>>>0;if(!t)checkInt(this,e,r,4,4294967295,0);this[r+3]=e>>>24;this[r+2]=e>>>16;this[r+1]=e>>>8;this[r]=e&255;return r+4};Buffer.prototype.writeUInt32BE=function writeUInt32BE(e,r,t){e=+e;r=r>>>0;if(!t)checkInt(this,e,r,4,4294967295,0);this[r]=e>>>24;this[r+1]=e>>>16;this[r+2]=e>>>8;this[r+3]=e&255;return r+4};Buffer.prototype.writeIntLE=function writeIntLE(e,r,t,f){e=+e;r=r>>>0;if(!f){var n=Math.pow(2,8*t-1);checkInt(this,e,r,t,n-1,-n)}var i=0;var o=1;var u=0;this[r]=e&255;while(++i<t&&(o*=256)){if(e<0&&u===0&&this[r+i-1]!==0){u=1}this[r+i]=(e/o>>0)-u&255}return r+t};Buffer.prototype.writeIntBE=function writeIntBE(e,r,t,f){e=+e;r=r>>>0;if(!f){var n=Math.pow(2,8*t-1);checkInt(this,e,r,t,n-1,-n)}var i=t-1;var o=1;var u=0;this[r+i]=e&255;while(--i>=0&&(o*=256)){if(e<0&&u===0&&this[r+i+1]!==0){u=1}this[r+i]=(e/o>>0)-u&255}return r+t};Buffer.prototype.writeInt8=function writeInt8(e,r,t){e=+e;r=r>>>0;if(!t)checkInt(this,e,r,1,127,-128);if(e<0)e=255+e+1;this[r]=e&255;return r+1};Buffer.prototype.writeInt16LE=function writeInt16LE(e,r,t){e=+e;r=r>>>0;if(!t)checkInt(this,e,r,2,32767,-32768);this[r]=e&255;this[r+1]=e>>>8;return r+2};Buffer.prototype.writeInt16BE=function writeInt16BE(e,r,t){e=+e;r=r>>>0;if(!t)checkInt(this,e,r,2,32767,-32768);this[r]=e>>>8;this[r+1]=e&255;return r+2};Buffer.prototype.writeInt32LE=function writeInt32LE(e,r,t){e=+e;r=r>>>0;if(!t)checkInt(this,e,r,4,2147483647,-2147483648);this[r]=e&255;this[r+1]=e>>>8;this[r+2]=e>>>16;this[r+3]=e>>>24;return r+4};Buffer.prototype.writeInt32BE=function writeInt32BE(e,r,t){e=+e;r=r>>>0;if(!t)checkInt(this,e,r,4,2147483647,-2147483648);if(e<0)e=4294967295+e+1;this[r]=e>>>24;this[r+1]=e>>>16;this[r+2]=e>>>8;this[r+3]=e&255;return r+4};function checkIEEE754(e,r,t,f,n,i){if(t+f>e.length)throw new RangeError(\"Index out of range\");if(t<0)throw new RangeError(\"Index out of range\")}function writeFloat(e,r,t,f,i){r=+r;t=t>>>0;if(!i){checkIEEE754(e,r,t,4,34028234663852886e22,-34028234663852886e22)}n.write(e,r,t,f,23,4);return t+4}Buffer.prototype.writeFloatLE=function writeFloatLE(e,r,t){return writeFloat(this,e,r,true,t)};Buffer.prototype.writeFloatBE=function writeFloatBE(e,r,t){return writeFloat(this,e,r,false,t)};function writeDouble(e,r,t,f,i){r=+r;t=t>>>0;if(!i){checkIEEE754(e,r,t,8,17976931348623157e292,-17976931348623157e292)}n.write(e,r,t,f,52,8);return t+8}Buffer.prototype.writeDoubleLE=function writeDoubleLE(e,r,t){return writeDouble(this,e,r,true,t)};Buffer.prototype.writeDoubleBE=function writeDoubleBE(e,r,t){return writeDouble(this,e,r,false,t)};Buffer.prototype.copy=function copy(e,r,t,f){if(!Buffer.isBuffer(e))throw new TypeError(\"argument should be a Buffer\");if(!t)t=0;if(!f&&f!==0)f=this.length;if(r>=e.length)r=e.length;if(!r)r=0;if(f>0&&f<t)f=t;if(f===t)return 0;if(e.length===0||this.length===0)return 0;if(r<0){throw new RangeError(\"targetStart out of bounds\")}if(t<0||t>=this.length)throw new RangeError(\"Index out of range\");if(f<0)throw new RangeError(\"sourceEnd out of bounds\");if(f>this.length)f=this.length;if(e.length-r<f-t){f=e.length-r+t}var n=f-t;if(this===e&&typeof Uint8Array.prototype.copyWithin===\"function\"){this.copyWithin(r,t,f)}else if(this===e&&t<r&&r<f){for(var i=n-1;i>=0;--i){e[i+r]=this[i+t]}}else{Uint8Array.prototype.set.call(e,this.subarray(t,f),r)}return n};Buffer.prototype.fill=function fill(e,r,t,f){if(typeof e===\"string\"){if(typeof r===\"string\"){f=r;r=0;t=this.length}else if(typeof t===\"string\"){f=t;t=this.length}if(f!==undefined&&typeof f!==\"string\"){throw new TypeError(\"encoding must be a string\")}if(typeof f===\"string\"&&!Buffer.isEncoding(f)){throw new TypeError(\"Unknown encoding: \"+f)}if(e.length===1){var n=e.charCodeAt(0);if(f===\"utf8\"&&n<128||f===\"latin1\"){e=n}}}else if(typeof e===\"number\"){e=e&255}else if(typeof e===\"boolean\"){e=Number(e)}if(r<0||this.length<r||this.length<t){throw new RangeError(\"Out of range index\")}if(t<=r){return this}r=r>>>0;t=t===undefined?this.length:t>>>0;if(!e)e=0;var i;if(typeof e===\"number\"){for(i=r;i<t;++i){this[i]=e}}else{var o=Buffer.isBuffer(e)?e:Buffer.from(e,f);var u=o.length;if(u===0){throw new TypeError('The value \"'+e+'\" is invalid for argument \"value\"')}for(i=0;i<t-r;++i){this[i+r]=o[i%u]}}return this};var a=/[^+/0-9A-Za-z-_]/g;function base64clean(e){e=e.split(\"=\")[0];e=e.trim().replace(a,\"\");if(e.length<2)return\"\";while(e.length%4!==0){e=e+\"=\"}return e}function utf8ToBytes(e,r){r=r||Infinity;var t;var f=e.length;var n=null;var i=[];for(var o=0;o<f;++o){t=e.charCodeAt(o);if(t>55295&&t<57344){if(!n){if(t>56319){if((r-=3)>-1)i.push(239,191,189);continue}else if(o+1===f){if((r-=3)>-1)i.push(239,191,189);continue}n=t;continue}if(t<56320){if((r-=3)>-1)i.push(239,191,189);n=t;continue}t=(n-55296<<10|t-56320)+65536}else if(n){if((r-=3)>-1)i.push(239,191,189)}n=null;if(t<128){if((r-=1)<0)break;i.push(t)}else if(t<2048){if((r-=2)<0)break;i.push(t>>6|192,t&63|128)}else if(t<65536){if((r-=3)<0)break;i.push(t>>12|224,t>>6&63|128,t&63|128)}else if(t<1114112){if((r-=4)<0)break;i.push(t>>18|240,t>>12&63|128,t>>6&63|128,t&63|128)}else{throw new Error(\"Invalid code point\")}}return i}function asciiToBytes(e){var r=[];for(var t=0;t<e.length;++t){r.push(e.charCodeAt(t)&255)}return r}function utf16leToBytes(e,r){var t,f,n;var i=[];for(var o=0;o<e.length;++o){if((r-=2)<0)break;t=e.charCodeAt(o);f=t>>8;n=t%256;i.push(n);i.push(f)}return i}function base64ToBytes(e){return f.toByteArray(base64clean(e))}function blitBuffer(e,r,t,f){for(var n=0;n<f;++n){if(n+t>=r.length||n>=e.length)break;r[n+t]=e[n]}return n}function isInstance(e,r){return e instanceof r||e!=null&&e.constructor!=null&&e.constructor.name!=null&&e.constructor.name===r.name}function numberIsNaN(e){return e!==e}var s=function(){var e=\"0123456789abcdef\";var r=new Array(256);for(var t=0;t<16;++t){var f=t*16;for(var n=0;n<16;++n){r[f+n]=e[t]+e[n]}}return r}()},783:function(e,r){\n/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */\nr.read=function(e,r,t,f,n){var i,o;var u=n*8-f-1;var a=(1<<u)-1;var s=a>>1;var h=-7;var c=t?n-1:0;var l=t?-1:1;var p=e[r+c];c+=l;i=p&(1<<-h)-1;p>>=-h;h+=u;for(;h>0;i=i*256+e[r+c],c+=l,h-=8){}o=i&(1<<-h)-1;i>>=-h;h+=f;for(;h>0;o=o*256+e[r+c],c+=l,h-=8){}if(i===0){i=1-s}else if(i===a){return o?NaN:(p?-1:1)*Infinity}else{o=o+Math.pow(2,f);i=i-s}return(p?-1:1)*o*Math.pow(2,i-f)};r.write=function(e,r,t,f,n,i){var o,u,a;var s=i*8-n-1;var h=(1<<s)-1;var c=h>>1;var l=n===23?Math.pow(2,-24)-Math.pow(2,-77):0;var p=f?0:i-1;var y=f?1:-1;var g=r<0||r===0&&1/r<0?1:0;r=Math.abs(r);if(isNaN(r)||r===Infinity){u=isNaN(r)?1:0;o=h}else{o=Math.floor(Math.log(r)/Math.LN2);if(r*(a=Math.pow(2,-o))<1){o--;a*=2}if(o+c>=1){r+=l/a}else{r+=l*Math.pow(2,1-c)}if(r*a>=2){o++;a/=2}if(o+c>=h){u=0;o=h}else if(o+c>=1){u=(r*a-1)*Math.pow(2,n);o=o+c}else{u=r*Math.pow(2,c-1)*Math.pow(2,n);o=0}}for(;n>=8;e[t+p]=u&255,p+=y,u/=256,n-=8){}o=o<<n|u;s+=n;for(;s>0;e[t+p]=o&255,p+=y,o/=256,s-=8){}e[t+p-y]|=g*128}}};var r={};function __nccwpck_require__(t){var f=r[t];if(f!==undefined){return f.exports}var n=r[t]={exports:{}};var i=true;try{e[t](n,n.exports,__nccwpck_require__);i=false}finally{if(i)delete r[t]}return n.exports}if(typeof __nccwpck_require__!==\"undefined\")__nccwpck_require__.ab=__dirname+\"/\";var t=__nccwpck_require__(72);module.exports=t})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvYnVmZmVyL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7QUFBQSxZQUFZLE9BQU8sa0JBQWtCLGFBQWEsd0JBQXdCLDBCQUEwQiw4QkFBOEIsU0FBUyxTQUFTLHVEQUF1RCx5RUFBeUUsdUJBQXVCLElBQUksS0FBSyxVQUFVLHFCQUFxQix3QkFBd0Isd0JBQXdCLG9CQUFvQixlQUFlLFVBQVUsa0VBQWtFLHFCQUFxQixjQUFjLG9CQUFvQixZQUFZLHVCQUF1QixpQkFBaUIsV0FBVyxXQUFXLGtCQUFrQiw0QkFBNEIsa0JBQWtCLHdCQUF3QixNQUFNLGlCQUFpQixXQUFXLFdBQVcsZ0NBQWdDLFFBQVEsZ0JBQWdCLE1BQU0sUUFBUSxJQUFJLE1BQU0sK0ZBQStGLGlCQUFpQixnQkFBZ0IsYUFBYSxVQUFVLGdEQUFnRCxhQUFhLFVBQVUseUVBQXlFLGdCQUFnQixhQUFhLFNBQVMsNEJBQTRCLGtEQUFrRCw0QkFBNEIsTUFBTSxTQUFTLFlBQVksSUFBSSxNQUFNLHFEQUFxRCwyQkFBMkIsa0JBQWtCLDBCQUEwQixNQUFNLGVBQWUsVUFBVSxTQUFTLFlBQVksa0JBQWtCLElBQUksTUFBTSxxQ0FBcUMsVUFBVSxTQUFTLGdDQUFnQyxlQUFlLHFCQUFxQiwyQ0FBMkMsbUJBQW1CLG9CQUFvQjtBQUM5ckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixhQUFhLCtHQUErRyxnQkFBZ0Isd0JBQXdCLHVCQUF1QixpQkFBaUIsZUFBZSwrQ0FBK0MsaUdBQWlHLGtLQUFrSyw2QkFBNkIsSUFBSSx3QkFBd0IsT0FBTyxlQUFlLFlBQVksOENBQThDLDJCQUEyQixvQkFBb0IsU0FBUyxjQUFjLGlEQUFpRCwrQkFBK0IsMkNBQTJDLG9CQUFvQixFQUFFLGlEQUFpRCwrQkFBK0IsMkNBQTJDLHdCQUF3QixFQUFFLHlCQUF5QixRQUFRLHVFQUF1RSx3QkFBd0IsMENBQTBDLFNBQVMsdUJBQXVCLHdCQUF3Qix3QkFBd0IsMEZBQTBGLHNCQUFzQixtQkFBbUIscUJBQXFCLHFCQUFxQix3QkFBd0IsdUJBQXVCLDBCQUEwQix3QkFBd0IsWUFBWSxtSkFBbUosbUVBQW1FLDhCQUE4Qix5SEFBeUgsOEJBQThCLHdCQUF3Qiw2RkFBNkYsNkJBQTZCLG1CQUFtQiwwQkFBMEIsb0JBQW9CLGNBQWMscUdBQXFHLHdEQUF3RCxtSkFBbUosNEJBQTRCLG9CQUFvQiw2REFBNkQseUNBQXlDLHVCQUF1Qix3QkFBd0IsOERBQThELGFBQWEsd0VBQXdFLHNCQUFzQixjQUFjLFNBQVMsdUJBQXVCLGtCQUFrQiw2RUFBNkUsdUJBQXVCLDZCQUE2QixxQkFBcUIsd0JBQXdCLGNBQWMsd0NBQXdDLCtCQUErQix1QkFBdUIsbUNBQW1DLHVCQUF1Qix5QkFBeUIsZ0NBQWdDLFNBQVMsMEJBQTBCLDRDQUE0Qyx3QkFBd0Isc0JBQXNCLG1CQUFtQixVQUFVLGVBQWUsU0FBUywwQkFBMEIsdUNBQXVDLHNCQUFzQixZQUFZLElBQUksTUFBTSxjQUFjLFNBQVMsZ0NBQWdDLHdCQUF3Qiw2REFBNkQsMEJBQTBCLDZEQUE2RCxNQUFNLGlDQUFpQyxvQkFBb0IsdUJBQXVCLHNCQUFzQixLQUFLLHdCQUF3QiwwQ0FBMEMsU0FBUyx1QkFBdUIsdUJBQXVCLDBCQUEwQixzQkFBc0IsaUJBQWlCLFNBQVMsZ0JBQWdCLFNBQVMseUJBQXlCLHNEQUFzRCx1QkFBdUIsd0JBQXdCLDZDQUE2Qyw4QkFBOEIsb0JBQW9CLFNBQVMsMkdBQTJHLFdBQVcsdUJBQXVCLFVBQVUsSUFBSSx3QkFBd0IscUNBQXFDLDBEQUEwRCxxQ0FBcUMsbUVBQW1FLG1FQUFtRSw2Q0FBNkMsNkZBQTZGLGtCQUFrQixlQUFlLGVBQWUsNEJBQTRCLElBQUksS0FBSyxnQkFBZ0IsT0FBTyxPQUFPLE9BQU8sZ0JBQWdCLGdCQUFnQixVQUFVLHlDQUF5QyxnQ0FBZ0Msb0pBQW9KLHVCQUF1QixtQ0FBbUMsc0JBQXNCLG1FQUFtRSxpQkFBaUIsdUJBQXVCLE1BQU0sa0JBQWtCLElBQUksUUFBUSxXQUFXLEtBQUssZ0JBQWdCLDRCQUE0QixRQUFRLFFBQVEsV0FBVyxLQUFLLFdBQVcsNkJBQTZCLGlCQUFpQix3QkFBd0IsbUVBQW1FLFlBQVksWUFBWSxVQUFVLHlCQUF5Qix1QkFBdUIsZ0JBQWdCLHFEQUFxRCxvQkFBb0Isd0JBQXdCLDRIQUE0SCxlQUFlLDhDQUE4QyxzQkFBc0IsWUFBWSxNQUFNLEVBQUUsVUFBVSwrQ0FBK0Msb0RBQW9ELCtEQUErRCx1QkFBdUIsNENBQTRDLGNBQWMsa0NBQWtDLHVCQUF1QixTQUFTLDZCQUE2Qiw2QkFBNkIsWUFBWSx1QkFBdUIsSUFBSSxrQkFBa0IsU0FBUyxpQ0FBaUMsY0FBYyxTQUFTLFNBQVMsT0FBTyxPQUFPLFNBQVMsU0FBUyxlQUFlLFlBQVksVUFBVSxvQ0FBb0Msa0RBQWtELHdDQUF3Qyx1REFBdUQsMENBQTBDLGtGQUFrRix5REFBeUQsdUJBQXVCLFNBQVMsZ0NBQWdDLHFCQUFxQixXQUFXLFVBQVUsT0FBTywwQ0FBMEMsa0JBQWtCLFlBQVksa0VBQWtFLFlBQVksSUFBSSxNQUFNLGlCQUFpQixhQUFhLDBDQUEwQyxrQkFBa0IsWUFBWSxrRUFBa0UsWUFBWSxJQUFJLE1BQU0saUJBQWlCLG1CQUFtQixhQUFhLDBDQUEwQyxrQkFBa0IsWUFBWSxrRUFBa0UsWUFBWSxJQUFJLE1BQU0saUJBQWlCLG1CQUFtQixtQkFBbUIsbUJBQW1CLGFBQWEsOENBQThDLGtCQUFrQixrQkFBa0IsbURBQW1ELDJDQUEyQywwREFBMEQsMkNBQTJDLHdFQUF3RSx3QkFBd0IsbUNBQW1DLDRDQUE0QyxTQUFTLDBCQUEwQix1Q0FBdUMsRUFBRSxrQkFBa0IsNEJBQTRCLHdCQUF3QixNQUFNLDZDQUE2QyxxREFBcUQsNkJBQTZCLHVDQUF1Qyx3QkFBd0Isa0hBQWtILGtCQUFrQixJQUFJLGtCQUFrQixlQUFlLGtCQUFrQixJQUFJLGtCQUFrQixjQUFjLHdDQUF3QywyQ0FBMkMsZUFBZSxTQUFTLFNBQVMsU0FBUyxTQUFTLFNBQVMsT0FBTyxPQUFPLE9BQU8sT0FBTyxxQkFBcUIsVUFBVSxVQUFVLG9CQUFvQixzQkFBc0IsbUJBQW1CLFlBQVksSUFBSSxLQUFLLGdCQUFnQixPQUFPLE9BQU8sT0FBTyxnQkFBZ0IsZ0JBQWdCLFVBQVUseUNBQXlDLHlCQUF5Qix3QkFBd0IsSUFBSSxJQUFJLHNCQUFzQixhQUFhLHVCQUF1QixjQUFjLEtBQUssbUJBQW1CLGlCQUFpQixvQkFBb0IsZ0JBQWdCLGNBQWMsa0JBQWtCLGFBQWEsU0FBUyxjQUFjLHdCQUF3QixtQkFBbUIsdUJBQXVCLGlCQUFpQixTQUFTLCtCQUErQiw2QkFBNkIsUUFBUSxxREFBcUQsTUFBTSxnREFBZ0QsS0FBSyxxREFBcUQsaUNBQWlDLDREQUE0RCxpQ0FBaUMsUUFBUSxlQUFlLGVBQWUsa0JBQWtCLDBCQUEwQiwyREFBMkQsMkJBQTJCLFNBQVMsSUFBSSxLQUFLLEtBQUssTUFBTSxtQkFBbUIsVUFBVSxZQUFZLEtBQUssNEJBQTRCLE1BQU0sTUFBTSxTQUFTLFFBQVEsSUFBSSxLQUFLLHFDQUFxQyxjQUFjLHdCQUF3QixLQUFLLGlCQUFpQixPQUFPLEtBQUssZUFBZSxRQUFRLEtBQUssS0FBSyxXQUFXLFlBQVksSUFBSSxLQUFLLDRCQUE0QixRQUFRLE9BQU8sZUFBZSxTQUFTLG1EQUFtRCxpQ0FBaUMsaURBQWlELDhDQUE4Qyx5REFBeUQsK0NBQStDLDJCQUEyQixlQUFlLGlCQUFpQixPQUFPLElBQUksS0FBSyxZQUFZLFFBQVEsS0FBSyxlQUFlLFVBQVUsTUFBTSxZQUFZLElBQUksS0FBSyxtQ0FBbUMsMkJBQTJCLFNBQVMsU0FBUyw0QkFBNEIsbURBQW1ELDZCQUE2Qix5Q0FBeUMsOEJBQThCLDJCQUEyQiw4QkFBOEIsMENBQTBDLDRCQUE0QixzREFBc0QsK0NBQStDLGtCQUFrQixTQUFTLGNBQWMsSUFBSSw0Q0FBNEMsSUFBSSxjQUFjLElBQUkscUJBQXFCLFFBQVEsZ0JBQWdCLFFBQVEsMEJBQTBCLEtBQUssSUFBSSxhQUFhLEtBQUssMkZBQTJGLG9CQUFvQiwwQkFBMEIsMENBQTBDLCtEQUErRCxlQUFlLFlBQVksTUFBTSxFQUFFLFVBQVUsc0NBQXNDLG9EQUFvRCwwQ0FBMEMseURBQXlELDRDQUE0QyxpRkFBaUYseURBQXlELHVCQUF1QixVQUFVLDBDQUEwQyxPQUFPLG1FQUFtRSw0QkFBNEIsd0JBQXdCLDBCQUEwQixLQUFLLHNDQUFzQywwQkFBMEIsdUJBQXVCLFNBQVMsUUFBUSxXQUFXLFdBQVcsV0FBVyxnQ0FBZ0MsV0FBVyxZQUFZLFVBQVUsaUJBQWlCLElBQUksTUFBTSxnQkFBZ0Isa0JBQWtCLGlCQUFpQixVQUFVLEtBQUssTUFBTSxnQkFBZ0IsU0FBUyxpQ0FBaUMsNEJBQTRCLCtCQUErQixLQUFLLE1BQU0sZ0JBQWdCLFNBQVMsU0FBUyxnREFBZ0QsdUNBQXVDLHVCQUF1QixPQUFPLGFBQWEsUUFBUSxJQUFJLGlCQUFpQixTQUFTLDBCQUEwQixlQUFlLFVBQVUsS0FBSyxnQ0FBZ0MsV0FBVyxrQ0FBa0MsZUFBZSxTQUFTLDJDQUEyQyxTQUFTLFFBQVEsV0FBVyxxREFBcUQsU0FBUywyQkFBMkIsU0FBUyx1QkFBdUIsWUFBWSxJQUFJLEtBQUssaUNBQWlDLFNBQVMsNEJBQTRCLFNBQVMsdUJBQXVCLFlBQVksSUFBSSxLQUFLLDZCQUE2QixTQUFTLHlCQUF5QixlQUFlLGVBQWUsb0JBQW9CLFNBQVMsWUFBWSxJQUFJLEtBQUssV0FBVyxTQUFTLDZCQUE2QixtQkFBbUIsU0FBUyxZQUFZLFdBQVcsTUFBTSx3Q0FBd0MsU0FBUywyQ0FBMkMsa0JBQWtCLE1BQU0sc0JBQXNCLFFBQVEsS0FBSyxXQUFXLGFBQWEsSUFBSSxRQUFRLEtBQUssV0FBVyxhQUFhLElBQUksV0FBVyx5QkFBeUIsMENBQTBDLFVBQVUsNEJBQTRCLDJEQUEyRCx1RUFBdUUsdURBQXVELFFBQVEsUUFBUSxtQ0FBbUMsY0FBYyxRQUFRLFFBQVEsdUJBQXVCLGVBQWUsVUFBVSx1REFBdUQsUUFBUSxRQUFRLE9BQU8sNkJBQTZCLGtCQUFrQixRQUFRLHFCQUFxQixpQkFBaUIsVUFBVSxtREFBbUQsUUFBUSxtQ0FBbUMsZ0JBQWdCLHlEQUF5RCxRQUFRLG1DQUFtQyw2QkFBNkIseURBQXlELFFBQVEsbUNBQW1DLDZCQUE2Qix5REFBeUQsUUFBUSxtQ0FBbUMsK0RBQStELHlEQUF5RCxRQUFRLG1DQUFtQyxnRUFBZ0UscURBQXFELFFBQVEsUUFBUSxtQ0FBbUMsY0FBYyxRQUFRLFFBQVEsdUJBQXVCLGVBQWUsT0FBTywyQkFBMkIsVUFBVSxxREFBcUQsUUFBUSxRQUFRLG1DQUFtQyxRQUFRLFFBQVEsa0JBQWtCLHFCQUFxQixpQkFBaUIsT0FBTywyQkFBMkIsVUFBVSxpREFBaUQsUUFBUSxtQ0FBbUMsaUNBQWlDLDBCQUEwQix1REFBdUQsUUFBUSxtQ0FBbUMsMkJBQTJCLCtCQUErQix1REFBdUQsUUFBUSxtQ0FBbUMsMkJBQTJCLCtCQUErQix1REFBdUQsUUFBUSxtQ0FBbUMseURBQXlELHVEQUF1RCxRQUFRLG1DQUFtQyx5REFBeUQsdURBQXVELFFBQVEsbUNBQW1DLGlDQUFpQyx1REFBdUQsUUFBUSxtQ0FBbUMsa0NBQWtDLHlEQUF5RCxRQUFRLG1DQUFtQyxpQ0FBaUMseURBQXlELFFBQVEsbUNBQW1DLGtDQUFrQywrQkFBK0IsMEZBQTBGLHNFQUFzRSwyREFBMkQsMkRBQTJELEtBQUssUUFBUSxRQUFRLE9BQU8sd0JBQXdCLHlCQUF5QixRQUFRLFFBQVEsY0FBYyx1QkFBdUIsa0JBQWtCLFlBQVksMkRBQTJELEtBQUssUUFBUSxRQUFRLE9BQU8sd0JBQXdCLHlCQUF5QixVQUFVLFFBQVEsZ0JBQWdCLHdCQUF3QixrQkFBa0IsWUFBWSx1REFBdUQsS0FBSyxRQUFRLGlDQUFpQyxjQUFjLFlBQVksNkRBQTZELEtBQUssUUFBUSxtQ0FBbUMsY0FBYyxnQkFBZ0IsWUFBWSw2REFBNkQsS0FBSyxRQUFRLG1DQUFtQyxjQUFjLGdCQUFnQixZQUFZLDZEQUE2RCxLQUFLLFFBQVEsd0NBQXdDLGlCQUFpQixpQkFBaUIsZ0JBQWdCLGNBQWMsWUFBWSw2REFBNkQsS0FBSyxRQUFRLHdDQUF3QyxlQUFlLGlCQUFpQixnQkFBZ0IsZ0JBQWdCLFlBQVkseURBQXlELEtBQUssUUFBUSxPQUFPLHdCQUF3Qiw0QkFBNEIsUUFBUSxRQUFRLFFBQVEsY0FBYyx1QkFBdUIsZ0NBQWdDLElBQUkseUJBQXlCLFlBQVkseURBQXlELEtBQUssUUFBUSxPQUFPLHdCQUF3Qiw0QkFBNEIsVUFBVSxRQUFRLFFBQVEsZ0JBQWdCLHdCQUF3QixnQ0FBZ0MsSUFBSSx5QkFBeUIsWUFBWSxxREFBcUQsS0FBSyxRQUFRLG9DQUFvQyxpQkFBaUIsY0FBYyxZQUFZLDJEQUEyRCxLQUFLLFFBQVEsd0NBQXdDLGNBQWMsZ0JBQWdCLFlBQVksMkRBQTJELEtBQUssUUFBUSx3Q0FBd0MsY0FBYyxnQkFBZ0IsWUFBWSwyREFBMkQsS0FBSyxRQUFRLGtEQUFrRCxjQUFjLGdCQUFnQixpQkFBaUIsaUJBQWlCLFlBQVksMkRBQTJELEtBQUssUUFBUSxrREFBa0Qsd0JBQXdCLGVBQWUsaUJBQWlCLGdCQUFnQixnQkFBZ0IsWUFBWSxtQ0FBbUMsMkRBQTJELGtEQUFrRCwrQkFBK0IsS0FBSyxRQUFRLE9BQU8saUVBQWlFLHNCQUFzQixXQUFXLDJEQUEyRCxvQ0FBb0MsMkRBQTJELHFDQUFxQyxnQ0FBZ0MsS0FBSyxRQUFRLE9BQU8sbUVBQW1FLHNCQUFzQixXQUFXLDZEQUE2RCxxQ0FBcUMsNkRBQTZELHNDQUFzQyw2Q0FBNkMsMEVBQTBFLFVBQVUsMkJBQTJCLDBCQUEwQixVQUFVLGdCQUFnQixrQkFBa0IsMENBQTBDLFFBQVEsa0RBQWtELGtFQUFrRSx1REFBdUQsK0JBQStCLG1CQUFtQixlQUFlLFVBQVUsa0VBQWtFLHVCQUF1Qiw0QkFBNEIsY0FBYyxLQUFLLEtBQUssa0JBQWtCLEtBQUssc0RBQXNELFVBQVUsNkNBQTZDLHdCQUF3Qix3QkFBd0IsSUFBSSxJQUFJLGNBQWMsNkJBQTZCLElBQUksY0FBYyx1Q0FBdUMsaURBQWlELCtDQUErQyw0Q0FBNEMsaUJBQWlCLHNCQUFzQixvQ0FBb0MsTUFBTSw2QkFBNkIsUUFBUSw4QkFBOEIsWUFBWSxzQ0FBc0MsMkNBQTJDLFNBQVMsWUFBWSxRQUFRLGtDQUFrQyxVQUFVLE1BQU0sd0JBQXdCLFFBQVEsSUFBSSxLQUFLLFdBQVcsS0FBSyw0Q0FBNEMsZUFBZSxVQUFVLHlFQUF5RSxRQUFRLE1BQU0sS0FBSyxrQkFBa0IsYUFBYSwwQkFBMEIsd0JBQXdCLGtCQUFrQix5QkFBeUIsdUJBQXVCLHNCQUFzQixRQUFRLFNBQVMsMEJBQTBCLGNBQWMsTUFBTSxlQUFlLFdBQVcsU0FBUyxZQUFZLElBQUksS0FBSyxrQkFBa0IscUJBQXFCLE9BQU8sWUFBWSxpQ0FBaUMsU0FBUyxpQkFBaUIsaUNBQWlDLFNBQVMsSUFBSSxTQUFTLFlBQVksaUNBQWlDLElBQUksU0FBUyw4QkFBOEIsV0FBVyxpQ0FBaUMsT0FBTyxVQUFVLGtCQUFrQixVQUFVLGdCQUFnQixrQkFBa0IsMEJBQTBCLGlCQUFpQixrQkFBa0IsdUNBQXVDLG1CQUFtQixrQkFBa0Isb0RBQW9ELEtBQUssdUNBQXVDLFNBQVMseUJBQXlCLFNBQVMsWUFBWSxXQUFXLEtBQUssNEJBQTRCLFNBQVMsNkJBQTZCLFVBQVUsU0FBUyxZQUFZLFdBQVcsS0FBSyxrQkFBa0Isa0JBQWtCLE9BQU8sUUFBUSxVQUFVLFVBQVUsU0FBUywwQkFBMEIscUNBQXFDLDZCQUE2QixZQUFZLElBQUksS0FBSyxvQ0FBb0MsWUFBWSxTQUFTLHlCQUF5QiwyR0FBMkcsd0JBQXdCLGFBQWEsaUJBQWlCLHlCQUF5QixxQkFBcUIsWUFBWSxLQUFLLEtBQUssV0FBVyxZQUFZLEtBQUssS0FBSyxrQkFBa0IsU0FBUyxHQUFHO0FBQ3p4dkI7QUFDQSwyQkFBMkIsUUFBUSxjQUFjLGVBQWUsV0FBVyxTQUFTLGNBQWMsYUFBYSxhQUFhLEtBQUssY0FBYyxPQUFPLEtBQUssS0FBSyxJQUFJLDJCQUEyQixjQUFjLE9BQU8sS0FBSyxLQUFLLElBQUksMkJBQTJCLFVBQVUsTUFBTSxlQUFlLCtCQUErQixLQUFLLGtCQUFrQixNQUFNLGtDQUFrQyw4QkFBOEIsVUFBVSxjQUFjLGVBQWUsV0FBVywrQ0FBK0MsY0FBYyxhQUFhLDRCQUE0QixjQUFjLDJCQUEyQixlQUFlLElBQUksS0FBSyxtQ0FBbUMsMkJBQTJCLElBQUksS0FBSyxXQUFXLE9BQU8sS0FBSyxxQkFBcUIsV0FBVyxJQUFJLEtBQUssV0FBVyxJQUFJLElBQUksZ0JBQWdCLHdCQUF3QixNQUFNLEtBQUssa0NBQWtDLEtBQUssS0FBSyxLQUFLLGdDQUFnQyxTQUFTLEtBQUssS0FBSyxJQUFJLGdDQUFnQyxtQkFBbUIsU0FBUyxnQ0FBZ0MsV0FBVyxrQkFBa0IsaUJBQWlCLFlBQVksWUFBWSxXQUFXLElBQUksc0NBQXNDLFFBQVEsUUFBUSxpQkFBaUIsaUJBQWlCLG1FQUFtRSxTQUFTLEtBQUssOEJBQThCLGlCQUFpQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL2J1ZmZlci9pbmRleC5qcz8wOWNjIl0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe3ZhciBlPXs2NzU6ZnVuY3Rpb24oZSxyKXtcInVzZSBzdHJpY3RcIjtyLmJ5dGVMZW5ndGg9Ynl0ZUxlbmd0aDtyLnRvQnl0ZUFycmF5PXRvQnl0ZUFycmF5O3IuZnJvbUJ5dGVBcnJheT1mcm9tQnl0ZUFycmF5O3ZhciB0PVtdO3ZhciBmPVtdO3ZhciBuPXR5cGVvZiBVaW50OEFycmF5IT09XCJ1bmRlZmluZWRcIj9VaW50OEFycmF5OkFycmF5O3ZhciBpPVwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrL1wiO2Zvcih2YXIgbz0wLHU9aS5sZW5ndGg7bzx1Oysrbyl7dFtvXT1pW29dO2ZbaS5jaGFyQ29kZUF0KG8pXT1vfWZbXCItXCIuY2hhckNvZGVBdCgwKV09NjI7ZltcIl9cIi5jaGFyQ29kZUF0KDApXT02MztmdW5jdGlvbiBnZXRMZW5zKGUpe3ZhciByPWUubGVuZ3RoO2lmKHIlND4wKXt0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHN0cmluZy4gTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0XCIpfXZhciB0PWUuaW5kZXhPZihcIj1cIik7aWYodD09PS0xKXQ9cjt2YXIgZj10PT09cj8wOjQtdCU0O3JldHVyblt0LGZdfWZ1bmN0aW9uIGJ5dGVMZW5ndGgoZSl7dmFyIHI9Z2V0TGVucyhlKTt2YXIgdD1yWzBdO3ZhciBmPXJbMV07cmV0dXJuKHQrZikqMy80LWZ9ZnVuY3Rpb24gX2J5dGVMZW5ndGgoZSxyLHQpe3JldHVybihyK3QpKjMvNC10fWZ1bmN0aW9uIHRvQnl0ZUFycmF5KGUpe3ZhciByO3ZhciB0PWdldExlbnMoZSk7dmFyIGk9dFswXTt2YXIgbz10WzFdO3ZhciB1PW5ldyBuKF9ieXRlTGVuZ3RoKGUsaSxvKSk7dmFyIGE9MDt2YXIgcz1vPjA/aS00Omk7dmFyIGg7Zm9yKGg9MDtoPHM7aCs9NCl7cj1mW2UuY2hhckNvZGVBdChoKV08PDE4fGZbZS5jaGFyQ29kZUF0KGgrMSldPDwxMnxmW2UuY2hhckNvZGVBdChoKzIpXTw8NnxmW2UuY2hhckNvZGVBdChoKzMpXTt1W2ErK109cj4+MTYmMjU1O3VbYSsrXT1yPj44JjI1NTt1W2ErK109ciYyNTV9aWYobz09PTIpe3I9ZltlLmNoYXJDb2RlQXQoaCldPDwyfGZbZS5jaGFyQ29kZUF0KGgrMSldPj40O3VbYSsrXT1yJjI1NX1pZihvPT09MSl7cj1mW2UuY2hhckNvZGVBdChoKV08PDEwfGZbZS5jaGFyQ29kZUF0KGgrMSldPDw0fGZbZS5jaGFyQ29kZUF0KGgrMildPj4yO3VbYSsrXT1yPj44JjI1NTt1W2ErK109ciYyNTV9cmV0dXJuIHV9ZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0KGUpe3JldHVybiB0W2U+PjE4JjYzXSt0W2U+PjEyJjYzXSt0W2U+PjYmNjNdK3RbZSY2M119ZnVuY3Rpb24gZW5jb2RlQ2h1bmsoZSxyLHQpe3ZhciBmO3ZhciBuPVtdO2Zvcih2YXIgaT1yO2k8dDtpKz0zKXtmPShlW2ldPDwxNiYxNjcxMTY4MCkrKGVbaSsxXTw8OCY2NTI4MCkrKGVbaSsyXSYyNTUpO24ucHVzaCh0cmlwbGV0VG9CYXNlNjQoZikpfXJldHVybiBuLmpvaW4oXCJcIil9ZnVuY3Rpb24gZnJvbUJ5dGVBcnJheShlKXt2YXIgcjt2YXIgZj1lLmxlbmd0aDt2YXIgbj1mJTM7dmFyIGk9W107dmFyIG89MTYzODM7Zm9yKHZhciB1PTAsYT1mLW47dTxhO3UrPW8pe2kucHVzaChlbmNvZGVDaHVuayhlLHUsdStvPmE/YTp1K28pKX1pZihuPT09MSl7cj1lW2YtMV07aS5wdXNoKHRbcj4+Ml0rdFtyPDw0JjYzXStcIj09XCIpfWVsc2UgaWYobj09PTIpe3I9KGVbZi0yXTw8OCkrZVtmLTFdO2kucHVzaCh0W3I+PjEwXSt0W3I+PjQmNjNdK3Rbcjw8MiY2M10rXCI9XCIpfXJldHVybiBpLmpvaW4oXCJcIil9fSw3MjpmdW5jdGlvbihlLHIsdCl7XCJ1c2Ugc3RyaWN0XCI7XG4vKiFcbiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLlxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi92YXIgZj10KDY3NSk7dmFyIG49dCg3ODMpO3ZhciBpPXR5cGVvZiBTeW1ib2w9PT1cImZ1bmN0aW9uXCImJnR5cGVvZiBTeW1ib2wuZm9yPT09XCJmdW5jdGlvblwiP1N5bWJvbC5mb3IoXCJub2RlanMudXRpbC5pbnNwZWN0LmN1c3RvbVwiKTpudWxsO3IuQnVmZmVyPUJ1ZmZlcjtyLlNsb3dCdWZmZXI9U2xvd0J1ZmZlcjtyLklOU1BFQ1RfTUFYX0JZVEVTPTUwO3ZhciBvPTIxNDc0ODM2NDc7ci5rTWF4TGVuZ3RoPW87QnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQ9dHlwZWRBcnJheVN1cHBvcnQoKTtpZighQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQmJnR5cGVvZiBjb25zb2xlIT09XCJ1bmRlZmluZWRcIiYmdHlwZW9mIGNvbnNvbGUuZXJyb3I9PT1cImZ1bmN0aW9uXCIpe2NvbnNvbGUuZXJyb3IoXCJUaGlzIGJyb3dzZXIgbGFja3MgdHlwZWQgYXJyYXkgKFVpbnQ4QXJyYXkpIHN1cHBvcnQgd2hpY2ggaXMgcmVxdWlyZWQgYnkgXCIrXCJgYnVmZmVyYCB2NS54LiBVc2UgYGJ1ZmZlcmAgdjQueCBpZiB5b3UgcmVxdWlyZSBvbGQgYnJvd3NlciBzdXBwb3J0LlwiKX1mdW5jdGlvbiB0eXBlZEFycmF5U3VwcG9ydCgpe3RyeXt2YXIgZT1uZXcgVWludDhBcnJheSgxKTt2YXIgcj17Zm9vOmZ1bmN0aW9uKCl7cmV0dXJuIDQyfX07T2JqZWN0LnNldFByb3RvdHlwZU9mKHIsVWludDhBcnJheS5wcm90b3R5cGUpO09iamVjdC5zZXRQcm90b3R5cGVPZihlLHIpO3JldHVybiBlLmZvbygpPT09NDJ9Y2F0Y2goZSl7cmV0dXJuIGZhbHNlfX1PYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLnByb3RvdHlwZSxcInBhcmVudFwiLHtlbnVtZXJhYmxlOnRydWUsZ2V0OmZ1bmN0aW9uKCl7aWYoIUJ1ZmZlci5pc0J1ZmZlcih0aGlzKSlyZXR1cm4gdW5kZWZpbmVkO3JldHVybiB0aGlzLmJ1ZmZlcn19KTtPYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLnByb3RvdHlwZSxcIm9mZnNldFwiLHtlbnVtZXJhYmxlOnRydWUsZ2V0OmZ1bmN0aW9uKCl7aWYoIUJ1ZmZlci5pc0J1ZmZlcih0aGlzKSlyZXR1cm4gdW5kZWZpbmVkO3JldHVybiB0aGlzLmJ5dGVPZmZzZXR9fSk7ZnVuY3Rpb24gY3JlYXRlQnVmZmVyKGUpe2lmKGU+byl7dGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBcIicrZSsnXCIgaXMgaW52YWxpZCBmb3Igb3B0aW9uIFwic2l6ZVwiJyl9dmFyIHI9bmV3IFVpbnQ4QXJyYXkoZSk7T2JqZWN0LnNldFByb3RvdHlwZU9mKHIsQnVmZmVyLnByb3RvdHlwZSk7cmV0dXJuIHJ9ZnVuY3Rpb24gQnVmZmVyKGUscix0KXtpZih0eXBlb2YgZT09PVwibnVtYmVyXCIpe2lmKHR5cGVvZiByPT09XCJzdHJpbmdcIil7dGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwic3RyaW5nXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIHN0cmluZy4gUmVjZWl2ZWQgdHlwZSBudW1iZXInKX1yZXR1cm4gYWxsb2NVbnNhZmUoZSl9cmV0dXJuIGZyb20oZSxyLHQpfUJ1ZmZlci5wb29sU2l6ZT04MTkyO2Z1bmN0aW9uIGZyb20oZSxyLHQpe2lmKHR5cGVvZiBlPT09XCJzdHJpbmdcIil7cmV0dXJuIGZyb21TdHJpbmcoZSxyKX1pZihBcnJheUJ1ZmZlci5pc1ZpZXcoZSkpe3JldHVybiBmcm9tQXJyYXlMaWtlKGUpfWlmKGU9PW51bGwpe3Rocm93IG5ldyBUeXBlRXJyb3IoXCJUaGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCBcIitcIm9yIEFycmF5LWxpa2UgT2JqZWN0LiBSZWNlaXZlZCB0eXBlIFwiK3R5cGVvZiBlKX1pZihpc0luc3RhbmNlKGUsQXJyYXlCdWZmZXIpfHxlJiZpc0luc3RhbmNlKGUuYnVmZmVyLEFycmF5QnVmZmVyKSl7cmV0dXJuIGZyb21BcnJheUJ1ZmZlcihlLHIsdCl9aWYodHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyIT09XCJ1bmRlZmluZWRcIiYmKGlzSW5zdGFuY2UoZSxTaGFyZWRBcnJheUJ1ZmZlcil8fGUmJmlzSW5zdGFuY2UoZS5idWZmZXIsU2hhcmVkQXJyYXlCdWZmZXIpKSl7cmV0dXJuIGZyb21BcnJheUJ1ZmZlcihlLHIsdCl9aWYodHlwZW9mIGU9PT1cIm51bWJlclwiKXt0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJ2YWx1ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIG9mIHR5cGUgbnVtYmVyLiBSZWNlaXZlZCB0eXBlIG51bWJlcicpfXZhciBmPWUudmFsdWVPZiYmZS52YWx1ZU9mKCk7aWYoZiE9bnVsbCYmZiE9PWUpe3JldHVybiBCdWZmZXIuZnJvbShmLHIsdCl9dmFyIG49ZnJvbU9iamVjdChlKTtpZihuKXJldHVybiBuO2lmKHR5cGVvZiBTeW1ib2whPT1cInVuZGVmaW5lZFwiJiZTeW1ib2wudG9QcmltaXRpdmUhPW51bGwmJnR5cGVvZiBlW1N5bWJvbC50b1ByaW1pdGl2ZV09PT1cImZ1bmN0aW9uXCIpe3JldHVybiBCdWZmZXIuZnJvbShlW1N5bWJvbC50b1ByaW1pdGl2ZV0oXCJzdHJpbmdcIikscix0KX10aHJvdyBuZXcgVHlwZUVycm9yKFwiVGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgXCIrXCJvciBBcnJheS1saWtlIE9iamVjdC4gUmVjZWl2ZWQgdHlwZSBcIit0eXBlb2YgZSl9QnVmZmVyLmZyb209ZnVuY3Rpb24oZSxyLHQpe3JldHVybiBmcm9tKGUscix0KX07T2JqZWN0LnNldFByb3RvdHlwZU9mKEJ1ZmZlci5wcm90b3R5cGUsVWludDhBcnJheS5wcm90b3R5cGUpO09iamVjdC5zZXRQcm90b3R5cGVPZihCdWZmZXIsVWludDhBcnJheSk7ZnVuY3Rpb24gYXNzZXJ0U2l6ZShlKXtpZih0eXBlb2YgZSE9PVwibnVtYmVyXCIpe3Rocm93IG5ldyBUeXBlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBudW1iZXInKX1lbHNlIGlmKGU8MCl7dGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBcIicrZSsnXCIgaXMgaW52YWxpZCBmb3Igb3B0aW9uIFwic2l6ZVwiJyl9fWZ1bmN0aW9uIGFsbG9jKGUscix0KXthc3NlcnRTaXplKGUpO2lmKGU8PTApe3JldHVybiBjcmVhdGVCdWZmZXIoZSl9aWYociE9PXVuZGVmaW5lZCl7cmV0dXJuIHR5cGVvZiB0PT09XCJzdHJpbmdcIj9jcmVhdGVCdWZmZXIoZSkuZmlsbChyLHQpOmNyZWF0ZUJ1ZmZlcihlKS5maWxsKHIpfXJldHVybiBjcmVhdGVCdWZmZXIoZSl9QnVmZmVyLmFsbG9jPWZ1bmN0aW9uKGUscix0KXtyZXR1cm4gYWxsb2MoZSxyLHQpfTtmdW5jdGlvbiBhbGxvY1Vuc2FmZShlKXthc3NlcnRTaXplKGUpO3JldHVybiBjcmVhdGVCdWZmZXIoZTwwPzA6Y2hlY2tlZChlKXwwKX1CdWZmZXIuYWxsb2NVbnNhZmU9ZnVuY3Rpb24oZSl7cmV0dXJuIGFsbG9jVW5zYWZlKGUpfTtCdWZmZXIuYWxsb2NVbnNhZmVTbG93PWZ1bmN0aW9uKGUpe3JldHVybiBhbGxvY1Vuc2FmZShlKX07ZnVuY3Rpb24gZnJvbVN0cmluZyhlLHIpe2lmKHR5cGVvZiByIT09XCJzdHJpbmdcInx8cj09PVwiXCIpe3I9XCJ1dGY4XCJ9aWYoIUJ1ZmZlci5pc0VuY29kaW5nKHIpKXt0aHJvdyBuZXcgVHlwZUVycm9yKFwiVW5rbm93biBlbmNvZGluZzogXCIrcil9dmFyIHQ9Ynl0ZUxlbmd0aChlLHIpfDA7dmFyIGY9Y3JlYXRlQnVmZmVyKHQpO3ZhciBuPWYud3JpdGUoZSxyKTtpZihuIT09dCl7Zj1mLnNsaWNlKDAsbil9cmV0dXJuIGZ9ZnVuY3Rpb24gZnJvbUFycmF5TGlrZShlKXt2YXIgcj1lLmxlbmd0aDwwPzA6Y2hlY2tlZChlLmxlbmd0aCl8MDt2YXIgdD1jcmVhdGVCdWZmZXIocik7Zm9yKHZhciBmPTA7ZjxyO2YrPTEpe3RbZl09ZVtmXSYyNTV9cmV0dXJuIHR9ZnVuY3Rpb24gZnJvbUFycmF5QnVmZmVyKGUscix0KXtpZihyPDB8fGUuYnl0ZUxlbmd0aDxyKXt0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJvZmZzZXRcIiBpcyBvdXRzaWRlIG9mIGJ1ZmZlciBib3VuZHMnKX1pZihlLmJ5dGVMZW5ndGg8cisodHx8MCkpe3Rocm93IG5ldyBSYW5nZUVycm9yKCdcImxlbmd0aFwiIGlzIG91dHNpZGUgb2YgYnVmZmVyIGJvdW5kcycpfXZhciBmO2lmKHI9PT11bmRlZmluZWQmJnQ9PT11bmRlZmluZWQpe2Y9bmV3IFVpbnQ4QXJyYXkoZSl9ZWxzZSBpZih0PT09dW5kZWZpbmVkKXtmPW5ldyBVaW50OEFycmF5KGUscil9ZWxzZXtmPW5ldyBVaW50OEFycmF5KGUscix0KX1PYmplY3Quc2V0UHJvdG90eXBlT2YoZixCdWZmZXIucHJvdG90eXBlKTtyZXR1cm4gZn1mdW5jdGlvbiBmcm9tT2JqZWN0KGUpe2lmKEJ1ZmZlci5pc0J1ZmZlcihlKSl7dmFyIHI9Y2hlY2tlZChlLmxlbmd0aCl8MDt2YXIgdD1jcmVhdGVCdWZmZXIocik7aWYodC5sZW5ndGg9PT0wKXtyZXR1cm4gdH1lLmNvcHkodCwwLDAscik7cmV0dXJuIHR9aWYoZS5sZW5ndGghPT11bmRlZmluZWQpe2lmKHR5cGVvZiBlLmxlbmd0aCE9PVwibnVtYmVyXCJ8fG51bWJlcklzTmFOKGUubGVuZ3RoKSl7cmV0dXJuIGNyZWF0ZUJ1ZmZlcigwKX1yZXR1cm4gZnJvbUFycmF5TGlrZShlKX1pZihlLnR5cGU9PT1cIkJ1ZmZlclwiJiZBcnJheS5pc0FycmF5KGUuZGF0YSkpe3JldHVybiBmcm9tQXJyYXlMaWtlKGUuZGF0YSl9fWZ1bmN0aW9uIGNoZWNrZWQoZSl7aWYoZT49byl7dGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJBdHRlbXB0IHRvIGFsbG9jYXRlIEJ1ZmZlciBsYXJnZXIgdGhhbiBtYXhpbXVtIFwiK1wic2l6ZTogMHhcIitvLnRvU3RyaW5nKDE2KStcIiBieXRlc1wiKX1yZXR1cm4gZXwwfWZ1bmN0aW9uIFNsb3dCdWZmZXIoZSl7aWYoK2UhPWUpe2U9MH1yZXR1cm4gQnVmZmVyLmFsbG9jKCtlKX1CdWZmZXIuaXNCdWZmZXI9ZnVuY3Rpb24gaXNCdWZmZXIoZSl7cmV0dXJuIGUhPW51bGwmJmUuX2lzQnVmZmVyPT09dHJ1ZSYmZSE9PUJ1ZmZlci5wcm90b3R5cGV9O0J1ZmZlci5jb21wYXJlPWZ1bmN0aW9uIGNvbXBhcmUoZSxyKXtpZihpc0luc3RhbmNlKGUsVWludDhBcnJheSkpZT1CdWZmZXIuZnJvbShlLGUub2Zmc2V0LGUuYnl0ZUxlbmd0aCk7aWYoaXNJbnN0YW5jZShyLFVpbnQ4QXJyYXkpKXI9QnVmZmVyLmZyb20ocixyLm9mZnNldCxyLmJ5dGVMZW5ndGgpO2lmKCFCdWZmZXIuaXNCdWZmZXIoZSl8fCFCdWZmZXIuaXNCdWZmZXIocikpe3Rocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcImJ1ZjFcIiwgXCJidWYyXCIgYXJndW1lbnRzIG11c3QgYmUgb25lIG9mIHR5cGUgQnVmZmVyIG9yIFVpbnQ4QXJyYXknKX1pZihlPT09cilyZXR1cm4gMDt2YXIgdD1lLmxlbmd0aDt2YXIgZj1yLmxlbmd0aDtmb3IodmFyIG49MCxpPU1hdGgubWluKHQsZik7bjxpOysrbil7aWYoZVtuXSE9PXJbbl0pe3Q9ZVtuXTtmPXJbbl07YnJlYWt9fWlmKHQ8ZilyZXR1cm4tMTtpZihmPHQpcmV0dXJuIDE7cmV0dXJuIDB9O0J1ZmZlci5pc0VuY29kaW5nPWZ1bmN0aW9uIGlzRW5jb2RpbmcoZSl7c3dpdGNoKFN0cmluZyhlKS50b0xvd2VyQ2FzZSgpKXtjYXNlXCJoZXhcIjpjYXNlXCJ1dGY4XCI6Y2FzZVwidXRmLThcIjpjYXNlXCJhc2NpaVwiOmNhc2VcImxhdGluMVwiOmNhc2VcImJpbmFyeVwiOmNhc2VcImJhc2U2NFwiOmNhc2VcInVjczJcIjpjYXNlXCJ1Y3MtMlwiOmNhc2VcInV0ZjE2bGVcIjpjYXNlXCJ1dGYtMTZsZVwiOnJldHVybiB0cnVlO2RlZmF1bHQ6cmV0dXJuIGZhbHNlfX07QnVmZmVyLmNvbmNhdD1mdW5jdGlvbiBjb25jYXQoZSxyKXtpZighQXJyYXkuaXNBcnJheShlKSl7dGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJyl9aWYoZS5sZW5ndGg9PT0wKXtyZXR1cm4gQnVmZmVyLmFsbG9jKDApfXZhciB0O2lmKHI9PT11bmRlZmluZWQpe3I9MDtmb3IodD0wO3Q8ZS5sZW5ndGg7Kyt0KXtyKz1lW3RdLmxlbmd0aH19dmFyIGY9QnVmZmVyLmFsbG9jVW5zYWZlKHIpO3ZhciBuPTA7Zm9yKHQ9MDt0PGUubGVuZ3RoOysrdCl7dmFyIGk9ZVt0XTtpZihpc0luc3RhbmNlKGksVWludDhBcnJheSkpe2k9QnVmZmVyLmZyb20oaSl9aWYoIUJ1ZmZlci5pc0J1ZmZlcihpKSl7dGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJyl9aS5jb3B5KGYsbik7bis9aS5sZW5ndGh9cmV0dXJuIGZ9O2Z1bmN0aW9uIGJ5dGVMZW5ndGgoZSxyKXtpZihCdWZmZXIuaXNCdWZmZXIoZSkpe3JldHVybiBlLmxlbmd0aH1pZihBcnJheUJ1ZmZlci5pc1ZpZXcoZSl8fGlzSW5zdGFuY2UoZSxBcnJheUJ1ZmZlcikpe3JldHVybiBlLmJ5dGVMZW5ndGh9aWYodHlwZW9mIGUhPT1cInN0cmluZ1wiKXt0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJzdHJpbmdcIiBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIHN0cmluZywgQnVmZmVyLCBvciBBcnJheUJ1ZmZlci4gJytcIlJlY2VpdmVkIHR5cGUgXCIrdHlwZW9mIGUpfXZhciB0PWUubGVuZ3RoO3ZhciBmPWFyZ3VtZW50cy5sZW5ndGg+MiYmYXJndW1lbnRzWzJdPT09dHJ1ZTtpZighZiYmdD09PTApcmV0dXJuIDA7dmFyIG49ZmFsc2U7Zm9yKDs7KXtzd2l0Y2gocil7Y2FzZVwiYXNjaWlcIjpjYXNlXCJsYXRpbjFcIjpjYXNlXCJiaW5hcnlcIjpyZXR1cm4gdDtjYXNlXCJ1dGY4XCI6Y2FzZVwidXRmLThcIjpyZXR1cm4gdXRmOFRvQnl0ZXMoZSkubGVuZ3RoO2Nhc2VcInVjczJcIjpjYXNlXCJ1Y3MtMlwiOmNhc2VcInV0ZjE2bGVcIjpjYXNlXCJ1dGYtMTZsZVwiOnJldHVybiB0KjI7Y2FzZVwiaGV4XCI6cmV0dXJuIHQ+Pj4xO2Nhc2VcImJhc2U2NFwiOnJldHVybiBiYXNlNjRUb0J5dGVzKGUpLmxlbmd0aDtkZWZhdWx0OmlmKG4pe3JldHVybiBmPy0xOnV0ZjhUb0J5dGVzKGUpLmxlbmd0aH1yPShcIlwiK3IpLnRvTG93ZXJDYXNlKCk7bj10cnVlfX19QnVmZmVyLmJ5dGVMZW5ndGg9Ynl0ZUxlbmd0aDtmdW5jdGlvbiBzbG93VG9TdHJpbmcoZSxyLHQpe3ZhciBmPWZhbHNlO2lmKHI9PT11bmRlZmluZWR8fHI8MCl7cj0wfWlmKHI+dGhpcy5sZW5ndGgpe3JldHVyblwiXCJ9aWYodD09PXVuZGVmaW5lZHx8dD50aGlzLmxlbmd0aCl7dD10aGlzLmxlbmd0aH1pZih0PD0wKXtyZXR1cm5cIlwifXQ+Pj49MDtyPj4+PTA7aWYodDw9cil7cmV0dXJuXCJcIn1pZighZSllPVwidXRmOFwiO3doaWxlKHRydWUpe3N3aXRjaChlKXtjYXNlXCJoZXhcIjpyZXR1cm4gaGV4U2xpY2UodGhpcyxyLHQpO2Nhc2VcInV0ZjhcIjpjYXNlXCJ1dGYtOFwiOnJldHVybiB1dGY4U2xpY2UodGhpcyxyLHQpO2Nhc2VcImFzY2lpXCI6cmV0dXJuIGFzY2lpU2xpY2UodGhpcyxyLHQpO2Nhc2VcImxhdGluMVwiOmNhc2VcImJpbmFyeVwiOnJldHVybiBsYXRpbjFTbGljZSh0aGlzLHIsdCk7Y2FzZVwiYmFzZTY0XCI6cmV0dXJuIGJhc2U2NFNsaWNlKHRoaXMscix0KTtjYXNlXCJ1Y3MyXCI6Y2FzZVwidWNzLTJcIjpjYXNlXCJ1dGYxNmxlXCI6Y2FzZVwidXRmLTE2bGVcIjpyZXR1cm4gdXRmMTZsZVNsaWNlKHRoaXMscix0KTtkZWZhdWx0OmlmKGYpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlVua25vd24gZW5jb2Rpbmc6IFwiK2UpO2U9KGUrXCJcIikudG9Mb3dlckNhc2UoKTtmPXRydWV9fX1CdWZmZXIucHJvdG90eXBlLl9pc0J1ZmZlcj10cnVlO2Z1bmN0aW9uIHN3YXAoZSxyLHQpe3ZhciBmPWVbcl07ZVtyXT1lW3RdO2VbdF09Zn1CdWZmZXIucHJvdG90eXBlLnN3YXAxNj1mdW5jdGlvbiBzd2FwMTYoKXt2YXIgZT10aGlzLmxlbmd0aDtpZihlJTIhPT0wKXt0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkJ1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAxNi1iaXRzXCIpfWZvcih2YXIgcj0wO3I8ZTtyKz0yKXtzd2FwKHRoaXMscixyKzEpfXJldHVybiB0aGlzfTtCdWZmZXIucHJvdG90eXBlLnN3YXAzMj1mdW5jdGlvbiBzd2FwMzIoKXt2YXIgZT10aGlzLmxlbmd0aDtpZihlJTQhPT0wKXt0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkJ1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAzMi1iaXRzXCIpfWZvcih2YXIgcj0wO3I8ZTtyKz00KXtzd2FwKHRoaXMscixyKzMpO3N3YXAodGhpcyxyKzEscisyKX1yZXR1cm4gdGhpc307QnVmZmVyLnByb3RvdHlwZS5zd2FwNjQ9ZnVuY3Rpb24gc3dhcDY0KCl7dmFyIGU9dGhpcy5sZW5ndGg7aWYoZSU4IT09MCl7dGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNjQtYml0c1wiKX1mb3IodmFyIHI9MDtyPGU7cis9OCl7c3dhcCh0aGlzLHIscis3KTtzd2FwKHRoaXMscisxLHIrNik7c3dhcCh0aGlzLHIrMixyKzUpO3N3YXAodGhpcyxyKzMscis0KX1yZXR1cm4gdGhpc307QnVmZmVyLnByb3RvdHlwZS50b1N0cmluZz1mdW5jdGlvbiB0b1N0cmluZygpe3ZhciBlPXRoaXMubGVuZ3RoO2lmKGU9PT0wKXJldHVyblwiXCI7aWYoYXJndW1lbnRzLmxlbmd0aD09PTApcmV0dXJuIHV0ZjhTbGljZSh0aGlzLDAsZSk7cmV0dXJuIHNsb3dUb1N0cmluZy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9O0J1ZmZlci5wcm90b3R5cGUudG9Mb2NhbGVTdHJpbmc9QnVmZmVyLnByb3RvdHlwZS50b1N0cmluZztCdWZmZXIucHJvdG90eXBlLmVxdWFscz1mdW5jdGlvbiBlcXVhbHMoZSl7aWYoIUJ1ZmZlci5pc0J1ZmZlcihlKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlclwiKTtpZih0aGlzPT09ZSlyZXR1cm4gdHJ1ZTtyZXR1cm4gQnVmZmVyLmNvbXBhcmUodGhpcyxlKT09PTB9O0J1ZmZlci5wcm90b3R5cGUuaW5zcGVjdD1mdW5jdGlvbiBpbnNwZWN0KCl7dmFyIGU9XCJcIjt2YXIgdD1yLklOU1BFQ1RfTUFYX0JZVEVTO2U9dGhpcy50b1N0cmluZyhcImhleFwiLDAsdCkucmVwbGFjZSgvKC57Mn0pL2csXCIkMSBcIikudHJpbSgpO2lmKHRoaXMubGVuZ3RoPnQpZSs9XCIgLi4uIFwiO3JldHVyblwiPEJ1ZmZlciBcIitlK1wiPlwifTtpZihpKXtCdWZmZXIucHJvdG90eXBlW2ldPUJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdH1CdWZmZXIucHJvdG90eXBlLmNvbXBhcmU9ZnVuY3Rpb24gY29tcGFyZShlLHIsdCxmLG4pe2lmKGlzSW5zdGFuY2UoZSxVaW50OEFycmF5KSl7ZT1CdWZmZXIuZnJvbShlLGUub2Zmc2V0LGUuYnl0ZUxlbmd0aCl9aWYoIUJ1ZmZlci5pc0J1ZmZlcihlKSl7dGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwidGFyZ2V0XCIgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBCdWZmZXIgb3IgVWludDhBcnJheS4gJytcIlJlY2VpdmVkIHR5cGUgXCIrdHlwZW9mIGUpfWlmKHI9PT11bmRlZmluZWQpe3I9MH1pZih0PT09dW5kZWZpbmVkKXt0PWU/ZS5sZW5ndGg6MH1pZihmPT09dW5kZWZpbmVkKXtmPTB9aWYobj09PXVuZGVmaW5lZCl7bj10aGlzLmxlbmd0aH1pZihyPDB8fHQ+ZS5sZW5ndGh8fGY8MHx8bj50aGlzLmxlbmd0aCl7dGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJvdXQgb2YgcmFuZ2UgaW5kZXhcIil9aWYoZj49biYmcj49dCl7cmV0dXJuIDB9aWYoZj49bil7cmV0dXJuLTF9aWYocj49dCl7cmV0dXJuIDF9cj4+Pj0wO3Q+Pj49MDtmPj4+PTA7bj4+Pj0wO2lmKHRoaXM9PT1lKXJldHVybiAwO3ZhciBpPW4tZjt2YXIgbz10LXI7dmFyIHU9TWF0aC5taW4oaSxvKTt2YXIgYT10aGlzLnNsaWNlKGYsbik7dmFyIHM9ZS5zbGljZShyLHQpO2Zvcih2YXIgaD0wO2g8dTsrK2gpe2lmKGFbaF0hPT1zW2hdKXtpPWFbaF07bz1zW2hdO2JyZWFrfX1pZihpPG8pcmV0dXJuLTE7aWYobzxpKXJldHVybiAxO3JldHVybiAwfTtmdW5jdGlvbiBiaWRpcmVjdGlvbmFsSW5kZXhPZihlLHIsdCxmLG4pe2lmKGUubGVuZ3RoPT09MClyZXR1cm4tMTtpZih0eXBlb2YgdD09PVwic3RyaW5nXCIpe2Y9dDt0PTB9ZWxzZSBpZih0PjIxNDc0ODM2NDcpe3Q9MjE0NzQ4MzY0N31lbHNlIGlmKHQ8LTIxNDc0ODM2NDgpe3Q9LTIxNDc0ODM2NDh9dD0rdDtpZihudW1iZXJJc05hTih0KSl7dD1uPzA6ZS5sZW5ndGgtMX1pZih0PDApdD1lLmxlbmd0aCt0O2lmKHQ+PWUubGVuZ3RoKXtpZihuKXJldHVybi0xO2Vsc2UgdD1lLmxlbmd0aC0xfWVsc2UgaWYodDwwKXtpZihuKXQ9MDtlbHNlIHJldHVybi0xfWlmKHR5cGVvZiByPT09XCJzdHJpbmdcIil7cj1CdWZmZXIuZnJvbShyLGYpfWlmKEJ1ZmZlci5pc0J1ZmZlcihyKSl7aWYoci5sZW5ndGg9PT0wKXtyZXR1cm4tMX1yZXR1cm4gYXJyYXlJbmRleE9mKGUscix0LGYsbil9ZWxzZSBpZih0eXBlb2Ygcj09PVwibnVtYmVyXCIpe3I9ciYyNTU7aWYodHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2Y9PT1cImZ1bmN0aW9uXCIpe2lmKG4pe3JldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwoZSxyLHQpfWVsc2V7cmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmxhc3RJbmRleE9mLmNhbGwoZSxyLHQpfX1yZXR1cm4gYXJyYXlJbmRleE9mKGUsW3JdLHQsZixuKX10aHJvdyBuZXcgVHlwZUVycm9yKFwidmFsIG11c3QgYmUgc3RyaW5nLCBudW1iZXIgb3IgQnVmZmVyXCIpfWZ1bmN0aW9uIGFycmF5SW5kZXhPZihlLHIsdCxmLG4pe3ZhciBpPTE7dmFyIG89ZS5sZW5ndGg7dmFyIHU9ci5sZW5ndGg7aWYoZiE9PXVuZGVmaW5lZCl7Zj1TdHJpbmcoZikudG9Mb3dlckNhc2UoKTtpZihmPT09XCJ1Y3MyXCJ8fGY9PT1cInVjcy0yXCJ8fGY9PT1cInV0ZjE2bGVcInx8Zj09PVwidXRmLTE2bGVcIil7aWYoZS5sZW5ndGg8Mnx8ci5sZW5ndGg8Mil7cmV0dXJuLTF9aT0yO28vPTI7dS89Mjt0Lz0yfX1mdW5jdGlvbiByZWFkKGUscil7aWYoaT09PTEpe3JldHVybiBlW3JdfWVsc2V7cmV0dXJuIGUucmVhZFVJbnQxNkJFKHIqaSl9fXZhciBhO2lmKG4pe3ZhciBzPS0xO2ZvcihhPXQ7YTxvO2ErKyl7aWYocmVhZChlLGEpPT09cmVhZChyLHM9PT0tMT8wOmEtcykpe2lmKHM9PT0tMSlzPWE7aWYoYS1zKzE9PT11KXJldHVybiBzKml9ZWxzZXtpZihzIT09LTEpYS09YS1zO3M9LTF9fX1lbHNle2lmKHQrdT5vKXQ9by11O2ZvcihhPXQ7YT49MDthLS0pe3ZhciBoPXRydWU7Zm9yKHZhciBjPTA7Yzx1O2MrKyl7aWYocmVhZChlLGErYykhPT1yZWFkKHIsYykpe2g9ZmFsc2U7YnJlYWt9fWlmKGgpcmV0dXJuIGF9fXJldHVybi0xfUJ1ZmZlci5wcm90b3R5cGUuaW5jbHVkZXM9ZnVuY3Rpb24gaW5jbHVkZXMoZSxyLHQpe3JldHVybiB0aGlzLmluZGV4T2YoZSxyLHQpIT09LTF9O0J1ZmZlci5wcm90b3R5cGUuaW5kZXhPZj1mdW5jdGlvbiBpbmRleE9mKGUscix0KXtyZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcyxlLHIsdCx0cnVlKX07QnVmZmVyLnByb3RvdHlwZS5sYXN0SW5kZXhPZj1mdW5jdGlvbiBsYXN0SW5kZXhPZihlLHIsdCl7cmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsZSxyLHQsZmFsc2UpfTtmdW5jdGlvbiBoZXhXcml0ZShlLHIsdCxmKXt0PU51bWJlcih0KXx8MDt2YXIgbj1lLmxlbmd0aC10O2lmKCFmKXtmPW59ZWxzZXtmPU51bWJlcihmKTtpZihmPm4pe2Y9bn19dmFyIGk9ci5sZW5ndGg7aWYoZj5pLzIpe2Y9aS8yfWZvcih2YXIgbz0wO288ZjsrK28pe3ZhciB1PXBhcnNlSW50KHIuc3Vic3RyKG8qMiwyKSwxNik7aWYobnVtYmVySXNOYU4odSkpcmV0dXJuIG87ZVt0K29dPXV9cmV0dXJuIG99ZnVuY3Rpb24gdXRmOFdyaXRlKGUscix0LGYpe3JldHVybiBibGl0QnVmZmVyKHV0ZjhUb0J5dGVzKHIsZS5sZW5ndGgtdCksZSx0LGYpfWZ1bmN0aW9uIGFzY2lpV3JpdGUoZSxyLHQsZil7cmV0dXJuIGJsaXRCdWZmZXIoYXNjaWlUb0J5dGVzKHIpLGUsdCxmKX1mdW5jdGlvbiBsYXRpbjFXcml0ZShlLHIsdCxmKXtyZXR1cm4gYXNjaWlXcml0ZShlLHIsdCxmKX1mdW5jdGlvbiBiYXNlNjRXcml0ZShlLHIsdCxmKXtyZXR1cm4gYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHIpLGUsdCxmKX1mdW5jdGlvbiB1Y3MyV3JpdGUoZSxyLHQsZil7cmV0dXJuIGJsaXRCdWZmZXIodXRmMTZsZVRvQnl0ZXMocixlLmxlbmd0aC10KSxlLHQsZil9QnVmZmVyLnByb3RvdHlwZS53cml0ZT1mdW5jdGlvbiB3cml0ZShlLHIsdCxmKXtpZihyPT09dW5kZWZpbmVkKXtmPVwidXRmOFwiO3Q9dGhpcy5sZW5ndGg7cj0wfWVsc2UgaWYodD09PXVuZGVmaW5lZCYmdHlwZW9mIHI9PT1cInN0cmluZ1wiKXtmPXI7dD10aGlzLmxlbmd0aDtyPTB9ZWxzZSBpZihpc0Zpbml0ZShyKSl7cj1yPj4+MDtpZihpc0Zpbml0ZSh0KSl7dD10Pj4+MDtpZihmPT09dW5kZWZpbmVkKWY9XCJ1dGY4XCJ9ZWxzZXtmPXQ7dD11bmRlZmluZWR9fWVsc2V7dGhyb3cgbmV3IEVycm9yKFwiQnVmZmVyLndyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldFssIGxlbmd0aF0pIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWRcIil9dmFyIG49dGhpcy5sZW5ndGgtcjtpZih0PT09dW5kZWZpbmVkfHx0Pm4pdD1uO2lmKGUubGVuZ3RoPjAmJih0PDB8fHI8MCl8fHI+dGhpcy5sZW5ndGgpe3Rocm93IG5ldyBSYW5nZUVycm9yKFwiQXR0ZW1wdCB0byB3cml0ZSBvdXRzaWRlIGJ1ZmZlciBib3VuZHNcIil9aWYoIWYpZj1cInV0ZjhcIjt2YXIgaT1mYWxzZTtmb3IoOzspe3N3aXRjaChmKXtjYXNlXCJoZXhcIjpyZXR1cm4gaGV4V3JpdGUodGhpcyxlLHIsdCk7Y2FzZVwidXRmOFwiOmNhc2VcInV0Zi04XCI6cmV0dXJuIHV0ZjhXcml0ZSh0aGlzLGUscix0KTtjYXNlXCJhc2NpaVwiOnJldHVybiBhc2NpaVdyaXRlKHRoaXMsZSxyLHQpO2Nhc2VcImxhdGluMVwiOmNhc2VcImJpbmFyeVwiOnJldHVybiBsYXRpbjFXcml0ZSh0aGlzLGUscix0KTtjYXNlXCJiYXNlNjRcIjpyZXR1cm4gYmFzZTY0V3JpdGUodGhpcyxlLHIsdCk7Y2FzZVwidWNzMlwiOmNhc2VcInVjcy0yXCI6Y2FzZVwidXRmMTZsZVwiOmNhc2VcInV0Zi0xNmxlXCI6cmV0dXJuIHVjczJXcml0ZSh0aGlzLGUscix0KTtkZWZhdWx0OmlmKGkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlVua25vd24gZW5jb2Rpbmc6IFwiK2YpO2Y9KFwiXCIrZikudG9Mb3dlckNhc2UoKTtpPXRydWV9fX07QnVmZmVyLnByb3RvdHlwZS50b0pTT049ZnVuY3Rpb24gdG9KU09OKCl7cmV0dXJue3R5cGU6XCJCdWZmZXJcIixkYXRhOkFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2Fycnx8dGhpcywwKX19O2Z1bmN0aW9uIGJhc2U2NFNsaWNlKGUscix0KXtpZihyPT09MCYmdD09PWUubGVuZ3RoKXtyZXR1cm4gZi5mcm9tQnl0ZUFycmF5KGUpfWVsc2V7cmV0dXJuIGYuZnJvbUJ5dGVBcnJheShlLnNsaWNlKHIsdCkpfX1mdW5jdGlvbiB1dGY4U2xpY2UoZSxyLHQpe3Q9TWF0aC5taW4oZS5sZW5ndGgsdCk7dmFyIGY9W107dmFyIG49cjt3aGlsZShuPHQpe3ZhciBpPWVbbl07dmFyIG89bnVsbDt2YXIgdT1pPjIzOT80Omk+MjIzPzM6aT4xOTE/MjoxO2lmKG4rdTw9dCl7dmFyIGEscyxoLGM7c3dpdGNoKHUpe2Nhc2UgMTppZihpPDEyOCl7bz1pfWJyZWFrO2Nhc2UgMjphPWVbbisxXTtpZigoYSYxOTIpPT09MTI4KXtjPShpJjMxKTw8NnxhJjYzO2lmKGM+MTI3KXtvPWN9fWJyZWFrO2Nhc2UgMzphPWVbbisxXTtzPWVbbisyXTtpZigoYSYxOTIpPT09MTI4JiYocyYxOTIpPT09MTI4KXtjPShpJjE1KTw8MTJ8KGEmNjMpPDw2fHMmNjM7aWYoYz4yMDQ3JiYoYzw1NTI5Nnx8Yz41NzM0Mykpe289Y319YnJlYWs7Y2FzZSA0OmE9ZVtuKzFdO3M9ZVtuKzJdO2g9ZVtuKzNdO2lmKChhJjE5Mik9PT0xMjgmJihzJjE5Mik9PT0xMjgmJihoJjE5Mik9PT0xMjgpe2M9KGkmMTUpPDwxOHwoYSY2Myk8PDEyfChzJjYzKTw8NnxoJjYzO2lmKGM+NjU1MzUmJmM8MTExNDExMil7bz1jfX19fWlmKG89PT1udWxsKXtvPTY1NTMzO3U9MX1lbHNlIGlmKG8+NjU1MzUpe28tPTY1NTM2O2YucHVzaChvPj4+MTAmMTAyM3w1NTI5Nik7bz01NjMyMHxvJjEwMjN9Zi5wdXNoKG8pO24rPXV9cmV0dXJuIGRlY29kZUNvZGVQb2ludHNBcnJheShmKX12YXIgdT00MDk2O2Z1bmN0aW9uIGRlY29kZUNvZGVQb2ludHNBcnJheShlKXt2YXIgcj1lLmxlbmd0aDtpZihyPD11KXtyZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsZSl9dmFyIHQ9XCJcIjt2YXIgZj0wO3doaWxlKGY8cil7dCs9U3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsZS5zbGljZShmLGYrPXUpKX1yZXR1cm4gdH1mdW5jdGlvbiBhc2NpaVNsaWNlKGUscix0KXt2YXIgZj1cIlwiO3Q9TWF0aC5taW4oZS5sZW5ndGgsdCk7Zm9yKHZhciBuPXI7bjx0Oysrbil7Zis9U3RyaW5nLmZyb21DaGFyQ29kZShlW25dJjEyNyl9cmV0dXJuIGZ9ZnVuY3Rpb24gbGF0aW4xU2xpY2UoZSxyLHQpe3ZhciBmPVwiXCI7dD1NYXRoLm1pbihlLmxlbmd0aCx0KTtmb3IodmFyIG49cjtuPHQ7KytuKXtmKz1TdHJpbmcuZnJvbUNoYXJDb2RlKGVbbl0pfXJldHVybiBmfWZ1bmN0aW9uIGhleFNsaWNlKGUscix0KXt2YXIgZj1lLmxlbmd0aDtpZighcnx8cjwwKXI9MDtpZighdHx8dDwwfHx0PmYpdD1mO3ZhciBuPVwiXCI7Zm9yKHZhciBpPXI7aTx0OysraSl7bis9c1tlW2ldXX1yZXR1cm4gbn1mdW5jdGlvbiB1dGYxNmxlU2xpY2UoZSxyLHQpe3ZhciBmPWUuc2xpY2Uocix0KTt2YXIgbj1cIlwiO2Zvcih2YXIgaT0wO2k8Zi5sZW5ndGg7aSs9Mil7bis9U3RyaW5nLmZyb21DaGFyQ29kZShmW2ldK2ZbaSsxXSoyNTYpfXJldHVybiBufUJ1ZmZlci5wcm90b3R5cGUuc2xpY2U9ZnVuY3Rpb24gc2xpY2UoZSxyKXt2YXIgdD10aGlzLmxlbmd0aDtlPX5+ZTtyPXI9PT11bmRlZmluZWQ/dDp+fnI7aWYoZTwwKXtlKz10O2lmKGU8MCllPTB9ZWxzZSBpZihlPnQpe2U9dH1pZihyPDApe3IrPXQ7aWYocjwwKXI9MH1lbHNlIGlmKHI+dCl7cj10fWlmKHI8ZSlyPWU7dmFyIGY9dGhpcy5zdWJhcnJheShlLHIpO09iamVjdC5zZXRQcm90b3R5cGVPZihmLEJ1ZmZlci5wcm90b3R5cGUpO3JldHVybiBmfTtmdW5jdGlvbiBjaGVja09mZnNldChlLHIsdCl7aWYoZSUxIT09MHx8ZTwwKXRocm93IG5ldyBSYW5nZUVycm9yKFwib2Zmc2V0IGlzIG5vdCB1aW50XCIpO2lmKGUrcj50KXRocm93IG5ldyBSYW5nZUVycm9yKFwiVHJ5aW5nIHRvIGFjY2VzcyBiZXlvbmQgYnVmZmVyIGxlbmd0aFwiKX1CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50TEU9ZnVuY3Rpb24gcmVhZFVJbnRMRShlLHIsdCl7ZT1lPj4+MDtyPXI+Pj4wO2lmKCF0KWNoZWNrT2Zmc2V0KGUscix0aGlzLmxlbmd0aCk7dmFyIGY9dGhpc1tlXTt2YXIgbj0xO3ZhciBpPTA7d2hpbGUoKytpPHImJihuKj0yNTYpKXtmKz10aGlzW2UraV0qbn1yZXR1cm4gZn07QnVmZmVyLnByb3RvdHlwZS5yZWFkVUludEJFPWZ1bmN0aW9uIHJlYWRVSW50QkUoZSxyLHQpe2U9ZT4+PjA7cj1yPj4+MDtpZighdCl7Y2hlY2tPZmZzZXQoZSxyLHRoaXMubGVuZ3RoKX12YXIgZj10aGlzW2UrLS1yXTt2YXIgbj0xO3doaWxlKHI+MCYmKG4qPTI1Nikpe2YrPXRoaXNbZSstLXJdKm59cmV0dXJuIGZ9O0J1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4PWZ1bmN0aW9uIHJlYWRVSW50OChlLHIpe2U9ZT4+PjA7aWYoIXIpY2hlY2tPZmZzZXQoZSwxLHRoaXMubGVuZ3RoKTtyZXR1cm4gdGhpc1tlXX07QnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEU9ZnVuY3Rpb24gcmVhZFVJbnQxNkxFKGUscil7ZT1lPj4+MDtpZighciljaGVja09mZnNldChlLDIsdGhpcy5sZW5ndGgpO3JldHVybiB0aGlzW2VdfHRoaXNbZSsxXTw8OH07QnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkU9ZnVuY3Rpb24gcmVhZFVJbnQxNkJFKGUscil7ZT1lPj4+MDtpZighciljaGVja09mZnNldChlLDIsdGhpcy5sZW5ndGgpO3JldHVybiB0aGlzW2VdPDw4fHRoaXNbZSsxXX07QnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEU9ZnVuY3Rpb24gcmVhZFVJbnQzMkxFKGUscil7ZT1lPj4+MDtpZighciljaGVja09mZnNldChlLDQsdGhpcy5sZW5ndGgpO3JldHVybih0aGlzW2VdfHRoaXNbZSsxXTw8OHx0aGlzW2UrMl08PDE2KSt0aGlzW2UrM10qMTY3NzcyMTZ9O0J1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFPWZ1bmN0aW9uIHJlYWRVSW50MzJCRShlLHIpe2U9ZT4+PjA7aWYoIXIpY2hlY2tPZmZzZXQoZSw0LHRoaXMubGVuZ3RoKTtyZXR1cm4gdGhpc1tlXSoxNjc3NzIxNisodGhpc1tlKzFdPDwxNnx0aGlzW2UrMl08PDh8dGhpc1tlKzNdKX07QnVmZmVyLnByb3RvdHlwZS5yZWFkSW50TEU9ZnVuY3Rpb24gcmVhZEludExFKGUscix0KXtlPWU+Pj4wO3I9cj4+PjA7aWYoIXQpY2hlY2tPZmZzZXQoZSxyLHRoaXMubGVuZ3RoKTt2YXIgZj10aGlzW2VdO3ZhciBuPTE7dmFyIGk9MDt3aGlsZSgrK2k8ciYmKG4qPTI1Nikpe2YrPXRoaXNbZStpXSpufW4qPTEyODtpZihmPj1uKWYtPU1hdGgucG93KDIsOCpyKTtyZXR1cm4gZn07QnVmZmVyLnByb3RvdHlwZS5yZWFkSW50QkU9ZnVuY3Rpb24gcmVhZEludEJFKGUscix0KXtlPWU+Pj4wO3I9cj4+PjA7aWYoIXQpY2hlY2tPZmZzZXQoZSxyLHRoaXMubGVuZ3RoKTt2YXIgZj1yO3ZhciBuPTE7dmFyIGk9dGhpc1tlKy0tZl07d2hpbGUoZj4wJiYobio9MjU2KSl7aSs9dGhpc1tlKy0tZl0qbn1uKj0xMjg7aWYoaT49bilpLT1NYXRoLnBvdygyLDgqcik7cmV0dXJuIGl9O0J1ZmZlci5wcm90b3R5cGUucmVhZEludDg9ZnVuY3Rpb24gcmVhZEludDgoZSxyKXtlPWU+Pj4wO2lmKCFyKWNoZWNrT2Zmc2V0KGUsMSx0aGlzLmxlbmd0aCk7aWYoISh0aGlzW2VdJjEyOCkpcmV0dXJuIHRoaXNbZV07cmV0dXJuKDI1NS10aGlzW2VdKzEpKi0xfTtCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFPWZ1bmN0aW9uIHJlYWRJbnQxNkxFKGUscil7ZT1lPj4+MDtpZighciljaGVja09mZnNldChlLDIsdGhpcy5sZW5ndGgpO3ZhciB0PXRoaXNbZV18dGhpc1tlKzFdPDw4O3JldHVybiB0JjMyNzY4P3R8NDI5NDkwMTc2MDp0fTtCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFPWZ1bmN0aW9uIHJlYWRJbnQxNkJFKGUscil7ZT1lPj4+MDtpZighciljaGVja09mZnNldChlLDIsdGhpcy5sZW5ndGgpO3ZhciB0PXRoaXNbZSsxXXx0aGlzW2VdPDw4O3JldHVybiB0JjMyNzY4P3R8NDI5NDkwMTc2MDp0fTtCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFPWZ1bmN0aW9uIHJlYWRJbnQzMkxFKGUscil7ZT1lPj4+MDtpZighciljaGVja09mZnNldChlLDQsdGhpcy5sZW5ndGgpO3JldHVybiB0aGlzW2VdfHRoaXNbZSsxXTw8OHx0aGlzW2UrMl08PDE2fHRoaXNbZSszXTw8MjR9O0J1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkU9ZnVuY3Rpb24gcmVhZEludDMyQkUoZSxyKXtlPWU+Pj4wO2lmKCFyKWNoZWNrT2Zmc2V0KGUsNCx0aGlzLmxlbmd0aCk7cmV0dXJuIHRoaXNbZV08PDI0fHRoaXNbZSsxXTw8MTZ8dGhpc1tlKzJdPDw4fHRoaXNbZSszXX07QnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRT1mdW5jdGlvbiByZWFkRmxvYXRMRShlLHIpe2U9ZT4+PjA7aWYoIXIpY2hlY2tPZmZzZXQoZSw0LHRoaXMubGVuZ3RoKTtyZXR1cm4gbi5yZWFkKHRoaXMsZSx0cnVlLDIzLDQpfTtCdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFPWZ1bmN0aW9uIHJlYWRGbG9hdEJFKGUscil7ZT1lPj4+MDtpZighciljaGVja09mZnNldChlLDQsdGhpcy5sZW5ndGgpO3JldHVybiBuLnJlYWQodGhpcyxlLGZhbHNlLDIzLDQpfTtCdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRT1mdW5jdGlvbiByZWFkRG91YmxlTEUoZSxyKXtlPWU+Pj4wO2lmKCFyKWNoZWNrT2Zmc2V0KGUsOCx0aGlzLmxlbmd0aCk7cmV0dXJuIG4ucmVhZCh0aGlzLGUsdHJ1ZSw1Miw4KX07QnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkU9ZnVuY3Rpb24gcmVhZERvdWJsZUJFKGUscil7ZT1lPj4+MDtpZighciljaGVja09mZnNldChlLDgsdGhpcy5sZW5ndGgpO3JldHVybiBuLnJlYWQodGhpcyxlLGZhbHNlLDUyLDgpfTtmdW5jdGlvbiBjaGVja0ludChlLHIsdCxmLG4saSl7aWYoIUJ1ZmZlci5pc0J1ZmZlcihlKSl0aHJvdyBuZXcgVHlwZUVycm9yKCdcImJ1ZmZlclwiIGFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXIgaW5zdGFuY2UnKTtpZihyPm58fHI8aSl0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IGlzIG91dCBvZiBib3VuZHMnKTtpZih0K2Y+ZS5sZW5ndGgpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbmRleCBvdXQgb2YgcmFuZ2VcIil9QnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRMRT1mdW5jdGlvbiB3cml0ZVVJbnRMRShlLHIsdCxmKXtlPStlO3I9cj4+PjA7dD10Pj4+MDtpZighZil7dmFyIG49TWF0aC5wb3coMiw4KnQpLTE7Y2hlY2tJbnQodGhpcyxlLHIsdCxuLDApfXZhciBpPTE7dmFyIG89MDt0aGlzW3JdPWUmMjU1O3doaWxlKCsrbzx0JiYoaSo9MjU2KSl7dGhpc1tyK29dPWUvaSYyNTV9cmV0dXJuIHIrdH07QnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRCRT1mdW5jdGlvbiB3cml0ZVVJbnRCRShlLHIsdCxmKXtlPStlO3I9cj4+PjA7dD10Pj4+MDtpZighZil7dmFyIG49TWF0aC5wb3coMiw4KnQpLTE7Y2hlY2tJbnQodGhpcyxlLHIsdCxuLDApfXZhciBpPXQtMTt2YXIgbz0xO3RoaXNbcitpXT1lJjI1NTt3aGlsZSgtLWk+PTAmJihvKj0yNTYpKXt0aGlzW3IraV09ZS9vJjI1NX1yZXR1cm4gcit0fTtCdWZmZXIucHJvdG90eXBlLndyaXRlVUludDg9ZnVuY3Rpb24gd3JpdGVVSW50OChlLHIsdCl7ZT0rZTtyPXI+Pj4wO2lmKCF0KWNoZWNrSW50KHRoaXMsZSxyLDEsMjU1LDApO3RoaXNbcl09ZSYyNTU7cmV0dXJuIHIrMX07QnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFPWZ1bmN0aW9uIHdyaXRlVUludDE2TEUoZSxyLHQpe2U9K2U7cj1yPj4+MDtpZighdCljaGVja0ludCh0aGlzLGUsciwyLDY1NTM1LDApO3RoaXNbcl09ZSYyNTU7dGhpc1tyKzFdPWU+Pj44O3JldHVybiByKzJ9O0J1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRT1mdW5jdGlvbiB3cml0ZVVJbnQxNkJFKGUscix0KXtlPStlO3I9cj4+PjA7aWYoIXQpY2hlY2tJbnQodGhpcyxlLHIsMiw2NTUzNSwwKTt0aGlzW3JdPWU+Pj44O3RoaXNbcisxXT1lJjI1NTtyZXR1cm4gcisyfTtCdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEU9ZnVuY3Rpb24gd3JpdGVVSW50MzJMRShlLHIsdCl7ZT0rZTtyPXI+Pj4wO2lmKCF0KWNoZWNrSW50KHRoaXMsZSxyLDQsNDI5NDk2NzI5NSwwKTt0aGlzW3IrM109ZT4+PjI0O3RoaXNbcisyXT1lPj4+MTY7dGhpc1tyKzFdPWU+Pj44O3RoaXNbcl09ZSYyNTU7cmV0dXJuIHIrNH07QnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFPWZ1bmN0aW9uIHdyaXRlVUludDMyQkUoZSxyLHQpe2U9K2U7cj1yPj4+MDtpZighdCljaGVja0ludCh0aGlzLGUsciw0LDQyOTQ5NjcyOTUsMCk7dGhpc1tyXT1lPj4+MjQ7dGhpc1tyKzFdPWU+Pj4xNjt0aGlzW3IrMl09ZT4+Pjg7dGhpc1tyKzNdPWUmMjU1O3JldHVybiByKzR9O0J1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRMRT1mdW5jdGlvbiB3cml0ZUludExFKGUscix0LGYpe2U9K2U7cj1yPj4+MDtpZighZil7dmFyIG49TWF0aC5wb3coMiw4KnQtMSk7Y2hlY2tJbnQodGhpcyxlLHIsdCxuLTEsLW4pfXZhciBpPTA7dmFyIG89MTt2YXIgdT0wO3RoaXNbcl09ZSYyNTU7d2hpbGUoKytpPHQmJihvKj0yNTYpKXtpZihlPDAmJnU9PT0wJiZ0aGlzW3IraS0xXSE9PTApe3U9MX10aGlzW3IraV09KGUvbz4+MCktdSYyNTV9cmV0dXJuIHIrdH07QnVmZmVyLnByb3RvdHlwZS53cml0ZUludEJFPWZ1bmN0aW9uIHdyaXRlSW50QkUoZSxyLHQsZil7ZT0rZTtyPXI+Pj4wO2lmKCFmKXt2YXIgbj1NYXRoLnBvdygyLDgqdC0xKTtjaGVja0ludCh0aGlzLGUscix0LG4tMSwtbil9dmFyIGk9dC0xO3ZhciBvPTE7dmFyIHU9MDt0aGlzW3IraV09ZSYyNTU7d2hpbGUoLS1pPj0wJiYobyo9MjU2KSl7aWYoZTwwJiZ1PT09MCYmdGhpc1tyK2krMV0hPT0wKXt1PTF9dGhpc1tyK2ldPShlL28+PjApLXUmMjU1fXJldHVybiByK3R9O0J1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4PWZ1bmN0aW9uIHdyaXRlSW50OChlLHIsdCl7ZT0rZTtyPXI+Pj4wO2lmKCF0KWNoZWNrSW50KHRoaXMsZSxyLDEsMTI3LC0xMjgpO2lmKGU8MCllPTI1NStlKzE7dGhpc1tyXT1lJjI1NTtyZXR1cm4gcisxfTtCdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRT1mdW5jdGlvbiB3cml0ZUludDE2TEUoZSxyLHQpe2U9K2U7cj1yPj4+MDtpZighdCljaGVja0ludCh0aGlzLGUsciwyLDMyNzY3LC0zMjc2OCk7dGhpc1tyXT1lJjI1NTt0aGlzW3IrMV09ZT4+Pjg7cmV0dXJuIHIrMn07QnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2QkU9ZnVuY3Rpb24gd3JpdGVJbnQxNkJFKGUscix0KXtlPStlO3I9cj4+PjA7aWYoIXQpY2hlY2tJbnQodGhpcyxlLHIsMiwzMjc2NywtMzI3NjgpO3RoaXNbcl09ZT4+Pjg7dGhpc1tyKzFdPWUmMjU1O3JldHVybiByKzJ9O0J1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFPWZ1bmN0aW9uIHdyaXRlSW50MzJMRShlLHIsdCl7ZT0rZTtyPXI+Pj4wO2lmKCF0KWNoZWNrSW50KHRoaXMsZSxyLDQsMjE0NzQ4MzY0NywtMjE0NzQ4MzY0OCk7dGhpc1tyXT1lJjI1NTt0aGlzW3IrMV09ZT4+Pjg7dGhpc1tyKzJdPWU+Pj4xNjt0aGlzW3IrM109ZT4+PjI0O3JldHVybiByKzR9O0J1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFPWZ1bmN0aW9uIHdyaXRlSW50MzJCRShlLHIsdCl7ZT0rZTtyPXI+Pj4wO2lmKCF0KWNoZWNrSW50KHRoaXMsZSxyLDQsMjE0NzQ4MzY0NywtMjE0NzQ4MzY0OCk7aWYoZTwwKWU9NDI5NDk2NzI5NStlKzE7dGhpc1tyXT1lPj4+MjQ7dGhpc1tyKzFdPWU+Pj4xNjt0aGlzW3IrMl09ZT4+Pjg7dGhpc1tyKzNdPWUmMjU1O3JldHVybiByKzR9O2Z1bmN0aW9uIGNoZWNrSUVFRTc1NChlLHIsdCxmLG4saSl7aWYodCtmPmUubGVuZ3RoKXRocm93IG5ldyBSYW5nZUVycm9yKFwiSW5kZXggb3V0IG9mIHJhbmdlXCIpO2lmKHQ8MCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkluZGV4IG91dCBvZiByYW5nZVwiKX1mdW5jdGlvbiB3cml0ZUZsb2F0KGUscix0LGYsaSl7cj0rcjt0PXQ+Pj4wO2lmKCFpKXtjaGVja0lFRUU3NTQoZSxyLHQsNCwzNDAyODIzNDY2Mzg1Mjg4NmUyMiwtMzQwMjgyMzQ2NjM4NTI4ODZlMjIpfW4ud3JpdGUoZSxyLHQsZiwyMyw0KTtyZXR1cm4gdCs0fUJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFPWZ1bmN0aW9uIHdyaXRlRmxvYXRMRShlLHIsdCl7cmV0dXJuIHdyaXRlRmxvYXQodGhpcyxlLHIsdHJ1ZSx0KX07QnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkU9ZnVuY3Rpb24gd3JpdGVGbG9hdEJFKGUscix0KXtyZXR1cm4gd3JpdGVGbG9hdCh0aGlzLGUscixmYWxzZSx0KX07ZnVuY3Rpb24gd3JpdGVEb3VibGUoZSxyLHQsZixpKXtyPStyO3Q9dD4+PjA7aWYoIWkpe2NoZWNrSUVFRTc1NChlLHIsdCw4LDE3OTc2OTMxMzQ4NjIzMTU3ZTI5MiwtMTc5NzY5MzEzNDg2MjMxNTdlMjkyKX1uLndyaXRlKGUscix0LGYsNTIsOCk7cmV0dXJuIHQrOH1CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlTEU9ZnVuY3Rpb24gd3JpdGVEb3VibGVMRShlLHIsdCl7cmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsZSxyLHRydWUsdCl9O0J1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRT1mdW5jdGlvbiB3cml0ZURvdWJsZUJFKGUscix0KXtyZXR1cm4gd3JpdGVEb3VibGUodGhpcyxlLHIsZmFsc2UsdCl9O0J1ZmZlci5wcm90b3R5cGUuY29weT1mdW5jdGlvbiBjb3B5KGUscix0LGYpe2lmKCFCdWZmZXIuaXNCdWZmZXIoZSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcImFyZ3VtZW50IHNob3VsZCBiZSBhIEJ1ZmZlclwiKTtpZighdCl0PTA7aWYoIWYmJmYhPT0wKWY9dGhpcy5sZW5ndGg7aWYocj49ZS5sZW5ndGgpcj1lLmxlbmd0aDtpZighcilyPTA7aWYoZj4wJiZmPHQpZj10O2lmKGY9PT10KXJldHVybiAwO2lmKGUubGVuZ3RoPT09MHx8dGhpcy5sZW5ndGg9PT0wKXJldHVybiAwO2lmKHI8MCl7dGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJ0YXJnZXRTdGFydCBvdXQgb2YgYm91bmRzXCIpfWlmKHQ8MHx8dD49dGhpcy5sZW5ndGgpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbmRleCBvdXQgb2YgcmFuZ2VcIik7aWYoZjwwKXRocm93IG5ldyBSYW5nZUVycm9yKFwic291cmNlRW5kIG91dCBvZiBib3VuZHNcIik7aWYoZj50aGlzLmxlbmd0aClmPXRoaXMubGVuZ3RoO2lmKGUubGVuZ3RoLXI8Zi10KXtmPWUubGVuZ3RoLXIrdH12YXIgbj1mLXQ7aWYodGhpcz09PWUmJnR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5jb3B5V2l0aGluPT09XCJmdW5jdGlvblwiKXt0aGlzLmNvcHlXaXRoaW4ocix0LGYpfWVsc2UgaWYodGhpcz09PWUmJnQ8ciYmcjxmKXtmb3IodmFyIGk9bi0xO2k+PTA7LS1pKXtlW2krcl09dGhpc1tpK3RdfX1lbHNle1VpbnQ4QXJyYXkucHJvdG90eXBlLnNldC5jYWxsKGUsdGhpcy5zdWJhcnJheSh0LGYpLHIpfXJldHVybiBufTtCdWZmZXIucHJvdG90eXBlLmZpbGw9ZnVuY3Rpb24gZmlsbChlLHIsdCxmKXtpZih0eXBlb2YgZT09PVwic3RyaW5nXCIpe2lmKHR5cGVvZiByPT09XCJzdHJpbmdcIil7Zj1yO3I9MDt0PXRoaXMubGVuZ3RofWVsc2UgaWYodHlwZW9mIHQ9PT1cInN0cmluZ1wiKXtmPXQ7dD10aGlzLmxlbmd0aH1pZihmIT09dW5kZWZpbmVkJiZ0eXBlb2YgZiE9PVwic3RyaW5nXCIpe3Rocm93IG5ldyBUeXBlRXJyb3IoXCJlbmNvZGluZyBtdXN0IGJlIGEgc3RyaW5nXCIpfWlmKHR5cGVvZiBmPT09XCJzdHJpbmdcIiYmIUJ1ZmZlci5pc0VuY29kaW5nKGYpKXt0aHJvdyBuZXcgVHlwZUVycm9yKFwiVW5rbm93biBlbmNvZGluZzogXCIrZil9aWYoZS5sZW5ndGg9PT0xKXt2YXIgbj1lLmNoYXJDb2RlQXQoMCk7aWYoZj09PVwidXRmOFwiJiZuPDEyOHx8Zj09PVwibGF0aW4xXCIpe2U9bn19fWVsc2UgaWYodHlwZW9mIGU9PT1cIm51bWJlclwiKXtlPWUmMjU1fWVsc2UgaWYodHlwZW9mIGU9PT1cImJvb2xlYW5cIil7ZT1OdW1iZXIoZSl9aWYocjwwfHx0aGlzLmxlbmd0aDxyfHx0aGlzLmxlbmd0aDx0KXt0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIk91dCBvZiByYW5nZSBpbmRleFwiKX1pZih0PD1yKXtyZXR1cm4gdGhpc31yPXI+Pj4wO3Q9dD09PXVuZGVmaW5lZD90aGlzLmxlbmd0aDp0Pj4+MDtpZighZSllPTA7dmFyIGk7aWYodHlwZW9mIGU9PT1cIm51bWJlclwiKXtmb3IoaT1yO2k8dDsrK2kpe3RoaXNbaV09ZX19ZWxzZXt2YXIgbz1CdWZmZXIuaXNCdWZmZXIoZSk/ZTpCdWZmZXIuZnJvbShlLGYpO3ZhciB1PW8ubGVuZ3RoO2lmKHU9PT0wKXt0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgdmFsdWUgXCInK2UrJ1wiIGlzIGludmFsaWQgZm9yIGFyZ3VtZW50IFwidmFsdWVcIicpfWZvcihpPTA7aTx0LXI7KytpKXt0aGlzW2krcl09b1tpJXVdfX1yZXR1cm4gdGhpc307dmFyIGE9L1teKy8wLTlBLVphLXotX10vZztmdW5jdGlvbiBiYXNlNjRjbGVhbihlKXtlPWUuc3BsaXQoXCI9XCIpWzBdO2U9ZS50cmltKCkucmVwbGFjZShhLFwiXCIpO2lmKGUubGVuZ3RoPDIpcmV0dXJuXCJcIjt3aGlsZShlLmxlbmd0aCU0IT09MCl7ZT1lK1wiPVwifXJldHVybiBlfWZ1bmN0aW9uIHV0ZjhUb0J5dGVzKGUscil7cj1yfHxJbmZpbml0eTt2YXIgdDt2YXIgZj1lLmxlbmd0aDt2YXIgbj1udWxsO3ZhciBpPVtdO2Zvcih2YXIgbz0wO288ZjsrK28pe3Q9ZS5jaGFyQ29kZUF0KG8pO2lmKHQ+NTUyOTUmJnQ8NTczNDQpe2lmKCFuKXtpZih0PjU2MzE5KXtpZigoci09Myk+LTEpaS5wdXNoKDIzOSwxOTEsMTg5KTtjb250aW51ZX1lbHNlIGlmKG8rMT09PWYpe2lmKChyLT0zKT4tMSlpLnB1c2goMjM5LDE5MSwxODkpO2NvbnRpbnVlfW49dDtjb250aW51ZX1pZih0PDU2MzIwKXtpZigoci09Myk+LTEpaS5wdXNoKDIzOSwxOTEsMTg5KTtuPXQ7Y29udGludWV9dD0obi01NTI5Njw8MTB8dC01NjMyMCkrNjU1MzZ9ZWxzZSBpZihuKXtpZigoci09Myk+LTEpaS5wdXNoKDIzOSwxOTEsMTg5KX1uPW51bGw7aWYodDwxMjgpe2lmKChyLT0xKTwwKWJyZWFrO2kucHVzaCh0KX1lbHNlIGlmKHQ8MjA0OCl7aWYoKHItPTIpPDApYnJlYWs7aS5wdXNoKHQ+PjZ8MTkyLHQmNjN8MTI4KX1lbHNlIGlmKHQ8NjU1MzYpe2lmKChyLT0zKTwwKWJyZWFrO2kucHVzaCh0Pj4xMnwyMjQsdD4+NiY2M3wxMjgsdCY2M3wxMjgpfWVsc2UgaWYodDwxMTE0MTEyKXtpZigoci09NCk8MClicmVhaztpLnB1c2godD4+MTh8MjQwLHQ+PjEyJjYzfDEyOCx0Pj42JjYzfDEyOCx0JjYzfDEyOCl9ZWxzZXt0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGNvZGUgcG9pbnRcIil9fXJldHVybiBpfWZ1bmN0aW9uIGFzY2lpVG9CeXRlcyhlKXt2YXIgcj1bXTtmb3IodmFyIHQ9MDt0PGUubGVuZ3RoOysrdCl7ci5wdXNoKGUuY2hhckNvZGVBdCh0KSYyNTUpfXJldHVybiByfWZ1bmN0aW9uIHV0ZjE2bGVUb0J5dGVzKGUscil7dmFyIHQsZixuO3ZhciBpPVtdO2Zvcih2YXIgbz0wO288ZS5sZW5ndGg7KytvKXtpZigoci09Mik8MClicmVhazt0PWUuY2hhckNvZGVBdChvKTtmPXQ+Pjg7bj10JTI1NjtpLnB1c2gobik7aS5wdXNoKGYpfXJldHVybiBpfWZ1bmN0aW9uIGJhc2U2NFRvQnl0ZXMoZSl7cmV0dXJuIGYudG9CeXRlQXJyYXkoYmFzZTY0Y2xlYW4oZSkpfWZ1bmN0aW9uIGJsaXRCdWZmZXIoZSxyLHQsZil7Zm9yKHZhciBuPTA7bjxmOysrbil7aWYobit0Pj1yLmxlbmd0aHx8bj49ZS5sZW5ndGgpYnJlYWs7cltuK3RdPWVbbl19cmV0dXJuIG59ZnVuY3Rpb24gaXNJbnN0YW5jZShlLHIpe3JldHVybiBlIGluc3RhbmNlb2Ygcnx8ZSE9bnVsbCYmZS5jb25zdHJ1Y3RvciE9bnVsbCYmZS5jb25zdHJ1Y3Rvci5uYW1lIT1udWxsJiZlLmNvbnN0cnVjdG9yLm5hbWU9PT1yLm5hbWV9ZnVuY3Rpb24gbnVtYmVySXNOYU4oZSl7cmV0dXJuIGUhPT1lfXZhciBzPWZ1bmN0aW9uKCl7dmFyIGU9XCIwMTIzNDU2Nzg5YWJjZGVmXCI7dmFyIHI9bmV3IEFycmF5KDI1Nik7Zm9yKHZhciB0PTA7dDwxNjsrK3Qpe3ZhciBmPXQqMTY7Zm9yKHZhciBuPTA7bjwxNjsrK24pe3JbZituXT1lW3RdK2Vbbl19fXJldHVybiByfSgpfSw3ODM6ZnVuY3Rpb24oZSxyKXtcbi8qISBpZWVlNzU0LiBCU0QtMy1DbGF1c2UgTGljZW5zZS4gRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnL29wZW5zb3VyY2U+ICovXG5yLnJlYWQ9ZnVuY3Rpb24oZSxyLHQsZixuKXt2YXIgaSxvO3ZhciB1PW4qOC1mLTE7dmFyIGE9KDE8PHUpLTE7dmFyIHM9YT4+MTt2YXIgaD0tNzt2YXIgYz10P24tMTowO3ZhciBsPXQ/LTE6MTt2YXIgcD1lW3IrY107Yys9bDtpPXAmKDE8PC1oKS0xO3A+Pj0taDtoKz11O2Zvcig7aD4wO2k9aSoyNTYrZVtyK2NdLGMrPWwsaC09OCl7fW89aSYoMTw8LWgpLTE7aT4+PS1oO2grPWY7Zm9yKDtoPjA7bz1vKjI1NitlW3IrY10sYys9bCxoLT04KXt9aWYoaT09PTApe2k9MS1zfWVsc2UgaWYoaT09PWEpe3JldHVybiBvP05hTjoocD8tMToxKSpJbmZpbml0eX1lbHNle289bytNYXRoLnBvdygyLGYpO2k9aS1zfXJldHVybihwPy0xOjEpKm8qTWF0aC5wb3coMixpLWYpfTtyLndyaXRlPWZ1bmN0aW9uKGUscix0LGYsbixpKXt2YXIgbyx1LGE7dmFyIHM9aSo4LW4tMTt2YXIgaD0oMTw8cyktMTt2YXIgYz1oPj4xO3ZhciBsPW49PT0yMz9NYXRoLnBvdygyLC0yNCktTWF0aC5wb3coMiwtNzcpOjA7dmFyIHA9Zj8wOmktMTt2YXIgeT1mPzE6LTE7dmFyIGc9cjwwfHxyPT09MCYmMS9yPDA/MTowO3I9TWF0aC5hYnMocik7aWYoaXNOYU4ocil8fHI9PT1JbmZpbml0eSl7dT1pc05hTihyKT8xOjA7bz1ofWVsc2V7bz1NYXRoLmZsb29yKE1hdGgubG9nKHIpL01hdGguTE4yKTtpZihyKihhPU1hdGgucG93KDIsLW8pKTwxKXtvLS07YSo9Mn1pZihvK2M+PTEpe3IrPWwvYX1lbHNle3IrPWwqTWF0aC5wb3coMiwxLWMpfWlmKHIqYT49Mil7bysrO2EvPTJ9aWYobytjPj1oKXt1PTA7bz1ofWVsc2UgaWYobytjPj0xKXt1PShyKmEtMSkqTWF0aC5wb3coMixuKTtvPW8rY31lbHNle3U9cipNYXRoLnBvdygyLGMtMSkqTWF0aC5wb3coMixuKTtvPTB9fWZvcig7bj49ODtlW3QrcF09dSYyNTUscCs9eSx1Lz0yNTYsbi09OCl7fW89bzw8bnx1O3MrPW47Zm9yKDtzPjA7ZVt0K3BdPW8mMjU1LHArPXksby89MjU2LHMtPTgpe31lW3QrcC15XXw9ZyoxMjh9fX07dmFyIHI9e307ZnVuY3Rpb24gX19uY2N3cGNrX3JlcXVpcmVfXyh0KXt2YXIgZj1yW3RdO2lmKGYhPT11bmRlZmluZWQpe3JldHVybiBmLmV4cG9ydHN9dmFyIG49clt0XT17ZXhwb3J0czp7fX07dmFyIGk9dHJ1ZTt0cnl7ZVt0XShuLG4uZXhwb3J0cyxfX25jY3dwY2tfcmVxdWlyZV9fKTtpPWZhbHNlfWZpbmFsbHl7aWYoaSlkZWxldGUgclt0XX1yZXR1cm4gbi5leHBvcnRzfWlmKHR5cGVvZiBfX25jY3dwY2tfcmVxdWlyZV9fIT09XCJ1bmRlZmluZWRcIilfX25jY3dwY2tfcmVxdWlyZV9fLmFiPV9fZGlybmFtZStcIi9cIjt2YXIgdD1fX25jY3dwY2tfcmVxdWlyZV9fKDcyKTttb2R1bGUuZXhwb3J0cz10fSkoKTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/buffer/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/native-url/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/next/dist/compiled/native-url/index.js ***!
  \*************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var __dirname = \"/\";\n(function(){var e={452:function(e){\"use strict\";e.exports=__webpack_require__(/*! next/dist/compiled/querystring-es3 */ \"(app-pages-browser)/./node_modules/next/dist/compiled/querystring-es3/index.js\")}};var t={};function __nccwpck_require__(o){var a=t[o];if(a!==undefined){return a.exports}var s=t[o]={exports:{}};var n=true;try{e[o](s,s.exports,__nccwpck_require__);n=false}finally{if(n)delete t[o]}return s.exports}if(typeof __nccwpck_require__!==\"undefined\")__nccwpck_require__.ab=__dirname+\"/\";var o={};!function(){var e=o;var t,a=(t=__nccwpck_require__(452))&&\"object\"==typeof t&&\"default\"in t?t.default:t,s=/https?|ftp|gopher|file/;function r(e){\"string\"==typeof e&&(e=d(e));var t=function(e,t,o){var a=e.auth,s=e.hostname,n=e.protocol||\"\",p=e.pathname||\"\",c=e.hash||\"\",i=e.query||\"\",u=!1;a=a?encodeURIComponent(a).replace(/%3A/i,\":\")+\"@\":\"\",e.host?u=a+e.host:s&&(u=a+(~s.indexOf(\":\")?\"[\"+s+\"]\":s),e.port&&(u+=\":\"+e.port)),i&&\"object\"==typeof i&&(i=t.encode(i));var f=e.search||i&&\"?\"+i||\"\";return n&&\":\"!==n.substr(-1)&&(n+=\":\"),e.slashes||(!n||o.test(n))&&!1!==u?(u=\"//\"+(u||\"\"),p&&\"/\"!==p[0]&&(p=\"/\"+p)):u||(u=\"\"),c&&\"#\"!==c[0]&&(c=\"#\"+c),f&&\"?\"!==f[0]&&(f=\"?\"+f),{protocol:n,host:u,pathname:p=p.replace(/[?#]/g,encodeURIComponent),search:f=f.replace(\"#\",\"%23\"),hash:c}}(e,a,s);return\"\"+t.protocol+t.host+t.pathname+t.search+t.hash}var n=\"http://\",p=\"w.w\",c=n+p,i=/^([a-z0-9.+-]*:\\/\\/\\/)([a-z0-9.+-]:\\/*)?/i,u=/https?|ftp|gopher|file/;function h(e,t){var o=\"string\"==typeof e?d(e):e;e=\"object\"==typeof e?r(e):e;var a=d(t),s=\"\";o.protocol&&!o.slashes&&(s=o.protocol,e=e.replace(o.protocol,\"\"),s+=\"/\"===t[0]||\"/\"===e[0]?\"/\":\"\"),s&&a.protocol&&(s=\"\",a.slashes||(s=a.protocol,t=t.replace(a.protocol,\"\")));var p=e.match(i);p&&!a.protocol&&(e=e.substr((s=p[1]+(p[2]||\"\")).length),/^\\/\\/[^/]/.test(t)&&(s=s.slice(0,-1)));var f=new URL(e,c+\"/\"),m=new URL(t,f).toString().replace(c,\"\"),v=a.protocol||o.protocol;return v+=o.slashes||a.slashes?\"//\":\"\",!s&&v?m=m.replace(n,v):s&&(m=m.replace(n,\"\")),u.test(m)||~t.indexOf(\".\")||\"/\"===e.slice(-1)||\"/\"===t.slice(-1)||\"/\"!==m.slice(-1)||(m=m.slice(0,-1)),s&&(m=s+(\"/\"===m[0]?m.substr(1):m)),m}function l(){}l.prototype.parse=d,l.prototype.format=r,l.prototype.resolve=h,l.prototype.resolveObject=h;var f=/^https?|ftp|gopher|file/,m=/^(.*?)([#?].*)/,v=/^([a-z0-9.+-]*:)(\\/{0,3})(.*)/i,_=/^([a-z0-9.+-]*:)?\\/\\/\\/*/i,b=/^([a-z0-9.+-]*:)(\\/{0,2})\\[(.*)\\]$/i;function d(e,t,o){if(void 0===t&&(t=!1),void 0===o&&(o=!1),e&&\"object\"==typeof e&&e instanceof l)return e;var s=(e=e.trim()).match(m);e=s?s[1].replace(/\\\\/g,\"/\")+s[2]:e.replace(/\\\\/g,\"/\"),b.test(e)&&\"/\"!==e.slice(-1)&&(e+=\"/\");var n=!/(^javascript)/.test(e)&&e.match(v),i=_.test(e),u=\"\";n&&(f.test(n[1])||(u=n[1].toLowerCase(),e=\"\"+n[2]+n[3]),n[2]||(i=!1,f.test(n[1])?(u=n[1],e=\"\"+n[3]):e=\"//\"+n[3]),3!==n[2].length&&1!==n[2].length||(u=n[1],e=\"/\"+n[3]));var g,y=(s?s[1]:e).match(/^https?:\\/\\/[^/]+(:[0-9]+)(?=\\/|$)/),w=y&&y[1],x=new l,C=\"\",U=\"\";try{g=new URL(e)}catch(t){C=t,u||o||!/^\\/\\//.test(e)||/^\\/\\/.+[@.]/.test(e)||(U=\"/\",e=e.substr(1));try{g=new URL(e,c)}catch(e){return x.protocol=u,x.href=u,x}}x.slashes=i&&!U,x.host=g.host===p?\"\":g.host,x.hostname=g.hostname===p?\"\":g.hostname.replace(/(\\[|\\])/g,\"\"),x.protocol=C?u||null:g.protocol,x.search=g.search.replace(/\\\\/g,\"%5C\"),x.hash=g.hash.replace(/\\\\/g,\"%5C\");var j=e.split(\"#\");!x.search&&~j[0].indexOf(\"?\")&&(x.search=\"?\"),x.hash||\"\"!==j[1]||(x.hash=\"#\"),x.query=t?a.decode(g.search.substr(1)):x.search.substr(1),x.pathname=U+(n?function(e){return e.replace(/['^|`]/g,(function(e){return\"%\"+e.charCodeAt().toString(16).toUpperCase()})).replace(/((?:%[0-9A-F]{2})+)/g,(function(e,t){try{return decodeURIComponent(t).split(\"\").map((function(e){var t=e.charCodeAt();return t>256||/^[a-z0-9]$/i.test(e)?e:\"%\"+t.toString(16).toUpperCase()})).join(\"\")}catch(e){return t}}))}(g.pathname):g.pathname),\"about:\"===x.protocol&&\"blank\"===x.pathname&&(x.protocol=\"\",x.pathname=\"\"),C&&\"/\"!==e[0]&&(x.pathname=x.pathname.substr(1)),u&&!f.test(u)&&\"/\"!==e.slice(-1)&&\"/\"===x.pathname&&(x.pathname=\"\"),x.path=x.pathname+x.search,x.auth=[g.username,g.password].map(decodeURIComponent).filter(Boolean).join(\":\"),x.port=g.port,w&&!x.host.endsWith(w)&&(x.host+=w,x.port=w.slice(1)),x.href=U?\"\"+x.pathname+x.search+x.hash:r(x);var q=/^(file)/.test(x.href)?[\"host\",\"hostname\"]:[];return Object.keys(x).forEach((function(e){~q.indexOf(e)||(x[e]=x[e]||null)})),x}e.parse=d,e.format=r,e.resolve=h,e.resolveObject=function(e,t){return d(h(e,t))},e.Url=l}();module.exports=o})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvbmF0aXZlLXVybC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiO0FBQUEsWUFBWSxPQUFPLGdCQUFnQixhQUFhLFVBQVUsbUJBQU8sQ0FBQywwSEFBb0MsSUFBSSxTQUFTLGdDQUFnQyxXQUFXLGtCQUFrQixpQkFBaUIsWUFBWSxZQUFZLFdBQVcsSUFBSSxzQ0FBc0MsUUFBUSxRQUFRLGlCQUFpQixpQkFBaUIsbUVBQW1FLFNBQVMsS0FBSyxTQUFTLFlBQVksUUFBUSwrR0FBK0csY0FBYyw2QkFBNkIsc0JBQXNCLDRGQUE0Riw2S0FBNkssNkJBQTZCLGlMQUFpTCx5R0FBeUcsUUFBUSxzREFBc0QsdUdBQXVHLGdCQUFnQixnQ0FBZ0MsNEJBQTRCLGdCQUFnQiw4S0FBOEssaUJBQWlCLGdHQUFnRyx3RkFBd0Ysa09BQWtPLGNBQWMsMkZBQTJGLDBFQUEwRSxJQUFJLDZEQUE2RCxJQUFJLGFBQWEsa0JBQWtCLHdGQUF3Riw0QkFBNEIsNkZBQTZGLDREQUE0RCx3S0FBd0ssMkZBQTJGLElBQUksYUFBYSxTQUFTLHlFQUF5RSxJQUFJLGVBQWUsU0FBUyxnQ0FBZ0MscU5BQXFOLG1CQUFtQixvS0FBb0ssd0NBQXdDLG9EQUFvRCwwQkFBMEIsRUFBRSxxQkFBcUIsSUFBSSx3REFBd0QscUJBQXFCLHVFQUF1RSxZQUFZLFNBQVMsVUFBVSxHQUFHLHFiQUFxYixvREFBb0QsMkNBQTJDLGlDQUFpQyxLQUFLLCtEQUErRCxpQkFBaUIsU0FBUyxHQUFHLGlCQUFpQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL25hdGl2ZS11cmwvaW5kZXguanM/NDczMSJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oKXt2YXIgZT17NDUyOmZ1bmN0aW9uKGUpe1widXNlIHN0cmljdFwiO2UuZXhwb3J0cz1yZXF1aXJlKFwibmV4dC9kaXN0L2NvbXBpbGVkL3F1ZXJ5c3RyaW5nLWVzM1wiKX19O3ZhciB0PXt9O2Z1bmN0aW9uIF9fbmNjd3Bja19yZXF1aXJlX18obyl7dmFyIGE9dFtvXTtpZihhIT09dW5kZWZpbmVkKXtyZXR1cm4gYS5leHBvcnRzfXZhciBzPXRbb109e2V4cG9ydHM6e319O3ZhciBuPXRydWU7dHJ5e2Vbb10ocyxzLmV4cG9ydHMsX19uY2N3cGNrX3JlcXVpcmVfXyk7bj1mYWxzZX1maW5hbGx5e2lmKG4pZGVsZXRlIHRbb119cmV0dXJuIHMuZXhwb3J0c31pZih0eXBlb2YgX19uY2N3cGNrX3JlcXVpcmVfXyE9PVwidW5kZWZpbmVkXCIpX19uY2N3cGNrX3JlcXVpcmVfXy5hYj1fX2Rpcm5hbWUrXCIvXCI7dmFyIG89e307IWZ1bmN0aW9uKCl7dmFyIGU9bzt2YXIgdCxhPSh0PV9fbmNjd3Bja19yZXF1aXJlX18oNDUyKSkmJlwib2JqZWN0XCI9PXR5cGVvZiB0JiZcImRlZmF1bHRcImluIHQ/dC5kZWZhdWx0OnQscz0vaHR0cHM/fGZ0cHxnb3BoZXJ8ZmlsZS87ZnVuY3Rpb24gcihlKXtcInN0cmluZ1wiPT10eXBlb2YgZSYmKGU9ZChlKSk7dmFyIHQ9ZnVuY3Rpb24oZSx0LG8pe3ZhciBhPWUuYXV0aCxzPWUuaG9zdG5hbWUsbj1lLnByb3RvY29sfHxcIlwiLHA9ZS5wYXRobmFtZXx8XCJcIixjPWUuaGFzaHx8XCJcIixpPWUucXVlcnl8fFwiXCIsdT0hMTthPWE/ZW5jb2RlVVJJQ29tcG9uZW50KGEpLnJlcGxhY2UoLyUzQS9pLFwiOlwiKStcIkBcIjpcIlwiLGUuaG9zdD91PWErZS5ob3N0OnMmJih1PWErKH5zLmluZGV4T2YoXCI6XCIpP1wiW1wiK3MrXCJdXCI6cyksZS5wb3J0JiYodSs9XCI6XCIrZS5wb3J0KSksaSYmXCJvYmplY3RcIj09dHlwZW9mIGkmJihpPXQuZW5jb2RlKGkpKTt2YXIgZj1lLnNlYXJjaHx8aSYmXCI/XCIraXx8XCJcIjtyZXR1cm4gbiYmXCI6XCIhPT1uLnN1YnN0cigtMSkmJihuKz1cIjpcIiksZS5zbGFzaGVzfHwoIW58fG8udGVzdChuKSkmJiExIT09dT8odT1cIi8vXCIrKHV8fFwiXCIpLHAmJlwiL1wiIT09cFswXSYmKHA9XCIvXCIrcCkpOnV8fCh1PVwiXCIpLGMmJlwiI1wiIT09Y1swXSYmKGM9XCIjXCIrYyksZiYmXCI/XCIhPT1mWzBdJiYoZj1cIj9cIitmKSx7cHJvdG9jb2w6bixob3N0OnUscGF0aG5hbWU6cD1wLnJlcGxhY2UoL1s/I10vZyxlbmNvZGVVUklDb21wb25lbnQpLHNlYXJjaDpmPWYucmVwbGFjZShcIiNcIixcIiUyM1wiKSxoYXNoOmN9fShlLGEscyk7cmV0dXJuXCJcIit0LnByb3RvY29sK3QuaG9zdCt0LnBhdGhuYW1lK3Quc2VhcmNoK3QuaGFzaH12YXIgbj1cImh0dHA6Ly9cIixwPVwidy53XCIsYz1uK3AsaT0vXihbYS16MC05ListXSo6XFwvXFwvXFwvKShbYS16MC05ListXTpcXC8qKT8vaSx1PS9odHRwcz98ZnRwfGdvcGhlcnxmaWxlLztmdW5jdGlvbiBoKGUsdCl7dmFyIG89XCJzdHJpbmdcIj09dHlwZW9mIGU/ZChlKTplO2U9XCJvYmplY3RcIj09dHlwZW9mIGU/cihlKTplO3ZhciBhPWQodCkscz1cIlwiO28ucHJvdG9jb2wmJiFvLnNsYXNoZXMmJihzPW8ucHJvdG9jb2wsZT1lLnJlcGxhY2Uoby5wcm90b2NvbCxcIlwiKSxzKz1cIi9cIj09PXRbMF18fFwiL1wiPT09ZVswXT9cIi9cIjpcIlwiKSxzJiZhLnByb3RvY29sJiYocz1cIlwiLGEuc2xhc2hlc3x8KHM9YS5wcm90b2NvbCx0PXQucmVwbGFjZShhLnByb3RvY29sLFwiXCIpKSk7dmFyIHA9ZS5tYXRjaChpKTtwJiYhYS5wcm90b2NvbCYmKGU9ZS5zdWJzdHIoKHM9cFsxXSsocFsyXXx8XCJcIikpLmxlbmd0aCksL15cXC9cXC9bXi9dLy50ZXN0KHQpJiYocz1zLnNsaWNlKDAsLTEpKSk7dmFyIGY9bmV3IFVSTChlLGMrXCIvXCIpLG09bmV3IFVSTCh0LGYpLnRvU3RyaW5nKCkucmVwbGFjZShjLFwiXCIpLHY9YS5wcm90b2NvbHx8by5wcm90b2NvbDtyZXR1cm4gdis9by5zbGFzaGVzfHxhLnNsYXNoZXM/XCIvL1wiOlwiXCIsIXMmJnY/bT1tLnJlcGxhY2Uobix2KTpzJiYobT1tLnJlcGxhY2UobixcIlwiKSksdS50ZXN0KG0pfHx+dC5pbmRleE9mKFwiLlwiKXx8XCIvXCI9PT1lLnNsaWNlKC0xKXx8XCIvXCI9PT10LnNsaWNlKC0xKXx8XCIvXCIhPT1tLnNsaWNlKC0xKXx8KG09bS5zbGljZSgwLC0xKSkscyYmKG09cysoXCIvXCI9PT1tWzBdP20uc3Vic3RyKDEpOm0pKSxtfWZ1bmN0aW9uIGwoKXt9bC5wcm90b3R5cGUucGFyc2U9ZCxsLnByb3RvdHlwZS5mb3JtYXQ9cixsLnByb3RvdHlwZS5yZXNvbHZlPWgsbC5wcm90b3R5cGUucmVzb2x2ZU9iamVjdD1oO3ZhciBmPS9eaHR0cHM/fGZ0cHxnb3BoZXJ8ZmlsZS8sbT0vXiguKj8pKFsjP10uKikvLHY9L14oW2EtejAtOS4rLV0qOikoXFwvezAsM30pKC4qKS9pLF89L14oW2EtejAtOS4rLV0qOik/XFwvXFwvXFwvKi9pLGI9L14oW2EtejAtOS4rLV0qOikoXFwvezAsMn0pXFxbKC4qKVxcXSQvaTtmdW5jdGlvbiBkKGUsdCxvKXtpZih2b2lkIDA9PT10JiYodD0hMSksdm9pZCAwPT09byYmKG89ITEpLGUmJlwib2JqZWN0XCI9PXR5cGVvZiBlJiZlIGluc3RhbmNlb2YgbClyZXR1cm4gZTt2YXIgcz0oZT1lLnRyaW0oKSkubWF0Y2gobSk7ZT1zP3NbMV0ucmVwbGFjZSgvXFxcXC9nLFwiL1wiKStzWzJdOmUucmVwbGFjZSgvXFxcXC9nLFwiL1wiKSxiLnRlc3QoZSkmJlwiL1wiIT09ZS5zbGljZSgtMSkmJihlKz1cIi9cIik7dmFyIG49IS8oXmphdmFzY3JpcHQpLy50ZXN0KGUpJiZlLm1hdGNoKHYpLGk9Xy50ZXN0KGUpLHU9XCJcIjtuJiYoZi50ZXN0KG5bMV0pfHwodT1uWzFdLnRvTG93ZXJDYXNlKCksZT1cIlwiK25bMl0rblszXSksblsyXXx8KGk9ITEsZi50ZXN0KG5bMV0pPyh1PW5bMV0sZT1cIlwiK25bM10pOmU9XCIvL1wiK25bM10pLDMhPT1uWzJdLmxlbmd0aCYmMSE9PW5bMl0ubGVuZ3RofHwodT1uWzFdLGU9XCIvXCIrblszXSkpO3ZhciBnLHk9KHM/c1sxXTplKS5tYXRjaCgvXmh0dHBzPzpcXC9cXC9bXi9dKyg6WzAtOV0rKSg/PVxcL3wkKS8pLHc9eSYmeVsxXSx4PW5ldyBsLEM9XCJcIixVPVwiXCI7dHJ5e2c9bmV3IFVSTChlKX1jYXRjaCh0KXtDPXQsdXx8b3x8IS9eXFwvXFwvLy50ZXN0KGUpfHwvXlxcL1xcLy4rW0AuXS8udGVzdChlKXx8KFU9XCIvXCIsZT1lLnN1YnN0cigxKSk7dHJ5e2c9bmV3IFVSTChlLGMpfWNhdGNoKGUpe3JldHVybiB4LnByb3RvY29sPXUseC5ocmVmPXUseH19eC5zbGFzaGVzPWkmJiFVLHguaG9zdD1nLmhvc3Q9PT1wP1wiXCI6Zy5ob3N0LHguaG9zdG5hbWU9Zy5ob3N0bmFtZT09PXA/XCJcIjpnLmhvc3RuYW1lLnJlcGxhY2UoLyhcXFt8XFxdKS9nLFwiXCIpLHgucHJvdG9jb2w9Qz91fHxudWxsOmcucHJvdG9jb2wseC5zZWFyY2g9Zy5zZWFyY2gucmVwbGFjZSgvXFxcXC9nLFwiJTVDXCIpLHguaGFzaD1nLmhhc2gucmVwbGFjZSgvXFxcXC9nLFwiJTVDXCIpO3ZhciBqPWUuc3BsaXQoXCIjXCIpOyF4LnNlYXJjaCYmfmpbMF0uaW5kZXhPZihcIj9cIikmJih4LnNlYXJjaD1cIj9cIikseC5oYXNofHxcIlwiIT09alsxXXx8KHguaGFzaD1cIiNcIikseC5xdWVyeT10P2EuZGVjb2RlKGcuc2VhcmNoLnN1YnN0cigxKSk6eC5zZWFyY2guc3Vic3RyKDEpLHgucGF0aG5hbWU9VSsobj9mdW5jdGlvbihlKXtyZXR1cm4gZS5yZXBsYWNlKC9bJ158YF0vZywoZnVuY3Rpb24oZSl7cmV0dXJuXCIlXCIrZS5jaGFyQ29kZUF0KCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCl9KSkucmVwbGFjZSgvKCg/OiVbMC05QS1GXXsyfSkrKS9nLChmdW5jdGlvbihlLHQpe3RyeXtyZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KHQpLnNwbGl0KFwiXCIpLm1hcCgoZnVuY3Rpb24oZSl7dmFyIHQ9ZS5jaGFyQ29kZUF0KCk7cmV0dXJuIHQ+MjU2fHwvXlthLXowLTldJC9pLnRlc3QoZSk/ZTpcIiVcIit0LnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpfSkpLmpvaW4oXCJcIil9Y2F0Y2goZSl7cmV0dXJuIHR9fSkpfShnLnBhdGhuYW1lKTpnLnBhdGhuYW1lKSxcImFib3V0OlwiPT09eC5wcm90b2NvbCYmXCJibGFua1wiPT09eC5wYXRobmFtZSYmKHgucHJvdG9jb2w9XCJcIix4LnBhdGhuYW1lPVwiXCIpLEMmJlwiL1wiIT09ZVswXSYmKHgucGF0aG5hbWU9eC5wYXRobmFtZS5zdWJzdHIoMSkpLHUmJiFmLnRlc3QodSkmJlwiL1wiIT09ZS5zbGljZSgtMSkmJlwiL1wiPT09eC5wYXRobmFtZSYmKHgucGF0aG5hbWU9XCJcIikseC5wYXRoPXgucGF0aG5hbWUreC5zZWFyY2gseC5hdXRoPVtnLnVzZXJuYW1lLGcucGFzc3dvcmRdLm1hcChkZWNvZGVVUklDb21wb25lbnQpLmZpbHRlcihCb29sZWFuKS5qb2luKFwiOlwiKSx4LnBvcnQ9Zy5wb3J0LHcmJiF4Lmhvc3QuZW5kc1dpdGgodykmJih4Lmhvc3QrPXcseC5wb3J0PXcuc2xpY2UoMSkpLHguaHJlZj1VP1wiXCIreC5wYXRobmFtZSt4LnNlYXJjaCt4Lmhhc2g6cih4KTt2YXIgcT0vXihmaWxlKS8udGVzdCh4LmhyZWYpP1tcImhvc3RcIixcImhvc3RuYW1lXCJdOltdO3JldHVybiBPYmplY3Qua2V5cyh4KS5mb3JFYWNoKChmdW5jdGlvbihlKXt+cS5pbmRleE9mKGUpfHwoeFtlXT14W2VdfHxudWxsKX0pKSx4fWUucGFyc2U9ZCxlLmZvcm1hdD1yLGUucmVzb2x2ZT1oLGUucmVzb2x2ZU9iamVjdD1mdW5jdGlvbihlLHQpe3JldHVybiBkKGgoZSx0KSl9LGUuVXJsPWx9KCk7bW9kdWxlLmV4cG9ydHM9b30pKCk7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/native-url/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/process/browser.js":
/*!************************************************************!*\
  !*** ./node_modules/next/dist/compiled/process/browser.js ***!
  \************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var __dirname = \"/\";\n(function(){var e={229:function(e){var t=e.exports={};var r;var n;function defaultSetTimout(){throw new Error(\"setTimeout has not been defined\")}function defaultClearTimeout(){throw new Error(\"clearTimeout has not been defined\")}(function(){try{if(typeof setTimeout===\"function\"){r=setTimeout}else{r=defaultSetTimout}}catch(e){r=defaultSetTimout}try{if(typeof clearTimeout===\"function\"){n=clearTimeout}else{n=defaultClearTimeout}}catch(e){n=defaultClearTimeout}})();function runTimeout(e){if(r===setTimeout){return setTimeout(e,0)}if((r===defaultSetTimout||!r)&&setTimeout){r=setTimeout;return setTimeout(e,0)}try{return r(e,0)}catch(t){try{return r.call(null,e,0)}catch(t){return r.call(this,e,0)}}}function runClearTimeout(e){if(n===clearTimeout){return clearTimeout(e)}if((n===defaultClearTimeout||!n)&&clearTimeout){n=clearTimeout;return clearTimeout(e)}try{return n(e)}catch(t){try{return n.call(null,e)}catch(t){return n.call(this,e)}}}var i=[];var o=false;var u;var a=-1;function cleanUpNextTick(){if(!o||!u){return}o=false;if(u.length){i=u.concat(i)}else{a=-1}if(i.length){drainQueue()}}function drainQueue(){if(o){return}var e=runTimeout(cleanUpNextTick);o=true;var t=i.length;while(t){u=i;i=[];while(++a<t){if(u){u[a].run()}}a=-1;t=i.length}u=null;o=false;runClearTimeout(e)}t.nextTick=function(e){var t=new Array(arguments.length-1);if(arguments.length>1){for(var r=1;r<arguments.length;r++){t[r-1]=arguments[r]}}i.push(new Item(e,t));if(i.length===1&&!o){runTimeout(drainQueue)}};function Item(e,t){this.fun=e;this.array=t}Item.prototype.run=function(){this.fun.apply(null,this.array)};t.title=\"browser\";t.browser=true;t.env={};t.argv=[];t.version=\"\";t.versions={};function noop(){}t.on=noop;t.addListener=noop;t.once=noop;t.off=noop;t.removeListener=noop;t.removeAllListeners=noop;t.emit=noop;t.prependListener=noop;t.prependOnceListener=noop;t.listeners=function(e){return[]};t.binding=function(e){throw new Error(\"process.binding is not supported\")};t.cwd=function(){return\"/\"};t.chdir=function(e){throw new Error(\"process.chdir is not supported\")};t.umask=function(){return 0}}};var t={};function __nccwpck_require__(r){var n=t[r];if(n!==undefined){return n.exports}var i=t[r]={exports:{}};var o=true;try{e[r](i,i.exports,__nccwpck_require__);o=false}finally{if(o)delete t[r]}return i.exports}if(typeof __nccwpck_require__!==\"undefined\")__nccwpck_require__.ab=__dirname+\"/\";var r=__nccwpck_require__(229);module.exports=r})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcHJvY2Vzcy9icm93c2VyLmpzIiwibWFwcGluZ3MiOiI7QUFBQSxZQUFZLE9BQU8sZ0JBQWdCLG1CQUFtQixNQUFNLE1BQU0sNEJBQTRCLG1EQUFtRCwrQkFBK0IscURBQXFELFlBQVksSUFBSSxtQ0FBbUMsYUFBYSxLQUFLLG9CQUFvQixTQUFTLG1CQUFtQixJQUFJLHFDQUFxQyxlQUFlLEtBQUssdUJBQXVCLFNBQVMsdUJBQXVCLElBQUksdUJBQXVCLG1CQUFtQix1QkFBdUIsMkNBQTJDLGFBQWEsdUJBQXVCLElBQUksY0FBYyxTQUFTLElBQUksd0JBQXdCLFNBQVMsMEJBQTBCLDRCQUE0QixxQkFBcUIsdUJBQXVCLGdEQUFnRCxlQUFlLHVCQUF1QixJQUFJLFlBQVksU0FBUyxJQUFJLHNCQUFzQixTQUFTLHdCQUF3QixTQUFTLFlBQVksTUFBTSxTQUFTLDJCQUEyQixXQUFXLE9BQU8sUUFBUSxhQUFhLGNBQWMsS0FBSyxLQUFLLGFBQWEsY0FBYyxzQkFBc0IsTUFBTSxPQUFPLGtDQUFrQyxPQUFPLGVBQWUsU0FBUyxJQUFJLEtBQUssYUFBYSxNQUFNLFlBQVksS0FBSyxXQUFXLE9BQU8sUUFBUSxtQkFBbUIsdUJBQXVCLG9DQUFvQyx1QkFBdUIsWUFBWSxtQkFBbUIsS0FBSyxxQkFBcUIsc0JBQXNCLHFCQUFxQix5QkFBeUIsbUJBQW1CLFdBQVcsYUFBYSw4QkFBOEIsaUNBQWlDLGtCQUFrQixlQUFlLFNBQVMsVUFBVSxhQUFhLGNBQWMsaUJBQWlCLFVBQVUsbUJBQW1CLFlBQVksV0FBVyxzQkFBc0IsMEJBQTBCLFlBQVksdUJBQXVCLDJCQUEyQix3QkFBd0IsVUFBVSxzQkFBc0IscURBQXFELGlCQUFpQixXQUFXLG9CQUFvQixtREFBbUQsbUJBQW1CLFlBQVksU0FBUyxnQ0FBZ0MsV0FBVyxrQkFBa0IsaUJBQWlCLFlBQVksWUFBWSxXQUFXLElBQUksc0NBQXNDLFFBQVEsUUFBUSxpQkFBaUIsaUJBQWlCLG1FQUFtRSxTQUFTLEtBQUssK0JBQStCLGlCQUFpQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3Byb2Nlc3MvYnJvd3Nlci5qcz82YzRhIl0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe3ZhciBlPXsyMjk6ZnVuY3Rpb24oZSl7dmFyIHQ9ZS5leHBvcnRzPXt9O3ZhciByO3ZhciBuO2Z1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKXt0aHJvdyBuZXcgRXJyb3IoXCJzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkXCIpfWZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQoKXt0aHJvdyBuZXcgRXJyb3IoXCJjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWRcIil9KGZ1bmN0aW9uKCl7dHJ5e2lmKHR5cGVvZiBzZXRUaW1lb3V0PT09XCJmdW5jdGlvblwiKXtyPXNldFRpbWVvdXR9ZWxzZXtyPWRlZmF1bHRTZXRUaW1vdXR9fWNhdGNoKGUpe3I9ZGVmYXVsdFNldFRpbW91dH10cnl7aWYodHlwZW9mIGNsZWFyVGltZW91dD09PVwiZnVuY3Rpb25cIil7bj1jbGVhclRpbWVvdXR9ZWxzZXtuPWRlZmF1bHRDbGVhclRpbWVvdXR9fWNhdGNoKGUpe249ZGVmYXVsdENsZWFyVGltZW91dH19KSgpO2Z1bmN0aW9uIHJ1blRpbWVvdXQoZSl7aWYocj09PXNldFRpbWVvdXQpe3JldHVybiBzZXRUaW1lb3V0KGUsMCl9aWYoKHI9PT1kZWZhdWx0U2V0VGltb3V0fHwhcikmJnNldFRpbWVvdXQpe3I9c2V0VGltZW91dDtyZXR1cm4gc2V0VGltZW91dChlLDApfXRyeXtyZXR1cm4gcihlLDApfWNhdGNoKHQpe3RyeXtyZXR1cm4gci5jYWxsKG51bGwsZSwwKX1jYXRjaCh0KXtyZXR1cm4gci5jYWxsKHRoaXMsZSwwKX19fWZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChlKXtpZihuPT09Y2xlYXJUaW1lb3V0KXtyZXR1cm4gY2xlYXJUaW1lb3V0KGUpfWlmKChuPT09ZGVmYXVsdENsZWFyVGltZW91dHx8IW4pJiZjbGVhclRpbWVvdXQpe249Y2xlYXJUaW1lb3V0O3JldHVybiBjbGVhclRpbWVvdXQoZSl9dHJ5e3JldHVybiBuKGUpfWNhdGNoKHQpe3RyeXtyZXR1cm4gbi5jYWxsKG51bGwsZSl9Y2F0Y2godCl7cmV0dXJuIG4uY2FsbCh0aGlzLGUpfX19dmFyIGk9W107dmFyIG89ZmFsc2U7dmFyIHU7dmFyIGE9LTE7ZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCl7aWYoIW98fCF1KXtyZXR1cm59bz1mYWxzZTtpZih1Lmxlbmd0aCl7aT11LmNvbmNhdChpKX1lbHNle2E9LTF9aWYoaS5sZW5ndGgpe2RyYWluUXVldWUoKX19ZnVuY3Rpb24gZHJhaW5RdWV1ZSgpe2lmKG8pe3JldHVybn12YXIgZT1ydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7bz10cnVlO3ZhciB0PWkubGVuZ3RoO3doaWxlKHQpe3U9aTtpPVtdO3doaWxlKCsrYTx0KXtpZih1KXt1W2FdLnJ1bigpfX1hPS0xO3Q9aS5sZW5ndGh9dT1udWxsO289ZmFsc2U7cnVuQ2xlYXJUaW1lb3V0KGUpfXQubmV4dFRpY2s9ZnVuY3Rpb24oZSl7dmFyIHQ9bmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgtMSk7aWYoYXJndW1lbnRzLmxlbmd0aD4xKXtmb3IodmFyIHI9MTtyPGFyZ3VtZW50cy5sZW5ndGg7cisrKXt0W3ItMV09YXJndW1lbnRzW3JdfX1pLnB1c2gobmV3IEl0ZW0oZSx0KSk7aWYoaS5sZW5ndGg9PT0xJiYhbyl7cnVuVGltZW91dChkcmFpblF1ZXVlKX19O2Z1bmN0aW9uIEl0ZW0oZSx0KXt0aGlzLmZ1bj1lO3RoaXMuYXJyYXk9dH1JdGVtLnByb3RvdHlwZS5ydW49ZnVuY3Rpb24oKXt0aGlzLmZ1bi5hcHBseShudWxsLHRoaXMuYXJyYXkpfTt0LnRpdGxlPVwiYnJvd3NlclwiO3QuYnJvd3Nlcj10cnVlO3QuZW52PXt9O3QuYXJndj1bXTt0LnZlcnNpb249XCJcIjt0LnZlcnNpb25zPXt9O2Z1bmN0aW9uIG5vb3AoKXt9dC5vbj1ub29wO3QuYWRkTGlzdGVuZXI9bm9vcDt0Lm9uY2U9bm9vcDt0Lm9mZj1ub29wO3QucmVtb3ZlTGlzdGVuZXI9bm9vcDt0LnJlbW92ZUFsbExpc3RlbmVycz1ub29wO3QuZW1pdD1ub29wO3QucHJlcGVuZExpc3RlbmVyPW5vb3A7dC5wcmVwZW5kT25jZUxpc3RlbmVyPW5vb3A7dC5saXN0ZW5lcnM9ZnVuY3Rpb24oZSl7cmV0dXJuW119O3QuYmluZGluZz1mdW5jdGlvbihlKXt0aHJvdyBuZXcgRXJyb3IoXCJwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZFwiKX07dC5jd2Q9ZnVuY3Rpb24oKXtyZXR1cm5cIi9cIn07dC5jaGRpcj1mdW5jdGlvbihlKXt0aHJvdyBuZXcgRXJyb3IoXCJwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWRcIil9O3QudW1hc2s9ZnVuY3Rpb24oKXtyZXR1cm4gMH19fTt2YXIgdD17fTtmdW5jdGlvbiBfX25jY3dwY2tfcmVxdWlyZV9fKHIpe3ZhciBuPXRbcl07aWYobiE9PXVuZGVmaW5lZCl7cmV0dXJuIG4uZXhwb3J0c312YXIgaT10W3JdPXtleHBvcnRzOnt9fTt2YXIgbz10cnVlO3RyeXtlW3JdKGksaS5leHBvcnRzLF9fbmNjd3Bja19yZXF1aXJlX18pO289ZmFsc2V9ZmluYWxseXtpZihvKWRlbGV0ZSB0W3JdfXJldHVybiBpLmV4cG9ydHN9aWYodHlwZW9mIF9fbmNjd3Bja19yZXF1aXJlX18hPT1cInVuZGVmaW5lZFwiKV9fbmNjd3Bja19yZXF1aXJlX18uYWI9X19kaXJuYW1lK1wiL1wiO3ZhciByPV9fbmNjd3Bja19yZXF1aXJlX18oMjI5KTttb2R1bGUuZXhwb3J0cz1yfSkoKTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/process/browser.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/querystring-es3/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/compiled/querystring-es3/index.js ***!
  \******************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var __dirname = \"/\";\n(function(){\"use strict\";var e={815:function(e){function hasOwnProperty(e,r){return Object.prototype.hasOwnProperty.call(e,r)}e.exports=function(e,n,t,o){n=n||\"&\";t=t||\"=\";var a={};if(typeof e!==\"string\"||e.length===0){return a}var i=/\\+/g;e=e.split(n);var u=1e3;if(o&&typeof o.maxKeys===\"number\"){u=o.maxKeys}var c=e.length;if(u>0&&c>u){c=u}for(var p=0;p<c;++p){var f=e[p].replace(i,\"%20\"),s=f.indexOf(t),_,l,y,d;if(s>=0){_=f.substr(0,s);l=f.substr(s+1)}else{_=f;l=\"\"}y=decodeURIComponent(_);d=decodeURIComponent(l);if(!hasOwnProperty(a,y)){a[y]=d}else if(r(a[y])){a[y].push(d)}else{a[y]=[a[y],d]}}return a};var r=Array.isArray||function(e){return Object.prototype.toString.call(e)===\"[object Array]\"}},577:function(e){var stringifyPrimitive=function(e){switch(typeof e){case\"string\":return e;case\"boolean\":return e?\"true\":\"false\";case\"number\":return isFinite(e)?e:\"\";default:return\"\"}};e.exports=function(e,t,o,a){t=t||\"&\";o=o||\"=\";if(e===null){e=undefined}if(typeof e===\"object\"){return map(n(e),(function(n){var a=encodeURIComponent(stringifyPrimitive(n))+o;if(r(e[n])){return map(e[n],(function(e){return a+encodeURIComponent(stringifyPrimitive(e))})).join(t)}else{return a+encodeURIComponent(stringifyPrimitive(e[n]))}})).join(t)}if(!a)return\"\";return encodeURIComponent(stringifyPrimitive(a))+o+encodeURIComponent(stringifyPrimitive(e))};var r=Array.isArray||function(e){return Object.prototype.toString.call(e)===\"[object Array]\"};function map(e,r){if(e.map)return e.map(r);var n=[];for(var t=0;t<e.length;t++){n.push(r(e[t],t))}return n}var n=Object.keys||function(e){var r=[];for(var n in e){if(Object.prototype.hasOwnProperty.call(e,n))r.push(n)}return r}}};var r={};function __nccwpck_require__(n){var t=r[n];if(t!==undefined){return t.exports}var o=r[n]={exports:{}};var a=true;try{e[n](o,o.exports,__nccwpck_require__);a=false}finally{if(a)delete r[n]}return o.exports}if(typeof __nccwpck_require__!==\"undefined\")__nccwpck_require__.ab=__dirname+\"/\";var n={};!function(){var e=n;e.decode=e.parse=__nccwpck_require__(815);e.encode=e.stringify=__nccwpck_require__(577)}();module.exports=n})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcXVlcnlzdHJpbmctZXMzL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7QUFBQSxZQUFZLGFBQWEsT0FBTyxnQkFBZ0IsNkJBQTZCLGlEQUFpRCw0QkFBNEIsU0FBUyxTQUFTLFNBQVMsc0NBQXNDLFNBQVMsWUFBWSxhQUFhLFVBQVUsbUNBQW1DLFlBQVksZUFBZSxhQUFhLElBQUksWUFBWSxJQUFJLEtBQUssbURBQW1ELFNBQVMsZ0JBQWdCLGdCQUFnQixLQUFLLElBQUksS0FBSyx3QkFBd0Isd0JBQXdCLHlCQUF5QixPQUFPLGlCQUFpQixhQUFhLEtBQUssZUFBZSxVQUFVLGlDQUFpQyw2REFBNkQsaUJBQWlCLG1DQUFtQyxpQkFBaUIsc0JBQXNCLHNDQUFzQyxxQ0FBcUMsbUJBQW1CLDRCQUE0QixTQUFTLFNBQVMsYUFBYSxZQUFZLHdCQUF3Qiw2QkFBNkIsa0RBQWtELFlBQVksNkJBQTZCLG1EQUFtRCxXQUFXLEtBQUssdURBQXVELFdBQVcsZUFBZSw4RkFBOEYsaUNBQWlDLDZEQUE2RCxrQkFBa0IseUJBQXlCLFNBQVMsWUFBWSxXQUFXLEtBQUssa0JBQWtCLFNBQVMsK0JBQStCLFNBQVMsZ0JBQWdCLHVEQUF1RCxZQUFZLFNBQVMsZ0NBQWdDLFdBQVcsa0JBQWtCLGlCQUFpQixZQUFZLFlBQVksV0FBVyxJQUFJLHNDQUFzQyxRQUFRLFFBQVEsaUJBQWlCLGlCQUFpQixtRUFBbUUsU0FBUyxLQUFLLFNBQVMsWUFBWSxRQUFRLDBDQUEwQyw4Q0FBOEMsR0FBRyxpQkFBaUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9xdWVyeXN0cmluZy1lczMvaW5kZXguanM/MWM1YSJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oKXtcInVzZSBzdHJpY3RcIjt2YXIgZT17ODE1OmZ1bmN0aW9uKGUpe2Z1bmN0aW9uIGhhc093blByb3BlcnR5KGUscil7cmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLHIpfWUuZXhwb3J0cz1mdW5jdGlvbihlLG4sdCxvKXtuPW58fFwiJlwiO3Q9dHx8XCI9XCI7dmFyIGE9e307aWYodHlwZW9mIGUhPT1cInN0cmluZ1wifHxlLmxlbmd0aD09PTApe3JldHVybiBhfXZhciBpPS9cXCsvZztlPWUuc3BsaXQobik7dmFyIHU9MWUzO2lmKG8mJnR5cGVvZiBvLm1heEtleXM9PT1cIm51bWJlclwiKXt1PW8ubWF4S2V5c312YXIgYz1lLmxlbmd0aDtpZih1PjAmJmM+dSl7Yz11fWZvcih2YXIgcD0wO3A8YzsrK3Ape3ZhciBmPWVbcF0ucmVwbGFjZShpLFwiJTIwXCIpLHM9Zi5pbmRleE9mKHQpLF8sbCx5LGQ7aWYocz49MCl7Xz1mLnN1YnN0cigwLHMpO2w9Zi5zdWJzdHIocysxKX1lbHNle189ZjtsPVwiXCJ9eT1kZWNvZGVVUklDb21wb25lbnQoXyk7ZD1kZWNvZGVVUklDb21wb25lbnQobCk7aWYoIWhhc093blByb3BlcnR5KGEseSkpe2FbeV09ZH1lbHNlIGlmKHIoYVt5XSkpe2FbeV0ucHVzaChkKX1lbHNle2FbeV09W2FbeV0sZF19fXJldHVybiBhfTt2YXIgcj1BcnJheS5pc0FycmF5fHxmdW5jdGlvbihlKXtyZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGUpPT09XCJbb2JqZWN0IEFycmF5XVwifX0sNTc3OmZ1bmN0aW9uKGUpe3ZhciBzdHJpbmdpZnlQcmltaXRpdmU9ZnVuY3Rpb24oZSl7c3dpdGNoKHR5cGVvZiBlKXtjYXNlXCJzdHJpbmdcIjpyZXR1cm4gZTtjYXNlXCJib29sZWFuXCI6cmV0dXJuIGU/XCJ0cnVlXCI6XCJmYWxzZVwiO2Nhc2VcIm51bWJlclwiOnJldHVybiBpc0Zpbml0ZShlKT9lOlwiXCI7ZGVmYXVsdDpyZXR1cm5cIlwifX07ZS5leHBvcnRzPWZ1bmN0aW9uKGUsdCxvLGEpe3Q9dHx8XCImXCI7bz1vfHxcIj1cIjtpZihlPT09bnVsbCl7ZT11bmRlZmluZWR9aWYodHlwZW9mIGU9PT1cIm9iamVjdFwiKXtyZXR1cm4gbWFwKG4oZSksKGZ1bmN0aW9uKG4pe3ZhciBhPWVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUobikpK287aWYocihlW25dKSl7cmV0dXJuIG1hcChlW25dLChmdW5jdGlvbihlKXtyZXR1cm4gYStlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKGUpKX0pKS5qb2luKHQpfWVsc2V7cmV0dXJuIGErZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShlW25dKSl9fSkpLmpvaW4odCl9aWYoIWEpcmV0dXJuXCJcIjtyZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShhKSkrbytlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKGUpKX07dmFyIHI9QXJyYXkuaXNBcnJheXx8ZnVuY3Rpb24oZSl7cmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChlKT09PVwiW29iamVjdCBBcnJheV1cIn07ZnVuY3Rpb24gbWFwKGUscil7aWYoZS5tYXApcmV0dXJuIGUubWFwKHIpO3ZhciBuPVtdO2Zvcih2YXIgdD0wO3Q8ZS5sZW5ndGg7dCsrKXtuLnB1c2gocihlW3RdLHQpKX1yZXR1cm4gbn12YXIgbj1PYmplY3Qua2V5c3x8ZnVuY3Rpb24oZSl7dmFyIHI9W107Zm9yKHZhciBuIGluIGUpe2lmKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLG4pKXIucHVzaChuKX1yZXR1cm4gcn19fTt2YXIgcj17fTtmdW5jdGlvbiBfX25jY3dwY2tfcmVxdWlyZV9fKG4pe3ZhciB0PXJbbl07aWYodCE9PXVuZGVmaW5lZCl7cmV0dXJuIHQuZXhwb3J0c312YXIgbz1yW25dPXtleHBvcnRzOnt9fTt2YXIgYT10cnVlO3RyeXtlW25dKG8sby5leHBvcnRzLF9fbmNjd3Bja19yZXF1aXJlX18pO2E9ZmFsc2V9ZmluYWxseXtpZihhKWRlbGV0ZSByW25dfXJldHVybiBvLmV4cG9ydHN9aWYodHlwZW9mIF9fbmNjd3Bja19yZXF1aXJlX18hPT1cInVuZGVmaW5lZFwiKV9fbmNjd3Bja19yZXF1aXJlX18uYWI9X19kaXJuYW1lK1wiL1wiO3ZhciBuPXt9OyFmdW5jdGlvbigpe3ZhciBlPW47ZS5kZWNvZGU9ZS5wYXJzZT1fX25jY3dwY2tfcmVxdWlyZV9fKDgxNSk7ZS5lbmNvZGU9ZS5zdHJpbmdpZnk9X19uY2N3cGNrX3JlcXVpcmVfXyg1NzcpfSgpO21vZHVsZS5leHBvcnRzPW59KSgpOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/querystring-es3/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/prop-types/checkPropTypes.js":
/*!***************************************************!*\
  !*** ./node_modules/prop-types/checkPropTypes.js ***!
  \***************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nvar printWarning = function() {};\n\nif (true) {\n  var ReactPropTypesSecret = __webpack_require__(/*! ./lib/ReactPropTypesSecret */ \"(app-pages-browser)/./node_modules/prop-types/lib/ReactPropTypesSecret.js\");\n  var loggedTypeFailures = {};\n  var has = __webpack_require__(/*! ./lib/has */ \"(app-pages-browser)/./node_modules/prop-types/lib/has.js\");\n\n  printWarning = function(text) {\n    var message = 'Warning: ' + text;\n    if (typeof console !== 'undefined') {\n      console.error(message);\n    }\n    try {\n      // --- Welcome to debugging React ---\n      // This error was thrown as a convenience so that you can use this stack\n      // to find the callsite that caused this warning to fire.\n      throw new Error(message);\n    } catch (x) { /**/ }\n  };\n}\n\n/**\n * Assert that the values match with the type specs.\n * Error messages are memorized and will only be shown once.\n *\n * @param {object} typeSpecs Map of name to a ReactPropType\n * @param {object} values Runtime values that need to be type-checked\n * @param {string} location e.g. \"prop\", \"context\", \"child context\"\n * @param {string} componentName Name of the component for error messages.\n * @param {?Function} getStack Returns the component stack.\n * @private\n */\nfunction checkPropTypes(typeSpecs, values, location, componentName, getStack) {\n  if (true) {\n    for (var typeSpecName in typeSpecs) {\n      if (has(typeSpecs, typeSpecName)) {\n        var error;\n        // Prop type validation may throw. In case they do, we don't want to\n        // fail the render phase where it didn't fail before. So we log it.\n        // After these have been cleaned up, we'll let them throw.\n        try {\n          // This is intentionally an invariant that gets caught. It's the same\n          // behavior as without this statement except with a better message.\n          if (typeof typeSpecs[typeSpecName] !== 'function') {\n            var err = Error(\n              (componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' +\n              'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' +\n              'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.'\n            );\n            err.name = 'Invariant Violation';\n            throw err;\n          }\n          error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);\n        } catch (ex) {\n          error = ex;\n        }\n        if (error && !(error instanceof Error)) {\n          printWarning(\n            (componentName || 'React class') + ': type specification of ' +\n            location + ' `' + typeSpecName + '` is invalid; the type checker ' +\n            'function must return `null` or an `Error` but returned a ' + typeof error + '. ' +\n            'You may have forgotten to pass an argument to the type checker ' +\n            'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' +\n            'shape all require an argument).'\n          );\n        }\n        if (error instanceof Error && !(error.message in loggedTypeFailures)) {\n          // Only monitor this failure once because there tends to be a lot of the\n          // same error.\n          loggedTypeFailures[error.message] = true;\n\n          var stack = getStack ? getStack() : '';\n\n          printWarning(\n            'Failed ' + location + ' type: ' + error.message + (stack != null ? stack : '')\n          );\n        }\n      }\n    }\n  }\n}\n\n/**\n * Resets warning cache when testing.\n *\n * @private\n */\ncheckPropTypes.resetWarningCache = function() {\n  if (true) {\n    loggedTypeFailures = {};\n  }\n}\n\nmodule.exports = checkPropTypes;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2NoZWNrUHJvcFR5cGVzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYjs7QUFFQSxJQUFJLElBQXFDO0FBQ3pDLDZCQUE2QixtQkFBTyxDQUFDLDZHQUE0QjtBQUNqRTtBQUNBLFlBQVksbUJBQU8sQ0FBQywyRUFBVzs7QUFFL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLFlBQVk7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFdBQVc7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsTUFBTSxJQUFxQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkdBQTZHO0FBQzdHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLElBQXFDO0FBQzNDO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9jaGVja1Byb3BUeXBlcy5qcz9mOGRkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgcHJpbnRXYXJuaW5nID0gZnVuY3Rpb24oKSB7fTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gcmVxdWlyZSgnLi9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQnKTtcbiAgdmFyIGxvZ2dlZFR5cGVGYWlsdXJlcyA9IHt9O1xuICB2YXIgaGFzID0gcmVxdWlyZSgnLi9saWIvaGFzJyk7XG5cbiAgcHJpbnRXYXJuaW5nID0gZnVuY3Rpb24odGV4dCkge1xuICAgIHZhciBtZXNzYWdlID0gJ1dhcm5pbmc6ICcgKyB0ZXh0O1xuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAvLyAtLS0gV2VsY29tZSB0byBkZWJ1Z2dpbmcgUmVhY3QgLS0tXG4gICAgICAvLyBUaGlzIGVycm9yIHdhcyB0aHJvd24gYXMgYSBjb252ZW5pZW5jZSBzbyB0aGF0IHlvdSBjYW4gdXNlIHRoaXMgc3RhY2tcbiAgICAgIC8vIHRvIGZpbmQgdGhlIGNhbGxzaXRlIHRoYXQgY2F1c2VkIHRoaXMgd2FybmluZyB0byBmaXJlLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIH0gY2F0Y2ggKHgpIHsgLyoqLyB9XG4gIH07XG59XG5cbi8qKlxuICogQXNzZXJ0IHRoYXQgdGhlIHZhbHVlcyBtYXRjaCB3aXRoIHRoZSB0eXBlIHNwZWNzLlxuICogRXJyb3IgbWVzc2FnZXMgYXJlIG1lbW9yaXplZCBhbmQgd2lsbCBvbmx5IGJlIHNob3duIG9uY2UuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IHR5cGVTcGVjcyBNYXAgb2YgbmFtZSB0byBhIFJlYWN0UHJvcFR5cGVcbiAqIEBwYXJhbSB7b2JqZWN0fSB2YWx1ZXMgUnVudGltZSB2YWx1ZXMgdGhhdCBuZWVkIHRvIGJlIHR5cGUtY2hlY2tlZFxuICogQHBhcmFtIHtzdHJpbmd9IGxvY2F0aW9uIGUuZy4gXCJwcm9wXCIsIFwiY29udGV4dFwiLCBcImNoaWxkIGNvbnRleHRcIlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbXBvbmVudE5hbWUgTmFtZSBvZiB0aGUgY29tcG9uZW50IGZvciBlcnJvciBtZXNzYWdlcy5cbiAqIEBwYXJhbSB7P0Z1bmN0aW9ufSBnZXRTdGFjayBSZXR1cm5zIHRoZSBjb21wb25lbnQgc3RhY2suXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjaGVja1Byb3BUeXBlcyh0eXBlU3BlY3MsIHZhbHVlcywgbG9jYXRpb24sIGNvbXBvbmVudE5hbWUsIGdldFN0YWNrKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgZm9yICh2YXIgdHlwZVNwZWNOYW1lIGluIHR5cGVTcGVjcykge1xuICAgICAgaWYgKGhhcyh0eXBlU3BlY3MsIHR5cGVTcGVjTmFtZSkpIHtcbiAgICAgICAgdmFyIGVycm9yO1xuICAgICAgICAvLyBQcm9wIHR5cGUgdmFsaWRhdGlvbiBtYXkgdGhyb3cuIEluIGNhc2UgdGhleSBkbywgd2UgZG9uJ3Qgd2FudCB0b1xuICAgICAgICAvLyBmYWlsIHRoZSByZW5kZXIgcGhhc2Ugd2hlcmUgaXQgZGlkbid0IGZhaWwgYmVmb3JlLiBTbyB3ZSBsb2cgaXQuXG4gICAgICAgIC8vIEFmdGVyIHRoZXNlIGhhdmUgYmVlbiBjbGVhbmVkIHVwLCB3ZSdsbCBsZXQgdGhlbSB0aHJvdy5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBUaGlzIGlzIGludGVudGlvbmFsbHkgYW4gaW52YXJpYW50IHRoYXQgZ2V0cyBjYXVnaHQuIEl0J3MgdGhlIHNhbWVcbiAgICAgICAgICAvLyBiZWhhdmlvciBhcyB3aXRob3V0IHRoaXMgc3RhdGVtZW50IGV4Y2VwdCB3aXRoIGEgYmV0dGVyIG1lc3NhZ2UuXG4gICAgICAgICAgaWYgKHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdmFyIGVyciA9IEVycm9yKFxuICAgICAgICAgICAgICAoY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnKSArICc6ICcgKyBsb2NhdGlvbiArICcgdHlwZSBgJyArIHR5cGVTcGVjTmFtZSArICdgIGlzIGludmFsaWQ7ICcgK1xuICAgICAgICAgICAgICAnaXQgbXVzdCBiZSBhIGZ1bmN0aW9uLCB1c3VhbGx5IGZyb20gdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLCBidXQgcmVjZWl2ZWQgYCcgKyB0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gKyAnYC4nICtcbiAgICAgICAgICAgICAgJ1RoaXMgb2Z0ZW4gaGFwcGVucyBiZWNhdXNlIG9mIHR5cG9zIHN1Y2ggYXMgYFByb3BUeXBlcy5mdW5jdGlvbmAgaW5zdGVhZCBvZiBgUHJvcFR5cGVzLmZ1bmNgLidcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBlcnIubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZXJyb3IgPSB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSh2YWx1ZXMsIHR5cGVTcGVjTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIG51bGwsIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICBlcnJvciA9IGV4O1xuICAgICAgICB9XG4gICAgICAgIGlmIChlcnJvciAmJiAhKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpKSB7XG4gICAgICAgICAgcHJpbnRXYXJuaW5nKFxuICAgICAgICAgICAgKGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJykgKyAnOiB0eXBlIHNwZWNpZmljYXRpb24gb2YgJyArXG4gICAgICAgICAgICBsb2NhdGlvbiArICcgYCcgKyB0eXBlU3BlY05hbWUgKyAnYCBpcyBpbnZhbGlkOyB0aGUgdHlwZSBjaGVja2VyICcgK1xuICAgICAgICAgICAgJ2Z1bmN0aW9uIG11c3QgcmV0dXJuIGBudWxsYCBvciBhbiBgRXJyb3JgIGJ1dCByZXR1cm5lZCBhICcgKyB0eXBlb2YgZXJyb3IgKyAnLiAnICtcbiAgICAgICAgICAgICdZb3UgbWF5IGhhdmUgZm9yZ290dGVuIHRvIHBhc3MgYW4gYXJndW1lbnQgdG8gdGhlIHR5cGUgY2hlY2tlciAnICtcbiAgICAgICAgICAgICdjcmVhdG9yIChhcnJheU9mLCBpbnN0YW5jZU9mLCBvYmplY3RPZiwgb25lT2YsIG9uZU9mVHlwZSwgYW5kICcgK1xuICAgICAgICAgICAgJ3NoYXBlIGFsbCByZXF1aXJlIGFuIGFyZ3VtZW50KS4nXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiAhKGVycm9yLm1lc3NhZ2UgaW4gbG9nZ2VkVHlwZUZhaWx1cmVzKSkge1xuICAgICAgICAgIC8vIE9ubHkgbW9uaXRvciB0aGlzIGZhaWx1cmUgb25jZSBiZWNhdXNlIHRoZXJlIHRlbmRzIHRvIGJlIGEgbG90IG9mIHRoZVxuICAgICAgICAgIC8vIHNhbWUgZXJyb3IuXG4gICAgICAgICAgbG9nZ2VkVHlwZUZhaWx1cmVzW2Vycm9yLm1lc3NhZ2VdID0gdHJ1ZTtcblxuICAgICAgICAgIHZhciBzdGFjayA9IGdldFN0YWNrID8gZ2V0U3RhY2soKSA6ICcnO1xuXG4gICAgICAgICAgcHJpbnRXYXJuaW5nKFxuICAgICAgICAgICAgJ0ZhaWxlZCAnICsgbG9jYXRpb24gKyAnIHR5cGU6ICcgKyBlcnJvci5tZXNzYWdlICsgKHN0YWNrICE9IG51bGwgPyBzdGFjayA6ICcnKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBSZXNldHMgd2FybmluZyBjYWNoZSB3aGVuIHRlc3RpbmcuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuY2hlY2tQcm9wVHlwZXMucmVzZXRXYXJuaW5nQ2FjaGUgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBsb2dnZWRUeXBlRmFpbHVyZXMgPSB7fTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNoZWNrUHJvcFR5cGVzO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/prop-types/checkPropTypes.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/prop-types/factoryWithTypeCheckers.js":
/*!************************************************************!*\
  !*** ./node_modules/prop-types/factoryWithTypeCheckers.js ***!
  \************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nvar ReactIs = __webpack_require__(/*! react-is */ \"(app-pages-browser)/./node_modules/react-is/index.js\");\nvar assign = __webpack_require__(/*! object-assign */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/object-assign.js\");\n\nvar ReactPropTypesSecret = __webpack_require__(/*! ./lib/ReactPropTypesSecret */ \"(app-pages-browser)/./node_modules/prop-types/lib/ReactPropTypesSecret.js\");\nvar has = __webpack_require__(/*! ./lib/has */ \"(app-pages-browser)/./node_modules/prop-types/lib/has.js\");\nvar checkPropTypes = __webpack_require__(/*! ./checkPropTypes */ \"(app-pages-browser)/./node_modules/prop-types/checkPropTypes.js\");\n\nvar printWarning = function() {};\n\nif (true) {\n  printWarning = function(text) {\n    var message = 'Warning: ' + text;\n    if (typeof console !== 'undefined') {\n      console.error(message);\n    }\n    try {\n      // --- Welcome to debugging React ---\n      // This error was thrown as a convenience so that you can use this stack\n      // to find the callsite that caused this warning to fire.\n      throw new Error(message);\n    } catch (x) {}\n  };\n}\n\nfunction emptyFunctionThatReturnsNull() {\n  return null;\n}\n\nmodule.exports = function(isValidElement, throwOnDirectAccess) {\n  /* global Symbol */\n  var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;\n  var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.\n\n  /**\n   * Returns the iterator method function contained on the iterable object.\n   *\n   * Be sure to invoke the function with the iterable as context:\n   *\n   *     var iteratorFn = getIteratorFn(myIterable);\n   *     if (iteratorFn) {\n   *       var iterator = iteratorFn.call(myIterable);\n   *       ...\n   *     }\n   *\n   * @param {?object} maybeIterable\n   * @return {?function}\n   */\n  function getIteratorFn(maybeIterable) {\n    var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);\n    if (typeof iteratorFn === 'function') {\n      return iteratorFn;\n    }\n  }\n\n  /**\n   * Collection of methods that allow declaration and validation of props that are\n   * supplied to React components. Example usage:\n   *\n   *   var Props = require('ReactPropTypes');\n   *   var MyArticle = React.createClass({\n   *     propTypes: {\n   *       // An optional string prop named \"description\".\n   *       description: Props.string,\n   *\n   *       // A required enum prop named \"category\".\n   *       category: Props.oneOf(['News','Photos']).isRequired,\n   *\n   *       // A prop named \"dialog\" that requires an instance of Dialog.\n   *       dialog: Props.instanceOf(Dialog).isRequired\n   *     },\n   *     render: function() { ... }\n   *   });\n   *\n   * A more formal specification of how these methods are used:\n   *\n   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)\n   *   decl := ReactPropTypes.{type}(.isRequired)?\n   *\n   * Each and every declaration produces a function with the same signature. This\n   * allows the creation of custom validation functions. For example:\n   *\n   *  var MyLink = React.createClass({\n   *    propTypes: {\n   *      // An optional string or URI prop named \"href\".\n   *      href: function(props, propName, componentName) {\n   *        var propValue = props[propName];\n   *        if (propValue != null && typeof propValue !== 'string' &&\n   *            !(propValue instanceof URI)) {\n   *          return new Error(\n   *            'Expected a string or an URI for ' + propName + ' in ' +\n   *            componentName\n   *          );\n   *        }\n   *      }\n   *    },\n   *    render: function() {...}\n   *  });\n   *\n   * @internal\n   */\n\n  var ANONYMOUS = '<<anonymous>>';\n\n  // Important!\n  // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.\n  var ReactPropTypes = {\n    array: createPrimitiveTypeChecker('array'),\n    bigint: createPrimitiveTypeChecker('bigint'),\n    bool: createPrimitiveTypeChecker('boolean'),\n    func: createPrimitiveTypeChecker('function'),\n    number: createPrimitiveTypeChecker('number'),\n    object: createPrimitiveTypeChecker('object'),\n    string: createPrimitiveTypeChecker('string'),\n    symbol: createPrimitiveTypeChecker('symbol'),\n\n    any: createAnyTypeChecker(),\n    arrayOf: createArrayOfTypeChecker,\n    element: createElementTypeChecker(),\n    elementType: createElementTypeTypeChecker(),\n    instanceOf: createInstanceTypeChecker,\n    node: createNodeChecker(),\n    objectOf: createObjectOfTypeChecker,\n    oneOf: createEnumTypeChecker,\n    oneOfType: createUnionTypeChecker,\n    shape: createShapeTypeChecker,\n    exact: createStrictShapeTypeChecker,\n  };\n\n  /**\n   * inlined Object.is polyfill to avoid requiring consumers ship their own\n   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n   */\n  /*eslint-disable no-self-compare*/\n  function is(x, y) {\n    // SameValue algorithm\n    if (x === y) {\n      // Steps 1-5, 7-10\n      // Steps 6.b-6.e: +0 != -0\n      return x !== 0 || 1 / x === 1 / y;\n    } else {\n      // Step 6.a: NaN == NaN\n      return x !== x && y !== y;\n    }\n  }\n  /*eslint-enable no-self-compare*/\n\n  /**\n   * We use an Error-like object for backward compatibility as people may call\n   * PropTypes directly and inspect their output. However, we don't use real\n   * Errors anymore. We don't inspect their stack anyway, and creating them\n   * is prohibitively expensive if they are created too often, such as what\n   * happens in oneOfType() for any type before the one that matched.\n   */\n  function PropTypeError(message, data) {\n    this.message = message;\n    this.data = data && typeof data === 'object' ? data: {};\n    this.stack = '';\n  }\n  // Make `instanceof Error` still work for returned errors.\n  PropTypeError.prototype = Error.prototype;\n\n  function createChainableTypeChecker(validate) {\n    if (true) {\n      var manualPropTypeCallCache = {};\n      var manualPropTypeWarningCount = 0;\n    }\n    function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {\n      componentName = componentName || ANONYMOUS;\n      propFullName = propFullName || propName;\n\n      if (secret !== ReactPropTypesSecret) {\n        if (throwOnDirectAccess) {\n          // New behavior only for users of `prop-types` package\n          var err = new Error(\n            'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +\n            'Use `PropTypes.checkPropTypes()` to call them. ' +\n            'Read more at http://fb.me/use-check-prop-types'\n          );\n          err.name = 'Invariant Violation';\n          throw err;\n        } else if ( true && typeof console !== 'undefined') {\n          // Old behavior for people using React.PropTypes\n          var cacheKey = componentName + ':' + propName;\n          if (\n            !manualPropTypeCallCache[cacheKey] &&\n            // Avoid spamming the console because they are often not actionable except for lib authors\n            manualPropTypeWarningCount < 3\n          ) {\n            printWarning(\n              'You are manually calling a React.PropTypes validation ' +\n              'function for the `' + propFullName + '` prop on `' + componentName + '`. This is deprecated ' +\n              'and will throw in the standalone `prop-types` package. ' +\n              'You may be seeing this warning due to a third-party PropTypes ' +\n              'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.'\n            );\n            manualPropTypeCallCache[cacheKey] = true;\n            manualPropTypeWarningCount++;\n          }\n        }\n      }\n      if (props[propName] == null) {\n        if (isRequired) {\n          if (props[propName] === null) {\n            return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));\n          }\n          return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));\n        }\n        return null;\n      } else {\n        return validate(props, propName, componentName, location, propFullName);\n      }\n    }\n\n    var chainedCheckType = checkType.bind(null, false);\n    chainedCheckType.isRequired = checkType.bind(null, true);\n\n    return chainedCheckType;\n  }\n\n  function createPrimitiveTypeChecker(expectedType) {\n    function validate(props, propName, componentName, location, propFullName, secret) {\n      var propValue = props[propName];\n      var propType = getPropType(propValue);\n      if (propType !== expectedType) {\n        // `propValue` being instance of, say, date/regexp, pass the 'object'\n        // check, but we can offer a more precise error message here rather than\n        // 'of type `object`'.\n        var preciseType = getPreciseType(propValue);\n\n        return new PropTypeError(\n          'Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'),\n          {expectedType: expectedType}\n        );\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createAnyTypeChecker() {\n    return createChainableTypeChecker(emptyFunctionThatReturnsNull);\n  }\n\n  function createArrayOfTypeChecker(typeChecker) {\n    function validate(props, propName, componentName, location, propFullName) {\n      if (typeof typeChecker !== 'function') {\n        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');\n      }\n      var propValue = props[propName];\n      if (!Array.isArray(propValue)) {\n        var propType = getPropType(propValue);\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));\n      }\n      for (var i = 0; i < propValue.length; i++) {\n        var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);\n        if (error instanceof Error) {\n          return error;\n        }\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createElementTypeChecker() {\n    function validate(props, propName, componentName, location, propFullName) {\n      var propValue = props[propName];\n      if (!isValidElement(propValue)) {\n        var propType = getPropType(propValue);\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createElementTypeTypeChecker() {\n    function validate(props, propName, componentName, location, propFullName) {\n      var propValue = props[propName];\n      if (!ReactIs.isValidElementType(propValue)) {\n        var propType = getPropType(propValue);\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement type.'));\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createInstanceTypeChecker(expectedClass) {\n    function validate(props, propName, componentName, location, propFullName) {\n      if (!(props[propName] instanceof expectedClass)) {\n        var expectedClassName = expectedClass.name || ANONYMOUS;\n        var actualClassName = getClassName(props[propName]);\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createEnumTypeChecker(expectedValues) {\n    if (!Array.isArray(expectedValues)) {\n      if (true) {\n        if (arguments.length > 1) {\n          printWarning(\n            'Invalid arguments supplied to oneOf, expected an array, got ' + arguments.length + ' arguments. ' +\n            'A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z]).'\n          );\n        } else {\n          printWarning('Invalid argument supplied to oneOf, expected an array.');\n        }\n      }\n      return emptyFunctionThatReturnsNull;\n    }\n\n    function validate(props, propName, componentName, location, propFullName) {\n      var propValue = props[propName];\n      for (var i = 0; i < expectedValues.length; i++) {\n        if (is(propValue, expectedValues[i])) {\n          return null;\n        }\n      }\n\n      var valuesString = JSON.stringify(expectedValues, function replacer(key, value) {\n        var type = getPreciseType(value);\n        if (type === 'symbol') {\n          return String(value);\n        }\n        return value;\n      });\n      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + String(propValue) + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createObjectOfTypeChecker(typeChecker) {\n    function validate(props, propName, componentName, location, propFullName) {\n      if (typeof typeChecker !== 'function') {\n        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');\n      }\n      var propValue = props[propName];\n      var propType = getPropType(propValue);\n      if (propType !== 'object') {\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));\n      }\n      for (var key in propValue) {\n        if (has(propValue, key)) {\n          var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);\n          if (error instanceof Error) {\n            return error;\n          }\n        }\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createUnionTypeChecker(arrayOfTypeCheckers) {\n    if (!Array.isArray(arrayOfTypeCheckers)) {\n       true ? printWarning('Invalid argument supplied to oneOfType, expected an instance of array.') : 0;\n      return emptyFunctionThatReturnsNull;\n    }\n\n    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {\n      var checker = arrayOfTypeCheckers[i];\n      if (typeof checker !== 'function') {\n        printWarning(\n          'Invalid argument supplied to oneOfType. Expected an array of check functions, but ' +\n          'received ' + getPostfixForTypeWarning(checker) + ' at index ' + i + '.'\n        );\n        return emptyFunctionThatReturnsNull;\n      }\n    }\n\n    function validate(props, propName, componentName, location, propFullName) {\n      var expectedTypes = [];\n      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {\n        var checker = arrayOfTypeCheckers[i];\n        var checkerResult = checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret);\n        if (checkerResult == null) {\n          return null;\n        }\n        if (checkerResult.data && has(checkerResult.data, 'expectedType')) {\n          expectedTypes.push(checkerResult.data.expectedType);\n        }\n      }\n      var expectedTypesMessage = (expectedTypes.length > 0) ? ', expected one of type [' + expectedTypes.join(', ') + ']': '';\n      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`' + expectedTypesMessage + '.'));\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createNodeChecker() {\n    function validate(props, propName, componentName, location, propFullName) {\n      if (!isNode(props[propName])) {\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function invalidValidatorError(componentName, location, propFullName, key, type) {\n    return new PropTypeError(\n      (componentName || 'React class') + ': ' + location + ' type `' + propFullName + '.' + key + '` is invalid; ' +\n      'it must be a function, usually from the `prop-types` package, but received `' + type + '`.'\n    );\n  }\n\n  function createShapeTypeChecker(shapeTypes) {\n    function validate(props, propName, componentName, location, propFullName) {\n      var propValue = props[propName];\n      var propType = getPropType(propValue);\n      if (propType !== 'object') {\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));\n      }\n      for (var key in shapeTypes) {\n        var checker = shapeTypes[key];\n        if (typeof checker !== 'function') {\n          return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));\n        }\n        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);\n        if (error) {\n          return error;\n        }\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createStrictShapeTypeChecker(shapeTypes) {\n    function validate(props, propName, componentName, location, propFullName) {\n      var propValue = props[propName];\n      var propType = getPropType(propValue);\n      if (propType !== 'object') {\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));\n      }\n      // We need to check all keys in case some are required but missing from props.\n      var allKeys = assign({}, props[propName], shapeTypes);\n      for (var key in allKeys) {\n        var checker = shapeTypes[key];\n        if (has(shapeTypes, key) && typeof checker !== 'function') {\n          return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));\n        }\n        if (!checker) {\n          return new PropTypeError(\n            'Invalid ' + location + ' `' + propFullName + '` key `' + key + '` supplied to `' + componentName + '`.' +\n            '\\nBad object: ' + JSON.stringify(props[propName], null, '  ') +\n            '\\nValid keys: ' + JSON.stringify(Object.keys(shapeTypes), null, '  ')\n          );\n        }\n        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);\n        if (error) {\n          return error;\n        }\n      }\n      return null;\n    }\n\n    return createChainableTypeChecker(validate);\n  }\n\n  function isNode(propValue) {\n    switch (typeof propValue) {\n      case 'number':\n      case 'string':\n      case 'undefined':\n        return true;\n      case 'boolean':\n        return !propValue;\n      case 'object':\n        if (Array.isArray(propValue)) {\n          return propValue.every(isNode);\n        }\n        if (propValue === null || isValidElement(propValue)) {\n          return true;\n        }\n\n        var iteratorFn = getIteratorFn(propValue);\n        if (iteratorFn) {\n          var iterator = iteratorFn.call(propValue);\n          var step;\n          if (iteratorFn !== propValue.entries) {\n            while (!(step = iterator.next()).done) {\n              if (!isNode(step.value)) {\n                return false;\n              }\n            }\n          } else {\n            // Iterator will provide entry [k,v] tuples rather than values.\n            while (!(step = iterator.next()).done) {\n              var entry = step.value;\n              if (entry) {\n                if (!isNode(entry[1])) {\n                  return false;\n                }\n              }\n            }\n          }\n        } else {\n          return false;\n        }\n\n        return true;\n      default:\n        return false;\n    }\n  }\n\n  function isSymbol(propType, propValue) {\n    // Native Symbol.\n    if (propType === 'symbol') {\n      return true;\n    }\n\n    // falsy value can't be a Symbol\n    if (!propValue) {\n      return false;\n    }\n\n    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'\n    if (propValue['@@toStringTag'] === 'Symbol') {\n      return true;\n    }\n\n    // Fallback for non-spec compliant Symbols which are polyfilled.\n    if (typeof Symbol === 'function' && propValue instanceof Symbol) {\n      return true;\n    }\n\n    return false;\n  }\n\n  // Equivalent of `typeof` but with special handling for array and regexp.\n  function getPropType(propValue) {\n    var propType = typeof propValue;\n    if (Array.isArray(propValue)) {\n      return 'array';\n    }\n    if (propValue instanceof RegExp) {\n      // Old webkits (at least until Android 4.0) return 'function' rather than\n      // 'object' for typeof a RegExp. We'll normalize this here so that /bla/\n      // passes PropTypes.object.\n      return 'object';\n    }\n    if (isSymbol(propType, propValue)) {\n      return 'symbol';\n    }\n    return propType;\n  }\n\n  // This handles more types than `getPropType`. Only used for error messages.\n  // See `createPrimitiveTypeChecker`.\n  function getPreciseType(propValue) {\n    if (typeof propValue === 'undefined' || propValue === null) {\n      return '' + propValue;\n    }\n    var propType = getPropType(propValue);\n    if (propType === 'object') {\n      if (propValue instanceof Date) {\n        return 'date';\n      } else if (propValue instanceof RegExp) {\n        return 'regexp';\n      }\n    }\n    return propType;\n  }\n\n  // Returns a string that is postfixed to a warning about an invalid type.\n  // For example, \"undefined\" or \"of type array\"\n  function getPostfixForTypeWarning(value) {\n    var type = getPreciseType(value);\n    switch (type) {\n      case 'array':\n      case 'object':\n        return 'an ' + type;\n      case 'boolean':\n      case 'date':\n      case 'regexp':\n        return 'a ' + type;\n      default:\n        return type;\n    }\n  }\n\n  // Returns class name of the object, if any.\n  function getClassName(propValue) {\n    if (!propValue.constructor || !propValue.constructor.name) {\n      return ANONYMOUS;\n    }\n    return propValue.constructor.name;\n  }\n\n  ReactPropTypes.checkPropTypes = checkPropTypes;\n  ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;\n  ReactPropTypes.PropTypes = ReactPropTypes;\n\n  return ReactPropTypes;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2ZhY3RvcnlXaXRoVHlwZUNoZWNrZXJzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYixjQUFjLG1CQUFPLENBQUMsc0VBQVU7QUFDaEMsYUFBYSxtQkFBTyxDQUFDLG9HQUFlOztBQUVwQywyQkFBMkIsbUJBQU8sQ0FBQyw2R0FBNEI7QUFDL0QsVUFBVSxtQkFBTyxDQUFDLDJFQUFXO0FBQzdCLHFCQUFxQixtQkFBTyxDQUFDLHlGQUFrQjs7QUFFL0M7O0FBRUEsSUFBSSxJQUFxQztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7O0FBRTNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDViw4QkFBOEI7QUFDOUIsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLEtBQUs7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCw0QkFBNEI7QUFDNUIsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsSUFBcUM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxTQUFTLEtBQXFDO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isc0JBQXNCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVSxJQUFxQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNCQUFzQiwyQkFBMkI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNLEtBQXFDLDRGQUE0RixDQUFNO0FBQzdJO0FBQ0E7O0FBRUEsb0JBQW9CLGdDQUFnQztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNCQUFzQixnQ0FBZ0M7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlIQUFpSDtBQUNqSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvZmFjdG9yeVdpdGhUeXBlQ2hlY2tlcnMuanM/NzI3YSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0SXMgPSByZXF1aXJlKCdyZWFjdC1pcycpO1xudmFyIGFzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gcmVxdWlyZSgnLi9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQnKTtcbnZhciBoYXMgPSByZXF1aXJlKCcuL2xpYi9oYXMnKTtcbnZhciBjaGVja1Byb3BUeXBlcyA9IHJlcXVpcmUoJy4vY2hlY2tQcm9wVHlwZXMnKTtcblxudmFyIHByaW50V2FybmluZyA9IGZ1bmN0aW9uKCkge307XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHByaW50V2FybmluZyA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgICB2YXIgbWVzc2FnZSA9ICdXYXJuaW5nOiAnICsgdGV4dDtcbiAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgLy8gLS0tIFdlbGNvbWUgdG8gZGVidWdnaW5nIFJlYWN0IC0tLVxuICAgICAgLy8gVGhpcyBlcnJvciB3YXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28gdGhhdCB5b3UgY2FuIHVzZSB0aGlzIHN0YWNrXG4gICAgICAvLyB0byBmaW5kIHRoZSBjYWxsc2l0ZSB0aGF0IGNhdXNlZCB0aGlzIHdhcm5pbmcgdG8gZmlyZS5cbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICB9IGNhdGNoICh4KSB7fVxuICB9O1xufVxuXG5mdW5jdGlvbiBlbXB0eUZ1bmN0aW9uVGhhdFJldHVybnNOdWxsKCkge1xuICByZXR1cm4gbnVsbDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpc1ZhbGlkRWxlbWVudCwgdGhyb3dPbkRpcmVjdEFjY2Vzcykge1xuICAvKiBnbG9iYWwgU3ltYm9sICovXG4gIHZhciBJVEVSQVRPUl9TWU1CT0wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5pdGVyYXRvcjtcbiAgdmFyIEZBVVhfSVRFUkFUT1JfU1lNQk9MID0gJ0BAaXRlcmF0b3InOyAvLyBCZWZvcmUgU3ltYm9sIHNwZWMuXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGl0ZXJhdG9yIG1ldGhvZCBmdW5jdGlvbiBjb250YWluZWQgb24gdGhlIGl0ZXJhYmxlIG9iamVjdC5cbiAgICpcbiAgICogQmUgc3VyZSB0byBpbnZva2UgdGhlIGZ1bmN0aW9uIHdpdGggdGhlIGl0ZXJhYmxlIGFzIGNvbnRleHQ6XG4gICAqXG4gICAqICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obXlJdGVyYWJsZSk7XG4gICAqICAgICBpZiAoaXRlcmF0b3JGbikge1xuICAgKiAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwobXlJdGVyYWJsZSk7XG4gICAqICAgICAgIC4uLlxuICAgKiAgICAgfVxuICAgKlxuICAgKiBAcGFyYW0gez9vYmplY3R9IG1heWJlSXRlcmFibGVcbiAgICogQHJldHVybiB7P2Z1bmN0aW9ufVxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKSB7XG4gICAgdmFyIGl0ZXJhdG9yRm4gPSBtYXliZUl0ZXJhYmxlICYmIChJVEVSQVRPUl9TWU1CT0wgJiYgbWF5YmVJdGVyYWJsZVtJVEVSQVRPUl9TWU1CT0xdIHx8IG1heWJlSXRlcmFibGVbRkFVWF9JVEVSQVRPUl9TWU1CT0xdKTtcbiAgICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBpdGVyYXRvckZuO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDb2xsZWN0aW9uIG9mIG1ldGhvZHMgdGhhdCBhbGxvdyBkZWNsYXJhdGlvbiBhbmQgdmFsaWRhdGlvbiBvZiBwcm9wcyB0aGF0IGFyZVxuICAgKiBzdXBwbGllZCB0byBSZWFjdCBjb21wb25lbnRzLiBFeGFtcGxlIHVzYWdlOlxuICAgKlxuICAgKiAgIHZhciBQcm9wcyA9IHJlcXVpcmUoJ1JlYWN0UHJvcFR5cGVzJyk7XG4gICAqICAgdmFyIE15QXJ0aWNsZSA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAgICogICAgIHByb3BUeXBlczoge1xuICAgKiAgICAgICAvLyBBbiBvcHRpb25hbCBzdHJpbmcgcHJvcCBuYW1lZCBcImRlc2NyaXB0aW9uXCIuXG4gICAqICAgICAgIGRlc2NyaXB0aW9uOiBQcm9wcy5zdHJpbmcsXG4gICAqXG4gICAqICAgICAgIC8vIEEgcmVxdWlyZWQgZW51bSBwcm9wIG5hbWVkIFwiY2F0ZWdvcnlcIi5cbiAgICogICAgICAgY2F0ZWdvcnk6IFByb3BzLm9uZU9mKFsnTmV3cycsJ1Bob3RvcyddKS5pc1JlcXVpcmVkLFxuICAgKlxuICAgKiAgICAgICAvLyBBIHByb3AgbmFtZWQgXCJkaWFsb2dcIiB0aGF0IHJlcXVpcmVzIGFuIGluc3RhbmNlIG9mIERpYWxvZy5cbiAgICogICAgICAgZGlhbG9nOiBQcm9wcy5pbnN0YW5jZU9mKERpYWxvZykuaXNSZXF1aXJlZFxuICAgKiAgICAgfSxcbiAgICogICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7IC4uLiB9XG4gICAqICAgfSk7XG4gICAqXG4gICAqIEEgbW9yZSBmb3JtYWwgc3BlY2lmaWNhdGlvbiBvZiBob3cgdGhlc2UgbWV0aG9kcyBhcmUgdXNlZDpcbiAgICpcbiAgICogICB0eXBlIDo9IGFycmF5fGJvb2x8ZnVuY3xvYmplY3R8bnVtYmVyfHN0cmluZ3xvbmVPZihbLi4uXSl8aW5zdGFuY2VPZiguLi4pXG4gICAqICAgZGVjbCA6PSBSZWFjdFByb3BUeXBlcy57dHlwZX0oLmlzUmVxdWlyZWQpP1xuICAgKlxuICAgKiBFYWNoIGFuZCBldmVyeSBkZWNsYXJhdGlvbiBwcm9kdWNlcyBhIGZ1bmN0aW9uIHdpdGggdGhlIHNhbWUgc2lnbmF0dXJlLiBUaGlzXG4gICAqIGFsbG93cyB0aGUgY3JlYXRpb24gb2YgY3VzdG9tIHZhbGlkYXRpb24gZnVuY3Rpb25zLiBGb3IgZXhhbXBsZTpcbiAgICpcbiAgICogIHZhciBNeUxpbmsgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gICAqICAgIHByb3BUeXBlczoge1xuICAgKiAgICAgIC8vIEFuIG9wdGlvbmFsIHN0cmluZyBvciBVUkkgcHJvcCBuYW1lZCBcImhyZWZcIi5cbiAgICogICAgICBocmVmOiBmdW5jdGlvbihwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUpIHtcbiAgICogICAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAqICAgICAgICBpZiAocHJvcFZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHByb3BWYWx1ZSAhPT0gJ3N0cmluZycgJiZcbiAgICogICAgICAgICAgICAhKHByb3BWYWx1ZSBpbnN0YW5jZW9mIFVSSSkpIHtcbiAgICogICAgICAgICAgcmV0dXJuIG5ldyBFcnJvcihcbiAgICogICAgICAgICAgICAnRXhwZWN0ZWQgYSBzdHJpbmcgb3IgYW4gVVJJIGZvciAnICsgcHJvcE5hbWUgKyAnIGluICcgK1xuICAgKiAgICAgICAgICAgIGNvbXBvbmVudE5hbWVcbiAgICogICAgICAgICAgKTtcbiAgICogICAgICAgIH1cbiAgICogICAgICB9XG4gICAqICAgIH0sXG4gICAqICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7Li4ufVxuICAgKiAgfSk7XG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cblxuICB2YXIgQU5PTllNT1VTID0gJzw8YW5vbnltb3VzPj4nO1xuXG4gIC8vIEltcG9ydGFudCFcbiAgLy8gS2VlcCB0aGlzIGxpc3QgaW4gc3luYyB3aXRoIHByb2R1Y3Rpb24gdmVyc2lvbiBpbiBgLi9mYWN0b3J5V2l0aFRocm93aW5nU2hpbXMuanNgLlxuICB2YXIgUmVhY3RQcm9wVHlwZXMgPSB7XG4gICAgYXJyYXk6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdhcnJheScpLFxuICAgIGJpZ2ludDogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ2JpZ2ludCcpLFxuICAgIGJvb2w6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdib29sZWFuJyksXG4gICAgZnVuYzogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ2Z1bmN0aW9uJyksXG4gICAgbnVtYmVyOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignbnVtYmVyJyksXG4gICAgb2JqZWN0OiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignb2JqZWN0JyksXG4gICAgc3RyaW5nOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignc3RyaW5nJyksXG4gICAgc3ltYm9sOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignc3ltYm9sJyksXG5cbiAgICBhbnk6IGNyZWF0ZUFueVR5cGVDaGVja2VyKCksXG4gICAgYXJyYXlPZjogY3JlYXRlQXJyYXlPZlR5cGVDaGVja2VyLFxuICAgIGVsZW1lbnQ6IGNyZWF0ZUVsZW1lbnRUeXBlQ2hlY2tlcigpLFxuICAgIGVsZW1lbnRUeXBlOiBjcmVhdGVFbGVtZW50VHlwZVR5cGVDaGVja2VyKCksXG4gICAgaW5zdGFuY2VPZjogY3JlYXRlSW5zdGFuY2VUeXBlQ2hlY2tlcixcbiAgICBub2RlOiBjcmVhdGVOb2RlQ2hlY2tlcigpLFxuICAgIG9iamVjdE9mOiBjcmVhdGVPYmplY3RPZlR5cGVDaGVja2VyLFxuICAgIG9uZU9mOiBjcmVhdGVFbnVtVHlwZUNoZWNrZXIsXG4gICAgb25lT2ZUeXBlOiBjcmVhdGVVbmlvblR5cGVDaGVja2VyLFxuICAgIHNoYXBlOiBjcmVhdGVTaGFwZVR5cGVDaGVja2VyLFxuICAgIGV4YWN0OiBjcmVhdGVTdHJpY3RTaGFwZVR5cGVDaGVja2VyLFxuICB9O1xuXG4gIC8qKlxuICAgKiBpbmxpbmVkIE9iamVjdC5pcyBwb2x5ZmlsbCB0byBhdm9pZCByZXF1aXJpbmcgY29uc3VtZXJzIHNoaXAgdGhlaXIgb3duXG4gICAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9pc1xuICAgKi9cbiAgLyplc2xpbnQtZGlzYWJsZSBuby1zZWxmLWNvbXBhcmUqL1xuICBmdW5jdGlvbiBpcyh4LCB5KSB7XG4gICAgLy8gU2FtZVZhbHVlIGFsZ29yaXRobVxuICAgIGlmICh4ID09PSB5KSB7XG4gICAgICAvLyBTdGVwcyAxLTUsIDctMTBcbiAgICAgIC8vIFN0ZXBzIDYuYi02LmU6ICswICE9IC0wXG4gICAgICByZXR1cm4geCAhPT0gMCB8fCAxIC8geCA9PT0gMSAvIHk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFN0ZXAgNi5hOiBOYU4gPT0gTmFOXG4gICAgICByZXR1cm4geCAhPT0geCAmJiB5ICE9PSB5O1xuICAgIH1cbiAgfVxuICAvKmVzbGludC1lbmFibGUgbm8tc2VsZi1jb21wYXJlKi9cblxuICAvKipcbiAgICogV2UgdXNlIGFuIEVycm9yLWxpa2Ugb2JqZWN0IGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5IGFzIHBlb3BsZSBtYXkgY2FsbFxuICAgKiBQcm9wVHlwZXMgZGlyZWN0bHkgYW5kIGluc3BlY3QgdGhlaXIgb3V0cHV0LiBIb3dldmVyLCB3ZSBkb24ndCB1c2UgcmVhbFxuICAgKiBFcnJvcnMgYW55bW9yZS4gV2UgZG9uJ3QgaW5zcGVjdCB0aGVpciBzdGFjayBhbnl3YXksIGFuZCBjcmVhdGluZyB0aGVtXG4gICAqIGlzIHByb2hpYml0aXZlbHkgZXhwZW5zaXZlIGlmIHRoZXkgYXJlIGNyZWF0ZWQgdG9vIG9mdGVuLCBzdWNoIGFzIHdoYXRcbiAgICogaGFwcGVucyBpbiBvbmVPZlR5cGUoKSBmb3IgYW55IHR5cGUgYmVmb3JlIHRoZSBvbmUgdGhhdCBtYXRjaGVkLlxuICAgKi9cbiAgZnVuY3Rpb24gUHJvcFR5cGVFcnJvcihtZXNzYWdlLCBkYXRhKSB7XG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICB0aGlzLmRhdGEgPSBkYXRhICYmIHR5cGVvZiBkYXRhID09PSAnb2JqZWN0JyA/IGRhdGE6IHt9O1xuICAgIHRoaXMuc3RhY2sgPSAnJztcbiAgfVxuICAvLyBNYWtlIGBpbnN0YW5jZW9mIEVycm9yYCBzdGlsbCB3b3JrIGZvciByZXR1cm5lZCBlcnJvcnMuXG4gIFByb3BUeXBlRXJyb3IucHJvdG90eXBlID0gRXJyb3IucHJvdG90eXBlO1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBtYW51YWxQcm9wVHlwZUNhbGxDYWNoZSA9IHt9O1xuICAgICAgdmFyIG1hbnVhbFByb3BUeXBlV2FybmluZ0NvdW50ID0gMDtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2hlY2tUeXBlKGlzUmVxdWlyZWQsIHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwgc2VjcmV0KSB7XG4gICAgICBjb21wb25lbnROYW1lID0gY29tcG9uZW50TmFtZSB8fCBBTk9OWU1PVVM7XG4gICAgICBwcm9wRnVsbE5hbWUgPSBwcm9wRnVsbE5hbWUgfHwgcHJvcE5hbWU7XG5cbiAgICAgIGlmIChzZWNyZXQgIT09IFJlYWN0UHJvcFR5cGVzU2VjcmV0KSB7XG4gICAgICAgIGlmICh0aHJvd09uRGlyZWN0QWNjZXNzKSB7XG4gICAgICAgICAgLy8gTmV3IGJlaGF2aW9yIG9ubHkgZm9yIHVzZXJzIG9mIGBwcm9wLXR5cGVzYCBwYWNrYWdlXG4gICAgICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcihcbiAgICAgICAgICAgICdDYWxsaW5nIFByb3BUeXBlcyB2YWxpZGF0b3JzIGRpcmVjdGx5IGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLiAnICtcbiAgICAgICAgICAgICdVc2UgYFByb3BUeXBlcy5jaGVja1Byb3BUeXBlcygpYCB0byBjYWxsIHRoZW0uICcgK1xuICAgICAgICAgICAgJ1JlYWQgbW9yZSBhdCBodHRwOi8vZmIubWUvdXNlLWNoZWNrLXByb3AtdHlwZXMnXG4gICAgICAgICAgKTtcbiAgICAgICAgICBlcnIubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcbiAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAvLyBPbGQgYmVoYXZpb3IgZm9yIHBlb3BsZSB1c2luZyBSZWFjdC5Qcm9wVHlwZXNcbiAgICAgICAgICB2YXIgY2FjaGVLZXkgPSBjb21wb25lbnROYW1lICsgJzonICsgcHJvcE5hbWU7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgIW1hbnVhbFByb3BUeXBlQ2FsbENhY2hlW2NhY2hlS2V5XSAmJlxuICAgICAgICAgICAgLy8gQXZvaWQgc3BhbW1pbmcgdGhlIGNvbnNvbGUgYmVjYXVzZSB0aGV5IGFyZSBvZnRlbiBub3QgYWN0aW9uYWJsZSBleGNlcHQgZm9yIGxpYiBhdXRob3JzXG4gICAgICAgICAgICBtYW51YWxQcm9wVHlwZVdhcm5pbmdDb3VudCA8IDNcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHByaW50V2FybmluZyhcbiAgICAgICAgICAgICAgJ1lvdSBhcmUgbWFudWFsbHkgY2FsbGluZyBhIFJlYWN0LlByb3BUeXBlcyB2YWxpZGF0aW9uICcgK1xuICAgICAgICAgICAgICAnZnVuY3Rpb24gZm9yIHRoZSBgJyArIHByb3BGdWxsTmFtZSArICdgIHByb3Agb24gYCcgKyBjb21wb25lbnROYW1lICsgJ2AuIFRoaXMgaXMgZGVwcmVjYXRlZCAnICtcbiAgICAgICAgICAgICAgJ2FuZCB3aWxsIHRocm93IGluIHRoZSBzdGFuZGFsb25lIGBwcm9wLXR5cGVzYCBwYWNrYWdlLiAnICtcbiAgICAgICAgICAgICAgJ1lvdSBtYXkgYmUgc2VlaW5nIHRoaXMgd2FybmluZyBkdWUgdG8gYSB0aGlyZC1wYXJ0eSBQcm9wVHlwZXMgJyArXG4gICAgICAgICAgICAgICdsaWJyYXJ5LiBTZWUgaHR0cHM6Ly9mYi5tZS9yZWFjdC13YXJuaW5nLWRvbnQtY2FsbC1wcm9wdHlwZXMgJyArICdmb3IgZGV0YWlscy4nXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgbWFudWFsUHJvcFR5cGVDYWxsQ2FjaGVbY2FjaGVLZXldID0gdHJ1ZTtcbiAgICAgICAgICAgIG1hbnVhbFByb3BUeXBlV2FybmluZ0NvdW50Kys7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09IG51bGwpIHtcbiAgICAgICAgaWYgKGlzUmVxdWlyZWQpIHtcbiAgICAgICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1RoZSAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2AgaXMgbWFya2VkIGFzIHJlcXVpcmVkICcgKyAoJ2luIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBidXQgaXRzIHZhbHVlIGlzIGBudWxsYC4nKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignVGhlICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBpcyBtYXJrZWQgYXMgcmVxdWlyZWQgaW4gJyArICgnYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGJ1dCBpdHMgdmFsdWUgaXMgYHVuZGVmaW5lZGAuJykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGNoYWluZWRDaGVja1R5cGUgPSBjaGVja1R5cGUuYmluZChudWxsLCBmYWxzZSk7XG4gICAgY2hhaW5lZENoZWNrVHlwZS5pc1JlcXVpcmVkID0gY2hlY2tUeXBlLmJpbmQobnVsbCwgdHJ1ZSk7XG5cbiAgICByZXR1cm4gY2hhaW5lZENoZWNrVHlwZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKGV4cGVjdGVkVHlwZSkge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwgc2VjcmV0KSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgIGlmIChwcm9wVHlwZSAhPT0gZXhwZWN0ZWRUeXBlKSB7XG4gICAgICAgIC8vIGBwcm9wVmFsdWVgIGJlaW5nIGluc3RhbmNlIG9mLCBzYXksIGRhdGUvcmVnZXhwLCBwYXNzIHRoZSAnb2JqZWN0J1xuICAgICAgICAvLyBjaGVjaywgYnV0IHdlIGNhbiBvZmZlciBhIG1vcmUgcHJlY2lzZSBlcnJvciBtZXNzYWdlIGhlcmUgcmF0aGVyIHRoYW5cbiAgICAgICAgLy8gJ29mIHR5cGUgYG9iamVjdGAnLlxuICAgICAgICB2YXIgcHJlY2lzZVR5cGUgPSBnZXRQcmVjaXNlVHlwZShwcm9wVmFsdWUpO1xuXG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcihcbiAgICAgICAgICAnSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByZWNpc2VUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkICcpICsgKCdgJyArIGV4cGVjdGVkVHlwZSArICdgLicpLFxuICAgICAgICAgIHtleHBlY3RlZFR5cGU6IGV4cGVjdGVkVHlwZX1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlQW55VHlwZUNoZWNrZXIoKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKGVtcHR5RnVuY3Rpb25UaGF0UmV0dXJuc051bGwpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlQXJyYXlPZlR5cGVDaGVja2VyKHR5cGVDaGVja2VyKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICBpZiAodHlwZW9mIHR5cGVDaGVja2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignUHJvcGVydHkgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiBjb21wb25lbnQgYCcgKyBjb21wb25lbnROYW1lICsgJ2AgaGFzIGludmFsaWQgUHJvcFR5cGUgbm90YXRpb24gaW5zaWRlIGFycmF5T2YuJyk7XG4gICAgICB9XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHByb3BWYWx1ZSkpIHtcbiAgICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJvcFR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYW4gYXJyYXkuJykpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wVmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGVycm9yID0gdHlwZUNoZWNrZXIocHJvcFZhbHVlLCBpLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJ1snICsgaSArICddJywgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVFbGVtZW50VHlwZUNoZWNrZXIoKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgaWYgKCFpc1ZhbGlkRWxlbWVudChwcm9wVmFsdWUpKSB7XG4gICAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByb3BUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGEgc2luZ2xlIFJlYWN0RWxlbWVudC4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnRUeXBlVHlwZUNoZWNrZXIoKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgaWYgKCFSZWFjdElzLmlzVmFsaWRFbGVtZW50VHlwZShwcm9wVmFsdWUpKSB7XG4gICAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByb3BUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGEgc2luZ2xlIFJlYWN0RWxlbWVudCB0eXBlLicpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlSW5zdGFuY2VUeXBlQ2hlY2tlcihleHBlY3RlZENsYXNzKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICBpZiAoIShwcm9wc1twcm9wTmFtZV0gaW5zdGFuY2VvZiBleHBlY3RlZENsYXNzKSkge1xuICAgICAgICB2YXIgZXhwZWN0ZWRDbGFzc05hbWUgPSBleHBlY3RlZENsYXNzLm5hbWUgfHwgQU5PTllNT1VTO1xuICAgICAgICB2YXIgYWN0dWFsQ2xhc3NOYW1lID0gZ2V0Q2xhc3NOYW1lKHByb3BzW3Byb3BOYW1lXSk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIGFjdHVhbENsYXNzTmFtZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCAnKSArICgnaW5zdGFuY2Ugb2YgYCcgKyBleHBlY3RlZENsYXNzTmFtZSArICdgLicpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlRW51bVR5cGVDaGVja2VyKGV4cGVjdGVkVmFsdWVzKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGV4cGVjdGVkVmFsdWVzKSkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgcHJpbnRXYXJuaW5nKFxuICAgICAgICAgICAgJ0ludmFsaWQgYXJndW1lbnRzIHN1cHBsaWVkIHRvIG9uZU9mLCBleHBlY3RlZCBhbiBhcnJheSwgZ290ICcgKyBhcmd1bWVudHMubGVuZ3RoICsgJyBhcmd1bWVudHMuICcgK1xuICAgICAgICAgICAgJ0EgY29tbW9uIG1pc3Rha2UgaXMgdG8gd3JpdGUgb25lT2YoeCwgeSwgeikgaW5zdGVhZCBvZiBvbmVPZihbeCwgeSwgel0pLidcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByaW50V2FybmluZygnSW52YWxpZCBhcmd1bWVudCBzdXBwbGllZCB0byBvbmVPZiwgZXhwZWN0ZWQgYW4gYXJyYXkuJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBlbXB0eUZ1bmN0aW9uVGhhdFJldHVybnNOdWxsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXhwZWN0ZWRWYWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGlzKHByb3BWYWx1ZSwgZXhwZWN0ZWRWYWx1ZXNbaV0pKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHZhbHVlc1N0cmluZyA9IEpTT04uc3RyaW5naWZ5KGV4cGVjdGVkVmFsdWVzLCBmdW5jdGlvbiByZXBsYWNlcihrZXksIHZhbHVlKSB7XG4gICAgICAgIHZhciB0eXBlID0gZ2V0UHJlY2lzZVR5cGUodmFsdWUpO1xuICAgICAgICBpZiAodHlwZSA9PT0gJ3N5bWJvbCcpIHtcbiAgICAgICAgICByZXR1cm4gU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdmFsdWUgYCcgKyBTdHJpbmcocHJvcFZhbHVlKSArICdgICcgKyAoJ3N1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBvbmUgb2YgJyArIHZhbHVlc1N0cmluZyArICcuJykpO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlT2JqZWN0T2ZUeXBlQ2hlY2tlcih0eXBlQ2hlY2tlcikge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgaWYgKHR5cGVvZiB0eXBlQ2hlY2tlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1Byb3BlcnR5IGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgY29tcG9uZW50IGAnICsgY29tcG9uZW50TmFtZSArICdgIGhhcyBpbnZhbGlkIFByb3BUeXBlIG5vdGF0aW9uIGluc2lkZSBvYmplY3RPZi4nKTtcbiAgICAgIH1cbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgaWYgKHByb3BUeXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcm9wVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhbiBvYmplY3QuJykpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIga2V5IGluIHByb3BWYWx1ZSkge1xuICAgICAgICBpZiAoaGFzKHByb3BWYWx1ZSwga2V5KSkge1xuICAgICAgICAgIHZhciBlcnJvciA9IHR5cGVDaGVja2VyKHByb3BWYWx1ZSwga2V5LCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJy4nICsga2V5LCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlVW5pb25UeXBlQ2hlY2tlcihhcnJheU9mVHlwZUNoZWNrZXJzKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGFycmF5T2ZUeXBlQ2hlY2tlcnMpKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gcHJpbnRXYXJuaW5nKCdJbnZhbGlkIGFyZ3VtZW50IHN1cHBsaWVkIHRvIG9uZU9mVHlwZSwgZXhwZWN0ZWQgYW4gaW5zdGFuY2Ugb2YgYXJyYXkuJykgOiB2b2lkIDA7XG4gICAgICByZXR1cm4gZW1wdHlGdW5jdGlvblRoYXRSZXR1cm5zTnVsbDtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5T2ZUeXBlQ2hlY2tlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjaGVja2VyID0gYXJyYXlPZlR5cGVDaGVja2Vyc1tpXTtcbiAgICAgIGlmICh0eXBlb2YgY2hlY2tlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBwcmludFdhcm5pbmcoXG4gICAgICAgICAgJ0ludmFsaWQgYXJndW1lbnQgc3VwcGxpZWQgdG8gb25lT2ZUeXBlLiBFeHBlY3RlZCBhbiBhcnJheSBvZiBjaGVjayBmdW5jdGlvbnMsIGJ1dCAnICtcbiAgICAgICAgICAncmVjZWl2ZWQgJyArIGdldFBvc3RmaXhGb3JUeXBlV2FybmluZyhjaGVja2VyKSArICcgYXQgaW5kZXggJyArIGkgKyAnLidcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIGVtcHR5RnVuY3Rpb25UaGF0UmV0dXJuc051bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICB2YXIgZXhwZWN0ZWRUeXBlcyA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheU9mVHlwZUNoZWNrZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGVja2VyID0gYXJyYXlPZlR5cGVDaGVja2Vyc1tpXTtcbiAgICAgICAgdmFyIGNoZWNrZXJSZXN1bHQgPSBjaGVja2VyKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICBpZiAoY2hlY2tlclJlc3VsdCA9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoZWNrZXJSZXN1bHQuZGF0YSAmJiBoYXMoY2hlY2tlclJlc3VsdC5kYXRhLCAnZXhwZWN0ZWRUeXBlJykpIHtcbiAgICAgICAgICBleHBlY3RlZFR5cGVzLnB1c2goY2hlY2tlclJlc3VsdC5kYXRhLmV4cGVjdGVkVHlwZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBleHBlY3RlZFR5cGVzTWVzc2FnZSA9IChleHBlY3RlZFR5cGVzLmxlbmd0aCA+IDApID8gJywgZXhwZWN0ZWQgb25lIG9mIHR5cGUgWycgKyBleHBlY3RlZFR5cGVzLmpvaW4oJywgJykgKyAnXSc6ICcnO1xuICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBzdXBwbGllZCB0byAnICsgKCdgJyArIGNvbXBvbmVudE5hbWUgKyAnYCcgKyBleHBlY3RlZFR5cGVzTWVzc2FnZSArICcuJykpO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlTm9kZUNoZWNrZXIoKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICBpZiAoIWlzTm9kZShwcm9wc1twcm9wTmFtZV0pKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agc3VwcGxpZWQgdG8gJyArICgnYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGEgUmVhY3ROb2RlLicpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gaW52YWxpZFZhbGlkYXRvckVycm9yKGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIGtleSwgdHlwZSkge1xuICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcihcbiAgICAgIChjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycpICsgJzogJyArIGxvY2F0aW9uICsgJyB0eXBlIGAnICsgcHJvcEZ1bGxOYW1lICsgJy4nICsga2V5ICsgJ2AgaXMgaW52YWxpZDsgJyArXG4gICAgICAnaXQgbXVzdCBiZSBhIGZ1bmN0aW9uLCB1c3VhbGx5IGZyb20gdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLCBidXQgcmVjZWl2ZWQgYCcgKyB0eXBlICsgJ2AuJ1xuICAgICk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVTaGFwZVR5cGVDaGVja2VyKHNoYXBlVHlwZXMpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgaWYgKHByb3BUeXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgYCcgKyBwcm9wVHlwZSArICdgICcgKyAoJ3N1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBgb2JqZWN0YC4nKSk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBrZXkgaW4gc2hhcGVUeXBlcykge1xuICAgICAgICB2YXIgY2hlY2tlciA9IHNoYXBlVHlwZXNba2V5XTtcbiAgICAgICAgaWYgKHR5cGVvZiBjaGVja2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgcmV0dXJuIGludmFsaWRWYWxpZGF0b3JFcnJvcihjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBrZXksIGdldFByZWNpc2VUeXBlKGNoZWNrZXIpKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXJyb3IgPSBjaGVja2VyKHByb3BWYWx1ZSwga2V5LCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJy4nICsga2V5LCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVTdHJpY3RTaGFwZVR5cGVDaGVja2VyKHNoYXBlVHlwZXMpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgaWYgKHByb3BUeXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgYCcgKyBwcm9wVHlwZSArICdgICcgKyAoJ3N1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBgb2JqZWN0YC4nKSk7XG4gICAgICB9XG4gICAgICAvLyBXZSBuZWVkIHRvIGNoZWNrIGFsbCBrZXlzIGluIGNhc2Ugc29tZSBhcmUgcmVxdWlyZWQgYnV0IG1pc3NpbmcgZnJvbSBwcm9wcy5cbiAgICAgIHZhciBhbGxLZXlzID0gYXNzaWduKHt9LCBwcm9wc1twcm9wTmFtZV0sIHNoYXBlVHlwZXMpO1xuICAgICAgZm9yICh2YXIga2V5IGluIGFsbEtleXMpIHtcbiAgICAgICAgdmFyIGNoZWNrZXIgPSBzaGFwZVR5cGVzW2tleV07XG4gICAgICAgIGlmIChoYXMoc2hhcGVUeXBlcywga2V5KSAmJiB0eXBlb2YgY2hlY2tlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHJldHVybiBpbnZhbGlkVmFsaWRhdG9yRXJyb3IoY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwga2V5LCBnZXRQcmVjaXNlVHlwZShjaGVja2VyKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjaGVja2VyKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKFxuICAgICAgICAgICAgJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIGtleSBgJyArIGtleSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLicgK1xuICAgICAgICAgICAgJ1xcbkJhZCBvYmplY3Q6ICcgKyBKU09OLnN0cmluZ2lmeShwcm9wc1twcm9wTmFtZV0sIG51bGwsICcgICcpICtcbiAgICAgICAgICAgICdcXG5WYWxpZCBrZXlzOiAnICsgSlNPTi5zdHJpbmdpZnkoT2JqZWN0LmtleXMoc2hhcGVUeXBlcyksIG51bGwsICcgICcpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXJyb3IgPSBjaGVja2VyKHByb3BWYWx1ZSwga2V5LCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJy4nICsga2V5LCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzTm9kZShwcm9wVmFsdWUpIHtcbiAgICBzd2l0Y2ggKHR5cGVvZiBwcm9wVmFsdWUpIHtcbiAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgY2FzZSAndW5kZWZpbmVkJzpcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgcmV0dXJuICFwcm9wVmFsdWU7XG4gICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwcm9wVmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIHByb3BWYWx1ZS5ldmVyeShpc05vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9wVmFsdWUgPT09IG51bGwgfHwgaXNWYWxpZEVsZW1lbnQocHJvcFZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKHByb3BWYWx1ZSk7XG4gICAgICAgIGlmIChpdGVyYXRvckZuKSB7XG4gICAgICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKHByb3BWYWx1ZSk7XG4gICAgICAgICAgdmFyIHN0ZXA7XG4gICAgICAgICAgaWYgKGl0ZXJhdG9yRm4gIT09IHByb3BWYWx1ZS5lbnRyaWVzKSB7XG4gICAgICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgICAgIGlmICghaXNOb2RlKHN0ZXAudmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEl0ZXJhdG9yIHdpbGwgcHJvdmlkZSBlbnRyeSBbayx2XSB0dXBsZXMgcmF0aGVyIHRoYW4gdmFsdWVzLlxuICAgICAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgICAgICB2YXIgZW50cnkgPSBzdGVwLnZhbHVlO1xuICAgICAgICAgICAgICBpZiAoZW50cnkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzTm9kZShlbnRyeVsxXSkpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaXNTeW1ib2wocHJvcFR5cGUsIHByb3BWYWx1ZSkge1xuICAgIC8vIE5hdGl2ZSBTeW1ib2wuXG4gICAgaWYgKHByb3BUeXBlID09PSAnc3ltYm9sJykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gZmFsc3kgdmFsdWUgY2FuJ3QgYmUgYSBTeW1ib2xcbiAgICBpZiAoIXByb3BWYWx1ZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIDE5LjQuMy41IFN5bWJvbC5wcm90b3R5cGVbQEB0b1N0cmluZ1RhZ10gPT09ICdTeW1ib2wnXG4gICAgaWYgKHByb3BWYWx1ZVsnQEB0b1N0cmluZ1RhZyddID09PSAnU3ltYm9sJykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gRmFsbGJhY2sgZm9yIG5vbi1zcGVjIGNvbXBsaWFudCBTeW1ib2xzIHdoaWNoIGFyZSBwb2x5ZmlsbGVkLlxuICAgIGlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIHByb3BWYWx1ZSBpbnN0YW5jZW9mIFN5bWJvbCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gRXF1aXZhbGVudCBvZiBgdHlwZW9mYCBidXQgd2l0aCBzcGVjaWFsIGhhbmRsaW5nIGZvciBhcnJheSBhbmQgcmVnZXhwLlxuICBmdW5jdGlvbiBnZXRQcm9wVHlwZShwcm9wVmFsdWUpIHtcbiAgICB2YXIgcHJvcFR5cGUgPSB0eXBlb2YgcHJvcFZhbHVlO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHByb3BWYWx1ZSkpIHtcbiAgICAgIHJldHVybiAnYXJyYXknO1xuICAgIH1cbiAgICBpZiAocHJvcFZhbHVlIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAvLyBPbGQgd2Via2l0cyAoYXQgbGVhc3QgdW50aWwgQW5kcm9pZCA0LjApIHJldHVybiAnZnVuY3Rpb24nIHJhdGhlciB0aGFuXG4gICAgICAvLyAnb2JqZWN0JyBmb3IgdHlwZW9mIGEgUmVnRXhwLiBXZSdsbCBub3JtYWxpemUgdGhpcyBoZXJlIHNvIHRoYXQgL2JsYS9cbiAgICAgIC8vIHBhc3NlcyBQcm9wVHlwZXMub2JqZWN0LlxuICAgICAgcmV0dXJuICdvYmplY3QnO1xuICAgIH1cbiAgICBpZiAoaXNTeW1ib2wocHJvcFR5cGUsIHByb3BWYWx1ZSkpIHtcbiAgICAgIHJldHVybiAnc3ltYm9sJztcbiAgICB9XG4gICAgcmV0dXJuIHByb3BUeXBlO1xuICB9XG5cbiAgLy8gVGhpcyBoYW5kbGVzIG1vcmUgdHlwZXMgdGhhbiBgZ2V0UHJvcFR5cGVgLiBPbmx5IHVzZWQgZm9yIGVycm9yIG1lc3NhZ2VzLlxuICAvLyBTZWUgYGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyYC5cbiAgZnVuY3Rpb24gZ2V0UHJlY2lzZVR5cGUocHJvcFZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiBwcm9wVmFsdWUgPT09ICd1bmRlZmluZWQnIHx8IHByb3BWYWx1ZSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuICcnICsgcHJvcFZhbHVlO1xuICAgIH1cbiAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgIGlmIChwcm9wVHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGlmIChwcm9wVmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgIHJldHVybiAnZGF0ZSc7XG4gICAgICB9IGVsc2UgaWYgKHByb3BWYWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgICByZXR1cm4gJ3JlZ2V4cCc7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwcm9wVHlwZTtcbiAgfVxuXG4gIC8vIFJldHVybnMgYSBzdHJpbmcgdGhhdCBpcyBwb3N0Zml4ZWQgdG8gYSB3YXJuaW5nIGFib3V0IGFuIGludmFsaWQgdHlwZS5cbiAgLy8gRm9yIGV4YW1wbGUsIFwidW5kZWZpbmVkXCIgb3IgXCJvZiB0eXBlIGFycmF5XCJcbiAgZnVuY3Rpb24gZ2V0UG9zdGZpeEZvclR5cGVXYXJuaW5nKHZhbHVlKSB7XG4gICAgdmFyIHR5cGUgPSBnZXRQcmVjaXNlVHlwZSh2YWx1ZSk7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlICdhcnJheSc6XG4gICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICByZXR1cm4gJ2FuICcgKyB0eXBlO1xuICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICBjYXNlICdkYXRlJzpcbiAgICAgIGNhc2UgJ3JlZ2V4cCc6XG4gICAgICAgIHJldHVybiAnYSAnICsgdHlwZTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB0eXBlO1xuICAgIH1cbiAgfVxuXG4gIC8vIFJldHVybnMgY2xhc3MgbmFtZSBvZiB0aGUgb2JqZWN0LCBpZiBhbnkuXG4gIGZ1bmN0aW9uIGdldENsYXNzTmFtZShwcm9wVmFsdWUpIHtcbiAgICBpZiAoIXByb3BWYWx1ZS5jb25zdHJ1Y3RvciB8fCAhcHJvcFZhbHVlLmNvbnN0cnVjdG9yLm5hbWUpIHtcbiAgICAgIHJldHVybiBBTk9OWU1PVVM7XG4gICAgfVxuICAgIHJldHVybiBwcm9wVmFsdWUuY29uc3RydWN0b3IubmFtZTtcbiAgfVxuXG4gIFJlYWN0UHJvcFR5cGVzLmNoZWNrUHJvcFR5cGVzID0gY2hlY2tQcm9wVHlwZXM7XG4gIFJlYWN0UHJvcFR5cGVzLnJlc2V0V2FybmluZ0NhY2hlID0gY2hlY2tQcm9wVHlwZXMucmVzZXRXYXJuaW5nQ2FjaGU7XG4gIFJlYWN0UHJvcFR5cGVzLlByb3BUeXBlcyA9IFJlYWN0UHJvcFR5cGVzO1xuXG4gIHJldHVybiBSZWFjdFByb3BUeXBlcztcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/prop-types/factoryWithTypeCheckers.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/prop-types/index.js":
/*!******************************************!*\
  !*** ./node_modules/prop-types/index.js ***!
  \******************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nif (true) {\n  var ReactIs = __webpack_require__(/*! react-is */ \"(app-pages-browser)/./node_modules/react-is/index.js\");\n\n  // By explicitly using `prop-types` you are opting into new development behavior.\n  // http://fb.me/prop-types-in-prod\n  var throwOnDirectAccess = true;\n  module.exports = __webpack_require__(/*! ./factoryWithTypeCheckers */ \"(app-pages-browser)/./node_modules/prop-types/factoryWithTypeCheckers.js\")(ReactIs.isElement, throwOnDirectAccess);\n} else {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJLElBQXFDO0FBQ3pDLGdCQUFnQixtQkFBTyxDQUFDLHNFQUFVOztBQUVsQztBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsbUJBQU8sQ0FBQywyR0FBMkI7QUFDdEQsRUFBRSxLQUFLLEVBSU4iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvaW5kZXguanM/N2I0NCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBSZWFjdElzID0gcmVxdWlyZSgncmVhY3QtaXMnKTtcblxuICAvLyBCeSBleHBsaWNpdGx5IHVzaW5nIGBwcm9wLXR5cGVzYCB5b3UgYXJlIG9wdGluZyBpbnRvIG5ldyBkZXZlbG9wbWVudCBiZWhhdmlvci5cbiAgLy8gaHR0cDovL2ZiLm1lL3Byb3AtdHlwZXMtaW4tcHJvZFxuICB2YXIgdGhyb3dPbkRpcmVjdEFjY2VzcyA9IHRydWU7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9mYWN0b3J5V2l0aFR5cGVDaGVja2VycycpKFJlYWN0SXMuaXNFbGVtZW50LCB0aHJvd09uRGlyZWN0QWNjZXNzKTtcbn0gZWxzZSB7XG4gIC8vIEJ5IGV4cGxpY2l0bHkgdXNpbmcgYHByb3AtdHlwZXNgIHlvdSBhcmUgb3B0aW5nIGludG8gbmV3IHByb2R1Y3Rpb24gYmVoYXZpb3IuXG4gIC8vIGh0dHA6Ly9mYi5tZS9wcm9wLXR5cGVzLWluLXByb2RcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2ZhY3RvcnlXaXRoVGhyb3dpbmdTaGltcycpKCk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/prop-types/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/prop-types/lib/ReactPropTypesSecret.js":
/*!*************************************************************!*\
  !*** ./node_modules/prop-types/lib/ReactPropTypesSecret.js ***!
  \*************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nvar ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';\n\nmodule.exports = ReactPropTypesSecret;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2xpYi9SZWFjdFByb3BUeXBlc1NlY3JldC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWI7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0LmpzP2YyMTAiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9ICdTRUNSRVRfRE9fTk9UX1BBU1NfVEhJU19PUl9ZT1VfV0lMTF9CRV9GSVJFRCc7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RQcm9wVHlwZXNTZWNyZXQ7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/prop-types/lib/ReactPropTypesSecret.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/prop-types/lib/has.js":
/*!********************************************!*\
  !*** ./node_modules/prop-types/lib/has.js ***!
  \********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("module.exports = Function.call.bind(Object.prototype.hasOwnProperty);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2xpYi9oYXMuanMiLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvbGliL2hhcy5qcz9lOTk3Il0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gRnVuY3Rpb24uY2FsbC5iaW5kKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/prop-types/lib/has.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-is/cjs/react-is.development.js":
/*!***********************************************************!*\
  !*** ./node_modules/react-is/cjs/react-is.development.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/** @license React v16.13.1\n * react-is.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\n\n\nif (true) {\n  (function() {\n'use strict';\n\n// The Symbol used to tag the ReactElement-like types. If there is no native Symbol\n// nor polyfill, then a plain number is used for performance.\nvar hasSymbol = typeof Symbol === 'function' && Symbol.for;\nvar REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for('react.element') : 0xeac7;\nvar REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 0xeaca;\nvar REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for('react.fragment') : 0xeacb;\nvar REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for('react.strict_mode') : 0xeacc;\nvar REACT_PROFILER_TYPE = hasSymbol ? Symbol.for('react.profiler') : 0xead2;\nvar REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for('react.provider') : 0xeacd;\nvar REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for('react.context') : 0xeace; // TODO: We don't use AsyncMode or ConcurrentMode anymore. They were temporary\n// (unstable) APIs that have been removed. Can we remove the symbols?\n\nvar REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for('react.async_mode') : 0xeacf;\nvar REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for('react.concurrent_mode') : 0xeacf;\nvar REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 0xead0;\nvar REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for('react.suspense') : 0xead1;\nvar REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for('react.suspense_list') : 0xead8;\nvar REACT_MEMO_TYPE = hasSymbol ? Symbol.for('react.memo') : 0xead3;\nvar REACT_LAZY_TYPE = hasSymbol ? Symbol.for('react.lazy') : 0xead4;\nvar REACT_BLOCK_TYPE = hasSymbol ? Symbol.for('react.block') : 0xead9;\nvar REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for('react.fundamental') : 0xead5;\nvar REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for('react.responder') : 0xead6;\nvar REACT_SCOPE_TYPE = hasSymbol ? Symbol.for('react.scope') : 0xead7;\n\nfunction isValidElementType(type) {\n  return typeof type === 'string' || typeof type === 'function' || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.\n  type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === 'object' && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);\n}\n\nfunction typeOf(object) {\n  if (typeof object === 'object' && object !== null) {\n    var $$typeof = object.$$typeof;\n\n    switch ($$typeof) {\n      case REACT_ELEMENT_TYPE:\n        var type = object.type;\n\n        switch (type) {\n          case REACT_ASYNC_MODE_TYPE:\n          case REACT_CONCURRENT_MODE_TYPE:\n          case REACT_FRAGMENT_TYPE:\n          case REACT_PROFILER_TYPE:\n          case REACT_STRICT_MODE_TYPE:\n          case REACT_SUSPENSE_TYPE:\n            return type;\n\n          default:\n            var $$typeofType = type && type.$$typeof;\n\n            switch ($$typeofType) {\n              case REACT_CONTEXT_TYPE:\n              case REACT_FORWARD_REF_TYPE:\n              case REACT_LAZY_TYPE:\n              case REACT_MEMO_TYPE:\n              case REACT_PROVIDER_TYPE:\n                return $$typeofType;\n\n              default:\n                return $$typeof;\n            }\n\n        }\n\n      case REACT_PORTAL_TYPE:\n        return $$typeof;\n    }\n  }\n\n  return undefined;\n} // AsyncMode is deprecated along with isAsyncMode\n\nvar AsyncMode = REACT_ASYNC_MODE_TYPE;\nvar ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;\nvar ContextConsumer = REACT_CONTEXT_TYPE;\nvar ContextProvider = REACT_PROVIDER_TYPE;\nvar Element = REACT_ELEMENT_TYPE;\nvar ForwardRef = REACT_FORWARD_REF_TYPE;\nvar Fragment = REACT_FRAGMENT_TYPE;\nvar Lazy = REACT_LAZY_TYPE;\nvar Memo = REACT_MEMO_TYPE;\nvar Portal = REACT_PORTAL_TYPE;\nvar Profiler = REACT_PROFILER_TYPE;\nvar StrictMode = REACT_STRICT_MODE_TYPE;\nvar Suspense = REACT_SUSPENSE_TYPE;\nvar hasWarnedAboutDeprecatedIsAsyncMode = false; // AsyncMode should be deprecated\n\nfunction isAsyncMode(object) {\n  {\n    if (!hasWarnedAboutDeprecatedIsAsyncMode) {\n      hasWarnedAboutDeprecatedIsAsyncMode = true; // Using console['warn'] to evade Babel and ESLint\n\n      console['warn']('The ReactIs.isAsyncMode() alias has been deprecated, ' + 'and will be removed in React 17+. Update your code to use ' + 'ReactIs.isConcurrentMode() instead. It has the exact same API.');\n    }\n  }\n\n  return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;\n}\nfunction isConcurrentMode(object) {\n  return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;\n}\nfunction isContextConsumer(object) {\n  return typeOf(object) === REACT_CONTEXT_TYPE;\n}\nfunction isContextProvider(object) {\n  return typeOf(object) === REACT_PROVIDER_TYPE;\n}\nfunction isElement(object) {\n  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n}\nfunction isForwardRef(object) {\n  return typeOf(object) === REACT_FORWARD_REF_TYPE;\n}\nfunction isFragment(object) {\n  return typeOf(object) === REACT_FRAGMENT_TYPE;\n}\nfunction isLazy(object) {\n  return typeOf(object) === REACT_LAZY_TYPE;\n}\nfunction isMemo(object) {\n  return typeOf(object) === REACT_MEMO_TYPE;\n}\nfunction isPortal(object) {\n  return typeOf(object) === REACT_PORTAL_TYPE;\n}\nfunction isProfiler(object) {\n  return typeOf(object) === REACT_PROFILER_TYPE;\n}\nfunction isStrictMode(object) {\n  return typeOf(object) === REACT_STRICT_MODE_TYPE;\n}\nfunction isSuspense(object) {\n  return typeOf(object) === REACT_SUSPENSE_TYPE;\n}\n\nexports.AsyncMode = AsyncMode;\nexports.ConcurrentMode = ConcurrentMode;\nexports.ContextConsumer = ContextConsumer;\nexports.ContextProvider = ContextProvider;\nexports.Element = Element;\nexports.ForwardRef = ForwardRef;\nexports.Fragment = Fragment;\nexports.Lazy = Lazy;\nexports.Memo = Memo;\nexports.Portal = Portal;\nexports.Profiler = Profiler;\nexports.StrictMode = StrictMode;\nexports.Suspense = Suspense;\nexports.isAsyncMode = isAsyncMode;\nexports.isConcurrentMode = isConcurrentMode;\nexports.isContextConsumer = isContextConsumer;\nexports.isContextProvider = isContextProvider;\nexports.isElement = isElement;\nexports.isForwardRef = isForwardRef;\nexports.isFragment = isFragment;\nexports.isLazy = isLazy;\nexports.isMemo = isMemo;\nexports.isPortal = isPortal;\nexports.isProfiler = isProfiler;\nexports.isStrictMode = isStrictMode;\nexports.isSuspense = isSuspense;\nexports.isValidElementType = isValidElementType;\nexports.typeOf = typeOf;\n  })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1pcy9janMvcmVhY3QtaXMuZGV2ZWxvcG1lbnQuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7OztBQUliLElBQUksSUFBcUM7QUFDekM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMkU7QUFDM0U7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEOztBQUVqRDtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7O0FBRWxEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQjtBQUNqQixzQkFBc0I7QUFDdEIsdUJBQXVCO0FBQ3ZCLHVCQUF1QjtBQUN2QixlQUFlO0FBQ2Ysa0JBQWtCO0FBQ2xCLGdCQUFnQjtBQUNoQixZQUFZO0FBQ1osWUFBWTtBQUNaLGNBQWM7QUFDZCxnQkFBZ0I7QUFDaEIsa0JBQWtCO0FBQ2xCLGdCQUFnQjtBQUNoQixtQkFBbUI7QUFDbkIsd0JBQXdCO0FBQ3hCLHlCQUF5QjtBQUN6Qix5QkFBeUI7QUFDekIsaUJBQWlCO0FBQ2pCLG9CQUFvQjtBQUNwQixrQkFBa0I7QUFDbEIsY0FBYztBQUNkLGNBQWM7QUFDZCxnQkFBZ0I7QUFDaEIsa0JBQWtCO0FBQ2xCLG9CQUFvQjtBQUNwQixrQkFBa0I7QUFDbEIsMEJBQTBCO0FBQzFCLGNBQWM7QUFDZCxHQUFHO0FBQ0giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWlzL2Nqcy9yZWFjdC1pcy5kZXZlbG9wbWVudC5qcz84MWY1Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKiBAbGljZW5zZSBSZWFjdCB2MTYuMTMuMVxuICogcmVhY3QtaXMuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cblxuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIChmdW5jdGlvbigpIHtcbid1c2Ugc3RyaWN0JztcblxuLy8gVGhlIFN5bWJvbCB1c2VkIHRvIHRhZyB0aGUgUmVhY3RFbGVtZW50LWxpa2UgdHlwZXMuIElmIHRoZXJlIGlzIG5vIG5hdGl2ZSBTeW1ib2xcbi8vIG5vciBwb2x5ZmlsbCwgdGhlbiBhIHBsYWluIG51bWJlciBpcyB1c2VkIGZvciBwZXJmb3JtYW5jZS5cbnZhciBoYXNTeW1ib2wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5mb3I7XG52YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpIDogMHhlYWM3O1xudmFyIFJFQUNUX1BPUlRBTF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QucG9ydGFsJykgOiAweGVhY2E7XG52YXIgUkVBQ1RfRlJBR01FTlRfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmZyYWdtZW50JykgOiAweGVhY2I7XG52YXIgUkVBQ1RfU1RSSUNUX01PREVfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnN0cmljdF9tb2RlJykgOiAweGVhY2M7XG52YXIgUkVBQ1RfUFJPRklMRVJfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnByb2ZpbGVyJykgOiAweGVhZDI7XG52YXIgUkVBQ1RfUFJPVklERVJfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnByb3ZpZGVyJykgOiAweGVhY2Q7XG52YXIgUkVBQ1RfQ09OVEVYVF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuY29udGV4dCcpIDogMHhlYWNlOyAvLyBUT0RPOiBXZSBkb24ndCB1c2UgQXN5bmNNb2RlIG9yIENvbmN1cnJlbnRNb2RlIGFueW1vcmUuIFRoZXkgd2VyZSB0ZW1wb3Jhcnlcbi8vICh1bnN0YWJsZSkgQVBJcyB0aGF0IGhhdmUgYmVlbiByZW1vdmVkLiBDYW4gd2UgcmVtb3ZlIHRoZSBzeW1ib2xzP1xuXG52YXIgUkVBQ1RfQVNZTkNfTU9ERV9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuYXN5bmNfbW9kZScpIDogMHhlYWNmO1xudmFyIFJFQUNUX0NPTkNVUlJFTlRfTU9ERV9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuY29uY3VycmVudF9tb2RlJykgOiAweGVhY2Y7XG52YXIgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmZvcndhcmRfcmVmJykgOiAweGVhZDA7XG52YXIgUkVBQ1RfU1VTUEVOU0VfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnN1c3BlbnNlJykgOiAweGVhZDE7XG52YXIgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3Quc3VzcGVuc2VfbGlzdCcpIDogMHhlYWQ4O1xudmFyIFJFQUNUX01FTU9fVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0Lm1lbW8nKSA6IDB4ZWFkMztcbnZhciBSRUFDVF9MQVpZX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5sYXp5JykgOiAweGVhZDQ7XG52YXIgUkVBQ1RfQkxPQ0tfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmJsb2NrJykgOiAweGVhZDk7XG52YXIgUkVBQ1RfRlVOREFNRU5UQUxfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmZ1bmRhbWVudGFsJykgOiAweGVhZDU7XG52YXIgUkVBQ1RfUkVTUE9OREVSX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5yZXNwb25kZXInKSA6IDB4ZWFkNjtcbnZhciBSRUFDVF9TQ09QRV9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3Quc2NvcGUnKSA6IDB4ZWFkNztcblxuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpIHtcbiAgcmV0dXJuIHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyB8fCAvLyBOb3RlOiBpdHMgdHlwZW9mIG1pZ2h0IGJlIG90aGVyIHRoYW4gJ3N5bWJvbCcgb3IgJ251bWJlcicgaWYgaXQncyBhIHBvbHlmaWxsLlxuICB0eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX0NPTkNVUlJFTlRfTU9ERV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1BST0ZJTEVSX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSB8fCB0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCAmJiAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTEFaWV9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9QUk9WSURFUl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZVTkRBTUVOVEFMX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfUkVTUE9OREVSX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfU0NPUEVfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9CTE9DS19UWVBFKTtcbn1cblxuZnVuY3Rpb24gdHlwZU9mKG9iamVjdCkge1xuICBpZiAodHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgb2JqZWN0ICE9PSBudWxsKSB7XG4gICAgdmFyICQkdHlwZW9mID0gb2JqZWN0LiQkdHlwZW9mO1xuXG4gICAgc3dpdGNoICgkJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9FTEVNRU5UX1RZUEU6XG4gICAgICAgIHZhciB0eXBlID0gb2JqZWN0LnR5cGU7XG5cbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgY2FzZSBSRUFDVF9BU1lOQ19NT0RFX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9DT05DVVJSRU5UX01PREVfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX0ZSQUdNRU5UX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfU1RSSUNUX01PREVfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gdHlwZTtcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB2YXIgJCR0eXBlb2ZUeXBlID0gdHlwZSAmJiB0eXBlLiQkdHlwZW9mO1xuXG4gICAgICAgICAgICBzd2l0Y2ggKCQkdHlwZW9mVHlwZSkge1xuICAgICAgICAgICAgICBjYXNlIFJFQUNUX0NPTlRFWFRfVFlQRTpcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICAgICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfUFJPVklERVJfVFlQRTpcbiAgICAgICAgICAgICAgICByZXR1cm4gJCR0eXBlb2ZUeXBlO1xuXG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuICQkdHlwZW9mO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgcmV0dXJuICQkdHlwZW9mO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB1bmRlZmluZWQ7XG59IC8vIEFzeW5jTW9kZSBpcyBkZXByZWNhdGVkIGFsb25nIHdpdGggaXNBc3luY01vZGVcblxudmFyIEFzeW5jTW9kZSA9IFJFQUNUX0FTWU5DX01PREVfVFlQRTtcbnZhciBDb25jdXJyZW50TW9kZSA9IFJFQUNUX0NPTkNVUlJFTlRfTU9ERV9UWVBFO1xudmFyIENvbnRleHRDb25zdW1lciA9IFJFQUNUX0NPTlRFWFRfVFlQRTtcbnZhciBDb250ZXh0UHJvdmlkZXIgPSBSRUFDVF9QUk9WSURFUl9UWVBFO1xudmFyIEVsZW1lbnQgPSBSRUFDVF9FTEVNRU5UX1RZUEU7XG52YXIgRm9yd2FyZFJlZiA9IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU7XG52YXIgRnJhZ21lbnQgPSBSRUFDVF9GUkFHTUVOVF9UWVBFO1xudmFyIExhenkgPSBSRUFDVF9MQVpZX1RZUEU7XG52YXIgTWVtbyA9IFJFQUNUX01FTU9fVFlQRTtcbnZhciBQb3J0YWwgPSBSRUFDVF9QT1JUQUxfVFlQRTtcbnZhciBQcm9maWxlciA9IFJFQUNUX1BST0ZJTEVSX1RZUEU7XG52YXIgU3RyaWN0TW9kZSA9IFJFQUNUX1NUUklDVF9NT0RFX1RZUEU7XG52YXIgU3VzcGVuc2UgPSBSRUFDVF9TVVNQRU5TRV9UWVBFO1xudmFyIGhhc1dhcm5lZEFib3V0RGVwcmVjYXRlZElzQXN5bmNNb2RlID0gZmFsc2U7IC8vIEFzeW5jTW9kZSBzaG91bGQgYmUgZGVwcmVjYXRlZFxuXG5mdW5jdGlvbiBpc0FzeW5jTW9kZShvYmplY3QpIHtcbiAge1xuICAgIGlmICghaGFzV2FybmVkQWJvdXREZXByZWNhdGVkSXNBc3luY01vZGUpIHtcbiAgICAgIGhhc1dhcm5lZEFib3V0RGVwcmVjYXRlZElzQXN5bmNNb2RlID0gdHJ1ZTsgLy8gVXNpbmcgY29uc29sZVsnd2FybiddIHRvIGV2YWRlIEJhYmVsIGFuZCBFU0xpbnRcblxuICAgICAgY29uc29sZVsnd2FybiddKCdUaGUgUmVhY3RJcy5pc0FzeW5jTW9kZSgpIGFsaWFzIGhhcyBiZWVuIGRlcHJlY2F0ZWQsICcgKyAnYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBSZWFjdCAxNysuIFVwZGF0ZSB5b3VyIGNvZGUgdG8gdXNlICcgKyAnUmVhY3RJcy5pc0NvbmN1cnJlbnRNb2RlKCkgaW5zdGVhZC4gSXQgaGFzIHRoZSBleGFjdCBzYW1lIEFQSS4nKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gaXNDb25jdXJyZW50TW9kZShvYmplY3QpIHx8IHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9BU1lOQ19NT0RFX1RZUEU7XG59XG5mdW5jdGlvbiBpc0NvbmN1cnJlbnRNb2RlKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX0NPTkNVUlJFTlRfTU9ERV9UWVBFO1xufVxuZnVuY3Rpb24gaXNDb250ZXh0Q29uc3VtZXIob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFO1xufVxuZnVuY3Rpb24gaXNDb250ZXh0UHJvdmlkZXIob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfUFJPVklERVJfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzRWxlbWVudChvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdCAhPT0gbnVsbCAmJiBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzRm9yd2FyZFJlZihvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFO1xufVxuZnVuY3Rpb24gaXNGcmFnbWVudChvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFO1xufVxuZnVuY3Rpb24gaXNMYXp5KG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX0xBWllfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzTWVtbyhvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9NRU1PX1RZUEU7XG59XG5mdW5jdGlvbiBpc1BvcnRhbChvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9QT1JUQUxfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzUHJvZmlsZXIob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfUFJPRklMRVJfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzU3RyaWN0TW9kZShvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFO1xufVxuZnVuY3Rpb24gaXNTdXNwZW5zZShvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9TVVNQRU5TRV9UWVBFO1xufVxuXG5leHBvcnRzLkFzeW5jTW9kZSA9IEFzeW5jTW9kZTtcbmV4cG9ydHMuQ29uY3VycmVudE1vZGUgPSBDb25jdXJyZW50TW9kZTtcbmV4cG9ydHMuQ29udGV4dENvbnN1bWVyID0gQ29udGV4dENvbnN1bWVyO1xuZXhwb3J0cy5Db250ZXh0UHJvdmlkZXIgPSBDb250ZXh0UHJvdmlkZXI7XG5leHBvcnRzLkVsZW1lbnQgPSBFbGVtZW50O1xuZXhwb3J0cy5Gb3J3YXJkUmVmID0gRm9yd2FyZFJlZjtcbmV4cG9ydHMuRnJhZ21lbnQgPSBGcmFnbWVudDtcbmV4cG9ydHMuTGF6eSA9IExhenk7XG5leHBvcnRzLk1lbW8gPSBNZW1vO1xuZXhwb3J0cy5Qb3J0YWwgPSBQb3J0YWw7XG5leHBvcnRzLlByb2ZpbGVyID0gUHJvZmlsZXI7XG5leHBvcnRzLlN0cmljdE1vZGUgPSBTdHJpY3RNb2RlO1xuZXhwb3J0cy5TdXNwZW5zZSA9IFN1c3BlbnNlO1xuZXhwb3J0cy5pc0FzeW5jTW9kZSA9IGlzQXN5bmNNb2RlO1xuZXhwb3J0cy5pc0NvbmN1cnJlbnRNb2RlID0gaXNDb25jdXJyZW50TW9kZTtcbmV4cG9ydHMuaXNDb250ZXh0Q29uc3VtZXIgPSBpc0NvbnRleHRDb25zdW1lcjtcbmV4cG9ydHMuaXNDb250ZXh0UHJvdmlkZXIgPSBpc0NvbnRleHRQcm92aWRlcjtcbmV4cG9ydHMuaXNFbGVtZW50ID0gaXNFbGVtZW50O1xuZXhwb3J0cy5pc0ZvcndhcmRSZWYgPSBpc0ZvcndhcmRSZWY7XG5leHBvcnRzLmlzRnJhZ21lbnQgPSBpc0ZyYWdtZW50O1xuZXhwb3J0cy5pc0xhenkgPSBpc0xhenk7XG5leHBvcnRzLmlzTWVtbyA9IGlzTWVtbztcbmV4cG9ydHMuaXNQb3J0YWwgPSBpc1BvcnRhbDtcbmV4cG9ydHMuaXNQcm9maWxlciA9IGlzUHJvZmlsZXI7XG5leHBvcnRzLmlzU3RyaWN0TW9kZSA9IGlzU3RyaWN0TW9kZTtcbmV4cG9ydHMuaXNTdXNwZW5zZSA9IGlzU3VzcGVuc2U7XG5leHBvcnRzLmlzVmFsaWRFbGVtZW50VHlwZSA9IGlzVmFsaWRFbGVtZW50VHlwZTtcbmV4cG9ydHMudHlwZU9mID0gdHlwZU9mO1xuICB9KSgpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-is/cjs/react-is.development.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-is/index.js":
/*!****************************************!*\
  !*** ./node_modules/react-is/index.js ***!
  \****************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-is.development.js */ \"(app-pages-browser)/./node_modules/react-is/cjs/react-is.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1pcy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixJQUFJLEtBQXFDLEVBQUUsRUFFMUMsQ0FBQztBQUNGLEVBQUUsb0pBQXlEO0FBQzNEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFjdC1pcy9pbmRleC5qcz8yYmRlIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1pcy5wcm9kdWN0aW9uLm1pbi5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1pcy5kZXZlbG9wbWVudC5qcycpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-is/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-pdf/node_modules/pdfjs-dist/build/pdf.js":
/*!*********************************************************************!*\
  !*** ./node_modules/react-pdf/node_modules/pdfjs-dist/build/pdf.js ***!
  \*********************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"(app-pages-browser)/./node_modules/next/dist/compiled/buffer/index.js\")[\"Buffer\"];\n/**\n * @licstart The following is the entire license notice for the\n * JavaScript code in this page\n *\n * Copyright 2023 Mozilla Foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * @licend The above is the entire license notice for the\n * JavaScript code in this page\n */\n\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(true)\n\t\tmodule.exports = root.pdfjsLib = factory();\n\telse {}\n})(globalThis, () => {\nreturn /******/ (() => { // webpackBootstrap\n/******/ \t\"use strict\";\n/******/ \tvar __webpack_modules__ = ([\n/* 0 */,\n/* 1 */\n/***/ ((__unused_webpack_module, exports) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.VerbosityLevel = exports.Util = exports.UnknownErrorException = exports.UnexpectedResponseException = exports.TextRenderingMode = exports.RenderingIntentFlag = exports.PromiseCapability = exports.PermissionFlag = exports.PasswordResponses = exports.PasswordException = exports.PageActionEventType = exports.OPS = exports.MissingPDFException = exports.MAX_IMAGE_SIZE_TO_CACHE = exports.LINE_FACTOR = exports.LINE_DESCENT_FACTOR = exports.InvalidPDFException = exports.ImageKind = exports.IDENTITY_MATRIX = exports.FormatError = exports.FeatureTest = exports.FONT_IDENTITY_MATRIX = exports.DocumentActionEventType = exports.CMapCompressionType = exports.BaseException = exports.BASELINE_FACTOR = exports.AnnotationType = exports.AnnotationReplyType = exports.AnnotationPrefix = exports.AnnotationMode = exports.AnnotationFlag = exports.AnnotationFieldFlag = exports.AnnotationEditorType = exports.AnnotationEditorPrefix = exports.AnnotationEditorParamsType = exports.AnnotationBorderStyleType = exports.AnnotationActionEventType = exports.AbortException = void 0;\nexports.assert = assert;\nexports.bytesToString = bytesToString;\nexports.createValidAbsoluteUrl = createValidAbsoluteUrl;\nexports.getModificationDate = getModificationDate;\nexports.getUuid = getUuid;\nexports.getVerbosityLevel = getVerbosityLevel;\nexports.info = info;\nexports.isArrayBuffer = isArrayBuffer;\nexports.isArrayEqual = isArrayEqual;\nexports.isNodeJS = void 0;\nexports.normalizeUnicode = normalizeUnicode;\nexports.objectFromMap = objectFromMap;\nexports.objectSize = objectSize;\nexports.setVerbosityLevel = setVerbosityLevel;\nexports.shadow = shadow;\nexports.string32 = string32;\nexports.stringToBytes = stringToBytes;\nexports.stringToPDFString = stringToPDFString;\nexports.stringToUTF8String = stringToUTF8String;\nexports.unreachable = unreachable;\nexports.utf8StringToString = utf8StringToString;\nexports.warn = warn;\nconst isNodeJS = typeof process === \"object\" && process + \"\" === \"[object process]\" && !process.versions.nw && !(process.versions.electron && process.type && process.type !== \"browser\");\nexports.isNodeJS = isNodeJS;\nconst IDENTITY_MATRIX = [1, 0, 0, 1, 0, 0];\nexports.IDENTITY_MATRIX = IDENTITY_MATRIX;\nconst FONT_IDENTITY_MATRIX = [0.001, 0, 0, 0.001, 0, 0];\nexports.FONT_IDENTITY_MATRIX = FONT_IDENTITY_MATRIX;\nconst MAX_IMAGE_SIZE_TO_CACHE = 10e6;\nexports.MAX_IMAGE_SIZE_TO_CACHE = MAX_IMAGE_SIZE_TO_CACHE;\nconst LINE_FACTOR = 1.35;\nexports.LINE_FACTOR = LINE_FACTOR;\nconst LINE_DESCENT_FACTOR = 0.35;\nexports.LINE_DESCENT_FACTOR = LINE_DESCENT_FACTOR;\nconst BASELINE_FACTOR = LINE_DESCENT_FACTOR / LINE_FACTOR;\nexports.BASELINE_FACTOR = BASELINE_FACTOR;\nconst RenderingIntentFlag = {\n  ANY: 0x01,\n  DISPLAY: 0x02,\n  PRINT: 0x04,\n  SAVE: 0x08,\n  ANNOTATIONS_FORMS: 0x10,\n  ANNOTATIONS_STORAGE: 0x20,\n  ANNOTATIONS_DISABLE: 0x40,\n  OPLIST: 0x100\n};\nexports.RenderingIntentFlag = RenderingIntentFlag;\nconst AnnotationMode = {\n  DISABLE: 0,\n  ENABLE: 1,\n  ENABLE_FORMS: 2,\n  ENABLE_STORAGE: 3\n};\nexports.AnnotationMode = AnnotationMode;\nconst AnnotationEditorPrefix = \"pdfjs_internal_editor_\";\nexports.AnnotationEditorPrefix = AnnotationEditorPrefix;\nconst AnnotationEditorType = {\n  DISABLE: -1,\n  NONE: 0,\n  FREETEXT: 3,\n  STAMP: 13,\n  INK: 15\n};\nexports.AnnotationEditorType = AnnotationEditorType;\nconst AnnotationEditorParamsType = {\n  RESIZE: 1,\n  CREATE: 2,\n  FREETEXT_SIZE: 11,\n  FREETEXT_COLOR: 12,\n  FREETEXT_OPACITY: 13,\n  INK_COLOR: 21,\n  INK_THICKNESS: 22,\n  INK_OPACITY: 23\n};\nexports.AnnotationEditorParamsType = AnnotationEditorParamsType;\nconst PermissionFlag = {\n  PRINT: 0x04,\n  MODIFY_CONTENTS: 0x08,\n  COPY: 0x10,\n  MODIFY_ANNOTATIONS: 0x20,\n  FILL_INTERACTIVE_FORMS: 0x100,\n  COPY_FOR_ACCESSIBILITY: 0x200,\n  ASSEMBLE: 0x400,\n  PRINT_HIGH_QUALITY: 0x800\n};\nexports.PermissionFlag = PermissionFlag;\nconst TextRenderingMode = {\n  FILL: 0,\n  STROKE: 1,\n  FILL_STROKE: 2,\n  INVISIBLE: 3,\n  FILL_ADD_TO_PATH: 4,\n  STROKE_ADD_TO_PATH: 5,\n  FILL_STROKE_ADD_TO_PATH: 6,\n  ADD_TO_PATH: 7,\n  FILL_STROKE_MASK: 3,\n  ADD_TO_PATH_FLAG: 4\n};\nexports.TextRenderingMode = TextRenderingMode;\nconst ImageKind = {\n  GRAYSCALE_1BPP: 1,\n  RGB_24BPP: 2,\n  RGBA_32BPP: 3\n};\nexports.ImageKind = ImageKind;\nconst AnnotationType = {\n  TEXT: 1,\n  LINK: 2,\n  FREETEXT: 3,\n  LINE: 4,\n  SQUARE: 5,\n  CIRCLE: 6,\n  POLYGON: 7,\n  POLYLINE: 8,\n  HIGHLIGHT: 9,\n  UNDERLINE: 10,\n  SQUIGGLY: 11,\n  STRIKEOUT: 12,\n  STAMP: 13,\n  CARET: 14,\n  INK: 15,\n  POPUP: 16,\n  FILEATTACHMENT: 17,\n  SOUND: 18,\n  MOVIE: 19,\n  WIDGET: 20,\n  SCREEN: 21,\n  PRINTERMARK: 22,\n  TRAPNET: 23,\n  WATERMARK: 24,\n  THREED: 25,\n  REDACT: 26\n};\nexports.AnnotationType = AnnotationType;\nconst AnnotationReplyType = {\n  GROUP: \"Group\",\n  REPLY: \"R\"\n};\nexports.AnnotationReplyType = AnnotationReplyType;\nconst AnnotationFlag = {\n  INVISIBLE: 0x01,\n  HIDDEN: 0x02,\n  PRINT: 0x04,\n  NOZOOM: 0x08,\n  NOROTATE: 0x10,\n  NOVIEW: 0x20,\n  READONLY: 0x40,\n  LOCKED: 0x80,\n  TOGGLENOVIEW: 0x100,\n  LOCKEDCONTENTS: 0x200\n};\nexports.AnnotationFlag = AnnotationFlag;\nconst AnnotationFieldFlag = {\n  READONLY: 0x0000001,\n  REQUIRED: 0x0000002,\n  NOEXPORT: 0x0000004,\n  MULTILINE: 0x0001000,\n  PASSWORD: 0x0002000,\n  NOTOGGLETOOFF: 0x0004000,\n  RADIO: 0x0008000,\n  PUSHBUTTON: 0x0010000,\n  COMBO: 0x0020000,\n  EDIT: 0x0040000,\n  SORT: 0x0080000,\n  FILESELECT: 0x0100000,\n  MULTISELECT: 0x0200000,\n  DONOTSPELLCHECK: 0x0400000,\n  DONOTSCROLL: 0x0800000,\n  COMB: 0x1000000,\n  RICHTEXT: 0x2000000,\n  RADIOSINUNISON: 0x2000000,\n  COMMITONSELCHANGE: 0x4000000\n};\nexports.AnnotationFieldFlag = AnnotationFieldFlag;\nconst AnnotationBorderStyleType = {\n  SOLID: 1,\n  DASHED: 2,\n  BEVELED: 3,\n  INSET: 4,\n  UNDERLINE: 5\n};\nexports.AnnotationBorderStyleType = AnnotationBorderStyleType;\nconst AnnotationActionEventType = {\n  E: \"Mouse Enter\",\n  X: \"Mouse Exit\",\n  D: \"Mouse Down\",\n  U: \"Mouse Up\",\n  Fo: \"Focus\",\n  Bl: \"Blur\",\n  PO: \"PageOpen\",\n  PC: \"PageClose\",\n  PV: \"PageVisible\",\n  PI: \"PageInvisible\",\n  K: \"Keystroke\",\n  F: \"Format\",\n  V: \"Validate\",\n  C: \"Calculate\"\n};\nexports.AnnotationActionEventType = AnnotationActionEventType;\nconst DocumentActionEventType = {\n  WC: \"WillClose\",\n  WS: \"WillSave\",\n  DS: \"DidSave\",\n  WP: \"WillPrint\",\n  DP: \"DidPrint\"\n};\nexports.DocumentActionEventType = DocumentActionEventType;\nconst PageActionEventType = {\n  O: \"PageOpen\",\n  C: \"PageClose\"\n};\nexports.PageActionEventType = PageActionEventType;\nconst VerbosityLevel = {\n  ERRORS: 0,\n  WARNINGS: 1,\n  INFOS: 5\n};\nexports.VerbosityLevel = VerbosityLevel;\nconst CMapCompressionType = {\n  NONE: 0,\n  BINARY: 1\n};\nexports.CMapCompressionType = CMapCompressionType;\nconst OPS = {\n  dependency: 1,\n  setLineWidth: 2,\n  setLineCap: 3,\n  setLineJoin: 4,\n  setMiterLimit: 5,\n  setDash: 6,\n  setRenderingIntent: 7,\n  setFlatness: 8,\n  setGState: 9,\n  save: 10,\n  restore: 11,\n  transform: 12,\n  moveTo: 13,\n  lineTo: 14,\n  curveTo: 15,\n  curveTo2: 16,\n  curveTo3: 17,\n  closePath: 18,\n  rectangle: 19,\n  stroke: 20,\n  closeStroke: 21,\n  fill: 22,\n  eoFill: 23,\n  fillStroke: 24,\n  eoFillStroke: 25,\n  closeFillStroke: 26,\n  closeEOFillStroke: 27,\n  endPath: 28,\n  clip: 29,\n  eoClip: 30,\n  beginText: 31,\n  endText: 32,\n  setCharSpacing: 33,\n  setWordSpacing: 34,\n  setHScale: 35,\n  setLeading: 36,\n  setFont: 37,\n  setTextRenderingMode: 38,\n  setTextRise: 39,\n  moveText: 40,\n  setLeadingMoveText: 41,\n  setTextMatrix: 42,\n  nextLine: 43,\n  showText: 44,\n  showSpacedText: 45,\n  nextLineShowText: 46,\n  nextLineSetSpacingShowText: 47,\n  setCharWidth: 48,\n  setCharWidthAndBounds: 49,\n  setStrokeColorSpace: 50,\n  setFillColorSpace: 51,\n  setStrokeColor: 52,\n  setStrokeColorN: 53,\n  setFillColor: 54,\n  setFillColorN: 55,\n  setStrokeGray: 56,\n  setFillGray: 57,\n  setStrokeRGBColor: 58,\n  setFillRGBColor: 59,\n  setStrokeCMYKColor: 60,\n  setFillCMYKColor: 61,\n  shadingFill: 62,\n  beginInlineImage: 63,\n  beginImageData: 64,\n  endInlineImage: 65,\n  paintXObject: 66,\n  markPoint: 67,\n  markPointProps: 68,\n  beginMarkedContent: 69,\n  beginMarkedContentProps: 70,\n  endMarkedContent: 71,\n  beginCompat: 72,\n  endCompat: 73,\n  paintFormXObjectBegin: 74,\n  paintFormXObjectEnd: 75,\n  beginGroup: 76,\n  endGroup: 77,\n  beginAnnotation: 80,\n  endAnnotation: 81,\n  paintImageMaskXObject: 83,\n  paintImageMaskXObjectGroup: 84,\n  paintImageXObject: 85,\n  paintInlineImageXObject: 86,\n  paintInlineImageXObjectGroup: 87,\n  paintImageXObjectRepeat: 88,\n  paintImageMaskXObjectRepeat: 89,\n  paintSolidColorImageMask: 90,\n  constructPath: 91\n};\nexports.OPS = OPS;\nconst PasswordResponses = {\n  NEED_PASSWORD: 1,\n  INCORRECT_PASSWORD: 2\n};\nexports.PasswordResponses = PasswordResponses;\nlet verbosity = VerbosityLevel.WARNINGS;\nfunction setVerbosityLevel(level) {\n  if (Number.isInteger(level)) {\n    verbosity = level;\n  }\n}\nfunction getVerbosityLevel() {\n  return verbosity;\n}\nfunction info(msg) {\n  if (verbosity >= VerbosityLevel.INFOS) {\n    console.log(`Info: ${msg}`);\n  }\n}\nfunction warn(msg) {\n  if (verbosity >= VerbosityLevel.WARNINGS) {\n    console.log(`Warning: ${msg}`);\n  }\n}\nfunction unreachable(msg) {\n  throw new Error(msg);\n}\nfunction assert(cond, msg) {\n  if (!cond) {\n    unreachable(msg);\n  }\n}\nfunction _isValidProtocol(url) {\n  switch (url?.protocol) {\n    case \"http:\":\n    case \"https:\":\n    case \"ftp:\":\n    case \"mailto:\":\n    case \"tel:\":\n      return true;\n    default:\n      return false;\n  }\n}\nfunction createValidAbsoluteUrl(url, baseUrl = null, options = null) {\n  if (!url) {\n    return null;\n  }\n  try {\n    if (options && typeof url === \"string\") {\n      if (options.addDefaultProtocol && url.startsWith(\"www.\")) {\n        const dots = url.match(/\\./g);\n        if (dots?.length >= 2) {\n          url = `http://${url}`;\n        }\n      }\n      if (options.tryConvertEncoding) {\n        try {\n          url = stringToUTF8String(url);\n        } catch {}\n      }\n    }\n    const absoluteUrl = baseUrl ? new URL(url, baseUrl) : new URL(url);\n    if (_isValidProtocol(absoluteUrl)) {\n      return absoluteUrl;\n    }\n  } catch {}\n  return null;\n}\nfunction shadow(obj, prop, value, nonSerializable = false) {\n  Object.defineProperty(obj, prop, {\n    value,\n    enumerable: !nonSerializable,\n    configurable: true,\n    writable: false\n  });\n  return value;\n}\nconst BaseException = function BaseExceptionClosure() {\n  function BaseException(message, name) {\n    if (this.constructor === BaseException) {\n      unreachable(\"Cannot initialize BaseException.\");\n    }\n    this.message = message;\n    this.name = name;\n  }\n  BaseException.prototype = new Error();\n  BaseException.constructor = BaseException;\n  return BaseException;\n}();\nexports.BaseException = BaseException;\nclass PasswordException extends BaseException {\n  constructor(msg, code) {\n    super(msg, \"PasswordException\");\n    this.code = code;\n  }\n}\nexports.PasswordException = PasswordException;\nclass UnknownErrorException extends BaseException {\n  constructor(msg, details) {\n    super(msg, \"UnknownErrorException\");\n    this.details = details;\n  }\n}\nexports.UnknownErrorException = UnknownErrorException;\nclass InvalidPDFException extends BaseException {\n  constructor(msg) {\n    super(msg, \"InvalidPDFException\");\n  }\n}\nexports.InvalidPDFException = InvalidPDFException;\nclass MissingPDFException extends BaseException {\n  constructor(msg) {\n    super(msg, \"MissingPDFException\");\n  }\n}\nexports.MissingPDFException = MissingPDFException;\nclass UnexpectedResponseException extends BaseException {\n  constructor(msg, status) {\n    super(msg, \"UnexpectedResponseException\");\n    this.status = status;\n  }\n}\nexports.UnexpectedResponseException = UnexpectedResponseException;\nclass FormatError extends BaseException {\n  constructor(msg) {\n    super(msg, \"FormatError\");\n  }\n}\nexports.FormatError = FormatError;\nclass AbortException extends BaseException {\n  constructor(msg) {\n    super(msg, \"AbortException\");\n  }\n}\nexports.AbortException = AbortException;\nfunction bytesToString(bytes) {\n  if (typeof bytes !== \"object\" || bytes?.length === undefined) {\n    unreachable(\"Invalid argument for bytesToString\");\n  }\n  const length = bytes.length;\n  const MAX_ARGUMENT_COUNT = 8192;\n  if (length < MAX_ARGUMENT_COUNT) {\n    return String.fromCharCode.apply(null, bytes);\n  }\n  const strBuf = [];\n  for (let i = 0; i < length; i += MAX_ARGUMENT_COUNT) {\n    const chunkEnd = Math.min(i + MAX_ARGUMENT_COUNT, length);\n    const chunk = bytes.subarray(i, chunkEnd);\n    strBuf.push(String.fromCharCode.apply(null, chunk));\n  }\n  return strBuf.join(\"\");\n}\nfunction stringToBytes(str) {\n  if (typeof str !== \"string\") {\n    unreachable(\"Invalid argument for stringToBytes\");\n  }\n  const length = str.length;\n  const bytes = new Uint8Array(length);\n  for (let i = 0; i < length; ++i) {\n    bytes[i] = str.charCodeAt(i) & 0xff;\n  }\n  return bytes;\n}\nfunction string32(value) {\n  return String.fromCharCode(value >> 24 & 0xff, value >> 16 & 0xff, value >> 8 & 0xff, value & 0xff);\n}\nfunction objectSize(obj) {\n  return Object.keys(obj).length;\n}\nfunction objectFromMap(map) {\n  const obj = Object.create(null);\n  for (const [key, value] of map) {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction isLittleEndian() {\n  const buffer8 = new Uint8Array(4);\n  buffer8[0] = 1;\n  const view32 = new Uint32Array(buffer8.buffer, 0, 1);\n  return view32[0] === 1;\n}\nfunction isEvalSupported() {\n  try {\n    new Function(\"\");\n    return true;\n  } catch {\n    return false;\n  }\n}\nclass FeatureTest {\n  static get isLittleEndian() {\n    return shadow(this, \"isLittleEndian\", isLittleEndian());\n  }\n  static get isEvalSupported() {\n    return shadow(this, \"isEvalSupported\", isEvalSupported());\n  }\n  static get isOffscreenCanvasSupported() {\n    return shadow(this, \"isOffscreenCanvasSupported\", typeof OffscreenCanvas !== \"undefined\");\n  }\n  static get platform() {\n    if (typeof navigator === \"undefined\") {\n      return shadow(this, \"platform\", {\n        isWin: false,\n        isMac: false\n      });\n    }\n    return shadow(this, \"platform\", {\n      isWin: navigator.platform.includes(\"Win\"),\n      isMac: navigator.platform.includes(\"Mac\")\n    });\n  }\n  static get isCSSRoundSupported() {\n    return shadow(this, \"isCSSRoundSupported\", globalThis.CSS?.supports?.(\"width: round(1.5px, 1px)\"));\n  }\n}\nexports.FeatureTest = FeatureTest;\nconst hexNumbers = [...Array(256).keys()].map(n => n.toString(16).padStart(2, \"0\"));\nclass Util {\n  static makeHexColor(r, g, b) {\n    return `#${hexNumbers[r]}${hexNumbers[g]}${hexNumbers[b]}`;\n  }\n  static scaleMinMax(transform, minMax) {\n    let temp;\n    if (transform[0]) {\n      if (transform[0] < 0) {\n        temp = minMax[0];\n        minMax[0] = minMax[1];\n        minMax[1] = temp;\n      }\n      minMax[0] *= transform[0];\n      minMax[1] *= transform[0];\n      if (transform[3] < 0) {\n        temp = minMax[2];\n        minMax[2] = minMax[3];\n        minMax[3] = temp;\n      }\n      minMax[2] *= transform[3];\n      minMax[3] *= transform[3];\n    } else {\n      temp = minMax[0];\n      minMax[0] = minMax[2];\n      minMax[2] = temp;\n      temp = minMax[1];\n      minMax[1] = minMax[3];\n      minMax[3] = temp;\n      if (transform[1] < 0) {\n        temp = minMax[2];\n        minMax[2] = minMax[3];\n        minMax[3] = temp;\n      }\n      minMax[2] *= transform[1];\n      minMax[3] *= transform[1];\n      if (transform[2] < 0) {\n        temp = minMax[0];\n        minMax[0] = minMax[1];\n        minMax[1] = temp;\n      }\n      minMax[0] *= transform[2];\n      minMax[1] *= transform[2];\n    }\n    minMax[0] += transform[4];\n    minMax[1] += transform[4];\n    minMax[2] += transform[5];\n    minMax[3] += transform[5];\n  }\n  static transform(m1, m2) {\n    return [m1[0] * m2[0] + m1[2] * m2[1], m1[1] * m2[0] + m1[3] * m2[1], m1[0] * m2[2] + m1[2] * m2[3], m1[1] * m2[2] + m1[3] * m2[3], m1[0] * m2[4] + m1[2] * m2[5] + m1[4], m1[1] * m2[4] + m1[3] * m2[5] + m1[5]];\n  }\n  static applyTransform(p, m) {\n    const xt = p[0] * m[0] + p[1] * m[2] + m[4];\n    const yt = p[0] * m[1] + p[1] * m[3] + m[5];\n    return [xt, yt];\n  }\n  static applyInverseTransform(p, m) {\n    const d = m[0] * m[3] - m[1] * m[2];\n    const xt = (p[0] * m[3] - p[1] * m[2] + m[2] * m[5] - m[4] * m[3]) / d;\n    const yt = (-p[0] * m[1] + p[1] * m[0] + m[4] * m[1] - m[5] * m[0]) / d;\n    return [xt, yt];\n  }\n  static getAxialAlignedBoundingBox(r, m) {\n    const p1 = this.applyTransform(r, m);\n    const p2 = this.applyTransform(r.slice(2, 4), m);\n    const p3 = this.applyTransform([r[0], r[3]], m);\n    const p4 = this.applyTransform([r[2], r[1]], m);\n    return [Math.min(p1[0], p2[0], p3[0], p4[0]), Math.min(p1[1], p2[1], p3[1], p4[1]), Math.max(p1[0], p2[0], p3[0], p4[0]), Math.max(p1[1], p2[1], p3[1], p4[1])];\n  }\n  static inverseTransform(m) {\n    const d = m[0] * m[3] - m[1] * m[2];\n    return [m[3] / d, -m[1] / d, -m[2] / d, m[0] / d, (m[2] * m[5] - m[4] * m[3]) / d, (m[4] * m[1] - m[5] * m[0]) / d];\n  }\n  static singularValueDecompose2dScale(m) {\n    const transpose = [m[0], m[2], m[1], m[3]];\n    const a = m[0] * transpose[0] + m[1] * transpose[2];\n    const b = m[0] * transpose[1] + m[1] * transpose[3];\n    const c = m[2] * transpose[0] + m[3] * transpose[2];\n    const d = m[2] * transpose[1] + m[3] * transpose[3];\n    const first = (a + d) / 2;\n    const second = Math.sqrt((a + d) ** 2 - 4 * (a * d - c * b)) / 2;\n    const sx = first + second || 1;\n    const sy = first - second || 1;\n    return [Math.sqrt(sx), Math.sqrt(sy)];\n  }\n  static normalizeRect(rect) {\n    const r = rect.slice(0);\n    if (rect[0] > rect[2]) {\n      r[0] = rect[2];\n      r[2] = rect[0];\n    }\n    if (rect[1] > rect[3]) {\n      r[1] = rect[3];\n      r[3] = rect[1];\n    }\n    return r;\n  }\n  static intersect(rect1, rect2) {\n    const xLow = Math.max(Math.min(rect1[0], rect1[2]), Math.min(rect2[0], rect2[2]));\n    const xHigh = Math.min(Math.max(rect1[0], rect1[2]), Math.max(rect2[0], rect2[2]));\n    if (xLow > xHigh) {\n      return null;\n    }\n    const yLow = Math.max(Math.min(rect1[1], rect1[3]), Math.min(rect2[1], rect2[3]));\n    const yHigh = Math.min(Math.max(rect1[1], rect1[3]), Math.max(rect2[1], rect2[3]));\n    if (yLow > yHigh) {\n      return null;\n    }\n    return [xLow, yLow, xHigh, yHigh];\n  }\n  static bezierBoundingBox(x0, y0, x1, y1, x2, y2, x3, y3) {\n    const tvalues = [],\n      bounds = [[], []];\n    let a, b, c, t, t1, t2, b2ac, sqrtb2ac;\n    for (let i = 0; i < 2; ++i) {\n      if (i === 0) {\n        b = 6 * x0 - 12 * x1 + 6 * x2;\n        a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;\n        c = 3 * x1 - 3 * x0;\n      } else {\n        b = 6 * y0 - 12 * y1 + 6 * y2;\n        a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;\n        c = 3 * y1 - 3 * y0;\n      }\n      if (Math.abs(a) < 1e-12) {\n        if (Math.abs(b) < 1e-12) {\n          continue;\n        }\n        t = -c / b;\n        if (0 < t && t < 1) {\n          tvalues.push(t);\n        }\n        continue;\n      }\n      b2ac = b * b - 4 * c * a;\n      sqrtb2ac = Math.sqrt(b2ac);\n      if (b2ac < 0) {\n        continue;\n      }\n      t1 = (-b + sqrtb2ac) / (2 * a);\n      if (0 < t1 && t1 < 1) {\n        tvalues.push(t1);\n      }\n      t2 = (-b - sqrtb2ac) / (2 * a);\n      if (0 < t2 && t2 < 1) {\n        tvalues.push(t2);\n      }\n    }\n    let j = tvalues.length,\n      mt;\n    const jlen = j;\n    while (j--) {\n      t = tvalues[j];\n      mt = 1 - t;\n      bounds[0][j] = mt * mt * mt * x0 + 3 * mt * mt * t * x1 + 3 * mt * t * t * x2 + t * t * t * x3;\n      bounds[1][j] = mt * mt * mt * y0 + 3 * mt * mt * t * y1 + 3 * mt * t * t * y2 + t * t * t * y3;\n    }\n    bounds[0][jlen] = x0;\n    bounds[1][jlen] = y0;\n    bounds[0][jlen + 1] = x3;\n    bounds[1][jlen + 1] = y3;\n    bounds[0].length = bounds[1].length = jlen + 2;\n    return [Math.min(...bounds[0]), Math.min(...bounds[1]), Math.max(...bounds[0]), Math.max(...bounds[1])];\n  }\n}\nexports.Util = Util;\nconst PDFStringTranslateTable = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x2d8, 0x2c7, 0x2c6, 0x2d9, 0x2dd, 0x2db, 0x2da, 0x2dc, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x2022, 0x2020, 0x2021, 0x2026, 0x2014, 0x2013, 0x192, 0x2044, 0x2039, 0x203a, 0x2212, 0x2030, 0x201e, 0x201c, 0x201d, 0x2018, 0x2019, 0x201a, 0x2122, 0xfb01, 0xfb02, 0x141, 0x152, 0x160, 0x178, 0x17d, 0x131, 0x142, 0x153, 0x161, 0x17e, 0, 0x20ac];\nfunction stringToPDFString(str) {\n  if (str[0] >= \"\\xEF\") {\n    let encoding;\n    if (str[0] === \"\\xFE\" && str[1] === \"\\xFF\") {\n      encoding = \"utf-16be\";\n    } else if (str[0] === \"\\xFF\" && str[1] === \"\\xFE\") {\n      encoding = \"utf-16le\";\n    } else if (str[0] === \"\\xEF\" && str[1] === \"\\xBB\" && str[2] === \"\\xBF\") {\n      encoding = \"utf-8\";\n    }\n    if (encoding) {\n      try {\n        const decoder = new TextDecoder(encoding, {\n          fatal: true\n        });\n        const buffer = stringToBytes(str);\n        return decoder.decode(buffer);\n      } catch (ex) {\n        warn(`stringToPDFString: \"${ex}\".`);\n      }\n    }\n  }\n  const strBuf = [];\n  for (let i = 0, ii = str.length; i < ii; i++) {\n    const code = PDFStringTranslateTable[str.charCodeAt(i)];\n    strBuf.push(code ? String.fromCharCode(code) : str.charAt(i));\n  }\n  return strBuf.join(\"\");\n}\nfunction stringToUTF8String(str) {\n  return decodeURIComponent(escape(str));\n}\nfunction utf8StringToString(str) {\n  return unescape(encodeURIComponent(str));\n}\nfunction isArrayBuffer(v) {\n  return typeof v === \"object\" && v?.byteLength !== undefined;\n}\nfunction isArrayEqual(arr1, arr2) {\n  if (arr1.length !== arr2.length) {\n    return false;\n  }\n  for (let i = 0, ii = arr1.length; i < ii; i++) {\n    if (arr1[i] !== arr2[i]) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction getModificationDate(date = new Date()) {\n  const buffer = [date.getUTCFullYear().toString(), (date.getUTCMonth() + 1).toString().padStart(2, \"0\"), date.getUTCDate().toString().padStart(2, \"0\"), date.getUTCHours().toString().padStart(2, \"0\"), date.getUTCMinutes().toString().padStart(2, \"0\"), date.getUTCSeconds().toString().padStart(2, \"0\")];\n  return buffer.join(\"\");\n}\nclass PromiseCapability {\n  #settled = false;\n  constructor() {\n    this.promise = new Promise((resolve, reject) => {\n      this.resolve = data => {\n        this.#settled = true;\n        resolve(data);\n      };\n      this.reject = reason => {\n        this.#settled = true;\n        reject(reason);\n      };\n    });\n  }\n  get settled() {\n    return this.#settled;\n  }\n}\nexports.PromiseCapability = PromiseCapability;\nlet NormalizeRegex = null;\nlet NormalizationMap = null;\nfunction normalizeUnicode(str) {\n  if (!NormalizeRegex) {\n    NormalizeRegex = /([\\u00a0\\u00b5\\u037e\\u0eb3\\u2000-\\u200a\\u202f\\u2126\\ufb00-\\ufb04\\ufb06\\ufb20-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40-\\ufb41\\ufb43-\\ufb44\\ufb46-\\ufba1\\ufba4-\\ufba9\\ufbae-\\ufbb1\\ufbd3-\\ufbdc\\ufbde-\\ufbe7\\ufbea-\\ufbf8\\ufbfc-\\ufbfd\\ufc00-\\ufc5d\\ufc64-\\ufcf1\\ufcf5-\\ufd3d\\ufd88\\ufdf4\\ufdfa-\\ufdfb\\ufe71\\ufe77\\ufe79\\ufe7b\\ufe7d]+)|(\\ufb05+)/gu;\n    NormalizationMap = new Map([[\"\", \"t\"]]);\n  }\n  return str.replaceAll(NormalizeRegex, (_, p1, p2) => {\n    return p1 ? p1.normalize(\"NFKC\") : NormalizationMap.get(p2);\n  });\n}\nfunction getUuid() {\n  if (typeof crypto !== \"undefined\" && typeof crypto?.randomUUID === \"function\") {\n    return crypto.randomUUID();\n  }\n  const buf = new Uint8Array(32);\n  if (typeof crypto !== \"undefined\" && typeof crypto?.getRandomValues === \"function\") {\n    crypto.getRandomValues(buf);\n  } else {\n    for (let i = 0; i < 32; i++) {\n      buf[i] = Math.floor(Math.random() * 255);\n    }\n  }\n  return bytesToString(buf);\n}\nconst AnnotationPrefix = \"pdfjs_internal_id_\";\nexports.AnnotationPrefix = AnnotationPrefix;\n\n/***/ }),\n/* 2 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.RenderTask = exports.PDFWorkerUtil = exports.PDFWorker = exports.PDFPageProxy = exports.PDFDocumentProxy = exports.PDFDocumentLoadingTask = exports.PDFDataRangeTransport = exports.LoopbackPort = exports.DefaultStandardFontDataFactory = exports.DefaultFilterFactory = exports.DefaultCanvasFactory = exports.DefaultCMapReaderFactory = void 0;\nObject.defineProperty(exports, \"SVGGraphics\", ({\n  enumerable: true,\n  get: function () {\n    return _displaySvg.SVGGraphics;\n  }\n}));\nexports.build = void 0;\nexports.getDocument = getDocument;\nexports.version = void 0;\nvar _util = __w_pdfjs_require__(1);\nvar _annotation_storage = __w_pdfjs_require__(3);\nvar _display_utils = __w_pdfjs_require__(6);\nvar _font_loader = __w_pdfjs_require__(9);\nvar _displayNode_utils = __w_pdfjs_require__(10);\nvar _canvas = __w_pdfjs_require__(11);\nvar _worker_options = __w_pdfjs_require__(14);\nvar _message_handler = __w_pdfjs_require__(15);\nvar _metadata = __w_pdfjs_require__(16);\nvar _optional_content_config = __w_pdfjs_require__(17);\nvar _transport_stream = __w_pdfjs_require__(18);\nvar _displayFetch_stream = __w_pdfjs_require__(19);\nvar _displayNetwork = __w_pdfjs_require__(22);\nvar _displayNode_stream = __w_pdfjs_require__(23);\nvar _displaySvg = __w_pdfjs_require__(24);\nvar _xfa_text = __w_pdfjs_require__(25);\nconst DEFAULT_RANGE_CHUNK_SIZE = 65536;\nconst RENDERING_CANCELLED_TIMEOUT = 100;\nconst DELAYED_CLEANUP_TIMEOUT = 5000;\nconst DefaultCanvasFactory = _util.isNodeJS ? _displayNode_utils.NodeCanvasFactory : _display_utils.DOMCanvasFactory;\nexports.DefaultCanvasFactory = DefaultCanvasFactory;\nconst DefaultCMapReaderFactory = _util.isNodeJS ? _displayNode_utils.NodeCMapReaderFactory : _display_utils.DOMCMapReaderFactory;\nexports.DefaultCMapReaderFactory = DefaultCMapReaderFactory;\nconst DefaultFilterFactory = _util.isNodeJS ? _displayNode_utils.NodeFilterFactory : _display_utils.DOMFilterFactory;\nexports.DefaultFilterFactory = DefaultFilterFactory;\nconst DefaultStandardFontDataFactory = _util.isNodeJS ? _displayNode_utils.NodeStandardFontDataFactory : _display_utils.DOMStandardFontDataFactory;\nexports.DefaultStandardFontDataFactory = DefaultStandardFontDataFactory;\nfunction getDocument(src) {\n  if (typeof src === \"string\" || src instanceof URL) {\n    src = {\n      url: src\n    };\n  } else if ((0, _util.isArrayBuffer)(src)) {\n    src = {\n      data: src\n    };\n  }\n  if (typeof src !== \"object\") {\n    throw new Error(\"Invalid parameter in getDocument, need parameter object.\");\n  }\n  if (!src.url && !src.data && !src.range) {\n    throw new Error(\"Invalid parameter object: need either .data, .range or .url\");\n  }\n  const task = new PDFDocumentLoadingTask();\n  const {\n    docId\n  } = task;\n  const url = src.url ? getUrlProp(src.url) : null;\n  const data = src.data ? getDataProp(src.data) : null;\n  const httpHeaders = src.httpHeaders || null;\n  const withCredentials = src.withCredentials === true;\n  const password = src.password ?? null;\n  const rangeTransport = src.range instanceof PDFDataRangeTransport ? src.range : null;\n  const rangeChunkSize = Number.isInteger(src.rangeChunkSize) && src.rangeChunkSize > 0 ? src.rangeChunkSize : DEFAULT_RANGE_CHUNK_SIZE;\n  let worker = src.worker instanceof PDFWorker ? src.worker : null;\n  const verbosity = src.verbosity;\n  const docBaseUrl = typeof src.docBaseUrl === \"string\" && !(0, _display_utils.isDataScheme)(src.docBaseUrl) ? src.docBaseUrl : null;\n  const cMapUrl = typeof src.cMapUrl === \"string\" ? src.cMapUrl : null;\n  const cMapPacked = src.cMapPacked !== false;\n  const CMapReaderFactory = src.CMapReaderFactory || DefaultCMapReaderFactory;\n  const standardFontDataUrl = typeof src.standardFontDataUrl === \"string\" ? src.standardFontDataUrl : null;\n  const StandardFontDataFactory = src.StandardFontDataFactory || DefaultStandardFontDataFactory;\n  const ignoreErrors = src.stopAtErrors !== true;\n  const maxImageSize = Number.isInteger(src.maxImageSize) && src.maxImageSize > -1 ? src.maxImageSize : -1;\n  const isEvalSupported = src.isEvalSupported !== false;\n  const isOffscreenCanvasSupported = typeof src.isOffscreenCanvasSupported === \"boolean\" ? src.isOffscreenCanvasSupported : !_util.isNodeJS;\n  const canvasMaxAreaInBytes = Number.isInteger(src.canvasMaxAreaInBytes) ? src.canvasMaxAreaInBytes : -1;\n  const disableFontFace = typeof src.disableFontFace === \"boolean\" ? src.disableFontFace : _util.isNodeJS;\n  const fontExtraProperties = src.fontExtraProperties === true;\n  const enableXfa = src.enableXfa === true;\n  const ownerDocument = src.ownerDocument || globalThis.document;\n  const disableRange = src.disableRange === true;\n  const disableStream = src.disableStream === true;\n  const disableAutoFetch = src.disableAutoFetch === true;\n  const pdfBug = src.pdfBug === true;\n  const length = rangeTransport ? rangeTransport.length : src.length ?? NaN;\n  const useSystemFonts = typeof src.useSystemFonts === \"boolean\" ? src.useSystemFonts : !_util.isNodeJS && !disableFontFace;\n  const useWorkerFetch = typeof src.useWorkerFetch === \"boolean\" ? src.useWorkerFetch : CMapReaderFactory === _display_utils.DOMCMapReaderFactory && StandardFontDataFactory === _display_utils.DOMStandardFontDataFactory && cMapUrl && standardFontDataUrl && (0, _display_utils.isValidFetchUrl)(cMapUrl, document.baseURI) && (0, _display_utils.isValidFetchUrl)(standardFontDataUrl, document.baseURI);\n  const canvasFactory = src.canvasFactory || new DefaultCanvasFactory({\n    ownerDocument\n  });\n  const filterFactory = src.filterFactory || new DefaultFilterFactory({\n    docId,\n    ownerDocument\n  });\n  const styleElement = null;\n  (0, _util.setVerbosityLevel)(verbosity);\n  const transportFactory = {\n    canvasFactory,\n    filterFactory\n  };\n  if (!useWorkerFetch) {\n    transportFactory.cMapReaderFactory = new CMapReaderFactory({\n      baseUrl: cMapUrl,\n      isCompressed: cMapPacked\n    });\n    transportFactory.standardFontDataFactory = new StandardFontDataFactory({\n      baseUrl: standardFontDataUrl\n    });\n  }\n  if (!worker) {\n    const workerParams = {\n      verbosity,\n      port: _worker_options.GlobalWorkerOptions.workerPort\n    };\n    worker = workerParams.port ? PDFWorker.fromPort(workerParams) : new PDFWorker(workerParams);\n    task._worker = worker;\n  }\n  const fetchDocParams = {\n    docId,\n    apiVersion: '3.11.174',\n    data,\n    password,\n    disableAutoFetch,\n    rangeChunkSize,\n    length,\n    docBaseUrl,\n    enableXfa,\n    evaluatorOptions: {\n      maxImageSize,\n      disableFontFace,\n      ignoreErrors,\n      isEvalSupported,\n      isOffscreenCanvasSupported,\n      canvasMaxAreaInBytes,\n      fontExtraProperties,\n      useSystemFonts,\n      cMapUrl: useWorkerFetch ? cMapUrl : null,\n      standardFontDataUrl: useWorkerFetch ? standardFontDataUrl : null\n    }\n  };\n  const transportParams = {\n    ignoreErrors,\n    isEvalSupported,\n    disableFontFace,\n    fontExtraProperties,\n    enableXfa,\n    ownerDocument,\n    disableAutoFetch,\n    pdfBug,\n    styleElement\n  };\n  worker.promise.then(function () {\n    if (task.destroyed) {\n      throw new Error(\"Loading aborted\");\n    }\n    const workerIdPromise = _fetchDocument(worker, fetchDocParams);\n    const networkStreamPromise = new Promise(function (resolve) {\n      let networkStream;\n      if (rangeTransport) {\n        networkStream = new _transport_stream.PDFDataTransportStream({\n          length,\n          initialData: rangeTransport.initialData,\n          progressiveDone: rangeTransport.progressiveDone,\n          contentDispositionFilename: rangeTransport.contentDispositionFilename,\n          disableRange,\n          disableStream\n        }, rangeTransport);\n      } else if (!data) {\n        const createPDFNetworkStream = params => {\n          if (_util.isNodeJS) {\n            return new _displayNode_stream.PDFNodeStream(params);\n          }\n          return (0, _display_utils.isValidFetchUrl)(params.url) ? new _displayFetch_stream.PDFFetchStream(params) : new _displayNetwork.PDFNetworkStream(params);\n        };\n        networkStream = createPDFNetworkStream({\n          url,\n          length,\n          httpHeaders,\n          withCredentials,\n          rangeChunkSize,\n          disableRange,\n          disableStream\n        });\n      }\n      resolve(networkStream);\n    });\n    return Promise.all([workerIdPromise, networkStreamPromise]).then(function ([workerId, networkStream]) {\n      if (task.destroyed) {\n        throw new Error(\"Loading aborted\");\n      }\n      const messageHandler = new _message_handler.MessageHandler(docId, workerId, worker.port);\n      const transport = new WorkerTransport(messageHandler, task, networkStream, transportParams, transportFactory);\n      task._transport = transport;\n      messageHandler.send(\"Ready\", null);\n    });\n  }).catch(task._capability.reject);\n  return task;\n}\nasync function _fetchDocument(worker, source) {\n  if (worker.destroyed) {\n    throw new Error(\"Worker was destroyed\");\n  }\n  const workerId = await worker.messageHandler.sendWithPromise(\"GetDocRequest\", source, source.data ? [source.data.buffer] : null);\n  if (worker.destroyed) {\n    throw new Error(\"Worker was destroyed\");\n  }\n  return workerId;\n}\nfunction getUrlProp(val) {\n  if (val instanceof URL) {\n    return val.href;\n  }\n  try {\n    return new URL(val, window.location).href;\n  } catch {\n    if (_util.isNodeJS && typeof val === \"string\") {\n      return val;\n    }\n  }\n  throw new Error(\"Invalid PDF url data: \" + \"either string or URL-object is expected in the url property.\");\n}\nfunction getDataProp(val) {\n  if (_util.isNodeJS && typeof Buffer !== \"undefined\" && val instanceof Buffer) {\n    throw new Error(\"Please provide binary data as `Uint8Array`, rather than `Buffer`.\");\n  }\n  if (val instanceof Uint8Array && val.byteLength === val.buffer.byteLength) {\n    return val;\n  }\n  if (typeof val === \"string\") {\n    return (0, _util.stringToBytes)(val);\n  }\n  if (typeof val === \"object\" && !isNaN(val?.length) || (0, _util.isArrayBuffer)(val)) {\n    return new Uint8Array(val);\n  }\n  throw new Error(\"Invalid PDF binary data: either TypedArray, \" + \"string, or array-like object is expected in the data property.\");\n}\nclass PDFDocumentLoadingTask {\n  static #docId = 0;\n  constructor() {\n    this._capability = new _util.PromiseCapability();\n    this._transport = null;\n    this._worker = null;\n    this.docId = `d${PDFDocumentLoadingTask.#docId++}`;\n    this.destroyed = false;\n    this.onPassword = null;\n    this.onProgress = null;\n  }\n  get promise() {\n    return this._capability.promise;\n  }\n  async destroy() {\n    this.destroyed = true;\n    try {\n      if (this._worker?.port) {\n        this._worker._pendingDestroy = true;\n      }\n      await this._transport?.destroy();\n    } catch (ex) {\n      if (this._worker?.port) {\n        delete this._worker._pendingDestroy;\n      }\n      throw ex;\n    }\n    this._transport = null;\n    if (this._worker) {\n      this._worker.destroy();\n      this._worker = null;\n    }\n  }\n}\nexports.PDFDocumentLoadingTask = PDFDocumentLoadingTask;\nclass PDFDataRangeTransport {\n  constructor(length, initialData, progressiveDone = false, contentDispositionFilename = null) {\n    this.length = length;\n    this.initialData = initialData;\n    this.progressiveDone = progressiveDone;\n    this.contentDispositionFilename = contentDispositionFilename;\n    this._rangeListeners = [];\n    this._progressListeners = [];\n    this._progressiveReadListeners = [];\n    this._progressiveDoneListeners = [];\n    this._readyCapability = new _util.PromiseCapability();\n  }\n  addRangeListener(listener) {\n    this._rangeListeners.push(listener);\n  }\n  addProgressListener(listener) {\n    this._progressListeners.push(listener);\n  }\n  addProgressiveReadListener(listener) {\n    this._progressiveReadListeners.push(listener);\n  }\n  addProgressiveDoneListener(listener) {\n    this._progressiveDoneListeners.push(listener);\n  }\n  onDataRange(begin, chunk) {\n    for (const listener of this._rangeListeners) {\n      listener(begin, chunk);\n    }\n  }\n  onDataProgress(loaded, total) {\n    this._readyCapability.promise.then(() => {\n      for (const listener of this._progressListeners) {\n        listener(loaded, total);\n      }\n    });\n  }\n  onDataProgressiveRead(chunk) {\n    this._readyCapability.promise.then(() => {\n      for (const listener of this._progressiveReadListeners) {\n        listener(chunk);\n      }\n    });\n  }\n  onDataProgressiveDone() {\n    this._readyCapability.promise.then(() => {\n      for (const listener of this._progressiveDoneListeners) {\n        listener();\n      }\n    });\n  }\n  transportReady() {\n    this._readyCapability.resolve();\n  }\n  requestDataRange(begin, end) {\n    (0, _util.unreachable)(\"Abstract method PDFDataRangeTransport.requestDataRange\");\n  }\n  abort() {}\n}\nexports.PDFDataRangeTransport = PDFDataRangeTransport;\nclass PDFDocumentProxy {\n  constructor(pdfInfo, transport) {\n    this._pdfInfo = pdfInfo;\n    this._transport = transport;\n    Object.defineProperty(this, \"getJavaScript\", {\n      value: () => {\n        (0, _display_utils.deprecated)(\"`PDFDocumentProxy.getJavaScript`, \" + \"please use `PDFDocumentProxy.getJSActions` instead.\");\n        return this.getJSActions().then(js => {\n          if (!js) {\n            return js;\n          }\n          const jsArr = [];\n          for (const name in js) {\n            jsArr.push(...js[name]);\n          }\n          return jsArr;\n        });\n      }\n    });\n  }\n  get annotationStorage() {\n    return this._transport.annotationStorage;\n  }\n  get filterFactory() {\n    return this._transport.filterFactory;\n  }\n  get numPages() {\n    return this._pdfInfo.numPages;\n  }\n  get fingerprints() {\n    return this._pdfInfo.fingerprints;\n  }\n  get isPureXfa() {\n    return (0, _util.shadow)(this, \"isPureXfa\", !!this._transport._htmlForXfa);\n  }\n  get allXfaHtml() {\n    return this._transport._htmlForXfa;\n  }\n  getPage(pageNumber) {\n    return this._transport.getPage(pageNumber);\n  }\n  getPageIndex(ref) {\n    return this._transport.getPageIndex(ref);\n  }\n  getDestinations() {\n    return this._transport.getDestinations();\n  }\n  getDestination(id) {\n    return this._transport.getDestination(id);\n  }\n  getPageLabels() {\n    return this._transport.getPageLabels();\n  }\n  getPageLayout() {\n    return this._transport.getPageLayout();\n  }\n  getPageMode() {\n    return this._transport.getPageMode();\n  }\n  getViewerPreferences() {\n    return this._transport.getViewerPreferences();\n  }\n  getOpenAction() {\n    return this._transport.getOpenAction();\n  }\n  getAttachments() {\n    return this._transport.getAttachments();\n  }\n  getJSActions() {\n    return this._transport.getDocJSActions();\n  }\n  getOutline() {\n    return this._transport.getOutline();\n  }\n  getOptionalContentConfig() {\n    return this._transport.getOptionalContentConfig();\n  }\n  getPermissions() {\n    return this._transport.getPermissions();\n  }\n  getMetadata() {\n    return this._transport.getMetadata();\n  }\n  getMarkInfo() {\n    return this._transport.getMarkInfo();\n  }\n  getData() {\n    return this._transport.getData();\n  }\n  saveDocument() {\n    return this._transport.saveDocument();\n  }\n  getDownloadInfo() {\n    return this._transport.downloadInfoCapability.promise;\n  }\n  cleanup(keepLoadedFonts = false) {\n    return this._transport.startCleanup(keepLoadedFonts || this.isPureXfa);\n  }\n  destroy() {\n    return this.loadingTask.destroy();\n  }\n  get loadingParams() {\n    return this._transport.loadingParams;\n  }\n  get loadingTask() {\n    return this._transport.loadingTask;\n  }\n  getFieldObjects() {\n    return this._transport.getFieldObjects();\n  }\n  hasJSActions() {\n    return this._transport.hasJSActions();\n  }\n  getCalculationOrderIds() {\n    return this._transport.getCalculationOrderIds();\n  }\n}\nexports.PDFDocumentProxy = PDFDocumentProxy;\nclass PDFPageProxy {\n  #delayedCleanupTimeout = null;\n  #pendingCleanup = false;\n  constructor(pageIndex, pageInfo, transport, pdfBug = false) {\n    this._pageIndex = pageIndex;\n    this._pageInfo = pageInfo;\n    this._transport = transport;\n    this._stats = pdfBug ? new _display_utils.StatTimer() : null;\n    this._pdfBug = pdfBug;\n    this.commonObjs = transport.commonObjs;\n    this.objs = new PDFObjects();\n    this._maybeCleanupAfterRender = false;\n    this._intentStates = new Map();\n    this.destroyed = false;\n  }\n  get pageNumber() {\n    return this._pageIndex + 1;\n  }\n  get rotate() {\n    return this._pageInfo.rotate;\n  }\n  get ref() {\n    return this._pageInfo.ref;\n  }\n  get userUnit() {\n    return this._pageInfo.userUnit;\n  }\n  get view() {\n    return this._pageInfo.view;\n  }\n  getViewport({\n    scale,\n    rotation = this.rotate,\n    offsetX = 0,\n    offsetY = 0,\n    dontFlip = false\n  } = {}) {\n    return new _display_utils.PageViewport({\n      viewBox: this.view,\n      scale,\n      rotation,\n      offsetX,\n      offsetY,\n      dontFlip\n    });\n  }\n  getAnnotations({\n    intent = \"display\"\n  } = {}) {\n    const intentArgs = this._transport.getRenderingIntent(intent);\n    return this._transport.getAnnotations(this._pageIndex, intentArgs.renderingIntent);\n  }\n  getJSActions() {\n    return this._transport.getPageJSActions(this._pageIndex);\n  }\n  get filterFactory() {\n    return this._transport.filterFactory;\n  }\n  get isPureXfa() {\n    return (0, _util.shadow)(this, \"isPureXfa\", !!this._transport._htmlForXfa);\n  }\n  async getXfa() {\n    return this._transport._htmlForXfa?.children[this._pageIndex] || null;\n  }\n  render({\n    canvasContext,\n    viewport,\n    intent = \"display\",\n    annotationMode = _util.AnnotationMode.ENABLE,\n    transform = null,\n    background = null,\n    optionalContentConfigPromise = null,\n    annotationCanvasMap = null,\n    pageColors = null,\n    printAnnotationStorage = null\n  }) {\n    this._stats?.time(\"Overall\");\n    const intentArgs = this._transport.getRenderingIntent(intent, annotationMode, printAnnotationStorage);\n    this.#pendingCleanup = false;\n    this.#abortDelayedCleanup();\n    if (!optionalContentConfigPromise) {\n      optionalContentConfigPromise = this._transport.getOptionalContentConfig();\n    }\n    let intentState = this._intentStates.get(intentArgs.cacheKey);\n    if (!intentState) {\n      intentState = Object.create(null);\n      this._intentStates.set(intentArgs.cacheKey, intentState);\n    }\n    if (intentState.streamReaderCancelTimeout) {\n      clearTimeout(intentState.streamReaderCancelTimeout);\n      intentState.streamReaderCancelTimeout = null;\n    }\n    const intentPrint = !!(intentArgs.renderingIntent & _util.RenderingIntentFlag.PRINT);\n    if (!intentState.displayReadyCapability) {\n      intentState.displayReadyCapability = new _util.PromiseCapability();\n      intentState.operatorList = {\n        fnArray: [],\n        argsArray: [],\n        lastChunk: false,\n        separateAnnots: null\n      };\n      this._stats?.time(\"Page Request\");\n      this._pumpOperatorList(intentArgs);\n    }\n    const complete = error => {\n      intentState.renderTasks.delete(internalRenderTask);\n      if (this._maybeCleanupAfterRender || intentPrint) {\n        this.#pendingCleanup = true;\n      }\n      this.#tryCleanup(!intentPrint);\n      if (error) {\n        internalRenderTask.capability.reject(error);\n        this._abortOperatorList({\n          intentState,\n          reason: error instanceof Error ? error : new Error(error)\n        });\n      } else {\n        internalRenderTask.capability.resolve();\n      }\n      this._stats?.timeEnd(\"Rendering\");\n      this._stats?.timeEnd(\"Overall\");\n    };\n    const internalRenderTask = new InternalRenderTask({\n      callback: complete,\n      params: {\n        canvasContext,\n        viewport,\n        transform,\n        background\n      },\n      objs: this.objs,\n      commonObjs: this.commonObjs,\n      annotationCanvasMap,\n      operatorList: intentState.operatorList,\n      pageIndex: this._pageIndex,\n      canvasFactory: this._transport.canvasFactory,\n      filterFactory: this._transport.filterFactory,\n      useRequestAnimationFrame: !intentPrint,\n      pdfBug: this._pdfBug,\n      pageColors\n    });\n    (intentState.renderTasks ||= new Set()).add(internalRenderTask);\n    const renderTask = internalRenderTask.task;\n    Promise.all([intentState.displayReadyCapability.promise, optionalContentConfigPromise]).then(([transparency, optionalContentConfig]) => {\n      if (this.destroyed) {\n        complete();\n        return;\n      }\n      this._stats?.time(\"Rendering\");\n      internalRenderTask.initializeGraphics({\n        transparency,\n        optionalContentConfig\n      });\n      internalRenderTask.operatorListChanged();\n    }).catch(complete);\n    return renderTask;\n  }\n  getOperatorList({\n    intent = \"display\",\n    annotationMode = _util.AnnotationMode.ENABLE,\n    printAnnotationStorage = null\n  } = {}) {\n    function operatorListChanged() {\n      if (intentState.operatorList.lastChunk) {\n        intentState.opListReadCapability.resolve(intentState.operatorList);\n        intentState.renderTasks.delete(opListTask);\n      }\n    }\n    const intentArgs = this._transport.getRenderingIntent(intent, annotationMode, printAnnotationStorage, true);\n    let intentState = this._intentStates.get(intentArgs.cacheKey);\n    if (!intentState) {\n      intentState = Object.create(null);\n      this._intentStates.set(intentArgs.cacheKey, intentState);\n    }\n    let opListTask;\n    if (!intentState.opListReadCapability) {\n      opListTask = Object.create(null);\n      opListTask.operatorListChanged = operatorListChanged;\n      intentState.opListReadCapability = new _util.PromiseCapability();\n      (intentState.renderTasks ||= new Set()).add(opListTask);\n      intentState.operatorList = {\n        fnArray: [],\n        argsArray: [],\n        lastChunk: false,\n        separateAnnots: null\n      };\n      this._stats?.time(\"Page Request\");\n      this._pumpOperatorList(intentArgs);\n    }\n    return intentState.opListReadCapability.promise;\n  }\n  streamTextContent({\n    includeMarkedContent = false,\n    disableNormalization = false\n  } = {}) {\n    const TEXT_CONTENT_CHUNK_SIZE = 100;\n    return this._transport.messageHandler.sendWithStream(\"GetTextContent\", {\n      pageIndex: this._pageIndex,\n      includeMarkedContent: includeMarkedContent === true,\n      disableNormalization: disableNormalization === true\n    }, {\n      highWaterMark: TEXT_CONTENT_CHUNK_SIZE,\n      size(textContent) {\n        return textContent.items.length;\n      }\n    });\n  }\n  getTextContent(params = {}) {\n    if (this._transport._htmlForXfa) {\n      return this.getXfa().then(xfa => {\n        return _xfa_text.XfaText.textContent(xfa);\n      });\n    }\n    const readableStream = this.streamTextContent(params);\n    return new Promise(function (resolve, reject) {\n      function pump() {\n        reader.read().then(function ({\n          value,\n          done\n        }) {\n          if (done) {\n            resolve(textContent);\n            return;\n          }\n          Object.assign(textContent.styles, value.styles);\n          textContent.items.push(...value.items);\n          pump();\n        }, reject);\n      }\n      const reader = readableStream.getReader();\n      const textContent = {\n        items: [],\n        styles: Object.create(null)\n      };\n      pump();\n    });\n  }\n  getStructTree() {\n    return this._transport.getStructTree(this._pageIndex);\n  }\n  _destroy() {\n    this.destroyed = true;\n    const waitOn = [];\n    for (const intentState of this._intentStates.values()) {\n      this._abortOperatorList({\n        intentState,\n        reason: new Error(\"Page was destroyed.\"),\n        force: true\n      });\n      if (intentState.opListReadCapability) {\n        continue;\n      }\n      for (const internalRenderTask of intentState.renderTasks) {\n        waitOn.push(internalRenderTask.completed);\n        internalRenderTask.cancel();\n      }\n    }\n    this.objs.clear();\n    this.#pendingCleanup = false;\n    this.#abortDelayedCleanup();\n    return Promise.all(waitOn);\n  }\n  cleanup(resetStats = false) {\n    this.#pendingCleanup = true;\n    const success = this.#tryCleanup(false);\n    if (resetStats && success) {\n      this._stats &&= new _display_utils.StatTimer();\n    }\n    return success;\n  }\n  #tryCleanup(delayed = false) {\n    this.#abortDelayedCleanup();\n    if (!this.#pendingCleanup || this.destroyed) {\n      return false;\n    }\n    if (delayed) {\n      this.#delayedCleanupTimeout = setTimeout(() => {\n        this.#delayedCleanupTimeout = null;\n        this.#tryCleanup(false);\n      }, DELAYED_CLEANUP_TIMEOUT);\n      return false;\n    }\n    for (const {\n      renderTasks,\n      operatorList\n    } of this._intentStates.values()) {\n      if (renderTasks.size > 0 || !operatorList.lastChunk) {\n        return false;\n      }\n    }\n    this._intentStates.clear();\n    this.objs.clear();\n    this.#pendingCleanup = false;\n    return true;\n  }\n  #abortDelayedCleanup() {\n    if (this.#delayedCleanupTimeout) {\n      clearTimeout(this.#delayedCleanupTimeout);\n      this.#delayedCleanupTimeout = null;\n    }\n  }\n  _startRenderPage(transparency, cacheKey) {\n    const intentState = this._intentStates.get(cacheKey);\n    if (!intentState) {\n      return;\n    }\n    this._stats?.timeEnd(\"Page Request\");\n    intentState.displayReadyCapability?.resolve(transparency);\n  }\n  _renderPageChunk(operatorListChunk, intentState) {\n    for (let i = 0, ii = operatorListChunk.length; i < ii; i++) {\n      intentState.operatorList.fnArray.push(operatorListChunk.fnArray[i]);\n      intentState.operatorList.argsArray.push(operatorListChunk.argsArray[i]);\n    }\n    intentState.operatorList.lastChunk = operatorListChunk.lastChunk;\n    intentState.operatorList.separateAnnots = operatorListChunk.separateAnnots;\n    for (const internalRenderTask of intentState.renderTasks) {\n      internalRenderTask.operatorListChanged();\n    }\n    if (operatorListChunk.lastChunk) {\n      this.#tryCleanup(true);\n    }\n  }\n  _pumpOperatorList({\n    renderingIntent,\n    cacheKey,\n    annotationStorageSerializable\n  }) {\n    const {\n      map,\n      transfers\n    } = annotationStorageSerializable;\n    const readableStream = this._transport.messageHandler.sendWithStream(\"GetOperatorList\", {\n      pageIndex: this._pageIndex,\n      intent: renderingIntent,\n      cacheKey,\n      annotationStorage: map\n    }, transfers);\n    const reader = readableStream.getReader();\n    const intentState = this._intentStates.get(cacheKey);\n    intentState.streamReader = reader;\n    const pump = () => {\n      reader.read().then(({\n        value,\n        done\n      }) => {\n        if (done) {\n          intentState.streamReader = null;\n          return;\n        }\n        if (this._transport.destroyed) {\n          return;\n        }\n        this._renderPageChunk(value, intentState);\n        pump();\n      }, reason => {\n        intentState.streamReader = null;\n        if (this._transport.destroyed) {\n          return;\n        }\n        if (intentState.operatorList) {\n          intentState.operatorList.lastChunk = true;\n          for (const internalRenderTask of intentState.renderTasks) {\n            internalRenderTask.operatorListChanged();\n          }\n          this.#tryCleanup(true);\n        }\n        if (intentState.displayReadyCapability) {\n          intentState.displayReadyCapability.reject(reason);\n        } else if (intentState.opListReadCapability) {\n          intentState.opListReadCapability.reject(reason);\n        } else {\n          throw reason;\n        }\n      });\n    };\n    pump();\n  }\n  _abortOperatorList({\n    intentState,\n    reason,\n    force = false\n  }) {\n    if (!intentState.streamReader) {\n      return;\n    }\n    if (intentState.streamReaderCancelTimeout) {\n      clearTimeout(intentState.streamReaderCancelTimeout);\n      intentState.streamReaderCancelTimeout = null;\n    }\n    if (!force) {\n      if (intentState.renderTasks.size > 0) {\n        return;\n      }\n      if (reason instanceof _display_utils.RenderingCancelledException) {\n        let delay = RENDERING_CANCELLED_TIMEOUT;\n        if (reason.extraDelay > 0 && reason.extraDelay < 1000) {\n          delay += reason.extraDelay;\n        }\n        intentState.streamReaderCancelTimeout = setTimeout(() => {\n          intentState.streamReaderCancelTimeout = null;\n          this._abortOperatorList({\n            intentState,\n            reason,\n            force: true\n          });\n        }, delay);\n        return;\n      }\n    }\n    intentState.streamReader.cancel(new _util.AbortException(reason.message)).catch(() => {});\n    intentState.streamReader = null;\n    if (this._transport.destroyed) {\n      return;\n    }\n    for (const [curCacheKey, curIntentState] of this._intentStates) {\n      if (curIntentState === intentState) {\n        this._intentStates.delete(curCacheKey);\n        break;\n      }\n    }\n    this.cleanup();\n  }\n  get stats() {\n    return this._stats;\n  }\n}\nexports.PDFPageProxy = PDFPageProxy;\nclass LoopbackPort {\n  #listeners = new Set();\n  #deferred = Promise.resolve();\n  postMessage(obj, transfer) {\n    const event = {\n      data: structuredClone(obj, transfer ? {\n        transfer\n      } : null)\n    };\n    this.#deferred.then(() => {\n      for (const listener of this.#listeners) {\n        listener.call(this, event);\n      }\n    });\n  }\n  addEventListener(name, listener) {\n    this.#listeners.add(listener);\n  }\n  removeEventListener(name, listener) {\n    this.#listeners.delete(listener);\n  }\n  terminate() {\n    this.#listeners.clear();\n  }\n}\nexports.LoopbackPort = LoopbackPort;\nconst PDFWorkerUtil = {\n  isWorkerDisabled: false,\n  fallbackWorkerSrc: null,\n  fakeWorkerId: 0\n};\nexports.PDFWorkerUtil = PDFWorkerUtil;\n{\n  if (_util.isNodeJS && \"function\" === \"function\") {\n    PDFWorkerUtil.isWorkerDisabled = true;\n    PDFWorkerUtil.fallbackWorkerSrc = \"./pdf.worker.js\";\n  } else if (typeof document === \"object\") {\n    const pdfjsFilePath = document?.currentScript?.src;\n    if (pdfjsFilePath) {\n      PDFWorkerUtil.fallbackWorkerSrc = pdfjsFilePath.replace(/(\\.(?:min\\.)?js)(\\?.*)?$/i, \".worker$1$2\");\n    }\n  }\n  PDFWorkerUtil.isSameOrigin = function (baseUrl, otherUrl) {\n    let base;\n    try {\n      base = new URL(baseUrl);\n      if (!base.origin || base.origin === \"null\") {\n        return false;\n      }\n    } catch {\n      return false;\n    }\n    const other = new URL(otherUrl, base);\n    return base.origin === other.origin;\n  };\n  PDFWorkerUtil.createCDNWrapper = function (url) {\n    const wrapper = `importScripts(\"${url}\");`;\n    return URL.createObjectURL(new Blob([wrapper]));\n  };\n}\nclass PDFWorker {\n  static #workerPorts;\n  constructor({\n    name = null,\n    port = null,\n    verbosity = (0, _util.getVerbosityLevel)()\n  } = {}) {\n    this.name = name;\n    this.destroyed = false;\n    this.verbosity = verbosity;\n    this._readyCapability = new _util.PromiseCapability();\n    this._port = null;\n    this._webWorker = null;\n    this._messageHandler = null;\n    if (port) {\n      if (PDFWorker.#workerPorts?.has(port)) {\n        throw new Error(\"Cannot use more than one PDFWorker per port.\");\n      }\n      (PDFWorker.#workerPorts ||= new WeakMap()).set(port, this);\n      this._initializeFromPort(port);\n      return;\n    }\n    this._initialize();\n  }\n  get promise() {\n    return this._readyCapability.promise;\n  }\n  get port() {\n    return this._port;\n  }\n  get messageHandler() {\n    return this._messageHandler;\n  }\n  _initializeFromPort(port) {\n    this._port = port;\n    this._messageHandler = new _message_handler.MessageHandler(\"main\", \"worker\", port);\n    this._messageHandler.on(\"ready\", function () {});\n    this._readyCapability.resolve();\n    this._messageHandler.send(\"configure\", {\n      verbosity: this.verbosity\n    });\n  }\n  _initialize() {\n    if (!PDFWorkerUtil.isWorkerDisabled && !PDFWorker._mainThreadWorkerMessageHandler) {\n      let {\n        workerSrc\n      } = PDFWorker;\n      try {\n        if (!PDFWorkerUtil.isSameOrigin(window.location.href, workerSrc)) {\n          workerSrc = PDFWorkerUtil.createCDNWrapper(new URL(workerSrc, window.location).href);\n        }\n        const worker = new Worker(workerSrc);\n        const messageHandler = new _message_handler.MessageHandler(\"main\", \"worker\", worker);\n        const terminateEarly = () => {\n          worker.removeEventListener(\"error\", onWorkerError);\n          messageHandler.destroy();\n          worker.terminate();\n          if (this.destroyed) {\n            this._readyCapability.reject(new Error(\"Worker was destroyed\"));\n          } else {\n            this._setupFakeWorker();\n          }\n        };\n        const onWorkerError = () => {\n          if (!this._webWorker) {\n            terminateEarly();\n          }\n        };\n        worker.addEventListener(\"error\", onWorkerError);\n        messageHandler.on(\"test\", data => {\n          worker.removeEventListener(\"error\", onWorkerError);\n          if (this.destroyed) {\n            terminateEarly();\n            return;\n          }\n          if (data) {\n            this._messageHandler = messageHandler;\n            this._port = worker;\n            this._webWorker = worker;\n            this._readyCapability.resolve();\n            messageHandler.send(\"configure\", {\n              verbosity: this.verbosity\n            });\n          } else {\n            this._setupFakeWorker();\n            messageHandler.destroy();\n            worker.terminate();\n          }\n        });\n        messageHandler.on(\"ready\", data => {\n          worker.removeEventListener(\"error\", onWorkerError);\n          if (this.destroyed) {\n            terminateEarly();\n            return;\n          }\n          try {\n            sendTest();\n          } catch {\n            this._setupFakeWorker();\n          }\n        });\n        const sendTest = () => {\n          const testObj = new Uint8Array();\n          messageHandler.send(\"test\", testObj, [testObj.buffer]);\n        };\n        sendTest();\n        return;\n      } catch {\n        (0, _util.info)(\"The worker has been disabled.\");\n      }\n    }\n    this._setupFakeWorker();\n  }\n  _setupFakeWorker() {\n    if (!PDFWorkerUtil.isWorkerDisabled) {\n      (0, _util.warn)(\"Setting up fake worker.\");\n      PDFWorkerUtil.isWorkerDisabled = true;\n    }\n    PDFWorker._setupFakeWorkerGlobal.then(WorkerMessageHandler => {\n      if (this.destroyed) {\n        this._readyCapability.reject(new Error(\"Worker was destroyed\"));\n        return;\n      }\n      const port = new LoopbackPort();\n      this._port = port;\n      const id = `fake${PDFWorkerUtil.fakeWorkerId++}`;\n      const workerHandler = new _message_handler.MessageHandler(id + \"_worker\", id, port);\n      WorkerMessageHandler.setup(workerHandler, port);\n      const messageHandler = new _message_handler.MessageHandler(id, id + \"_worker\", port);\n      this._messageHandler = messageHandler;\n      this._readyCapability.resolve();\n      messageHandler.send(\"configure\", {\n        verbosity: this.verbosity\n      });\n    }).catch(reason => {\n      this._readyCapability.reject(new Error(`Setting up fake worker failed: \"${reason.message}\".`));\n    });\n  }\n  destroy() {\n    this.destroyed = true;\n    if (this._webWorker) {\n      this._webWorker.terminate();\n      this._webWorker = null;\n    }\n    PDFWorker.#workerPorts?.delete(this._port);\n    this._port = null;\n    if (this._messageHandler) {\n      this._messageHandler.destroy();\n      this._messageHandler = null;\n    }\n  }\n  static fromPort(params) {\n    if (!params?.port) {\n      throw new Error(\"PDFWorker.fromPort - invalid method signature.\");\n    }\n    const cachedPort = this.#workerPorts?.get(params.port);\n    if (cachedPort) {\n      if (cachedPort._pendingDestroy) {\n        throw new Error(\"PDFWorker.fromPort - the worker is being destroyed.\\n\" + \"Please remember to await `PDFDocumentLoadingTask.destroy()`-calls.\");\n      }\n      return cachedPort;\n    }\n    return new PDFWorker(params);\n  }\n  static get workerSrc() {\n    if (_worker_options.GlobalWorkerOptions.workerSrc) {\n      return _worker_options.GlobalWorkerOptions.workerSrc;\n    }\n    if (PDFWorkerUtil.fallbackWorkerSrc !== null) {\n      if (!_util.isNodeJS) {\n        (0, _display_utils.deprecated)('No \"GlobalWorkerOptions.workerSrc\" specified.');\n      }\n      return PDFWorkerUtil.fallbackWorkerSrc;\n    }\n    throw new Error('No \"GlobalWorkerOptions.workerSrc\" specified.');\n  }\n  static get _mainThreadWorkerMessageHandler() {\n    try {\n      return globalThis.pdfjsWorker?.WorkerMessageHandler || null;\n    } catch {\n      return null;\n    }\n  }\n  static get _setupFakeWorkerGlobal() {\n    const loader = async () => {\n      const mainWorkerMessageHandler = this._mainThreadWorkerMessageHandler;\n      if (mainWorkerMessageHandler) {\n        return mainWorkerMessageHandler;\n      }\n      if (_util.isNodeJS && \"function\" === \"function\") {\n        const worker = eval(\"require\")(this.workerSrc);\n        return worker.WorkerMessageHandler;\n      }\n      await (0, _display_utils.loadScript)(this.workerSrc);\n      return window.pdfjsWorker.WorkerMessageHandler;\n    };\n    return (0, _util.shadow)(this, \"_setupFakeWorkerGlobal\", loader());\n  }\n}\nexports.PDFWorker = PDFWorker;\nclass WorkerTransport {\n  #methodPromises = new Map();\n  #pageCache = new Map();\n  #pagePromises = new Map();\n  #passwordCapability = null;\n  constructor(messageHandler, loadingTask, networkStream, params, factory) {\n    this.messageHandler = messageHandler;\n    this.loadingTask = loadingTask;\n    this.commonObjs = new PDFObjects();\n    this.fontLoader = new _font_loader.FontLoader({\n      ownerDocument: params.ownerDocument,\n      styleElement: params.styleElement\n    });\n    this._params = params;\n    this.canvasFactory = factory.canvasFactory;\n    this.filterFactory = factory.filterFactory;\n    this.cMapReaderFactory = factory.cMapReaderFactory;\n    this.standardFontDataFactory = factory.standardFontDataFactory;\n    this.destroyed = false;\n    this.destroyCapability = null;\n    this._networkStream = networkStream;\n    this._fullReader = null;\n    this._lastProgress = null;\n    this.downloadInfoCapability = new _util.PromiseCapability();\n    this.setupMessageHandler();\n  }\n  #cacheSimpleMethod(name, data = null) {\n    const cachedPromise = this.#methodPromises.get(name);\n    if (cachedPromise) {\n      return cachedPromise;\n    }\n    const promise = this.messageHandler.sendWithPromise(name, data);\n    this.#methodPromises.set(name, promise);\n    return promise;\n  }\n  get annotationStorage() {\n    return (0, _util.shadow)(this, \"annotationStorage\", new _annotation_storage.AnnotationStorage());\n  }\n  getRenderingIntent(intent, annotationMode = _util.AnnotationMode.ENABLE, printAnnotationStorage = null, isOpList = false) {\n    let renderingIntent = _util.RenderingIntentFlag.DISPLAY;\n    let annotationStorageSerializable = _annotation_storage.SerializableEmpty;\n    switch (intent) {\n      case \"any\":\n        renderingIntent = _util.RenderingIntentFlag.ANY;\n        break;\n      case \"display\":\n        break;\n      case \"print\":\n        renderingIntent = _util.RenderingIntentFlag.PRINT;\n        break;\n      default:\n        (0, _util.warn)(`getRenderingIntent - invalid intent: ${intent}`);\n    }\n    switch (annotationMode) {\n      case _util.AnnotationMode.DISABLE:\n        renderingIntent += _util.RenderingIntentFlag.ANNOTATIONS_DISABLE;\n        break;\n      case _util.AnnotationMode.ENABLE:\n        break;\n      case _util.AnnotationMode.ENABLE_FORMS:\n        renderingIntent += _util.RenderingIntentFlag.ANNOTATIONS_FORMS;\n        break;\n      case _util.AnnotationMode.ENABLE_STORAGE:\n        renderingIntent += _util.RenderingIntentFlag.ANNOTATIONS_STORAGE;\n        const annotationStorage = renderingIntent & _util.RenderingIntentFlag.PRINT && printAnnotationStorage instanceof _annotation_storage.PrintAnnotationStorage ? printAnnotationStorage : this.annotationStorage;\n        annotationStorageSerializable = annotationStorage.serializable;\n        break;\n      default:\n        (0, _util.warn)(`getRenderingIntent - invalid annotationMode: ${annotationMode}`);\n    }\n    if (isOpList) {\n      renderingIntent += _util.RenderingIntentFlag.OPLIST;\n    }\n    return {\n      renderingIntent,\n      cacheKey: `${renderingIntent}_${annotationStorageSerializable.hash}`,\n      annotationStorageSerializable\n    };\n  }\n  destroy() {\n    if (this.destroyCapability) {\n      return this.destroyCapability.promise;\n    }\n    this.destroyed = true;\n    this.destroyCapability = new _util.PromiseCapability();\n    this.#passwordCapability?.reject(new Error(\"Worker was destroyed during onPassword callback\"));\n    const waitOn = [];\n    for (const page of this.#pageCache.values()) {\n      waitOn.push(page._destroy());\n    }\n    this.#pageCache.clear();\n    this.#pagePromises.clear();\n    if (this.hasOwnProperty(\"annotationStorage\")) {\n      this.annotationStorage.resetModified();\n    }\n    const terminated = this.messageHandler.sendWithPromise(\"Terminate\", null);\n    waitOn.push(terminated);\n    Promise.all(waitOn).then(() => {\n      this.commonObjs.clear();\n      this.fontLoader.clear();\n      this.#methodPromises.clear();\n      this.filterFactory.destroy();\n      this._networkStream?.cancelAllRequests(new _util.AbortException(\"Worker was terminated.\"));\n      if (this.messageHandler) {\n        this.messageHandler.destroy();\n        this.messageHandler = null;\n      }\n      this.destroyCapability.resolve();\n    }, this.destroyCapability.reject);\n    return this.destroyCapability.promise;\n  }\n  setupMessageHandler() {\n    const {\n      messageHandler,\n      loadingTask\n    } = this;\n    messageHandler.on(\"GetReader\", (data, sink) => {\n      (0, _util.assert)(this._networkStream, \"GetReader - no `IPDFStream` instance available.\");\n      this._fullReader = this._networkStream.getFullReader();\n      this._fullReader.onProgress = evt => {\n        this._lastProgress = {\n          loaded: evt.loaded,\n          total: evt.total\n        };\n      };\n      sink.onPull = () => {\n        this._fullReader.read().then(function ({\n          value,\n          done\n        }) {\n          if (done) {\n            sink.close();\n            return;\n          }\n          (0, _util.assert)(value instanceof ArrayBuffer, \"GetReader - expected an ArrayBuffer.\");\n          sink.enqueue(new Uint8Array(value), 1, [value]);\n        }).catch(reason => {\n          sink.error(reason);\n        });\n      };\n      sink.onCancel = reason => {\n        this._fullReader.cancel(reason);\n        sink.ready.catch(readyReason => {\n          if (this.destroyed) {\n            return;\n          }\n          throw readyReason;\n        });\n      };\n    });\n    messageHandler.on(\"ReaderHeadersReady\", data => {\n      const headersCapability = new _util.PromiseCapability();\n      const fullReader = this._fullReader;\n      fullReader.headersReady.then(() => {\n        if (!fullReader.isStreamingSupported || !fullReader.isRangeSupported) {\n          if (this._lastProgress) {\n            loadingTask.onProgress?.(this._lastProgress);\n          }\n          fullReader.onProgress = evt => {\n            loadingTask.onProgress?.({\n              loaded: evt.loaded,\n              total: evt.total\n            });\n          };\n        }\n        headersCapability.resolve({\n          isStreamingSupported: fullReader.isStreamingSupported,\n          isRangeSupported: fullReader.isRangeSupported,\n          contentLength: fullReader.contentLength\n        });\n      }, headersCapability.reject);\n      return headersCapability.promise;\n    });\n    messageHandler.on(\"GetRangeReader\", (data, sink) => {\n      (0, _util.assert)(this._networkStream, \"GetRangeReader - no `IPDFStream` instance available.\");\n      const rangeReader = this._networkStream.getRangeReader(data.begin, data.end);\n      if (!rangeReader) {\n        sink.close();\n        return;\n      }\n      sink.onPull = () => {\n        rangeReader.read().then(function ({\n          value,\n          done\n        }) {\n          if (done) {\n            sink.close();\n            return;\n          }\n          (0, _util.assert)(value instanceof ArrayBuffer, \"GetRangeReader - expected an ArrayBuffer.\");\n          sink.enqueue(new Uint8Array(value), 1, [value]);\n        }).catch(reason => {\n          sink.error(reason);\n        });\n      };\n      sink.onCancel = reason => {\n        rangeReader.cancel(reason);\n        sink.ready.catch(readyReason => {\n          if (this.destroyed) {\n            return;\n          }\n          throw readyReason;\n        });\n      };\n    });\n    messageHandler.on(\"GetDoc\", ({\n      pdfInfo\n    }) => {\n      this._numPages = pdfInfo.numPages;\n      this._htmlForXfa = pdfInfo.htmlForXfa;\n      delete pdfInfo.htmlForXfa;\n      loadingTask._capability.resolve(new PDFDocumentProxy(pdfInfo, this));\n    });\n    messageHandler.on(\"DocException\", function (ex) {\n      let reason;\n      switch (ex.name) {\n        case \"PasswordException\":\n          reason = new _util.PasswordException(ex.message, ex.code);\n          break;\n        case \"InvalidPDFException\":\n          reason = new _util.InvalidPDFException(ex.message);\n          break;\n        case \"MissingPDFException\":\n          reason = new _util.MissingPDFException(ex.message);\n          break;\n        case \"UnexpectedResponseException\":\n          reason = new _util.UnexpectedResponseException(ex.message, ex.status);\n          break;\n        case \"UnknownErrorException\":\n          reason = new _util.UnknownErrorException(ex.message, ex.details);\n          break;\n        default:\n          (0, _util.unreachable)(\"DocException - expected a valid Error.\");\n      }\n      loadingTask._capability.reject(reason);\n    });\n    messageHandler.on(\"PasswordRequest\", exception => {\n      this.#passwordCapability = new _util.PromiseCapability();\n      if (loadingTask.onPassword) {\n        const updatePassword = password => {\n          if (password instanceof Error) {\n            this.#passwordCapability.reject(password);\n          } else {\n            this.#passwordCapability.resolve({\n              password\n            });\n          }\n        };\n        try {\n          loadingTask.onPassword(updatePassword, exception.code);\n        } catch (ex) {\n          this.#passwordCapability.reject(ex);\n        }\n      } else {\n        this.#passwordCapability.reject(new _util.PasswordException(exception.message, exception.code));\n      }\n      return this.#passwordCapability.promise;\n    });\n    messageHandler.on(\"DataLoaded\", data => {\n      loadingTask.onProgress?.({\n        loaded: data.length,\n        total: data.length\n      });\n      this.downloadInfoCapability.resolve(data);\n    });\n    messageHandler.on(\"StartRenderPage\", data => {\n      if (this.destroyed) {\n        return;\n      }\n      const page = this.#pageCache.get(data.pageIndex);\n      page._startRenderPage(data.transparency, data.cacheKey);\n    });\n    messageHandler.on(\"commonobj\", ([id, type, exportedData]) => {\n      if (this.destroyed) {\n        return;\n      }\n      if (this.commonObjs.has(id)) {\n        return;\n      }\n      switch (type) {\n        case \"Font\":\n          const params = this._params;\n          if (\"error\" in exportedData) {\n            const exportedError = exportedData.error;\n            (0, _util.warn)(`Error during font loading: ${exportedError}`);\n            this.commonObjs.resolve(id, exportedError);\n            break;\n          }\n          const inspectFont = params.pdfBug && globalThis.FontInspector?.enabled ? (font, url) => globalThis.FontInspector.fontAdded(font, url) : null;\n          const font = new _font_loader.FontFaceObject(exportedData, {\n            isEvalSupported: params.isEvalSupported,\n            disableFontFace: params.disableFontFace,\n            ignoreErrors: params.ignoreErrors,\n            inspectFont\n          });\n          this.fontLoader.bind(font).catch(reason => {\n            return messageHandler.sendWithPromise(\"FontFallback\", {\n              id\n            });\n          }).finally(() => {\n            if (!params.fontExtraProperties && font.data) {\n              font.data = null;\n            }\n            this.commonObjs.resolve(id, font);\n          });\n          break;\n        case \"FontPath\":\n        case \"Image\":\n        case \"Pattern\":\n          this.commonObjs.resolve(id, exportedData);\n          break;\n        default:\n          throw new Error(`Got unknown common object type ${type}`);\n      }\n    });\n    messageHandler.on(\"obj\", ([id, pageIndex, type, imageData]) => {\n      if (this.destroyed) {\n        return;\n      }\n      const pageProxy = this.#pageCache.get(pageIndex);\n      if (pageProxy.objs.has(id)) {\n        return;\n      }\n      switch (type) {\n        case \"Image\":\n          pageProxy.objs.resolve(id, imageData);\n          if (imageData) {\n            let length;\n            if (imageData.bitmap) {\n              const {\n                width,\n                height\n              } = imageData;\n              length = width * height * 4;\n            } else {\n              length = imageData.data?.length || 0;\n            }\n            if (length > _util.MAX_IMAGE_SIZE_TO_CACHE) {\n              pageProxy._maybeCleanupAfterRender = true;\n            }\n          }\n          break;\n        case \"Pattern\":\n          pageProxy.objs.resolve(id, imageData);\n          break;\n        default:\n          throw new Error(`Got unknown object type ${type}`);\n      }\n    });\n    messageHandler.on(\"DocProgress\", data => {\n      if (this.destroyed) {\n        return;\n      }\n      loadingTask.onProgress?.({\n        loaded: data.loaded,\n        total: data.total\n      });\n    });\n    messageHandler.on(\"FetchBuiltInCMap\", data => {\n      if (this.destroyed) {\n        return Promise.reject(new Error(\"Worker was destroyed.\"));\n      }\n      if (!this.cMapReaderFactory) {\n        return Promise.reject(new Error(\"CMapReaderFactory not initialized, see the `useWorkerFetch` parameter.\"));\n      }\n      return this.cMapReaderFactory.fetch(data);\n    });\n    messageHandler.on(\"FetchStandardFontData\", data => {\n      if (this.destroyed) {\n        return Promise.reject(new Error(\"Worker was destroyed.\"));\n      }\n      if (!this.standardFontDataFactory) {\n        return Promise.reject(new Error(\"StandardFontDataFactory not initialized, see the `useWorkerFetch` parameter.\"));\n      }\n      return this.standardFontDataFactory.fetch(data);\n    });\n  }\n  getData() {\n    return this.messageHandler.sendWithPromise(\"GetData\", null);\n  }\n  saveDocument() {\n    if (this.annotationStorage.size <= 0) {\n      (0, _util.warn)(\"saveDocument called while `annotationStorage` is empty, \" + \"please use the getData-method instead.\");\n    }\n    const {\n      map,\n      transfers\n    } = this.annotationStorage.serializable;\n    return this.messageHandler.sendWithPromise(\"SaveDocument\", {\n      isPureXfa: !!this._htmlForXfa,\n      numPages: this._numPages,\n      annotationStorage: map,\n      filename: this._fullReader?.filename ?? null\n    }, transfers).finally(() => {\n      this.annotationStorage.resetModified();\n    });\n  }\n  getPage(pageNumber) {\n    if (!Number.isInteger(pageNumber) || pageNumber <= 0 || pageNumber > this._numPages) {\n      return Promise.reject(new Error(\"Invalid page request.\"));\n    }\n    const pageIndex = pageNumber - 1,\n      cachedPromise = this.#pagePromises.get(pageIndex);\n    if (cachedPromise) {\n      return cachedPromise;\n    }\n    const promise = this.messageHandler.sendWithPromise(\"GetPage\", {\n      pageIndex\n    }).then(pageInfo => {\n      if (this.destroyed) {\n        throw new Error(\"Transport destroyed\");\n      }\n      const page = new PDFPageProxy(pageIndex, pageInfo, this, this._params.pdfBug);\n      this.#pageCache.set(pageIndex, page);\n      return page;\n    });\n    this.#pagePromises.set(pageIndex, promise);\n    return promise;\n  }\n  getPageIndex(ref) {\n    if (typeof ref !== \"object\" || ref === null || !Number.isInteger(ref.num) || ref.num < 0 || !Number.isInteger(ref.gen) || ref.gen < 0) {\n      return Promise.reject(new Error(\"Invalid pageIndex request.\"));\n    }\n    return this.messageHandler.sendWithPromise(\"GetPageIndex\", {\n      num: ref.num,\n      gen: ref.gen\n    });\n  }\n  getAnnotations(pageIndex, intent) {\n    return this.messageHandler.sendWithPromise(\"GetAnnotations\", {\n      pageIndex,\n      intent\n    });\n  }\n  getFieldObjects() {\n    return this.#cacheSimpleMethod(\"GetFieldObjects\");\n  }\n  hasJSActions() {\n    return this.#cacheSimpleMethod(\"HasJSActions\");\n  }\n  getCalculationOrderIds() {\n    return this.messageHandler.sendWithPromise(\"GetCalculationOrderIds\", null);\n  }\n  getDestinations() {\n    return this.messageHandler.sendWithPromise(\"GetDestinations\", null);\n  }\n  getDestination(id) {\n    if (typeof id !== \"string\") {\n      return Promise.reject(new Error(\"Invalid destination request.\"));\n    }\n    return this.messageHandler.sendWithPromise(\"GetDestination\", {\n      id\n    });\n  }\n  getPageLabels() {\n    return this.messageHandler.sendWithPromise(\"GetPageLabels\", null);\n  }\n  getPageLayout() {\n    return this.messageHandler.sendWithPromise(\"GetPageLayout\", null);\n  }\n  getPageMode() {\n    return this.messageHandler.sendWithPromise(\"GetPageMode\", null);\n  }\n  getViewerPreferences() {\n    return this.messageHandler.sendWithPromise(\"GetViewerPreferences\", null);\n  }\n  getOpenAction() {\n    return this.messageHandler.sendWithPromise(\"GetOpenAction\", null);\n  }\n  getAttachments() {\n    return this.messageHandler.sendWithPromise(\"GetAttachments\", null);\n  }\n  getDocJSActions() {\n    return this.#cacheSimpleMethod(\"GetDocJSActions\");\n  }\n  getPageJSActions(pageIndex) {\n    return this.messageHandler.sendWithPromise(\"GetPageJSActions\", {\n      pageIndex\n    });\n  }\n  getStructTree(pageIndex) {\n    return this.messageHandler.sendWithPromise(\"GetStructTree\", {\n      pageIndex\n    });\n  }\n  getOutline() {\n    return this.messageHandler.sendWithPromise(\"GetOutline\", null);\n  }\n  getOptionalContentConfig() {\n    return this.messageHandler.sendWithPromise(\"GetOptionalContentConfig\", null).then(results => {\n      return new _optional_content_config.OptionalContentConfig(results);\n    });\n  }\n  getPermissions() {\n    return this.messageHandler.sendWithPromise(\"GetPermissions\", null);\n  }\n  getMetadata() {\n    const name = \"GetMetadata\",\n      cachedPromise = this.#methodPromises.get(name);\n    if (cachedPromise) {\n      return cachedPromise;\n    }\n    const promise = this.messageHandler.sendWithPromise(name, null).then(results => {\n      return {\n        info: results[0],\n        metadata: results[1] ? new _metadata.Metadata(results[1]) : null,\n        contentDispositionFilename: this._fullReader?.filename ?? null,\n        contentLength: this._fullReader?.contentLength ?? null\n      };\n    });\n    this.#methodPromises.set(name, promise);\n    return promise;\n  }\n  getMarkInfo() {\n    return this.messageHandler.sendWithPromise(\"GetMarkInfo\", null);\n  }\n  async startCleanup(keepLoadedFonts = false) {\n    if (this.destroyed) {\n      return;\n    }\n    await this.messageHandler.sendWithPromise(\"Cleanup\", null);\n    for (const page of this.#pageCache.values()) {\n      const cleanupSuccessful = page.cleanup();\n      if (!cleanupSuccessful) {\n        throw new Error(`startCleanup: Page ${page.pageNumber} is currently rendering.`);\n      }\n    }\n    this.commonObjs.clear();\n    if (!keepLoadedFonts) {\n      this.fontLoader.clear();\n    }\n    this.#methodPromises.clear();\n    this.filterFactory.destroy(true);\n  }\n  get loadingParams() {\n    const {\n      disableAutoFetch,\n      enableXfa\n    } = this._params;\n    return (0, _util.shadow)(this, \"loadingParams\", {\n      disableAutoFetch,\n      enableXfa\n    });\n  }\n}\nclass PDFObjects {\n  #objs = Object.create(null);\n  #ensureObj(objId) {\n    return this.#objs[objId] ||= {\n      capability: new _util.PromiseCapability(),\n      data: null\n    };\n  }\n  get(objId, callback = null) {\n    if (callback) {\n      const obj = this.#ensureObj(objId);\n      obj.capability.promise.then(() => callback(obj.data));\n      return null;\n    }\n    const obj = this.#objs[objId];\n    if (!obj?.capability.settled) {\n      throw new Error(`Requesting object that isn't resolved yet ${objId}.`);\n    }\n    return obj.data;\n  }\n  has(objId) {\n    const obj = this.#objs[objId];\n    return obj?.capability.settled || false;\n  }\n  resolve(objId, data = null) {\n    const obj = this.#ensureObj(objId);\n    obj.data = data;\n    obj.capability.resolve();\n  }\n  clear() {\n    for (const objId in this.#objs) {\n      const {\n        data\n      } = this.#objs[objId];\n      data?.bitmap?.close();\n    }\n    this.#objs = Object.create(null);\n  }\n}\nclass RenderTask {\n  #internalRenderTask = null;\n  constructor(internalRenderTask) {\n    this.#internalRenderTask = internalRenderTask;\n    this.onContinue = null;\n  }\n  get promise() {\n    return this.#internalRenderTask.capability.promise;\n  }\n  cancel(extraDelay = 0) {\n    this.#internalRenderTask.cancel(null, extraDelay);\n  }\n  get separateAnnots() {\n    const {\n      separateAnnots\n    } = this.#internalRenderTask.operatorList;\n    if (!separateAnnots) {\n      return false;\n    }\n    const {\n      annotationCanvasMap\n    } = this.#internalRenderTask;\n    return separateAnnots.form || separateAnnots.canvas && annotationCanvasMap?.size > 0;\n  }\n}\nexports.RenderTask = RenderTask;\nclass InternalRenderTask {\n  static #canvasInUse = new WeakSet();\n  constructor({\n    callback,\n    params,\n    objs,\n    commonObjs,\n    annotationCanvasMap,\n    operatorList,\n    pageIndex,\n    canvasFactory,\n    filterFactory,\n    useRequestAnimationFrame = false,\n    pdfBug = false,\n    pageColors = null\n  }) {\n    this.callback = callback;\n    this.params = params;\n    this.objs = objs;\n    this.commonObjs = commonObjs;\n    this.annotationCanvasMap = annotationCanvasMap;\n    this.operatorListIdx = null;\n    this.operatorList = operatorList;\n    this._pageIndex = pageIndex;\n    this.canvasFactory = canvasFactory;\n    this.filterFactory = filterFactory;\n    this._pdfBug = pdfBug;\n    this.pageColors = pageColors;\n    this.running = false;\n    this.graphicsReadyCallback = null;\n    this.graphicsReady = false;\n    this._useRequestAnimationFrame = useRequestAnimationFrame === true && typeof window !== \"undefined\";\n    this.cancelled = false;\n    this.capability = new _util.PromiseCapability();\n    this.task = new RenderTask(this);\n    this._cancelBound = this.cancel.bind(this);\n    this._continueBound = this._continue.bind(this);\n    this._scheduleNextBound = this._scheduleNext.bind(this);\n    this._nextBound = this._next.bind(this);\n    this._canvas = params.canvasContext.canvas;\n  }\n  get completed() {\n    return this.capability.promise.catch(function () {});\n  }\n  initializeGraphics({\n    transparency = false,\n    optionalContentConfig\n  }) {\n    if (this.cancelled) {\n      return;\n    }\n    if (this._canvas) {\n      if (InternalRenderTask.#canvasInUse.has(this._canvas)) {\n        throw new Error(\"Cannot use the same canvas during multiple render() operations. \" + \"Use different canvas or ensure previous operations were \" + \"cancelled or completed.\");\n      }\n      InternalRenderTask.#canvasInUse.add(this._canvas);\n    }\n    if (this._pdfBug && globalThis.StepperManager?.enabled) {\n      this.stepper = globalThis.StepperManager.create(this._pageIndex);\n      this.stepper.init(this.operatorList);\n      this.stepper.nextBreakPoint = this.stepper.getNextBreakPoint();\n    }\n    const {\n      canvasContext,\n      viewport,\n      transform,\n      background\n    } = this.params;\n    this.gfx = new _canvas.CanvasGraphics(canvasContext, this.commonObjs, this.objs, this.canvasFactory, this.filterFactory, {\n      optionalContentConfig\n    }, this.annotationCanvasMap, this.pageColors);\n    this.gfx.beginDrawing({\n      transform,\n      viewport,\n      transparency,\n      background\n    });\n    this.operatorListIdx = 0;\n    this.graphicsReady = true;\n    this.graphicsReadyCallback?.();\n  }\n  cancel(error = null, extraDelay = 0) {\n    this.running = false;\n    this.cancelled = true;\n    this.gfx?.endDrawing();\n    InternalRenderTask.#canvasInUse.delete(this._canvas);\n    this.callback(error || new _display_utils.RenderingCancelledException(`Rendering cancelled, page ${this._pageIndex + 1}`, extraDelay));\n  }\n  operatorListChanged() {\n    if (!this.graphicsReady) {\n      this.graphicsReadyCallback ||= this._continueBound;\n      return;\n    }\n    this.stepper?.updateOperatorList(this.operatorList);\n    if (this.running) {\n      return;\n    }\n    this._continue();\n  }\n  _continue() {\n    this.running = true;\n    if (this.cancelled) {\n      return;\n    }\n    if (this.task.onContinue) {\n      this.task.onContinue(this._scheduleNextBound);\n    } else {\n      this._scheduleNext();\n    }\n  }\n  _scheduleNext() {\n    if (this._useRequestAnimationFrame) {\n      window.requestAnimationFrame(() => {\n        this._nextBound().catch(this._cancelBound);\n      });\n    } else {\n      Promise.resolve().then(this._nextBound).catch(this._cancelBound);\n    }\n  }\n  async _next() {\n    if (this.cancelled) {\n      return;\n    }\n    this.operatorListIdx = this.gfx.executeOperatorList(this.operatorList, this.operatorListIdx, this._continueBound, this.stepper);\n    if (this.operatorListIdx === this.operatorList.argsArray.length) {\n      this.running = false;\n      if (this.operatorList.lastChunk) {\n        this.gfx.endDrawing();\n        InternalRenderTask.#canvasInUse.delete(this._canvas);\n        this.callback();\n      }\n    }\n  }\n}\nconst version = '3.11.174';\nexports.version = version;\nconst build = 'ce8716743';\nexports.build = build;\n\n/***/ }),\n/* 3 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.SerializableEmpty = exports.PrintAnnotationStorage = exports.AnnotationStorage = void 0;\nvar _util = __w_pdfjs_require__(1);\nvar _editor = __w_pdfjs_require__(4);\nvar _murmurhash = __w_pdfjs_require__(8);\nconst SerializableEmpty = Object.freeze({\n  map: null,\n  hash: \"\",\n  transfers: undefined\n});\nexports.SerializableEmpty = SerializableEmpty;\nclass AnnotationStorage {\n  #modified = false;\n  #storage = new Map();\n  constructor() {\n    this.onSetModified = null;\n    this.onResetModified = null;\n    this.onAnnotationEditor = null;\n  }\n  getValue(key, defaultValue) {\n    const value = this.#storage.get(key);\n    if (value === undefined) {\n      return defaultValue;\n    }\n    return Object.assign(defaultValue, value);\n  }\n  getRawValue(key) {\n    return this.#storage.get(key);\n  }\n  remove(key) {\n    this.#storage.delete(key);\n    if (this.#storage.size === 0) {\n      this.resetModified();\n    }\n    if (typeof this.onAnnotationEditor === \"function\") {\n      for (const value of this.#storage.values()) {\n        if (value instanceof _editor.AnnotationEditor) {\n          return;\n        }\n      }\n      this.onAnnotationEditor(null);\n    }\n  }\n  setValue(key, value) {\n    const obj = this.#storage.get(key);\n    let modified = false;\n    if (obj !== undefined) {\n      for (const [entry, val] of Object.entries(value)) {\n        if (obj[entry] !== val) {\n          modified = true;\n          obj[entry] = val;\n        }\n      }\n    } else {\n      modified = true;\n      this.#storage.set(key, value);\n    }\n    if (modified) {\n      this.#setModified();\n    }\n    if (value instanceof _editor.AnnotationEditor && typeof this.onAnnotationEditor === \"function\") {\n      this.onAnnotationEditor(value.constructor._type);\n    }\n  }\n  has(key) {\n    return this.#storage.has(key);\n  }\n  getAll() {\n    return this.#storage.size > 0 ? (0, _util.objectFromMap)(this.#storage) : null;\n  }\n  setAll(obj) {\n    for (const [key, val] of Object.entries(obj)) {\n      this.setValue(key, val);\n    }\n  }\n  get size() {\n    return this.#storage.size;\n  }\n  #setModified() {\n    if (!this.#modified) {\n      this.#modified = true;\n      if (typeof this.onSetModified === \"function\") {\n        this.onSetModified();\n      }\n    }\n  }\n  resetModified() {\n    if (this.#modified) {\n      this.#modified = false;\n      if (typeof this.onResetModified === \"function\") {\n        this.onResetModified();\n      }\n    }\n  }\n  get print() {\n    return new PrintAnnotationStorage(this);\n  }\n  get serializable() {\n    if (this.#storage.size === 0) {\n      return SerializableEmpty;\n    }\n    const map = new Map(),\n      hash = new _murmurhash.MurmurHash3_64(),\n      transfers = [];\n    const context = Object.create(null);\n    let hasBitmap = false;\n    for (const [key, val] of this.#storage) {\n      const serialized = val instanceof _editor.AnnotationEditor ? val.serialize(false, context) : val;\n      if (serialized) {\n        map.set(key, serialized);\n        hash.update(`${key}:${JSON.stringify(serialized)}`);\n        hasBitmap ||= !!serialized.bitmap;\n      }\n    }\n    if (hasBitmap) {\n      for (const value of map.values()) {\n        if (value.bitmap) {\n          transfers.push(value.bitmap);\n        }\n      }\n    }\n    return map.size > 0 ? {\n      map,\n      hash: hash.hexdigest(),\n      transfers\n    } : SerializableEmpty;\n  }\n}\nexports.AnnotationStorage = AnnotationStorage;\nclass PrintAnnotationStorage extends AnnotationStorage {\n  #serializable;\n  constructor(parent) {\n    super();\n    const {\n      map,\n      hash,\n      transfers\n    } = parent.serializable;\n    const clone = structuredClone(map, transfers ? {\n      transfer: transfers\n    } : null);\n    this.#serializable = {\n      map: clone,\n      hash,\n      transfers\n    };\n  }\n  get print() {\n    (0, _util.unreachable)(\"Should not call PrintAnnotationStorage.print\");\n  }\n  get serializable() {\n    return this.#serializable;\n  }\n}\nexports.PrintAnnotationStorage = PrintAnnotationStorage;\n\n/***/ }),\n/* 4 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.AnnotationEditor = void 0;\nvar _tools = __w_pdfjs_require__(5);\nvar _util = __w_pdfjs_require__(1);\nvar _display_utils = __w_pdfjs_require__(6);\nclass AnnotationEditor {\n  #altText = \"\";\n  #altTextDecorative = false;\n  #altTextButton = null;\n  #altTextTooltip = null;\n  #altTextTooltipTimeout = null;\n  #keepAspectRatio = false;\n  #resizersDiv = null;\n  #boundFocusin = this.focusin.bind(this);\n  #boundFocusout = this.focusout.bind(this);\n  #hasBeenClicked = false;\n  #isEditing = false;\n  #isInEditMode = false;\n  _initialOptions = Object.create(null);\n  _uiManager = null;\n  _focusEventsAllowed = true;\n  _l10nPromise = null;\n  #isDraggable = false;\n  #zIndex = AnnotationEditor._zIndex++;\n  static _borderLineWidth = -1;\n  static _colorManager = new _tools.ColorManager();\n  static _zIndex = 1;\n  static SMALL_EDITOR_SIZE = 0;\n  constructor(parameters) {\n    if (this.constructor === AnnotationEditor) {\n      (0, _util.unreachable)(\"Cannot initialize AnnotationEditor.\");\n    }\n    this.parent = parameters.parent;\n    this.id = parameters.id;\n    this.width = this.height = null;\n    this.pageIndex = parameters.parent.pageIndex;\n    this.name = parameters.name;\n    this.div = null;\n    this._uiManager = parameters.uiManager;\n    this.annotationElementId = null;\n    this._willKeepAspectRatio = false;\n    this._initialOptions.isCentered = parameters.isCentered;\n    this._structTreeParentId = null;\n    const {\n      rotation,\n      rawDims: {\n        pageWidth,\n        pageHeight,\n        pageX,\n        pageY\n      }\n    } = this.parent.viewport;\n    this.rotation = rotation;\n    this.pageRotation = (360 + rotation - this._uiManager.viewParameters.rotation) % 360;\n    this.pageDimensions = [pageWidth, pageHeight];\n    this.pageTranslation = [pageX, pageY];\n    const [width, height] = this.parentDimensions;\n    this.x = parameters.x / width;\n    this.y = parameters.y / height;\n    this.isAttachedToDOM = false;\n    this.deleted = false;\n  }\n  get editorType() {\n    return Object.getPrototypeOf(this).constructor._type;\n  }\n  static get _defaultLineColor() {\n    return (0, _util.shadow)(this, \"_defaultLineColor\", this._colorManager.getHexCode(\"CanvasText\"));\n  }\n  static deleteAnnotationElement(editor) {\n    const fakeEditor = new FakeEditor({\n      id: editor.parent.getNextId(),\n      parent: editor.parent,\n      uiManager: editor._uiManager\n    });\n    fakeEditor.annotationElementId = editor.annotationElementId;\n    fakeEditor.deleted = true;\n    fakeEditor._uiManager.addToAnnotationStorage(fakeEditor);\n  }\n  static initialize(l10n, options = null) {\n    AnnotationEditor._l10nPromise ||= new Map([\"editor_alt_text_button_label\", \"editor_alt_text_edit_button_label\", \"editor_alt_text_decorative_tooltip\"].map(str => [str, l10n.get(str)]));\n    if (options?.strings) {\n      for (const str of options.strings) {\n        AnnotationEditor._l10nPromise.set(str, l10n.get(str));\n      }\n    }\n    if (AnnotationEditor._borderLineWidth !== -1) {\n      return;\n    }\n    const style = getComputedStyle(document.documentElement);\n    AnnotationEditor._borderLineWidth = parseFloat(style.getPropertyValue(\"--outline-width\")) || 0;\n  }\n  static updateDefaultParams(_type, _value) {}\n  static get defaultPropertiesToUpdate() {\n    return [];\n  }\n  static isHandlingMimeForPasting(mime) {\n    return false;\n  }\n  static paste(item, parent) {\n    (0, _util.unreachable)(\"Not implemented\");\n  }\n  get propertiesToUpdate() {\n    return [];\n  }\n  get _isDraggable() {\n    return this.#isDraggable;\n  }\n  set _isDraggable(value) {\n    this.#isDraggable = value;\n    this.div?.classList.toggle(\"draggable\", value);\n  }\n  center() {\n    const [pageWidth, pageHeight] = this.pageDimensions;\n    switch (this.parentRotation) {\n      case 90:\n        this.x -= this.height * pageHeight / (pageWidth * 2);\n        this.y += this.width * pageWidth / (pageHeight * 2);\n        break;\n      case 180:\n        this.x += this.width / 2;\n        this.y += this.height / 2;\n        break;\n      case 270:\n        this.x += this.height * pageHeight / (pageWidth * 2);\n        this.y -= this.width * pageWidth / (pageHeight * 2);\n        break;\n      default:\n        this.x -= this.width / 2;\n        this.y -= this.height / 2;\n        break;\n    }\n    this.fixAndSetPosition();\n  }\n  addCommands(params) {\n    this._uiManager.addCommands(params);\n  }\n  get currentLayer() {\n    return this._uiManager.currentLayer;\n  }\n  setInBackground() {\n    this.div.style.zIndex = 0;\n  }\n  setInForeground() {\n    this.div.style.zIndex = this.#zIndex;\n  }\n  setParent(parent) {\n    if (parent !== null) {\n      this.pageIndex = parent.pageIndex;\n      this.pageDimensions = parent.pageDimensions;\n    }\n    this.parent = parent;\n  }\n  focusin(event) {\n    if (!this._focusEventsAllowed) {\n      return;\n    }\n    if (!this.#hasBeenClicked) {\n      this.parent.setSelected(this);\n    } else {\n      this.#hasBeenClicked = false;\n    }\n  }\n  focusout(event) {\n    if (!this._focusEventsAllowed) {\n      return;\n    }\n    if (!this.isAttachedToDOM) {\n      return;\n    }\n    const target = event.relatedTarget;\n    if (target?.closest(`#${this.id}`)) {\n      return;\n    }\n    event.preventDefault();\n    if (!this.parent?.isMultipleSelection) {\n      this.commitOrRemove();\n    }\n  }\n  commitOrRemove() {\n    if (this.isEmpty()) {\n      this.remove();\n    } else {\n      this.commit();\n    }\n  }\n  commit() {\n    this.addToAnnotationStorage();\n  }\n  addToAnnotationStorage() {\n    this._uiManager.addToAnnotationStorage(this);\n  }\n  setAt(x, y, tx, ty) {\n    const [width, height] = this.parentDimensions;\n    [tx, ty] = this.screenToPageTranslation(tx, ty);\n    this.x = (x + tx) / width;\n    this.y = (y + ty) / height;\n    this.fixAndSetPosition();\n  }\n  #translate([width, height], x, y) {\n    [x, y] = this.screenToPageTranslation(x, y);\n    this.x += x / width;\n    this.y += y / height;\n    this.fixAndSetPosition();\n  }\n  translate(x, y) {\n    this.#translate(this.parentDimensions, x, y);\n  }\n  translateInPage(x, y) {\n    this.#translate(this.pageDimensions, x, y);\n    this.div.scrollIntoView({\n      block: \"nearest\"\n    });\n  }\n  drag(tx, ty) {\n    const [parentWidth, parentHeight] = this.parentDimensions;\n    this.x += tx / parentWidth;\n    this.y += ty / parentHeight;\n    if (this.parent && (this.x < 0 || this.x > 1 || this.y < 0 || this.y > 1)) {\n      const {\n        x,\n        y\n      } = this.div.getBoundingClientRect();\n      if (this.parent.findNewParent(this, x, y)) {\n        this.x -= Math.floor(this.x);\n        this.y -= Math.floor(this.y);\n      }\n    }\n    let {\n      x,\n      y\n    } = this;\n    const [bx, by] = this.#getBaseTranslation();\n    x += bx;\n    y += by;\n    this.div.style.left = `${(100 * x).toFixed(2)}%`;\n    this.div.style.top = `${(100 * y).toFixed(2)}%`;\n    this.div.scrollIntoView({\n      block: \"nearest\"\n    });\n  }\n  #getBaseTranslation() {\n    const [parentWidth, parentHeight] = this.parentDimensions;\n    const {\n      _borderLineWidth\n    } = AnnotationEditor;\n    const x = _borderLineWidth / parentWidth;\n    const y = _borderLineWidth / parentHeight;\n    switch (this.rotation) {\n      case 90:\n        return [-x, y];\n      case 180:\n        return [x, y];\n      case 270:\n        return [x, -y];\n      default:\n        return [-x, -y];\n    }\n  }\n  fixAndSetPosition() {\n    const [pageWidth, pageHeight] = this.pageDimensions;\n    let {\n      x,\n      y,\n      width,\n      height\n    } = this;\n    width *= pageWidth;\n    height *= pageHeight;\n    x *= pageWidth;\n    y *= pageHeight;\n    switch (this.rotation) {\n      case 0:\n        x = Math.max(0, Math.min(pageWidth - width, x));\n        y = Math.max(0, Math.min(pageHeight - height, y));\n        break;\n      case 90:\n        x = Math.max(0, Math.min(pageWidth - height, x));\n        y = Math.min(pageHeight, Math.max(width, y));\n        break;\n      case 180:\n        x = Math.min(pageWidth, Math.max(width, x));\n        y = Math.min(pageHeight, Math.max(height, y));\n        break;\n      case 270:\n        x = Math.min(pageWidth, Math.max(height, x));\n        y = Math.max(0, Math.min(pageHeight - width, y));\n        break;\n    }\n    this.x = x /= pageWidth;\n    this.y = y /= pageHeight;\n    const [bx, by] = this.#getBaseTranslation();\n    x += bx;\n    y += by;\n    const {\n      style\n    } = this.div;\n    style.left = `${(100 * x).toFixed(2)}%`;\n    style.top = `${(100 * y).toFixed(2)}%`;\n    this.moveInDOM();\n  }\n  static #rotatePoint(x, y, angle) {\n    switch (angle) {\n      case 90:\n        return [y, -x];\n      case 180:\n        return [-x, -y];\n      case 270:\n        return [-y, x];\n      default:\n        return [x, y];\n    }\n  }\n  screenToPageTranslation(x, y) {\n    return AnnotationEditor.#rotatePoint(x, y, this.parentRotation);\n  }\n  pageTranslationToScreen(x, y) {\n    return AnnotationEditor.#rotatePoint(x, y, 360 - this.parentRotation);\n  }\n  #getRotationMatrix(rotation) {\n    switch (rotation) {\n      case 90:\n        {\n          const [pageWidth, pageHeight] = this.pageDimensions;\n          return [0, -pageWidth / pageHeight, pageHeight / pageWidth, 0];\n        }\n      case 180:\n        return [-1, 0, 0, -1];\n      case 270:\n        {\n          const [pageWidth, pageHeight] = this.pageDimensions;\n          return [0, pageWidth / pageHeight, -pageHeight / pageWidth, 0];\n        }\n      default:\n        return [1, 0, 0, 1];\n    }\n  }\n  get parentScale() {\n    return this._uiManager.viewParameters.realScale;\n  }\n  get parentRotation() {\n    return (this._uiManager.viewParameters.rotation + this.pageRotation) % 360;\n  }\n  get parentDimensions() {\n    const {\n      parentScale,\n      pageDimensions: [pageWidth, pageHeight]\n    } = this;\n    const scaledWidth = pageWidth * parentScale;\n    const scaledHeight = pageHeight * parentScale;\n    return _util.FeatureTest.isCSSRoundSupported ? [Math.round(scaledWidth), Math.round(scaledHeight)] : [scaledWidth, scaledHeight];\n  }\n  setDims(width, height) {\n    const [parentWidth, parentHeight] = this.parentDimensions;\n    this.div.style.width = `${(100 * width / parentWidth).toFixed(2)}%`;\n    if (!this.#keepAspectRatio) {\n      this.div.style.height = `${(100 * height / parentHeight).toFixed(2)}%`;\n    }\n    this.#altTextButton?.classList.toggle(\"small\", width < AnnotationEditor.SMALL_EDITOR_SIZE || height < AnnotationEditor.SMALL_EDITOR_SIZE);\n  }\n  fixDims() {\n    const {\n      style\n    } = this.div;\n    const {\n      height,\n      width\n    } = style;\n    const widthPercent = width.endsWith(\"%\");\n    const heightPercent = !this.#keepAspectRatio && height.endsWith(\"%\");\n    if (widthPercent && heightPercent) {\n      return;\n    }\n    const [parentWidth, parentHeight] = this.parentDimensions;\n    if (!widthPercent) {\n      style.width = `${(100 * parseFloat(width) / parentWidth).toFixed(2)}%`;\n    }\n    if (!this.#keepAspectRatio && !heightPercent) {\n      style.height = `${(100 * parseFloat(height) / parentHeight).toFixed(2)}%`;\n    }\n  }\n  getInitialTranslation() {\n    return [0, 0];\n  }\n  #createResizers() {\n    if (this.#resizersDiv) {\n      return;\n    }\n    this.#resizersDiv = document.createElement(\"div\");\n    this.#resizersDiv.classList.add(\"resizers\");\n    const classes = [\"topLeft\", \"topRight\", \"bottomRight\", \"bottomLeft\"];\n    if (!this._willKeepAspectRatio) {\n      classes.push(\"topMiddle\", \"middleRight\", \"bottomMiddle\", \"middleLeft\");\n    }\n    for (const name of classes) {\n      const div = document.createElement(\"div\");\n      this.#resizersDiv.append(div);\n      div.classList.add(\"resizer\", name);\n      div.addEventListener(\"pointerdown\", this.#resizerPointerdown.bind(this, name));\n      div.addEventListener(\"contextmenu\", _display_utils.noContextMenu);\n    }\n    this.div.prepend(this.#resizersDiv);\n  }\n  #resizerPointerdown(name, event) {\n    event.preventDefault();\n    const {\n      isMac\n    } = _util.FeatureTest.platform;\n    if (event.button !== 0 || event.ctrlKey && isMac) {\n      return;\n    }\n    const boundResizerPointermove = this.#resizerPointermove.bind(this, name);\n    const savedDraggable = this._isDraggable;\n    this._isDraggable = false;\n    const pointerMoveOptions = {\n      passive: true,\n      capture: true\n    };\n    window.addEventListener(\"pointermove\", boundResizerPointermove, pointerMoveOptions);\n    const savedX = this.x;\n    const savedY = this.y;\n    const savedWidth = this.width;\n    const savedHeight = this.height;\n    const savedParentCursor = this.parent.div.style.cursor;\n    const savedCursor = this.div.style.cursor;\n    this.div.style.cursor = this.parent.div.style.cursor = window.getComputedStyle(event.target).cursor;\n    const pointerUpCallback = () => {\n      this._isDraggable = savedDraggable;\n      window.removeEventListener(\"pointerup\", pointerUpCallback);\n      window.removeEventListener(\"blur\", pointerUpCallback);\n      window.removeEventListener(\"pointermove\", boundResizerPointermove, pointerMoveOptions);\n      this.parent.div.style.cursor = savedParentCursor;\n      this.div.style.cursor = savedCursor;\n      const newX = this.x;\n      const newY = this.y;\n      const newWidth = this.width;\n      const newHeight = this.height;\n      if (newX === savedX && newY === savedY && newWidth === savedWidth && newHeight === savedHeight) {\n        return;\n      }\n      this.addCommands({\n        cmd: () => {\n          this.width = newWidth;\n          this.height = newHeight;\n          this.x = newX;\n          this.y = newY;\n          const [parentWidth, parentHeight] = this.parentDimensions;\n          this.setDims(parentWidth * newWidth, parentHeight * newHeight);\n          this.fixAndSetPosition();\n        },\n        undo: () => {\n          this.width = savedWidth;\n          this.height = savedHeight;\n          this.x = savedX;\n          this.y = savedY;\n          const [parentWidth, parentHeight] = this.parentDimensions;\n          this.setDims(parentWidth * savedWidth, parentHeight * savedHeight);\n          this.fixAndSetPosition();\n        },\n        mustExec: true\n      });\n    };\n    window.addEventListener(\"pointerup\", pointerUpCallback);\n    window.addEventListener(\"blur\", pointerUpCallback);\n  }\n  #resizerPointermove(name, event) {\n    const [parentWidth, parentHeight] = this.parentDimensions;\n    const savedX = this.x;\n    const savedY = this.y;\n    const savedWidth = this.width;\n    const savedHeight = this.height;\n    const minWidth = AnnotationEditor.MIN_SIZE / parentWidth;\n    const minHeight = AnnotationEditor.MIN_SIZE / parentHeight;\n    const round = x => Math.round(x * 10000) / 10000;\n    const rotationMatrix = this.#getRotationMatrix(this.rotation);\n    const transf = (x, y) => [rotationMatrix[0] * x + rotationMatrix[2] * y, rotationMatrix[1] * x + rotationMatrix[3] * y];\n    const invRotationMatrix = this.#getRotationMatrix(360 - this.rotation);\n    const invTransf = (x, y) => [invRotationMatrix[0] * x + invRotationMatrix[2] * y, invRotationMatrix[1] * x + invRotationMatrix[3] * y];\n    let getPoint;\n    let getOpposite;\n    let isDiagonal = false;\n    let isHorizontal = false;\n    switch (name) {\n      case \"topLeft\":\n        isDiagonal = true;\n        getPoint = (w, h) => [0, 0];\n        getOpposite = (w, h) => [w, h];\n        break;\n      case \"topMiddle\":\n        getPoint = (w, h) => [w / 2, 0];\n        getOpposite = (w, h) => [w / 2, h];\n        break;\n      case \"topRight\":\n        isDiagonal = true;\n        getPoint = (w, h) => [w, 0];\n        getOpposite = (w, h) => [0, h];\n        break;\n      case \"middleRight\":\n        isHorizontal = true;\n        getPoint = (w, h) => [w, h / 2];\n        getOpposite = (w, h) => [0, h / 2];\n        break;\n      case \"bottomRight\":\n        isDiagonal = true;\n        getPoint = (w, h) => [w, h];\n        getOpposite = (w, h) => [0, 0];\n        break;\n      case \"bottomMiddle\":\n        getPoint = (w, h) => [w / 2, h];\n        getOpposite = (w, h) => [w / 2, 0];\n        break;\n      case \"bottomLeft\":\n        isDiagonal = true;\n        getPoint = (w, h) => [0, h];\n        getOpposite = (w, h) => [w, 0];\n        break;\n      case \"middleLeft\":\n        isHorizontal = true;\n        getPoint = (w, h) => [0, h / 2];\n        getOpposite = (w, h) => [w, h / 2];\n        break;\n    }\n    const point = getPoint(savedWidth, savedHeight);\n    const oppositePoint = getOpposite(savedWidth, savedHeight);\n    let transfOppositePoint = transf(...oppositePoint);\n    const oppositeX = round(savedX + transfOppositePoint[0]);\n    const oppositeY = round(savedY + transfOppositePoint[1]);\n    let ratioX = 1;\n    let ratioY = 1;\n    let [deltaX, deltaY] = this.screenToPageTranslation(event.movementX, event.movementY);\n    [deltaX, deltaY] = invTransf(deltaX / parentWidth, deltaY / parentHeight);\n    if (isDiagonal) {\n      const oldDiag = Math.hypot(savedWidth, savedHeight);\n      ratioX = ratioY = Math.max(Math.min(Math.hypot(oppositePoint[0] - point[0] - deltaX, oppositePoint[1] - point[1] - deltaY) / oldDiag, 1 / savedWidth, 1 / savedHeight), minWidth / savedWidth, minHeight / savedHeight);\n    } else if (isHorizontal) {\n      ratioX = Math.max(minWidth, Math.min(1, Math.abs(oppositePoint[0] - point[0] - deltaX))) / savedWidth;\n    } else {\n      ratioY = Math.max(minHeight, Math.min(1, Math.abs(oppositePoint[1] - point[1] - deltaY))) / savedHeight;\n    }\n    const newWidth = round(savedWidth * ratioX);\n    const newHeight = round(savedHeight * ratioY);\n    transfOppositePoint = transf(...getOpposite(newWidth, newHeight));\n    const newX = oppositeX - transfOppositePoint[0];\n    const newY = oppositeY - transfOppositePoint[1];\n    this.width = newWidth;\n    this.height = newHeight;\n    this.x = newX;\n    this.y = newY;\n    this.setDims(parentWidth * newWidth, parentHeight * newHeight);\n    this.fixAndSetPosition();\n  }\n  async addAltTextButton() {\n    if (this.#altTextButton) {\n      return;\n    }\n    const altText = this.#altTextButton = document.createElement(\"button\");\n    altText.className = \"altText\";\n    const msg = await AnnotationEditor._l10nPromise.get(\"editor_alt_text_button_label\");\n    altText.textContent = msg;\n    altText.setAttribute(\"aria-label\", msg);\n    altText.tabIndex = \"0\";\n    altText.addEventListener(\"contextmenu\", _display_utils.noContextMenu);\n    altText.addEventListener(\"pointerdown\", event => event.stopPropagation());\n    altText.addEventListener(\"click\", event => {\n      event.preventDefault();\n      this._uiManager.editAltText(this);\n    }, {\n      capture: true\n    });\n    altText.addEventListener(\"keydown\", event => {\n      if (event.target === altText && event.key === \"Enter\") {\n        event.preventDefault();\n        this._uiManager.editAltText(this);\n      }\n    });\n    this.#setAltTextButtonState();\n    this.div.append(altText);\n    if (!AnnotationEditor.SMALL_EDITOR_SIZE) {\n      const PERCENT = 40;\n      AnnotationEditor.SMALL_EDITOR_SIZE = Math.min(128, Math.round(altText.getBoundingClientRect().width * (1 + PERCENT / 100)));\n    }\n  }\n  async #setAltTextButtonState() {\n    const button = this.#altTextButton;\n    if (!button) {\n      return;\n    }\n    if (!this.#altText && !this.#altTextDecorative) {\n      button.classList.remove(\"done\");\n      this.#altTextTooltip?.remove();\n      return;\n    }\n    AnnotationEditor._l10nPromise.get(\"editor_alt_text_edit_button_label\").then(msg => {\n      button.setAttribute(\"aria-label\", msg);\n    });\n    let tooltip = this.#altTextTooltip;\n    if (!tooltip) {\n      this.#altTextTooltip = tooltip = document.createElement(\"span\");\n      tooltip.className = \"tooltip\";\n      tooltip.setAttribute(\"role\", \"tooltip\");\n      const id = tooltip.id = `alt-text-tooltip-${this.id}`;\n      button.setAttribute(\"aria-describedby\", id);\n      const DELAY_TO_SHOW_TOOLTIP = 100;\n      button.addEventListener(\"mouseenter\", () => {\n        this.#altTextTooltipTimeout = setTimeout(() => {\n          this.#altTextTooltipTimeout = null;\n          this.#altTextTooltip.classList.add(\"show\");\n          this._uiManager._eventBus.dispatch(\"reporttelemetry\", {\n            source: this,\n            details: {\n              type: \"editing\",\n              subtype: this.editorType,\n              data: {\n                action: \"alt_text_tooltip\"\n              }\n            }\n          });\n        }, DELAY_TO_SHOW_TOOLTIP);\n      });\n      button.addEventListener(\"mouseleave\", () => {\n        clearTimeout(this.#altTextTooltipTimeout);\n        this.#altTextTooltipTimeout = null;\n        this.#altTextTooltip?.classList.remove(\"show\");\n      });\n    }\n    button.classList.add(\"done\");\n    tooltip.innerText = this.#altTextDecorative ? await AnnotationEditor._l10nPromise.get(\"editor_alt_text_decorative_tooltip\") : this.#altText;\n    if (!tooltip.parentNode) {\n      button.append(tooltip);\n    }\n  }\n  getClientDimensions() {\n    return this.div.getBoundingClientRect();\n  }\n  get altTextData() {\n    return {\n      altText: this.#altText,\n      decorative: this.#altTextDecorative\n    };\n  }\n  set altTextData({\n    altText,\n    decorative\n  }) {\n    if (this.#altText === altText && this.#altTextDecorative === decorative) {\n      return;\n    }\n    this.#altText = altText;\n    this.#altTextDecorative = decorative;\n    this.#setAltTextButtonState();\n  }\n  render() {\n    this.div = document.createElement(\"div\");\n    this.div.setAttribute(\"data-editor-rotation\", (360 - this.rotation) % 360);\n    this.div.className = this.name;\n    this.div.setAttribute(\"id\", this.id);\n    this.div.setAttribute(\"tabIndex\", 0);\n    this.setInForeground();\n    this.div.addEventListener(\"focusin\", this.#boundFocusin);\n    this.div.addEventListener(\"focusout\", this.#boundFocusout);\n    const [parentWidth, parentHeight] = this.parentDimensions;\n    if (this.parentRotation % 180 !== 0) {\n      this.div.style.maxWidth = `${(100 * parentHeight / parentWidth).toFixed(2)}%`;\n      this.div.style.maxHeight = `${(100 * parentWidth / parentHeight).toFixed(2)}%`;\n    }\n    const [tx, ty] = this.getInitialTranslation();\n    this.translate(tx, ty);\n    (0, _tools.bindEvents)(this, this.div, [\"pointerdown\"]);\n    return this.div;\n  }\n  pointerdown(event) {\n    const {\n      isMac\n    } = _util.FeatureTest.platform;\n    if (event.button !== 0 || event.ctrlKey && isMac) {\n      event.preventDefault();\n      return;\n    }\n    this.#hasBeenClicked = true;\n    this.#setUpDragSession(event);\n  }\n  #setUpDragSession(event) {\n    if (!this._isDraggable) {\n      return;\n    }\n    const isSelected = this._uiManager.isSelected(this);\n    this._uiManager.setUpDragSession();\n    let pointerMoveOptions, pointerMoveCallback;\n    if (isSelected) {\n      pointerMoveOptions = {\n        passive: true,\n        capture: true\n      };\n      pointerMoveCallback = e => {\n        const [tx, ty] = this.screenToPageTranslation(e.movementX, e.movementY);\n        this._uiManager.dragSelectedEditors(tx, ty);\n      };\n      window.addEventListener(\"pointermove\", pointerMoveCallback, pointerMoveOptions);\n    }\n    const pointerUpCallback = () => {\n      window.removeEventListener(\"pointerup\", pointerUpCallback);\n      window.removeEventListener(\"blur\", pointerUpCallback);\n      if (isSelected) {\n        window.removeEventListener(\"pointermove\", pointerMoveCallback, pointerMoveOptions);\n      }\n      this.#hasBeenClicked = false;\n      if (!this._uiManager.endDragSession()) {\n        const {\n          isMac\n        } = _util.FeatureTest.platform;\n        if (event.ctrlKey && !isMac || event.shiftKey || event.metaKey && isMac) {\n          this.parent.toggleSelected(this);\n        } else {\n          this.parent.setSelected(this);\n        }\n      }\n    };\n    window.addEventListener(\"pointerup\", pointerUpCallback);\n    window.addEventListener(\"blur\", pointerUpCallback);\n  }\n  moveInDOM() {\n    this.parent?.moveEditorInDOM(this);\n  }\n  _setParentAndPosition(parent, x, y) {\n    parent.changeParent(this);\n    this.x = x;\n    this.y = y;\n    this.fixAndSetPosition();\n  }\n  getRect(tx, ty) {\n    const scale = this.parentScale;\n    const [pageWidth, pageHeight] = this.pageDimensions;\n    const [pageX, pageY] = this.pageTranslation;\n    const shiftX = tx / scale;\n    const shiftY = ty / scale;\n    const x = this.x * pageWidth;\n    const y = this.y * pageHeight;\n    const width = this.width * pageWidth;\n    const height = this.height * pageHeight;\n    switch (this.rotation) {\n      case 0:\n        return [x + shiftX + pageX, pageHeight - y - shiftY - height + pageY, x + shiftX + width + pageX, pageHeight - y - shiftY + pageY];\n      case 90:\n        return [x + shiftY + pageX, pageHeight - y + shiftX + pageY, x + shiftY + height + pageX, pageHeight - y + shiftX + width + pageY];\n      case 180:\n        return [x - shiftX - width + pageX, pageHeight - y + shiftY + pageY, x - shiftX + pageX, pageHeight - y + shiftY + height + pageY];\n      case 270:\n        return [x - shiftY - height + pageX, pageHeight - y - shiftX - width + pageY, x - shiftY + pageX, pageHeight - y - shiftX + pageY];\n      default:\n        throw new Error(\"Invalid rotation\");\n    }\n  }\n  getRectInCurrentCoords(rect, pageHeight) {\n    const [x1, y1, x2, y2] = rect;\n    const width = x2 - x1;\n    const height = y2 - y1;\n    switch (this.rotation) {\n      case 0:\n        return [x1, pageHeight - y2, width, height];\n      case 90:\n        return [x1, pageHeight - y1, height, width];\n      case 180:\n        return [x2, pageHeight - y1, width, height];\n      case 270:\n        return [x2, pageHeight - y2, height, width];\n      default:\n        throw new Error(\"Invalid rotation\");\n    }\n  }\n  onceAdded() {}\n  isEmpty() {\n    return false;\n  }\n  enableEditMode() {\n    this.#isInEditMode = true;\n  }\n  disableEditMode() {\n    this.#isInEditMode = false;\n  }\n  isInEditMode() {\n    return this.#isInEditMode;\n  }\n  shouldGetKeyboardEvents() {\n    return false;\n  }\n  needsToBeRebuilt() {\n    return this.div && !this.isAttachedToDOM;\n  }\n  rebuild() {\n    this.div?.addEventListener(\"focusin\", this.#boundFocusin);\n    this.div?.addEventListener(\"focusout\", this.#boundFocusout);\n  }\n  serialize(isForCopying = false, context = null) {\n    (0, _util.unreachable)(\"An editor must be serializable\");\n  }\n  static deserialize(data, parent, uiManager) {\n    const editor = new this.prototype.constructor({\n      parent,\n      id: parent.getNextId(),\n      uiManager\n    });\n    editor.rotation = data.rotation;\n    const [pageWidth, pageHeight] = editor.pageDimensions;\n    const [x, y, width, height] = editor.getRectInCurrentCoords(data.rect, pageHeight);\n    editor.x = x / pageWidth;\n    editor.y = y / pageHeight;\n    editor.width = width / pageWidth;\n    editor.height = height / pageHeight;\n    return editor;\n  }\n  remove() {\n    this.div.removeEventListener(\"focusin\", this.#boundFocusin);\n    this.div.removeEventListener(\"focusout\", this.#boundFocusout);\n    if (!this.isEmpty()) {\n      this.commit();\n    }\n    if (this.parent) {\n      this.parent.remove(this);\n    } else {\n      this._uiManager.removeEditor(this);\n    }\n    this.#altTextButton?.remove();\n    this.#altTextButton = null;\n    this.#altTextTooltip = null;\n  }\n  get isResizable() {\n    return false;\n  }\n  makeResizable() {\n    if (this.isResizable) {\n      this.#createResizers();\n      this.#resizersDiv.classList.remove(\"hidden\");\n    }\n  }\n  select() {\n    this.makeResizable();\n    this.div?.classList.add(\"selectedEditor\");\n  }\n  unselect() {\n    this.#resizersDiv?.classList.add(\"hidden\");\n    this.div?.classList.remove(\"selectedEditor\");\n    if (this.div?.contains(document.activeElement)) {\n      this._uiManager.currentLayer.div.focus();\n    }\n  }\n  updateParams(type, value) {}\n  disableEditing() {\n    if (this.#altTextButton) {\n      this.#altTextButton.hidden = true;\n    }\n  }\n  enableEditing() {\n    if (this.#altTextButton) {\n      this.#altTextButton.hidden = false;\n    }\n  }\n  enterInEditMode() {}\n  get contentDiv() {\n    return this.div;\n  }\n  get isEditing() {\n    return this.#isEditing;\n  }\n  set isEditing(value) {\n    this.#isEditing = value;\n    if (!this.parent) {\n      return;\n    }\n    if (value) {\n      this.parent.setSelected(this);\n      this.parent.setActiveEditor(this);\n    } else {\n      this.parent.setActiveEditor(null);\n    }\n  }\n  setAspectRatio(width, height) {\n    this.#keepAspectRatio = true;\n    const aspectRatio = width / height;\n    const {\n      style\n    } = this.div;\n    style.aspectRatio = aspectRatio;\n    style.height = \"auto\";\n  }\n  static get MIN_SIZE() {\n    return 16;\n  }\n}\nexports.AnnotationEditor = AnnotationEditor;\nclass FakeEditor extends AnnotationEditor {\n  constructor(params) {\n    super(params);\n    this.annotationElementId = params.annotationElementId;\n    this.deleted = true;\n  }\n  serialize() {\n    return {\n      id: this.annotationElementId,\n      deleted: true,\n      pageIndex: this.pageIndex\n    };\n  }\n}\n\n/***/ }),\n/* 5 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.KeyboardManager = exports.CommandManager = exports.ColorManager = exports.AnnotationEditorUIManager = void 0;\nexports.bindEvents = bindEvents;\nexports.opacityToHex = opacityToHex;\nvar _util = __w_pdfjs_require__(1);\nvar _display_utils = __w_pdfjs_require__(6);\nfunction bindEvents(obj, element, names) {\n  for (const name of names) {\n    element.addEventListener(name, obj[name].bind(obj));\n  }\n}\nfunction opacityToHex(opacity) {\n  return Math.round(Math.min(255, Math.max(1, 255 * opacity))).toString(16).padStart(2, \"0\");\n}\nclass IdManager {\n  #id = 0;\n  getId() {\n    return `${_util.AnnotationEditorPrefix}${this.#id++}`;\n  }\n}\nclass ImageManager {\n  #baseId = (0, _util.getUuid)();\n  #id = 0;\n  #cache = null;\n  static get _isSVGFittingCanvas() {\n    const svg = `data:image/svg+xml;charset=UTF-8,<svg viewBox=\"0 0 1 1\" width=\"1\" height=\"1\" xmlns=\"http://www.w3.org/2000/svg\"><rect width=\"1\" height=\"1\" style=\"fill:red;\"/></svg>`;\n    const canvas = new OffscreenCanvas(1, 3);\n    const ctx = canvas.getContext(\"2d\");\n    const image = new Image();\n    image.src = svg;\n    const promise = image.decode().then(() => {\n      ctx.drawImage(image, 0, 0, 1, 1, 0, 0, 1, 3);\n      return new Uint32Array(ctx.getImageData(0, 0, 1, 1).data.buffer)[0] === 0;\n    });\n    return (0, _util.shadow)(this, \"_isSVGFittingCanvas\", promise);\n  }\n  async #get(key, rawData) {\n    this.#cache ||= new Map();\n    let data = this.#cache.get(key);\n    if (data === null) {\n      return null;\n    }\n    if (data?.bitmap) {\n      data.refCounter += 1;\n      return data;\n    }\n    try {\n      data ||= {\n        bitmap: null,\n        id: `image_${this.#baseId}_${this.#id++}`,\n        refCounter: 0,\n        isSvg: false\n      };\n      let image;\n      if (typeof rawData === \"string\") {\n        data.url = rawData;\n        const response = await fetch(rawData);\n        if (!response.ok) {\n          throw new Error(response.statusText);\n        }\n        image = await response.blob();\n      } else {\n        image = data.file = rawData;\n      }\n      if (image.type === \"image/svg+xml\") {\n        const mustRemoveAspectRatioPromise = ImageManager._isSVGFittingCanvas;\n        const fileReader = new FileReader();\n        const imageElement = new Image();\n        const imagePromise = new Promise((resolve, reject) => {\n          imageElement.onload = () => {\n            data.bitmap = imageElement;\n            data.isSvg = true;\n            resolve();\n          };\n          fileReader.onload = async () => {\n            const url = data.svgUrl = fileReader.result;\n            imageElement.src = (await mustRemoveAspectRatioPromise) ? `${url}#svgView(preserveAspectRatio(none))` : url;\n          };\n          imageElement.onerror = fileReader.onerror = reject;\n        });\n        fileReader.readAsDataURL(image);\n        await imagePromise;\n      } else {\n        data.bitmap = await createImageBitmap(image);\n      }\n      data.refCounter = 1;\n    } catch (e) {\n      console.error(e);\n      data = null;\n    }\n    this.#cache.set(key, data);\n    if (data) {\n      this.#cache.set(data.id, data);\n    }\n    return data;\n  }\n  async getFromFile(file) {\n    const {\n      lastModified,\n      name,\n      size,\n      type\n    } = file;\n    return this.#get(`${lastModified}_${name}_${size}_${type}`, file);\n  }\n  async getFromUrl(url) {\n    return this.#get(url, url);\n  }\n  async getFromId(id) {\n    this.#cache ||= new Map();\n    const data = this.#cache.get(id);\n    if (!data) {\n      return null;\n    }\n    if (data.bitmap) {\n      data.refCounter += 1;\n      return data;\n    }\n    if (data.file) {\n      return this.getFromFile(data.file);\n    }\n    return this.getFromUrl(data.url);\n  }\n  getSvgUrl(id) {\n    const data = this.#cache.get(id);\n    if (!data?.isSvg) {\n      return null;\n    }\n    return data.svgUrl;\n  }\n  deleteId(id) {\n    this.#cache ||= new Map();\n    const data = this.#cache.get(id);\n    if (!data) {\n      return;\n    }\n    data.refCounter -= 1;\n    if (data.refCounter !== 0) {\n      return;\n    }\n    data.bitmap = null;\n  }\n  isValidId(id) {\n    return id.startsWith(`image_${this.#baseId}_`);\n  }\n}\nclass CommandManager {\n  #commands = [];\n  #locked = false;\n  #maxSize;\n  #position = -1;\n  constructor(maxSize = 128) {\n    this.#maxSize = maxSize;\n  }\n  add({\n    cmd,\n    undo,\n    mustExec,\n    type = NaN,\n    overwriteIfSameType = false,\n    keepUndo = false\n  }) {\n    if (mustExec) {\n      cmd();\n    }\n    if (this.#locked) {\n      return;\n    }\n    const save = {\n      cmd,\n      undo,\n      type\n    };\n    if (this.#position === -1) {\n      if (this.#commands.length > 0) {\n        this.#commands.length = 0;\n      }\n      this.#position = 0;\n      this.#commands.push(save);\n      return;\n    }\n    if (overwriteIfSameType && this.#commands[this.#position].type === type) {\n      if (keepUndo) {\n        save.undo = this.#commands[this.#position].undo;\n      }\n      this.#commands[this.#position] = save;\n      return;\n    }\n    const next = this.#position + 1;\n    if (next === this.#maxSize) {\n      this.#commands.splice(0, 1);\n    } else {\n      this.#position = next;\n      if (next < this.#commands.length) {\n        this.#commands.splice(next);\n      }\n    }\n    this.#commands.push(save);\n  }\n  undo() {\n    if (this.#position === -1) {\n      return;\n    }\n    this.#locked = true;\n    this.#commands[this.#position].undo();\n    this.#locked = false;\n    this.#position -= 1;\n  }\n  redo() {\n    if (this.#position < this.#commands.length - 1) {\n      this.#position += 1;\n      this.#locked = true;\n      this.#commands[this.#position].cmd();\n      this.#locked = false;\n    }\n  }\n  hasSomethingToUndo() {\n    return this.#position !== -1;\n  }\n  hasSomethingToRedo() {\n    return this.#position < this.#commands.length - 1;\n  }\n  destroy() {\n    this.#commands = null;\n  }\n}\nexports.CommandManager = CommandManager;\nclass KeyboardManager {\n  constructor(callbacks) {\n    this.buffer = [];\n    this.callbacks = new Map();\n    this.allKeys = new Set();\n    const {\n      isMac\n    } = _util.FeatureTest.platform;\n    for (const [keys, callback, options = {}] of callbacks) {\n      for (const key of keys) {\n        const isMacKey = key.startsWith(\"mac+\");\n        if (isMac && isMacKey) {\n          this.callbacks.set(key.slice(4), {\n            callback,\n            options\n          });\n          this.allKeys.add(key.split(\"+\").at(-1));\n        } else if (!isMac && !isMacKey) {\n          this.callbacks.set(key, {\n            callback,\n            options\n          });\n          this.allKeys.add(key.split(\"+\").at(-1));\n        }\n      }\n    }\n  }\n  #serialize(event) {\n    if (event.altKey) {\n      this.buffer.push(\"alt\");\n    }\n    if (event.ctrlKey) {\n      this.buffer.push(\"ctrl\");\n    }\n    if (event.metaKey) {\n      this.buffer.push(\"meta\");\n    }\n    if (event.shiftKey) {\n      this.buffer.push(\"shift\");\n    }\n    this.buffer.push(event.key);\n    const str = this.buffer.join(\"+\");\n    this.buffer.length = 0;\n    return str;\n  }\n  exec(self, event) {\n    if (!this.allKeys.has(event.key)) {\n      return;\n    }\n    const info = this.callbacks.get(this.#serialize(event));\n    if (!info) {\n      return;\n    }\n    const {\n      callback,\n      options: {\n        bubbles = false,\n        args = [],\n        checker = null\n      }\n    } = info;\n    if (checker && !checker(self, event)) {\n      return;\n    }\n    callback.bind(self, ...args)();\n    if (!bubbles) {\n      event.stopPropagation();\n      event.preventDefault();\n    }\n  }\n}\nexports.KeyboardManager = KeyboardManager;\nclass ColorManager {\n  static _colorsMapping = new Map([[\"CanvasText\", [0, 0, 0]], [\"Canvas\", [255, 255, 255]]]);\n  get _colors() {\n    const colors = new Map([[\"CanvasText\", null], [\"Canvas\", null]]);\n    (0, _display_utils.getColorValues)(colors);\n    return (0, _util.shadow)(this, \"_colors\", colors);\n  }\n  convert(color) {\n    const rgb = (0, _display_utils.getRGB)(color);\n    if (!window.matchMedia(\"(forced-colors: active)\").matches) {\n      return rgb;\n    }\n    for (const [name, RGB] of this._colors) {\n      if (RGB.every((x, i) => x === rgb[i])) {\n        return ColorManager._colorsMapping.get(name);\n      }\n    }\n    return rgb;\n  }\n  getHexCode(name) {\n    const rgb = this._colors.get(name);\n    if (!rgb) {\n      return name;\n    }\n    return _util.Util.makeHexColor(...rgb);\n  }\n}\nexports.ColorManager = ColorManager;\nclass AnnotationEditorUIManager {\n  #activeEditor = null;\n  #allEditors = new Map();\n  #allLayers = new Map();\n  #altTextManager = null;\n  #annotationStorage = null;\n  #commandManager = new CommandManager();\n  #currentPageIndex = 0;\n  #deletedAnnotationsElementIds = new Set();\n  #draggingEditors = null;\n  #editorTypes = null;\n  #editorsToRescale = new Set();\n  #filterFactory = null;\n  #idManager = new IdManager();\n  #isEnabled = false;\n  #isWaiting = false;\n  #lastActiveElement = null;\n  #mode = _util.AnnotationEditorType.NONE;\n  #selectedEditors = new Set();\n  #pageColors = null;\n  #boundBlur = this.blur.bind(this);\n  #boundFocus = this.focus.bind(this);\n  #boundCopy = this.copy.bind(this);\n  #boundCut = this.cut.bind(this);\n  #boundPaste = this.paste.bind(this);\n  #boundKeydown = this.keydown.bind(this);\n  #boundOnEditingAction = this.onEditingAction.bind(this);\n  #boundOnPageChanging = this.onPageChanging.bind(this);\n  #boundOnScaleChanging = this.onScaleChanging.bind(this);\n  #boundOnRotationChanging = this.onRotationChanging.bind(this);\n  #previousStates = {\n    isEditing: false,\n    isEmpty: true,\n    hasSomethingToUndo: false,\n    hasSomethingToRedo: false,\n    hasSelectedEditor: false\n  };\n  #translation = [0, 0];\n  #translationTimeoutId = null;\n  #container = null;\n  #viewer = null;\n  static TRANSLATE_SMALL = 1;\n  static TRANSLATE_BIG = 10;\n  static get _keyboardManager() {\n    const proto = AnnotationEditorUIManager.prototype;\n    const arrowChecker = self => {\n      const {\n        activeElement\n      } = document;\n      return activeElement && self.#container.contains(activeElement) && self.hasSomethingToControl();\n    };\n    const small = this.TRANSLATE_SMALL;\n    const big = this.TRANSLATE_BIG;\n    return (0, _util.shadow)(this, \"_keyboardManager\", new KeyboardManager([[[\"ctrl+a\", \"mac+meta+a\"], proto.selectAll], [[\"ctrl+z\", \"mac+meta+z\"], proto.undo], [[\"ctrl+y\", \"ctrl+shift+z\", \"mac+meta+shift+z\", \"ctrl+shift+Z\", \"mac+meta+shift+Z\"], proto.redo], [[\"Backspace\", \"alt+Backspace\", \"ctrl+Backspace\", \"shift+Backspace\", \"mac+Backspace\", \"mac+alt+Backspace\", \"mac+ctrl+Backspace\", \"Delete\", \"ctrl+Delete\", \"shift+Delete\", \"mac+Delete\"], proto.delete], [[\"Escape\", \"mac+Escape\"], proto.unselectAll], [[\"ArrowLeft\", \"mac+ArrowLeft\"], proto.translateSelectedEditors, {\n      args: [-small, 0],\n      checker: arrowChecker\n    }], [[\"ctrl+ArrowLeft\", \"mac+shift+ArrowLeft\"], proto.translateSelectedEditors, {\n      args: [-big, 0],\n      checker: arrowChecker\n    }], [[\"ArrowRight\", \"mac+ArrowRight\"], proto.translateSelectedEditors, {\n      args: [small, 0],\n      checker: arrowChecker\n    }], [[\"ctrl+ArrowRight\", \"mac+shift+ArrowRight\"], proto.translateSelectedEditors, {\n      args: [big, 0],\n      checker: arrowChecker\n    }], [[\"ArrowUp\", \"mac+ArrowUp\"], proto.translateSelectedEditors, {\n      args: [0, -small],\n      checker: arrowChecker\n    }], [[\"ctrl+ArrowUp\", \"mac+shift+ArrowUp\"], proto.translateSelectedEditors, {\n      args: [0, -big],\n      checker: arrowChecker\n    }], [[\"ArrowDown\", \"mac+ArrowDown\"], proto.translateSelectedEditors, {\n      args: [0, small],\n      checker: arrowChecker\n    }], [[\"ctrl+ArrowDown\", \"mac+shift+ArrowDown\"], proto.translateSelectedEditors, {\n      args: [0, big],\n      checker: arrowChecker\n    }]]));\n  }\n  constructor(container, viewer, altTextManager, eventBus, pdfDocument, pageColors) {\n    this.#container = container;\n    this.#viewer = viewer;\n    this.#altTextManager = altTextManager;\n    this._eventBus = eventBus;\n    this._eventBus._on(\"editingaction\", this.#boundOnEditingAction);\n    this._eventBus._on(\"pagechanging\", this.#boundOnPageChanging);\n    this._eventBus._on(\"scalechanging\", this.#boundOnScaleChanging);\n    this._eventBus._on(\"rotationchanging\", this.#boundOnRotationChanging);\n    this.#annotationStorage = pdfDocument.annotationStorage;\n    this.#filterFactory = pdfDocument.filterFactory;\n    this.#pageColors = pageColors;\n    this.viewParameters = {\n      realScale: _display_utils.PixelsPerInch.PDF_TO_CSS_UNITS,\n      rotation: 0\n    };\n  }\n  destroy() {\n    this.#removeKeyboardManager();\n    this.#removeFocusManager();\n    this._eventBus._off(\"editingaction\", this.#boundOnEditingAction);\n    this._eventBus._off(\"pagechanging\", this.#boundOnPageChanging);\n    this._eventBus._off(\"scalechanging\", this.#boundOnScaleChanging);\n    this._eventBus._off(\"rotationchanging\", this.#boundOnRotationChanging);\n    for (const layer of this.#allLayers.values()) {\n      layer.destroy();\n    }\n    this.#allLayers.clear();\n    this.#allEditors.clear();\n    this.#editorsToRescale.clear();\n    this.#activeEditor = null;\n    this.#selectedEditors.clear();\n    this.#commandManager.destroy();\n    this.#altTextManager.destroy();\n  }\n  get hcmFilter() {\n    return (0, _util.shadow)(this, \"hcmFilter\", this.#pageColors ? this.#filterFactory.addHCMFilter(this.#pageColors.foreground, this.#pageColors.background) : \"none\");\n  }\n  get direction() {\n    return (0, _util.shadow)(this, \"direction\", getComputedStyle(this.#container).direction);\n  }\n  editAltText(editor) {\n    this.#altTextManager?.editAltText(this, editor);\n  }\n  onPageChanging({\n    pageNumber\n  }) {\n    this.#currentPageIndex = pageNumber - 1;\n  }\n  focusMainContainer() {\n    this.#container.focus();\n  }\n  findParent(x, y) {\n    for (const layer of this.#allLayers.values()) {\n      const {\n        x: layerX,\n        y: layerY,\n        width,\n        height\n      } = layer.div.getBoundingClientRect();\n      if (x >= layerX && x <= layerX + width && y >= layerY && y <= layerY + height) {\n        return layer;\n      }\n    }\n    return null;\n  }\n  disableUserSelect(value = false) {\n    this.#viewer.classList.toggle(\"noUserSelect\", value);\n  }\n  addShouldRescale(editor) {\n    this.#editorsToRescale.add(editor);\n  }\n  removeShouldRescale(editor) {\n    this.#editorsToRescale.delete(editor);\n  }\n  onScaleChanging({\n    scale\n  }) {\n    this.commitOrRemove();\n    this.viewParameters.realScale = scale * _display_utils.PixelsPerInch.PDF_TO_CSS_UNITS;\n    for (const editor of this.#editorsToRescale) {\n      editor.onScaleChanging();\n    }\n  }\n  onRotationChanging({\n    pagesRotation\n  }) {\n    this.commitOrRemove();\n    this.viewParameters.rotation = pagesRotation;\n  }\n  addToAnnotationStorage(editor) {\n    if (!editor.isEmpty() && this.#annotationStorage && !this.#annotationStorage.has(editor.id)) {\n      this.#annotationStorage.setValue(editor.id, editor);\n    }\n  }\n  #addFocusManager() {\n    window.addEventListener(\"focus\", this.#boundFocus);\n    window.addEventListener(\"blur\", this.#boundBlur);\n  }\n  #removeFocusManager() {\n    window.removeEventListener(\"focus\", this.#boundFocus);\n    window.removeEventListener(\"blur\", this.#boundBlur);\n  }\n  blur() {\n    if (!this.hasSelection) {\n      return;\n    }\n    const {\n      activeElement\n    } = document;\n    for (const editor of this.#selectedEditors) {\n      if (editor.div.contains(activeElement)) {\n        this.#lastActiveElement = [editor, activeElement];\n        editor._focusEventsAllowed = false;\n        break;\n      }\n    }\n  }\n  focus() {\n    if (!this.#lastActiveElement) {\n      return;\n    }\n    const [lastEditor, lastActiveElement] = this.#lastActiveElement;\n    this.#lastActiveElement = null;\n    lastActiveElement.addEventListener(\"focusin\", () => {\n      lastEditor._focusEventsAllowed = true;\n    }, {\n      once: true\n    });\n    lastActiveElement.focus();\n  }\n  #addKeyboardManager() {\n    window.addEventListener(\"keydown\", this.#boundKeydown, {\n      capture: true\n    });\n  }\n  #removeKeyboardManager() {\n    window.removeEventListener(\"keydown\", this.#boundKeydown, {\n      capture: true\n    });\n  }\n  #addCopyPasteListeners() {\n    document.addEventListener(\"copy\", this.#boundCopy);\n    document.addEventListener(\"cut\", this.#boundCut);\n    document.addEventListener(\"paste\", this.#boundPaste);\n  }\n  #removeCopyPasteListeners() {\n    document.removeEventListener(\"copy\", this.#boundCopy);\n    document.removeEventListener(\"cut\", this.#boundCut);\n    document.removeEventListener(\"paste\", this.#boundPaste);\n  }\n  addEditListeners() {\n    this.#addKeyboardManager();\n    this.#addCopyPasteListeners();\n  }\n  removeEditListeners() {\n    this.#removeKeyboardManager();\n    this.#removeCopyPasteListeners();\n  }\n  copy(event) {\n    event.preventDefault();\n    this.#activeEditor?.commitOrRemove();\n    if (!this.hasSelection) {\n      return;\n    }\n    const editors = [];\n    for (const editor of this.#selectedEditors) {\n      const serialized = editor.serialize(true);\n      if (serialized) {\n        editors.push(serialized);\n      }\n    }\n    if (editors.length === 0) {\n      return;\n    }\n    event.clipboardData.setData(\"application/pdfjs\", JSON.stringify(editors));\n  }\n  cut(event) {\n    this.copy(event);\n    this.delete();\n  }\n  paste(event) {\n    event.preventDefault();\n    const {\n      clipboardData\n    } = event;\n    for (const item of clipboardData.items) {\n      for (const editorType of this.#editorTypes) {\n        if (editorType.isHandlingMimeForPasting(item.type)) {\n          editorType.paste(item, this.currentLayer);\n          return;\n        }\n      }\n    }\n    let data = clipboardData.getData(\"application/pdfjs\");\n    if (!data) {\n      return;\n    }\n    try {\n      data = JSON.parse(data);\n    } catch (ex) {\n      (0, _util.warn)(`paste: \"${ex.message}\".`);\n      return;\n    }\n    if (!Array.isArray(data)) {\n      return;\n    }\n    this.unselectAll();\n    const layer = this.currentLayer;\n    try {\n      const newEditors = [];\n      for (const editor of data) {\n        const deserializedEditor = layer.deserialize(editor);\n        if (!deserializedEditor) {\n          return;\n        }\n        newEditors.push(deserializedEditor);\n      }\n      const cmd = () => {\n        for (const editor of newEditors) {\n          this.#addEditorToLayer(editor);\n        }\n        this.#selectEditors(newEditors);\n      };\n      const undo = () => {\n        for (const editor of newEditors) {\n          editor.remove();\n        }\n      };\n      this.addCommands({\n        cmd,\n        undo,\n        mustExec: true\n      });\n    } catch (ex) {\n      (0, _util.warn)(`paste: \"${ex.message}\".`);\n    }\n  }\n  keydown(event) {\n    if (!this.getActive()?.shouldGetKeyboardEvents()) {\n      AnnotationEditorUIManager._keyboardManager.exec(this, event);\n    }\n  }\n  onEditingAction(details) {\n    if ([\"undo\", \"redo\", \"delete\", \"selectAll\"].includes(details.name)) {\n      this[details.name]();\n    }\n  }\n  #dispatchUpdateStates(details) {\n    const hasChanged = Object.entries(details).some(([key, value]) => this.#previousStates[key] !== value);\n    if (hasChanged) {\n      this._eventBus.dispatch(\"annotationeditorstateschanged\", {\n        source: this,\n        details: Object.assign(this.#previousStates, details)\n      });\n    }\n  }\n  #dispatchUpdateUI(details) {\n    this._eventBus.dispatch(\"annotationeditorparamschanged\", {\n      source: this,\n      details\n    });\n  }\n  setEditingState(isEditing) {\n    if (isEditing) {\n      this.#addFocusManager();\n      this.#addKeyboardManager();\n      this.#addCopyPasteListeners();\n      this.#dispatchUpdateStates({\n        isEditing: this.#mode !== _util.AnnotationEditorType.NONE,\n        isEmpty: this.#isEmpty(),\n        hasSomethingToUndo: this.#commandManager.hasSomethingToUndo(),\n        hasSomethingToRedo: this.#commandManager.hasSomethingToRedo(),\n        hasSelectedEditor: false\n      });\n    } else {\n      this.#removeFocusManager();\n      this.#removeKeyboardManager();\n      this.#removeCopyPasteListeners();\n      this.#dispatchUpdateStates({\n        isEditing: false\n      });\n      this.disableUserSelect(false);\n    }\n  }\n  registerEditorTypes(types) {\n    if (this.#editorTypes) {\n      return;\n    }\n    this.#editorTypes = types;\n    for (const editorType of this.#editorTypes) {\n      this.#dispatchUpdateUI(editorType.defaultPropertiesToUpdate);\n    }\n  }\n  getId() {\n    return this.#idManager.getId();\n  }\n  get currentLayer() {\n    return this.#allLayers.get(this.#currentPageIndex);\n  }\n  getLayer(pageIndex) {\n    return this.#allLayers.get(pageIndex);\n  }\n  get currentPageIndex() {\n    return this.#currentPageIndex;\n  }\n  addLayer(layer) {\n    this.#allLayers.set(layer.pageIndex, layer);\n    if (this.#isEnabled) {\n      layer.enable();\n    } else {\n      layer.disable();\n    }\n  }\n  removeLayer(layer) {\n    this.#allLayers.delete(layer.pageIndex);\n  }\n  updateMode(mode, editId = null) {\n    if (this.#mode === mode) {\n      return;\n    }\n    this.#mode = mode;\n    if (mode === _util.AnnotationEditorType.NONE) {\n      this.setEditingState(false);\n      this.#disableAll();\n      return;\n    }\n    this.setEditingState(true);\n    this.#enableAll();\n    this.unselectAll();\n    for (const layer of this.#allLayers.values()) {\n      layer.updateMode(mode);\n    }\n    if (!editId) {\n      return;\n    }\n    for (const editor of this.#allEditors.values()) {\n      if (editor.annotationElementId === editId) {\n        this.setSelected(editor);\n        editor.enterInEditMode();\n        break;\n      }\n    }\n  }\n  updateToolbar(mode) {\n    if (mode === this.#mode) {\n      return;\n    }\n    this._eventBus.dispatch(\"switchannotationeditormode\", {\n      source: this,\n      mode\n    });\n  }\n  updateParams(type, value) {\n    if (!this.#editorTypes) {\n      return;\n    }\n    if (type === _util.AnnotationEditorParamsType.CREATE) {\n      this.currentLayer.addNewEditor(type);\n      return;\n    }\n    for (const editor of this.#selectedEditors) {\n      editor.updateParams(type, value);\n    }\n    for (const editorType of this.#editorTypes) {\n      editorType.updateDefaultParams(type, value);\n    }\n  }\n  enableWaiting(mustWait = false) {\n    if (this.#isWaiting === mustWait) {\n      return;\n    }\n    this.#isWaiting = mustWait;\n    for (const layer of this.#allLayers.values()) {\n      if (mustWait) {\n        layer.disableClick();\n      } else {\n        layer.enableClick();\n      }\n      layer.div.classList.toggle(\"waiting\", mustWait);\n    }\n  }\n  #enableAll() {\n    if (!this.#isEnabled) {\n      this.#isEnabled = true;\n      for (const layer of this.#allLayers.values()) {\n        layer.enable();\n      }\n    }\n  }\n  #disableAll() {\n    this.unselectAll();\n    if (this.#isEnabled) {\n      this.#isEnabled = false;\n      for (const layer of this.#allLayers.values()) {\n        layer.disable();\n      }\n    }\n  }\n  getEditors(pageIndex) {\n    const editors = [];\n    for (const editor of this.#allEditors.values()) {\n      if (editor.pageIndex === pageIndex) {\n        editors.push(editor);\n      }\n    }\n    return editors;\n  }\n  getEditor(id) {\n    return this.#allEditors.get(id);\n  }\n  addEditor(editor) {\n    this.#allEditors.set(editor.id, editor);\n  }\n  removeEditor(editor) {\n    this.#allEditors.delete(editor.id);\n    this.unselect(editor);\n    if (!editor.annotationElementId || !this.#deletedAnnotationsElementIds.has(editor.annotationElementId)) {\n      this.#annotationStorage?.remove(editor.id);\n    }\n  }\n  addDeletedAnnotationElement(editor) {\n    this.#deletedAnnotationsElementIds.add(editor.annotationElementId);\n    editor.deleted = true;\n  }\n  isDeletedAnnotationElement(annotationElementId) {\n    return this.#deletedAnnotationsElementIds.has(annotationElementId);\n  }\n  removeDeletedAnnotationElement(editor) {\n    this.#deletedAnnotationsElementIds.delete(editor.annotationElementId);\n    editor.deleted = false;\n  }\n  #addEditorToLayer(editor) {\n    const layer = this.#allLayers.get(editor.pageIndex);\n    if (layer) {\n      layer.addOrRebuild(editor);\n    } else {\n      this.addEditor(editor);\n    }\n  }\n  setActiveEditor(editor) {\n    if (this.#activeEditor === editor) {\n      return;\n    }\n    this.#activeEditor = editor;\n    if (editor) {\n      this.#dispatchUpdateUI(editor.propertiesToUpdate);\n    }\n  }\n  toggleSelected(editor) {\n    if (this.#selectedEditors.has(editor)) {\n      this.#selectedEditors.delete(editor);\n      editor.unselect();\n      this.#dispatchUpdateStates({\n        hasSelectedEditor: this.hasSelection\n      });\n      return;\n    }\n    this.#selectedEditors.add(editor);\n    editor.select();\n    this.#dispatchUpdateUI(editor.propertiesToUpdate);\n    this.#dispatchUpdateStates({\n      hasSelectedEditor: true\n    });\n  }\n  setSelected(editor) {\n    for (const ed of this.#selectedEditors) {\n      if (ed !== editor) {\n        ed.unselect();\n      }\n    }\n    this.#selectedEditors.clear();\n    this.#selectedEditors.add(editor);\n    editor.select();\n    this.#dispatchUpdateUI(editor.propertiesToUpdate);\n    this.#dispatchUpdateStates({\n      hasSelectedEditor: true\n    });\n  }\n  isSelected(editor) {\n    return this.#selectedEditors.has(editor);\n  }\n  unselect(editor) {\n    editor.unselect();\n    this.#selectedEditors.delete(editor);\n    this.#dispatchUpdateStates({\n      hasSelectedEditor: this.hasSelection\n    });\n  }\n  get hasSelection() {\n    return this.#selectedEditors.size !== 0;\n  }\n  undo() {\n    this.#commandManager.undo();\n    this.#dispatchUpdateStates({\n      hasSomethingToUndo: this.#commandManager.hasSomethingToUndo(),\n      hasSomethingToRedo: true,\n      isEmpty: this.#isEmpty()\n    });\n  }\n  redo() {\n    this.#commandManager.redo();\n    this.#dispatchUpdateStates({\n      hasSomethingToUndo: true,\n      hasSomethingToRedo: this.#commandManager.hasSomethingToRedo(),\n      isEmpty: this.#isEmpty()\n    });\n  }\n  addCommands(params) {\n    this.#commandManager.add(params);\n    this.#dispatchUpdateStates({\n      hasSomethingToUndo: true,\n      hasSomethingToRedo: false,\n      isEmpty: this.#isEmpty()\n    });\n  }\n  #isEmpty() {\n    if (this.#allEditors.size === 0) {\n      return true;\n    }\n    if (this.#allEditors.size === 1) {\n      for (const editor of this.#allEditors.values()) {\n        return editor.isEmpty();\n      }\n    }\n    return false;\n  }\n  delete() {\n    this.commitOrRemove();\n    if (!this.hasSelection) {\n      return;\n    }\n    const editors = [...this.#selectedEditors];\n    const cmd = () => {\n      for (const editor of editors) {\n        editor.remove();\n      }\n    };\n    const undo = () => {\n      for (const editor of editors) {\n        this.#addEditorToLayer(editor);\n      }\n    };\n    this.addCommands({\n      cmd,\n      undo,\n      mustExec: true\n    });\n  }\n  commitOrRemove() {\n    this.#activeEditor?.commitOrRemove();\n  }\n  hasSomethingToControl() {\n    return this.#activeEditor || this.hasSelection;\n  }\n  #selectEditors(editors) {\n    this.#selectedEditors.clear();\n    for (const editor of editors) {\n      if (editor.isEmpty()) {\n        continue;\n      }\n      this.#selectedEditors.add(editor);\n      editor.select();\n    }\n    this.#dispatchUpdateStates({\n      hasSelectedEditor: true\n    });\n  }\n  selectAll() {\n    for (const editor of this.#selectedEditors) {\n      editor.commit();\n    }\n    this.#selectEditors(this.#allEditors.values());\n  }\n  unselectAll() {\n    if (this.#activeEditor) {\n      this.#activeEditor.commitOrRemove();\n      return;\n    }\n    if (!this.hasSelection) {\n      return;\n    }\n    for (const editor of this.#selectedEditors) {\n      editor.unselect();\n    }\n    this.#selectedEditors.clear();\n    this.#dispatchUpdateStates({\n      hasSelectedEditor: false\n    });\n  }\n  translateSelectedEditors(x, y, noCommit = false) {\n    if (!noCommit) {\n      this.commitOrRemove();\n    }\n    if (!this.hasSelection) {\n      return;\n    }\n    this.#translation[0] += x;\n    this.#translation[1] += y;\n    const [totalX, totalY] = this.#translation;\n    const editors = [...this.#selectedEditors];\n    const TIME_TO_WAIT = 1000;\n    if (this.#translationTimeoutId) {\n      clearTimeout(this.#translationTimeoutId);\n    }\n    this.#translationTimeoutId = setTimeout(() => {\n      this.#translationTimeoutId = null;\n      this.#translation[0] = this.#translation[1] = 0;\n      this.addCommands({\n        cmd: () => {\n          for (const editor of editors) {\n            if (this.#allEditors.has(editor.id)) {\n              editor.translateInPage(totalX, totalY);\n            }\n          }\n        },\n        undo: () => {\n          for (const editor of editors) {\n            if (this.#allEditors.has(editor.id)) {\n              editor.translateInPage(-totalX, -totalY);\n            }\n          }\n        },\n        mustExec: false\n      });\n    }, TIME_TO_WAIT);\n    for (const editor of editors) {\n      editor.translateInPage(x, y);\n    }\n  }\n  setUpDragSession() {\n    if (!this.hasSelection) {\n      return;\n    }\n    this.disableUserSelect(true);\n    this.#draggingEditors = new Map();\n    for (const editor of this.#selectedEditors) {\n      this.#draggingEditors.set(editor, {\n        savedX: editor.x,\n        savedY: editor.y,\n        savedPageIndex: editor.pageIndex,\n        newX: 0,\n        newY: 0,\n        newPageIndex: -1\n      });\n    }\n  }\n  endDragSession() {\n    if (!this.#draggingEditors) {\n      return false;\n    }\n    this.disableUserSelect(false);\n    const map = this.#draggingEditors;\n    this.#draggingEditors = null;\n    let mustBeAddedInUndoStack = false;\n    for (const [{\n      x,\n      y,\n      pageIndex\n    }, value] of map) {\n      value.newX = x;\n      value.newY = y;\n      value.newPageIndex = pageIndex;\n      mustBeAddedInUndoStack ||= x !== value.savedX || y !== value.savedY || pageIndex !== value.savedPageIndex;\n    }\n    if (!mustBeAddedInUndoStack) {\n      return false;\n    }\n    const move = (editor, x, y, pageIndex) => {\n      if (this.#allEditors.has(editor.id)) {\n        const parent = this.#allLayers.get(pageIndex);\n        if (parent) {\n          editor._setParentAndPosition(parent, x, y);\n        } else {\n          editor.pageIndex = pageIndex;\n          editor.x = x;\n          editor.y = y;\n        }\n      }\n    };\n    this.addCommands({\n      cmd: () => {\n        for (const [editor, {\n          newX,\n          newY,\n          newPageIndex\n        }] of map) {\n          move(editor, newX, newY, newPageIndex);\n        }\n      },\n      undo: () => {\n        for (const [editor, {\n          savedX,\n          savedY,\n          savedPageIndex\n        }] of map) {\n          move(editor, savedX, savedY, savedPageIndex);\n        }\n      },\n      mustExec: true\n    });\n    return true;\n  }\n  dragSelectedEditors(tx, ty) {\n    if (!this.#draggingEditors) {\n      return;\n    }\n    for (const editor of this.#draggingEditors.keys()) {\n      editor.drag(tx, ty);\n    }\n  }\n  rebuild(editor) {\n    if (editor.parent === null) {\n      const parent = this.getLayer(editor.pageIndex);\n      if (parent) {\n        parent.changeParent(editor);\n        parent.addOrRebuild(editor);\n      } else {\n        this.addEditor(editor);\n        this.addToAnnotationStorage(editor);\n        editor.rebuild();\n      }\n    } else {\n      editor.parent.addOrRebuild(editor);\n    }\n  }\n  isActive(editor) {\n    return this.#activeEditor === editor;\n  }\n  getActive() {\n    return this.#activeEditor;\n  }\n  getMode() {\n    return this.#mode;\n  }\n  get imageManager() {\n    return (0, _util.shadow)(this, \"imageManager\", new ImageManager());\n  }\n}\nexports.AnnotationEditorUIManager = AnnotationEditorUIManager;\n\n/***/ }),\n/* 6 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.StatTimer = exports.RenderingCancelledException = exports.PixelsPerInch = exports.PageViewport = exports.PDFDateString = exports.DOMStandardFontDataFactory = exports.DOMSVGFactory = exports.DOMFilterFactory = exports.DOMCanvasFactory = exports.DOMCMapReaderFactory = void 0;\nexports.deprecated = deprecated;\nexports.getColorValues = getColorValues;\nexports.getCurrentTransform = getCurrentTransform;\nexports.getCurrentTransformInverse = getCurrentTransformInverse;\nexports.getFilenameFromUrl = getFilenameFromUrl;\nexports.getPdfFilenameFromUrl = getPdfFilenameFromUrl;\nexports.getRGB = getRGB;\nexports.getXfaPageViewport = getXfaPageViewport;\nexports.isDataScheme = isDataScheme;\nexports.isPdfFile = isPdfFile;\nexports.isValidFetchUrl = isValidFetchUrl;\nexports.loadScript = loadScript;\nexports.noContextMenu = noContextMenu;\nexports.setLayerDimensions = setLayerDimensions;\nvar _base_factory = __w_pdfjs_require__(7);\nvar _util = __w_pdfjs_require__(1);\nconst SVG_NS = \"http://www.w3.org/2000/svg\";\nclass PixelsPerInch {\n  static CSS = 96.0;\n  static PDF = 72.0;\n  static PDF_TO_CSS_UNITS = this.CSS / this.PDF;\n}\nexports.PixelsPerInch = PixelsPerInch;\nclass DOMFilterFactory extends _base_factory.BaseFilterFactory {\n  #_cache;\n  #_defs;\n  #docId;\n  #document;\n  #hcmFilter;\n  #hcmKey;\n  #hcmUrl;\n  #hcmHighlightFilter;\n  #hcmHighlightKey;\n  #hcmHighlightUrl;\n  #id = 0;\n  constructor({\n    docId,\n    ownerDocument = globalThis.document\n  } = {}) {\n    super();\n    this.#docId = docId;\n    this.#document = ownerDocument;\n  }\n  get #cache() {\n    return this.#_cache ||= new Map();\n  }\n  get #defs() {\n    if (!this.#_defs) {\n      const div = this.#document.createElement(\"div\");\n      const {\n        style\n      } = div;\n      style.visibility = \"hidden\";\n      style.contain = \"strict\";\n      style.width = style.height = 0;\n      style.position = \"absolute\";\n      style.top = style.left = 0;\n      style.zIndex = -1;\n      const svg = this.#document.createElementNS(SVG_NS, \"svg\");\n      svg.setAttribute(\"width\", 0);\n      svg.setAttribute(\"height\", 0);\n      this.#_defs = this.#document.createElementNS(SVG_NS, \"defs\");\n      div.append(svg);\n      svg.append(this.#_defs);\n      this.#document.body.append(div);\n    }\n    return this.#_defs;\n  }\n  addFilter(maps) {\n    if (!maps) {\n      return \"none\";\n    }\n    let value = this.#cache.get(maps);\n    if (value) {\n      return value;\n    }\n    let tableR, tableG, tableB, key;\n    if (maps.length === 1) {\n      const mapR = maps[0];\n      const buffer = new Array(256);\n      for (let i = 0; i < 256; i++) {\n        buffer[i] = mapR[i] / 255;\n      }\n      key = tableR = tableG = tableB = buffer.join(\",\");\n    } else {\n      const [mapR, mapG, mapB] = maps;\n      const bufferR = new Array(256);\n      const bufferG = new Array(256);\n      const bufferB = new Array(256);\n      for (let i = 0; i < 256; i++) {\n        bufferR[i] = mapR[i] / 255;\n        bufferG[i] = mapG[i] / 255;\n        bufferB[i] = mapB[i] / 255;\n      }\n      tableR = bufferR.join(\",\");\n      tableG = bufferG.join(\",\");\n      tableB = bufferB.join(\",\");\n      key = `${tableR}${tableG}${tableB}`;\n    }\n    value = this.#cache.get(key);\n    if (value) {\n      this.#cache.set(maps, value);\n      return value;\n    }\n    const id = `g_${this.#docId}_transfer_map_${this.#id++}`;\n    const url = `url(#${id})`;\n    this.#cache.set(maps, url);\n    this.#cache.set(key, url);\n    const filter = this.#createFilter(id);\n    this.#addTransferMapConversion(tableR, tableG, tableB, filter);\n    return url;\n  }\n  addHCMFilter(fgColor, bgColor) {\n    const key = `${fgColor}-${bgColor}`;\n    if (this.#hcmKey === key) {\n      return this.#hcmUrl;\n    }\n    this.#hcmKey = key;\n    this.#hcmUrl = \"none\";\n    this.#hcmFilter?.remove();\n    if (!fgColor || !bgColor) {\n      return this.#hcmUrl;\n    }\n    const fgRGB = this.#getRGB(fgColor);\n    fgColor = _util.Util.makeHexColor(...fgRGB);\n    const bgRGB = this.#getRGB(bgColor);\n    bgColor = _util.Util.makeHexColor(...bgRGB);\n    this.#defs.style.color = \"\";\n    if (fgColor === \"#000000\" && bgColor === \"#ffffff\" || fgColor === bgColor) {\n      return this.#hcmUrl;\n    }\n    const map = new Array(256);\n    for (let i = 0; i <= 255; i++) {\n      const x = i / 255;\n      map[i] = x <= 0.03928 ? x / 12.92 : ((x + 0.055) / 1.055) ** 2.4;\n    }\n    const table = map.join(\",\");\n    const id = `g_${this.#docId}_hcm_filter`;\n    const filter = this.#hcmHighlightFilter = this.#createFilter(id);\n    this.#addTransferMapConversion(table, table, table, filter);\n    this.#addGrayConversion(filter);\n    const getSteps = (c, n) => {\n      const start = fgRGB[c] / 255;\n      const end = bgRGB[c] / 255;\n      const arr = new Array(n + 1);\n      for (let i = 0; i <= n; i++) {\n        arr[i] = start + i / n * (end - start);\n      }\n      return arr.join(\",\");\n    };\n    this.#addTransferMapConversion(getSteps(0, 5), getSteps(1, 5), getSteps(2, 5), filter);\n    this.#hcmUrl = `url(#${id})`;\n    return this.#hcmUrl;\n  }\n  addHighlightHCMFilter(fgColor, bgColor, newFgColor, newBgColor) {\n    const key = `${fgColor}-${bgColor}-${newFgColor}-${newBgColor}`;\n    if (this.#hcmHighlightKey === key) {\n      return this.#hcmHighlightUrl;\n    }\n    this.#hcmHighlightKey = key;\n    this.#hcmHighlightUrl = \"none\";\n    this.#hcmHighlightFilter?.remove();\n    if (!fgColor || !bgColor) {\n      return this.#hcmHighlightUrl;\n    }\n    const [fgRGB, bgRGB] = [fgColor, bgColor].map(this.#getRGB.bind(this));\n    let fgGray = Math.round(0.2126 * fgRGB[0] + 0.7152 * fgRGB[1] + 0.0722 * fgRGB[2]);\n    let bgGray = Math.round(0.2126 * bgRGB[0] + 0.7152 * bgRGB[1] + 0.0722 * bgRGB[2]);\n    let [newFgRGB, newBgRGB] = [newFgColor, newBgColor].map(this.#getRGB.bind(this));\n    if (bgGray < fgGray) {\n      [fgGray, bgGray, newFgRGB, newBgRGB] = [bgGray, fgGray, newBgRGB, newFgRGB];\n    }\n    this.#defs.style.color = \"\";\n    const getSteps = (fg, bg, n) => {\n      const arr = new Array(256);\n      const step = (bgGray - fgGray) / n;\n      const newStart = fg / 255;\n      const newStep = (bg - fg) / (255 * n);\n      let prev = 0;\n      for (let i = 0; i <= n; i++) {\n        const k = Math.round(fgGray + i * step);\n        const value = newStart + i * newStep;\n        for (let j = prev; j <= k; j++) {\n          arr[j] = value;\n        }\n        prev = k + 1;\n      }\n      for (let i = prev; i < 256; i++) {\n        arr[i] = arr[prev - 1];\n      }\n      return arr.join(\",\");\n    };\n    const id = `g_${this.#docId}_hcm_highlight_filter`;\n    const filter = this.#hcmHighlightFilter = this.#createFilter(id);\n    this.#addGrayConversion(filter);\n    this.#addTransferMapConversion(getSteps(newFgRGB[0], newBgRGB[0], 5), getSteps(newFgRGB[1], newBgRGB[1], 5), getSteps(newFgRGB[2], newBgRGB[2], 5), filter);\n    this.#hcmHighlightUrl = `url(#${id})`;\n    return this.#hcmHighlightUrl;\n  }\n  destroy(keepHCM = false) {\n    if (keepHCM && (this.#hcmUrl || this.#hcmHighlightUrl)) {\n      return;\n    }\n    if (this.#_defs) {\n      this.#_defs.parentNode.parentNode.remove();\n      this.#_defs = null;\n    }\n    if (this.#_cache) {\n      this.#_cache.clear();\n      this.#_cache = null;\n    }\n    this.#id = 0;\n  }\n  #addGrayConversion(filter) {\n    const feColorMatrix = this.#document.createElementNS(SVG_NS, \"feColorMatrix\");\n    feColorMatrix.setAttribute(\"type\", \"matrix\");\n    feColorMatrix.setAttribute(\"values\", \"0.2126 0.7152 0.0722 0 0 0.2126 0.7152 0.0722 0 0 0.2126 0.7152 0.0722 0 0 0 0 0 1 0\");\n    filter.append(feColorMatrix);\n  }\n  #createFilter(id) {\n    const filter = this.#document.createElementNS(SVG_NS, \"filter\");\n    filter.setAttribute(\"color-interpolation-filters\", \"sRGB\");\n    filter.setAttribute(\"id\", id);\n    this.#defs.append(filter);\n    return filter;\n  }\n  #appendFeFunc(feComponentTransfer, func, table) {\n    const feFunc = this.#document.createElementNS(SVG_NS, func);\n    feFunc.setAttribute(\"type\", \"discrete\");\n    feFunc.setAttribute(\"tableValues\", table);\n    feComponentTransfer.append(feFunc);\n  }\n  #addTransferMapConversion(rTable, gTable, bTable, filter) {\n    const feComponentTransfer = this.#document.createElementNS(SVG_NS, \"feComponentTransfer\");\n    filter.append(feComponentTransfer);\n    this.#appendFeFunc(feComponentTransfer, \"feFuncR\", rTable);\n    this.#appendFeFunc(feComponentTransfer, \"feFuncG\", gTable);\n    this.#appendFeFunc(feComponentTransfer, \"feFuncB\", bTable);\n  }\n  #getRGB(color) {\n    this.#defs.style.color = color;\n    return getRGB(getComputedStyle(this.#defs).getPropertyValue(\"color\"));\n  }\n}\nexports.DOMFilterFactory = DOMFilterFactory;\nclass DOMCanvasFactory extends _base_factory.BaseCanvasFactory {\n  constructor({\n    ownerDocument = globalThis.document\n  } = {}) {\n    super();\n    this._document = ownerDocument;\n  }\n  _createCanvas(width, height) {\n    const canvas = this._document.createElement(\"canvas\");\n    canvas.width = width;\n    canvas.height = height;\n    return canvas;\n  }\n}\nexports.DOMCanvasFactory = DOMCanvasFactory;\nasync function fetchData(url, asTypedArray = false) {\n  if (isValidFetchUrl(url, document.baseURI)) {\n    const response = await fetch(url);\n    if (!response.ok) {\n      throw new Error(response.statusText);\n    }\n    return asTypedArray ? new Uint8Array(await response.arrayBuffer()) : (0, _util.stringToBytes)(await response.text());\n  }\n  return new Promise((resolve, reject) => {\n    const request = new XMLHttpRequest();\n    request.open(\"GET\", url, true);\n    if (asTypedArray) {\n      request.responseType = \"arraybuffer\";\n    }\n    request.onreadystatechange = () => {\n      if (request.readyState !== XMLHttpRequest.DONE) {\n        return;\n      }\n      if (request.status === 200 || request.status === 0) {\n        let data;\n        if (asTypedArray && request.response) {\n          data = new Uint8Array(request.response);\n        } else if (!asTypedArray && request.responseText) {\n          data = (0, _util.stringToBytes)(request.responseText);\n        }\n        if (data) {\n          resolve(data);\n          return;\n        }\n      }\n      reject(new Error(request.statusText));\n    };\n    request.send(null);\n  });\n}\nclass DOMCMapReaderFactory extends _base_factory.BaseCMapReaderFactory {\n  _fetchData(url, compressionType) {\n    return fetchData(url, this.isCompressed).then(data => {\n      return {\n        cMapData: data,\n        compressionType\n      };\n    });\n  }\n}\nexports.DOMCMapReaderFactory = DOMCMapReaderFactory;\nclass DOMStandardFontDataFactory extends _base_factory.BaseStandardFontDataFactory {\n  _fetchData(url) {\n    return fetchData(url, true);\n  }\n}\nexports.DOMStandardFontDataFactory = DOMStandardFontDataFactory;\nclass DOMSVGFactory extends _base_factory.BaseSVGFactory {\n  _createSVG(type) {\n    return document.createElementNS(SVG_NS, type);\n  }\n}\nexports.DOMSVGFactory = DOMSVGFactory;\nclass PageViewport {\n  constructor({\n    viewBox,\n    scale,\n    rotation,\n    offsetX = 0,\n    offsetY = 0,\n    dontFlip = false\n  }) {\n    this.viewBox = viewBox;\n    this.scale = scale;\n    this.rotation = rotation;\n    this.offsetX = offsetX;\n    this.offsetY = offsetY;\n    const centerX = (viewBox[2] + viewBox[0]) / 2;\n    const centerY = (viewBox[3] + viewBox[1]) / 2;\n    let rotateA, rotateB, rotateC, rotateD;\n    rotation %= 360;\n    if (rotation < 0) {\n      rotation += 360;\n    }\n    switch (rotation) {\n      case 180:\n        rotateA = -1;\n        rotateB = 0;\n        rotateC = 0;\n        rotateD = 1;\n        break;\n      case 90:\n        rotateA = 0;\n        rotateB = 1;\n        rotateC = 1;\n        rotateD = 0;\n        break;\n      case 270:\n        rotateA = 0;\n        rotateB = -1;\n        rotateC = -1;\n        rotateD = 0;\n        break;\n      case 0:\n        rotateA = 1;\n        rotateB = 0;\n        rotateC = 0;\n        rotateD = -1;\n        break;\n      default:\n        throw new Error(\"PageViewport: Invalid rotation, must be a multiple of 90 degrees.\");\n    }\n    if (dontFlip) {\n      rotateC = -rotateC;\n      rotateD = -rotateD;\n    }\n    let offsetCanvasX, offsetCanvasY;\n    let width, height;\n    if (rotateA === 0) {\n      offsetCanvasX = Math.abs(centerY - viewBox[1]) * scale + offsetX;\n      offsetCanvasY = Math.abs(centerX - viewBox[0]) * scale + offsetY;\n      width = (viewBox[3] - viewBox[1]) * scale;\n      height = (viewBox[2] - viewBox[0]) * scale;\n    } else {\n      offsetCanvasX = Math.abs(centerX - viewBox[0]) * scale + offsetX;\n      offsetCanvasY = Math.abs(centerY - viewBox[1]) * scale + offsetY;\n      width = (viewBox[2] - viewBox[0]) * scale;\n      height = (viewBox[3] - viewBox[1]) * scale;\n    }\n    this.transform = [rotateA * scale, rotateB * scale, rotateC * scale, rotateD * scale, offsetCanvasX - rotateA * scale * centerX - rotateC * scale * centerY, offsetCanvasY - rotateB * scale * centerX - rotateD * scale * centerY];\n    this.width = width;\n    this.height = height;\n  }\n  get rawDims() {\n    const {\n      viewBox\n    } = this;\n    return (0, _util.shadow)(this, \"rawDims\", {\n      pageWidth: viewBox[2] - viewBox[0],\n      pageHeight: viewBox[3] - viewBox[1],\n      pageX: viewBox[0],\n      pageY: viewBox[1]\n    });\n  }\n  clone({\n    scale = this.scale,\n    rotation = this.rotation,\n    offsetX = this.offsetX,\n    offsetY = this.offsetY,\n    dontFlip = false\n  } = {}) {\n    return new PageViewport({\n      viewBox: this.viewBox.slice(),\n      scale,\n      rotation,\n      offsetX,\n      offsetY,\n      dontFlip\n    });\n  }\n  convertToViewportPoint(x, y) {\n    return _util.Util.applyTransform([x, y], this.transform);\n  }\n  convertToViewportRectangle(rect) {\n    const topLeft = _util.Util.applyTransform([rect[0], rect[1]], this.transform);\n    const bottomRight = _util.Util.applyTransform([rect[2], rect[3]], this.transform);\n    return [topLeft[0], topLeft[1], bottomRight[0], bottomRight[1]];\n  }\n  convertToPdfPoint(x, y) {\n    return _util.Util.applyInverseTransform([x, y], this.transform);\n  }\n}\nexports.PageViewport = PageViewport;\nclass RenderingCancelledException extends _util.BaseException {\n  constructor(msg, extraDelay = 0) {\n    super(msg, \"RenderingCancelledException\");\n    this.extraDelay = extraDelay;\n  }\n}\nexports.RenderingCancelledException = RenderingCancelledException;\nfunction isDataScheme(url) {\n  const ii = url.length;\n  let i = 0;\n  while (i < ii && url[i].trim() === \"\") {\n    i++;\n  }\n  return url.substring(i, i + 5).toLowerCase() === \"data:\";\n}\nfunction isPdfFile(filename) {\n  return typeof filename === \"string\" && /\\.pdf$/i.test(filename);\n}\nfunction getFilenameFromUrl(url, onlyStripPath = false) {\n  if (!onlyStripPath) {\n    [url] = url.split(/[#?]/, 1);\n  }\n  return url.substring(url.lastIndexOf(\"/\") + 1);\n}\nfunction getPdfFilenameFromUrl(url, defaultFilename = \"document.pdf\") {\n  if (typeof url !== \"string\") {\n    return defaultFilename;\n  }\n  if (isDataScheme(url)) {\n    (0, _util.warn)('getPdfFilenameFromUrl: ignore \"data:\"-URL for performance reasons.');\n    return defaultFilename;\n  }\n  const reURI = /^(?:(?:[^:]+:)?\\/\\/[^/]+)?([^?#]*)(\\?[^#]*)?(#.*)?$/;\n  const reFilename = /[^/?#=]+\\.pdf\\b(?!.*\\.pdf\\b)/i;\n  const splitURI = reURI.exec(url);\n  let suggestedFilename = reFilename.exec(splitURI[1]) || reFilename.exec(splitURI[2]) || reFilename.exec(splitURI[3]);\n  if (suggestedFilename) {\n    suggestedFilename = suggestedFilename[0];\n    if (suggestedFilename.includes(\"%\")) {\n      try {\n        suggestedFilename = reFilename.exec(decodeURIComponent(suggestedFilename))[0];\n      } catch {}\n    }\n  }\n  return suggestedFilename || defaultFilename;\n}\nclass StatTimer {\n  started = Object.create(null);\n  times = [];\n  time(name) {\n    if (name in this.started) {\n      (0, _util.warn)(`Timer is already running for ${name}`);\n    }\n    this.started[name] = Date.now();\n  }\n  timeEnd(name) {\n    if (!(name in this.started)) {\n      (0, _util.warn)(`Timer has not been started for ${name}`);\n    }\n    this.times.push({\n      name,\n      start: this.started[name],\n      end: Date.now()\n    });\n    delete this.started[name];\n  }\n  toString() {\n    const outBuf = [];\n    let longest = 0;\n    for (const {\n      name\n    } of this.times) {\n      longest = Math.max(name.length, longest);\n    }\n    for (const {\n      name,\n      start,\n      end\n    } of this.times) {\n      outBuf.push(`${name.padEnd(longest)} ${end - start}ms\\n`);\n    }\n    return outBuf.join(\"\");\n  }\n}\nexports.StatTimer = StatTimer;\nfunction isValidFetchUrl(url, baseUrl) {\n  try {\n    const {\n      protocol\n    } = baseUrl ? new URL(url, baseUrl) : new URL(url);\n    return protocol === \"http:\" || protocol === \"https:\";\n  } catch {\n    return false;\n  }\n}\nfunction noContextMenu(e) {\n  e.preventDefault();\n}\nfunction loadScript(src, removeScriptElement = false) {\n  return new Promise((resolve, reject) => {\n    const script = document.createElement(\"script\");\n    script.src = src;\n    script.onload = function (evt) {\n      if (removeScriptElement) {\n        script.remove();\n      }\n      resolve(evt);\n    };\n    script.onerror = function () {\n      reject(new Error(`Cannot load script at: ${script.src}`));\n    };\n    (document.head || document.documentElement).append(script);\n  });\n}\nfunction deprecated(details) {\n  console.log(\"Deprecated API usage: \" + details);\n}\nlet pdfDateStringRegex;\nclass PDFDateString {\n  static toDateObject(input) {\n    if (!input || typeof input !== \"string\") {\n      return null;\n    }\n    pdfDateStringRegex ||= new RegExp(\"^D:\" + \"(\\\\d{4})\" + \"(\\\\d{2})?\" + \"(\\\\d{2})?\" + \"(\\\\d{2})?\" + \"(\\\\d{2})?\" + \"(\\\\d{2})?\" + \"([Z|+|-])?\" + \"(\\\\d{2})?\" + \"'?\" + \"(\\\\d{2})?\" + \"'?\");\n    const matches = pdfDateStringRegex.exec(input);\n    if (!matches) {\n      return null;\n    }\n    const year = parseInt(matches[1], 10);\n    let month = parseInt(matches[2], 10);\n    month = month >= 1 && month <= 12 ? month - 1 : 0;\n    let day = parseInt(matches[3], 10);\n    day = day >= 1 && day <= 31 ? day : 1;\n    let hour = parseInt(matches[4], 10);\n    hour = hour >= 0 && hour <= 23 ? hour : 0;\n    let minute = parseInt(matches[5], 10);\n    minute = minute >= 0 && minute <= 59 ? minute : 0;\n    let second = parseInt(matches[6], 10);\n    second = second >= 0 && second <= 59 ? second : 0;\n    const universalTimeRelation = matches[7] || \"Z\";\n    let offsetHour = parseInt(matches[8], 10);\n    offsetHour = offsetHour >= 0 && offsetHour <= 23 ? offsetHour : 0;\n    let offsetMinute = parseInt(matches[9], 10) || 0;\n    offsetMinute = offsetMinute >= 0 && offsetMinute <= 59 ? offsetMinute : 0;\n    if (universalTimeRelation === \"-\") {\n      hour += offsetHour;\n      minute += offsetMinute;\n    } else if (universalTimeRelation === \"+\") {\n      hour -= offsetHour;\n      minute -= offsetMinute;\n    }\n    return new Date(Date.UTC(year, month, day, hour, minute, second));\n  }\n}\nexports.PDFDateString = PDFDateString;\nfunction getXfaPageViewport(xfaPage, {\n  scale = 1,\n  rotation = 0\n}) {\n  const {\n    width,\n    height\n  } = xfaPage.attributes.style;\n  const viewBox = [0, 0, parseInt(width), parseInt(height)];\n  return new PageViewport({\n    viewBox,\n    scale,\n    rotation\n  });\n}\nfunction getRGB(color) {\n  if (color.startsWith(\"#\")) {\n    const colorRGB = parseInt(color.slice(1), 16);\n    return [(colorRGB & 0xff0000) >> 16, (colorRGB & 0x00ff00) >> 8, colorRGB & 0x0000ff];\n  }\n  if (color.startsWith(\"rgb(\")) {\n    return color.slice(4, -1).split(\",\").map(x => parseInt(x));\n  }\n  if (color.startsWith(\"rgba(\")) {\n    return color.slice(5, -1).split(\",\").map(x => parseInt(x)).slice(0, 3);\n  }\n  (0, _util.warn)(`Not a valid color format: \"${color}\"`);\n  return [0, 0, 0];\n}\nfunction getColorValues(colors) {\n  const span = document.createElement(\"span\");\n  span.style.visibility = \"hidden\";\n  document.body.append(span);\n  for (const name of colors.keys()) {\n    span.style.color = name;\n    const computedColor = window.getComputedStyle(span).color;\n    colors.set(name, getRGB(computedColor));\n  }\n  span.remove();\n}\nfunction getCurrentTransform(ctx) {\n  const {\n    a,\n    b,\n    c,\n    d,\n    e,\n    f\n  } = ctx.getTransform();\n  return [a, b, c, d, e, f];\n}\nfunction getCurrentTransformInverse(ctx) {\n  const {\n    a,\n    b,\n    c,\n    d,\n    e,\n    f\n  } = ctx.getTransform().invertSelf();\n  return [a, b, c, d, e, f];\n}\nfunction setLayerDimensions(div, viewport, mustFlip = false, mustRotate = true) {\n  if (viewport instanceof PageViewport) {\n    const {\n      pageWidth,\n      pageHeight\n    } = viewport.rawDims;\n    const {\n      style\n    } = div;\n    const useRound = _util.FeatureTest.isCSSRoundSupported;\n    const w = `var(--scale-factor) * ${pageWidth}px`,\n      h = `var(--scale-factor) * ${pageHeight}px`;\n    const widthStr = useRound ? `round(${w}, 1px)` : `calc(${w})`,\n      heightStr = useRound ? `round(${h}, 1px)` : `calc(${h})`;\n    if (!mustFlip || viewport.rotation % 180 === 0) {\n      style.width = widthStr;\n      style.height = heightStr;\n    } else {\n      style.width = heightStr;\n      style.height = widthStr;\n    }\n  }\n  if (mustRotate) {\n    div.setAttribute(\"data-main-rotation\", viewport.rotation);\n  }\n}\n\n/***/ }),\n/* 7 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.BaseStandardFontDataFactory = exports.BaseSVGFactory = exports.BaseFilterFactory = exports.BaseCanvasFactory = exports.BaseCMapReaderFactory = void 0;\nvar _util = __w_pdfjs_require__(1);\nclass BaseFilterFactory {\n  constructor() {\n    if (this.constructor === BaseFilterFactory) {\n      (0, _util.unreachable)(\"Cannot initialize BaseFilterFactory.\");\n    }\n  }\n  addFilter(maps) {\n    return \"none\";\n  }\n  addHCMFilter(fgColor, bgColor) {\n    return \"none\";\n  }\n  addHighlightHCMFilter(fgColor, bgColor, newFgColor, newBgColor) {\n    return \"none\";\n  }\n  destroy(keepHCM = false) {}\n}\nexports.BaseFilterFactory = BaseFilterFactory;\nclass BaseCanvasFactory {\n  constructor() {\n    if (this.constructor === BaseCanvasFactory) {\n      (0, _util.unreachable)(\"Cannot initialize BaseCanvasFactory.\");\n    }\n  }\n  create(width, height) {\n    if (width <= 0 || height <= 0) {\n      throw new Error(\"Invalid canvas size\");\n    }\n    const canvas = this._createCanvas(width, height);\n    return {\n      canvas,\n      context: canvas.getContext(\"2d\")\n    };\n  }\n  reset(canvasAndContext, width, height) {\n    if (!canvasAndContext.canvas) {\n      throw new Error(\"Canvas is not specified\");\n    }\n    if (width <= 0 || height <= 0) {\n      throw new Error(\"Invalid canvas size\");\n    }\n    canvasAndContext.canvas.width = width;\n    canvasAndContext.canvas.height = height;\n  }\n  destroy(canvasAndContext) {\n    if (!canvasAndContext.canvas) {\n      throw new Error(\"Canvas is not specified\");\n    }\n    canvasAndContext.canvas.width = 0;\n    canvasAndContext.canvas.height = 0;\n    canvasAndContext.canvas = null;\n    canvasAndContext.context = null;\n  }\n  _createCanvas(width, height) {\n    (0, _util.unreachable)(\"Abstract method `_createCanvas` called.\");\n  }\n}\nexports.BaseCanvasFactory = BaseCanvasFactory;\nclass BaseCMapReaderFactory {\n  constructor({\n    baseUrl = null,\n    isCompressed = true\n  }) {\n    if (this.constructor === BaseCMapReaderFactory) {\n      (0, _util.unreachable)(\"Cannot initialize BaseCMapReaderFactory.\");\n    }\n    this.baseUrl = baseUrl;\n    this.isCompressed = isCompressed;\n  }\n  async fetch({\n    name\n  }) {\n    if (!this.baseUrl) {\n      throw new Error('The CMap \"baseUrl\" parameter must be specified, ensure that ' + 'the \"cMapUrl\" and \"cMapPacked\" API parameters are provided.');\n    }\n    if (!name) {\n      throw new Error(\"CMap name must be specified.\");\n    }\n    const url = this.baseUrl + name + (this.isCompressed ? \".bcmap\" : \"\");\n    const compressionType = this.isCompressed ? _util.CMapCompressionType.BINARY : _util.CMapCompressionType.NONE;\n    return this._fetchData(url, compressionType).catch(reason => {\n      throw new Error(`Unable to load ${this.isCompressed ? \"binary \" : \"\"}CMap at: ${url}`);\n    });\n  }\n  _fetchData(url, compressionType) {\n    (0, _util.unreachable)(\"Abstract method `_fetchData` called.\");\n  }\n}\nexports.BaseCMapReaderFactory = BaseCMapReaderFactory;\nclass BaseStandardFontDataFactory {\n  constructor({\n    baseUrl = null\n  }) {\n    if (this.constructor === BaseStandardFontDataFactory) {\n      (0, _util.unreachable)(\"Cannot initialize BaseStandardFontDataFactory.\");\n    }\n    this.baseUrl = baseUrl;\n  }\n  async fetch({\n    filename\n  }) {\n    if (!this.baseUrl) {\n      throw new Error('The standard font \"baseUrl\" parameter must be specified, ensure that ' + 'the \"standardFontDataUrl\" API parameter is provided.');\n    }\n    if (!filename) {\n      throw new Error(\"Font filename must be specified.\");\n    }\n    const url = `${this.baseUrl}${filename}`;\n    return this._fetchData(url).catch(reason => {\n      throw new Error(`Unable to load font data at: ${url}`);\n    });\n  }\n  _fetchData(url) {\n    (0, _util.unreachable)(\"Abstract method `_fetchData` called.\");\n  }\n}\nexports.BaseStandardFontDataFactory = BaseStandardFontDataFactory;\nclass BaseSVGFactory {\n  constructor() {\n    if (this.constructor === BaseSVGFactory) {\n      (0, _util.unreachable)(\"Cannot initialize BaseSVGFactory.\");\n    }\n  }\n  create(width, height, skipDimensions = false) {\n    if (width <= 0 || height <= 0) {\n      throw new Error(\"Invalid SVG dimensions\");\n    }\n    const svg = this._createSVG(\"svg:svg\");\n    svg.setAttribute(\"version\", \"1.1\");\n    if (!skipDimensions) {\n      svg.setAttribute(\"width\", `${width}px`);\n      svg.setAttribute(\"height\", `${height}px`);\n    }\n    svg.setAttribute(\"preserveAspectRatio\", \"none\");\n    svg.setAttribute(\"viewBox\", `0 0 ${width} ${height}`);\n    return svg;\n  }\n  createElement(type) {\n    if (typeof type !== \"string\") {\n      throw new Error(\"Invalid SVG element type\");\n    }\n    return this._createSVG(type);\n  }\n  _createSVG(type) {\n    (0, _util.unreachable)(\"Abstract method `_createSVG` called.\");\n  }\n}\nexports.BaseSVGFactory = BaseSVGFactory;\n\n/***/ }),\n/* 8 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.MurmurHash3_64 = void 0;\nvar _util = __w_pdfjs_require__(1);\nconst SEED = 0xc3d2e1f0;\nconst MASK_HIGH = 0xffff0000;\nconst MASK_LOW = 0xffff;\nclass MurmurHash3_64 {\n  constructor(seed) {\n    this.h1 = seed ? seed & 0xffffffff : SEED;\n    this.h2 = seed ? seed & 0xffffffff : SEED;\n  }\n  update(input) {\n    let data, length;\n    if (typeof input === \"string\") {\n      data = new Uint8Array(input.length * 2);\n      length = 0;\n      for (let i = 0, ii = input.length; i < ii; i++) {\n        const code = input.charCodeAt(i);\n        if (code <= 0xff) {\n          data[length++] = code;\n        } else {\n          data[length++] = code >>> 8;\n          data[length++] = code & 0xff;\n        }\n      }\n    } else if ((0, _util.isArrayBuffer)(input)) {\n      data = input.slice();\n      length = data.byteLength;\n    } else {\n      throw new Error(\"Wrong data format in MurmurHash3_64_update. \" + \"Input must be a string or array.\");\n    }\n    const blockCounts = length >> 2;\n    const tailLength = length - blockCounts * 4;\n    const dataUint32 = new Uint32Array(data.buffer, 0, blockCounts);\n    let k1 = 0,\n      k2 = 0;\n    let h1 = this.h1,\n      h2 = this.h2;\n    const C1 = 0xcc9e2d51,\n      C2 = 0x1b873593;\n    const C1_LOW = C1 & MASK_LOW,\n      C2_LOW = C2 & MASK_LOW;\n    for (let i = 0; i < blockCounts; i++) {\n      if (i & 1) {\n        k1 = dataUint32[i];\n        k1 = k1 * C1 & MASK_HIGH | k1 * C1_LOW & MASK_LOW;\n        k1 = k1 << 15 | k1 >>> 17;\n        k1 = k1 * C2 & MASK_HIGH | k1 * C2_LOW & MASK_LOW;\n        h1 ^= k1;\n        h1 = h1 << 13 | h1 >>> 19;\n        h1 = h1 * 5 + 0xe6546b64;\n      } else {\n        k2 = dataUint32[i];\n        k2 = k2 * C1 & MASK_HIGH | k2 * C1_LOW & MASK_LOW;\n        k2 = k2 << 15 | k2 >>> 17;\n        k2 = k2 * C2 & MASK_HIGH | k2 * C2_LOW & MASK_LOW;\n        h2 ^= k2;\n        h2 = h2 << 13 | h2 >>> 19;\n        h2 = h2 * 5 + 0xe6546b64;\n      }\n    }\n    k1 = 0;\n    switch (tailLength) {\n      case 3:\n        k1 ^= data[blockCounts * 4 + 2] << 16;\n      case 2:\n        k1 ^= data[blockCounts * 4 + 1] << 8;\n      case 1:\n        k1 ^= data[blockCounts * 4];\n        k1 = k1 * C1 & MASK_HIGH | k1 * C1_LOW & MASK_LOW;\n        k1 = k1 << 15 | k1 >>> 17;\n        k1 = k1 * C2 & MASK_HIGH | k1 * C2_LOW & MASK_LOW;\n        if (blockCounts & 1) {\n          h1 ^= k1;\n        } else {\n          h2 ^= k1;\n        }\n    }\n    this.h1 = h1;\n    this.h2 = h2;\n  }\n  hexdigest() {\n    let h1 = this.h1,\n      h2 = this.h2;\n    h1 ^= h2 >>> 1;\n    h1 = h1 * 0xed558ccd & MASK_HIGH | h1 * 0x8ccd & MASK_LOW;\n    h2 = h2 * 0xff51afd7 & MASK_HIGH | ((h2 << 16 | h1 >>> 16) * 0xafd7ed55 & MASK_HIGH) >>> 16;\n    h1 ^= h2 >>> 1;\n    h1 = h1 * 0x1a85ec53 & MASK_HIGH | h1 * 0xec53 & MASK_LOW;\n    h2 = h2 * 0xc4ceb9fe & MASK_HIGH | ((h2 << 16 | h1 >>> 16) * 0xb9fe1a85 & MASK_HIGH) >>> 16;\n    h1 ^= h2 >>> 1;\n    return (h1 >>> 0).toString(16).padStart(8, \"0\") + (h2 >>> 0).toString(16).padStart(8, \"0\");\n  }\n}\nexports.MurmurHash3_64 = MurmurHash3_64;\n\n/***/ }),\n/* 9 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.FontLoader = exports.FontFaceObject = void 0;\nvar _util = __w_pdfjs_require__(1);\nclass FontLoader {\n  #systemFonts = new Set();\n  constructor({\n    ownerDocument = globalThis.document,\n    styleElement = null\n  }) {\n    this._document = ownerDocument;\n    this.nativeFontFaces = new Set();\n    this.styleElement = null;\n    this.loadingRequests = [];\n    this.loadTestFontId = 0;\n  }\n  addNativeFontFace(nativeFontFace) {\n    this.nativeFontFaces.add(nativeFontFace);\n    this._document.fonts.add(nativeFontFace);\n  }\n  removeNativeFontFace(nativeFontFace) {\n    this.nativeFontFaces.delete(nativeFontFace);\n    this._document.fonts.delete(nativeFontFace);\n  }\n  insertRule(rule) {\n    if (!this.styleElement) {\n      this.styleElement = this._document.createElement(\"style\");\n      this._document.documentElement.getElementsByTagName(\"head\")[0].append(this.styleElement);\n    }\n    const styleSheet = this.styleElement.sheet;\n    styleSheet.insertRule(rule, styleSheet.cssRules.length);\n  }\n  clear() {\n    for (const nativeFontFace of this.nativeFontFaces) {\n      this._document.fonts.delete(nativeFontFace);\n    }\n    this.nativeFontFaces.clear();\n    this.#systemFonts.clear();\n    if (this.styleElement) {\n      this.styleElement.remove();\n      this.styleElement = null;\n    }\n  }\n  async loadSystemFont(info) {\n    if (!info || this.#systemFonts.has(info.loadedName)) {\n      return;\n    }\n    (0, _util.assert)(!this.disableFontFace, \"loadSystemFont shouldn't be called when `disableFontFace` is set.\");\n    if (this.isFontLoadingAPISupported) {\n      const {\n        loadedName,\n        src,\n        style\n      } = info;\n      const fontFace = new FontFace(loadedName, src, style);\n      this.addNativeFontFace(fontFace);\n      try {\n        await fontFace.load();\n        this.#systemFonts.add(loadedName);\n      } catch {\n        (0, _util.warn)(`Cannot load system font: ${info.baseFontName}, installing it could help to improve PDF rendering.`);\n        this.removeNativeFontFace(fontFace);\n      }\n      return;\n    }\n    (0, _util.unreachable)(\"Not implemented: loadSystemFont without the Font Loading API.\");\n  }\n  async bind(font) {\n    if (font.attached || font.missingFile && !font.systemFontInfo) {\n      return;\n    }\n    font.attached = true;\n    if (font.systemFontInfo) {\n      await this.loadSystemFont(font.systemFontInfo);\n      return;\n    }\n    if (this.isFontLoadingAPISupported) {\n      const nativeFontFace = font.createNativeFontFace();\n      if (nativeFontFace) {\n        this.addNativeFontFace(nativeFontFace);\n        try {\n          await nativeFontFace.loaded;\n        } catch (ex) {\n          (0, _util.warn)(`Failed to load font '${nativeFontFace.family}': '${ex}'.`);\n          font.disableFontFace = true;\n          throw ex;\n        }\n      }\n      return;\n    }\n    const rule = font.createFontFaceRule();\n    if (rule) {\n      this.insertRule(rule);\n      if (this.isSyncFontLoadingSupported) {\n        return;\n      }\n      await new Promise(resolve => {\n        const request = this._queueLoadingCallback(resolve);\n        this._prepareFontLoadEvent(font, request);\n      });\n    }\n  }\n  get isFontLoadingAPISupported() {\n    const hasFonts = !!this._document?.fonts;\n    return (0, _util.shadow)(this, \"isFontLoadingAPISupported\", hasFonts);\n  }\n  get isSyncFontLoadingSupported() {\n    let supported = false;\n    if (_util.isNodeJS) {\n      supported = true;\n    } else if (typeof navigator !== \"undefined\" && /Mozilla\\/5.0.*?rv:\\d+.*? Gecko/.test(navigator.userAgent)) {\n      supported = true;\n    }\n    return (0, _util.shadow)(this, \"isSyncFontLoadingSupported\", supported);\n  }\n  _queueLoadingCallback(callback) {\n    function completeRequest() {\n      (0, _util.assert)(!request.done, \"completeRequest() cannot be called twice.\");\n      request.done = true;\n      while (loadingRequests.length > 0 && loadingRequests[0].done) {\n        const otherRequest = loadingRequests.shift();\n        setTimeout(otherRequest.callback, 0);\n      }\n    }\n    const {\n      loadingRequests\n    } = this;\n    const request = {\n      done: false,\n      complete: completeRequest,\n      callback\n    };\n    loadingRequests.push(request);\n    return request;\n  }\n  get _loadTestFont() {\n    const testFont = atob(\"T1RUTwALAIAAAwAwQ0ZGIDHtZg4AAAOYAAAAgUZGVE1lkzZwAAAEHAAAABxHREVGABQA\" + \"FQAABDgAAAAeT1MvMlYNYwkAAAEgAAAAYGNtYXABDQLUAAACNAAAAUJoZWFk/xVFDQAA\" + \"ALwAAAA2aGhlYQdkA+oAAAD0AAAAJGhtdHgD6AAAAAAEWAAAAAZtYXhwAAJQAAAAARgA\" + \"AAAGbmFtZVjmdH4AAAGAAAAAsXBvc3T/hgAzAAADeAAAACAAAQAAAAEAALZRFsRfDzz1\" + \"AAsD6AAAAADOBOTLAAAAAM4KHDwAAAAAA+gDIQAAAAgAAgAAAAAAAAABAAADIQAAAFoD\" + \"6AAAAAAD6AABAAAAAAAAAAAAAAAAAAAAAQAAUAAAAgAAAAQD6AH0AAUAAAKKArwAAACM\" + \"AooCvAAAAeAAMQECAAACAAYJAAAAAAAAAAAAAQAAAAAAAAAAAAAAAFBmRWQAwAAuAC4D\" + \"IP84AFoDIQAAAAAAAQAAAAAAAAAAACAAIAABAAAADgCuAAEAAAAAAAAAAQAAAAEAAAAA\" + \"AAEAAQAAAAEAAAAAAAIAAQAAAAEAAAAAAAMAAQAAAAEAAAAAAAQAAQAAAAEAAAAAAAUA\" + \"AQAAAAEAAAAAAAYAAQAAAAMAAQQJAAAAAgABAAMAAQQJAAEAAgABAAMAAQQJAAIAAgAB\" + \"AAMAAQQJAAMAAgABAAMAAQQJAAQAAgABAAMAAQQJAAUAAgABAAMAAQQJAAYAAgABWABY\" + \"AAAAAAAAAwAAAAMAAAAcAAEAAAAAADwAAwABAAAAHAAEACAAAAAEAAQAAQAAAC7//wAA\" + \"AC7////TAAEAAAAAAAABBgAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAD/gwAyAAAAAQAAAAAAAAAAAAAAAAAA\" + \"AAABAAQEAAEBAQJYAAEBASH4DwD4GwHEAvgcA/gXBIwMAYuL+nz5tQXkD5j3CBLnEQAC\" + \"AQEBIVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYAAABAQAADwACAQEEE/t3\" + \"Dov6fAH6fAT+fPp8+nwHDosMCvm1Cvm1DAz6fBQAAAAAAAABAAAAAMmJbzEAAAAAzgTj\" + \"FQAAAADOBOQpAAEAAAAAAAAADAAUAAQAAAABAAAAAgABAAAAAAAAAAAD6AAAAAAAAA==\");\n    return (0, _util.shadow)(this, \"_loadTestFont\", testFont);\n  }\n  _prepareFontLoadEvent(font, request) {\n    function int32(data, offset) {\n      return data.charCodeAt(offset) << 24 | data.charCodeAt(offset + 1) << 16 | data.charCodeAt(offset + 2) << 8 | data.charCodeAt(offset + 3) & 0xff;\n    }\n    function spliceString(s, offset, remove, insert) {\n      const chunk1 = s.substring(0, offset);\n      const chunk2 = s.substring(offset + remove);\n      return chunk1 + insert + chunk2;\n    }\n    let i, ii;\n    const canvas = this._document.createElement(\"canvas\");\n    canvas.width = 1;\n    canvas.height = 1;\n    const ctx = canvas.getContext(\"2d\");\n    let called = 0;\n    function isFontReady(name, callback) {\n      if (++called > 30) {\n        (0, _util.warn)(\"Load test font never loaded.\");\n        callback();\n        return;\n      }\n      ctx.font = \"30px \" + name;\n      ctx.fillText(\".\", 0, 20);\n      const imageData = ctx.getImageData(0, 0, 1, 1);\n      if (imageData.data[3] > 0) {\n        callback();\n        return;\n      }\n      setTimeout(isFontReady.bind(null, name, callback));\n    }\n    const loadTestFontId = `lt${Date.now()}${this.loadTestFontId++}`;\n    let data = this._loadTestFont;\n    const COMMENT_OFFSET = 976;\n    data = spliceString(data, COMMENT_OFFSET, loadTestFontId.length, loadTestFontId);\n    const CFF_CHECKSUM_OFFSET = 16;\n    const XXXX_VALUE = 0x58585858;\n    let checksum = int32(data, CFF_CHECKSUM_OFFSET);\n    for (i = 0, ii = loadTestFontId.length - 3; i < ii; i += 4) {\n      checksum = checksum - XXXX_VALUE + int32(loadTestFontId, i) | 0;\n    }\n    if (i < loadTestFontId.length) {\n      checksum = checksum - XXXX_VALUE + int32(loadTestFontId + \"XXX\", i) | 0;\n    }\n    data = spliceString(data, CFF_CHECKSUM_OFFSET, 4, (0, _util.string32)(checksum));\n    const url = `url(data:font/opentype;base64,${btoa(data)});`;\n    const rule = `@font-face {font-family:\"${loadTestFontId}\";src:${url}}`;\n    this.insertRule(rule);\n    const div = this._document.createElement(\"div\");\n    div.style.visibility = \"hidden\";\n    div.style.width = div.style.height = \"10px\";\n    div.style.position = \"absolute\";\n    div.style.top = div.style.left = \"0px\";\n    for (const name of [font.loadedName, loadTestFontId]) {\n      const span = this._document.createElement(\"span\");\n      span.textContent = \"Hi\";\n      span.style.fontFamily = name;\n      div.append(span);\n    }\n    this._document.body.append(div);\n    isFontReady(loadTestFontId, () => {\n      div.remove();\n      request.complete();\n    });\n  }\n}\nexports.FontLoader = FontLoader;\nclass FontFaceObject {\n  constructor(translatedData, {\n    isEvalSupported = true,\n    disableFontFace = false,\n    ignoreErrors = false,\n    inspectFont = null\n  }) {\n    this.compiledGlyphs = Object.create(null);\n    for (const i in translatedData) {\n      this[i] = translatedData[i];\n    }\n    this.isEvalSupported = isEvalSupported !== false;\n    this.disableFontFace = disableFontFace === true;\n    this.ignoreErrors = ignoreErrors === true;\n    this._inspectFont = inspectFont;\n  }\n  createNativeFontFace() {\n    if (!this.data || this.disableFontFace) {\n      return null;\n    }\n    let nativeFontFace;\n    if (!this.cssFontInfo) {\n      nativeFontFace = new FontFace(this.loadedName, this.data, {});\n    } else {\n      const css = {\n        weight: this.cssFontInfo.fontWeight\n      };\n      if (this.cssFontInfo.italicAngle) {\n        css.style = `oblique ${this.cssFontInfo.italicAngle}deg`;\n      }\n      nativeFontFace = new FontFace(this.cssFontInfo.fontFamily, this.data, css);\n    }\n    this._inspectFont?.(this);\n    return nativeFontFace;\n  }\n  createFontFaceRule() {\n    if (!this.data || this.disableFontFace) {\n      return null;\n    }\n    const data = (0, _util.bytesToString)(this.data);\n    const url = `url(data:${this.mimetype};base64,${btoa(data)});`;\n    let rule;\n    if (!this.cssFontInfo) {\n      rule = `@font-face {font-family:\"${this.loadedName}\";src:${url}}`;\n    } else {\n      let css = `font-weight: ${this.cssFontInfo.fontWeight};`;\n      if (this.cssFontInfo.italicAngle) {\n        css += `font-style: oblique ${this.cssFontInfo.italicAngle}deg;`;\n      }\n      rule = `@font-face {font-family:\"${this.cssFontInfo.fontFamily}\";${css}src:${url}}`;\n    }\n    this._inspectFont?.(this, url);\n    return rule;\n  }\n  getPathGenerator(objs, character) {\n    if (this.compiledGlyphs[character] !== undefined) {\n      return this.compiledGlyphs[character];\n    }\n    let cmds;\n    try {\n      cmds = objs.get(this.loadedName + \"_path_\" + character);\n    } catch (ex) {\n      if (!this.ignoreErrors) {\n        throw ex;\n      }\n      (0, _util.warn)(`getPathGenerator - ignoring character: \"${ex}\".`);\n      return this.compiledGlyphs[character] = function (c, size) {};\n    }\n    if (this.isEvalSupported && _util.FeatureTest.isEvalSupported) {\n      const jsBuf = [];\n      for (const current of cmds) {\n        const args = current.args !== undefined ? current.args.join(\",\") : \"\";\n        jsBuf.push(\"c.\", current.cmd, \"(\", args, \");\\n\");\n      }\n      return this.compiledGlyphs[character] = new Function(\"c\", \"size\", jsBuf.join(\"\"));\n    }\n    return this.compiledGlyphs[character] = function (c, size) {\n      for (const current of cmds) {\n        if (current.cmd === \"scale\") {\n          current.args = [size, -size];\n        }\n        c[current.cmd].apply(c, current.args);\n      }\n    };\n  }\n}\nexports.FontFaceObject = FontFaceObject;\n\n/***/ }),\n/* 10 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.NodeStandardFontDataFactory = exports.NodeFilterFactory = exports.NodeCanvasFactory = exports.NodeCMapReaderFactory = void 0;\nvar _base_factory = __w_pdfjs_require__(7);\nvar _util = __w_pdfjs_require__(1);\n;\n;\nconst fetchData = function (url) {\n  return new Promise((resolve, reject) => {\n    const fs = __webpack_require__(/*! fs */ \"?4fe2\");\n    fs.readFile(url, (error, data) => {\n      if (error || !data) {\n        reject(new Error(error));\n        return;\n      }\n      resolve(new Uint8Array(data));\n    });\n  });\n};\nclass NodeFilterFactory extends _base_factory.BaseFilterFactory {}\nexports.NodeFilterFactory = NodeFilterFactory;\nclass NodeCanvasFactory extends _base_factory.BaseCanvasFactory {\n  _createCanvas(width, height) {\n    const Canvas = __webpack_require__(/*! canvas */ \"?f848\");\n    return Canvas.createCanvas(width, height);\n  }\n}\nexports.NodeCanvasFactory = NodeCanvasFactory;\nclass NodeCMapReaderFactory extends _base_factory.BaseCMapReaderFactory {\n  _fetchData(url, compressionType) {\n    return fetchData(url).then(data => {\n      return {\n        cMapData: data,\n        compressionType\n      };\n    });\n  }\n}\nexports.NodeCMapReaderFactory = NodeCMapReaderFactory;\nclass NodeStandardFontDataFactory extends _base_factory.BaseStandardFontDataFactory {\n  _fetchData(url) {\n    return fetchData(url);\n  }\n}\nexports.NodeStandardFontDataFactory = NodeStandardFontDataFactory;\n\n/***/ }),\n/* 11 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.CanvasGraphics = void 0;\nvar _util = __w_pdfjs_require__(1);\nvar _display_utils = __w_pdfjs_require__(6);\nvar _pattern_helper = __w_pdfjs_require__(12);\nvar _image_utils = __w_pdfjs_require__(13);\nconst MIN_FONT_SIZE = 16;\nconst MAX_FONT_SIZE = 100;\nconst MAX_GROUP_SIZE = 4096;\nconst EXECUTION_TIME = 15;\nconst EXECUTION_STEPS = 10;\nconst MAX_SIZE_TO_COMPILE = 1000;\nconst FULL_CHUNK_HEIGHT = 16;\nfunction mirrorContextOperations(ctx, destCtx) {\n  if (ctx._removeMirroring) {\n    throw new Error(\"Context is already forwarding operations.\");\n  }\n  ctx.__originalSave = ctx.save;\n  ctx.__originalRestore = ctx.restore;\n  ctx.__originalRotate = ctx.rotate;\n  ctx.__originalScale = ctx.scale;\n  ctx.__originalTranslate = ctx.translate;\n  ctx.__originalTransform = ctx.transform;\n  ctx.__originalSetTransform = ctx.setTransform;\n  ctx.__originalResetTransform = ctx.resetTransform;\n  ctx.__originalClip = ctx.clip;\n  ctx.__originalMoveTo = ctx.moveTo;\n  ctx.__originalLineTo = ctx.lineTo;\n  ctx.__originalBezierCurveTo = ctx.bezierCurveTo;\n  ctx.__originalRect = ctx.rect;\n  ctx.__originalClosePath = ctx.closePath;\n  ctx.__originalBeginPath = ctx.beginPath;\n  ctx._removeMirroring = () => {\n    ctx.save = ctx.__originalSave;\n    ctx.restore = ctx.__originalRestore;\n    ctx.rotate = ctx.__originalRotate;\n    ctx.scale = ctx.__originalScale;\n    ctx.translate = ctx.__originalTranslate;\n    ctx.transform = ctx.__originalTransform;\n    ctx.setTransform = ctx.__originalSetTransform;\n    ctx.resetTransform = ctx.__originalResetTransform;\n    ctx.clip = ctx.__originalClip;\n    ctx.moveTo = ctx.__originalMoveTo;\n    ctx.lineTo = ctx.__originalLineTo;\n    ctx.bezierCurveTo = ctx.__originalBezierCurveTo;\n    ctx.rect = ctx.__originalRect;\n    ctx.closePath = ctx.__originalClosePath;\n    ctx.beginPath = ctx.__originalBeginPath;\n    delete ctx._removeMirroring;\n  };\n  ctx.save = function ctxSave() {\n    destCtx.save();\n    this.__originalSave();\n  };\n  ctx.restore = function ctxRestore() {\n    destCtx.restore();\n    this.__originalRestore();\n  };\n  ctx.translate = function ctxTranslate(x, y) {\n    destCtx.translate(x, y);\n    this.__originalTranslate(x, y);\n  };\n  ctx.scale = function ctxScale(x, y) {\n    destCtx.scale(x, y);\n    this.__originalScale(x, y);\n  };\n  ctx.transform = function ctxTransform(a, b, c, d, e, f) {\n    destCtx.transform(a, b, c, d, e, f);\n    this.__originalTransform(a, b, c, d, e, f);\n  };\n  ctx.setTransform = function ctxSetTransform(a, b, c, d, e, f) {\n    destCtx.setTransform(a, b, c, d, e, f);\n    this.__originalSetTransform(a, b, c, d, e, f);\n  };\n  ctx.resetTransform = function ctxResetTransform() {\n    destCtx.resetTransform();\n    this.__originalResetTransform();\n  };\n  ctx.rotate = function ctxRotate(angle) {\n    destCtx.rotate(angle);\n    this.__originalRotate(angle);\n  };\n  ctx.clip = function ctxRotate(rule) {\n    destCtx.clip(rule);\n    this.__originalClip(rule);\n  };\n  ctx.moveTo = function (x, y) {\n    destCtx.moveTo(x, y);\n    this.__originalMoveTo(x, y);\n  };\n  ctx.lineTo = function (x, y) {\n    destCtx.lineTo(x, y);\n    this.__originalLineTo(x, y);\n  };\n  ctx.bezierCurveTo = function (cp1x, cp1y, cp2x, cp2y, x, y) {\n    destCtx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);\n    this.__originalBezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);\n  };\n  ctx.rect = function (x, y, width, height) {\n    destCtx.rect(x, y, width, height);\n    this.__originalRect(x, y, width, height);\n  };\n  ctx.closePath = function () {\n    destCtx.closePath();\n    this.__originalClosePath();\n  };\n  ctx.beginPath = function () {\n    destCtx.beginPath();\n    this.__originalBeginPath();\n  };\n}\nclass CachedCanvases {\n  constructor(canvasFactory) {\n    this.canvasFactory = canvasFactory;\n    this.cache = Object.create(null);\n  }\n  getCanvas(id, width, height) {\n    let canvasEntry;\n    if (this.cache[id] !== undefined) {\n      canvasEntry = this.cache[id];\n      this.canvasFactory.reset(canvasEntry, width, height);\n    } else {\n      canvasEntry = this.canvasFactory.create(width, height);\n      this.cache[id] = canvasEntry;\n    }\n    return canvasEntry;\n  }\n  delete(id) {\n    delete this.cache[id];\n  }\n  clear() {\n    for (const id in this.cache) {\n      const canvasEntry = this.cache[id];\n      this.canvasFactory.destroy(canvasEntry);\n      delete this.cache[id];\n    }\n  }\n}\nfunction drawImageAtIntegerCoords(ctx, srcImg, srcX, srcY, srcW, srcH, destX, destY, destW, destH) {\n  const [a, b, c, d, tx, ty] = (0, _display_utils.getCurrentTransform)(ctx);\n  if (b === 0 && c === 0) {\n    const tlX = destX * a + tx;\n    const rTlX = Math.round(tlX);\n    const tlY = destY * d + ty;\n    const rTlY = Math.round(tlY);\n    const brX = (destX + destW) * a + tx;\n    const rWidth = Math.abs(Math.round(brX) - rTlX) || 1;\n    const brY = (destY + destH) * d + ty;\n    const rHeight = Math.abs(Math.round(brY) - rTlY) || 1;\n    ctx.setTransform(Math.sign(a), 0, 0, Math.sign(d), rTlX, rTlY);\n    ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, 0, 0, rWidth, rHeight);\n    ctx.setTransform(a, b, c, d, tx, ty);\n    return [rWidth, rHeight];\n  }\n  if (a === 0 && d === 0) {\n    const tlX = destY * c + tx;\n    const rTlX = Math.round(tlX);\n    const tlY = destX * b + ty;\n    const rTlY = Math.round(tlY);\n    const brX = (destY + destH) * c + tx;\n    const rWidth = Math.abs(Math.round(brX) - rTlX) || 1;\n    const brY = (destX + destW) * b + ty;\n    const rHeight = Math.abs(Math.round(brY) - rTlY) || 1;\n    ctx.setTransform(0, Math.sign(b), Math.sign(c), 0, rTlX, rTlY);\n    ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, 0, 0, rHeight, rWidth);\n    ctx.setTransform(a, b, c, d, tx, ty);\n    return [rHeight, rWidth];\n  }\n  ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, destX, destY, destW, destH);\n  const scaleX = Math.hypot(a, b);\n  const scaleY = Math.hypot(c, d);\n  return [scaleX * destW, scaleY * destH];\n}\nfunction compileType3Glyph(imgData) {\n  const {\n    width,\n    height\n  } = imgData;\n  if (width > MAX_SIZE_TO_COMPILE || height > MAX_SIZE_TO_COMPILE) {\n    return null;\n  }\n  const POINT_TO_PROCESS_LIMIT = 1000;\n  const POINT_TYPES = new Uint8Array([0, 2, 4, 0, 1, 0, 5, 4, 8, 10, 0, 8, 0, 2, 1, 0]);\n  const width1 = width + 1;\n  let points = new Uint8Array(width1 * (height + 1));\n  let i, j, j0;\n  const lineSize = width + 7 & ~7;\n  let data = new Uint8Array(lineSize * height),\n    pos = 0;\n  for (const elem of imgData.data) {\n    let mask = 128;\n    while (mask > 0) {\n      data[pos++] = elem & mask ? 0 : 255;\n      mask >>= 1;\n    }\n  }\n  let count = 0;\n  pos = 0;\n  if (data[pos] !== 0) {\n    points[0] = 1;\n    ++count;\n  }\n  for (j = 1; j < width; j++) {\n    if (data[pos] !== data[pos + 1]) {\n      points[j] = data[pos] ? 2 : 1;\n      ++count;\n    }\n    pos++;\n  }\n  if (data[pos] !== 0) {\n    points[j] = 2;\n    ++count;\n  }\n  for (i = 1; i < height; i++) {\n    pos = i * lineSize;\n    j0 = i * width1;\n    if (data[pos - lineSize] !== data[pos]) {\n      points[j0] = data[pos] ? 1 : 8;\n      ++count;\n    }\n    let sum = (data[pos] ? 4 : 0) + (data[pos - lineSize] ? 8 : 0);\n    for (j = 1; j < width; j++) {\n      sum = (sum >> 2) + (data[pos + 1] ? 4 : 0) + (data[pos - lineSize + 1] ? 8 : 0);\n      if (POINT_TYPES[sum]) {\n        points[j0 + j] = POINT_TYPES[sum];\n        ++count;\n      }\n      pos++;\n    }\n    if (data[pos - lineSize] !== data[pos]) {\n      points[j0 + j] = data[pos] ? 2 : 4;\n      ++count;\n    }\n    if (count > POINT_TO_PROCESS_LIMIT) {\n      return null;\n    }\n  }\n  pos = lineSize * (height - 1);\n  j0 = i * width1;\n  if (data[pos] !== 0) {\n    points[j0] = 8;\n    ++count;\n  }\n  for (j = 1; j < width; j++) {\n    if (data[pos] !== data[pos + 1]) {\n      points[j0 + j] = data[pos] ? 4 : 8;\n      ++count;\n    }\n    pos++;\n  }\n  if (data[pos] !== 0) {\n    points[j0 + j] = 4;\n    ++count;\n  }\n  if (count > POINT_TO_PROCESS_LIMIT) {\n    return null;\n  }\n  const steps = new Int32Array([0, width1, -1, 0, -width1, 0, 0, 0, 1]);\n  const path = new Path2D();\n  for (i = 0; count && i <= height; i++) {\n    let p = i * width1;\n    const end = p + width;\n    while (p < end && !points[p]) {\n      p++;\n    }\n    if (p === end) {\n      continue;\n    }\n    path.moveTo(p % width1, i);\n    const p0 = p;\n    let type = points[p];\n    do {\n      const step = steps[type];\n      do {\n        p += step;\n      } while (!points[p]);\n      const pp = points[p];\n      if (pp !== 5 && pp !== 10) {\n        type = pp;\n        points[p] = 0;\n      } else {\n        type = pp & 0x33 * type >> 4;\n        points[p] &= type >> 2 | type << 2;\n      }\n      path.lineTo(p % width1, p / width1 | 0);\n      if (!points[p]) {\n        --count;\n      }\n    } while (p0 !== p);\n    --i;\n  }\n  data = null;\n  points = null;\n  const drawOutline = function (c) {\n    c.save();\n    c.scale(1 / width, -1 / height);\n    c.translate(0, -height);\n    c.fill(path);\n    c.beginPath();\n    c.restore();\n  };\n  return drawOutline;\n}\nclass CanvasExtraState {\n  constructor(width, height) {\n    this.alphaIsShape = false;\n    this.fontSize = 0;\n    this.fontSizeScale = 1;\n    this.textMatrix = _util.IDENTITY_MATRIX;\n    this.textMatrixScale = 1;\n    this.fontMatrix = _util.FONT_IDENTITY_MATRIX;\n    this.leading = 0;\n    this.x = 0;\n    this.y = 0;\n    this.lineX = 0;\n    this.lineY = 0;\n    this.charSpacing = 0;\n    this.wordSpacing = 0;\n    this.textHScale = 1;\n    this.textRenderingMode = _util.TextRenderingMode.FILL;\n    this.textRise = 0;\n    this.fillColor = \"#000000\";\n    this.strokeColor = \"#000000\";\n    this.patternFill = false;\n    this.fillAlpha = 1;\n    this.strokeAlpha = 1;\n    this.lineWidth = 1;\n    this.activeSMask = null;\n    this.transferMaps = \"none\";\n    this.startNewPathAndClipBox([0, 0, width, height]);\n  }\n  clone() {\n    const clone = Object.create(this);\n    clone.clipBox = this.clipBox.slice();\n    return clone;\n  }\n  setCurrentPoint(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n  updatePathMinMax(transform, x, y) {\n    [x, y] = _util.Util.applyTransform([x, y], transform);\n    this.minX = Math.min(this.minX, x);\n    this.minY = Math.min(this.minY, y);\n    this.maxX = Math.max(this.maxX, x);\n    this.maxY = Math.max(this.maxY, y);\n  }\n  updateRectMinMax(transform, rect) {\n    const p1 = _util.Util.applyTransform(rect, transform);\n    const p2 = _util.Util.applyTransform(rect.slice(2), transform);\n    this.minX = Math.min(this.minX, p1[0], p2[0]);\n    this.minY = Math.min(this.minY, p1[1], p2[1]);\n    this.maxX = Math.max(this.maxX, p1[0], p2[0]);\n    this.maxY = Math.max(this.maxY, p1[1], p2[1]);\n  }\n  updateScalingPathMinMax(transform, minMax) {\n    _util.Util.scaleMinMax(transform, minMax);\n    this.minX = Math.min(this.minX, minMax[0]);\n    this.maxX = Math.max(this.maxX, minMax[1]);\n    this.minY = Math.min(this.minY, minMax[2]);\n    this.maxY = Math.max(this.maxY, minMax[3]);\n  }\n  updateCurvePathMinMax(transform, x0, y0, x1, y1, x2, y2, x3, y3, minMax) {\n    const box = _util.Util.bezierBoundingBox(x0, y0, x1, y1, x2, y2, x3, y3);\n    if (minMax) {\n      minMax[0] = Math.min(minMax[0], box[0], box[2]);\n      minMax[1] = Math.max(minMax[1], box[0], box[2]);\n      minMax[2] = Math.min(minMax[2], box[1], box[3]);\n      minMax[3] = Math.max(minMax[3], box[1], box[3]);\n      return;\n    }\n    this.updateRectMinMax(transform, box);\n  }\n  getPathBoundingBox(pathType = _pattern_helper.PathType.FILL, transform = null) {\n    const box = [this.minX, this.minY, this.maxX, this.maxY];\n    if (pathType === _pattern_helper.PathType.STROKE) {\n      if (!transform) {\n        (0, _util.unreachable)(\"Stroke bounding box must include transform.\");\n      }\n      const scale = _util.Util.singularValueDecompose2dScale(transform);\n      const xStrokePad = scale[0] * this.lineWidth / 2;\n      const yStrokePad = scale[1] * this.lineWidth / 2;\n      box[0] -= xStrokePad;\n      box[1] -= yStrokePad;\n      box[2] += xStrokePad;\n      box[3] += yStrokePad;\n    }\n    return box;\n  }\n  updateClipFromPath() {\n    const intersect = _util.Util.intersect(this.clipBox, this.getPathBoundingBox());\n    this.startNewPathAndClipBox(intersect || [0, 0, 0, 0]);\n  }\n  isEmptyClip() {\n    return this.minX === Infinity;\n  }\n  startNewPathAndClipBox(box) {\n    this.clipBox = box;\n    this.minX = Infinity;\n    this.minY = Infinity;\n    this.maxX = 0;\n    this.maxY = 0;\n  }\n  getClippedPathBoundingBox(pathType = _pattern_helper.PathType.FILL, transform = null) {\n    return _util.Util.intersect(this.clipBox, this.getPathBoundingBox(pathType, transform));\n  }\n}\nfunction putBinaryImageData(ctx, imgData) {\n  if (typeof ImageData !== \"undefined\" && imgData instanceof ImageData) {\n    ctx.putImageData(imgData, 0, 0);\n    return;\n  }\n  const height = imgData.height,\n    width = imgData.width;\n  const partialChunkHeight = height % FULL_CHUNK_HEIGHT;\n  const fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;\n  const totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;\n  const chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);\n  let srcPos = 0,\n    destPos;\n  const src = imgData.data;\n  const dest = chunkImgData.data;\n  let i, j, thisChunkHeight, elemsInThisChunk;\n  if (imgData.kind === _util.ImageKind.GRAYSCALE_1BPP) {\n    const srcLength = src.byteLength;\n    const dest32 = new Uint32Array(dest.buffer, 0, dest.byteLength >> 2);\n    const dest32DataLength = dest32.length;\n    const fullSrcDiff = width + 7 >> 3;\n    const white = 0xffffffff;\n    const black = _util.FeatureTest.isLittleEndian ? 0xff000000 : 0x000000ff;\n    for (i = 0; i < totalChunks; i++) {\n      thisChunkHeight = i < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;\n      destPos = 0;\n      for (j = 0; j < thisChunkHeight; j++) {\n        const srcDiff = srcLength - srcPos;\n        let k = 0;\n        const kEnd = srcDiff > fullSrcDiff ? width : srcDiff * 8 - 7;\n        const kEndUnrolled = kEnd & ~7;\n        let mask = 0;\n        let srcByte = 0;\n        for (; k < kEndUnrolled; k += 8) {\n          srcByte = src[srcPos++];\n          dest32[destPos++] = srcByte & 128 ? white : black;\n          dest32[destPos++] = srcByte & 64 ? white : black;\n          dest32[destPos++] = srcByte & 32 ? white : black;\n          dest32[destPos++] = srcByte & 16 ? white : black;\n          dest32[destPos++] = srcByte & 8 ? white : black;\n          dest32[destPos++] = srcByte & 4 ? white : black;\n          dest32[destPos++] = srcByte & 2 ? white : black;\n          dest32[destPos++] = srcByte & 1 ? white : black;\n        }\n        for (; k < kEnd; k++) {\n          if (mask === 0) {\n            srcByte = src[srcPos++];\n            mask = 128;\n          }\n          dest32[destPos++] = srcByte & mask ? white : black;\n          mask >>= 1;\n        }\n      }\n      while (destPos < dest32DataLength) {\n        dest32[destPos++] = 0;\n      }\n      ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);\n    }\n  } else if (imgData.kind === _util.ImageKind.RGBA_32BPP) {\n    j = 0;\n    elemsInThisChunk = width * FULL_CHUNK_HEIGHT * 4;\n    for (i = 0; i < fullChunks; i++) {\n      dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));\n      srcPos += elemsInThisChunk;\n      ctx.putImageData(chunkImgData, 0, j);\n      j += FULL_CHUNK_HEIGHT;\n    }\n    if (i < totalChunks) {\n      elemsInThisChunk = width * partialChunkHeight * 4;\n      dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));\n      ctx.putImageData(chunkImgData, 0, j);\n    }\n  } else if (imgData.kind === _util.ImageKind.RGB_24BPP) {\n    thisChunkHeight = FULL_CHUNK_HEIGHT;\n    elemsInThisChunk = width * thisChunkHeight;\n    for (i = 0; i < totalChunks; i++) {\n      if (i >= fullChunks) {\n        thisChunkHeight = partialChunkHeight;\n        elemsInThisChunk = width * thisChunkHeight;\n      }\n      destPos = 0;\n      for (j = elemsInThisChunk; j--;) {\n        dest[destPos++] = src[srcPos++];\n        dest[destPos++] = src[srcPos++];\n        dest[destPos++] = src[srcPos++];\n        dest[destPos++] = 255;\n      }\n      ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);\n    }\n  } else {\n    throw new Error(`bad image kind: ${imgData.kind}`);\n  }\n}\nfunction putBinaryImageMask(ctx, imgData) {\n  if (imgData.bitmap) {\n    ctx.drawImage(imgData.bitmap, 0, 0);\n    return;\n  }\n  const height = imgData.height,\n    width = imgData.width;\n  const partialChunkHeight = height % FULL_CHUNK_HEIGHT;\n  const fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;\n  const totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;\n  const chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);\n  let srcPos = 0;\n  const src = imgData.data;\n  const dest = chunkImgData.data;\n  for (let i = 0; i < totalChunks; i++) {\n    const thisChunkHeight = i < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;\n    ({\n      srcPos\n    } = (0, _image_utils.convertBlackAndWhiteToRGBA)({\n      src,\n      srcPos,\n      dest,\n      width,\n      height: thisChunkHeight,\n      nonBlackColor: 0\n    }));\n    ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);\n  }\n}\nfunction copyCtxState(sourceCtx, destCtx) {\n  const properties = [\"strokeStyle\", \"fillStyle\", \"fillRule\", \"globalAlpha\", \"lineWidth\", \"lineCap\", \"lineJoin\", \"miterLimit\", \"globalCompositeOperation\", \"font\", \"filter\"];\n  for (const property of properties) {\n    if (sourceCtx[property] !== undefined) {\n      destCtx[property] = sourceCtx[property];\n    }\n  }\n  if (sourceCtx.setLineDash !== undefined) {\n    destCtx.setLineDash(sourceCtx.getLineDash());\n    destCtx.lineDashOffset = sourceCtx.lineDashOffset;\n  }\n}\nfunction resetCtxToDefault(ctx) {\n  ctx.strokeStyle = ctx.fillStyle = \"#000000\";\n  ctx.fillRule = \"nonzero\";\n  ctx.globalAlpha = 1;\n  ctx.lineWidth = 1;\n  ctx.lineCap = \"butt\";\n  ctx.lineJoin = \"miter\";\n  ctx.miterLimit = 10;\n  ctx.globalCompositeOperation = \"source-over\";\n  ctx.font = \"10px sans-serif\";\n  if (ctx.setLineDash !== undefined) {\n    ctx.setLineDash([]);\n    ctx.lineDashOffset = 0;\n  }\n  if (!_util.isNodeJS) {\n    const {\n      filter\n    } = ctx;\n    if (filter !== \"none\" && filter !== \"\") {\n      ctx.filter = \"none\";\n    }\n  }\n}\nfunction composeSMaskBackdrop(bytes, r0, g0, b0) {\n  const length = bytes.length;\n  for (let i = 3; i < length; i += 4) {\n    const alpha = bytes[i];\n    if (alpha === 0) {\n      bytes[i - 3] = r0;\n      bytes[i - 2] = g0;\n      bytes[i - 1] = b0;\n    } else if (alpha < 255) {\n      const alpha_ = 255 - alpha;\n      bytes[i - 3] = bytes[i - 3] * alpha + r0 * alpha_ >> 8;\n      bytes[i - 2] = bytes[i - 2] * alpha + g0 * alpha_ >> 8;\n      bytes[i - 1] = bytes[i - 1] * alpha + b0 * alpha_ >> 8;\n    }\n  }\n}\nfunction composeSMaskAlpha(maskData, layerData, transferMap) {\n  const length = maskData.length;\n  const scale = 1 / 255;\n  for (let i = 3; i < length; i += 4) {\n    const alpha = transferMap ? transferMap[maskData[i]] : maskData[i];\n    layerData[i] = layerData[i] * alpha * scale | 0;\n  }\n}\nfunction composeSMaskLuminosity(maskData, layerData, transferMap) {\n  const length = maskData.length;\n  for (let i = 3; i < length; i += 4) {\n    const y = maskData[i - 3] * 77 + maskData[i - 2] * 152 + maskData[i - 1] * 28;\n    layerData[i] = transferMap ? layerData[i] * transferMap[y >> 8] >> 8 : layerData[i] * y >> 16;\n  }\n}\nfunction genericComposeSMask(maskCtx, layerCtx, width, height, subtype, backdrop, transferMap, layerOffsetX, layerOffsetY, maskOffsetX, maskOffsetY) {\n  const hasBackdrop = !!backdrop;\n  const r0 = hasBackdrop ? backdrop[0] : 0;\n  const g0 = hasBackdrop ? backdrop[1] : 0;\n  const b0 = hasBackdrop ? backdrop[2] : 0;\n  const composeFn = subtype === \"Luminosity\" ? composeSMaskLuminosity : composeSMaskAlpha;\n  const PIXELS_TO_PROCESS = 1048576;\n  const chunkSize = Math.min(height, Math.ceil(PIXELS_TO_PROCESS / width));\n  for (let row = 0; row < height; row += chunkSize) {\n    const chunkHeight = Math.min(chunkSize, height - row);\n    const maskData = maskCtx.getImageData(layerOffsetX - maskOffsetX, row + (layerOffsetY - maskOffsetY), width, chunkHeight);\n    const layerData = layerCtx.getImageData(layerOffsetX, row + layerOffsetY, width, chunkHeight);\n    if (hasBackdrop) {\n      composeSMaskBackdrop(maskData.data, r0, g0, b0);\n    }\n    composeFn(maskData.data, layerData.data, transferMap);\n    layerCtx.putImageData(layerData, layerOffsetX, row + layerOffsetY);\n  }\n}\nfunction composeSMask(ctx, smask, layerCtx, layerBox) {\n  const layerOffsetX = layerBox[0];\n  const layerOffsetY = layerBox[1];\n  const layerWidth = layerBox[2] - layerOffsetX;\n  const layerHeight = layerBox[3] - layerOffsetY;\n  if (layerWidth === 0 || layerHeight === 0) {\n    return;\n  }\n  genericComposeSMask(smask.context, layerCtx, layerWidth, layerHeight, smask.subtype, smask.backdrop, smask.transferMap, layerOffsetX, layerOffsetY, smask.offsetX, smask.offsetY);\n  ctx.save();\n  ctx.globalAlpha = 1;\n  ctx.globalCompositeOperation = \"source-over\";\n  ctx.setTransform(1, 0, 0, 1, 0, 0);\n  ctx.drawImage(layerCtx.canvas, 0, 0);\n  ctx.restore();\n}\nfunction getImageSmoothingEnabled(transform, interpolate) {\n  const scale = _util.Util.singularValueDecompose2dScale(transform);\n  scale[0] = Math.fround(scale[0]);\n  scale[1] = Math.fround(scale[1]);\n  const actualScale = Math.fround((globalThis.devicePixelRatio || 1) * _display_utils.PixelsPerInch.PDF_TO_CSS_UNITS);\n  if (interpolate !== undefined) {\n    return interpolate;\n  } else if (scale[0] <= actualScale || scale[1] <= actualScale) {\n    return true;\n  }\n  return false;\n}\nconst LINE_CAP_STYLES = [\"butt\", \"round\", \"square\"];\nconst LINE_JOIN_STYLES = [\"miter\", \"round\", \"bevel\"];\nconst NORMAL_CLIP = {};\nconst EO_CLIP = {};\nclass CanvasGraphics {\n  constructor(canvasCtx, commonObjs, objs, canvasFactory, filterFactory, {\n    optionalContentConfig,\n    markedContentStack = null\n  }, annotationCanvasMap, pageColors) {\n    this.ctx = canvasCtx;\n    this.current = new CanvasExtraState(this.ctx.canvas.width, this.ctx.canvas.height);\n    this.stateStack = [];\n    this.pendingClip = null;\n    this.pendingEOFill = false;\n    this.res = null;\n    this.xobjs = null;\n    this.commonObjs = commonObjs;\n    this.objs = objs;\n    this.canvasFactory = canvasFactory;\n    this.filterFactory = filterFactory;\n    this.groupStack = [];\n    this.processingType3 = null;\n    this.baseTransform = null;\n    this.baseTransformStack = [];\n    this.groupLevel = 0;\n    this.smaskStack = [];\n    this.smaskCounter = 0;\n    this.tempSMask = null;\n    this.suspendedCtx = null;\n    this.contentVisible = true;\n    this.markedContentStack = markedContentStack || [];\n    this.optionalContentConfig = optionalContentConfig;\n    this.cachedCanvases = new CachedCanvases(this.canvasFactory);\n    this.cachedPatterns = new Map();\n    this.annotationCanvasMap = annotationCanvasMap;\n    this.viewportScale = 1;\n    this.outputScaleX = 1;\n    this.outputScaleY = 1;\n    this.pageColors = pageColors;\n    this._cachedScaleForStroking = [-1, 0];\n    this._cachedGetSinglePixelWidth = null;\n    this._cachedBitmapsMap = new Map();\n  }\n  getObject(data, fallback = null) {\n    if (typeof data === \"string\") {\n      return data.startsWith(\"g_\") ? this.commonObjs.get(data) : this.objs.get(data);\n    }\n    return fallback;\n  }\n  beginDrawing({\n    transform,\n    viewport,\n    transparency = false,\n    background = null\n  }) {\n    const width = this.ctx.canvas.width;\n    const height = this.ctx.canvas.height;\n    const savedFillStyle = this.ctx.fillStyle;\n    this.ctx.fillStyle = background || \"#ffffff\";\n    this.ctx.fillRect(0, 0, width, height);\n    this.ctx.fillStyle = savedFillStyle;\n    if (transparency) {\n      const transparentCanvas = this.cachedCanvases.getCanvas(\"transparent\", width, height);\n      this.compositeCtx = this.ctx;\n      this.transparentCanvas = transparentCanvas.canvas;\n      this.ctx = transparentCanvas.context;\n      this.ctx.save();\n      this.ctx.transform(...(0, _display_utils.getCurrentTransform)(this.compositeCtx));\n    }\n    this.ctx.save();\n    resetCtxToDefault(this.ctx);\n    if (transform) {\n      this.ctx.transform(...transform);\n      this.outputScaleX = transform[0];\n      this.outputScaleY = transform[0];\n    }\n    this.ctx.transform(...viewport.transform);\n    this.viewportScale = viewport.scale;\n    this.baseTransform = (0, _display_utils.getCurrentTransform)(this.ctx);\n  }\n  executeOperatorList(operatorList, executionStartIdx, continueCallback, stepper) {\n    const argsArray = operatorList.argsArray;\n    const fnArray = operatorList.fnArray;\n    let i = executionStartIdx || 0;\n    const argsArrayLen = argsArray.length;\n    if (argsArrayLen === i) {\n      return i;\n    }\n    const chunkOperations = argsArrayLen - i > EXECUTION_STEPS && typeof continueCallback === \"function\";\n    const endTime = chunkOperations ? Date.now() + EXECUTION_TIME : 0;\n    let steps = 0;\n    const commonObjs = this.commonObjs;\n    const objs = this.objs;\n    let fnId;\n    while (true) {\n      if (stepper !== undefined && i === stepper.nextBreakPoint) {\n        stepper.breakIt(i, continueCallback);\n        return i;\n      }\n      fnId = fnArray[i];\n      if (fnId !== _util.OPS.dependency) {\n        this[fnId].apply(this, argsArray[i]);\n      } else {\n        for (const depObjId of argsArray[i]) {\n          const objsPool = depObjId.startsWith(\"g_\") ? commonObjs : objs;\n          if (!objsPool.has(depObjId)) {\n            objsPool.get(depObjId, continueCallback);\n            return i;\n          }\n        }\n      }\n      i++;\n      if (i === argsArrayLen) {\n        return i;\n      }\n      if (chunkOperations && ++steps > EXECUTION_STEPS) {\n        if (Date.now() > endTime) {\n          continueCallback();\n          return i;\n        }\n        steps = 0;\n      }\n    }\n  }\n  #restoreInitialState() {\n    while (this.stateStack.length || this.inSMaskMode) {\n      this.restore();\n    }\n    this.ctx.restore();\n    if (this.transparentCanvas) {\n      this.ctx = this.compositeCtx;\n      this.ctx.save();\n      this.ctx.setTransform(1, 0, 0, 1, 0, 0);\n      this.ctx.drawImage(this.transparentCanvas, 0, 0);\n      this.ctx.restore();\n      this.transparentCanvas = null;\n    }\n  }\n  endDrawing() {\n    this.#restoreInitialState();\n    this.cachedCanvases.clear();\n    this.cachedPatterns.clear();\n    for (const cache of this._cachedBitmapsMap.values()) {\n      for (const canvas of cache.values()) {\n        if (typeof HTMLCanvasElement !== \"undefined\" && canvas instanceof HTMLCanvasElement) {\n          canvas.width = canvas.height = 0;\n        }\n      }\n      cache.clear();\n    }\n    this._cachedBitmapsMap.clear();\n    this.#drawFilter();\n  }\n  #drawFilter() {\n    if (this.pageColors) {\n      const hcmFilterId = this.filterFactory.addHCMFilter(this.pageColors.foreground, this.pageColors.background);\n      if (hcmFilterId !== \"none\") {\n        const savedFilter = this.ctx.filter;\n        this.ctx.filter = hcmFilterId;\n        this.ctx.drawImage(this.ctx.canvas, 0, 0);\n        this.ctx.filter = savedFilter;\n      }\n    }\n  }\n  _scaleImage(img, inverseTransform) {\n    const width = img.width;\n    const height = img.height;\n    let widthScale = Math.max(Math.hypot(inverseTransform[0], inverseTransform[1]), 1);\n    let heightScale = Math.max(Math.hypot(inverseTransform[2], inverseTransform[3]), 1);\n    let paintWidth = width,\n      paintHeight = height;\n    let tmpCanvasId = \"prescale1\";\n    let tmpCanvas, tmpCtx;\n    while (widthScale > 2 && paintWidth > 1 || heightScale > 2 && paintHeight > 1) {\n      let newWidth = paintWidth,\n        newHeight = paintHeight;\n      if (widthScale > 2 && paintWidth > 1) {\n        newWidth = paintWidth >= 16384 ? Math.floor(paintWidth / 2) - 1 || 1 : Math.ceil(paintWidth / 2);\n        widthScale /= paintWidth / newWidth;\n      }\n      if (heightScale > 2 && paintHeight > 1) {\n        newHeight = paintHeight >= 16384 ? Math.floor(paintHeight / 2) - 1 || 1 : Math.ceil(paintHeight) / 2;\n        heightScale /= paintHeight / newHeight;\n      }\n      tmpCanvas = this.cachedCanvases.getCanvas(tmpCanvasId, newWidth, newHeight);\n      tmpCtx = tmpCanvas.context;\n      tmpCtx.clearRect(0, 0, newWidth, newHeight);\n      tmpCtx.drawImage(img, 0, 0, paintWidth, paintHeight, 0, 0, newWidth, newHeight);\n      img = tmpCanvas.canvas;\n      paintWidth = newWidth;\n      paintHeight = newHeight;\n      tmpCanvasId = tmpCanvasId === \"prescale1\" ? \"prescale2\" : \"prescale1\";\n    }\n    return {\n      img,\n      paintWidth,\n      paintHeight\n    };\n  }\n  _createMaskCanvas(img) {\n    const ctx = this.ctx;\n    const {\n      width,\n      height\n    } = img;\n    const fillColor = this.current.fillColor;\n    const isPatternFill = this.current.patternFill;\n    const currentTransform = (0, _display_utils.getCurrentTransform)(ctx);\n    let cache, cacheKey, scaled, maskCanvas;\n    if ((img.bitmap || img.data) && img.count > 1) {\n      const mainKey = img.bitmap || img.data.buffer;\n      cacheKey = JSON.stringify(isPatternFill ? currentTransform : [currentTransform.slice(0, 4), fillColor]);\n      cache = this._cachedBitmapsMap.get(mainKey);\n      if (!cache) {\n        cache = new Map();\n        this._cachedBitmapsMap.set(mainKey, cache);\n      }\n      const cachedImage = cache.get(cacheKey);\n      if (cachedImage && !isPatternFill) {\n        const offsetX = Math.round(Math.min(currentTransform[0], currentTransform[2]) + currentTransform[4]);\n        const offsetY = Math.round(Math.min(currentTransform[1], currentTransform[3]) + currentTransform[5]);\n        return {\n          canvas: cachedImage,\n          offsetX,\n          offsetY\n        };\n      }\n      scaled = cachedImage;\n    }\n    if (!scaled) {\n      maskCanvas = this.cachedCanvases.getCanvas(\"maskCanvas\", width, height);\n      putBinaryImageMask(maskCanvas.context, img);\n    }\n    let maskToCanvas = _util.Util.transform(currentTransform, [1 / width, 0, 0, -1 / height, 0, 0]);\n    maskToCanvas = _util.Util.transform(maskToCanvas, [1, 0, 0, 1, 0, -height]);\n    const cord1 = _util.Util.applyTransform([0, 0], maskToCanvas);\n    const cord2 = _util.Util.applyTransform([width, height], maskToCanvas);\n    const rect = _util.Util.normalizeRect([cord1[0], cord1[1], cord2[0], cord2[1]]);\n    const drawnWidth = Math.round(rect[2] - rect[0]) || 1;\n    const drawnHeight = Math.round(rect[3] - rect[1]) || 1;\n    const fillCanvas = this.cachedCanvases.getCanvas(\"fillCanvas\", drawnWidth, drawnHeight);\n    const fillCtx = fillCanvas.context;\n    const offsetX = Math.min(cord1[0], cord2[0]);\n    const offsetY = Math.min(cord1[1], cord2[1]);\n    fillCtx.translate(-offsetX, -offsetY);\n    fillCtx.transform(...maskToCanvas);\n    if (!scaled) {\n      scaled = this._scaleImage(maskCanvas.canvas, (0, _display_utils.getCurrentTransformInverse)(fillCtx));\n      scaled = scaled.img;\n      if (cache && isPatternFill) {\n        cache.set(cacheKey, scaled);\n      }\n    }\n    fillCtx.imageSmoothingEnabled = getImageSmoothingEnabled((0, _display_utils.getCurrentTransform)(fillCtx), img.interpolate);\n    drawImageAtIntegerCoords(fillCtx, scaled, 0, 0, scaled.width, scaled.height, 0, 0, width, height);\n    fillCtx.globalCompositeOperation = \"source-in\";\n    const inverse = _util.Util.transform((0, _display_utils.getCurrentTransformInverse)(fillCtx), [1, 0, 0, 1, -offsetX, -offsetY]);\n    fillCtx.fillStyle = isPatternFill ? fillColor.getPattern(ctx, this, inverse, _pattern_helper.PathType.FILL) : fillColor;\n    fillCtx.fillRect(0, 0, width, height);\n    if (cache && !isPatternFill) {\n      this.cachedCanvases.delete(\"fillCanvas\");\n      cache.set(cacheKey, fillCanvas.canvas);\n    }\n    return {\n      canvas: fillCanvas.canvas,\n      offsetX: Math.round(offsetX),\n      offsetY: Math.round(offsetY)\n    };\n  }\n  setLineWidth(width) {\n    if (width !== this.current.lineWidth) {\n      this._cachedScaleForStroking[0] = -1;\n    }\n    this.current.lineWidth = width;\n    this.ctx.lineWidth = width;\n  }\n  setLineCap(style) {\n    this.ctx.lineCap = LINE_CAP_STYLES[style];\n  }\n  setLineJoin(style) {\n    this.ctx.lineJoin = LINE_JOIN_STYLES[style];\n  }\n  setMiterLimit(limit) {\n    this.ctx.miterLimit = limit;\n  }\n  setDash(dashArray, dashPhase) {\n    const ctx = this.ctx;\n    if (ctx.setLineDash !== undefined) {\n      ctx.setLineDash(dashArray);\n      ctx.lineDashOffset = dashPhase;\n    }\n  }\n  setRenderingIntent(intent) {}\n  setFlatness(flatness) {}\n  setGState(states) {\n    for (const [key, value] of states) {\n      switch (key) {\n        case \"LW\":\n          this.setLineWidth(value);\n          break;\n        case \"LC\":\n          this.setLineCap(value);\n          break;\n        case \"LJ\":\n          this.setLineJoin(value);\n          break;\n        case \"ML\":\n          this.setMiterLimit(value);\n          break;\n        case \"D\":\n          this.setDash(value[0], value[1]);\n          break;\n        case \"RI\":\n          this.setRenderingIntent(value);\n          break;\n        case \"FL\":\n          this.setFlatness(value);\n          break;\n        case \"Font\":\n          this.setFont(value[0], value[1]);\n          break;\n        case \"CA\":\n          this.current.strokeAlpha = value;\n          break;\n        case \"ca\":\n          this.current.fillAlpha = value;\n          this.ctx.globalAlpha = value;\n          break;\n        case \"BM\":\n          this.ctx.globalCompositeOperation = value;\n          break;\n        case \"SMask\":\n          this.current.activeSMask = value ? this.tempSMask : null;\n          this.tempSMask = null;\n          this.checkSMaskState();\n          break;\n        case \"TR\":\n          this.ctx.filter = this.current.transferMaps = this.filterFactory.addFilter(value);\n          break;\n      }\n    }\n  }\n  get inSMaskMode() {\n    return !!this.suspendedCtx;\n  }\n  checkSMaskState() {\n    const inSMaskMode = this.inSMaskMode;\n    if (this.current.activeSMask && !inSMaskMode) {\n      this.beginSMaskMode();\n    } else if (!this.current.activeSMask && inSMaskMode) {\n      this.endSMaskMode();\n    }\n  }\n  beginSMaskMode() {\n    if (this.inSMaskMode) {\n      throw new Error(\"beginSMaskMode called while already in smask mode\");\n    }\n    const drawnWidth = this.ctx.canvas.width;\n    const drawnHeight = this.ctx.canvas.height;\n    const cacheId = \"smaskGroupAt\" + this.groupLevel;\n    const scratchCanvas = this.cachedCanvases.getCanvas(cacheId, drawnWidth, drawnHeight);\n    this.suspendedCtx = this.ctx;\n    this.ctx = scratchCanvas.context;\n    const ctx = this.ctx;\n    ctx.setTransform(...(0, _display_utils.getCurrentTransform)(this.suspendedCtx));\n    copyCtxState(this.suspendedCtx, ctx);\n    mirrorContextOperations(ctx, this.suspendedCtx);\n    this.setGState([[\"BM\", \"source-over\"], [\"ca\", 1], [\"CA\", 1]]);\n  }\n  endSMaskMode() {\n    if (!this.inSMaskMode) {\n      throw new Error(\"endSMaskMode called while not in smask mode\");\n    }\n    this.ctx._removeMirroring();\n    copyCtxState(this.ctx, this.suspendedCtx);\n    this.ctx = this.suspendedCtx;\n    this.suspendedCtx = null;\n  }\n  compose(dirtyBox) {\n    if (!this.current.activeSMask) {\n      return;\n    }\n    if (!dirtyBox) {\n      dirtyBox = [0, 0, this.ctx.canvas.width, this.ctx.canvas.height];\n    } else {\n      dirtyBox[0] = Math.floor(dirtyBox[0]);\n      dirtyBox[1] = Math.floor(dirtyBox[1]);\n      dirtyBox[2] = Math.ceil(dirtyBox[2]);\n      dirtyBox[3] = Math.ceil(dirtyBox[3]);\n    }\n    const smask = this.current.activeSMask;\n    const suspendedCtx = this.suspendedCtx;\n    composeSMask(suspendedCtx, smask, this.ctx, dirtyBox);\n    this.ctx.save();\n    this.ctx.setTransform(1, 0, 0, 1, 0, 0);\n    this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height);\n    this.ctx.restore();\n  }\n  save() {\n    if (this.inSMaskMode) {\n      copyCtxState(this.ctx, this.suspendedCtx);\n      this.suspendedCtx.save();\n    } else {\n      this.ctx.save();\n    }\n    const old = this.current;\n    this.stateStack.push(old);\n    this.current = old.clone();\n  }\n  restore() {\n    if (this.stateStack.length === 0 && this.inSMaskMode) {\n      this.endSMaskMode();\n    }\n    if (this.stateStack.length !== 0) {\n      this.current = this.stateStack.pop();\n      if (this.inSMaskMode) {\n        this.suspendedCtx.restore();\n        copyCtxState(this.suspendedCtx, this.ctx);\n      } else {\n        this.ctx.restore();\n      }\n      this.checkSMaskState();\n      this.pendingClip = null;\n      this._cachedScaleForStroking[0] = -1;\n      this._cachedGetSinglePixelWidth = null;\n    }\n  }\n  transform(a, b, c, d, e, f) {\n    this.ctx.transform(a, b, c, d, e, f);\n    this._cachedScaleForStroking[0] = -1;\n    this._cachedGetSinglePixelWidth = null;\n  }\n  constructPath(ops, args, minMax) {\n    const ctx = this.ctx;\n    const current = this.current;\n    let x = current.x,\n      y = current.y;\n    let startX, startY;\n    const currentTransform = (0, _display_utils.getCurrentTransform)(ctx);\n    const isScalingMatrix = currentTransform[0] === 0 && currentTransform[3] === 0 || currentTransform[1] === 0 && currentTransform[2] === 0;\n    const minMaxForBezier = isScalingMatrix ? minMax.slice(0) : null;\n    for (let i = 0, j = 0, ii = ops.length; i < ii; i++) {\n      switch (ops[i] | 0) {\n        case _util.OPS.rectangle:\n          x = args[j++];\n          y = args[j++];\n          const width = args[j++];\n          const height = args[j++];\n          const xw = x + width;\n          const yh = y + height;\n          ctx.moveTo(x, y);\n          if (width === 0 || height === 0) {\n            ctx.lineTo(xw, yh);\n          } else {\n            ctx.lineTo(xw, y);\n            ctx.lineTo(xw, yh);\n            ctx.lineTo(x, yh);\n          }\n          if (!isScalingMatrix) {\n            current.updateRectMinMax(currentTransform, [x, y, xw, yh]);\n          }\n          ctx.closePath();\n          break;\n        case _util.OPS.moveTo:\n          x = args[j++];\n          y = args[j++];\n          ctx.moveTo(x, y);\n          if (!isScalingMatrix) {\n            current.updatePathMinMax(currentTransform, x, y);\n          }\n          break;\n        case _util.OPS.lineTo:\n          x = args[j++];\n          y = args[j++];\n          ctx.lineTo(x, y);\n          if (!isScalingMatrix) {\n            current.updatePathMinMax(currentTransform, x, y);\n          }\n          break;\n        case _util.OPS.curveTo:\n          startX = x;\n          startY = y;\n          x = args[j + 4];\n          y = args[j + 5];\n          ctx.bezierCurveTo(args[j], args[j + 1], args[j + 2], args[j + 3], x, y);\n          current.updateCurvePathMinMax(currentTransform, startX, startY, args[j], args[j + 1], args[j + 2], args[j + 3], x, y, minMaxForBezier);\n          j += 6;\n          break;\n        case _util.OPS.curveTo2:\n          startX = x;\n          startY = y;\n          ctx.bezierCurveTo(x, y, args[j], args[j + 1], args[j + 2], args[j + 3]);\n          current.updateCurvePathMinMax(currentTransform, startX, startY, x, y, args[j], args[j + 1], args[j + 2], args[j + 3], minMaxForBezier);\n          x = args[j + 2];\n          y = args[j + 3];\n          j += 4;\n          break;\n        case _util.OPS.curveTo3:\n          startX = x;\n          startY = y;\n          x = args[j + 2];\n          y = args[j + 3];\n          ctx.bezierCurveTo(args[j], args[j + 1], x, y, x, y);\n          current.updateCurvePathMinMax(currentTransform, startX, startY, args[j], args[j + 1], x, y, x, y, minMaxForBezier);\n          j += 4;\n          break;\n        case _util.OPS.closePath:\n          ctx.closePath();\n          break;\n      }\n    }\n    if (isScalingMatrix) {\n      current.updateScalingPathMinMax(currentTransform, minMaxForBezier);\n    }\n    current.setCurrentPoint(x, y);\n  }\n  closePath() {\n    this.ctx.closePath();\n  }\n  stroke(consumePath = true) {\n    const ctx = this.ctx;\n    const strokeColor = this.current.strokeColor;\n    ctx.globalAlpha = this.current.strokeAlpha;\n    if (this.contentVisible) {\n      if (typeof strokeColor === \"object\" && strokeColor?.getPattern) {\n        ctx.save();\n        ctx.strokeStyle = strokeColor.getPattern(ctx, this, (0, _display_utils.getCurrentTransformInverse)(ctx), _pattern_helper.PathType.STROKE);\n        this.rescaleAndStroke(false);\n        ctx.restore();\n      } else {\n        this.rescaleAndStroke(true);\n      }\n    }\n    if (consumePath) {\n      this.consumePath(this.current.getClippedPathBoundingBox());\n    }\n    ctx.globalAlpha = this.current.fillAlpha;\n  }\n  closeStroke() {\n    this.closePath();\n    this.stroke();\n  }\n  fill(consumePath = true) {\n    const ctx = this.ctx;\n    const fillColor = this.current.fillColor;\n    const isPatternFill = this.current.patternFill;\n    let needRestore = false;\n    if (isPatternFill) {\n      ctx.save();\n      ctx.fillStyle = fillColor.getPattern(ctx, this, (0, _display_utils.getCurrentTransformInverse)(ctx), _pattern_helper.PathType.FILL);\n      needRestore = true;\n    }\n    const intersect = this.current.getClippedPathBoundingBox();\n    if (this.contentVisible && intersect !== null) {\n      if (this.pendingEOFill) {\n        ctx.fill(\"evenodd\");\n        this.pendingEOFill = false;\n      } else {\n        ctx.fill();\n      }\n    }\n    if (needRestore) {\n      ctx.restore();\n    }\n    if (consumePath) {\n      this.consumePath(intersect);\n    }\n  }\n  eoFill() {\n    this.pendingEOFill = true;\n    this.fill();\n  }\n  fillStroke() {\n    this.fill(false);\n    this.stroke(false);\n    this.consumePath();\n  }\n  eoFillStroke() {\n    this.pendingEOFill = true;\n    this.fillStroke();\n  }\n  closeFillStroke() {\n    this.closePath();\n    this.fillStroke();\n  }\n  closeEOFillStroke() {\n    this.pendingEOFill = true;\n    this.closePath();\n    this.fillStroke();\n  }\n  endPath() {\n    this.consumePath();\n  }\n  clip() {\n    this.pendingClip = NORMAL_CLIP;\n  }\n  eoClip() {\n    this.pendingClip = EO_CLIP;\n  }\n  beginText() {\n    this.current.textMatrix = _util.IDENTITY_MATRIX;\n    this.current.textMatrixScale = 1;\n    this.current.x = this.current.lineX = 0;\n    this.current.y = this.current.lineY = 0;\n  }\n  endText() {\n    const paths = this.pendingTextPaths;\n    const ctx = this.ctx;\n    if (paths === undefined) {\n      ctx.beginPath();\n      return;\n    }\n    ctx.save();\n    ctx.beginPath();\n    for (const path of paths) {\n      ctx.setTransform(...path.transform);\n      ctx.translate(path.x, path.y);\n      path.addToPath(ctx, path.fontSize);\n    }\n    ctx.restore();\n    ctx.clip();\n    ctx.beginPath();\n    delete this.pendingTextPaths;\n  }\n  setCharSpacing(spacing) {\n    this.current.charSpacing = spacing;\n  }\n  setWordSpacing(spacing) {\n    this.current.wordSpacing = spacing;\n  }\n  setHScale(scale) {\n    this.current.textHScale = scale / 100;\n  }\n  setLeading(leading) {\n    this.current.leading = -leading;\n  }\n  setFont(fontRefName, size) {\n    const fontObj = this.commonObjs.get(fontRefName);\n    const current = this.current;\n    if (!fontObj) {\n      throw new Error(`Can't find font for ${fontRefName}`);\n    }\n    current.fontMatrix = fontObj.fontMatrix || _util.FONT_IDENTITY_MATRIX;\n    if (current.fontMatrix[0] === 0 || current.fontMatrix[3] === 0) {\n      (0, _util.warn)(\"Invalid font matrix for font \" + fontRefName);\n    }\n    if (size < 0) {\n      size = -size;\n      current.fontDirection = -1;\n    } else {\n      current.fontDirection = 1;\n    }\n    this.current.font = fontObj;\n    this.current.fontSize = size;\n    if (fontObj.isType3Font) {\n      return;\n    }\n    const name = fontObj.loadedName || \"sans-serif\";\n    const typeface = fontObj.systemFontInfo?.css || `\"${name}\", ${fontObj.fallbackName}`;\n    let bold = \"normal\";\n    if (fontObj.black) {\n      bold = \"900\";\n    } else if (fontObj.bold) {\n      bold = \"bold\";\n    }\n    const italic = fontObj.italic ? \"italic\" : \"normal\";\n    let browserFontSize = size;\n    if (size < MIN_FONT_SIZE) {\n      browserFontSize = MIN_FONT_SIZE;\n    } else if (size > MAX_FONT_SIZE) {\n      browserFontSize = MAX_FONT_SIZE;\n    }\n    this.current.fontSizeScale = size / browserFontSize;\n    this.ctx.font = `${italic} ${bold} ${browserFontSize}px ${typeface}`;\n  }\n  setTextRenderingMode(mode) {\n    this.current.textRenderingMode = mode;\n  }\n  setTextRise(rise) {\n    this.current.textRise = rise;\n  }\n  moveText(x, y) {\n    this.current.x = this.current.lineX += x;\n    this.current.y = this.current.lineY += y;\n  }\n  setLeadingMoveText(x, y) {\n    this.setLeading(-y);\n    this.moveText(x, y);\n  }\n  setTextMatrix(a, b, c, d, e, f) {\n    this.current.textMatrix = [a, b, c, d, e, f];\n    this.current.textMatrixScale = Math.hypot(a, b);\n    this.current.x = this.current.lineX = 0;\n    this.current.y = this.current.lineY = 0;\n  }\n  nextLine() {\n    this.moveText(0, this.current.leading);\n  }\n  paintChar(character, x, y, patternTransform) {\n    const ctx = this.ctx;\n    const current = this.current;\n    const font = current.font;\n    const textRenderingMode = current.textRenderingMode;\n    const fontSize = current.fontSize / current.fontSizeScale;\n    const fillStrokeMode = textRenderingMode & _util.TextRenderingMode.FILL_STROKE_MASK;\n    const isAddToPathSet = !!(textRenderingMode & _util.TextRenderingMode.ADD_TO_PATH_FLAG);\n    const patternFill = current.patternFill && !font.missingFile;\n    let addToPath;\n    if (font.disableFontFace || isAddToPathSet || patternFill) {\n      addToPath = font.getPathGenerator(this.commonObjs, character);\n    }\n    if (font.disableFontFace || patternFill) {\n      ctx.save();\n      ctx.translate(x, y);\n      ctx.beginPath();\n      addToPath(ctx, fontSize);\n      if (patternTransform) {\n        ctx.setTransform(...patternTransform);\n      }\n      if (fillStrokeMode === _util.TextRenderingMode.FILL || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {\n        ctx.fill();\n      }\n      if (fillStrokeMode === _util.TextRenderingMode.STROKE || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {\n        ctx.stroke();\n      }\n      ctx.restore();\n    } else {\n      if (fillStrokeMode === _util.TextRenderingMode.FILL || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {\n        ctx.fillText(character, x, y);\n      }\n      if (fillStrokeMode === _util.TextRenderingMode.STROKE || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {\n        ctx.strokeText(character, x, y);\n      }\n    }\n    if (isAddToPathSet) {\n      const paths = this.pendingTextPaths ||= [];\n      paths.push({\n        transform: (0, _display_utils.getCurrentTransform)(ctx),\n        x,\n        y,\n        fontSize,\n        addToPath\n      });\n    }\n  }\n  get isFontSubpixelAAEnabled() {\n    const {\n      context: ctx\n    } = this.cachedCanvases.getCanvas(\"isFontSubpixelAAEnabled\", 10, 10);\n    ctx.scale(1.5, 1);\n    ctx.fillText(\"I\", 0, 10);\n    const data = ctx.getImageData(0, 0, 10, 10).data;\n    let enabled = false;\n    for (let i = 3; i < data.length; i += 4) {\n      if (data[i] > 0 && data[i] < 255) {\n        enabled = true;\n        break;\n      }\n    }\n    return (0, _util.shadow)(this, \"isFontSubpixelAAEnabled\", enabled);\n  }\n  showText(glyphs) {\n    const current = this.current;\n    const font = current.font;\n    if (font.isType3Font) {\n      return this.showType3Text(glyphs);\n    }\n    const fontSize = current.fontSize;\n    if (fontSize === 0) {\n      return undefined;\n    }\n    const ctx = this.ctx;\n    const fontSizeScale = current.fontSizeScale;\n    const charSpacing = current.charSpacing;\n    const wordSpacing = current.wordSpacing;\n    const fontDirection = current.fontDirection;\n    const textHScale = current.textHScale * fontDirection;\n    const glyphsLength = glyphs.length;\n    const vertical = font.vertical;\n    const spacingDir = vertical ? 1 : -1;\n    const defaultVMetrics = font.defaultVMetrics;\n    const widthAdvanceScale = fontSize * current.fontMatrix[0];\n    const simpleFillText = current.textRenderingMode === _util.TextRenderingMode.FILL && !font.disableFontFace && !current.patternFill;\n    ctx.save();\n    ctx.transform(...current.textMatrix);\n    ctx.translate(current.x, current.y + current.textRise);\n    if (fontDirection > 0) {\n      ctx.scale(textHScale, -1);\n    } else {\n      ctx.scale(textHScale, 1);\n    }\n    let patternTransform;\n    if (current.patternFill) {\n      ctx.save();\n      const pattern = current.fillColor.getPattern(ctx, this, (0, _display_utils.getCurrentTransformInverse)(ctx), _pattern_helper.PathType.FILL);\n      patternTransform = (0, _display_utils.getCurrentTransform)(ctx);\n      ctx.restore();\n      ctx.fillStyle = pattern;\n    }\n    let lineWidth = current.lineWidth;\n    const scale = current.textMatrixScale;\n    if (scale === 0 || lineWidth === 0) {\n      const fillStrokeMode = current.textRenderingMode & _util.TextRenderingMode.FILL_STROKE_MASK;\n      if (fillStrokeMode === _util.TextRenderingMode.STROKE || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {\n        lineWidth = this.getSinglePixelWidth();\n      }\n    } else {\n      lineWidth /= scale;\n    }\n    if (fontSizeScale !== 1.0) {\n      ctx.scale(fontSizeScale, fontSizeScale);\n      lineWidth /= fontSizeScale;\n    }\n    ctx.lineWidth = lineWidth;\n    if (font.isInvalidPDFjsFont) {\n      const chars = [];\n      let width = 0;\n      for (const glyph of glyphs) {\n        chars.push(glyph.unicode);\n        width += glyph.width;\n      }\n      ctx.fillText(chars.join(\"\"), 0, 0);\n      current.x += width * widthAdvanceScale * textHScale;\n      ctx.restore();\n      this.compose();\n      return undefined;\n    }\n    let x = 0,\n      i;\n    for (i = 0; i < glyphsLength; ++i) {\n      const glyph = glyphs[i];\n      if (typeof glyph === \"number\") {\n        x += spacingDir * glyph * fontSize / 1000;\n        continue;\n      }\n      let restoreNeeded = false;\n      const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;\n      const character = glyph.fontChar;\n      const accent = glyph.accent;\n      let scaledX, scaledY;\n      let width = glyph.width;\n      if (vertical) {\n        const vmetric = glyph.vmetric || defaultVMetrics;\n        const vx = -(glyph.vmetric ? vmetric[1] : width * 0.5) * widthAdvanceScale;\n        const vy = vmetric[2] * widthAdvanceScale;\n        width = vmetric ? -vmetric[0] : width;\n        scaledX = vx / fontSizeScale;\n        scaledY = (x + vy) / fontSizeScale;\n      } else {\n        scaledX = x / fontSizeScale;\n        scaledY = 0;\n      }\n      if (font.remeasure && width > 0) {\n        const measuredWidth = ctx.measureText(character).width * 1000 / fontSize * fontSizeScale;\n        if (width < measuredWidth && this.isFontSubpixelAAEnabled) {\n          const characterScaleX = width / measuredWidth;\n          restoreNeeded = true;\n          ctx.save();\n          ctx.scale(characterScaleX, 1);\n          scaledX /= characterScaleX;\n        } else if (width !== measuredWidth) {\n          scaledX += (width - measuredWidth) / 2000 * fontSize / fontSizeScale;\n        }\n      }\n      if (this.contentVisible && (glyph.isInFont || font.missingFile)) {\n        if (simpleFillText && !accent) {\n          ctx.fillText(character, scaledX, scaledY);\n        } else {\n          this.paintChar(character, scaledX, scaledY, patternTransform);\n          if (accent) {\n            const scaledAccentX = scaledX + fontSize * accent.offset.x / fontSizeScale;\n            const scaledAccentY = scaledY - fontSize * accent.offset.y / fontSizeScale;\n            this.paintChar(accent.fontChar, scaledAccentX, scaledAccentY, patternTransform);\n          }\n        }\n      }\n      const charWidth = vertical ? width * widthAdvanceScale - spacing * fontDirection : width * widthAdvanceScale + spacing * fontDirection;\n      x += charWidth;\n      if (restoreNeeded) {\n        ctx.restore();\n      }\n    }\n    if (vertical) {\n      current.y -= x;\n    } else {\n      current.x += x * textHScale;\n    }\n    ctx.restore();\n    this.compose();\n    return undefined;\n  }\n  showType3Text(glyphs) {\n    const ctx = this.ctx;\n    const current = this.current;\n    const font = current.font;\n    const fontSize = current.fontSize;\n    const fontDirection = current.fontDirection;\n    const spacingDir = font.vertical ? 1 : -1;\n    const charSpacing = current.charSpacing;\n    const wordSpacing = current.wordSpacing;\n    const textHScale = current.textHScale * fontDirection;\n    const fontMatrix = current.fontMatrix || _util.FONT_IDENTITY_MATRIX;\n    const glyphsLength = glyphs.length;\n    const isTextInvisible = current.textRenderingMode === _util.TextRenderingMode.INVISIBLE;\n    let i, glyph, width, spacingLength;\n    if (isTextInvisible || fontSize === 0) {\n      return;\n    }\n    this._cachedScaleForStroking[0] = -1;\n    this._cachedGetSinglePixelWidth = null;\n    ctx.save();\n    ctx.transform(...current.textMatrix);\n    ctx.translate(current.x, current.y);\n    ctx.scale(textHScale, fontDirection);\n    for (i = 0; i < glyphsLength; ++i) {\n      glyph = glyphs[i];\n      if (typeof glyph === \"number\") {\n        spacingLength = spacingDir * glyph * fontSize / 1000;\n        this.ctx.translate(spacingLength, 0);\n        current.x += spacingLength * textHScale;\n        continue;\n      }\n      const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;\n      const operatorList = font.charProcOperatorList[glyph.operatorListId];\n      if (!operatorList) {\n        (0, _util.warn)(`Type3 character \"${glyph.operatorListId}\" is not available.`);\n        continue;\n      }\n      if (this.contentVisible) {\n        this.processingType3 = glyph;\n        this.save();\n        ctx.scale(fontSize, fontSize);\n        ctx.transform(...fontMatrix);\n        this.executeOperatorList(operatorList);\n        this.restore();\n      }\n      const transformed = _util.Util.applyTransform([glyph.width, 0], fontMatrix);\n      width = transformed[0] * fontSize + spacing;\n      ctx.translate(width, 0);\n      current.x += width * textHScale;\n    }\n    ctx.restore();\n    this.processingType3 = null;\n  }\n  setCharWidth(xWidth, yWidth) {}\n  setCharWidthAndBounds(xWidth, yWidth, llx, lly, urx, ury) {\n    this.ctx.rect(llx, lly, urx - llx, ury - lly);\n    this.ctx.clip();\n    this.endPath();\n  }\n  getColorN_Pattern(IR) {\n    let pattern;\n    if (IR[0] === \"TilingPattern\") {\n      const color = IR[1];\n      const baseTransform = this.baseTransform || (0, _display_utils.getCurrentTransform)(this.ctx);\n      const canvasGraphicsFactory = {\n        createCanvasGraphics: ctx => {\n          return new CanvasGraphics(ctx, this.commonObjs, this.objs, this.canvasFactory, this.filterFactory, {\n            optionalContentConfig: this.optionalContentConfig,\n            markedContentStack: this.markedContentStack\n          });\n        }\n      };\n      pattern = new _pattern_helper.TilingPattern(IR, color, this.ctx, canvasGraphicsFactory, baseTransform);\n    } else {\n      pattern = this._getPattern(IR[1], IR[2]);\n    }\n    return pattern;\n  }\n  setStrokeColorN() {\n    this.current.strokeColor = this.getColorN_Pattern(arguments);\n  }\n  setFillColorN() {\n    this.current.fillColor = this.getColorN_Pattern(arguments);\n    this.current.patternFill = true;\n  }\n  setStrokeRGBColor(r, g, b) {\n    const color = _util.Util.makeHexColor(r, g, b);\n    this.ctx.strokeStyle = color;\n    this.current.strokeColor = color;\n  }\n  setFillRGBColor(r, g, b) {\n    const color = _util.Util.makeHexColor(r, g, b);\n    this.ctx.fillStyle = color;\n    this.current.fillColor = color;\n    this.current.patternFill = false;\n  }\n  _getPattern(objId, matrix = null) {\n    let pattern;\n    if (this.cachedPatterns.has(objId)) {\n      pattern = this.cachedPatterns.get(objId);\n    } else {\n      pattern = (0, _pattern_helper.getShadingPattern)(this.getObject(objId));\n      this.cachedPatterns.set(objId, pattern);\n    }\n    if (matrix) {\n      pattern.matrix = matrix;\n    }\n    return pattern;\n  }\n  shadingFill(objId) {\n    if (!this.contentVisible) {\n      return;\n    }\n    const ctx = this.ctx;\n    this.save();\n    const pattern = this._getPattern(objId);\n    ctx.fillStyle = pattern.getPattern(ctx, this, (0, _display_utils.getCurrentTransformInverse)(ctx), _pattern_helper.PathType.SHADING);\n    const inv = (0, _display_utils.getCurrentTransformInverse)(ctx);\n    if (inv) {\n      const {\n        width,\n        height\n      } = ctx.canvas;\n      const [x0, y0, x1, y1] = _util.Util.getAxialAlignedBoundingBox([0, 0, width, height], inv);\n      this.ctx.fillRect(x0, y0, x1 - x0, y1 - y0);\n    } else {\n      this.ctx.fillRect(-1e10, -1e10, 2e10, 2e10);\n    }\n    this.compose(this.current.getClippedPathBoundingBox());\n    this.restore();\n  }\n  beginInlineImage() {\n    (0, _util.unreachable)(\"Should not call beginInlineImage\");\n  }\n  beginImageData() {\n    (0, _util.unreachable)(\"Should not call beginImageData\");\n  }\n  paintFormXObjectBegin(matrix, bbox) {\n    if (!this.contentVisible) {\n      return;\n    }\n    this.save();\n    this.baseTransformStack.push(this.baseTransform);\n    if (Array.isArray(matrix) && matrix.length === 6) {\n      this.transform(...matrix);\n    }\n    this.baseTransform = (0, _display_utils.getCurrentTransform)(this.ctx);\n    if (bbox) {\n      const width = bbox[2] - bbox[0];\n      const height = bbox[3] - bbox[1];\n      this.ctx.rect(bbox[0], bbox[1], width, height);\n      this.current.updateRectMinMax((0, _display_utils.getCurrentTransform)(this.ctx), bbox);\n      this.clip();\n      this.endPath();\n    }\n  }\n  paintFormXObjectEnd() {\n    if (!this.contentVisible) {\n      return;\n    }\n    this.restore();\n    this.baseTransform = this.baseTransformStack.pop();\n  }\n  beginGroup(group) {\n    if (!this.contentVisible) {\n      return;\n    }\n    this.save();\n    if (this.inSMaskMode) {\n      this.endSMaskMode();\n      this.current.activeSMask = null;\n    }\n    const currentCtx = this.ctx;\n    if (!group.isolated) {\n      (0, _util.info)(\"TODO: Support non-isolated groups.\");\n    }\n    if (group.knockout) {\n      (0, _util.warn)(\"Knockout groups not supported.\");\n    }\n    const currentTransform = (0, _display_utils.getCurrentTransform)(currentCtx);\n    if (group.matrix) {\n      currentCtx.transform(...group.matrix);\n    }\n    if (!group.bbox) {\n      throw new Error(\"Bounding box is required.\");\n    }\n    let bounds = _util.Util.getAxialAlignedBoundingBox(group.bbox, (0, _display_utils.getCurrentTransform)(currentCtx));\n    const canvasBounds = [0, 0, currentCtx.canvas.width, currentCtx.canvas.height];\n    bounds = _util.Util.intersect(bounds, canvasBounds) || [0, 0, 0, 0];\n    const offsetX = Math.floor(bounds[0]);\n    const offsetY = Math.floor(bounds[1]);\n    let drawnWidth = Math.max(Math.ceil(bounds[2]) - offsetX, 1);\n    let drawnHeight = Math.max(Math.ceil(bounds[3]) - offsetY, 1);\n    let scaleX = 1,\n      scaleY = 1;\n    if (drawnWidth > MAX_GROUP_SIZE) {\n      scaleX = drawnWidth / MAX_GROUP_SIZE;\n      drawnWidth = MAX_GROUP_SIZE;\n    }\n    if (drawnHeight > MAX_GROUP_SIZE) {\n      scaleY = drawnHeight / MAX_GROUP_SIZE;\n      drawnHeight = MAX_GROUP_SIZE;\n    }\n    this.current.startNewPathAndClipBox([0, 0, drawnWidth, drawnHeight]);\n    let cacheId = \"groupAt\" + this.groupLevel;\n    if (group.smask) {\n      cacheId += \"_smask_\" + this.smaskCounter++ % 2;\n    }\n    const scratchCanvas = this.cachedCanvases.getCanvas(cacheId, drawnWidth, drawnHeight);\n    const groupCtx = scratchCanvas.context;\n    groupCtx.scale(1 / scaleX, 1 / scaleY);\n    groupCtx.translate(-offsetX, -offsetY);\n    groupCtx.transform(...currentTransform);\n    if (group.smask) {\n      this.smaskStack.push({\n        canvas: scratchCanvas.canvas,\n        context: groupCtx,\n        offsetX,\n        offsetY,\n        scaleX,\n        scaleY,\n        subtype: group.smask.subtype,\n        backdrop: group.smask.backdrop,\n        transferMap: group.smask.transferMap || null,\n        startTransformInverse: null\n      });\n    } else {\n      currentCtx.setTransform(1, 0, 0, 1, 0, 0);\n      currentCtx.translate(offsetX, offsetY);\n      currentCtx.scale(scaleX, scaleY);\n      currentCtx.save();\n    }\n    copyCtxState(currentCtx, groupCtx);\n    this.ctx = groupCtx;\n    this.setGState([[\"BM\", \"source-over\"], [\"ca\", 1], [\"CA\", 1]]);\n    this.groupStack.push(currentCtx);\n    this.groupLevel++;\n  }\n  endGroup(group) {\n    if (!this.contentVisible) {\n      return;\n    }\n    this.groupLevel--;\n    const groupCtx = this.ctx;\n    const ctx = this.groupStack.pop();\n    this.ctx = ctx;\n    this.ctx.imageSmoothingEnabled = false;\n    if (group.smask) {\n      this.tempSMask = this.smaskStack.pop();\n      this.restore();\n    } else {\n      this.ctx.restore();\n      const currentMtx = (0, _display_utils.getCurrentTransform)(this.ctx);\n      this.restore();\n      this.ctx.save();\n      this.ctx.setTransform(...currentMtx);\n      const dirtyBox = _util.Util.getAxialAlignedBoundingBox([0, 0, groupCtx.canvas.width, groupCtx.canvas.height], currentMtx);\n      this.ctx.drawImage(groupCtx.canvas, 0, 0);\n      this.ctx.restore();\n      this.compose(dirtyBox);\n    }\n  }\n  beginAnnotation(id, rect, transform, matrix, hasOwnCanvas) {\n    this.#restoreInitialState();\n    resetCtxToDefault(this.ctx);\n    this.ctx.save();\n    this.save();\n    if (this.baseTransform) {\n      this.ctx.setTransform(...this.baseTransform);\n    }\n    if (Array.isArray(rect) && rect.length === 4) {\n      const width = rect[2] - rect[0];\n      const height = rect[3] - rect[1];\n      if (hasOwnCanvas && this.annotationCanvasMap) {\n        transform = transform.slice();\n        transform[4] -= rect[0];\n        transform[5] -= rect[1];\n        rect = rect.slice();\n        rect[0] = rect[1] = 0;\n        rect[2] = width;\n        rect[3] = height;\n        const [scaleX, scaleY] = _util.Util.singularValueDecompose2dScale((0, _display_utils.getCurrentTransform)(this.ctx));\n        const {\n          viewportScale\n        } = this;\n        const canvasWidth = Math.ceil(width * this.outputScaleX * viewportScale);\n        const canvasHeight = Math.ceil(height * this.outputScaleY * viewportScale);\n        this.annotationCanvas = this.canvasFactory.create(canvasWidth, canvasHeight);\n        const {\n          canvas,\n          context\n        } = this.annotationCanvas;\n        this.annotationCanvasMap.set(id, canvas);\n        this.annotationCanvas.savedCtx = this.ctx;\n        this.ctx = context;\n        this.ctx.save();\n        this.ctx.setTransform(scaleX, 0, 0, -scaleY, 0, height * scaleY);\n        resetCtxToDefault(this.ctx);\n      } else {\n        resetCtxToDefault(this.ctx);\n        this.ctx.rect(rect[0], rect[1], width, height);\n        this.ctx.clip();\n        this.endPath();\n      }\n    }\n    this.current = new CanvasExtraState(this.ctx.canvas.width, this.ctx.canvas.height);\n    this.transform(...transform);\n    this.transform(...matrix);\n  }\n  endAnnotation() {\n    if (this.annotationCanvas) {\n      this.ctx.restore();\n      this.#drawFilter();\n      this.ctx = this.annotationCanvas.savedCtx;\n      delete this.annotationCanvas.savedCtx;\n      delete this.annotationCanvas;\n    }\n  }\n  paintImageMaskXObject(img) {\n    if (!this.contentVisible) {\n      return;\n    }\n    const count = img.count;\n    img = this.getObject(img.data, img);\n    img.count = count;\n    const ctx = this.ctx;\n    const glyph = this.processingType3;\n    if (glyph) {\n      if (glyph.compiled === undefined) {\n        glyph.compiled = compileType3Glyph(img);\n      }\n      if (glyph.compiled) {\n        glyph.compiled(ctx);\n        return;\n      }\n    }\n    const mask = this._createMaskCanvas(img);\n    const maskCanvas = mask.canvas;\n    ctx.save();\n    ctx.setTransform(1, 0, 0, 1, 0, 0);\n    ctx.drawImage(maskCanvas, mask.offsetX, mask.offsetY);\n    ctx.restore();\n    this.compose();\n  }\n  paintImageMaskXObjectRepeat(img, scaleX, skewX = 0, skewY = 0, scaleY, positions) {\n    if (!this.contentVisible) {\n      return;\n    }\n    img = this.getObject(img.data, img);\n    const ctx = this.ctx;\n    ctx.save();\n    const currentTransform = (0, _display_utils.getCurrentTransform)(ctx);\n    ctx.transform(scaleX, skewX, skewY, scaleY, 0, 0);\n    const mask = this._createMaskCanvas(img);\n    ctx.setTransform(1, 0, 0, 1, mask.offsetX - currentTransform[4], mask.offsetY - currentTransform[5]);\n    for (let i = 0, ii = positions.length; i < ii; i += 2) {\n      const trans = _util.Util.transform(currentTransform, [scaleX, skewX, skewY, scaleY, positions[i], positions[i + 1]]);\n      const [x, y] = _util.Util.applyTransform([0, 0], trans);\n      ctx.drawImage(mask.canvas, x, y);\n    }\n    ctx.restore();\n    this.compose();\n  }\n  paintImageMaskXObjectGroup(images) {\n    if (!this.contentVisible) {\n      return;\n    }\n    const ctx = this.ctx;\n    const fillColor = this.current.fillColor;\n    const isPatternFill = this.current.patternFill;\n    for (const image of images) {\n      const {\n        data,\n        width,\n        height,\n        transform\n      } = image;\n      const maskCanvas = this.cachedCanvases.getCanvas(\"maskCanvas\", width, height);\n      const maskCtx = maskCanvas.context;\n      maskCtx.save();\n      const img = this.getObject(data, image);\n      putBinaryImageMask(maskCtx, img);\n      maskCtx.globalCompositeOperation = \"source-in\";\n      maskCtx.fillStyle = isPatternFill ? fillColor.getPattern(maskCtx, this, (0, _display_utils.getCurrentTransformInverse)(ctx), _pattern_helper.PathType.FILL) : fillColor;\n      maskCtx.fillRect(0, 0, width, height);\n      maskCtx.restore();\n      ctx.save();\n      ctx.transform(...transform);\n      ctx.scale(1, -1);\n      drawImageAtIntegerCoords(ctx, maskCanvas.canvas, 0, 0, width, height, 0, -1, 1, 1);\n      ctx.restore();\n    }\n    this.compose();\n  }\n  paintImageXObject(objId) {\n    if (!this.contentVisible) {\n      return;\n    }\n    const imgData = this.getObject(objId);\n    if (!imgData) {\n      (0, _util.warn)(\"Dependent image isn't ready yet\");\n      return;\n    }\n    this.paintInlineImageXObject(imgData);\n  }\n  paintImageXObjectRepeat(objId, scaleX, scaleY, positions) {\n    if (!this.contentVisible) {\n      return;\n    }\n    const imgData = this.getObject(objId);\n    if (!imgData) {\n      (0, _util.warn)(\"Dependent image isn't ready yet\");\n      return;\n    }\n    const width = imgData.width;\n    const height = imgData.height;\n    const map = [];\n    for (let i = 0, ii = positions.length; i < ii; i += 2) {\n      map.push({\n        transform: [scaleX, 0, 0, scaleY, positions[i], positions[i + 1]],\n        x: 0,\n        y: 0,\n        w: width,\n        h: height\n      });\n    }\n    this.paintInlineImageXObjectGroup(imgData, map);\n  }\n  applyTransferMapsToCanvas(ctx) {\n    if (this.current.transferMaps !== \"none\") {\n      ctx.filter = this.current.transferMaps;\n      ctx.drawImage(ctx.canvas, 0, 0);\n      ctx.filter = \"none\";\n    }\n    return ctx.canvas;\n  }\n  applyTransferMapsToBitmap(imgData) {\n    if (this.current.transferMaps === \"none\") {\n      return imgData.bitmap;\n    }\n    const {\n      bitmap,\n      width,\n      height\n    } = imgData;\n    const tmpCanvas = this.cachedCanvases.getCanvas(\"inlineImage\", width, height);\n    const tmpCtx = tmpCanvas.context;\n    tmpCtx.filter = this.current.transferMaps;\n    tmpCtx.drawImage(bitmap, 0, 0);\n    tmpCtx.filter = \"none\";\n    return tmpCanvas.canvas;\n  }\n  paintInlineImageXObject(imgData) {\n    if (!this.contentVisible) {\n      return;\n    }\n    const width = imgData.width;\n    const height = imgData.height;\n    const ctx = this.ctx;\n    this.save();\n    if (!_util.isNodeJS) {\n      const {\n        filter\n      } = ctx;\n      if (filter !== \"none\" && filter !== \"\") {\n        ctx.filter = \"none\";\n      }\n    }\n    ctx.scale(1 / width, -1 / height);\n    let imgToPaint;\n    if (imgData.bitmap) {\n      imgToPaint = this.applyTransferMapsToBitmap(imgData);\n    } else if (typeof HTMLElement === \"function\" && imgData instanceof HTMLElement || !imgData.data) {\n      imgToPaint = imgData;\n    } else {\n      const tmpCanvas = this.cachedCanvases.getCanvas(\"inlineImage\", width, height);\n      const tmpCtx = tmpCanvas.context;\n      putBinaryImageData(tmpCtx, imgData);\n      imgToPaint = this.applyTransferMapsToCanvas(tmpCtx);\n    }\n    const scaled = this._scaleImage(imgToPaint, (0, _display_utils.getCurrentTransformInverse)(ctx));\n    ctx.imageSmoothingEnabled = getImageSmoothingEnabled((0, _display_utils.getCurrentTransform)(ctx), imgData.interpolate);\n    drawImageAtIntegerCoords(ctx, scaled.img, 0, 0, scaled.paintWidth, scaled.paintHeight, 0, -height, width, height);\n    this.compose();\n    this.restore();\n  }\n  paintInlineImageXObjectGroup(imgData, map) {\n    if (!this.contentVisible) {\n      return;\n    }\n    const ctx = this.ctx;\n    let imgToPaint;\n    if (imgData.bitmap) {\n      imgToPaint = imgData.bitmap;\n    } else {\n      const w = imgData.width;\n      const h = imgData.height;\n      const tmpCanvas = this.cachedCanvases.getCanvas(\"inlineImage\", w, h);\n      const tmpCtx = tmpCanvas.context;\n      putBinaryImageData(tmpCtx, imgData);\n      imgToPaint = this.applyTransferMapsToCanvas(tmpCtx);\n    }\n    for (const entry of map) {\n      ctx.save();\n      ctx.transform(...entry.transform);\n      ctx.scale(1, -1);\n      drawImageAtIntegerCoords(ctx, imgToPaint, entry.x, entry.y, entry.w, entry.h, 0, -1, 1, 1);\n      ctx.restore();\n    }\n    this.compose();\n  }\n  paintSolidColorImageMask() {\n    if (!this.contentVisible) {\n      return;\n    }\n    this.ctx.fillRect(0, 0, 1, 1);\n    this.compose();\n  }\n  markPoint(tag) {}\n  markPointProps(tag, properties) {}\n  beginMarkedContent(tag) {\n    this.markedContentStack.push({\n      visible: true\n    });\n  }\n  beginMarkedContentProps(tag, properties) {\n    if (tag === \"OC\") {\n      this.markedContentStack.push({\n        visible: this.optionalContentConfig.isVisible(properties)\n      });\n    } else {\n      this.markedContentStack.push({\n        visible: true\n      });\n    }\n    this.contentVisible = this.isContentVisible();\n  }\n  endMarkedContent() {\n    this.markedContentStack.pop();\n    this.contentVisible = this.isContentVisible();\n  }\n  beginCompat() {}\n  endCompat() {}\n  consumePath(clipBox) {\n    const isEmpty = this.current.isEmptyClip();\n    if (this.pendingClip) {\n      this.current.updateClipFromPath();\n    }\n    if (!this.pendingClip) {\n      this.compose(clipBox);\n    }\n    const ctx = this.ctx;\n    if (this.pendingClip) {\n      if (!isEmpty) {\n        if (this.pendingClip === EO_CLIP) {\n          ctx.clip(\"evenodd\");\n        } else {\n          ctx.clip();\n        }\n      }\n      this.pendingClip = null;\n    }\n    this.current.startNewPathAndClipBox(this.current.clipBox);\n    ctx.beginPath();\n  }\n  getSinglePixelWidth() {\n    if (!this._cachedGetSinglePixelWidth) {\n      const m = (0, _display_utils.getCurrentTransform)(this.ctx);\n      if (m[1] === 0 && m[2] === 0) {\n        this._cachedGetSinglePixelWidth = 1 / Math.min(Math.abs(m[0]), Math.abs(m[3]));\n      } else {\n        const absDet = Math.abs(m[0] * m[3] - m[2] * m[1]);\n        const normX = Math.hypot(m[0], m[2]);\n        const normY = Math.hypot(m[1], m[3]);\n        this._cachedGetSinglePixelWidth = Math.max(normX, normY) / absDet;\n      }\n    }\n    return this._cachedGetSinglePixelWidth;\n  }\n  getScaleForStroking() {\n    if (this._cachedScaleForStroking[0] === -1) {\n      const {\n        lineWidth\n      } = this.current;\n      const {\n        a,\n        b,\n        c,\n        d\n      } = this.ctx.getTransform();\n      let scaleX, scaleY;\n      if (b === 0 && c === 0) {\n        const normX = Math.abs(a);\n        const normY = Math.abs(d);\n        if (normX === normY) {\n          if (lineWidth === 0) {\n            scaleX = scaleY = 1 / normX;\n          } else {\n            const scaledLineWidth = normX * lineWidth;\n            scaleX = scaleY = scaledLineWidth < 1 ? 1 / scaledLineWidth : 1;\n          }\n        } else if (lineWidth === 0) {\n          scaleX = 1 / normX;\n          scaleY = 1 / normY;\n        } else {\n          const scaledXLineWidth = normX * lineWidth;\n          const scaledYLineWidth = normY * lineWidth;\n          scaleX = scaledXLineWidth < 1 ? 1 / scaledXLineWidth : 1;\n          scaleY = scaledYLineWidth < 1 ? 1 / scaledYLineWidth : 1;\n        }\n      } else {\n        const absDet = Math.abs(a * d - b * c);\n        const normX = Math.hypot(a, b);\n        const normY = Math.hypot(c, d);\n        if (lineWidth === 0) {\n          scaleX = normY / absDet;\n          scaleY = normX / absDet;\n        } else {\n          const baseArea = lineWidth * absDet;\n          scaleX = normY > baseArea ? normY / baseArea : 1;\n          scaleY = normX > baseArea ? normX / baseArea : 1;\n        }\n      }\n      this._cachedScaleForStroking[0] = scaleX;\n      this._cachedScaleForStroking[1] = scaleY;\n    }\n    return this._cachedScaleForStroking;\n  }\n  rescaleAndStroke(saveRestore) {\n    const {\n      ctx\n    } = this;\n    const {\n      lineWidth\n    } = this.current;\n    const [scaleX, scaleY] = this.getScaleForStroking();\n    ctx.lineWidth = lineWidth || 1;\n    if (scaleX === 1 && scaleY === 1) {\n      ctx.stroke();\n      return;\n    }\n    const dashes = ctx.getLineDash();\n    if (saveRestore) {\n      ctx.save();\n    }\n    ctx.scale(scaleX, scaleY);\n    if (dashes.length > 0) {\n      const scale = Math.max(scaleX, scaleY);\n      ctx.setLineDash(dashes.map(x => x / scale));\n      ctx.lineDashOffset /= scale;\n    }\n    ctx.stroke();\n    if (saveRestore) {\n      ctx.restore();\n    }\n  }\n  isContentVisible() {\n    for (let i = this.markedContentStack.length - 1; i >= 0; i--) {\n      if (!this.markedContentStack[i].visible) {\n        return false;\n      }\n    }\n    return true;\n  }\n}\nexports.CanvasGraphics = CanvasGraphics;\nfor (const op in _util.OPS) {\n  if (CanvasGraphics.prototype[op] !== undefined) {\n    CanvasGraphics.prototype[_util.OPS[op]] = CanvasGraphics.prototype[op];\n  }\n}\n\n/***/ }),\n/* 12 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.TilingPattern = exports.PathType = void 0;\nexports.getShadingPattern = getShadingPattern;\nvar _util = __w_pdfjs_require__(1);\nvar _display_utils = __w_pdfjs_require__(6);\nconst PathType = {\n  FILL: \"Fill\",\n  STROKE: \"Stroke\",\n  SHADING: \"Shading\"\n};\nexports.PathType = PathType;\nfunction applyBoundingBox(ctx, bbox) {\n  if (!bbox) {\n    return;\n  }\n  const width = bbox[2] - bbox[0];\n  const height = bbox[3] - bbox[1];\n  const region = new Path2D();\n  region.rect(bbox[0], bbox[1], width, height);\n  ctx.clip(region);\n}\nclass BaseShadingPattern {\n  constructor() {\n    if (this.constructor === BaseShadingPattern) {\n      (0, _util.unreachable)(\"Cannot initialize BaseShadingPattern.\");\n    }\n  }\n  getPattern() {\n    (0, _util.unreachable)(\"Abstract method `getPattern` called.\");\n  }\n}\nclass RadialAxialShadingPattern extends BaseShadingPattern {\n  constructor(IR) {\n    super();\n    this._type = IR[1];\n    this._bbox = IR[2];\n    this._colorStops = IR[3];\n    this._p0 = IR[4];\n    this._p1 = IR[5];\n    this._r0 = IR[6];\n    this._r1 = IR[7];\n    this.matrix = null;\n  }\n  _createGradient(ctx) {\n    let grad;\n    if (this._type === \"axial\") {\n      grad = ctx.createLinearGradient(this._p0[0], this._p0[1], this._p1[0], this._p1[1]);\n    } else if (this._type === \"radial\") {\n      grad = ctx.createRadialGradient(this._p0[0], this._p0[1], this._r0, this._p1[0], this._p1[1], this._r1);\n    }\n    for (const colorStop of this._colorStops) {\n      grad.addColorStop(colorStop[0], colorStop[1]);\n    }\n    return grad;\n  }\n  getPattern(ctx, owner, inverse, pathType) {\n    let pattern;\n    if (pathType === PathType.STROKE || pathType === PathType.FILL) {\n      const ownerBBox = owner.current.getClippedPathBoundingBox(pathType, (0, _display_utils.getCurrentTransform)(ctx)) || [0, 0, 0, 0];\n      const width = Math.ceil(ownerBBox[2] - ownerBBox[0]) || 1;\n      const height = Math.ceil(ownerBBox[3] - ownerBBox[1]) || 1;\n      const tmpCanvas = owner.cachedCanvases.getCanvas(\"pattern\", width, height, true);\n      const tmpCtx = tmpCanvas.context;\n      tmpCtx.clearRect(0, 0, tmpCtx.canvas.width, tmpCtx.canvas.height);\n      tmpCtx.beginPath();\n      tmpCtx.rect(0, 0, tmpCtx.canvas.width, tmpCtx.canvas.height);\n      tmpCtx.translate(-ownerBBox[0], -ownerBBox[1]);\n      inverse = _util.Util.transform(inverse, [1, 0, 0, 1, ownerBBox[0], ownerBBox[1]]);\n      tmpCtx.transform(...owner.baseTransform);\n      if (this.matrix) {\n        tmpCtx.transform(...this.matrix);\n      }\n      applyBoundingBox(tmpCtx, this._bbox);\n      tmpCtx.fillStyle = this._createGradient(tmpCtx);\n      tmpCtx.fill();\n      pattern = ctx.createPattern(tmpCanvas.canvas, \"no-repeat\");\n      const domMatrix = new DOMMatrix(inverse);\n      pattern.setTransform(domMatrix);\n    } else {\n      applyBoundingBox(ctx, this._bbox);\n      pattern = this._createGradient(ctx);\n    }\n    return pattern;\n  }\n}\nfunction drawTriangle(data, context, p1, p2, p3, c1, c2, c3) {\n  const coords = context.coords,\n    colors = context.colors;\n  const bytes = data.data,\n    rowSize = data.width * 4;\n  let tmp;\n  if (coords[p1 + 1] > coords[p2 + 1]) {\n    tmp = p1;\n    p1 = p2;\n    p2 = tmp;\n    tmp = c1;\n    c1 = c2;\n    c2 = tmp;\n  }\n  if (coords[p2 + 1] > coords[p3 + 1]) {\n    tmp = p2;\n    p2 = p3;\n    p3 = tmp;\n    tmp = c2;\n    c2 = c3;\n    c3 = tmp;\n  }\n  if (coords[p1 + 1] > coords[p2 + 1]) {\n    tmp = p1;\n    p1 = p2;\n    p2 = tmp;\n    tmp = c1;\n    c1 = c2;\n    c2 = tmp;\n  }\n  const x1 = (coords[p1] + context.offsetX) * context.scaleX;\n  const y1 = (coords[p1 + 1] + context.offsetY) * context.scaleY;\n  const x2 = (coords[p2] + context.offsetX) * context.scaleX;\n  const y2 = (coords[p2 + 1] + context.offsetY) * context.scaleY;\n  const x3 = (coords[p3] + context.offsetX) * context.scaleX;\n  const y3 = (coords[p3 + 1] + context.offsetY) * context.scaleY;\n  if (y1 >= y3) {\n    return;\n  }\n  const c1r = colors[c1],\n    c1g = colors[c1 + 1],\n    c1b = colors[c1 + 2];\n  const c2r = colors[c2],\n    c2g = colors[c2 + 1],\n    c2b = colors[c2 + 2];\n  const c3r = colors[c3],\n    c3g = colors[c3 + 1],\n    c3b = colors[c3 + 2];\n  const minY = Math.round(y1),\n    maxY = Math.round(y3);\n  let xa, car, cag, cab;\n  let xb, cbr, cbg, cbb;\n  for (let y = minY; y <= maxY; y++) {\n    if (y < y2) {\n      const k = y < y1 ? 0 : (y1 - y) / (y1 - y2);\n      xa = x1 - (x1 - x2) * k;\n      car = c1r - (c1r - c2r) * k;\n      cag = c1g - (c1g - c2g) * k;\n      cab = c1b - (c1b - c2b) * k;\n    } else {\n      let k;\n      if (y > y3) {\n        k = 1;\n      } else if (y2 === y3) {\n        k = 0;\n      } else {\n        k = (y2 - y) / (y2 - y3);\n      }\n      xa = x2 - (x2 - x3) * k;\n      car = c2r - (c2r - c3r) * k;\n      cag = c2g - (c2g - c3g) * k;\n      cab = c2b - (c2b - c3b) * k;\n    }\n    let k;\n    if (y < y1) {\n      k = 0;\n    } else if (y > y3) {\n      k = 1;\n    } else {\n      k = (y1 - y) / (y1 - y3);\n    }\n    xb = x1 - (x1 - x3) * k;\n    cbr = c1r - (c1r - c3r) * k;\n    cbg = c1g - (c1g - c3g) * k;\n    cbb = c1b - (c1b - c3b) * k;\n    const x1_ = Math.round(Math.min(xa, xb));\n    const x2_ = Math.round(Math.max(xa, xb));\n    let j = rowSize * y + x1_ * 4;\n    for (let x = x1_; x <= x2_; x++) {\n      k = (xa - x) / (xa - xb);\n      if (k < 0) {\n        k = 0;\n      } else if (k > 1) {\n        k = 1;\n      }\n      bytes[j++] = car - (car - cbr) * k | 0;\n      bytes[j++] = cag - (cag - cbg) * k | 0;\n      bytes[j++] = cab - (cab - cbb) * k | 0;\n      bytes[j++] = 255;\n    }\n  }\n}\nfunction drawFigure(data, figure, context) {\n  const ps = figure.coords;\n  const cs = figure.colors;\n  let i, ii;\n  switch (figure.type) {\n    case \"lattice\":\n      const verticesPerRow = figure.verticesPerRow;\n      const rows = Math.floor(ps.length / verticesPerRow) - 1;\n      const cols = verticesPerRow - 1;\n      for (i = 0; i < rows; i++) {\n        let q = i * verticesPerRow;\n        for (let j = 0; j < cols; j++, q++) {\n          drawTriangle(data, context, ps[q], ps[q + 1], ps[q + verticesPerRow], cs[q], cs[q + 1], cs[q + verticesPerRow]);\n          drawTriangle(data, context, ps[q + verticesPerRow + 1], ps[q + 1], ps[q + verticesPerRow], cs[q + verticesPerRow + 1], cs[q + 1], cs[q + verticesPerRow]);\n        }\n      }\n      break;\n    case \"triangles\":\n      for (i = 0, ii = ps.length; i < ii; i += 3) {\n        drawTriangle(data, context, ps[i], ps[i + 1], ps[i + 2], cs[i], cs[i + 1], cs[i + 2]);\n      }\n      break;\n    default:\n      throw new Error(\"illegal figure\");\n  }\n}\nclass MeshShadingPattern extends BaseShadingPattern {\n  constructor(IR) {\n    super();\n    this._coords = IR[2];\n    this._colors = IR[3];\n    this._figures = IR[4];\n    this._bounds = IR[5];\n    this._bbox = IR[7];\n    this._background = IR[8];\n    this.matrix = null;\n  }\n  _createMeshCanvas(combinedScale, backgroundColor, cachedCanvases) {\n    const EXPECTED_SCALE = 1.1;\n    const MAX_PATTERN_SIZE = 3000;\n    const BORDER_SIZE = 2;\n    const offsetX = Math.floor(this._bounds[0]);\n    const offsetY = Math.floor(this._bounds[1]);\n    const boundsWidth = Math.ceil(this._bounds[2]) - offsetX;\n    const boundsHeight = Math.ceil(this._bounds[3]) - offsetY;\n    const width = Math.min(Math.ceil(Math.abs(boundsWidth * combinedScale[0] * EXPECTED_SCALE)), MAX_PATTERN_SIZE);\n    const height = Math.min(Math.ceil(Math.abs(boundsHeight * combinedScale[1] * EXPECTED_SCALE)), MAX_PATTERN_SIZE);\n    const scaleX = boundsWidth / width;\n    const scaleY = boundsHeight / height;\n    const context = {\n      coords: this._coords,\n      colors: this._colors,\n      offsetX: -offsetX,\n      offsetY: -offsetY,\n      scaleX: 1 / scaleX,\n      scaleY: 1 / scaleY\n    };\n    const paddedWidth = width + BORDER_SIZE * 2;\n    const paddedHeight = height + BORDER_SIZE * 2;\n    const tmpCanvas = cachedCanvases.getCanvas(\"mesh\", paddedWidth, paddedHeight, false);\n    const tmpCtx = tmpCanvas.context;\n    const data = tmpCtx.createImageData(width, height);\n    if (backgroundColor) {\n      const bytes = data.data;\n      for (let i = 0, ii = bytes.length; i < ii; i += 4) {\n        bytes[i] = backgroundColor[0];\n        bytes[i + 1] = backgroundColor[1];\n        bytes[i + 2] = backgroundColor[2];\n        bytes[i + 3] = 255;\n      }\n    }\n    for (const figure of this._figures) {\n      drawFigure(data, figure, context);\n    }\n    tmpCtx.putImageData(data, BORDER_SIZE, BORDER_SIZE);\n    const canvas = tmpCanvas.canvas;\n    return {\n      canvas,\n      offsetX: offsetX - BORDER_SIZE * scaleX,\n      offsetY: offsetY - BORDER_SIZE * scaleY,\n      scaleX,\n      scaleY\n    };\n  }\n  getPattern(ctx, owner, inverse, pathType) {\n    applyBoundingBox(ctx, this._bbox);\n    let scale;\n    if (pathType === PathType.SHADING) {\n      scale = _util.Util.singularValueDecompose2dScale((0, _display_utils.getCurrentTransform)(ctx));\n    } else {\n      scale = _util.Util.singularValueDecompose2dScale(owner.baseTransform);\n      if (this.matrix) {\n        const matrixScale = _util.Util.singularValueDecompose2dScale(this.matrix);\n        scale = [scale[0] * matrixScale[0], scale[1] * matrixScale[1]];\n      }\n    }\n    const temporaryPatternCanvas = this._createMeshCanvas(scale, pathType === PathType.SHADING ? null : this._background, owner.cachedCanvases);\n    if (pathType !== PathType.SHADING) {\n      ctx.setTransform(...owner.baseTransform);\n      if (this.matrix) {\n        ctx.transform(...this.matrix);\n      }\n    }\n    ctx.translate(temporaryPatternCanvas.offsetX, temporaryPatternCanvas.offsetY);\n    ctx.scale(temporaryPatternCanvas.scaleX, temporaryPatternCanvas.scaleY);\n    return ctx.createPattern(temporaryPatternCanvas.canvas, \"no-repeat\");\n  }\n}\nclass DummyShadingPattern extends BaseShadingPattern {\n  getPattern() {\n    return \"hotpink\";\n  }\n}\nfunction getShadingPattern(IR) {\n  switch (IR[0]) {\n    case \"RadialAxial\":\n      return new RadialAxialShadingPattern(IR);\n    case \"Mesh\":\n      return new MeshShadingPattern(IR);\n    case \"Dummy\":\n      return new DummyShadingPattern();\n  }\n  throw new Error(`Unknown IR type: ${IR[0]}`);\n}\nconst PaintType = {\n  COLORED: 1,\n  UNCOLORED: 2\n};\nclass TilingPattern {\n  static MAX_PATTERN_SIZE = 3000;\n  constructor(IR, color, ctx, canvasGraphicsFactory, baseTransform) {\n    this.operatorList = IR[2];\n    this.matrix = IR[3] || [1, 0, 0, 1, 0, 0];\n    this.bbox = IR[4];\n    this.xstep = IR[5];\n    this.ystep = IR[6];\n    this.paintType = IR[7];\n    this.tilingType = IR[8];\n    this.color = color;\n    this.ctx = ctx;\n    this.canvasGraphicsFactory = canvasGraphicsFactory;\n    this.baseTransform = baseTransform;\n  }\n  createPatternCanvas(owner) {\n    const operatorList = this.operatorList;\n    const bbox = this.bbox;\n    const xstep = this.xstep;\n    const ystep = this.ystep;\n    const paintType = this.paintType;\n    const tilingType = this.tilingType;\n    const color = this.color;\n    const canvasGraphicsFactory = this.canvasGraphicsFactory;\n    (0, _util.info)(\"TilingType: \" + tilingType);\n    const x0 = bbox[0],\n      y0 = bbox[1],\n      x1 = bbox[2],\n      y1 = bbox[3];\n    const matrixScale = _util.Util.singularValueDecompose2dScale(this.matrix);\n    const curMatrixScale = _util.Util.singularValueDecompose2dScale(this.baseTransform);\n    const combinedScale = [matrixScale[0] * curMatrixScale[0], matrixScale[1] * curMatrixScale[1]];\n    const dimx = this.getSizeAndScale(xstep, this.ctx.canvas.width, combinedScale[0]);\n    const dimy = this.getSizeAndScale(ystep, this.ctx.canvas.height, combinedScale[1]);\n    const tmpCanvas = owner.cachedCanvases.getCanvas(\"pattern\", dimx.size, dimy.size, true);\n    const tmpCtx = tmpCanvas.context;\n    const graphics = canvasGraphicsFactory.createCanvasGraphics(tmpCtx);\n    graphics.groupLevel = owner.groupLevel;\n    this.setFillAndStrokeStyleToContext(graphics, paintType, color);\n    let adjustedX0 = x0;\n    let adjustedY0 = y0;\n    let adjustedX1 = x1;\n    let adjustedY1 = y1;\n    if (x0 < 0) {\n      adjustedX0 = 0;\n      adjustedX1 += Math.abs(x0);\n    }\n    if (y0 < 0) {\n      adjustedY0 = 0;\n      adjustedY1 += Math.abs(y0);\n    }\n    tmpCtx.translate(-(dimx.scale * adjustedX0), -(dimy.scale * adjustedY0));\n    graphics.transform(dimx.scale, 0, 0, dimy.scale, 0, 0);\n    tmpCtx.save();\n    this.clipBbox(graphics, adjustedX0, adjustedY0, adjustedX1, adjustedY1);\n    graphics.baseTransform = (0, _display_utils.getCurrentTransform)(graphics.ctx);\n    graphics.executeOperatorList(operatorList);\n    graphics.endDrawing();\n    return {\n      canvas: tmpCanvas.canvas,\n      scaleX: dimx.scale,\n      scaleY: dimy.scale,\n      offsetX: adjustedX0,\n      offsetY: adjustedY0\n    };\n  }\n  getSizeAndScale(step, realOutputSize, scale) {\n    step = Math.abs(step);\n    const maxSize = Math.max(TilingPattern.MAX_PATTERN_SIZE, realOutputSize);\n    let size = Math.ceil(step * scale);\n    if (size >= maxSize) {\n      size = maxSize;\n    } else {\n      scale = size / step;\n    }\n    return {\n      scale,\n      size\n    };\n  }\n  clipBbox(graphics, x0, y0, x1, y1) {\n    const bboxWidth = x1 - x0;\n    const bboxHeight = y1 - y0;\n    graphics.ctx.rect(x0, y0, bboxWidth, bboxHeight);\n    graphics.current.updateRectMinMax((0, _display_utils.getCurrentTransform)(graphics.ctx), [x0, y0, x1, y1]);\n    graphics.clip();\n    graphics.endPath();\n  }\n  setFillAndStrokeStyleToContext(graphics, paintType, color) {\n    const context = graphics.ctx,\n      current = graphics.current;\n    switch (paintType) {\n      case PaintType.COLORED:\n        const ctx = this.ctx;\n        context.fillStyle = ctx.fillStyle;\n        context.strokeStyle = ctx.strokeStyle;\n        current.fillColor = ctx.fillStyle;\n        current.strokeColor = ctx.strokeStyle;\n        break;\n      case PaintType.UNCOLORED:\n        const cssColor = _util.Util.makeHexColor(color[0], color[1], color[2]);\n        context.fillStyle = cssColor;\n        context.strokeStyle = cssColor;\n        current.fillColor = cssColor;\n        current.strokeColor = cssColor;\n        break;\n      default:\n        throw new _util.FormatError(`Unsupported paint type: ${paintType}`);\n    }\n  }\n  getPattern(ctx, owner, inverse, pathType) {\n    let matrix = inverse;\n    if (pathType !== PathType.SHADING) {\n      matrix = _util.Util.transform(matrix, owner.baseTransform);\n      if (this.matrix) {\n        matrix = _util.Util.transform(matrix, this.matrix);\n      }\n    }\n    const temporaryPatternCanvas = this.createPatternCanvas(owner);\n    let domMatrix = new DOMMatrix(matrix);\n    domMatrix = domMatrix.translate(temporaryPatternCanvas.offsetX, temporaryPatternCanvas.offsetY);\n    domMatrix = domMatrix.scale(1 / temporaryPatternCanvas.scaleX, 1 / temporaryPatternCanvas.scaleY);\n    const pattern = ctx.createPattern(temporaryPatternCanvas.canvas, \"repeat\");\n    pattern.setTransform(domMatrix);\n    return pattern;\n  }\n}\nexports.TilingPattern = TilingPattern;\n\n/***/ }),\n/* 13 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.convertBlackAndWhiteToRGBA = convertBlackAndWhiteToRGBA;\nexports.convertToRGBA = convertToRGBA;\nexports.grayToRGBA = grayToRGBA;\nvar _util = __w_pdfjs_require__(1);\nfunction convertToRGBA(params) {\n  switch (params.kind) {\n    case _util.ImageKind.GRAYSCALE_1BPP:\n      return convertBlackAndWhiteToRGBA(params);\n    case _util.ImageKind.RGB_24BPP:\n      return convertRGBToRGBA(params);\n  }\n  return null;\n}\nfunction convertBlackAndWhiteToRGBA({\n  src,\n  srcPos = 0,\n  dest,\n  width,\n  height,\n  nonBlackColor = 0xffffffff,\n  inverseDecode = false\n}) {\n  const black = _util.FeatureTest.isLittleEndian ? 0xff000000 : 0x000000ff;\n  const [zeroMapping, oneMapping] = inverseDecode ? [nonBlackColor, black] : [black, nonBlackColor];\n  const widthInSource = width >> 3;\n  const widthRemainder = width & 7;\n  const srcLength = src.length;\n  dest = new Uint32Array(dest.buffer);\n  let destPos = 0;\n  for (let i = 0; i < height; i++) {\n    for (const max = srcPos + widthInSource; srcPos < max; srcPos++) {\n      const elem = srcPos < srcLength ? src[srcPos] : 255;\n      dest[destPos++] = elem & 0b10000000 ? oneMapping : zeroMapping;\n      dest[destPos++] = elem & 0b1000000 ? oneMapping : zeroMapping;\n      dest[destPos++] = elem & 0b100000 ? oneMapping : zeroMapping;\n      dest[destPos++] = elem & 0b10000 ? oneMapping : zeroMapping;\n      dest[destPos++] = elem & 0b1000 ? oneMapping : zeroMapping;\n      dest[destPos++] = elem & 0b100 ? oneMapping : zeroMapping;\n      dest[destPos++] = elem & 0b10 ? oneMapping : zeroMapping;\n      dest[destPos++] = elem & 0b1 ? oneMapping : zeroMapping;\n    }\n    if (widthRemainder === 0) {\n      continue;\n    }\n    const elem = srcPos < srcLength ? src[srcPos++] : 255;\n    for (let j = 0; j < widthRemainder; j++) {\n      dest[destPos++] = elem & 1 << 7 - j ? oneMapping : zeroMapping;\n    }\n  }\n  return {\n    srcPos,\n    destPos\n  };\n}\nfunction convertRGBToRGBA({\n  src,\n  srcPos = 0,\n  dest,\n  destPos = 0,\n  width,\n  height\n}) {\n  let i = 0;\n  const len32 = src.length >> 2;\n  const src32 = new Uint32Array(src.buffer, srcPos, len32);\n  if (_util.FeatureTest.isLittleEndian) {\n    for (; i < len32 - 2; i += 3, destPos += 4) {\n      const s1 = src32[i];\n      const s2 = src32[i + 1];\n      const s3 = src32[i + 2];\n      dest[destPos] = s1 | 0xff000000;\n      dest[destPos + 1] = s1 >>> 24 | s2 << 8 | 0xff000000;\n      dest[destPos + 2] = s2 >>> 16 | s3 << 16 | 0xff000000;\n      dest[destPos + 3] = s3 >>> 8 | 0xff000000;\n    }\n    for (let j = i * 4, jj = src.length; j < jj; j += 3) {\n      dest[destPos++] = src[j] | src[j + 1] << 8 | src[j + 2] << 16 | 0xff000000;\n    }\n  } else {\n    for (; i < len32 - 2; i += 3, destPos += 4) {\n      const s1 = src32[i];\n      const s2 = src32[i + 1];\n      const s3 = src32[i + 2];\n      dest[destPos] = s1 | 0xff;\n      dest[destPos + 1] = s1 << 24 | s2 >>> 8 | 0xff;\n      dest[destPos + 2] = s2 << 16 | s3 >>> 16 | 0xff;\n      dest[destPos + 3] = s3 << 8 | 0xff;\n    }\n    for (let j = i * 4, jj = src.length; j < jj; j += 3) {\n      dest[destPos++] = src[j] << 24 | src[j + 1] << 16 | src[j + 2] << 8 | 0xff;\n    }\n  }\n  return {\n    srcPos,\n    destPos\n  };\n}\nfunction grayToRGBA(src, dest) {\n  if (_util.FeatureTest.isLittleEndian) {\n    for (let i = 0, ii = src.length; i < ii; i++) {\n      dest[i] = src[i] * 0x10101 | 0xff000000;\n    }\n  } else {\n    for (let i = 0, ii = src.length; i < ii; i++) {\n      dest[i] = src[i] * 0x1010100 | 0x000000ff;\n    }\n  }\n}\n\n/***/ }),\n/* 14 */\n/***/ ((__unused_webpack_module, exports) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.GlobalWorkerOptions = void 0;\nconst GlobalWorkerOptions = Object.create(null);\nexports.GlobalWorkerOptions = GlobalWorkerOptions;\nGlobalWorkerOptions.workerPort = null;\nGlobalWorkerOptions.workerSrc = \"\";\n\n/***/ }),\n/* 15 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.MessageHandler = void 0;\nvar _util = __w_pdfjs_require__(1);\nconst CallbackKind = {\n  UNKNOWN: 0,\n  DATA: 1,\n  ERROR: 2\n};\nconst StreamKind = {\n  UNKNOWN: 0,\n  CANCEL: 1,\n  CANCEL_COMPLETE: 2,\n  CLOSE: 3,\n  ENQUEUE: 4,\n  ERROR: 5,\n  PULL: 6,\n  PULL_COMPLETE: 7,\n  START_COMPLETE: 8\n};\nfunction wrapReason(reason) {\n  if (!(reason instanceof Error || typeof reason === \"object\" && reason !== null)) {\n    (0, _util.unreachable)('wrapReason: Expected \"reason\" to be a (possibly cloned) Error.');\n  }\n  switch (reason.name) {\n    case \"AbortException\":\n      return new _util.AbortException(reason.message);\n    case \"MissingPDFException\":\n      return new _util.MissingPDFException(reason.message);\n    case \"PasswordException\":\n      return new _util.PasswordException(reason.message, reason.code);\n    case \"UnexpectedResponseException\":\n      return new _util.UnexpectedResponseException(reason.message, reason.status);\n    case \"UnknownErrorException\":\n      return new _util.UnknownErrorException(reason.message, reason.details);\n    default:\n      return new _util.UnknownErrorException(reason.message, reason.toString());\n  }\n}\nclass MessageHandler {\n  constructor(sourceName, targetName, comObj) {\n    this.sourceName = sourceName;\n    this.targetName = targetName;\n    this.comObj = comObj;\n    this.callbackId = 1;\n    this.streamId = 1;\n    this.streamSinks = Object.create(null);\n    this.streamControllers = Object.create(null);\n    this.callbackCapabilities = Object.create(null);\n    this.actionHandler = Object.create(null);\n    this._onComObjOnMessage = event => {\n      const data = event.data;\n      if (data.targetName !== this.sourceName) {\n        return;\n      }\n      if (data.stream) {\n        this.#processStreamMessage(data);\n        return;\n      }\n      if (data.callback) {\n        const callbackId = data.callbackId;\n        const capability = this.callbackCapabilities[callbackId];\n        if (!capability) {\n          throw new Error(`Cannot resolve callback ${callbackId}`);\n        }\n        delete this.callbackCapabilities[callbackId];\n        if (data.callback === CallbackKind.DATA) {\n          capability.resolve(data.data);\n        } else if (data.callback === CallbackKind.ERROR) {\n          capability.reject(wrapReason(data.reason));\n        } else {\n          throw new Error(\"Unexpected callback case\");\n        }\n        return;\n      }\n      const action = this.actionHandler[data.action];\n      if (!action) {\n        throw new Error(`Unknown action from worker: ${data.action}`);\n      }\n      if (data.callbackId) {\n        const cbSourceName = this.sourceName;\n        const cbTargetName = data.sourceName;\n        new Promise(function (resolve) {\n          resolve(action(data.data));\n        }).then(function (result) {\n          comObj.postMessage({\n            sourceName: cbSourceName,\n            targetName: cbTargetName,\n            callback: CallbackKind.DATA,\n            callbackId: data.callbackId,\n            data: result\n          });\n        }, function (reason) {\n          comObj.postMessage({\n            sourceName: cbSourceName,\n            targetName: cbTargetName,\n            callback: CallbackKind.ERROR,\n            callbackId: data.callbackId,\n            reason: wrapReason(reason)\n          });\n        });\n        return;\n      }\n      if (data.streamId) {\n        this.#createStreamSink(data);\n        return;\n      }\n      action(data.data);\n    };\n    comObj.addEventListener(\"message\", this._onComObjOnMessage);\n  }\n  on(actionName, handler) {\n    const ah = this.actionHandler;\n    if (ah[actionName]) {\n      throw new Error(`There is already an actionName called \"${actionName}\"`);\n    }\n    ah[actionName] = handler;\n  }\n  send(actionName, data, transfers) {\n    this.comObj.postMessage({\n      sourceName: this.sourceName,\n      targetName: this.targetName,\n      action: actionName,\n      data\n    }, transfers);\n  }\n  sendWithPromise(actionName, data, transfers) {\n    const callbackId = this.callbackId++;\n    const capability = new _util.PromiseCapability();\n    this.callbackCapabilities[callbackId] = capability;\n    try {\n      this.comObj.postMessage({\n        sourceName: this.sourceName,\n        targetName: this.targetName,\n        action: actionName,\n        callbackId,\n        data\n      }, transfers);\n    } catch (ex) {\n      capability.reject(ex);\n    }\n    return capability.promise;\n  }\n  sendWithStream(actionName, data, queueingStrategy, transfers) {\n    const streamId = this.streamId++,\n      sourceName = this.sourceName,\n      targetName = this.targetName,\n      comObj = this.comObj;\n    return new ReadableStream({\n      start: controller => {\n        const startCapability = new _util.PromiseCapability();\n        this.streamControllers[streamId] = {\n          controller,\n          startCall: startCapability,\n          pullCall: null,\n          cancelCall: null,\n          isClosed: false\n        };\n        comObj.postMessage({\n          sourceName,\n          targetName,\n          action: actionName,\n          streamId,\n          data,\n          desiredSize: controller.desiredSize\n        }, transfers);\n        return startCapability.promise;\n      },\n      pull: controller => {\n        const pullCapability = new _util.PromiseCapability();\n        this.streamControllers[streamId].pullCall = pullCapability;\n        comObj.postMessage({\n          sourceName,\n          targetName,\n          stream: StreamKind.PULL,\n          streamId,\n          desiredSize: controller.desiredSize\n        });\n        return pullCapability.promise;\n      },\n      cancel: reason => {\n        (0, _util.assert)(reason instanceof Error, \"cancel must have a valid reason\");\n        const cancelCapability = new _util.PromiseCapability();\n        this.streamControllers[streamId].cancelCall = cancelCapability;\n        this.streamControllers[streamId].isClosed = true;\n        comObj.postMessage({\n          sourceName,\n          targetName,\n          stream: StreamKind.CANCEL,\n          streamId,\n          reason: wrapReason(reason)\n        });\n        return cancelCapability.promise;\n      }\n    }, queueingStrategy);\n  }\n  #createStreamSink(data) {\n    const streamId = data.streamId,\n      sourceName = this.sourceName,\n      targetName = data.sourceName,\n      comObj = this.comObj;\n    const self = this,\n      action = this.actionHandler[data.action];\n    const streamSink = {\n      enqueue(chunk, size = 1, transfers) {\n        if (this.isCancelled) {\n          return;\n        }\n        const lastDesiredSize = this.desiredSize;\n        this.desiredSize -= size;\n        if (lastDesiredSize > 0 && this.desiredSize <= 0) {\n          this.sinkCapability = new _util.PromiseCapability();\n          this.ready = this.sinkCapability.promise;\n        }\n        comObj.postMessage({\n          sourceName,\n          targetName,\n          stream: StreamKind.ENQUEUE,\n          streamId,\n          chunk\n        }, transfers);\n      },\n      close() {\n        if (this.isCancelled) {\n          return;\n        }\n        this.isCancelled = true;\n        comObj.postMessage({\n          sourceName,\n          targetName,\n          stream: StreamKind.CLOSE,\n          streamId\n        });\n        delete self.streamSinks[streamId];\n      },\n      error(reason) {\n        (0, _util.assert)(reason instanceof Error, \"error must have a valid reason\");\n        if (this.isCancelled) {\n          return;\n        }\n        this.isCancelled = true;\n        comObj.postMessage({\n          sourceName,\n          targetName,\n          stream: StreamKind.ERROR,\n          streamId,\n          reason: wrapReason(reason)\n        });\n      },\n      sinkCapability: new _util.PromiseCapability(),\n      onPull: null,\n      onCancel: null,\n      isCancelled: false,\n      desiredSize: data.desiredSize,\n      ready: null\n    };\n    streamSink.sinkCapability.resolve();\n    streamSink.ready = streamSink.sinkCapability.promise;\n    this.streamSinks[streamId] = streamSink;\n    new Promise(function (resolve) {\n      resolve(action(data.data, streamSink));\n    }).then(function () {\n      comObj.postMessage({\n        sourceName,\n        targetName,\n        stream: StreamKind.START_COMPLETE,\n        streamId,\n        success: true\n      });\n    }, function (reason) {\n      comObj.postMessage({\n        sourceName,\n        targetName,\n        stream: StreamKind.START_COMPLETE,\n        streamId,\n        reason: wrapReason(reason)\n      });\n    });\n  }\n  #processStreamMessage(data) {\n    const streamId = data.streamId,\n      sourceName = this.sourceName,\n      targetName = data.sourceName,\n      comObj = this.comObj;\n    const streamController = this.streamControllers[streamId],\n      streamSink = this.streamSinks[streamId];\n    switch (data.stream) {\n      case StreamKind.START_COMPLETE:\n        if (data.success) {\n          streamController.startCall.resolve();\n        } else {\n          streamController.startCall.reject(wrapReason(data.reason));\n        }\n        break;\n      case StreamKind.PULL_COMPLETE:\n        if (data.success) {\n          streamController.pullCall.resolve();\n        } else {\n          streamController.pullCall.reject(wrapReason(data.reason));\n        }\n        break;\n      case StreamKind.PULL:\n        if (!streamSink) {\n          comObj.postMessage({\n            sourceName,\n            targetName,\n            stream: StreamKind.PULL_COMPLETE,\n            streamId,\n            success: true\n          });\n          break;\n        }\n        if (streamSink.desiredSize <= 0 && data.desiredSize > 0) {\n          streamSink.sinkCapability.resolve();\n        }\n        streamSink.desiredSize = data.desiredSize;\n        new Promise(function (resolve) {\n          resolve(streamSink.onPull?.());\n        }).then(function () {\n          comObj.postMessage({\n            sourceName,\n            targetName,\n            stream: StreamKind.PULL_COMPLETE,\n            streamId,\n            success: true\n          });\n        }, function (reason) {\n          comObj.postMessage({\n            sourceName,\n            targetName,\n            stream: StreamKind.PULL_COMPLETE,\n            streamId,\n            reason: wrapReason(reason)\n          });\n        });\n        break;\n      case StreamKind.ENQUEUE:\n        (0, _util.assert)(streamController, \"enqueue should have stream controller\");\n        if (streamController.isClosed) {\n          break;\n        }\n        streamController.controller.enqueue(data.chunk);\n        break;\n      case StreamKind.CLOSE:\n        (0, _util.assert)(streamController, \"close should have stream controller\");\n        if (streamController.isClosed) {\n          break;\n        }\n        streamController.isClosed = true;\n        streamController.controller.close();\n        this.#deleteStreamController(streamController, streamId);\n        break;\n      case StreamKind.ERROR:\n        (0, _util.assert)(streamController, \"error should have stream controller\");\n        streamController.controller.error(wrapReason(data.reason));\n        this.#deleteStreamController(streamController, streamId);\n        break;\n      case StreamKind.CANCEL_COMPLETE:\n        if (data.success) {\n          streamController.cancelCall.resolve();\n        } else {\n          streamController.cancelCall.reject(wrapReason(data.reason));\n        }\n        this.#deleteStreamController(streamController, streamId);\n        break;\n      case StreamKind.CANCEL:\n        if (!streamSink) {\n          break;\n        }\n        new Promise(function (resolve) {\n          resolve(streamSink.onCancel?.(wrapReason(data.reason)));\n        }).then(function () {\n          comObj.postMessage({\n            sourceName,\n            targetName,\n            stream: StreamKind.CANCEL_COMPLETE,\n            streamId,\n            success: true\n          });\n        }, function (reason) {\n          comObj.postMessage({\n            sourceName,\n            targetName,\n            stream: StreamKind.CANCEL_COMPLETE,\n            streamId,\n            reason: wrapReason(reason)\n          });\n        });\n        streamSink.sinkCapability.reject(wrapReason(data.reason));\n        streamSink.isCancelled = true;\n        delete this.streamSinks[streamId];\n        break;\n      default:\n        throw new Error(\"Unexpected stream case\");\n    }\n  }\n  async #deleteStreamController(streamController, streamId) {\n    await Promise.allSettled([streamController.startCall?.promise, streamController.pullCall?.promise, streamController.cancelCall?.promise]);\n    delete this.streamControllers[streamId];\n  }\n  destroy() {\n    this.comObj.removeEventListener(\"message\", this._onComObjOnMessage);\n  }\n}\nexports.MessageHandler = MessageHandler;\n\n/***/ }),\n/* 16 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.Metadata = void 0;\nvar _util = __w_pdfjs_require__(1);\nclass Metadata {\n  #metadataMap;\n  #data;\n  constructor({\n    parsedData,\n    rawData\n  }) {\n    this.#metadataMap = parsedData;\n    this.#data = rawData;\n  }\n  getRaw() {\n    return this.#data;\n  }\n  get(name) {\n    return this.#metadataMap.get(name) ?? null;\n  }\n  getAll() {\n    return (0, _util.objectFromMap)(this.#metadataMap);\n  }\n  has(name) {\n    return this.#metadataMap.has(name);\n  }\n}\nexports.Metadata = Metadata;\n\n/***/ }),\n/* 17 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.OptionalContentConfig = void 0;\nvar _util = __w_pdfjs_require__(1);\nvar _murmurhash = __w_pdfjs_require__(8);\nconst INTERNAL = Symbol(\"INTERNAL\");\nclass OptionalContentGroup {\n  #visible = true;\n  constructor(name, intent) {\n    this.name = name;\n    this.intent = intent;\n  }\n  get visible() {\n    return this.#visible;\n  }\n  _setVisible(internal, visible) {\n    if (internal !== INTERNAL) {\n      (0, _util.unreachable)(\"Internal method `_setVisible` called.\");\n    }\n    this.#visible = visible;\n  }\n}\nclass OptionalContentConfig {\n  #cachedGetHash = null;\n  #groups = new Map();\n  #initialHash = null;\n  #order = null;\n  constructor(data) {\n    this.name = null;\n    this.creator = null;\n    if (data === null) {\n      return;\n    }\n    this.name = data.name;\n    this.creator = data.creator;\n    this.#order = data.order;\n    for (const group of data.groups) {\n      this.#groups.set(group.id, new OptionalContentGroup(group.name, group.intent));\n    }\n    if (data.baseState === \"OFF\") {\n      for (const group of this.#groups.values()) {\n        group._setVisible(INTERNAL, false);\n      }\n    }\n    for (const on of data.on) {\n      this.#groups.get(on)._setVisible(INTERNAL, true);\n    }\n    for (const off of data.off) {\n      this.#groups.get(off)._setVisible(INTERNAL, false);\n    }\n    this.#initialHash = this.getHash();\n  }\n  #evaluateVisibilityExpression(array) {\n    const length = array.length;\n    if (length < 2) {\n      return true;\n    }\n    const operator = array[0];\n    for (let i = 1; i < length; i++) {\n      const element = array[i];\n      let state;\n      if (Array.isArray(element)) {\n        state = this.#evaluateVisibilityExpression(element);\n      } else if (this.#groups.has(element)) {\n        state = this.#groups.get(element).visible;\n      } else {\n        (0, _util.warn)(`Optional content group not found: ${element}`);\n        return true;\n      }\n      switch (operator) {\n        case \"And\":\n          if (!state) {\n            return false;\n          }\n          break;\n        case \"Or\":\n          if (state) {\n            return true;\n          }\n          break;\n        case \"Not\":\n          return !state;\n        default:\n          return true;\n      }\n    }\n    return operator === \"And\";\n  }\n  isVisible(group) {\n    if (this.#groups.size === 0) {\n      return true;\n    }\n    if (!group) {\n      (0, _util.warn)(\"Optional content group not defined.\");\n      return true;\n    }\n    if (group.type === \"OCG\") {\n      if (!this.#groups.has(group.id)) {\n        (0, _util.warn)(`Optional content group not found: ${group.id}`);\n        return true;\n      }\n      return this.#groups.get(group.id).visible;\n    } else if (group.type === \"OCMD\") {\n      if (group.expression) {\n        return this.#evaluateVisibilityExpression(group.expression);\n      }\n      if (!group.policy || group.policy === \"AnyOn\") {\n        for (const id of group.ids) {\n          if (!this.#groups.has(id)) {\n            (0, _util.warn)(`Optional content group not found: ${id}`);\n            return true;\n          }\n          if (this.#groups.get(id).visible) {\n            return true;\n          }\n        }\n        return false;\n      } else if (group.policy === \"AllOn\") {\n        for (const id of group.ids) {\n          if (!this.#groups.has(id)) {\n            (0, _util.warn)(`Optional content group not found: ${id}`);\n            return true;\n          }\n          if (!this.#groups.get(id).visible) {\n            return false;\n          }\n        }\n        return true;\n      } else if (group.policy === \"AnyOff\") {\n        for (const id of group.ids) {\n          if (!this.#groups.has(id)) {\n            (0, _util.warn)(`Optional content group not found: ${id}`);\n            return true;\n          }\n          if (!this.#groups.get(id).visible) {\n            return true;\n          }\n        }\n        return false;\n      } else if (group.policy === \"AllOff\") {\n        for (const id of group.ids) {\n          if (!this.#groups.has(id)) {\n            (0, _util.warn)(`Optional content group not found: ${id}`);\n            return true;\n          }\n          if (this.#groups.get(id).visible) {\n            return false;\n          }\n        }\n        return true;\n      }\n      (0, _util.warn)(`Unknown optional content policy ${group.policy}.`);\n      return true;\n    }\n    (0, _util.warn)(`Unknown group type ${group.type}.`);\n    return true;\n  }\n  setVisibility(id, visible = true) {\n    if (!this.#groups.has(id)) {\n      (0, _util.warn)(`Optional content group not found: ${id}`);\n      return;\n    }\n    this.#groups.get(id)._setVisible(INTERNAL, !!visible);\n    this.#cachedGetHash = null;\n  }\n  get hasInitialVisibility() {\n    return this.#initialHash === null || this.getHash() === this.#initialHash;\n  }\n  getOrder() {\n    if (!this.#groups.size) {\n      return null;\n    }\n    if (this.#order) {\n      return this.#order.slice();\n    }\n    return [...this.#groups.keys()];\n  }\n  getGroups() {\n    return this.#groups.size > 0 ? (0, _util.objectFromMap)(this.#groups) : null;\n  }\n  getGroup(id) {\n    return this.#groups.get(id) || null;\n  }\n  getHash() {\n    if (this.#cachedGetHash !== null) {\n      return this.#cachedGetHash;\n    }\n    const hash = new _murmurhash.MurmurHash3_64();\n    for (const [id, group] of this.#groups) {\n      hash.update(`${id}:${group.visible}`);\n    }\n    return this.#cachedGetHash = hash.hexdigest();\n  }\n}\nexports.OptionalContentConfig = OptionalContentConfig;\n\n/***/ }),\n/* 18 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.PDFDataTransportStream = void 0;\nvar _util = __w_pdfjs_require__(1);\nvar _display_utils = __w_pdfjs_require__(6);\nclass PDFDataTransportStream {\n  constructor({\n    length,\n    initialData,\n    progressiveDone = false,\n    contentDispositionFilename = null,\n    disableRange = false,\n    disableStream = false\n  }, pdfDataRangeTransport) {\n    (0, _util.assert)(pdfDataRangeTransport, 'PDFDataTransportStream - missing required \"pdfDataRangeTransport\" argument.');\n    this._queuedChunks = [];\n    this._progressiveDone = progressiveDone;\n    this._contentDispositionFilename = contentDispositionFilename;\n    if (initialData?.length > 0) {\n      const buffer = initialData instanceof Uint8Array && initialData.byteLength === initialData.buffer.byteLength ? initialData.buffer : new Uint8Array(initialData).buffer;\n      this._queuedChunks.push(buffer);\n    }\n    this._pdfDataRangeTransport = pdfDataRangeTransport;\n    this._isStreamingSupported = !disableStream;\n    this._isRangeSupported = !disableRange;\n    this._contentLength = length;\n    this._fullRequestReader = null;\n    this._rangeReaders = [];\n    this._pdfDataRangeTransport.addRangeListener((begin, chunk) => {\n      this._onReceiveData({\n        begin,\n        chunk\n      });\n    });\n    this._pdfDataRangeTransport.addProgressListener((loaded, total) => {\n      this._onProgress({\n        loaded,\n        total\n      });\n    });\n    this._pdfDataRangeTransport.addProgressiveReadListener(chunk => {\n      this._onReceiveData({\n        chunk\n      });\n    });\n    this._pdfDataRangeTransport.addProgressiveDoneListener(() => {\n      this._onProgressiveDone();\n    });\n    this._pdfDataRangeTransport.transportReady();\n  }\n  _onReceiveData({\n    begin,\n    chunk\n  }) {\n    const buffer = chunk instanceof Uint8Array && chunk.byteLength === chunk.buffer.byteLength ? chunk.buffer : new Uint8Array(chunk).buffer;\n    if (begin === undefined) {\n      if (this._fullRequestReader) {\n        this._fullRequestReader._enqueue(buffer);\n      } else {\n        this._queuedChunks.push(buffer);\n      }\n    } else {\n      const found = this._rangeReaders.some(function (rangeReader) {\n        if (rangeReader._begin !== begin) {\n          return false;\n        }\n        rangeReader._enqueue(buffer);\n        return true;\n      });\n      (0, _util.assert)(found, \"_onReceiveData - no `PDFDataTransportStreamRangeReader` instance found.\");\n    }\n  }\n  get _progressiveDataLength() {\n    return this._fullRequestReader?._loaded ?? 0;\n  }\n  _onProgress(evt) {\n    if (evt.total === undefined) {\n      this._rangeReaders[0]?.onProgress?.({\n        loaded: evt.loaded\n      });\n    } else {\n      this._fullRequestReader?.onProgress?.({\n        loaded: evt.loaded,\n        total: evt.total\n      });\n    }\n  }\n  _onProgressiveDone() {\n    this._fullRequestReader?.progressiveDone();\n    this._progressiveDone = true;\n  }\n  _removeRangeReader(reader) {\n    const i = this._rangeReaders.indexOf(reader);\n    if (i >= 0) {\n      this._rangeReaders.splice(i, 1);\n    }\n  }\n  getFullReader() {\n    (0, _util.assert)(!this._fullRequestReader, \"PDFDataTransportStream.getFullReader can only be called once.\");\n    const queuedChunks = this._queuedChunks;\n    this._queuedChunks = null;\n    return new PDFDataTransportStreamReader(this, queuedChunks, this._progressiveDone, this._contentDispositionFilename);\n  }\n  getRangeReader(begin, end) {\n    if (end <= this._progressiveDataLength) {\n      return null;\n    }\n    const reader = new PDFDataTransportStreamRangeReader(this, begin, end);\n    this._pdfDataRangeTransport.requestDataRange(begin, end);\n    this._rangeReaders.push(reader);\n    return reader;\n  }\n  cancelAllRequests(reason) {\n    this._fullRequestReader?.cancel(reason);\n    for (const reader of this._rangeReaders.slice(0)) {\n      reader.cancel(reason);\n    }\n    this._pdfDataRangeTransport.abort();\n  }\n}\nexports.PDFDataTransportStream = PDFDataTransportStream;\nclass PDFDataTransportStreamReader {\n  constructor(stream, queuedChunks, progressiveDone = false, contentDispositionFilename = null) {\n    this._stream = stream;\n    this._done = progressiveDone || false;\n    this._filename = (0, _display_utils.isPdfFile)(contentDispositionFilename) ? contentDispositionFilename : null;\n    this._queuedChunks = queuedChunks || [];\n    this._loaded = 0;\n    for (const chunk of this._queuedChunks) {\n      this._loaded += chunk.byteLength;\n    }\n    this._requests = [];\n    this._headersReady = Promise.resolve();\n    stream._fullRequestReader = this;\n    this.onProgress = null;\n  }\n  _enqueue(chunk) {\n    if (this._done) {\n      return;\n    }\n    if (this._requests.length > 0) {\n      const requestCapability = this._requests.shift();\n      requestCapability.resolve({\n        value: chunk,\n        done: false\n      });\n    } else {\n      this._queuedChunks.push(chunk);\n    }\n    this._loaded += chunk.byteLength;\n  }\n  get headersReady() {\n    return this._headersReady;\n  }\n  get filename() {\n    return this._filename;\n  }\n  get isRangeSupported() {\n    return this._stream._isRangeSupported;\n  }\n  get isStreamingSupported() {\n    return this._stream._isStreamingSupported;\n  }\n  get contentLength() {\n    return this._stream._contentLength;\n  }\n  async read() {\n    if (this._queuedChunks.length > 0) {\n      const chunk = this._queuedChunks.shift();\n      return {\n        value: chunk,\n        done: false\n      };\n    }\n    if (this._done) {\n      return {\n        value: undefined,\n        done: true\n      };\n    }\n    const requestCapability = new _util.PromiseCapability();\n    this._requests.push(requestCapability);\n    return requestCapability.promise;\n  }\n  cancel(reason) {\n    this._done = true;\n    for (const requestCapability of this._requests) {\n      requestCapability.resolve({\n        value: undefined,\n        done: true\n      });\n    }\n    this._requests.length = 0;\n  }\n  progressiveDone() {\n    if (this._done) {\n      return;\n    }\n    this._done = true;\n  }\n}\nclass PDFDataTransportStreamRangeReader {\n  constructor(stream, begin, end) {\n    this._stream = stream;\n    this._begin = begin;\n    this._end = end;\n    this._queuedChunk = null;\n    this._requests = [];\n    this._done = false;\n    this.onProgress = null;\n  }\n  _enqueue(chunk) {\n    if (this._done) {\n      return;\n    }\n    if (this._requests.length === 0) {\n      this._queuedChunk = chunk;\n    } else {\n      const requestsCapability = this._requests.shift();\n      requestsCapability.resolve({\n        value: chunk,\n        done: false\n      });\n      for (const requestCapability of this._requests) {\n        requestCapability.resolve({\n          value: undefined,\n          done: true\n        });\n      }\n      this._requests.length = 0;\n    }\n    this._done = true;\n    this._stream._removeRangeReader(this);\n  }\n  get isStreamingSupported() {\n    return false;\n  }\n  async read() {\n    if (this._queuedChunk) {\n      const chunk = this._queuedChunk;\n      this._queuedChunk = null;\n      return {\n        value: chunk,\n        done: false\n      };\n    }\n    if (this._done) {\n      return {\n        value: undefined,\n        done: true\n      };\n    }\n    const requestCapability = new _util.PromiseCapability();\n    this._requests.push(requestCapability);\n    return requestCapability.promise;\n  }\n  cancel(reason) {\n    this._done = true;\n    for (const requestCapability of this._requests) {\n      requestCapability.resolve({\n        value: undefined,\n        done: true\n      });\n    }\n    this._requests.length = 0;\n    this._stream._removeRangeReader(this);\n  }\n}\n\n/***/ }),\n/* 19 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.PDFFetchStream = void 0;\nvar _util = __w_pdfjs_require__(1);\nvar _network_utils = __w_pdfjs_require__(20);\n;\nfunction createFetchOptions(headers, withCredentials, abortController) {\n  return {\n    method: \"GET\",\n    headers,\n    signal: abortController.signal,\n    mode: \"cors\",\n    credentials: withCredentials ? \"include\" : \"same-origin\",\n    redirect: \"follow\"\n  };\n}\nfunction createHeaders(httpHeaders) {\n  const headers = new Headers();\n  for (const property in httpHeaders) {\n    const value = httpHeaders[property];\n    if (value === undefined) {\n      continue;\n    }\n    headers.append(property, value);\n  }\n  return headers;\n}\nfunction getArrayBuffer(val) {\n  if (val instanceof Uint8Array) {\n    return val.buffer;\n  }\n  if (val instanceof ArrayBuffer) {\n    return val;\n  }\n  (0, _util.warn)(`getArrayBuffer - unexpected data format: ${val}`);\n  return new Uint8Array(val).buffer;\n}\nclass PDFFetchStream {\n  constructor(source) {\n    this.source = source;\n    this.isHttp = /^https?:/i.test(source.url);\n    this.httpHeaders = this.isHttp && source.httpHeaders || {};\n    this._fullRequestReader = null;\n    this._rangeRequestReaders = [];\n  }\n  get _progressiveDataLength() {\n    return this._fullRequestReader?._loaded ?? 0;\n  }\n  getFullReader() {\n    (0, _util.assert)(!this._fullRequestReader, \"PDFFetchStream.getFullReader can only be called once.\");\n    this._fullRequestReader = new PDFFetchStreamReader(this);\n    return this._fullRequestReader;\n  }\n  getRangeReader(begin, end) {\n    if (end <= this._progressiveDataLength) {\n      return null;\n    }\n    const reader = new PDFFetchStreamRangeReader(this, begin, end);\n    this._rangeRequestReaders.push(reader);\n    return reader;\n  }\n  cancelAllRequests(reason) {\n    this._fullRequestReader?.cancel(reason);\n    for (const reader of this._rangeRequestReaders.slice(0)) {\n      reader.cancel(reason);\n    }\n  }\n}\nexports.PDFFetchStream = PDFFetchStream;\nclass PDFFetchStreamReader {\n  constructor(stream) {\n    this._stream = stream;\n    this._reader = null;\n    this._loaded = 0;\n    this._filename = null;\n    const source = stream.source;\n    this._withCredentials = source.withCredentials || false;\n    this._contentLength = source.length;\n    this._headersCapability = new _util.PromiseCapability();\n    this._disableRange = source.disableRange || false;\n    this._rangeChunkSize = source.rangeChunkSize;\n    if (!this._rangeChunkSize && !this._disableRange) {\n      this._disableRange = true;\n    }\n    this._abortController = new AbortController();\n    this._isStreamingSupported = !source.disableStream;\n    this._isRangeSupported = !source.disableRange;\n    this._headers = createHeaders(this._stream.httpHeaders);\n    const url = source.url;\n    fetch(url, createFetchOptions(this._headers, this._withCredentials, this._abortController)).then(response => {\n      if (!(0, _network_utils.validateResponseStatus)(response.status)) {\n        throw (0, _network_utils.createResponseStatusError)(response.status, url);\n      }\n      this._reader = response.body.getReader();\n      this._headersCapability.resolve();\n      const getResponseHeader = name => {\n        return response.headers.get(name);\n      };\n      const {\n        allowRangeRequests,\n        suggestedLength\n      } = (0, _network_utils.validateRangeRequestCapabilities)({\n        getResponseHeader,\n        isHttp: this._stream.isHttp,\n        rangeChunkSize: this._rangeChunkSize,\n        disableRange: this._disableRange\n      });\n      this._isRangeSupported = allowRangeRequests;\n      this._contentLength = suggestedLength || this._contentLength;\n      this._filename = (0, _network_utils.extractFilenameFromHeader)(getResponseHeader);\n      if (!this._isStreamingSupported && this._isRangeSupported) {\n        this.cancel(new _util.AbortException(\"Streaming is disabled.\"));\n      }\n    }).catch(this._headersCapability.reject);\n    this.onProgress = null;\n  }\n  get headersReady() {\n    return this._headersCapability.promise;\n  }\n  get filename() {\n    return this._filename;\n  }\n  get contentLength() {\n    return this._contentLength;\n  }\n  get isRangeSupported() {\n    return this._isRangeSupported;\n  }\n  get isStreamingSupported() {\n    return this._isStreamingSupported;\n  }\n  async read() {\n    await this._headersCapability.promise;\n    const {\n      value,\n      done\n    } = await this._reader.read();\n    if (done) {\n      return {\n        value,\n        done\n      };\n    }\n    this._loaded += value.byteLength;\n    this.onProgress?.({\n      loaded: this._loaded,\n      total: this._contentLength\n    });\n    return {\n      value: getArrayBuffer(value),\n      done: false\n    };\n  }\n  cancel(reason) {\n    this._reader?.cancel(reason);\n    this._abortController.abort();\n  }\n}\nclass PDFFetchStreamRangeReader {\n  constructor(stream, begin, end) {\n    this._stream = stream;\n    this._reader = null;\n    this._loaded = 0;\n    const source = stream.source;\n    this._withCredentials = source.withCredentials || false;\n    this._readCapability = new _util.PromiseCapability();\n    this._isStreamingSupported = !source.disableStream;\n    this._abortController = new AbortController();\n    this._headers = createHeaders(this._stream.httpHeaders);\n    this._headers.append(\"Range\", `bytes=${begin}-${end - 1}`);\n    const url = source.url;\n    fetch(url, createFetchOptions(this._headers, this._withCredentials, this._abortController)).then(response => {\n      if (!(0, _network_utils.validateResponseStatus)(response.status)) {\n        throw (0, _network_utils.createResponseStatusError)(response.status, url);\n      }\n      this._readCapability.resolve();\n      this._reader = response.body.getReader();\n    }).catch(this._readCapability.reject);\n    this.onProgress = null;\n  }\n  get isStreamingSupported() {\n    return this._isStreamingSupported;\n  }\n  async read() {\n    await this._readCapability.promise;\n    const {\n      value,\n      done\n    } = await this._reader.read();\n    if (done) {\n      return {\n        value,\n        done\n      };\n    }\n    this._loaded += value.byteLength;\n    this.onProgress?.({\n      loaded: this._loaded\n    });\n    return {\n      value: getArrayBuffer(value),\n      done: false\n    };\n  }\n  cancel(reason) {\n    this._reader?.cancel(reason);\n    this._abortController.abort();\n  }\n}\n\n/***/ }),\n/* 20 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.createResponseStatusError = createResponseStatusError;\nexports.extractFilenameFromHeader = extractFilenameFromHeader;\nexports.validateRangeRequestCapabilities = validateRangeRequestCapabilities;\nexports.validateResponseStatus = validateResponseStatus;\nvar _util = __w_pdfjs_require__(1);\nvar _content_disposition = __w_pdfjs_require__(21);\nvar _display_utils = __w_pdfjs_require__(6);\nfunction validateRangeRequestCapabilities({\n  getResponseHeader,\n  isHttp,\n  rangeChunkSize,\n  disableRange\n}) {\n  const returnValues = {\n    allowRangeRequests: false,\n    suggestedLength: undefined\n  };\n  const length = parseInt(getResponseHeader(\"Content-Length\"), 10);\n  if (!Number.isInteger(length)) {\n    return returnValues;\n  }\n  returnValues.suggestedLength = length;\n  if (length <= 2 * rangeChunkSize) {\n    return returnValues;\n  }\n  if (disableRange || !isHttp) {\n    return returnValues;\n  }\n  if (getResponseHeader(\"Accept-Ranges\") !== \"bytes\") {\n    return returnValues;\n  }\n  const contentEncoding = getResponseHeader(\"Content-Encoding\") || \"identity\";\n  if (contentEncoding !== \"identity\") {\n    return returnValues;\n  }\n  returnValues.allowRangeRequests = true;\n  return returnValues;\n}\nfunction extractFilenameFromHeader(getResponseHeader) {\n  const contentDisposition = getResponseHeader(\"Content-Disposition\");\n  if (contentDisposition) {\n    let filename = (0, _content_disposition.getFilenameFromContentDispositionHeader)(contentDisposition);\n    if (filename.includes(\"%\")) {\n      try {\n        filename = decodeURIComponent(filename);\n      } catch {}\n    }\n    if ((0, _display_utils.isPdfFile)(filename)) {\n      return filename;\n    }\n  }\n  return null;\n}\nfunction createResponseStatusError(status, url) {\n  if (status === 404 || status === 0 && url.startsWith(\"file:\")) {\n    return new _util.MissingPDFException('Missing PDF \"' + url + '\".');\n  }\n  return new _util.UnexpectedResponseException(`Unexpected server response (${status}) while retrieving PDF \"${url}\".`, status);\n}\nfunction validateResponseStatus(status) {\n  return status === 200 || status === 206;\n}\n\n/***/ }),\n/* 21 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.getFilenameFromContentDispositionHeader = getFilenameFromContentDispositionHeader;\nvar _util = __w_pdfjs_require__(1);\nfunction getFilenameFromContentDispositionHeader(contentDisposition) {\n  let needsEncodingFixup = true;\n  let tmp = toParamRegExp(\"filename\\\\*\", \"i\").exec(contentDisposition);\n  if (tmp) {\n    tmp = tmp[1];\n    let filename = rfc2616unquote(tmp);\n    filename = unescape(filename);\n    filename = rfc5987decode(filename);\n    filename = rfc2047decode(filename);\n    return fixupEncoding(filename);\n  }\n  tmp = rfc2231getparam(contentDisposition);\n  if (tmp) {\n    const filename = rfc2047decode(tmp);\n    return fixupEncoding(filename);\n  }\n  tmp = toParamRegExp(\"filename\", \"i\").exec(contentDisposition);\n  if (tmp) {\n    tmp = tmp[1];\n    let filename = rfc2616unquote(tmp);\n    filename = rfc2047decode(filename);\n    return fixupEncoding(filename);\n  }\n  function toParamRegExp(attributePattern, flags) {\n    return new RegExp(\"(?:^|;)\\\\s*\" + attributePattern + \"\\\\s*=\\\\s*\" + \"(\" + '[^\";\\\\s][^;\\\\s]*' + \"|\" + '\"(?:[^\"\\\\\\\\]|\\\\\\\\\"?)+\"?' + \")\", flags);\n  }\n  function textdecode(encoding, value) {\n    if (encoding) {\n      if (!/^[\\x00-\\xFF]+$/.test(value)) {\n        return value;\n      }\n      try {\n        const decoder = new TextDecoder(encoding, {\n          fatal: true\n        });\n        const buffer = (0, _util.stringToBytes)(value);\n        value = decoder.decode(buffer);\n        needsEncodingFixup = false;\n      } catch {}\n    }\n    return value;\n  }\n  function fixupEncoding(value) {\n    if (needsEncodingFixup && /[\\x80-\\xff]/.test(value)) {\n      value = textdecode(\"utf-8\", value);\n      if (needsEncodingFixup) {\n        value = textdecode(\"iso-8859-1\", value);\n      }\n    }\n    return value;\n  }\n  function rfc2231getparam(contentDispositionStr) {\n    const matches = [];\n    let match;\n    const iter = toParamRegExp(\"filename\\\\*((?!0\\\\d)\\\\d+)(\\\\*?)\", \"ig\");\n    while ((match = iter.exec(contentDispositionStr)) !== null) {\n      let [, n, quot, part] = match;\n      n = parseInt(n, 10);\n      if (n in matches) {\n        if (n === 0) {\n          break;\n        }\n        continue;\n      }\n      matches[n] = [quot, part];\n    }\n    const parts = [];\n    for (let n = 0; n < matches.length; ++n) {\n      if (!(n in matches)) {\n        break;\n      }\n      let [quot, part] = matches[n];\n      part = rfc2616unquote(part);\n      if (quot) {\n        part = unescape(part);\n        if (n === 0) {\n          part = rfc5987decode(part);\n        }\n      }\n      parts.push(part);\n    }\n    return parts.join(\"\");\n  }\n  function rfc2616unquote(value) {\n    if (value.startsWith('\"')) {\n      const parts = value.slice(1).split('\\\\\"');\n      for (let i = 0; i < parts.length; ++i) {\n        const quotindex = parts[i].indexOf('\"');\n        if (quotindex !== -1) {\n          parts[i] = parts[i].slice(0, quotindex);\n          parts.length = i + 1;\n        }\n        parts[i] = parts[i].replaceAll(/\\\\(.)/g, \"$1\");\n      }\n      value = parts.join('\"');\n    }\n    return value;\n  }\n  function rfc5987decode(extvalue) {\n    const encodingend = extvalue.indexOf(\"'\");\n    if (encodingend === -1) {\n      return extvalue;\n    }\n    const encoding = extvalue.slice(0, encodingend);\n    const langvalue = extvalue.slice(encodingend + 1);\n    const value = langvalue.replace(/^[^']*'/, \"\");\n    return textdecode(encoding, value);\n  }\n  function rfc2047decode(value) {\n    if (!value.startsWith(\"=?\") || /[\\x00-\\x19\\x80-\\xff]/.test(value)) {\n      return value;\n    }\n    return value.replaceAll(/=\\?([\\w-]*)\\?([QqBb])\\?((?:[^?]|\\?(?!=))*)\\?=/g, function (matches, charset, encoding, text) {\n      if (encoding === \"q\" || encoding === \"Q\") {\n        text = text.replaceAll(\"_\", \" \");\n        text = text.replaceAll(/=([0-9a-fA-F]{2})/g, function (match, hex) {\n          return String.fromCharCode(parseInt(hex, 16));\n        });\n        return textdecode(charset, text);\n      }\n      try {\n        text = atob(text);\n      } catch {}\n      return textdecode(charset, text);\n    });\n  }\n  return \"\";\n}\n\n/***/ }),\n/* 22 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.PDFNetworkStream = void 0;\nvar _util = __w_pdfjs_require__(1);\nvar _network_utils = __w_pdfjs_require__(20);\n;\nconst OK_RESPONSE = 200;\nconst PARTIAL_CONTENT_RESPONSE = 206;\nfunction getArrayBuffer(xhr) {\n  const data = xhr.response;\n  if (typeof data !== \"string\") {\n    return data;\n  }\n  return (0, _util.stringToBytes)(data).buffer;\n}\nclass NetworkManager {\n  constructor(url, args = {}) {\n    this.url = url;\n    this.isHttp = /^https?:/i.test(url);\n    this.httpHeaders = this.isHttp && args.httpHeaders || Object.create(null);\n    this.withCredentials = args.withCredentials || false;\n    this.currXhrId = 0;\n    this.pendingRequests = Object.create(null);\n  }\n  requestRange(begin, end, listeners) {\n    const args = {\n      begin,\n      end\n    };\n    for (const prop in listeners) {\n      args[prop] = listeners[prop];\n    }\n    return this.request(args);\n  }\n  requestFull(listeners) {\n    return this.request(listeners);\n  }\n  request(args) {\n    const xhr = new XMLHttpRequest();\n    const xhrId = this.currXhrId++;\n    const pendingRequest = this.pendingRequests[xhrId] = {\n      xhr\n    };\n    xhr.open(\"GET\", this.url);\n    xhr.withCredentials = this.withCredentials;\n    for (const property in this.httpHeaders) {\n      const value = this.httpHeaders[property];\n      if (value === undefined) {\n        continue;\n      }\n      xhr.setRequestHeader(property, value);\n    }\n    if (this.isHttp && \"begin\" in args && \"end\" in args) {\n      xhr.setRequestHeader(\"Range\", `bytes=${args.begin}-${args.end - 1}`);\n      pendingRequest.expectedStatus = PARTIAL_CONTENT_RESPONSE;\n    } else {\n      pendingRequest.expectedStatus = OK_RESPONSE;\n    }\n    xhr.responseType = \"arraybuffer\";\n    if (args.onError) {\n      xhr.onerror = function (evt) {\n        args.onError(xhr.status);\n      };\n    }\n    xhr.onreadystatechange = this.onStateChange.bind(this, xhrId);\n    xhr.onprogress = this.onProgress.bind(this, xhrId);\n    pendingRequest.onHeadersReceived = args.onHeadersReceived;\n    pendingRequest.onDone = args.onDone;\n    pendingRequest.onError = args.onError;\n    pendingRequest.onProgress = args.onProgress;\n    xhr.send(null);\n    return xhrId;\n  }\n  onProgress(xhrId, evt) {\n    const pendingRequest = this.pendingRequests[xhrId];\n    if (!pendingRequest) {\n      return;\n    }\n    pendingRequest.onProgress?.(evt);\n  }\n  onStateChange(xhrId, evt) {\n    const pendingRequest = this.pendingRequests[xhrId];\n    if (!pendingRequest) {\n      return;\n    }\n    const xhr = pendingRequest.xhr;\n    if (xhr.readyState >= 2 && pendingRequest.onHeadersReceived) {\n      pendingRequest.onHeadersReceived();\n      delete pendingRequest.onHeadersReceived;\n    }\n    if (xhr.readyState !== 4) {\n      return;\n    }\n    if (!(xhrId in this.pendingRequests)) {\n      return;\n    }\n    delete this.pendingRequests[xhrId];\n    if (xhr.status === 0 && this.isHttp) {\n      pendingRequest.onError?.(xhr.status);\n      return;\n    }\n    const xhrStatus = xhr.status || OK_RESPONSE;\n    const ok_response_on_range_request = xhrStatus === OK_RESPONSE && pendingRequest.expectedStatus === PARTIAL_CONTENT_RESPONSE;\n    if (!ok_response_on_range_request && xhrStatus !== pendingRequest.expectedStatus) {\n      pendingRequest.onError?.(xhr.status);\n      return;\n    }\n    const chunk = getArrayBuffer(xhr);\n    if (xhrStatus === PARTIAL_CONTENT_RESPONSE) {\n      const rangeHeader = xhr.getResponseHeader(\"Content-Range\");\n      const matches = /bytes (\\d+)-(\\d+)\\/(\\d+)/.exec(rangeHeader);\n      pendingRequest.onDone({\n        begin: parseInt(matches[1], 10),\n        chunk\n      });\n    } else if (chunk) {\n      pendingRequest.onDone({\n        begin: 0,\n        chunk\n      });\n    } else {\n      pendingRequest.onError?.(xhr.status);\n    }\n  }\n  getRequestXhr(xhrId) {\n    return this.pendingRequests[xhrId].xhr;\n  }\n  isPendingRequest(xhrId) {\n    return xhrId in this.pendingRequests;\n  }\n  abortRequest(xhrId) {\n    const xhr = this.pendingRequests[xhrId].xhr;\n    delete this.pendingRequests[xhrId];\n    xhr.abort();\n  }\n}\nclass PDFNetworkStream {\n  constructor(source) {\n    this._source = source;\n    this._manager = new NetworkManager(source.url, {\n      httpHeaders: source.httpHeaders,\n      withCredentials: source.withCredentials\n    });\n    this._rangeChunkSize = source.rangeChunkSize;\n    this._fullRequestReader = null;\n    this._rangeRequestReaders = [];\n  }\n  _onRangeRequestReaderClosed(reader) {\n    const i = this._rangeRequestReaders.indexOf(reader);\n    if (i >= 0) {\n      this._rangeRequestReaders.splice(i, 1);\n    }\n  }\n  getFullReader() {\n    (0, _util.assert)(!this._fullRequestReader, \"PDFNetworkStream.getFullReader can only be called once.\");\n    this._fullRequestReader = new PDFNetworkStreamFullRequestReader(this._manager, this._source);\n    return this._fullRequestReader;\n  }\n  getRangeReader(begin, end) {\n    const reader = new PDFNetworkStreamRangeRequestReader(this._manager, begin, end);\n    reader.onClosed = this._onRangeRequestReaderClosed.bind(this);\n    this._rangeRequestReaders.push(reader);\n    return reader;\n  }\n  cancelAllRequests(reason) {\n    this._fullRequestReader?.cancel(reason);\n    for (const reader of this._rangeRequestReaders.slice(0)) {\n      reader.cancel(reason);\n    }\n  }\n}\nexports.PDFNetworkStream = PDFNetworkStream;\nclass PDFNetworkStreamFullRequestReader {\n  constructor(manager, source) {\n    this._manager = manager;\n    const args = {\n      onHeadersReceived: this._onHeadersReceived.bind(this),\n      onDone: this._onDone.bind(this),\n      onError: this._onError.bind(this),\n      onProgress: this._onProgress.bind(this)\n    };\n    this._url = source.url;\n    this._fullRequestId = manager.requestFull(args);\n    this._headersReceivedCapability = new _util.PromiseCapability();\n    this._disableRange = source.disableRange || false;\n    this._contentLength = source.length;\n    this._rangeChunkSize = source.rangeChunkSize;\n    if (!this._rangeChunkSize && !this._disableRange) {\n      this._disableRange = true;\n    }\n    this._isStreamingSupported = false;\n    this._isRangeSupported = false;\n    this._cachedChunks = [];\n    this._requests = [];\n    this._done = false;\n    this._storedError = undefined;\n    this._filename = null;\n    this.onProgress = null;\n  }\n  _onHeadersReceived() {\n    const fullRequestXhrId = this._fullRequestId;\n    const fullRequestXhr = this._manager.getRequestXhr(fullRequestXhrId);\n    const getResponseHeader = name => {\n      return fullRequestXhr.getResponseHeader(name);\n    };\n    const {\n      allowRangeRequests,\n      suggestedLength\n    } = (0, _network_utils.validateRangeRequestCapabilities)({\n      getResponseHeader,\n      isHttp: this._manager.isHttp,\n      rangeChunkSize: this._rangeChunkSize,\n      disableRange: this._disableRange\n    });\n    if (allowRangeRequests) {\n      this._isRangeSupported = true;\n    }\n    this._contentLength = suggestedLength || this._contentLength;\n    this._filename = (0, _network_utils.extractFilenameFromHeader)(getResponseHeader);\n    if (this._isRangeSupported) {\n      this._manager.abortRequest(fullRequestXhrId);\n    }\n    this._headersReceivedCapability.resolve();\n  }\n  _onDone(data) {\n    if (data) {\n      if (this._requests.length > 0) {\n        const requestCapability = this._requests.shift();\n        requestCapability.resolve({\n          value: data.chunk,\n          done: false\n        });\n      } else {\n        this._cachedChunks.push(data.chunk);\n      }\n    }\n    this._done = true;\n    if (this._cachedChunks.length > 0) {\n      return;\n    }\n    for (const requestCapability of this._requests) {\n      requestCapability.resolve({\n        value: undefined,\n        done: true\n      });\n    }\n    this._requests.length = 0;\n  }\n  _onError(status) {\n    this._storedError = (0, _network_utils.createResponseStatusError)(status, this._url);\n    this._headersReceivedCapability.reject(this._storedError);\n    for (const requestCapability of this._requests) {\n      requestCapability.reject(this._storedError);\n    }\n    this._requests.length = 0;\n    this._cachedChunks.length = 0;\n  }\n  _onProgress(evt) {\n    this.onProgress?.({\n      loaded: evt.loaded,\n      total: evt.lengthComputable ? evt.total : this._contentLength\n    });\n  }\n  get filename() {\n    return this._filename;\n  }\n  get isRangeSupported() {\n    return this._isRangeSupported;\n  }\n  get isStreamingSupported() {\n    return this._isStreamingSupported;\n  }\n  get contentLength() {\n    return this._contentLength;\n  }\n  get headersReady() {\n    return this._headersReceivedCapability.promise;\n  }\n  async read() {\n    if (this._storedError) {\n      throw this._storedError;\n    }\n    if (this._cachedChunks.length > 0) {\n      const chunk = this._cachedChunks.shift();\n      return {\n        value: chunk,\n        done: false\n      };\n    }\n    if (this._done) {\n      return {\n        value: undefined,\n        done: true\n      };\n    }\n    const requestCapability = new _util.PromiseCapability();\n    this._requests.push(requestCapability);\n    return requestCapability.promise;\n  }\n  cancel(reason) {\n    this._done = true;\n    this._headersReceivedCapability.reject(reason);\n    for (const requestCapability of this._requests) {\n      requestCapability.resolve({\n        value: undefined,\n        done: true\n      });\n    }\n    this._requests.length = 0;\n    if (this._manager.isPendingRequest(this._fullRequestId)) {\n      this._manager.abortRequest(this._fullRequestId);\n    }\n    this._fullRequestReader = null;\n  }\n}\nclass PDFNetworkStreamRangeRequestReader {\n  constructor(manager, begin, end) {\n    this._manager = manager;\n    const args = {\n      onDone: this._onDone.bind(this),\n      onError: this._onError.bind(this),\n      onProgress: this._onProgress.bind(this)\n    };\n    this._url = manager.url;\n    this._requestId = manager.requestRange(begin, end, args);\n    this._requests = [];\n    this._queuedChunk = null;\n    this._done = false;\n    this._storedError = undefined;\n    this.onProgress = null;\n    this.onClosed = null;\n  }\n  _close() {\n    this.onClosed?.(this);\n  }\n  _onDone(data) {\n    const chunk = data.chunk;\n    if (this._requests.length > 0) {\n      const requestCapability = this._requests.shift();\n      requestCapability.resolve({\n        value: chunk,\n        done: false\n      });\n    } else {\n      this._queuedChunk = chunk;\n    }\n    this._done = true;\n    for (const requestCapability of this._requests) {\n      requestCapability.resolve({\n        value: undefined,\n        done: true\n      });\n    }\n    this._requests.length = 0;\n    this._close();\n  }\n  _onError(status) {\n    this._storedError = (0, _network_utils.createResponseStatusError)(status, this._url);\n    for (const requestCapability of this._requests) {\n      requestCapability.reject(this._storedError);\n    }\n    this._requests.length = 0;\n    this._queuedChunk = null;\n  }\n  _onProgress(evt) {\n    if (!this.isStreamingSupported) {\n      this.onProgress?.({\n        loaded: evt.loaded\n      });\n    }\n  }\n  get isStreamingSupported() {\n    return false;\n  }\n  async read() {\n    if (this._storedError) {\n      throw this._storedError;\n    }\n    if (this._queuedChunk !== null) {\n      const chunk = this._queuedChunk;\n      this._queuedChunk = null;\n      return {\n        value: chunk,\n        done: false\n      };\n    }\n    if (this._done) {\n      return {\n        value: undefined,\n        done: true\n      };\n    }\n    const requestCapability = new _util.PromiseCapability();\n    this._requests.push(requestCapability);\n    return requestCapability.promise;\n  }\n  cancel(reason) {\n    this._done = true;\n    for (const requestCapability of this._requests) {\n      requestCapability.resolve({\n        value: undefined,\n        done: true\n      });\n    }\n    this._requests.length = 0;\n    if (this._manager.isPendingRequest(this._requestId)) {\n      this._manager.abortRequest(this._requestId);\n    }\n    this._close();\n  }\n}\n\n/***/ }),\n/* 23 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.PDFNodeStream = void 0;\nvar _util = __w_pdfjs_require__(1);\nvar _network_utils = __w_pdfjs_require__(20);\n;\nconst fileUriRegex = /^file:\\/\\/\\/[a-zA-Z]:\\//;\nfunction parseUrl(sourceUrl) {\n  const url = __webpack_require__(/*! url */ \"(app-pages-browser)/./node_modules/next/dist/compiled/native-url/index.js\");\n  const parsedUrl = url.parse(sourceUrl);\n  if (parsedUrl.protocol === \"file:\" || parsedUrl.host) {\n    return parsedUrl;\n  }\n  if (/^[a-z]:[/\\\\]/i.test(sourceUrl)) {\n    return url.parse(`file:///${sourceUrl}`);\n  }\n  if (!parsedUrl.host) {\n    parsedUrl.protocol = \"file:\";\n  }\n  return parsedUrl;\n}\nclass PDFNodeStream {\n  constructor(source) {\n    this.source = source;\n    this.url = parseUrl(source.url);\n    this.isHttp = this.url.protocol === \"http:\" || this.url.protocol === \"https:\";\n    this.isFsUrl = this.url.protocol === \"file:\";\n    this.httpHeaders = this.isHttp && source.httpHeaders || {};\n    this._fullRequestReader = null;\n    this._rangeRequestReaders = [];\n  }\n  get _progressiveDataLength() {\n    return this._fullRequestReader?._loaded ?? 0;\n  }\n  getFullReader() {\n    (0, _util.assert)(!this._fullRequestReader, \"PDFNodeStream.getFullReader can only be called once.\");\n    this._fullRequestReader = this.isFsUrl ? new PDFNodeStreamFsFullReader(this) : new PDFNodeStreamFullReader(this);\n    return this._fullRequestReader;\n  }\n  getRangeReader(start, end) {\n    if (end <= this._progressiveDataLength) {\n      return null;\n    }\n    const rangeReader = this.isFsUrl ? new PDFNodeStreamFsRangeReader(this, start, end) : new PDFNodeStreamRangeReader(this, start, end);\n    this._rangeRequestReaders.push(rangeReader);\n    return rangeReader;\n  }\n  cancelAllRequests(reason) {\n    this._fullRequestReader?.cancel(reason);\n    for (const reader of this._rangeRequestReaders.slice(0)) {\n      reader.cancel(reason);\n    }\n  }\n}\nexports.PDFNodeStream = PDFNodeStream;\nclass BaseFullReader {\n  constructor(stream) {\n    this._url = stream.url;\n    this._done = false;\n    this._storedError = null;\n    this.onProgress = null;\n    const source = stream.source;\n    this._contentLength = source.length;\n    this._loaded = 0;\n    this._filename = null;\n    this._disableRange = source.disableRange || false;\n    this._rangeChunkSize = source.rangeChunkSize;\n    if (!this._rangeChunkSize && !this._disableRange) {\n      this._disableRange = true;\n    }\n    this._isStreamingSupported = !source.disableStream;\n    this._isRangeSupported = !source.disableRange;\n    this._readableStream = null;\n    this._readCapability = new _util.PromiseCapability();\n    this._headersCapability = new _util.PromiseCapability();\n  }\n  get headersReady() {\n    return this._headersCapability.promise;\n  }\n  get filename() {\n    return this._filename;\n  }\n  get contentLength() {\n    return this._contentLength;\n  }\n  get isRangeSupported() {\n    return this._isRangeSupported;\n  }\n  get isStreamingSupported() {\n    return this._isStreamingSupported;\n  }\n  async read() {\n    await this._readCapability.promise;\n    if (this._done) {\n      return {\n        value: undefined,\n        done: true\n      };\n    }\n    if (this._storedError) {\n      throw this._storedError;\n    }\n    const chunk = this._readableStream.read();\n    if (chunk === null) {\n      this._readCapability = new _util.PromiseCapability();\n      return this.read();\n    }\n    this._loaded += chunk.length;\n    this.onProgress?.({\n      loaded: this._loaded,\n      total: this._contentLength\n    });\n    const buffer = new Uint8Array(chunk).buffer;\n    return {\n      value: buffer,\n      done: false\n    };\n  }\n  cancel(reason) {\n    if (!this._readableStream) {\n      this._error(reason);\n      return;\n    }\n    this._readableStream.destroy(reason);\n  }\n  _error(reason) {\n    this._storedError = reason;\n    this._readCapability.resolve();\n  }\n  _setReadableStream(readableStream) {\n    this._readableStream = readableStream;\n    readableStream.on(\"readable\", () => {\n      this._readCapability.resolve();\n    });\n    readableStream.on(\"end\", () => {\n      readableStream.destroy();\n      this._done = true;\n      this._readCapability.resolve();\n    });\n    readableStream.on(\"error\", reason => {\n      this._error(reason);\n    });\n    if (!this._isStreamingSupported && this._isRangeSupported) {\n      this._error(new _util.AbortException(\"streaming is disabled\"));\n    }\n    if (this._storedError) {\n      this._readableStream.destroy(this._storedError);\n    }\n  }\n}\nclass BaseRangeReader {\n  constructor(stream) {\n    this._url = stream.url;\n    this._done = false;\n    this._storedError = null;\n    this.onProgress = null;\n    this._loaded = 0;\n    this._readableStream = null;\n    this._readCapability = new _util.PromiseCapability();\n    const source = stream.source;\n    this._isStreamingSupported = !source.disableStream;\n  }\n  get isStreamingSupported() {\n    return this._isStreamingSupported;\n  }\n  async read() {\n    await this._readCapability.promise;\n    if (this._done) {\n      return {\n        value: undefined,\n        done: true\n      };\n    }\n    if (this._storedError) {\n      throw this._storedError;\n    }\n    const chunk = this._readableStream.read();\n    if (chunk === null) {\n      this._readCapability = new _util.PromiseCapability();\n      return this.read();\n    }\n    this._loaded += chunk.length;\n    this.onProgress?.({\n      loaded: this._loaded\n    });\n    const buffer = new Uint8Array(chunk).buffer;\n    return {\n      value: buffer,\n      done: false\n    };\n  }\n  cancel(reason) {\n    if (!this._readableStream) {\n      this._error(reason);\n      return;\n    }\n    this._readableStream.destroy(reason);\n  }\n  _error(reason) {\n    this._storedError = reason;\n    this._readCapability.resolve();\n  }\n  _setReadableStream(readableStream) {\n    this._readableStream = readableStream;\n    readableStream.on(\"readable\", () => {\n      this._readCapability.resolve();\n    });\n    readableStream.on(\"end\", () => {\n      readableStream.destroy();\n      this._done = true;\n      this._readCapability.resolve();\n    });\n    readableStream.on(\"error\", reason => {\n      this._error(reason);\n    });\n    if (this._storedError) {\n      this._readableStream.destroy(this._storedError);\n    }\n  }\n}\nfunction createRequestOptions(parsedUrl, headers) {\n  return {\n    protocol: parsedUrl.protocol,\n    auth: parsedUrl.auth,\n    host: parsedUrl.hostname,\n    port: parsedUrl.port,\n    path: parsedUrl.path,\n    method: \"GET\",\n    headers\n  };\n}\nclass PDFNodeStreamFullReader extends BaseFullReader {\n  constructor(stream) {\n    super(stream);\n    const handleResponse = response => {\n      if (response.statusCode === 404) {\n        const error = new _util.MissingPDFException(`Missing PDF \"${this._url}\".`);\n        this._storedError = error;\n        this._headersCapability.reject(error);\n        return;\n      }\n      this._headersCapability.resolve();\n      this._setReadableStream(response);\n      const getResponseHeader = name => {\n        return this._readableStream.headers[name.toLowerCase()];\n      };\n      const {\n        allowRangeRequests,\n        suggestedLength\n      } = (0, _network_utils.validateRangeRequestCapabilities)({\n        getResponseHeader,\n        isHttp: stream.isHttp,\n        rangeChunkSize: this._rangeChunkSize,\n        disableRange: this._disableRange\n      });\n      this._isRangeSupported = allowRangeRequests;\n      this._contentLength = suggestedLength || this._contentLength;\n      this._filename = (0, _network_utils.extractFilenameFromHeader)(getResponseHeader);\n    };\n    this._request = null;\n    if (this._url.protocol === \"http:\") {\n      const http = __webpack_require__(/*! http */ \"?0b2e\");\n      this._request = http.request(createRequestOptions(this._url, stream.httpHeaders), handleResponse);\n    } else {\n      const https = __webpack_require__(/*! https */ \"?fd26\");\n      this._request = https.request(createRequestOptions(this._url, stream.httpHeaders), handleResponse);\n    }\n    this._request.on(\"error\", reason => {\n      this._storedError = reason;\n      this._headersCapability.reject(reason);\n    });\n    this._request.end();\n  }\n}\nclass PDFNodeStreamRangeReader extends BaseRangeReader {\n  constructor(stream, start, end) {\n    super(stream);\n    this._httpHeaders = {};\n    for (const property in stream.httpHeaders) {\n      const value = stream.httpHeaders[property];\n      if (value === undefined) {\n        continue;\n      }\n      this._httpHeaders[property] = value;\n    }\n    this._httpHeaders.Range = `bytes=${start}-${end - 1}`;\n    const handleResponse = response => {\n      if (response.statusCode === 404) {\n        const error = new _util.MissingPDFException(`Missing PDF \"${this._url}\".`);\n        this._storedError = error;\n        return;\n      }\n      this._setReadableStream(response);\n    };\n    this._request = null;\n    if (this._url.protocol === \"http:\") {\n      const http = __webpack_require__(/*! http */ \"?0b2e\");\n      this._request = http.request(createRequestOptions(this._url, this._httpHeaders), handleResponse);\n    } else {\n      const https = __webpack_require__(/*! https */ \"?fd26\");\n      this._request = https.request(createRequestOptions(this._url, this._httpHeaders), handleResponse);\n    }\n    this._request.on(\"error\", reason => {\n      this._storedError = reason;\n    });\n    this._request.end();\n  }\n}\nclass PDFNodeStreamFsFullReader extends BaseFullReader {\n  constructor(stream) {\n    super(stream);\n    let path = decodeURIComponent(this._url.path);\n    if (fileUriRegex.test(this._url.href)) {\n      path = path.replace(/^\\//, \"\");\n    }\n    const fs = __webpack_require__(/*! fs */ \"?4fe2\");\n    fs.lstat(path, (error, stat) => {\n      if (error) {\n        if (error.code === \"ENOENT\") {\n          error = new _util.MissingPDFException(`Missing PDF \"${path}\".`);\n        }\n        this._storedError = error;\n        this._headersCapability.reject(error);\n        return;\n      }\n      this._contentLength = stat.size;\n      this._setReadableStream(fs.createReadStream(path));\n      this._headersCapability.resolve();\n    });\n  }\n}\nclass PDFNodeStreamFsRangeReader extends BaseRangeReader {\n  constructor(stream, start, end) {\n    super(stream);\n    let path = decodeURIComponent(this._url.path);\n    if (fileUriRegex.test(this._url.href)) {\n      path = path.replace(/^\\//, \"\");\n    }\n    const fs = __webpack_require__(/*! fs */ \"?4fe2\");\n    this._setReadableStream(fs.createReadStream(path, {\n      start,\n      end: end - 1\n    }));\n  }\n}\n\n/***/ }),\n/* 24 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.SVGGraphics = void 0;\nvar _display_utils = __w_pdfjs_require__(6);\nvar _util = __w_pdfjs_require__(1);\n;\nconst SVG_DEFAULTS = {\n  fontStyle: \"normal\",\n  fontWeight: \"normal\",\n  fillColor: \"#000000\"\n};\nconst XML_NS = \"http://www.w3.org/XML/1998/namespace\";\nconst XLINK_NS = \"http://www.w3.org/1999/xlink\";\nconst LINE_CAP_STYLES = [\"butt\", \"round\", \"square\"];\nconst LINE_JOIN_STYLES = [\"miter\", \"round\", \"bevel\"];\nconst createObjectURL = function (data, contentType = \"\", forceDataSchema = false) {\n  if (URL.createObjectURL && typeof Blob !== \"undefined\" && !forceDataSchema) {\n    return URL.createObjectURL(new Blob([data], {\n      type: contentType\n    }));\n  }\n  const digits = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\n  let buffer = `data:${contentType};base64,`;\n  for (let i = 0, ii = data.length; i < ii; i += 3) {\n    const b1 = data[i] & 0xff;\n    const b2 = data[i + 1] & 0xff;\n    const b3 = data[i + 2] & 0xff;\n    const d1 = b1 >> 2,\n      d2 = (b1 & 3) << 4 | b2 >> 4;\n    const d3 = i + 1 < ii ? (b2 & 0xf) << 2 | b3 >> 6 : 64;\n    const d4 = i + 2 < ii ? b3 & 0x3f : 64;\n    buffer += digits[d1] + digits[d2] + digits[d3] + digits[d4];\n  }\n  return buffer;\n};\nconst convertImgDataToPng = function () {\n  const PNG_HEADER = new Uint8Array([0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a]);\n  const CHUNK_WRAPPER_SIZE = 12;\n  const crcTable = new Int32Array(256);\n  for (let i = 0; i < 256; i++) {\n    let c = i;\n    for (let h = 0; h < 8; h++) {\n      c = c & 1 ? 0xedb88320 ^ c >> 1 & 0x7fffffff : c >> 1 & 0x7fffffff;\n    }\n    crcTable[i] = c;\n  }\n  function crc32(data, start, end) {\n    let crc = -1;\n    for (let i = start; i < end; i++) {\n      const a = (crc ^ data[i]) & 0xff;\n      const b = crcTable[a];\n      crc = crc >>> 8 ^ b;\n    }\n    return crc ^ -1;\n  }\n  function writePngChunk(type, body, data, offset) {\n    let p = offset;\n    const len = body.length;\n    data[p] = len >> 24 & 0xff;\n    data[p + 1] = len >> 16 & 0xff;\n    data[p + 2] = len >> 8 & 0xff;\n    data[p + 3] = len & 0xff;\n    p += 4;\n    data[p] = type.charCodeAt(0) & 0xff;\n    data[p + 1] = type.charCodeAt(1) & 0xff;\n    data[p + 2] = type.charCodeAt(2) & 0xff;\n    data[p + 3] = type.charCodeAt(3) & 0xff;\n    p += 4;\n    data.set(body, p);\n    p += body.length;\n    const crc = crc32(data, offset + 4, p);\n    data[p] = crc >> 24 & 0xff;\n    data[p + 1] = crc >> 16 & 0xff;\n    data[p + 2] = crc >> 8 & 0xff;\n    data[p + 3] = crc & 0xff;\n  }\n  function adler32(data, start, end) {\n    let a = 1;\n    let b = 0;\n    for (let i = start; i < end; ++i) {\n      a = (a + (data[i] & 0xff)) % 65521;\n      b = (b + a) % 65521;\n    }\n    return b << 16 | a;\n  }\n  function deflateSync(literals) {\n    if (!_util.isNodeJS) {\n      return deflateSyncUncompressed(literals);\n    }\n    try {\n      const input = parseInt(process.versions.node) >= 8 ? literals : Buffer.from(literals);\n      const output = (__webpack_require__(/*! zlib */ \"?2b44\").deflateSync)(input, {\n        level: 9\n      });\n      return output instanceof Uint8Array ? output : new Uint8Array(output);\n    } catch (e) {\n      (0, _util.warn)(\"Not compressing PNG because zlib.deflateSync is unavailable: \" + e);\n    }\n    return deflateSyncUncompressed(literals);\n  }\n  function deflateSyncUncompressed(literals) {\n    let len = literals.length;\n    const maxBlockLength = 0xffff;\n    const deflateBlocks = Math.ceil(len / maxBlockLength);\n    const idat = new Uint8Array(2 + len + deflateBlocks * 5 + 4);\n    let pi = 0;\n    idat[pi++] = 0x78;\n    idat[pi++] = 0x9c;\n    let pos = 0;\n    while (len > maxBlockLength) {\n      idat[pi++] = 0x00;\n      idat[pi++] = 0xff;\n      idat[pi++] = 0xff;\n      idat[pi++] = 0x00;\n      idat[pi++] = 0x00;\n      idat.set(literals.subarray(pos, pos + maxBlockLength), pi);\n      pi += maxBlockLength;\n      pos += maxBlockLength;\n      len -= maxBlockLength;\n    }\n    idat[pi++] = 0x01;\n    idat[pi++] = len & 0xff;\n    idat[pi++] = len >> 8 & 0xff;\n    idat[pi++] = ~len & 0xffff & 0xff;\n    idat[pi++] = (~len & 0xffff) >> 8 & 0xff;\n    idat.set(literals.subarray(pos), pi);\n    pi += literals.length - pos;\n    const adler = adler32(literals, 0, literals.length);\n    idat[pi++] = adler >> 24 & 0xff;\n    idat[pi++] = adler >> 16 & 0xff;\n    idat[pi++] = adler >> 8 & 0xff;\n    idat[pi++] = adler & 0xff;\n    return idat;\n  }\n  function encode(imgData, kind, forceDataSchema, isMask) {\n    const width = imgData.width;\n    const height = imgData.height;\n    let bitDepth, colorType, lineSize;\n    const bytes = imgData.data;\n    switch (kind) {\n      case _util.ImageKind.GRAYSCALE_1BPP:\n        colorType = 0;\n        bitDepth = 1;\n        lineSize = width + 7 >> 3;\n        break;\n      case _util.ImageKind.RGB_24BPP:\n        colorType = 2;\n        bitDepth = 8;\n        lineSize = width * 3;\n        break;\n      case _util.ImageKind.RGBA_32BPP:\n        colorType = 6;\n        bitDepth = 8;\n        lineSize = width * 4;\n        break;\n      default:\n        throw new Error(\"invalid format\");\n    }\n    const literals = new Uint8Array((1 + lineSize) * height);\n    let offsetLiterals = 0,\n      offsetBytes = 0;\n    for (let y = 0; y < height; ++y) {\n      literals[offsetLiterals++] = 0;\n      literals.set(bytes.subarray(offsetBytes, offsetBytes + lineSize), offsetLiterals);\n      offsetBytes += lineSize;\n      offsetLiterals += lineSize;\n    }\n    if (kind === _util.ImageKind.GRAYSCALE_1BPP && isMask) {\n      offsetLiterals = 0;\n      for (let y = 0; y < height; y++) {\n        offsetLiterals++;\n        for (let i = 0; i < lineSize; i++) {\n          literals[offsetLiterals++] ^= 0xff;\n        }\n      }\n    }\n    const ihdr = new Uint8Array([width >> 24 & 0xff, width >> 16 & 0xff, width >> 8 & 0xff, width & 0xff, height >> 24 & 0xff, height >> 16 & 0xff, height >> 8 & 0xff, height & 0xff, bitDepth, colorType, 0x00, 0x00, 0x00]);\n    const idat = deflateSync(literals);\n    const pngLength = PNG_HEADER.length + CHUNK_WRAPPER_SIZE * 3 + ihdr.length + idat.length;\n    const data = new Uint8Array(pngLength);\n    let offset = 0;\n    data.set(PNG_HEADER, offset);\n    offset += PNG_HEADER.length;\n    writePngChunk(\"IHDR\", ihdr, data, offset);\n    offset += CHUNK_WRAPPER_SIZE + ihdr.length;\n    writePngChunk(\"IDATA\", idat, data, offset);\n    offset += CHUNK_WRAPPER_SIZE + idat.length;\n    writePngChunk(\"IEND\", new Uint8Array(0), data, offset);\n    return createObjectURL(data, \"image/png\", forceDataSchema);\n  }\n  return function convertImgDataToPng(imgData, forceDataSchema, isMask) {\n    const kind = imgData.kind === undefined ? _util.ImageKind.GRAYSCALE_1BPP : imgData.kind;\n    return encode(imgData, kind, forceDataSchema, isMask);\n  };\n}();\nclass SVGExtraState {\n  constructor() {\n    this.fontSizeScale = 1;\n    this.fontWeight = SVG_DEFAULTS.fontWeight;\n    this.fontSize = 0;\n    this.textMatrix = _util.IDENTITY_MATRIX;\n    this.fontMatrix = _util.FONT_IDENTITY_MATRIX;\n    this.leading = 0;\n    this.textRenderingMode = _util.TextRenderingMode.FILL;\n    this.textMatrixScale = 1;\n    this.x = 0;\n    this.y = 0;\n    this.lineX = 0;\n    this.lineY = 0;\n    this.charSpacing = 0;\n    this.wordSpacing = 0;\n    this.textHScale = 1;\n    this.textRise = 0;\n    this.fillColor = SVG_DEFAULTS.fillColor;\n    this.strokeColor = \"#000000\";\n    this.fillAlpha = 1;\n    this.strokeAlpha = 1;\n    this.lineWidth = 1;\n    this.lineJoin = \"\";\n    this.lineCap = \"\";\n    this.miterLimit = 0;\n    this.dashArray = [];\n    this.dashPhase = 0;\n    this.dependencies = [];\n    this.activeClipUrl = null;\n    this.clipGroup = null;\n    this.maskId = \"\";\n  }\n  clone() {\n    return Object.create(this);\n  }\n  setCurrentPoint(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n}\nfunction opListToTree(opList) {\n  let opTree = [];\n  const tmp = [];\n  for (const opListElement of opList) {\n    if (opListElement.fn === \"save\") {\n      opTree.push({\n        fnId: 92,\n        fn: \"group\",\n        items: []\n      });\n      tmp.push(opTree);\n      opTree = opTree.at(-1).items;\n      continue;\n    }\n    if (opListElement.fn === \"restore\") {\n      opTree = tmp.pop();\n    } else {\n      opTree.push(opListElement);\n    }\n  }\n  return opTree;\n}\nfunction pf(value) {\n  if (Number.isInteger(value)) {\n    return value.toString();\n  }\n  const s = value.toFixed(10);\n  let i = s.length - 1;\n  if (s[i] !== \"0\") {\n    return s;\n  }\n  do {\n    i--;\n  } while (s[i] === \"0\");\n  return s.substring(0, s[i] === \".\" ? i : i + 1);\n}\nfunction pm(m) {\n  if (m[4] === 0 && m[5] === 0) {\n    if (m[1] === 0 && m[2] === 0) {\n      if (m[0] === 1 && m[3] === 1) {\n        return \"\";\n      }\n      return `scale(${pf(m[0])} ${pf(m[3])})`;\n    }\n    if (m[0] === m[3] && m[1] === -m[2]) {\n      const a = Math.acos(m[0]) * 180 / Math.PI;\n      return `rotate(${pf(a)})`;\n    }\n  } else if (m[0] === 1 && m[1] === 0 && m[2] === 0 && m[3] === 1) {\n    return `translate(${pf(m[4])} ${pf(m[5])})`;\n  }\n  return `matrix(${pf(m[0])} ${pf(m[1])} ${pf(m[2])} ${pf(m[3])} ${pf(m[4])} ` + `${pf(m[5])})`;\n}\nlet clipCount = 0;\nlet maskCount = 0;\nlet shadingCount = 0;\nclass SVGGraphics {\n  constructor(commonObjs, objs, forceDataSchema = false) {\n    (0, _display_utils.deprecated)(\"The SVG back-end is no longer maintained and *may* be removed in the future.\");\n    this.svgFactory = new _display_utils.DOMSVGFactory();\n    this.current = new SVGExtraState();\n    this.transformMatrix = _util.IDENTITY_MATRIX;\n    this.transformStack = [];\n    this.extraStack = [];\n    this.commonObjs = commonObjs;\n    this.objs = objs;\n    this.pendingClip = null;\n    this.pendingEOFill = false;\n    this.embedFonts = false;\n    this.embeddedFonts = Object.create(null);\n    this.cssStyle = null;\n    this.forceDataSchema = !!forceDataSchema;\n    this._operatorIdMapping = [];\n    for (const op in _util.OPS) {\n      this._operatorIdMapping[_util.OPS[op]] = op;\n    }\n  }\n  getObject(data, fallback = null) {\n    if (typeof data === \"string\") {\n      return data.startsWith(\"g_\") ? this.commonObjs.get(data) : this.objs.get(data);\n    }\n    return fallback;\n  }\n  save() {\n    this.transformStack.push(this.transformMatrix);\n    const old = this.current;\n    this.extraStack.push(old);\n    this.current = old.clone();\n  }\n  restore() {\n    this.transformMatrix = this.transformStack.pop();\n    this.current = this.extraStack.pop();\n    this.pendingClip = null;\n    this.tgrp = null;\n  }\n  group(items) {\n    this.save();\n    this.executeOpTree(items);\n    this.restore();\n  }\n  loadDependencies(operatorList) {\n    const fnArray = operatorList.fnArray;\n    const argsArray = operatorList.argsArray;\n    for (let i = 0, ii = fnArray.length; i < ii; i++) {\n      if (fnArray[i] !== _util.OPS.dependency) {\n        continue;\n      }\n      for (const obj of argsArray[i]) {\n        const objsPool = obj.startsWith(\"g_\") ? this.commonObjs : this.objs;\n        const promise = new Promise(resolve => {\n          objsPool.get(obj, resolve);\n        });\n        this.current.dependencies.push(promise);\n      }\n    }\n    return Promise.all(this.current.dependencies);\n  }\n  transform(a, b, c, d, e, f) {\n    const transformMatrix = [a, b, c, d, e, f];\n    this.transformMatrix = _util.Util.transform(this.transformMatrix, transformMatrix);\n    this.tgrp = null;\n  }\n  getSVG(operatorList, viewport) {\n    this.viewport = viewport;\n    const svgElement = this._initialize(viewport);\n    return this.loadDependencies(operatorList).then(() => {\n      this.transformMatrix = _util.IDENTITY_MATRIX;\n      this.executeOpTree(this.convertOpList(operatorList));\n      return svgElement;\n    });\n  }\n  convertOpList(operatorList) {\n    const operatorIdMapping = this._operatorIdMapping;\n    const argsArray = operatorList.argsArray;\n    const fnArray = operatorList.fnArray;\n    const opList = [];\n    for (let i = 0, ii = fnArray.length; i < ii; i++) {\n      const fnId = fnArray[i];\n      opList.push({\n        fnId,\n        fn: operatorIdMapping[fnId],\n        args: argsArray[i]\n      });\n    }\n    return opListToTree(opList);\n  }\n  executeOpTree(opTree) {\n    for (const opTreeElement of opTree) {\n      const fn = opTreeElement.fn;\n      const fnId = opTreeElement.fnId;\n      const args = opTreeElement.args;\n      switch (fnId | 0) {\n        case _util.OPS.beginText:\n          this.beginText();\n          break;\n        case _util.OPS.dependency:\n          break;\n        case _util.OPS.setLeading:\n          this.setLeading(args);\n          break;\n        case _util.OPS.setLeadingMoveText:\n          this.setLeadingMoveText(args[0], args[1]);\n          break;\n        case _util.OPS.setFont:\n          this.setFont(args);\n          break;\n        case _util.OPS.showText:\n          this.showText(args[0]);\n          break;\n        case _util.OPS.showSpacedText:\n          this.showText(args[0]);\n          break;\n        case _util.OPS.endText:\n          this.endText();\n          break;\n        case _util.OPS.moveText:\n          this.moveText(args[0], args[1]);\n          break;\n        case _util.OPS.setCharSpacing:\n          this.setCharSpacing(args[0]);\n          break;\n        case _util.OPS.setWordSpacing:\n          this.setWordSpacing(args[0]);\n          break;\n        case _util.OPS.setHScale:\n          this.setHScale(args[0]);\n          break;\n        case _util.OPS.setTextMatrix:\n          this.setTextMatrix(args[0], args[1], args[2], args[3], args[4], args[5]);\n          break;\n        case _util.OPS.setTextRise:\n          this.setTextRise(args[0]);\n          break;\n        case _util.OPS.setTextRenderingMode:\n          this.setTextRenderingMode(args[0]);\n          break;\n        case _util.OPS.setLineWidth:\n          this.setLineWidth(args[0]);\n          break;\n        case _util.OPS.setLineJoin:\n          this.setLineJoin(args[0]);\n          break;\n        case _util.OPS.setLineCap:\n          this.setLineCap(args[0]);\n          break;\n        case _util.OPS.setMiterLimit:\n          this.setMiterLimit(args[0]);\n          break;\n        case _util.OPS.setFillRGBColor:\n          this.setFillRGBColor(args[0], args[1], args[2]);\n          break;\n        case _util.OPS.setStrokeRGBColor:\n          this.setStrokeRGBColor(args[0], args[1], args[2]);\n          break;\n        case _util.OPS.setStrokeColorN:\n          this.setStrokeColorN(args);\n          break;\n        case _util.OPS.setFillColorN:\n          this.setFillColorN(args);\n          break;\n        case _util.OPS.shadingFill:\n          this.shadingFill(args[0]);\n          break;\n        case _util.OPS.setDash:\n          this.setDash(args[0], args[1]);\n          break;\n        case _util.OPS.setRenderingIntent:\n          this.setRenderingIntent(args[0]);\n          break;\n        case _util.OPS.setFlatness:\n          this.setFlatness(args[0]);\n          break;\n        case _util.OPS.setGState:\n          this.setGState(args[0]);\n          break;\n        case _util.OPS.fill:\n          this.fill();\n          break;\n        case _util.OPS.eoFill:\n          this.eoFill();\n          break;\n        case _util.OPS.stroke:\n          this.stroke();\n          break;\n        case _util.OPS.fillStroke:\n          this.fillStroke();\n          break;\n        case _util.OPS.eoFillStroke:\n          this.eoFillStroke();\n          break;\n        case _util.OPS.clip:\n          this.clip(\"nonzero\");\n          break;\n        case _util.OPS.eoClip:\n          this.clip(\"evenodd\");\n          break;\n        case _util.OPS.paintSolidColorImageMask:\n          this.paintSolidColorImageMask();\n          break;\n        case _util.OPS.paintImageXObject:\n          this.paintImageXObject(args[0]);\n          break;\n        case _util.OPS.paintInlineImageXObject:\n          this.paintInlineImageXObject(args[0]);\n          break;\n        case _util.OPS.paintImageMaskXObject:\n          this.paintImageMaskXObject(args[0]);\n          break;\n        case _util.OPS.paintFormXObjectBegin:\n          this.paintFormXObjectBegin(args[0], args[1]);\n          break;\n        case _util.OPS.paintFormXObjectEnd:\n          this.paintFormXObjectEnd();\n          break;\n        case _util.OPS.closePath:\n          this.closePath();\n          break;\n        case _util.OPS.closeStroke:\n          this.closeStroke();\n          break;\n        case _util.OPS.closeFillStroke:\n          this.closeFillStroke();\n          break;\n        case _util.OPS.closeEOFillStroke:\n          this.closeEOFillStroke();\n          break;\n        case _util.OPS.nextLine:\n          this.nextLine();\n          break;\n        case _util.OPS.transform:\n          this.transform(args[0], args[1], args[2], args[3], args[4], args[5]);\n          break;\n        case _util.OPS.constructPath:\n          this.constructPath(args[0], args[1]);\n          break;\n        case _util.OPS.endPath:\n          this.endPath();\n          break;\n        case 92:\n          this.group(opTreeElement.items);\n          break;\n        default:\n          (0, _util.warn)(`Unimplemented operator ${fn}`);\n          break;\n      }\n    }\n  }\n  setWordSpacing(wordSpacing) {\n    this.current.wordSpacing = wordSpacing;\n  }\n  setCharSpacing(charSpacing) {\n    this.current.charSpacing = charSpacing;\n  }\n  nextLine() {\n    this.moveText(0, this.current.leading);\n  }\n  setTextMatrix(a, b, c, d, e, f) {\n    const current = this.current;\n    current.textMatrix = current.lineMatrix = [a, b, c, d, e, f];\n    current.textMatrixScale = Math.hypot(a, b);\n    current.x = current.lineX = 0;\n    current.y = current.lineY = 0;\n    current.xcoords = [];\n    current.ycoords = [];\n    current.tspan = this.svgFactory.createElement(\"svg:tspan\");\n    current.tspan.setAttributeNS(null, \"font-family\", current.fontFamily);\n    current.tspan.setAttributeNS(null, \"font-size\", `${pf(current.fontSize)}px`);\n    current.tspan.setAttributeNS(null, \"y\", pf(-current.y));\n    current.txtElement = this.svgFactory.createElement(\"svg:text\");\n    current.txtElement.append(current.tspan);\n  }\n  beginText() {\n    const current = this.current;\n    current.x = current.lineX = 0;\n    current.y = current.lineY = 0;\n    current.textMatrix = _util.IDENTITY_MATRIX;\n    current.lineMatrix = _util.IDENTITY_MATRIX;\n    current.textMatrixScale = 1;\n    current.tspan = this.svgFactory.createElement(\"svg:tspan\");\n    current.txtElement = this.svgFactory.createElement(\"svg:text\");\n    current.txtgrp = this.svgFactory.createElement(\"svg:g\");\n    current.xcoords = [];\n    current.ycoords = [];\n  }\n  moveText(x, y) {\n    const current = this.current;\n    current.x = current.lineX += x;\n    current.y = current.lineY += y;\n    current.xcoords = [];\n    current.ycoords = [];\n    current.tspan = this.svgFactory.createElement(\"svg:tspan\");\n    current.tspan.setAttributeNS(null, \"font-family\", current.fontFamily);\n    current.tspan.setAttributeNS(null, \"font-size\", `${pf(current.fontSize)}px`);\n    current.tspan.setAttributeNS(null, \"y\", pf(-current.y));\n  }\n  showText(glyphs) {\n    const current = this.current;\n    const font = current.font;\n    const fontSize = current.fontSize;\n    if (fontSize === 0) {\n      return;\n    }\n    const fontSizeScale = current.fontSizeScale;\n    const charSpacing = current.charSpacing;\n    const wordSpacing = current.wordSpacing;\n    const fontDirection = current.fontDirection;\n    const textHScale = current.textHScale * fontDirection;\n    const vertical = font.vertical;\n    const spacingDir = vertical ? 1 : -1;\n    const defaultVMetrics = font.defaultVMetrics;\n    const widthAdvanceScale = fontSize * current.fontMatrix[0];\n    let x = 0;\n    for (const glyph of glyphs) {\n      if (glyph === null) {\n        x += fontDirection * wordSpacing;\n        continue;\n      } else if (typeof glyph === \"number\") {\n        x += spacingDir * glyph * fontSize / 1000;\n        continue;\n      }\n      const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;\n      const character = glyph.fontChar;\n      let scaledX, scaledY;\n      let width = glyph.width;\n      if (vertical) {\n        let vx;\n        const vmetric = glyph.vmetric || defaultVMetrics;\n        vx = glyph.vmetric ? vmetric[1] : width * 0.5;\n        vx = -vx * widthAdvanceScale;\n        const vy = vmetric[2] * widthAdvanceScale;\n        width = vmetric ? -vmetric[0] : width;\n        scaledX = vx / fontSizeScale;\n        scaledY = (x + vy) / fontSizeScale;\n      } else {\n        scaledX = x / fontSizeScale;\n        scaledY = 0;\n      }\n      if (glyph.isInFont || font.missingFile) {\n        current.xcoords.push(current.x + scaledX);\n        if (vertical) {\n          current.ycoords.push(-current.y + scaledY);\n        }\n        current.tspan.textContent += character;\n      } else {}\n      const charWidth = vertical ? width * widthAdvanceScale - spacing * fontDirection : width * widthAdvanceScale + spacing * fontDirection;\n      x += charWidth;\n    }\n    current.tspan.setAttributeNS(null, \"x\", current.xcoords.map(pf).join(\" \"));\n    if (vertical) {\n      current.tspan.setAttributeNS(null, \"y\", current.ycoords.map(pf).join(\" \"));\n    } else {\n      current.tspan.setAttributeNS(null, \"y\", pf(-current.y));\n    }\n    if (vertical) {\n      current.y -= x;\n    } else {\n      current.x += x * textHScale;\n    }\n    current.tspan.setAttributeNS(null, \"font-family\", current.fontFamily);\n    current.tspan.setAttributeNS(null, \"font-size\", `${pf(current.fontSize)}px`);\n    if (current.fontStyle !== SVG_DEFAULTS.fontStyle) {\n      current.tspan.setAttributeNS(null, \"font-style\", current.fontStyle);\n    }\n    if (current.fontWeight !== SVG_DEFAULTS.fontWeight) {\n      current.tspan.setAttributeNS(null, \"font-weight\", current.fontWeight);\n    }\n    const fillStrokeMode = current.textRenderingMode & _util.TextRenderingMode.FILL_STROKE_MASK;\n    if (fillStrokeMode === _util.TextRenderingMode.FILL || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {\n      if (current.fillColor !== SVG_DEFAULTS.fillColor) {\n        current.tspan.setAttributeNS(null, \"fill\", current.fillColor);\n      }\n      if (current.fillAlpha < 1) {\n        current.tspan.setAttributeNS(null, \"fill-opacity\", current.fillAlpha);\n      }\n    } else if (current.textRenderingMode === _util.TextRenderingMode.ADD_TO_PATH) {\n      current.tspan.setAttributeNS(null, \"fill\", \"transparent\");\n    } else {\n      current.tspan.setAttributeNS(null, \"fill\", \"none\");\n    }\n    if (fillStrokeMode === _util.TextRenderingMode.STROKE || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {\n      const lineWidthScale = 1 / (current.textMatrixScale || 1);\n      this._setStrokeAttributes(current.tspan, lineWidthScale);\n    }\n    let textMatrix = current.textMatrix;\n    if (current.textRise !== 0) {\n      textMatrix = textMatrix.slice();\n      textMatrix[5] += current.textRise;\n    }\n    current.txtElement.setAttributeNS(null, \"transform\", `${pm(textMatrix)} scale(${pf(textHScale)}, -1)`);\n    current.txtElement.setAttributeNS(XML_NS, \"xml:space\", \"preserve\");\n    current.txtElement.append(current.tspan);\n    current.txtgrp.append(current.txtElement);\n    this._ensureTransformGroup().append(current.txtElement);\n  }\n  setLeadingMoveText(x, y) {\n    this.setLeading(-y);\n    this.moveText(x, y);\n  }\n  addFontStyle(fontObj) {\n    if (!fontObj.data) {\n      throw new Error(\"addFontStyle: No font data available, \" + 'ensure that the \"fontExtraProperties\" API parameter is set.');\n    }\n    if (!this.cssStyle) {\n      this.cssStyle = this.svgFactory.createElement(\"svg:style\");\n      this.cssStyle.setAttributeNS(null, \"type\", \"text/css\");\n      this.defs.append(this.cssStyle);\n    }\n    const url = createObjectURL(fontObj.data, fontObj.mimetype, this.forceDataSchema);\n    this.cssStyle.textContent += `@font-face { font-family: \"${fontObj.loadedName}\";` + ` src: url(${url}); }\\n`;\n  }\n  setFont(details) {\n    const current = this.current;\n    const fontObj = this.commonObjs.get(details[0]);\n    let size = details[1];\n    current.font = fontObj;\n    if (this.embedFonts && !fontObj.missingFile && !this.embeddedFonts[fontObj.loadedName]) {\n      this.addFontStyle(fontObj);\n      this.embeddedFonts[fontObj.loadedName] = fontObj;\n    }\n    current.fontMatrix = fontObj.fontMatrix || _util.FONT_IDENTITY_MATRIX;\n    let bold = \"normal\";\n    if (fontObj.black) {\n      bold = \"900\";\n    } else if (fontObj.bold) {\n      bold = \"bold\";\n    }\n    const italic = fontObj.italic ? \"italic\" : \"normal\";\n    if (size < 0) {\n      size = -size;\n      current.fontDirection = -1;\n    } else {\n      current.fontDirection = 1;\n    }\n    current.fontSize = size;\n    current.fontFamily = fontObj.loadedName;\n    current.fontWeight = bold;\n    current.fontStyle = italic;\n    current.tspan = this.svgFactory.createElement(\"svg:tspan\");\n    current.tspan.setAttributeNS(null, \"y\", pf(-current.y));\n    current.xcoords = [];\n    current.ycoords = [];\n  }\n  endText() {\n    const current = this.current;\n    if (current.textRenderingMode & _util.TextRenderingMode.ADD_TO_PATH_FLAG && current.txtElement?.hasChildNodes()) {\n      current.element = current.txtElement;\n      this.clip(\"nonzero\");\n      this.endPath();\n    }\n  }\n  setLineWidth(width) {\n    if (width > 0) {\n      this.current.lineWidth = width;\n    }\n  }\n  setLineCap(style) {\n    this.current.lineCap = LINE_CAP_STYLES[style];\n  }\n  setLineJoin(style) {\n    this.current.lineJoin = LINE_JOIN_STYLES[style];\n  }\n  setMiterLimit(limit) {\n    this.current.miterLimit = limit;\n  }\n  setStrokeAlpha(strokeAlpha) {\n    this.current.strokeAlpha = strokeAlpha;\n  }\n  setStrokeRGBColor(r, g, b) {\n    this.current.strokeColor = _util.Util.makeHexColor(r, g, b);\n  }\n  setFillAlpha(fillAlpha) {\n    this.current.fillAlpha = fillAlpha;\n  }\n  setFillRGBColor(r, g, b) {\n    this.current.fillColor = _util.Util.makeHexColor(r, g, b);\n    this.current.tspan = this.svgFactory.createElement(\"svg:tspan\");\n    this.current.xcoords = [];\n    this.current.ycoords = [];\n  }\n  setStrokeColorN(args) {\n    this.current.strokeColor = this._makeColorN_Pattern(args);\n  }\n  setFillColorN(args) {\n    this.current.fillColor = this._makeColorN_Pattern(args);\n  }\n  shadingFill(args) {\n    const {\n      width,\n      height\n    } = this.viewport;\n    const inv = _util.Util.inverseTransform(this.transformMatrix);\n    const [x0, y0, x1, y1] = _util.Util.getAxialAlignedBoundingBox([0, 0, width, height], inv);\n    const rect = this.svgFactory.createElement(\"svg:rect\");\n    rect.setAttributeNS(null, \"x\", x0);\n    rect.setAttributeNS(null, \"y\", y0);\n    rect.setAttributeNS(null, \"width\", x1 - x0);\n    rect.setAttributeNS(null, \"height\", y1 - y0);\n    rect.setAttributeNS(null, \"fill\", this._makeShadingPattern(args));\n    if (this.current.fillAlpha < 1) {\n      rect.setAttributeNS(null, \"fill-opacity\", this.current.fillAlpha);\n    }\n    this._ensureTransformGroup().append(rect);\n  }\n  _makeColorN_Pattern(args) {\n    if (args[0] === \"TilingPattern\") {\n      return this._makeTilingPattern(args);\n    }\n    return this._makeShadingPattern(args);\n  }\n  _makeTilingPattern(args) {\n    const color = args[1];\n    const operatorList = args[2];\n    const matrix = args[3] || _util.IDENTITY_MATRIX;\n    const [x0, y0, x1, y1] = args[4];\n    const xstep = args[5];\n    const ystep = args[6];\n    const paintType = args[7];\n    const tilingId = `shading${shadingCount++}`;\n    const [tx0, ty0, tx1, ty1] = _util.Util.normalizeRect([..._util.Util.applyTransform([x0, y0], matrix), ..._util.Util.applyTransform([x1, y1], matrix)]);\n    const [xscale, yscale] = _util.Util.singularValueDecompose2dScale(matrix);\n    const txstep = xstep * xscale;\n    const tystep = ystep * yscale;\n    const tiling = this.svgFactory.createElement(\"svg:pattern\");\n    tiling.setAttributeNS(null, \"id\", tilingId);\n    tiling.setAttributeNS(null, \"patternUnits\", \"userSpaceOnUse\");\n    tiling.setAttributeNS(null, \"width\", txstep);\n    tiling.setAttributeNS(null, \"height\", tystep);\n    tiling.setAttributeNS(null, \"x\", `${tx0}`);\n    tiling.setAttributeNS(null, \"y\", `${ty0}`);\n    const svg = this.svg;\n    const transformMatrix = this.transformMatrix;\n    const fillColor = this.current.fillColor;\n    const strokeColor = this.current.strokeColor;\n    const bbox = this.svgFactory.create(tx1 - tx0, ty1 - ty0);\n    this.svg = bbox;\n    this.transformMatrix = matrix;\n    if (paintType === 2) {\n      const cssColor = _util.Util.makeHexColor(...color);\n      this.current.fillColor = cssColor;\n      this.current.strokeColor = cssColor;\n    }\n    this.executeOpTree(this.convertOpList(operatorList));\n    this.svg = svg;\n    this.transformMatrix = transformMatrix;\n    this.current.fillColor = fillColor;\n    this.current.strokeColor = strokeColor;\n    tiling.append(bbox.childNodes[0]);\n    this.defs.append(tiling);\n    return `url(#${tilingId})`;\n  }\n  _makeShadingPattern(args) {\n    if (typeof args === \"string\") {\n      args = this.objs.get(args);\n    }\n    switch (args[0]) {\n      case \"RadialAxial\":\n        const shadingId = `shading${shadingCount++}`;\n        const colorStops = args[3];\n        let gradient;\n        switch (args[1]) {\n          case \"axial\":\n            const point0 = args[4];\n            const point1 = args[5];\n            gradient = this.svgFactory.createElement(\"svg:linearGradient\");\n            gradient.setAttributeNS(null, \"id\", shadingId);\n            gradient.setAttributeNS(null, \"gradientUnits\", \"userSpaceOnUse\");\n            gradient.setAttributeNS(null, \"x1\", point0[0]);\n            gradient.setAttributeNS(null, \"y1\", point0[1]);\n            gradient.setAttributeNS(null, \"x2\", point1[0]);\n            gradient.setAttributeNS(null, \"y2\", point1[1]);\n            break;\n          case \"radial\":\n            const focalPoint = args[4];\n            const circlePoint = args[5];\n            const focalRadius = args[6];\n            const circleRadius = args[7];\n            gradient = this.svgFactory.createElement(\"svg:radialGradient\");\n            gradient.setAttributeNS(null, \"id\", shadingId);\n            gradient.setAttributeNS(null, \"gradientUnits\", \"userSpaceOnUse\");\n            gradient.setAttributeNS(null, \"cx\", circlePoint[0]);\n            gradient.setAttributeNS(null, \"cy\", circlePoint[1]);\n            gradient.setAttributeNS(null, \"r\", circleRadius);\n            gradient.setAttributeNS(null, \"fx\", focalPoint[0]);\n            gradient.setAttributeNS(null, \"fy\", focalPoint[1]);\n            gradient.setAttributeNS(null, \"fr\", focalRadius);\n            break;\n          default:\n            throw new Error(`Unknown RadialAxial type: ${args[1]}`);\n        }\n        for (const colorStop of colorStops) {\n          const stop = this.svgFactory.createElement(\"svg:stop\");\n          stop.setAttributeNS(null, \"offset\", colorStop[0]);\n          stop.setAttributeNS(null, \"stop-color\", colorStop[1]);\n          gradient.append(stop);\n        }\n        this.defs.append(gradient);\n        return `url(#${shadingId})`;\n      case \"Mesh\":\n        (0, _util.warn)(\"Unimplemented pattern Mesh\");\n        return null;\n      case \"Dummy\":\n        return \"hotpink\";\n      default:\n        throw new Error(`Unknown IR type: ${args[0]}`);\n    }\n  }\n  setDash(dashArray, dashPhase) {\n    this.current.dashArray = dashArray;\n    this.current.dashPhase = dashPhase;\n  }\n  constructPath(ops, args) {\n    const current = this.current;\n    let x = current.x,\n      y = current.y;\n    let d = [];\n    let j = 0;\n    for (const op of ops) {\n      switch (op | 0) {\n        case _util.OPS.rectangle:\n          x = args[j++];\n          y = args[j++];\n          const width = args[j++];\n          const height = args[j++];\n          const xw = x + width;\n          const yh = y + height;\n          d.push(\"M\", pf(x), pf(y), \"L\", pf(xw), pf(y), \"L\", pf(xw), pf(yh), \"L\", pf(x), pf(yh), \"Z\");\n          break;\n        case _util.OPS.moveTo:\n          x = args[j++];\n          y = args[j++];\n          d.push(\"M\", pf(x), pf(y));\n          break;\n        case _util.OPS.lineTo:\n          x = args[j++];\n          y = args[j++];\n          d.push(\"L\", pf(x), pf(y));\n          break;\n        case _util.OPS.curveTo:\n          x = args[j + 4];\n          y = args[j + 5];\n          d.push(\"C\", pf(args[j]), pf(args[j + 1]), pf(args[j + 2]), pf(args[j + 3]), pf(x), pf(y));\n          j += 6;\n          break;\n        case _util.OPS.curveTo2:\n          d.push(\"C\", pf(x), pf(y), pf(args[j]), pf(args[j + 1]), pf(args[j + 2]), pf(args[j + 3]));\n          x = args[j + 2];\n          y = args[j + 3];\n          j += 4;\n          break;\n        case _util.OPS.curveTo3:\n          x = args[j + 2];\n          y = args[j + 3];\n          d.push(\"C\", pf(args[j]), pf(args[j + 1]), pf(x), pf(y), pf(x), pf(y));\n          j += 4;\n          break;\n        case _util.OPS.closePath:\n          d.push(\"Z\");\n          break;\n      }\n    }\n    d = d.join(\" \");\n    if (current.path && ops.length > 0 && ops[0] !== _util.OPS.rectangle && ops[0] !== _util.OPS.moveTo) {\n      d = current.path.getAttributeNS(null, \"d\") + d;\n    } else {\n      current.path = this.svgFactory.createElement(\"svg:path\");\n      this._ensureTransformGroup().append(current.path);\n    }\n    current.path.setAttributeNS(null, \"d\", d);\n    current.path.setAttributeNS(null, \"fill\", \"none\");\n    current.element = current.path;\n    current.setCurrentPoint(x, y);\n  }\n  endPath() {\n    const current = this.current;\n    current.path = null;\n    if (!this.pendingClip) {\n      return;\n    }\n    if (!current.element) {\n      this.pendingClip = null;\n      return;\n    }\n    const clipId = `clippath${clipCount++}`;\n    const clipPath = this.svgFactory.createElement(\"svg:clipPath\");\n    clipPath.setAttributeNS(null, \"id\", clipId);\n    clipPath.setAttributeNS(null, \"transform\", pm(this.transformMatrix));\n    const clipElement = current.element.cloneNode(true);\n    if (this.pendingClip === \"evenodd\") {\n      clipElement.setAttributeNS(null, \"clip-rule\", \"evenodd\");\n    } else {\n      clipElement.setAttributeNS(null, \"clip-rule\", \"nonzero\");\n    }\n    this.pendingClip = null;\n    clipPath.append(clipElement);\n    this.defs.append(clipPath);\n    if (current.activeClipUrl) {\n      current.clipGroup = null;\n      for (const prev of this.extraStack) {\n        prev.clipGroup = null;\n      }\n      clipPath.setAttributeNS(null, \"clip-path\", current.activeClipUrl);\n    }\n    current.activeClipUrl = `url(#${clipId})`;\n    this.tgrp = null;\n  }\n  clip(type) {\n    this.pendingClip = type;\n  }\n  closePath() {\n    const current = this.current;\n    if (current.path) {\n      const d = `${current.path.getAttributeNS(null, \"d\")}Z`;\n      current.path.setAttributeNS(null, \"d\", d);\n    }\n  }\n  setLeading(leading) {\n    this.current.leading = -leading;\n  }\n  setTextRise(textRise) {\n    this.current.textRise = textRise;\n  }\n  setTextRenderingMode(textRenderingMode) {\n    this.current.textRenderingMode = textRenderingMode;\n  }\n  setHScale(scale) {\n    this.current.textHScale = scale / 100;\n  }\n  setRenderingIntent(intent) {}\n  setFlatness(flatness) {}\n  setGState(states) {\n    for (const [key, value] of states) {\n      switch (key) {\n        case \"LW\":\n          this.setLineWidth(value);\n          break;\n        case \"LC\":\n          this.setLineCap(value);\n          break;\n        case \"LJ\":\n          this.setLineJoin(value);\n          break;\n        case \"ML\":\n          this.setMiterLimit(value);\n          break;\n        case \"D\":\n          this.setDash(value[0], value[1]);\n          break;\n        case \"RI\":\n          this.setRenderingIntent(value);\n          break;\n        case \"FL\":\n          this.setFlatness(value);\n          break;\n        case \"Font\":\n          this.setFont(value);\n          break;\n        case \"CA\":\n          this.setStrokeAlpha(value);\n          break;\n        case \"ca\":\n          this.setFillAlpha(value);\n          break;\n        default:\n          (0, _util.warn)(`Unimplemented graphic state operator ${key}`);\n          break;\n      }\n    }\n  }\n  fill() {\n    const current = this.current;\n    if (current.element) {\n      current.element.setAttributeNS(null, \"fill\", current.fillColor);\n      current.element.setAttributeNS(null, \"fill-opacity\", current.fillAlpha);\n      this.endPath();\n    }\n  }\n  stroke() {\n    const current = this.current;\n    if (current.element) {\n      this._setStrokeAttributes(current.element);\n      current.element.setAttributeNS(null, \"fill\", \"none\");\n      this.endPath();\n    }\n  }\n  _setStrokeAttributes(element, lineWidthScale = 1) {\n    const current = this.current;\n    let dashArray = current.dashArray;\n    if (lineWidthScale !== 1 && dashArray.length > 0) {\n      dashArray = dashArray.map(function (value) {\n        return lineWidthScale * value;\n      });\n    }\n    element.setAttributeNS(null, \"stroke\", current.strokeColor);\n    element.setAttributeNS(null, \"stroke-opacity\", current.strokeAlpha);\n    element.setAttributeNS(null, \"stroke-miterlimit\", pf(current.miterLimit));\n    element.setAttributeNS(null, \"stroke-linecap\", current.lineCap);\n    element.setAttributeNS(null, \"stroke-linejoin\", current.lineJoin);\n    element.setAttributeNS(null, \"stroke-width\", pf(lineWidthScale * current.lineWidth) + \"px\");\n    element.setAttributeNS(null, \"stroke-dasharray\", dashArray.map(pf).join(\" \"));\n    element.setAttributeNS(null, \"stroke-dashoffset\", pf(lineWidthScale * current.dashPhase) + \"px\");\n  }\n  eoFill() {\n    this.current.element?.setAttributeNS(null, \"fill-rule\", \"evenodd\");\n    this.fill();\n  }\n  fillStroke() {\n    this.stroke();\n    this.fill();\n  }\n  eoFillStroke() {\n    this.current.element?.setAttributeNS(null, \"fill-rule\", \"evenodd\");\n    this.fillStroke();\n  }\n  closeStroke() {\n    this.closePath();\n    this.stroke();\n  }\n  closeFillStroke() {\n    this.closePath();\n    this.fillStroke();\n  }\n  closeEOFillStroke() {\n    this.closePath();\n    this.eoFillStroke();\n  }\n  paintSolidColorImageMask() {\n    const rect = this.svgFactory.createElement(\"svg:rect\");\n    rect.setAttributeNS(null, \"x\", \"0\");\n    rect.setAttributeNS(null, \"y\", \"0\");\n    rect.setAttributeNS(null, \"width\", \"1px\");\n    rect.setAttributeNS(null, \"height\", \"1px\");\n    rect.setAttributeNS(null, \"fill\", this.current.fillColor);\n    this._ensureTransformGroup().append(rect);\n  }\n  paintImageXObject(objId) {\n    const imgData = this.getObject(objId);\n    if (!imgData) {\n      (0, _util.warn)(`Dependent image with object ID ${objId} is not ready yet`);\n      return;\n    }\n    this.paintInlineImageXObject(imgData);\n  }\n  paintInlineImageXObject(imgData, mask) {\n    const width = imgData.width;\n    const height = imgData.height;\n    const imgSrc = convertImgDataToPng(imgData, this.forceDataSchema, !!mask);\n    const cliprect = this.svgFactory.createElement(\"svg:rect\");\n    cliprect.setAttributeNS(null, \"x\", \"0\");\n    cliprect.setAttributeNS(null, \"y\", \"0\");\n    cliprect.setAttributeNS(null, \"width\", pf(width));\n    cliprect.setAttributeNS(null, \"height\", pf(height));\n    this.current.element = cliprect;\n    this.clip(\"nonzero\");\n    const imgEl = this.svgFactory.createElement(\"svg:image\");\n    imgEl.setAttributeNS(XLINK_NS, \"xlink:href\", imgSrc);\n    imgEl.setAttributeNS(null, \"x\", \"0\");\n    imgEl.setAttributeNS(null, \"y\", pf(-height));\n    imgEl.setAttributeNS(null, \"width\", pf(width) + \"px\");\n    imgEl.setAttributeNS(null, \"height\", pf(height) + \"px\");\n    imgEl.setAttributeNS(null, \"transform\", `scale(${pf(1 / width)} ${pf(-1 / height)})`);\n    if (mask) {\n      mask.append(imgEl);\n    } else {\n      this._ensureTransformGroup().append(imgEl);\n    }\n  }\n  paintImageMaskXObject(img) {\n    const imgData = this.getObject(img.data, img);\n    if (imgData.bitmap) {\n      (0, _util.warn)(\"paintImageMaskXObject: ImageBitmap support is not implemented, \" + \"ensure that the `isOffscreenCanvasSupported` API parameter is disabled.\");\n      return;\n    }\n    const current = this.current;\n    const width = imgData.width;\n    const height = imgData.height;\n    const fillColor = current.fillColor;\n    current.maskId = `mask${maskCount++}`;\n    const mask = this.svgFactory.createElement(\"svg:mask\");\n    mask.setAttributeNS(null, \"id\", current.maskId);\n    const rect = this.svgFactory.createElement(\"svg:rect\");\n    rect.setAttributeNS(null, \"x\", \"0\");\n    rect.setAttributeNS(null, \"y\", \"0\");\n    rect.setAttributeNS(null, \"width\", pf(width));\n    rect.setAttributeNS(null, \"height\", pf(height));\n    rect.setAttributeNS(null, \"fill\", fillColor);\n    rect.setAttributeNS(null, \"mask\", `url(#${current.maskId})`);\n    this.defs.append(mask);\n    this._ensureTransformGroup().append(rect);\n    this.paintInlineImageXObject(imgData, mask);\n  }\n  paintFormXObjectBegin(matrix, bbox) {\n    if (Array.isArray(matrix) && matrix.length === 6) {\n      this.transform(matrix[0], matrix[1], matrix[2], matrix[3], matrix[4], matrix[5]);\n    }\n    if (bbox) {\n      const width = bbox[2] - bbox[0];\n      const height = bbox[3] - bbox[1];\n      const cliprect = this.svgFactory.createElement(\"svg:rect\");\n      cliprect.setAttributeNS(null, \"x\", bbox[0]);\n      cliprect.setAttributeNS(null, \"y\", bbox[1]);\n      cliprect.setAttributeNS(null, \"width\", pf(width));\n      cliprect.setAttributeNS(null, \"height\", pf(height));\n      this.current.element = cliprect;\n      this.clip(\"nonzero\");\n      this.endPath();\n    }\n  }\n  paintFormXObjectEnd() {}\n  _initialize(viewport) {\n    const svg = this.svgFactory.create(viewport.width, viewport.height);\n    const definitions = this.svgFactory.createElement(\"svg:defs\");\n    svg.append(definitions);\n    this.defs = definitions;\n    const rootGroup = this.svgFactory.createElement(\"svg:g\");\n    rootGroup.setAttributeNS(null, \"transform\", pm(viewport.transform));\n    svg.append(rootGroup);\n    this.svg = rootGroup;\n    return svg;\n  }\n  _ensureClipGroup() {\n    if (!this.current.clipGroup) {\n      const clipGroup = this.svgFactory.createElement(\"svg:g\");\n      clipGroup.setAttributeNS(null, \"clip-path\", this.current.activeClipUrl);\n      this.svg.append(clipGroup);\n      this.current.clipGroup = clipGroup;\n    }\n    return this.current.clipGroup;\n  }\n  _ensureTransformGroup() {\n    if (!this.tgrp) {\n      this.tgrp = this.svgFactory.createElement(\"svg:g\");\n      this.tgrp.setAttributeNS(null, \"transform\", pm(this.transformMatrix));\n      if (this.current.activeClipUrl) {\n        this._ensureClipGroup().append(this.tgrp);\n      } else {\n        this.svg.append(this.tgrp);\n      }\n    }\n    return this.tgrp;\n  }\n}\nexports.SVGGraphics = SVGGraphics;\n\n/***/ }),\n/* 25 */\n/***/ ((__unused_webpack_module, exports) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.XfaText = void 0;\nclass XfaText {\n  static textContent(xfa) {\n    const items = [];\n    const output = {\n      items,\n      styles: Object.create(null)\n    };\n    function walk(node) {\n      if (!node) {\n        return;\n      }\n      let str = null;\n      const name = node.name;\n      if (name === \"#text\") {\n        str = node.value;\n      } else if (!XfaText.shouldBuildText(name)) {\n        return;\n      } else if (node?.attributes?.textContent) {\n        str = node.attributes.textContent;\n      } else if (node.value) {\n        str = node.value;\n      }\n      if (str !== null) {\n        items.push({\n          str\n        });\n      }\n      if (!node.children) {\n        return;\n      }\n      for (const child of node.children) {\n        walk(child);\n      }\n    }\n    walk(xfa);\n    return output;\n  }\n  static shouldBuildText(name) {\n    return !(name === \"textarea\" || name === \"input\" || name === \"option\" || name === \"select\");\n  }\n}\nexports.XfaText = XfaText;\n\n/***/ }),\n/* 26 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.TextLayerRenderTask = void 0;\nexports.renderTextLayer = renderTextLayer;\nexports.updateTextLayer = updateTextLayer;\nvar _util = __w_pdfjs_require__(1);\nvar _display_utils = __w_pdfjs_require__(6);\nconst MAX_TEXT_DIVS_TO_RENDER = 100000;\nconst DEFAULT_FONT_SIZE = 30;\nconst DEFAULT_FONT_ASCENT = 0.8;\nconst ascentCache = new Map();\nfunction getCtx(size, isOffscreenCanvasSupported) {\n  let ctx;\n  if (isOffscreenCanvasSupported && _util.FeatureTest.isOffscreenCanvasSupported) {\n    ctx = new OffscreenCanvas(size, size).getContext(\"2d\", {\n      alpha: false\n    });\n  } else {\n    const canvas = document.createElement(\"canvas\");\n    canvas.width = canvas.height = size;\n    ctx = canvas.getContext(\"2d\", {\n      alpha: false\n    });\n  }\n  return ctx;\n}\nfunction getAscent(fontFamily, isOffscreenCanvasSupported) {\n  const cachedAscent = ascentCache.get(fontFamily);\n  if (cachedAscent) {\n    return cachedAscent;\n  }\n  const ctx = getCtx(DEFAULT_FONT_SIZE, isOffscreenCanvasSupported);\n  ctx.font = `${DEFAULT_FONT_SIZE}px ${fontFamily}`;\n  const metrics = ctx.measureText(\"\");\n  let ascent = metrics.fontBoundingBoxAscent;\n  let descent = Math.abs(metrics.fontBoundingBoxDescent);\n  if (ascent) {\n    const ratio = ascent / (ascent + descent);\n    ascentCache.set(fontFamily, ratio);\n    ctx.canvas.width = ctx.canvas.height = 0;\n    return ratio;\n  }\n  ctx.strokeStyle = \"red\";\n  ctx.clearRect(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE);\n  ctx.strokeText(\"g\", 0, 0);\n  let pixels = ctx.getImageData(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE).data;\n  descent = 0;\n  for (let i = pixels.length - 1 - 3; i >= 0; i -= 4) {\n    if (pixels[i] > 0) {\n      descent = Math.ceil(i / 4 / DEFAULT_FONT_SIZE);\n      break;\n    }\n  }\n  ctx.clearRect(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE);\n  ctx.strokeText(\"A\", 0, DEFAULT_FONT_SIZE);\n  pixels = ctx.getImageData(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE).data;\n  ascent = 0;\n  for (let i = 0, ii = pixels.length; i < ii; i += 4) {\n    if (pixels[i] > 0) {\n      ascent = DEFAULT_FONT_SIZE - Math.floor(i / 4 / DEFAULT_FONT_SIZE);\n      break;\n    }\n  }\n  ctx.canvas.width = ctx.canvas.height = 0;\n  if (ascent) {\n    const ratio = ascent / (ascent + descent);\n    ascentCache.set(fontFamily, ratio);\n    return ratio;\n  }\n  ascentCache.set(fontFamily, DEFAULT_FONT_ASCENT);\n  return DEFAULT_FONT_ASCENT;\n}\nfunction appendText(task, geom, styles) {\n  const textDiv = document.createElement(\"span\");\n  const textDivProperties = {\n    angle: 0,\n    canvasWidth: 0,\n    hasText: geom.str !== \"\",\n    hasEOL: geom.hasEOL,\n    fontSize: 0\n  };\n  task._textDivs.push(textDiv);\n  const tx = _util.Util.transform(task._transform, geom.transform);\n  let angle = Math.atan2(tx[1], tx[0]);\n  const style = styles[geom.fontName];\n  if (style.vertical) {\n    angle += Math.PI / 2;\n  }\n  const fontHeight = Math.hypot(tx[2], tx[3]);\n  const fontAscent = fontHeight * getAscent(style.fontFamily, task._isOffscreenCanvasSupported);\n  let left, top;\n  if (angle === 0) {\n    left = tx[4];\n    top = tx[5] - fontAscent;\n  } else {\n    left = tx[4] + fontAscent * Math.sin(angle);\n    top = tx[5] - fontAscent * Math.cos(angle);\n  }\n  const scaleFactorStr = \"calc(var(--scale-factor)*\";\n  const divStyle = textDiv.style;\n  if (task._container === task._rootContainer) {\n    divStyle.left = `${(100 * left / task._pageWidth).toFixed(2)}%`;\n    divStyle.top = `${(100 * top / task._pageHeight).toFixed(2)}%`;\n  } else {\n    divStyle.left = `${scaleFactorStr}${left.toFixed(2)}px)`;\n    divStyle.top = `${scaleFactorStr}${top.toFixed(2)}px)`;\n  }\n  divStyle.fontSize = `${scaleFactorStr}${fontHeight.toFixed(2)}px)`;\n  divStyle.fontFamily = style.fontFamily;\n  textDivProperties.fontSize = fontHeight;\n  textDiv.setAttribute(\"role\", \"presentation\");\n  textDiv.textContent = geom.str;\n  textDiv.dir = geom.dir;\n  if (task._fontInspectorEnabled) {\n    textDiv.dataset.fontName = geom.fontName;\n  }\n  if (angle !== 0) {\n    textDivProperties.angle = angle * (180 / Math.PI);\n  }\n  let shouldScaleText = false;\n  if (geom.str.length > 1) {\n    shouldScaleText = true;\n  } else if (geom.str !== \" \" && geom.transform[0] !== geom.transform[3]) {\n    const absScaleX = Math.abs(geom.transform[0]),\n      absScaleY = Math.abs(geom.transform[3]);\n    if (absScaleX !== absScaleY && Math.max(absScaleX, absScaleY) / Math.min(absScaleX, absScaleY) > 1.5) {\n      shouldScaleText = true;\n    }\n  }\n  if (shouldScaleText) {\n    textDivProperties.canvasWidth = style.vertical ? geom.height : geom.width;\n  }\n  task._textDivProperties.set(textDiv, textDivProperties);\n  if (task._isReadableStream) {\n    task._layoutText(textDiv);\n  }\n}\nfunction layout(params) {\n  const {\n    div,\n    scale,\n    properties,\n    ctx,\n    prevFontSize,\n    prevFontFamily\n  } = params;\n  const {\n    style\n  } = div;\n  let transform = \"\";\n  if (properties.canvasWidth !== 0 && properties.hasText) {\n    const {\n      fontFamily\n    } = style;\n    const {\n      canvasWidth,\n      fontSize\n    } = properties;\n    if (prevFontSize !== fontSize || prevFontFamily !== fontFamily) {\n      ctx.font = `${fontSize * scale}px ${fontFamily}`;\n      params.prevFontSize = fontSize;\n      params.prevFontFamily = fontFamily;\n    }\n    const {\n      width\n    } = ctx.measureText(div.textContent);\n    if (width > 0) {\n      transform = `scaleX(${canvasWidth * scale / width})`;\n    }\n  }\n  if (properties.angle !== 0) {\n    transform = `rotate(${properties.angle}deg) ${transform}`;\n  }\n  if (transform.length > 0) {\n    style.transform = transform;\n  }\n}\nfunction render(task) {\n  if (task._canceled) {\n    return;\n  }\n  const textDivs = task._textDivs;\n  const capability = task._capability;\n  const textDivsLength = textDivs.length;\n  if (textDivsLength > MAX_TEXT_DIVS_TO_RENDER) {\n    capability.resolve();\n    return;\n  }\n  if (!task._isReadableStream) {\n    for (const textDiv of textDivs) {\n      task._layoutText(textDiv);\n    }\n  }\n  capability.resolve();\n}\nclass TextLayerRenderTask {\n  constructor({\n    textContentSource,\n    container,\n    viewport,\n    textDivs,\n    textDivProperties,\n    textContentItemsStr,\n    isOffscreenCanvasSupported\n  }) {\n    this._textContentSource = textContentSource;\n    this._isReadableStream = textContentSource instanceof ReadableStream;\n    this._container = this._rootContainer = container;\n    this._textDivs = textDivs || [];\n    this._textContentItemsStr = textContentItemsStr || [];\n    this._isOffscreenCanvasSupported = isOffscreenCanvasSupported;\n    this._fontInspectorEnabled = !!globalThis.FontInspector?.enabled;\n    this._reader = null;\n    this._textDivProperties = textDivProperties || new WeakMap();\n    this._canceled = false;\n    this._capability = new _util.PromiseCapability();\n    this._layoutTextParams = {\n      prevFontSize: null,\n      prevFontFamily: null,\n      div: null,\n      scale: viewport.scale * (globalThis.devicePixelRatio || 1),\n      properties: null,\n      ctx: getCtx(0, isOffscreenCanvasSupported)\n    };\n    const {\n      pageWidth,\n      pageHeight,\n      pageX,\n      pageY\n    } = viewport.rawDims;\n    this._transform = [1, 0, 0, -1, -pageX, pageY + pageHeight];\n    this._pageWidth = pageWidth;\n    this._pageHeight = pageHeight;\n    (0, _display_utils.setLayerDimensions)(container, viewport);\n    this._capability.promise.finally(() => {\n      this._layoutTextParams = null;\n    }).catch(() => {});\n  }\n  get promise() {\n    return this._capability.promise;\n  }\n  cancel() {\n    this._canceled = true;\n    if (this._reader) {\n      this._reader.cancel(new _util.AbortException(\"TextLayer task cancelled.\")).catch(() => {});\n      this._reader = null;\n    }\n    this._capability.reject(new _util.AbortException(\"TextLayer task cancelled.\"));\n  }\n  _processItems(items, styleCache) {\n    for (const item of items) {\n      if (item.str === undefined) {\n        if (item.type === \"beginMarkedContentProps\" || item.type === \"beginMarkedContent\") {\n          const parent = this._container;\n          this._container = document.createElement(\"span\");\n          this._container.classList.add(\"markedContent\");\n          if (item.id !== null) {\n            this._container.setAttribute(\"id\", `${item.id}`);\n          }\n          parent.append(this._container);\n        } else if (item.type === \"endMarkedContent\") {\n          this._container = this._container.parentNode;\n        }\n        continue;\n      }\n      this._textContentItemsStr.push(item.str);\n      appendText(this, item, styleCache);\n    }\n  }\n  _layoutText(textDiv) {\n    const textDivProperties = this._layoutTextParams.properties = this._textDivProperties.get(textDiv);\n    this._layoutTextParams.div = textDiv;\n    layout(this._layoutTextParams);\n    if (textDivProperties.hasText) {\n      this._container.append(textDiv);\n    }\n    if (textDivProperties.hasEOL) {\n      const br = document.createElement(\"br\");\n      br.setAttribute(\"role\", \"presentation\");\n      this._container.append(br);\n    }\n  }\n  _render() {\n    const capability = new _util.PromiseCapability();\n    let styleCache = Object.create(null);\n    if (this._isReadableStream) {\n      const pump = () => {\n        this._reader.read().then(({\n          value,\n          done\n        }) => {\n          if (done) {\n            capability.resolve();\n            return;\n          }\n          Object.assign(styleCache, value.styles);\n          this._processItems(value.items, styleCache);\n          pump();\n        }, capability.reject);\n      };\n      this._reader = this._textContentSource.getReader();\n      pump();\n    } else if (this._textContentSource) {\n      const {\n        items,\n        styles\n      } = this._textContentSource;\n      this._processItems(items, styles);\n      capability.resolve();\n    } else {\n      throw new Error('No \"textContentSource\" parameter specified.');\n    }\n    capability.promise.then(() => {\n      styleCache = null;\n      render(this);\n    }, this._capability.reject);\n  }\n}\nexports.TextLayerRenderTask = TextLayerRenderTask;\nfunction renderTextLayer(params) {\n  if (!params.textContentSource && (params.textContent || params.textContentStream)) {\n    (0, _display_utils.deprecated)(\"The TextLayerRender `textContent`/`textContentStream` parameters \" + \"will be removed in the future, please use `textContentSource` instead.\");\n    params.textContentSource = params.textContent || params.textContentStream;\n  }\n  const {\n    container,\n    viewport\n  } = params;\n  const style = getComputedStyle(container);\n  const visibility = style.getPropertyValue(\"visibility\");\n  const scaleFactor = parseFloat(style.getPropertyValue(\"--scale-factor\"));\n  if (visibility === \"visible\" && (!scaleFactor || Math.abs(scaleFactor - viewport.scale) > 1e-5)) {\n    console.error(\"The `--scale-factor` CSS-variable must be set, \" + \"to the same value as `viewport.scale`, \" + \"either on the `container`-element itself or higher up in the DOM.\");\n  }\n  const task = new TextLayerRenderTask(params);\n  task._render();\n  return task;\n}\nfunction updateTextLayer({\n  container,\n  viewport,\n  textDivs,\n  textDivProperties,\n  isOffscreenCanvasSupported,\n  mustRotate = true,\n  mustRescale = true\n}) {\n  if (mustRotate) {\n    (0, _display_utils.setLayerDimensions)(container, {\n      rotation: viewport.rotation\n    });\n  }\n  if (mustRescale) {\n    const ctx = getCtx(0, isOffscreenCanvasSupported);\n    const scale = viewport.scale * (globalThis.devicePixelRatio || 1);\n    const params = {\n      prevFontSize: null,\n      prevFontFamily: null,\n      div: null,\n      scale,\n      properties: null,\n      ctx\n    };\n    for (const div of textDivs) {\n      params.properties = textDivProperties.get(div);\n      params.div = div;\n      layout(params);\n    }\n  }\n}\n\n/***/ }),\n/* 27 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.AnnotationEditorLayer = void 0;\nvar _util = __w_pdfjs_require__(1);\nvar _editor = __w_pdfjs_require__(4);\nvar _freetext = __w_pdfjs_require__(28);\nvar _ink = __w_pdfjs_require__(33);\nvar _display_utils = __w_pdfjs_require__(6);\nvar _stamp = __w_pdfjs_require__(34);\nclass AnnotationEditorLayer {\n  #accessibilityManager;\n  #allowClick = false;\n  #annotationLayer = null;\n  #boundPointerup = this.pointerup.bind(this);\n  #boundPointerdown = this.pointerdown.bind(this);\n  #editors = new Map();\n  #hadPointerDown = false;\n  #isCleaningUp = false;\n  #isDisabling = false;\n  #uiManager;\n  static _initialized = false;\n  constructor({\n    uiManager,\n    pageIndex,\n    div,\n    accessibilityManager,\n    annotationLayer,\n    viewport,\n    l10n\n  }) {\n    const editorTypes = [_freetext.FreeTextEditor, _ink.InkEditor, _stamp.StampEditor];\n    if (!AnnotationEditorLayer._initialized) {\n      AnnotationEditorLayer._initialized = true;\n      for (const editorType of editorTypes) {\n        editorType.initialize(l10n);\n      }\n    }\n    uiManager.registerEditorTypes(editorTypes);\n    this.#uiManager = uiManager;\n    this.pageIndex = pageIndex;\n    this.div = div;\n    this.#accessibilityManager = accessibilityManager;\n    this.#annotationLayer = annotationLayer;\n    this.viewport = viewport;\n    this.#uiManager.addLayer(this);\n  }\n  get isEmpty() {\n    return this.#editors.size === 0;\n  }\n  updateToolbar(mode) {\n    this.#uiManager.updateToolbar(mode);\n  }\n  updateMode(mode = this.#uiManager.getMode()) {\n    this.#cleanup();\n    if (mode === _util.AnnotationEditorType.INK) {\n      this.addInkEditorIfNeeded(false);\n      this.disableClick();\n    } else {\n      this.enableClick();\n    }\n    if (mode !== _util.AnnotationEditorType.NONE) {\n      this.div.classList.toggle(\"freeTextEditing\", mode === _util.AnnotationEditorType.FREETEXT);\n      this.div.classList.toggle(\"inkEditing\", mode === _util.AnnotationEditorType.INK);\n      this.div.classList.toggle(\"stampEditing\", mode === _util.AnnotationEditorType.STAMP);\n      this.div.hidden = false;\n    }\n  }\n  addInkEditorIfNeeded(isCommitting) {\n    if (!isCommitting && this.#uiManager.getMode() !== _util.AnnotationEditorType.INK) {\n      return;\n    }\n    if (!isCommitting) {\n      for (const editor of this.#editors.values()) {\n        if (editor.isEmpty()) {\n          editor.setInBackground();\n          return;\n        }\n      }\n    }\n    const editor = this.#createAndAddNewEditor({\n      offsetX: 0,\n      offsetY: 0\n    }, false);\n    editor.setInBackground();\n  }\n  setEditingState(isEditing) {\n    this.#uiManager.setEditingState(isEditing);\n  }\n  addCommands(params) {\n    this.#uiManager.addCommands(params);\n  }\n  enable() {\n    this.div.style.pointerEvents = \"auto\";\n    const annotationElementIds = new Set();\n    for (const editor of this.#editors.values()) {\n      editor.enableEditing();\n      if (editor.annotationElementId) {\n        annotationElementIds.add(editor.annotationElementId);\n      }\n    }\n    if (!this.#annotationLayer) {\n      return;\n    }\n    const editables = this.#annotationLayer.getEditableAnnotations();\n    for (const editable of editables) {\n      editable.hide();\n      if (this.#uiManager.isDeletedAnnotationElement(editable.data.id)) {\n        continue;\n      }\n      if (annotationElementIds.has(editable.data.id)) {\n        continue;\n      }\n      const editor = this.deserialize(editable);\n      if (!editor) {\n        continue;\n      }\n      this.addOrRebuild(editor);\n      editor.enableEditing();\n    }\n  }\n  disable() {\n    this.#isDisabling = true;\n    this.div.style.pointerEvents = \"none\";\n    const hiddenAnnotationIds = new Set();\n    for (const editor of this.#editors.values()) {\n      editor.disableEditing();\n      if (!editor.annotationElementId || editor.serialize() !== null) {\n        hiddenAnnotationIds.add(editor.annotationElementId);\n        continue;\n      }\n      this.getEditableAnnotation(editor.annotationElementId)?.show();\n      editor.remove();\n    }\n    if (this.#annotationLayer) {\n      const editables = this.#annotationLayer.getEditableAnnotations();\n      for (const editable of editables) {\n        const {\n          id\n        } = editable.data;\n        if (hiddenAnnotationIds.has(id) || this.#uiManager.isDeletedAnnotationElement(id)) {\n          continue;\n        }\n        editable.show();\n      }\n    }\n    this.#cleanup();\n    if (this.isEmpty) {\n      this.div.hidden = true;\n    }\n    this.#isDisabling = false;\n  }\n  getEditableAnnotation(id) {\n    return this.#annotationLayer?.getEditableAnnotation(id) || null;\n  }\n  setActiveEditor(editor) {\n    const currentActive = this.#uiManager.getActive();\n    if (currentActive === editor) {\n      return;\n    }\n    this.#uiManager.setActiveEditor(editor);\n  }\n  enableClick() {\n    this.div.addEventListener(\"pointerdown\", this.#boundPointerdown);\n    this.div.addEventListener(\"pointerup\", this.#boundPointerup);\n  }\n  disableClick() {\n    this.div.removeEventListener(\"pointerdown\", this.#boundPointerdown);\n    this.div.removeEventListener(\"pointerup\", this.#boundPointerup);\n  }\n  attach(editor) {\n    this.#editors.set(editor.id, editor);\n    const {\n      annotationElementId\n    } = editor;\n    if (annotationElementId && this.#uiManager.isDeletedAnnotationElement(annotationElementId)) {\n      this.#uiManager.removeDeletedAnnotationElement(editor);\n    }\n  }\n  detach(editor) {\n    this.#editors.delete(editor.id);\n    this.#accessibilityManager?.removePointerInTextLayer(editor.contentDiv);\n    if (!this.#isDisabling && editor.annotationElementId) {\n      this.#uiManager.addDeletedAnnotationElement(editor);\n    }\n  }\n  remove(editor) {\n    this.detach(editor);\n    this.#uiManager.removeEditor(editor);\n    if (editor.div.contains(document.activeElement)) {\n      setTimeout(() => {\n        this.#uiManager.focusMainContainer();\n      }, 0);\n    }\n    editor.div.remove();\n    editor.isAttachedToDOM = false;\n    if (!this.#isCleaningUp) {\n      this.addInkEditorIfNeeded(false);\n    }\n  }\n  changeParent(editor) {\n    if (editor.parent === this) {\n      return;\n    }\n    if (editor.annotationElementId) {\n      this.#uiManager.addDeletedAnnotationElement(editor.annotationElementId);\n      _editor.AnnotationEditor.deleteAnnotationElement(editor);\n      editor.annotationElementId = null;\n    }\n    this.attach(editor);\n    editor.parent?.detach(editor);\n    editor.setParent(this);\n    if (editor.div && editor.isAttachedToDOM) {\n      editor.div.remove();\n      this.div.append(editor.div);\n    }\n  }\n  add(editor) {\n    this.changeParent(editor);\n    this.#uiManager.addEditor(editor);\n    this.attach(editor);\n    if (!editor.isAttachedToDOM) {\n      const div = editor.render();\n      this.div.append(div);\n      editor.isAttachedToDOM = true;\n    }\n    editor.fixAndSetPosition();\n    editor.onceAdded();\n    this.#uiManager.addToAnnotationStorage(editor);\n  }\n  moveEditorInDOM(editor) {\n    if (!editor.isAttachedToDOM) {\n      return;\n    }\n    const {\n      activeElement\n    } = document;\n    if (editor.div.contains(activeElement)) {\n      editor._focusEventsAllowed = false;\n      setTimeout(() => {\n        if (!editor.div.contains(document.activeElement)) {\n          editor.div.addEventListener(\"focusin\", () => {\n            editor._focusEventsAllowed = true;\n          }, {\n            once: true\n          });\n          activeElement.focus();\n        } else {\n          editor._focusEventsAllowed = true;\n        }\n      }, 0);\n    }\n    editor._structTreeParentId = this.#accessibilityManager?.moveElementInDOM(this.div, editor.div, editor.contentDiv, true);\n  }\n  addOrRebuild(editor) {\n    if (editor.needsToBeRebuilt()) {\n      editor.rebuild();\n    } else {\n      this.add(editor);\n    }\n  }\n  addUndoableEditor(editor) {\n    const cmd = () => editor._uiManager.rebuild(editor);\n    const undo = () => {\n      editor.remove();\n    };\n    this.addCommands({\n      cmd,\n      undo,\n      mustExec: false\n    });\n  }\n  getNextId() {\n    return this.#uiManager.getId();\n  }\n  #createNewEditor(params) {\n    switch (this.#uiManager.getMode()) {\n      case _util.AnnotationEditorType.FREETEXT:\n        return new _freetext.FreeTextEditor(params);\n      case _util.AnnotationEditorType.INK:\n        return new _ink.InkEditor(params);\n      case _util.AnnotationEditorType.STAMP:\n        return new _stamp.StampEditor(params);\n    }\n    return null;\n  }\n  pasteEditor(mode, params) {\n    this.#uiManager.updateToolbar(mode);\n    this.#uiManager.updateMode(mode);\n    const {\n      offsetX,\n      offsetY\n    } = this.#getCenterPoint();\n    const id = this.getNextId();\n    const editor = this.#createNewEditor({\n      parent: this,\n      id,\n      x: offsetX,\n      y: offsetY,\n      uiManager: this.#uiManager,\n      isCentered: true,\n      ...params\n    });\n    if (editor) {\n      this.add(editor);\n    }\n  }\n  deserialize(data) {\n    switch (data.annotationType ?? data.annotationEditorType) {\n      case _util.AnnotationEditorType.FREETEXT:\n        return _freetext.FreeTextEditor.deserialize(data, this, this.#uiManager);\n      case _util.AnnotationEditorType.INK:\n        return _ink.InkEditor.deserialize(data, this, this.#uiManager);\n      case _util.AnnotationEditorType.STAMP:\n        return _stamp.StampEditor.deserialize(data, this, this.#uiManager);\n    }\n    return null;\n  }\n  #createAndAddNewEditor(event, isCentered) {\n    const id = this.getNextId();\n    const editor = this.#createNewEditor({\n      parent: this,\n      id,\n      x: event.offsetX,\n      y: event.offsetY,\n      uiManager: this.#uiManager,\n      isCentered\n    });\n    if (editor) {\n      this.add(editor);\n    }\n    return editor;\n  }\n  #getCenterPoint() {\n    const {\n      x,\n      y,\n      width,\n      height\n    } = this.div.getBoundingClientRect();\n    const tlX = Math.max(0, x);\n    const tlY = Math.max(0, y);\n    const brX = Math.min(window.innerWidth, x + width);\n    const brY = Math.min(window.innerHeight, y + height);\n    const centerX = (tlX + brX) / 2 - x;\n    const centerY = (tlY + brY) / 2 - y;\n    const [offsetX, offsetY] = this.viewport.rotation % 180 === 0 ? [centerX, centerY] : [centerY, centerX];\n    return {\n      offsetX,\n      offsetY\n    };\n  }\n  addNewEditor() {\n    this.#createAndAddNewEditor(this.#getCenterPoint(), true);\n  }\n  setSelected(editor) {\n    this.#uiManager.setSelected(editor);\n  }\n  toggleSelected(editor) {\n    this.#uiManager.toggleSelected(editor);\n  }\n  isSelected(editor) {\n    return this.#uiManager.isSelected(editor);\n  }\n  unselect(editor) {\n    this.#uiManager.unselect(editor);\n  }\n  pointerup(event) {\n    const {\n      isMac\n    } = _util.FeatureTest.platform;\n    if (event.button !== 0 || event.ctrlKey && isMac) {\n      return;\n    }\n    if (event.target !== this.div) {\n      return;\n    }\n    if (!this.#hadPointerDown) {\n      return;\n    }\n    this.#hadPointerDown = false;\n    if (!this.#allowClick) {\n      this.#allowClick = true;\n      return;\n    }\n    if (this.#uiManager.getMode() === _util.AnnotationEditorType.STAMP) {\n      this.#uiManager.unselectAll();\n      return;\n    }\n    this.#createAndAddNewEditor(event, false);\n  }\n  pointerdown(event) {\n    if (this.#hadPointerDown) {\n      this.#hadPointerDown = false;\n      return;\n    }\n    const {\n      isMac\n    } = _util.FeatureTest.platform;\n    if (event.button !== 0 || event.ctrlKey && isMac) {\n      return;\n    }\n    if (event.target !== this.div) {\n      return;\n    }\n    this.#hadPointerDown = true;\n    const editor = this.#uiManager.getActive();\n    this.#allowClick = !editor || editor.isEmpty();\n  }\n  findNewParent(editor, x, y) {\n    const layer = this.#uiManager.findParent(x, y);\n    if (layer === null || layer === this) {\n      return false;\n    }\n    layer.changeParent(editor);\n    return true;\n  }\n  destroy() {\n    if (this.#uiManager.getActive()?.parent === this) {\n      this.#uiManager.commitOrRemove();\n      this.#uiManager.setActiveEditor(null);\n    }\n    for (const editor of this.#editors.values()) {\n      this.#accessibilityManager?.removePointerInTextLayer(editor.contentDiv);\n      editor.setParent(null);\n      editor.isAttachedToDOM = false;\n      editor.div.remove();\n    }\n    this.div = null;\n    this.#editors.clear();\n    this.#uiManager.removeLayer(this);\n  }\n  #cleanup() {\n    this.#isCleaningUp = true;\n    for (const editor of this.#editors.values()) {\n      if (editor.isEmpty()) {\n        editor.remove();\n      }\n    }\n    this.#isCleaningUp = false;\n  }\n  render({\n    viewport\n  }) {\n    this.viewport = viewport;\n    (0, _display_utils.setLayerDimensions)(this.div, viewport);\n    for (const editor of this.#uiManager.getEditors(this.pageIndex)) {\n      this.add(editor);\n    }\n    this.updateMode();\n  }\n  update({\n    viewport\n  }) {\n    this.#uiManager.commitOrRemove();\n    this.viewport = viewport;\n    (0, _display_utils.setLayerDimensions)(this.div, {\n      rotation: viewport.rotation\n    });\n    this.updateMode();\n  }\n  get pageDimensions() {\n    const {\n      pageWidth,\n      pageHeight\n    } = this.viewport.rawDims;\n    return [pageWidth, pageHeight];\n  }\n}\nexports.AnnotationEditorLayer = AnnotationEditorLayer;\n\n/***/ }),\n/* 28 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.FreeTextEditor = void 0;\nvar _util = __w_pdfjs_require__(1);\nvar _tools = __w_pdfjs_require__(5);\nvar _editor = __w_pdfjs_require__(4);\nvar _annotation_layer = __w_pdfjs_require__(29);\nclass FreeTextEditor extends _editor.AnnotationEditor {\n  #boundEditorDivBlur = this.editorDivBlur.bind(this);\n  #boundEditorDivFocus = this.editorDivFocus.bind(this);\n  #boundEditorDivInput = this.editorDivInput.bind(this);\n  #boundEditorDivKeydown = this.editorDivKeydown.bind(this);\n  #color;\n  #content = \"\";\n  #editorDivId = `${this.id}-editor`;\n  #fontSize;\n  #initialData = null;\n  static _freeTextDefaultContent = \"\";\n  static _internalPadding = 0;\n  static _defaultColor = null;\n  static _defaultFontSize = 10;\n  static get _keyboardManager() {\n    const proto = FreeTextEditor.prototype;\n    const arrowChecker = self => self.isEmpty();\n    const small = _tools.AnnotationEditorUIManager.TRANSLATE_SMALL;\n    const big = _tools.AnnotationEditorUIManager.TRANSLATE_BIG;\n    return (0, _util.shadow)(this, \"_keyboardManager\", new _tools.KeyboardManager([[[\"ctrl+s\", \"mac+meta+s\", \"ctrl+p\", \"mac+meta+p\"], proto.commitOrRemove, {\n      bubbles: true\n    }], [[\"ctrl+Enter\", \"mac+meta+Enter\", \"Escape\", \"mac+Escape\"], proto.commitOrRemove], [[\"ArrowLeft\", \"mac+ArrowLeft\"], proto._translateEmpty, {\n      args: [-small, 0],\n      checker: arrowChecker\n    }], [[\"ctrl+ArrowLeft\", \"mac+shift+ArrowLeft\"], proto._translateEmpty, {\n      args: [-big, 0],\n      checker: arrowChecker\n    }], [[\"ArrowRight\", \"mac+ArrowRight\"], proto._translateEmpty, {\n      args: [small, 0],\n      checker: arrowChecker\n    }], [[\"ctrl+ArrowRight\", \"mac+shift+ArrowRight\"], proto._translateEmpty, {\n      args: [big, 0],\n      checker: arrowChecker\n    }], [[\"ArrowUp\", \"mac+ArrowUp\"], proto._translateEmpty, {\n      args: [0, -small],\n      checker: arrowChecker\n    }], [[\"ctrl+ArrowUp\", \"mac+shift+ArrowUp\"], proto._translateEmpty, {\n      args: [0, -big],\n      checker: arrowChecker\n    }], [[\"ArrowDown\", \"mac+ArrowDown\"], proto._translateEmpty, {\n      args: [0, small],\n      checker: arrowChecker\n    }], [[\"ctrl+ArrowDown\", \"mac+shift+ArrowDown\"], proto._translateEmpty, {\n      args: [0, big],\n      checker: arrowChecker\n    }]]));\n  }\n  static _type = \"freetext\";\n  constructor(params) {\n    super({\n      ...params,\n      name: \"freeTextEditor\"\n    });\n    this.#color = params.color || FreeTextEditor._defaultColor || _editor.AnnotationEditor._defaultLineColor;\n    this.#fontSize = params.fontSize || FreeTextEditor._defaultFontSize;\n  }\n  static initialize(l10n) {\n    _editor.AnnotationEditor.initialize(l10n, {\n      strings: [\"free_text2_default_content\", \"editor_free_text2_aria_label\"]\n    });\n    const style = getComputedStyle(document.documentElement);\n    this._internalPadding = parseFloat(style.getPropertyValue(\"--freetext-padding\"));\n  }\n  static updateDefaultParams(type, value) {\n    switch (type) {\n      case _util.AnnotationEditorParamsType.FREETEXT_SIZE:\n        FreeTextEditor._defaultFontSize = value;\n        break;\n      case _util.AnnotationEditorParamsType.FREETEXT_COLOR:\n        FreeTextEditor._defaultColor = value;\n        break;\n    }\n  }\n  updateParams(type, value) {\n    switch (type) {\n      case _util.AnnotationEditorParamsType.FREETEXT_SIZE:\n        this.#updateFontSize(value);\n        break;\n      case _util.AnnotationEditorParamsType.FREETEXT_COLOR:\n        this.#updateColor(value);\n        break;\n    }\n  }\n  static get defaultPropertiesToUpdate() {\n    return [[_util.AnnotationEditorParamsType.FREETEXT_SIZE, FreeTextEditor._defaultFontSize], [_util.AnnotationEditorParamsType.FREETEXT_COLOR, FreeTextEditor._defaultColor || _editor.AnnotationEditor._defaultLineColor]];\n  }\n  get propertiesToUpdate() {\n    return [[_util.AnnotationEditorParamsType.FREETEXT_SIZE, this.#fontSize], [_util.AnnotationEditorParamsType.FREETEXT_COLOR, this.#color]];\n  }\n  #updateFontSize(fontSize) {\n    const setFontsize = size => {\n      this.editorDiv.style.fontSize = `calc(${size}px * var(--scale-factor))`;\n      this.translate(0, -(size - this.#fontSize) * this.parentScale);\n      this.#fontSize = size;\n      this.#setEditorDimensions();\n    };\n    const savedFontsize = this.#fontSize;\n    this.addCommands({\n      cmd: () => {\n        setFontsize(fontSize);\n      },\n      undo: () => {\n        setFontsize(savedFontsize);\n      },\n      mustExec: true,\n      type: _util.AnnotationEditorParamsType.FREETEXT_SIZE,\n      overwriteIfSameType: true,\n      keepUndo: true\n    });\n  }\n  #updateColor(color) {\n    const savedColor = this.#color;\n    this.addCommands({\n      cmd: () => {\n        this.#color = this.editorDiv.style.color = color;\n      },\n      undo: () => {\n        this.#color = this.editorDiv.style.color = savedColor;\n      },\n      mustExec: true,\n      type: _util.AnnotationEditorParamsType.FREETEXT_COLOR,\n      overwriteIfSameType: true,\n      keepUndo: true\n    });\n  }\n  _translateEmpty(x, y) {\n    this._uiManager.translateSelectedEditors(x, y, true);\n  }\n  getInitialTranslation() {\n    const scale = this.parentScale;\n    return [-FreeTextEditor._internalPadding * scale, -(FreeTextEditor._internalPadding + this.#fontSize) * scale];\n  }\n  rebuild() {\n    if (!this.parent) {\n      return;\n    }\n    super.rebuild();\n    if (this.div === null) {\n      return;\n    }\n    if (!this.isAttachedToDOM) {\n      this.parent.add(this);\n    }\n  }\n  enableEditMode() {\n    if (this.isInEditMode()) {\n      return;\n    }\n    this.parent.setEditingState(false);\n    this.parent.updateToolbar(_util.AnnotationEditorType.FREETEXT);\n    super.enableEditMode();\n    this.overlayDiv.classList.remove(\"enabled\");\n    this.editorDiv.contentEditable = true;\n    this._isDraggable = false;\n    this.div.removeAttribute(\"aria-activedescendant\");\n    this.editorDiv.addEventListener(\"keydown\", this.#boundEditorDivKeydown);\n    this.editorDiv.addEventListener(\"focus\", this.#boundEditorDivFocus);\n    this.editorDiv.addEventListener(\"blur\", this.#boundEditorDivBlur);\n    this.editorDiv.addEventListener(\"input\", this.#boundEditorDivInput);\n  }\n  disableEditMode() {\n    if (!this.isInEditMode()) {\n      return;\n    }\n    this.parent.setEditingState(true);\n    super.disableEditMode();\n    this.overlayDiv.classList.add(\"enabled\");\n    this.editorDiv.contentEditable = false;\n    this.div.setAttribute(\"aria-activedescendant\", this.#editorDivId);\n    this._isDraggable = true;\n    this.editorDiv.removeEventListener(\"keydown\", this.#boundEditorDivKeydown);\n    this.editorDiv.removeEventListener(\"focus\", this.#boundEditorDivFocus);\n    this.editorDiv.removeEventListener(\"blur\", this.#boundEditorDivBlur);\n    this.editorDiv.removeEventListener(\"input\", this.#boundEditorDivInput);\n    this.div.focus({\n      preventScroll: true\n    });\n    this.isEditing = false;\n    this.parent.div.classList.add(\"freeTextEditing\");\n  }\n  focusin(event) {\n    if (!this._focusEventsAllowed) {\n      return;\n    }\n    super.focusin(event);\n    if (event.target !== this.editorDiv) {\n      this.editorDiv.focus();\n    }\n  }\n  onceAdded() {\n    if (this.width) {\n      this.#cheatInitialRect();\n      return;\n    }\n    this.enableEditMode();\n    this.editorDiv.focus();\n    if (this._initialOptions?.isCentered) {\n      this.center();\n    }\n    this._initialOptions = null;\n  }\n  isEmpty() {\n    return !this.editorDiv || this.editorDiv.innerText.trim() === \"\";\n  }\n  remove() {\n    this.isEditing = false;\n    if (this.parent) {\n      this.parent.setEditingState(true);\n      this.parent.div.classList.add(\"freeTextEditing\");\n    }\n    super.remove();\n  }\n  #extractText() {\n    const divs = this.editorDiv.getElementsByTagName(\"div\");\n    if (divs.length === 0) {\n      return this.editorDiv.innerText;\n    }\n    const buffer = [];\n    for (const div of divs) {\n      buffer.push(div.innerText.replace(/\\r\\n?|\\n/, \"\"));\n    }\n    return buffer.join(\"\\n\");\n  }\n  #setEditorDimensions() {\n    const [parentWidth, parentHeight] = this.parentDimensions;\n    let rect;\n    if (this.isAttachedToDOM) {\n      rect = this.div.getBoundingClientRect();\n    } else {\n      const {\n        currentLayer,\n        div\n      } = this;\n      const savedDisplay = div.style.display;\n      div.style.display = \"hidden\";\n      currentLayer.div.append(this.div);\n      rect = div.getBoundingClientRect();\n      div.remove();\n      div.style.display = savedDisplay;\n    }\n    if (this.rotation % 180 === this.parentRotation % 180) {\n      this.width = rect.width / parentWidth;\n      this.height = rect.height / parentHeight;\n    } else {\n      this.width = rect.height / parentWidth;\n      this.height = rect.width / parentHeight;\n    }\n    this.fixAndSetPosition();\n  }\n  commit() {\n    if (!this.isInEditMode()) {\n      return;\n    }\n    super.commit();\n    this.disableEditMode();\n    const savedText = this.#content;\n    const newText = this.#content = this.#extractText().trimEnd();\n    if (savedText === newText) {\n      return;\n    }\n    const setText = text => {\n      this.#content = text;\n      if (!text) {\n        this.remove();\n        return;\n      }\n      this.#setContent();\n      this._uiManager.rebuild(this);\n      this.#setEditorDimensions();\n    };\n    this.addCommands({\n      cmd: () => {\n        setText(newText);\n      },\n      undo: () => {\n        setText(savedText);\n      },\n      mustExec: false\n    });\n    this.#setEditorDimensions();\n  }\n  shouldGetKeyboardEvents() {\n    return this.isInEditMode();\n  }\n  enterInEditMode() {\n    this.enableEditMode();\n    this.editorDiv.focus();\n  }\n  dblclick(event) {\n    this.enterInEditMode();\n  }\n  keydown(event) {\n    if (event.target === this.div && event.key === \"Enter\") {\n      this.enterInEditMode();\n      event.preventDefault();\n    }\n  }\n  editorDivKeydown(event) {\n    FreeTextEditor._keyboardManager.exec(this, event);\n  }\n  editorDivFocus(event) {\n    this.isEditing = true;\n  }\n  editorDivBlur(event) {\n    this.isEditing = false;\n  }\n  editorDivInput(event) {\n    this.parent.div.classList.toggle(\"freeTextEditing\", this.isEmpty());\n  }\n  disableEditing() {\n    this.editorDiv.setAttribute(\"role\", \"comment\");\n    this.editorDiv.removeAttribute(\"aria-multiline\");\n  }\n  enableEditing() {\n    this.editorDiv.setAttribute(\"role\", \"textbox\");\n    this.editorDiv.setAttribute(\"aria-multiline\", true);\n  }\n  render() {\n    if (this.div) {\n      return this.div;\n    }\n    let baseX, baseY;\n    if (this.width) {\n      baseX = this.x;\n      baseY = this.y;\n    }\n    super.render();\n    this.editorDiv = document.createElement(\"div\");\n    this.editorDiv.className = \"internal\";\n    this.editorDiv.setAttribute(\"id\", this.#editorDivId);\n    this.enableEditing();\n    _editor.AnnotationEditor._l10nPromise.get(\"editor_free_text2_aria_label\").then(msg => this.editorDiv?.setAttribute(\"aria-label\", msg));\n    _editor.AnnotationEditor._l10nPromise.get(\"free_text2_default_content\").then(msg => this.editorDiv?.setAttribute(\"default-content\", msg));\n    this.editorDiv.contentEditable = true;\n    const {\n      style\n    } = this.editorDiv;\n    style.fontSize = `calc(${this.#fontSize}px * var(--scale-factor))`;\n    style.color = this.#color;\n    this.div.append(this.editorDiv);\n    this.overlayDiv = document.createElement(\"div\");\n    this.overlayDiv.classList.add(\"overlay\", \"enabled\");\n    this.div.append(this.overlayDiv);\n    (0, _tools.bindEvents)(this, this.div, [\"dblclick\", \"keydown\"]);\n    if (this.width) {\n      const [parentWidth, parentHeight] = this.parentDimensions;\n      if (this.annotationElementId) {\n        const {\n          position\n        } = this.#initialData;\n        let [tx, ty] = this.getInitialTranslation();\n        [tx, ty] = this.pageTranslationToScreen(tx, ty);\n        const [pageWidth, pageHeight] = this.pageDimensions;\n        const [pageX, pageY] = this.pageTranslation;\n        let posX, posY;\n        switch (this.rotation) {\n          case 0:\n            posX = baseX + (position[0] - pageX) / pageWidth;\n            posY = baseY + this.height - (position[1] - pageY) / pageHeight;\n            break;\n          case 90:\n            posX = baseX + (position[0] - pageX) / pageWidth;\n            posY = baseY - (position[1] - pageY) / pageHeight;\n            [tx, ty] = [ty, -tx];\n            break;\n          case 180:\n            posX = baseX - this.width + (position[0] - pageX) / pageWidth;\n            posY = baseY - (position[1] - pageY) / pageHeight;\n            [tx, ty] = [-tx, -ty];\n            break;\n          case 270:\n            posX = baseX + (position[0] - pageX - this.height * pageHeight) / pageWidth;\n            posY = baseY + (position[1] - pageY - this.width * pageWidth) / pageHeight;\n            [tx, ty] = [-ty, tx];\n            break;\n        }\n        this.setAt(posX * parentWidth, posY * parentHeight, tx, ty);\n      } else {\n        this.setAt(baseX * parentWidth, baseY * parentHeight, this.width * parentWidth, this.height * parentHeight);\n      }\n      this.#setContent();\n      this._isDraggable = true;\n      this.editorDiv.contentEditable = false;\n    } else {\n      this._isDraggable = false;\n      this.editorDiv.contentEditable = true;\n    }\n    return this.div;\n  }\n  #setContent() {\n    this.editorDiv.replaceChildren();\n    if (!this.#content) {\n      return;\n    }\n    for (const line of this.#content.split(\"\\n\")) {\n      const div = document.createElement(\"div\");\n      div.append(line ? document.createTextNode(line) : document.createElement(\"br\"));\n      this.editorDiv.append(div);\n    }\n  }\n  get contentDiv() {\n    return this.editorDiv;\n  }\n  static deserialize(data, parent, uiManager) {\n    let initialData = null;\n    if (data instanceof _annotation_layer.FreeTextAnnotationElement) {\n      const {\n        data: {\n          defaultAppearanceData: {\n            fontSize,\n            fontColor\n          },\n          rect,\n          rotation,\n          id\n        },\n        textContent,\n        textPosition,\n        parent: {\n          page: {\n            pageNumber\n          }\n        }\n      } = data;\n      if (!textContent || textContent.length === 0) {\n        return null;\n      }\n      initialData = data = {\n        annotationType: _util.AnnotationEditorType.FREETEXT,\n        color: Array.from(fontColor),\n        fontSize,\n        value: textContent.join(\"\\n\"),\n        position: textPosition,\n        pageIndex: pageNumber - 1,\n        rect,\n        rotation,\n        id,\n        deleted: false\n      };\n    }\n    const editor = super.deserialize(data, parent, uiManager);\n    editor.#fontSize = data.fontSize;\n    editor.#color = _util.Util.makeHexColor(...data.color);\n    editor.#content = data.value;\n    editor.annotationElementId = data.id || null;\n    editor.#initialData = initialData;\n    return editor;\n  }\n  serialize(isForCopying = false) {\n    if (this.isEmpty()) {\n      return null;\n    }\n    if (this.deleted) {\n      return {\n        pageIndex: this.pageIndex,\n        id: this.annotationElementId,\n        deleted: true\n      };\n    }\n    const padding = FreeTextEditor._internalPadding * this.parentScale;\n    const rect = this.getRect(padding, padding);\n    const color = _editor.AnnotationEditor._colorManager.convert(this.isAttachedToDOM ? getComputedStyle(this.editorDiv).color : this.#color);\n    const serialized = {\n      annotationType: _util.AnnotationEditorType.FREETEXT,\n      color,\n      fontSize: this.#fontSize,\n      value: this.#content,\n      pageIndex: this.pageIndex,\n      rect,\n      rotation: this.rotation,\n      structTreeParentId: this._structTreeParentId\n    };\n    if (isForCopying) {\n      return serialized;\n    }\n    if (this.annotationElementId && !this.#hasElementChanged(serialized)) {\n      return null;\n    }\n    serialized.id = this.annotationElementId;\n    return serialized;\n  }\n  #hasElementChanged(serialized) {\n    const {\n      value,\n      fontSize,\n      color,\n      rect,\n      pageIndex\n    } = this.#initialData;\n    return serialized.value !== value || serialized.fontSize !== fontSize || serialized.rect.some((x, i) => Math.abs(x - rect[i]) >= 1) || serialized.color.some((c, i) => c !== color[i]) || serialized.pageIndex !== pageIndex;\n  }\n  #cheatInitialRect(delayed = false) {\n    if (!this.annotationElementId) {\n      return;\n    }\n    this.#setEditorDimensions();\n    if (!delayed && (this.width === 0 || this.height === 0)) {\n      setTimeout(() => this.#cheatInitialRect(true), 0);\n      return;\n    }\n    const padding = FreeTextEditor._internalPadding * this.parentScale;\n    this.#initialData.rect = this.getRect(padding, padding);\n  }\n}\nexports.FreeTextEditor = FreeTextEditor;\n\n/***/ }),\n/* 29 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.StampAnnotationElement = exports.InkAnnotationElement = exports.FreeTextAnnotationElement = exports.AnnotationLayer = void 0;\nvar _util = __w_pdfjs_require__(1);\nvar _display_utils = __w_pdfjs_require__(6);\nvar _annotation_storage = __w_pdfjs_require__(3);\nvar _scripting_utils = __w_pdfjs_require__(30);\nvar _displayL10n_utils = __w_pdfjs_require__(31);\nvar _xfa_layer = __w_pdfjs_require__(32);\nconst DEFAULT_TAB_INDEX = 1000;\nconst DEFAULT_FONT_SIZE = 9;\nconst GetElementsByNameSet = new WeakSet();\nfunction getRectDims(rect) {\n  return {\n    width: rect[2] - rect[0],\n    height: rect[3] - rect[1]\n  };\n}\nclass AnnotationElementFactory {\n  static create(parameters) {\n    const subtype = parameters.data.annotationType;\n    switch (subtype) {\n      case _util.AnnotationType.LINK:\n        return new LinkAnnotationElement(parameters);\n      case _util.AnnotationType.TEXT:\n        return new TextAnnotationElement(parameters);\n      case _util.AnnotationType.WIDGET:\n        const fieldType = parameters.data.fieldType;\n        switch (fieldType) {\n          case \"Tx\":\n            return new TextWidgetAnnotationElement(parameters);\n          case \"Btn\":\n            if (parameters.data.radioButton) {\n              return new RadioButtonWidgetAnnotationElement(parameters);\n            } else if (parameters.data.checkBox) {\n              return new CheckboxWidgetAnnotationElement(parameters);\n            }\n            return new PushButtonWidgetAnnotationElement(parameters);\n          case \"Ch\":\n            return new ChoiceWidgetAnnotationElement(parameters);\n          case \"Sig\":\n            return new SignatureWidgetAnnotationElement(parameters);\n        }\n        return new WidgetAnnotationElement(parameters);\n      case _util.AnnotationType.POPUP:\n        return new PopupAnnotationElement(parameters);\n      case _util.AnnotationType.FREETEXT:\n        return new FreeTextAnnotationElement(parameters);\n      case _util.AnnotationType.LINE:\n        return new LineAnnotationElement(parameters);\n      case _util.AnnotationType.SQUARE:\n        return new SquareAnnotationElement(parameters);\n      case _util.AnnotationType.CIRCLE:\n        return new CircleAnnotationElement(parameters);\n      case _util.AnnotationType.POLYLINE:\n        return new PolylineAnnotationElement(parameters);\n      case _util.AnnotationType.CARET:\n        return new CaretAnnotationElement(parameters);\n      case _util.AnnotationType.INK:\n        return new InkAnnotationElement(parameters);\n      case _util.AnnotationType.POLYGON:\n        return new PolygonAnnotationElement(parameters);\n      case _util.AnnotationType.HIGHLIGHT:\n        return new HighlightAnnotationElement(parameters);\n      case _util.AnnotationType.UNDERLINE:\n        return new UnderlineAnnotationElement(parameters);\n      case _util.AnnotationType.SQUIGGLY:\n        return new SquigglyAnnotationElement(parameters);\n      case _util.AnnotationType.STRIKEOUT:\n        return new StrikeOutAnnotationElement(parameters);\n      case _util.AnnotationType.STAMP:\n        return new StampAnnotationElement(parameters);\n      case _util.AnnotationType.FILEATTACHMENT:\n        return new FileAttachmentAnnotationElement(parameters);\n      default:\n        return new AnnotationElement(parameters);\n    }\n  }\n}\nclass AnnotationElement {\n  #hasBorder = false;\n  constructor(parameters, {\n    isRenderable = false,\n    ignoreBorder = false,\n    createQuadrilaterals = false\n  } = {}) {\n    this.isRenderable = isRenderable;\n    this.data = parameters.data;\n    this.layer = parameters.layer;\n    this.linkService = parameters.linkService;\n    this.downloadManager = parameters.downloadManager;\n    this.imageResourcesPath = parameters.imageResourcesPath;\n    this.renderForms = parameters.renderForms;\n    this.svgFactory = parameters.svgFactory;\n    this.annotationStorage = parameters.annotationStorage;\n    this.enableScripting = parameters.enableScripting;\n    this.hasJSActions = parameters.hasJSActions;\n    this._fieldObjects = parameters.fieldObjects;\n    this.parent = parameters.parent;\n    if (isRenderable) {\n      this.container = this._createContainer(ignoreBorder);\n    }\n    if (createQuadrilaterals) {\n      this._createQuadrilaterals();\n    }\n  }\n  static _hasPopupData({\n    titleObj,\n    contentsObj,\n    richText\n  }) {\n    return !!(titleObj?.str || contentsObj?.str || richText?.str);\n  }\n  get hasPopupData() {\n    return AnnotationElement._hasPopupData(this.data);\n  }\n  _createContainer(ignoreBorder) {\n    const {\n      data,\n      parent: {\n        page,\n        viewport\n      }\n    } = this;\n    const container = document.createElement(\"section\");\n    container.setAttribute(\"data-annotation-id\", data.id);\n    if (!(this instanceof WidgetAnnotationElement)) {\n      container.tabIndex = DEFAULT_TAB_INDEX;\n    }\n    container.style.zIndex = this.parent.zIndex++;\n    if (this.data.popupRef) {\n      container.setAttribute(\"aria-haspopup\", \"dialog\");\n    }\n    if (data.noRotate) {\n      container.classList.add(\"norotate\");\n    }\n    const {\n      pageWidth,\n      pageHeight,\n      pageX,\n      pageY\n    } = viewport.rawDims;\n    if (!data.rect || this instanceof PopupAnnotationElement) {\n      const {\n        rotation\n      } = data;\n      if (!data.hasOwnCanvas && rotation !== 0) {\n        this.setRotation(rotation, container);\n      }\n      return container;\n    }\n    const {\n      width,\n      height\n    } = getRectDims(data.rect);\n    const rect = _util.Util.normalizeRect([data.rect[0], page.view[3] - data.rect[1] + page.view[1], data.rect[2], page.view[3] - data.rect[3] + page.view[1]]);\n    if (!ignoreBorder && data.borderStyle.width > 0) {\n      container.style.borderWidth = `${data.borderStyle.width}px`;\n      const horizontalRadius = data.borderStyle.horizontalCornerRadius;\n      const verticalRadius = data.borderStyle.verticalCornerRadius;\n      if (horizontalRadius > 0 || verticalRadius > 0) {\n        const radius = `calc(${horizontalRadius}px * var(--scale-factor)) / calc(${verticalRadius}px * var(--scale-factor))`;\n        container.style.borderRadius = radius;\n      } else if (this instanceof RadioButtonWidgetAnnotationElement) {\n        const radius = `calc(${width}px * var(--scale-factor)) / calc(${height}px * var(--scale-factor))`;\n        container.style.borderRadius = radius;\n      }\n      switch (data.borderStyle.style) {\n        case _util.AnnotationBorderStyleType.SOLID:\n          container.style.borderStyle = \"solid\";\n          break;\n        case _util.AnnotationBorderStyleType.DASHED:\n          container.style.borderStyle = \"dashed\";\n          break;\n        case _util.AnnotationBorderStyleType.BEVELED:\n          (0, _util.warn)(\"Unimplemented border style: beveled\");\n          break;\n        case _util.AnnotationBorderStyleType.INSET:\n          (0, _util.warn)(\"Unimplemented border style: inset\");\n          break;\n        case _util.AnnotationBorderStyleType.UNDERLINE:\n          container.style.borderBottomStyle = \"solid\";\n          break;\n        default:\n          break;\n      }\n      const borderColor = data.borderColor || null;\n      if (borderColor) {\n        this.#hasBorder = true;\n        container.style.borderColor = _util.Util.makeHexColor(borderColor[0] | 0, borderColor[1] | 0, borderColor[2] | 0);\n      } else {\n        container.style.borderWidth = 0;\n      }\n    }\n    container.style.left = `${100 * (rect[0] - pageX) / pageWidth}%`;\n    container.style.top = `${100 * (rect[1] - pageY) / pageHeight}%`;\n    const {\n      rotation\n    } = data;\n    if (data.hasOwnCanvas || rotation === 0) {\n      container.style.width = `${100 * width / pageWidth}%`;\n      container.style.height = `${100 * height / pageHeight}%`;\n    } else {\n      this.setRotation(rotation, container);\n    }\n    return container;\n  }\n  setRotation(angle, container = this.container) {\n    if (!this.data.rect) {\n      return;\n    }\n    const {\n      pageWidth,\n      pageHeight\n    } = this.parent.viewport.rawDims;\n    const {\n      width,\n      height\n    } = getRectDims(this.data.rect);\n    let elementWidth, elementHeight;\n    if (angle % 180 === 0) {\n      elementWidth = 100 * width / pageWidth;\n      elementHeight = 100 * height / pageHeight;\n    } else {\n      elementWidth = 100 * height / pageWidth;\n      elementHeight = 100 * width / pageHeight;\n    }\n    container.style.width = `${elementWidth}%`;\n    container.style.height = `${elementHeight}%`;\n    container.setAttribute(\"data-main-rotation\", (360 - angle) % 360);\n  }\n  get _commonActions() {\n    const setColor = (jsName, styleName, event) => {\n      const color = event.detail[jsName];\n      const colorType = color[0];\n      const colorArray = color.slice(1);\n      event.target.style[styleName] = _scripting_utils.ColorConverters[`${colorType}_HTML`](colorArray);\n      this.annotationStorage.setValue(this.data.id, {\n        [styleName]: _scripting_utils.ColorConverters[`${colorType}_rgb`](colorArray)\n      });\n    };\n    return (0, _util.shadow)(this, \"_commonActions\", {\n      display: event => {\n        const {\n          display\n        } = event.detail;\n        const hidden = display % 2 === 1;\n        this.container.style.visibility = hidden ? \"hidden\" : \"visible\";\n        this.annotationStorage.setValue(this.data.id, {\n          noView: hidden,\n          noPrint: display === 1 || display === 2\n        });\n      },\n      print: event => {\n        this.annotationStorage.setValue(this.data.id, {\n          noPrint: !event.detail.print\n        });\n      },\n      hidden: event => {\n        const {\n          hidden\n        } = event.detail;\n        this.container.style.visibility = hidden ? \"hidden\" : \"visible\";\n        this.annotationStorage.setValue(this.data.id, {\n          noPrint: hidden,\n          noView: hidden\n        });\n      },\n      focus: event => {\n        setTimeout(() => event.target.focus({\n          preventScroll: false\n        }), 0);\n      },\n      userName: event => {\n        event.target.title = event.detail.userName;\n      },\n      readonly: event => {\n        event.target.disabled = event.detail.readonly;\n      },\n      required: event => {\n        this._setRequired(event.target, event.detail.required);\n      },\n      bgColor: event => {\n        setColor(\"bgColor\", \"backgroundColor\", event);\n      },\n      fillColor: event => {\n        setColor(\"fillColor\", \"backgroundColor\", event);\n      },\n      fgColor: event => {\n        setColor(\"fgColor\", \"color\", event);\n      },\n      textColor: event => {\n        setColor(\"textColor\", \"color\", event);\n      },\n      borderColor: event => {\n        setColor(\"borderColor\", \"borderColor\", event);\n      },\n      strokeColor: event => {\n        setColor(\"strokeColor\", \"borderColor\", event);\n      },\n      rotation: event => {\n        const angle = event.detail.rotation;\n        this.setRotation(angle);\n        this.annotationStorage.setValue(this.data.id, {\n          rotation: angle\n        });\n      }\n    });\n  }\n  _dispatchEventFromSandbox(actions, jsEvent) {\n    const commonActions = this._commonActions;\n    for (const name of Object.keys(jsEvent.detail)) {\n      const action = actions[name] || commonActions[name];\n      action?.(jsEvent);\n    }\n  }\n  _setDefaultPropertiesFromJS(element) {\n    if (!this.enableScripting) {\n      return;\n    }\n    const storedData = this.annotationStorage.getRawValue(this.data.id);\n    if (!storedData) {\n      return;\n    }\n    const commonActions = this._commonActions;\n    for (const [actionName, detail] of Object.entries(storedData)) {\n      const action = commonActions[actionName];\n      if (action) {\n        const eventProxy = {\n          detail: {\n            [actionName]: detail\n          },\n          target: element\n        };\n        action(eventProxy);\n        delete storedData[actionName];\n      }\n    }\n  }\n  _createQuadrilaterals() {\n    if (!this.container) {\n      return;\n    }\n    const {\n      quadPoints\n    } = this.data;\n    if (!quadPoints) {\n      return;\n    }\n    const [rectBlX, rectBlY, rectTrX, rectTrY] = this.data.rect;\n    if (quadPoints.length === 1) {\n      const [, {\n        x: trX,\n        y: trY\n      }, {\n        x: blX,\n        y: blY\n      }] = quadPoints[0];\n      if (rectTrX === trX && rectTrY === trY && rectBlX === blX && rectBlY === blY) {\n        return;\n      }\n    }\n    const {\n      style\n    } = this.container;\n    let svgBuffer;\n    if (this.#hasBorder) {\n      const {\n        borderColor,\n        borderWidth\n      } = style;\n      style.borderWidth = 0;\n      svgBuffer = [\"url('data:image/svg+xml;utf8,\", `<svg xmlns=\"http://www.w3.org/2000/svg\"`, ` preserveAspectRatio=\"none\" viewBox=\"0 0 1 1\">`, `<g fill=\"transparent\" stroke=\"${borderColor}\" stroke-width=\"${borderWidth}\">`];\n      this.container.classList.add(\"hasBorder\");\n    }\n    const width = rectTrX - rectBlX;\n    const height = rectTrY - rectBlY;\n    const {\n      svgFactory\n    } = this;\n    const svg = svgFactory.createElement(\"svg\");\n    svg.classList.add(\"quadrilateralsContainer\");\n    svg.setAttribute(\"width\", 0);\n    svg.setAttribute(\"height\", 0);\n    const defs = svgFactory.createElement(\"defs\");\n    svg.append(defs);\n    const clipPath = svgFactory.createElement(\"clipPath\");\n    const id = `clippath_${this.data.id}`;\n    clipPath.setAttribute(\"id\", id);\n    clipPath.setAttribute(\"clipPathUnits\", \"objectBoundingBox\");\n    defs.append(clipPath);\n    for (const [, {\n      x: trX,\n      y: trY\n    }, {\n      x: blX,\n      y: blY\n    }] of quadPoints) {\n      const rect = svgFactory.createElement(\"rect\");\n      const x = (blX - rectBlX) / width;\n      const y = (rectTrY - trY) / height;\n      const rectWidth = (trX - blX) / width;\n      const rectHeight = (trY - blY) / height;\n      rect.setAttribute(\"x\", x);\n      rect.setAttribute(\"y\", y);\n      rect.setAttribute(\"width\", rectWidth);\n      rect.setAttribute(\"height\", rectHeight);\n      clipPath.append(rect);\n      svgBuffer?.push(`<rect vector-effect=\"non-scaling-stroke\" x=\"${x}\" y=\"${y}\" width=\"${rectWidth}\" height=\"${rectHeight}\"/>`);\n    }\n    if (this.#hasBorder) {\n      svgBuffer.push(`</g></svg>')`);\n      style.backgroundImage = svgBuffer.join(\"\");\n    }\n    this.container.append(svg);\n    this.container.style.clipPath = `url(#${id})`;\n  }\n  _createPopup() {\n    const {\n      container,\n      data\n    } = this;\n    container.setAttribute(\"aria-haspopup\", \"dialog\");\n    const popup = new PopupAnnotationElement({\n      data: {\n        color: data.color,\n        titleObj: data.titleObj,\n        modificationDate: data.modificationDate,\n        contentsObj: data.contentsObj,\n        richText: data.richText,\n        parentRect: data.rect,\n        borderStyle: 0,\n        id: `popup_${data.id}`,\n        rotation: data.rotation\n      },\n      parent: this.parent,\n      elements: [this]\n    });\n    this.parent.div.append(popup.render());\n  }\n  render() {\n    (0, _util.unreachable)(\"Abstract method `AnnotationElement.render` called\");\n  }\n  _getElementsByName(name, skipId = null) {\n    const fields = [];\n    if (this._fieldObjects) {\n      const fieldObj = this._fieldObjects[name];\n      if (fieldObj) {\n        for (const {\n          page,\n          id,\n          exportValues\n        } of fieldObj) {\n          if (page === -1) {\n            continue;\n          }\n          if (id === skipId) {\n            continue;\n          }\n          const exportValue = typeof exportValues === \"string\" ? exportValues : null;\n          const domElement = document.querySelector(`[data-element-id=\"${id}\"]`);\n          if (domElement && !GetElementsByNameSet.has(domElement)) {\n            (0, _util.warn)(`_getElementsByName - element not allowed: ${id}`);\n            continue;\n          }\n          fields.push({\n            id,\n            exportValue,\n            domElement\n          });\n        }\n      }\n      return fields;\n    }\n    for (const domElement of document.getElementsByName(name)) {\n      const {\n        exportValue\n      } = domElement;\n      const id = domElement.getAttribute(\"data-element-id\");\n      if (id === skipId) {\n        continue;\n      }\n      if (!GetElementsByNameSet.has(domElement)) {\n        continue;\n      }\n      fields.push({\n        id,\n        exportValue,\n        domElement\n      });\n    }\n    return fields;\n  }\n  show() {\n    if (this.container) {\n      this.container.hidden = false;\n    }\n    this.popup?.maybeShow();\n  }\n  hide() {\n    if (this.container) {\n      this.container.hidden = true;\n    }\n    this.popup?.forceHide();\n  }\n  getElementsToTriggerPopup() {\n    return this.container;\n  }\n  addHighlightArea() {\n    const triggers = this.getElementsToTriggerPopup();\n    if (Array.isArray(triggers)) {\n      for (const element of triggers) {\n        element.classList.add(\"highlightArea\");\n      }\n    } else {\n      triggers.classList.add(\"highlightArea\");\n    }\n  }\n  _editOnDoubleClick() {\n    const {\n      annotationEditorType: mode,\n      data: {\n        id: editId\n      }\n    } = this;\n    this.container.addEventListener(\"dblclick\", () => {\n      this.linkService.eventBus?.dispatch(\"switchannotationeditormode\", {\n        source: this,\n        mode,\n        editId\n      });\n    });\n  }\n}\nclass LinkAnnotationElement extends AnnotationElement {\n  constructor(parameters, options = null) {\n    super(parameters, {\n      isRenderable: true,\n      ignoreBorder: !!options?.ignoreBorder,\n      createQuadrilaterals: true\n    });\n    this.isTooltipOnly = parameters.data.isTooltipOnly;\n  }\n  render() {\n    const {\n      data,\n      linkService\n    } = this;\n    const link = document.createElement(\"a\");\n    link.setAttribute(\"data-element-id\", data.id);\n    let isBound = false;\n    if (data.url) {\n      linkService.addLinkAttributes(link, data.url, data.newWindow);\n      isBound = true;\n    } else if (data.action) {\n      this._bindNamedAction(link, data.action);\n      isBound = true;\n    } else if (data.attachment) {\n      this._bindAttachment(link, data.attachment);\n      isBound = true;\n    } else if (data.setOCGState) {\n      this.#bindSetOCGState(link, data.setOCGState);\n      isBound = true;\n    } else if (data.dest) {\n      this._bindLink(link, data.dest);\n      isBound = true;\n    } else {\n      if (data.actions && (data.actions.Action || data.actions[\"Mouse Up\"] || data.actions[\"Mouse Down\"]) && this.enableScripting && this.hasJSActions) {\n        this._bindJSAction(link, data);\n        isBound = true;\n      }\n      if (data.resetForm) {\n        this._bindResetFormAction(link, data.resetForm);\n        isBound = true;\n      } else if (this.isTooltipOnly && !isBound) {\n        this._bindLink(link, \"\");\n        isBound = true;\n      }\n    }\n    this.container.classList.add(\"linkAnnotation\");\n    if (isBound) {\n      this.container.append(link);\n    }\n    return this.container;\n  }\n  #setInternalLink() {\n    this.container.setAttribute(\"data-internal-link\", \"\");\n  }\n  _bindLink(link, destination) {\n    link.href = this.linkService.getDestinationHash(destination);\n    link.onclick = () => {\n      if (destination) {\n        this.linkService.goToDestination(destination);\n      }\n      return false;\n    };\n    if (destination || destination === \"\") {\n      this.#setInternalLink();\n    }\n  }\n  _bindNamedAction(link, action) {\n    link.href = this.linkService.getAnchorUrl(\"\");\n    link.onclick = () => {\n      this.linkService.executeNamedAction(action);\n      return false;\n    };\n    this.#setInternalLink();\n  }\n  _bindAttachment(link, attachment) {\n    link.href = this.linkService.getAnchorUrl(\"\");\n    link.onclick = () => {\n      this.downloadManager?.openOrDownloadData(this.container, attachment.content, attachment.filename);\n      return false;\n    };\n    this.#setInternalLink();\n  }\n  #bindSetOCGState(link, action) {\n    link.href = this.linkService.getAnchorUrl(\"\");\n    link.onclick = () => {\n      this.linkService.executeSetOCGState(action);\n      return false;\n    };\n    this.#setInternalLink();\n  }\n  _bindJSAction(link, data) {\n    link.href = this.linkService.getAnchorUrl(\"\");\n    const map = new Map([[\"Action\", \"onclick\"], [\"Mouse Up\", \"onmouseup\"], [\"Mouse Down\", \"onmousedown\"]]);\n    for (const name of Object.keys(data.actions)) {\n      const jsName = map.get(name);\n      if (!jsName) {\n        continue;\n      }\n      link[jsName] = () => {\n        this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n          source: this,\n          detail: {\n            id: data.id,\n            name\n          }\n        });\n        return false;\n      };\n    }\n    if (!link.onclick) {\n      link.onclick = () => false;\n    }\n    this.#setInternalLink();\n  }\n  _bindResetFormAction(link, resetForm) {\n    const otherClickAction = link.onclick;\n    if (!otherClickAction) {\n      link.href = this.linkService.getAnchorUrl(\"\");\n    }\n    this.#setInternalLink();\n    if (!this._fieldObjects) {\n      (0, _util.warn)(`_bindResetFormAction - \"resetForm\" action not supported, ` + \"ensure that the `fieldObjects` parameter is provided.\");\n      if (!otherClickAction) {\n        link.onclick = () => false;\n      }\n      return;\n    }\n    link.onclick = () => {\n      otherClickAction?.();\n      const {\n        fields: resetFormFields,\n        refs: resetFormRefs,\n        include\n      } = resetForm;\n      const allFields = [];\n      if (resetFormFields.length !== 0 || resetFormRefs.length !== 0) {\n        const fieldIds = new Set(resetFormRefs);\n        for (const fieldName of resetFormFields) {\n          const fields = this._fieldObjects[fieldName] || [];\n          for (const {\n            id\n          } of fields) {\n            fieldIds.add(id);\n          }\n        }\n        for (const fields of Object.values(this._fieldObjects)) {\n          for (const field of fields) {\n            if (fieldIds.has(field.id) === include) {\n              allFields.push(field);\n            }\n          }\n        }\n      } else {\n        for (const fields of Object.values(this._fieldObjects)) {\n          allFields.push(...fields);\n        }\n      }\n      const storage = this.annotationStorage;\n      const allIds = [];\n      for (const field of allFields) {\n        const {\n          id\n        } = field;\n        allIds.push(id);\n        switch (field.type) {\n          case \"text\":\n            {\n              const value = field.defaultValue || \"\";\n              storage.setValue(id, {\n                value\n              });\n              break;\n            }\n          case \"checkbox\":\n          case \"radiobutton\":\n            {\n              const value = field.defaultValue === field.exportValues;\n              storage.setValue(id, {\n                value\n              });\n              break;\n            }\n          case \"combobox\":\n          case \"listbox\":\n            {\n              const value = field.defaultValue || \"\";\n              storage.setValue(id, {\n                value\n              });\n              break;\n            }\n          default:\n            continue;\n        }\n        const domElement = document.querySelector(`[data-element-id=\"${id}\"]`);\n        if (!domElement) {\n          continue;\n        } else if (!GetElementsByNameSet.has(domElement)) {\n          (0, _util.warn)(`_bindResetFormAction - element not allowed: ${id}`);\n          continue;\n        }\n        domElement.dispatchEvent(new Event(\"resetform\"));\n      }\n      if (this.enableScripting) {\n        this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n          source: this,\n          detail: {\n            id: \"app\",\n            ids: allIds,\n            name: \"ResetForm\"\n          }\n        });\n      }\n      return false;\n    };\n  }\n}\nclass TextAnnotationElement extends AnnotationElement {\n  constructor(parameters) {\n    super(parameters, {\n      isRenderable: true\n    });\n  }\n  render() {\n    this.container.classList.add(\"textAnnotation\");\n    const image = document.createElement(\"img\");\n    image.src = this.imageResourcesPath + \"annotation-\" + this.data.name.toLowerCase() + \".svg\";\n    image.alt = \"[{{type}} Annotation]\";\n    image.dataset.l10nId = \"text_annotation_type\";\n    image.dataset.l10nArgs = JSON.stringify({\n      type: this.data.name\n    });\n    if (!this.data.popupRef && this.hasPopupData) {\n      this._createPopup();\n    }\n    this.container.append(image);\n    return this.container;\n  }\n}\nclass WidgetAnnotationElement extends AnnotationElement {\n  render() {\n    if (this.data.alternativeText) {\n      this.container.title = this.data.alternativeText;\n    }\n    return this.container;\n  }\n  showElementAndHideCanvas(element) {\n    if (this.data.hasOwnCanvas) {\n      if (element.previousSibling?.nodeName === \"CANVAS\") {\n        element.previousSibling.hidden = true;\n      }\n      element.hidden = false;\n    }\n  }\n  _getKeyModifier(event) {\n    const {\n      isWin,\n      isMac\n    } = _util.FeatureTest.platform;\n    return isWin && event.ctrlKey || isMac && event.metaKey;\n  }\n  _setEventListener(element, elementData, baseName, eventName, valueGetter) {\n    if (baseName.includes(\"mouse\")) {\n      element.addEventListener(baseName, event => {\n        this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n          source: this,\n          detail: {\n            id: this.data.id,\n            name: eventName,\n            value: valueGetter(event),\n            shift: event.shiftKey,\n            modifier: this._getKeyModifier(event)\n          }\n        });\n      });\n    } else {\n      element.addEventListener(baseName, event => {\n        if (baseName === \"blur\") {\n          if (!elementData.focused || !event.relatedTarget) {\n            return;\n          }\n          elementData.focused = false;\n        } else if (baseName === \"focus\") {\n          if (elementData.focused) {\n            return;\n          }\n          elementData.focused = true;\n        }\n        if (!valueGetter) {\n          return;\n        }\n        this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n          source: this,\n          detail: {\n            id: this.data.id,\n            name: eventName,\n            value: valueGetter(event)\n          }\n        });\n      });\n    }\n  }\n  _setEventListeners(element, elementData, names, getter) {\n    for (const [baseName, eventName] of names) {\n      if (eventName === \"Action\" || this.data.actions?.[eventName]) {\n        if (eventName === \"Focus\" || eventName === \"Blur\") {\n          elementData ||= {\n            focused: false\n          };\n        }\n        this._setEventListener(element, elementData, baseName, eventName, getter);\n        if (eventName === \"Focus\" && !this.data.actions?.Blur) {\n          this._setEventListener(element, elementData, \"blur\", \"Blur\", null);\n        } else if (eventName === \"Blur\" && !this.data.actions?.Focus) {\n          this._setEventListener(element, elementData, \"focus\", \"Focus\", null);\n        }\n      }\n    }\n  }\n  _setBackgroundColor(element) {\n    const color = this.data.backgroundColor || null;\n    element.style.backgroundColor = color === null ? \"transparent\" : _util.Util.makeHexColor(color[0], color[1], color[2]);\n  }\n  _setTextStyle(element) {\n    const TEXT_ALIGNMENT = [\"left\", \"center\", \"right\"];\n    const {\n      fontColor\n    } = this.data.defaultAppearanceData;\n    const fontSize = this.data.defaultAppearanceData.fontSize || DEFAULT_FONT_SIZE;\n    const style = element.style;\n    let computedFontSize;\n    const BORDER_SIZE = 2;\n    const roundToOneDecimal = x => Math.round(10 * x) / 10;\n    if (this.data.multiLine) {\n      const height = Math.abs(this.data.rect[3] - this.data.rect[1] - BORDER_SIZE);\n      const numberOfLines = Math.round(height / (_util.LINE_FACTOR * fontSize)) || 1;\n      const lineHeight = height / numberOfLines;\n      computedFontSize = Math.min(fontSize, roundToOneDecimal(lineHeight / _util.LINE_FACTOR));\n    } else {\n      const height = Math.abs(this.data.rect[3] - this.data.rect[1] - BORDER_SIZE);\n      computedFontSize = Math.min(fontSize, roundToOneDecimal(height / _util.LINE_FACTOR));\n    }\n    style.fontSize = `calc(${computedFontSize}px * var(--scale-factor))`;\n    style.color = _util.Util.makeHexColor(fontColor[0], fontColor[1], fontColor[2]);\n    if (this.data.textAlignment !== null) {\n      style.textAlign = TEXT_ALIGNMENT[this.data.textAlignment];\n    }\n  }\n  _setRequired(element, isRequired) {\n    if (isRequired) {\n      element.setAttribute(\"required\", true);\n    } else {\n      element.removeAttribute(\"required\");\n    }\n    element.setAttribute(\"aria-required\", isRequired);\n  }\n}\nclass TextWidgetAnnotationElement extends WidgetAnnotationElement {\n  constructor(parameters) {\n    const isRenderable = parameters.renderForms || !parameters.data.hasAppearance && !!parameters.data.fieldValue;\n    super(parameters, {\n      isRenderable\n    });\n  }\n  setPropertyOnSiblings(base, key, value, keyInStorage) {\n    const storage = this.annotationStorage;\n    for (const element of this._getElementsByName(base.name, base.id)) {\n      if (element.domElement) {\n        element.domElement[key] = value;\n      }\n      storage.setValue(element.id, {\n        [keyInStorage]: value\n      });\n    }\n  }\n  render() {\n    const storage = this.annotationStorage;\n    const id = this.data.id;\n    this.container.classList.add(\"textWidgetAnnotation\");\n    let element = null;\n    if (this.renderForms) {\n      const storedData = storage.getValue(id, {\n        value: this.data.fieldValue\n      });\n      let textContent = storedData.value || \"\";\n      const maxLen = storage.getValue(id, {\n        charLimit: this.data.maxLen\n      }).charLimit;\n      if (maxLen && textContent.length > maxLen) {\n        textContent = textContent.slice(0, maxLen);\n      }\n      let fieldFormattedValues = storedData.formattedValue || this.data.textContent?.join(\"\\n\") || null;\n      if (fieldFormattedValues && this.data.comb) {\n        fieldFormattedValues = fieldFormattedValues.replaceAll(/\\s+/g, \"\");\n      }\n      const elementData = {\n        userValue: textContent,\n        formattedValue: fieldFormattedValues,\n        lastCommittedValue: null,\n        commitKey: 1,\n        focused: false\n      };\n      if (this.data.multiLine) {\n        element = document.createElement(\"textarea\");\n        element.textContent = fieldFormattedValues ?? textContent;\n        if (this.data.doNotScroll) {\n          element.style.overflowY = \"hidden\";\n        }\n      } else {\n        element = document.createElement(\"input\");\n        element.type = \"text\";\n        element.setAttribute(\"value\", fieldFormattedValues ?? textContent);\n        if (this.data.doNotScroll) {\n          element.style.overflowX = \"hidden\";\n        }\n      }\n      if (this.data.hasOwnCanvas) {\n        element.hidden = true;\n      }\n      GetElementsByNameSet.add(element);\n      element.setAttribute(\"data-element-id\", id);\n      element.disabled = this.data.readOnly;\n      element.name = this.data.fieldName;\n      element.tabIndex = DEFAULT_TAB_INDEX;\n      this._setRequired(element, this.data.required);\n      if (maxLen) {\n        element.maxLength = maxLen;\n      }\n      element.addEventListener(\"input\", event => {\n        storage.setValue(id, {\n          value: event.target.value\n        });\n        this.setPropertyOnSiblings(element, \"value\", event.target.value, \"value\");\n        elementData.formattedValue = null;\n      });\n      element.addEventListener(\"resetform\", event => {\n        const defaultValue = this.data.defaultFieldValue ?? \"\";\n        element.value = elementData.userValue = defaultValue;\n        elementData.formattedValue = null;\n      });\n      let blurListener = event => {\n        const {\n          formattedValue\n        } = elementData;\n        if (formattedValue !== null && formattedValue !== undefined) {\n          event.target.value = formattedValue;\n        }\n        event.target.scrollLeft = 0;\n      };\n      if (this.enableScripting && this.hasJSActions) {\n        element.addEventListener(\"focus\", event => {\n          if (elementData.focused) {\n            return;\n          }\n          const {\n            target\n          } = event;\n          if (elementData.userValue) {\n            target.value = elementData.userValue;\n          }\n          elementData.lastCommittedValue = target.value;\n          elementData.commitKey = 1;\n          elementData.focused = true;\n        });\n        element.addEventListener(\"updatefromsandbox\", jsEvent => {\n          this.showElementAndHideCanvas(jsEvent.target);\n          const actions = {\n            value(event) {\n              elementData.userValue = event.detail.value ?? \"\";\n              storage.setValue(id, {\n                value: elementData.userValue.toString()\n              });\n              event.target.value = elementData.userValue;\n            },\n            formattedValue(event) {\n              const {\n                formattedValue\n              } = event.detail;\n              elementData.formattedValue = formattedValue;\n              if (formattedValue !== null && formattedValue !== undefined && event.target !== document.activeElement) {\n                event.target.value = formattedValue;\n              }\n              storage.setValue(id, {\n                formattedValue\n              });\n            },\n            selRange(event) {\n              event.target.setSelectionRange(...event.detail.selRange);\n            },\n            charLimit: event => {\n              const {\n                charLimit\n              } = event.detail;\n              const {\n                target\n              } = event;\n              if (charLimit === 0) {\n                target.removeAttribute(\"maxLength\");\n                return;\n              }\n              target.setAttribute(\"maxLength\", charLimit);\n              let value = elementData.userValue;\n              if (!value || value.length <= charLimit) {\n                return;\n              }\n              value = value.slice(0, charLimit);\n              target.value = elementData.userValue = value;\n              storage.setValue(id, {\n                value\n              });\n              this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n                source: this,\n                detail: {\n                  id,\n                  name: \"Keystroke\",\n                  value,\n                  willCommit: true,\n                  commitKey: 1,\n                  selStart: target.selectionStart,\n                  selEnd: target.selectionEnd\n                }\n              });\n            }\n          };\n          this._dispatchEventFromSandbox(actions, jsEvent);\n        });\n        element.addEventListener(\"keydown\", event => {\n          elementData.commitKey = 1;\n          let commitKey = -1;\n          if (event.key === \"Escape\") {\n            commitKey = 0;\n          } else if (event.key === \"Enter\" && !this.data.multiLine) {\n            commitKey = 2;\n          } else if (event.key === \"Tab\") {\n            elementData.commitKey = 3;\n          }\n          if (commitKey === -1) {\n            return;\n          }\n          const {\n            value\n          } = event.target;\n          if (elementData.lastCommittedValue === value) {\n            return;\n          }\n          elementData.lastCommittedValue = value;\n          elementData.userValue = value;\n          this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n            source: this,\n            detail: {\n              id,\n              name: \"Keystroke\",\n              value,\n              willCommit: true,\n              commitKey,\n              selStart: event.target.selectionStart,\n              selEnd: event.target.selectionEnd\n            }\n          });\n        });\n        const _blurListener = blurListener;\n        blurListener = null;\n        element.addEventListener(\"blur\", event => {\n          if (!elementData.focused || !event.relatedTarget) {\n            return;\n          }\n          elementData.focused = false;\n          const {\n            value\n          } = event.target;\n          elementData.userValue = value;\n          if (elementData.lastCommittedValue !== value) {\n            this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n              source: this,\n              detail: {\n                id,\n                name: \"Keystroke\",\n                value,\n                willCommit: true,\n                commitKey: elementData.commitKey,\n                selStart: event.target.selectionStart,\n                selEnd: event.target.selectionEnd\n              }\n            });\n          }\n          _blurListener(event);\n        });\n        if (this.data.actions?.Keystroke) {\n          element.addEventListener(\"beforeinput\", event => {\n            elementData.lastCommittedValue = null;\n            const {\n              data,\n              target\n            } = event;\n            const {\n              value,\n              selectionStart,\n              selectionEnd\n            } = target;\n            let selStart = selectionStart,\n              selEnd = selectionEnd;\n            switch (event.inputType) {\n              case \"deleteWordBackward\":\n                {\n                  const match = value.substring(0, selectionStart).match(/\\w*[^\\w]*$/);\n                  if (match) {\n                    selStart -= match[0].length;\n                  }\n                  break;\n                }\n              case \"deleteWordForward\":\n                {\n                  const match = value.substring(selectionStart).match(/^[^\\w]*\\w*/);\n                  if (match) {\n                    selEnd += match[0].length;\n                  }\n                  break;\n                }\n              case \"deleteContentBackward\":\n                if (selectionStart === selectionEnd) {\n                  selStart -= 1;\n                }\n                break;\n              case \"deleteContentForward\":\n                if (selectionStart === selectionEnd) {\n                  selEnd += 1;\n                }\n                break;\n            }\n            event.preventDefault();\n            this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n              source: this,\n              detail: {\n                id,\n                name: \"Keystroke\",\n                value,\n                change: data || \"\",\n                willCommit: false,\n                selStart,\n                selEnd\n              }\n            });\n          });\n        }\n        this._setEventListeners(element, elementData, [[\"focus\", \"Focus\"], [\"blur\", \"Blur\"], [\"mousedown\", \"Mouse Down\"], [\"mouseenter\", \"Mouse Enter\"], [\"mouseleave\", \"Mouse Exit\"], [\"mouseup\", \"Mouse Up\"]], event => event.target.value);\n      }\n      if (blurListener) {\n        element.addEventListener(\"blur\", blurListener);\n      }\n      if (this.data.comb) {\n        const fieldWidth = this.data.rect[2] - this.data.rect[0];\n        const combWidth = fieldWidth / maxLen;\n        element.classList.add(\"comb\");\n        element.style.letterSpacing = `calc(${combWidth}px * var(--scale-factor) - 1ch)`;\n      }\n    } else {\n      element = document.createElement(\"div\");\n      element.textContent = this.data.fieldValue;\n      element.style.verticalAlign = \"middle\";\n      element.style.display = \"table-cell\";\n    }\n    this._setTextStyle(element);\n    this._setBackgroundColor(element);\n    this._setDefaultPropertiesFromJS(element);\n    this.container.append(element);\n    return this.container;\n  }\n}\nclass SignatureWidgetAnnotationElement extends WidgetAnnotationElement {\n  constructor(parameters) {\n    super(parameters, {\n      isRenderable: !!parameters.data.hasOwnCanvas\n    });\n  }\n}\nclass CheckboxWidgetAnnotationElement extends WidgetAnnotationElement {\n  constructor(parameters) {\n    super(parameters, {\n      isRenderable: parameters.renderForms\n    });\n  }\n  render() {\n    const storage = this.annotationStorage;\n    const data = this.data;\n    const id = data.id;\n    let value = storage.getValue(id, {\n      value: data.exportValue === data.fieldValue\n    }).value;\n    if (typeof value === \"string\") {\n      value = value !== \"Off\";\n      storage.setValue(id, {\n        value\n      });\n    }\n    this.container.classList.add(\"buttonWidgetAnnotation\", \"checkBox\");\n    const element = document.createElement(\"input\");\n    GetElementsByNameSet.add(element);\n    element.setAttribute(\"data-element-id\", id);\n    element.disabled = data.readOnly;\n    this._setRequired(element, this.data.required);\n    element.type = \"checkbox\";\n    element.name = data.fieldName;\n    if (value) {\n      element.setAttribute(\"checked\", true);\n    }\n    element.setAttribute(\"exportValue\", data.exportValue);\n    element.tabIndex = DEFAULT_TAB_INDEX;\n    element.addEventListener(\"change\", event => {\n      const {\n        name,\n        checked\n      } = event.target;\n      for (const checkbox of this._getElementsByName(name, id)) {\n        const curChecked = checked && checkbox.exportValue === data.exportValue;\n        if (checkbox.domElement) {\n          checkbox.domElement.checked = curChecked;\n        }\n        storage.setValue(checkbox.id, {\n          value: curChecked\n        });\n      }\n      storage.setValue(id, {\n        value: checked\n      });\n    });\n    element.addEventListener(\"resetform\", event => {\n      const defaultValue = data.defaultFieldValue || \"Off\";\n      event.target.checked = defaultValue === data.exportValue;\n    });\n    if (this.enableScripting && this.hasJSActions) {\n      element.addEventListener(\"updatefromsandbox\", jsEvent => {\n        const actions = {\n          value(event) {\n            event.target.checked = event.detail.value !== \"Off\";\n            storage.setValue(id, {\n              value: event.target.checked\n            });\n          }\n        };\n        this._dispatchEventFromSandbox(actions, jsEvent);\n      });\n      this._setEventListeners(element, null, [[\"change\", \"Validate\"], [\"change\", \"Action\"], [\"focus\", \"Focus\"], [\"blur\", \"Blur\"], [\"mousedown\", \"Mouse Down\"], [\"mouseenter\", \"Mouse Enter\"], [\"mouseleave\", \"Mouse Exit\"], [\"mouseup\", \"Mouse Up\"]], event => event.target.checked);\n    }\n    this._setBackgroundColor(element);\n    this._setDefaultPropertiesFromJS(element);\n    this.container.append(element);\n    return this.container;\n  }\n}\nclass RadioButtonWidgetAnnotationElement extends WidgetAnnotationElement {\n  constructor(parameters) {\n    super(parameters, {\n      isRenderable: parameters.renderForms\n    });\n  }\n  render() {\n    this.container.classList.add(\"buttonWidgetAnnotation\", \"radioButton\");\n    const storage = this.annotationStorage;\n    const data = this.data;\n    const id = data.id;\n    let value = storage.getValue(id, {\n      value: data.fieldValue === data.buttonValue\n    }).value;\n    if (typeof value === \"string\") {\n      value = value !== data.buttonValue;\n      storage.setValue(id, {\n        value\n      });\n    }\n    const element = document.createElement(\"input\");\n    GetElementsByNameSet.add(element);\n    element.setAttribute(\"data-element-id\", id);\n    element.disabled = data.readOnly;\n    this._setRequired(element, this.data.required);\n    element.type = \"radio\";\n    element.name = data.fieldName;\n    if (value) {\n      element.setAttribute(\"checked\", true);\n    }\n    element.tabIndex = DEFAULT_TAB_INDEX;\n    element.addEventListener(\"change\", event => {\n      const {\n        name,\n        checked\n      } = event.target;\n      for (const radio of this._getElementsByName(name, id)) {\n        storage.setValue(radio.id, {\n          value: false\n        });\n      }\n      storage.setValue(id, {\n        value: checked\n      });\n    });\n    element.addEventListener(\"resetform\", event => {\n      const defaultValue = data.defaultFieldValue;\n      event.target.checked = defaultValue !== null && defaultValue !== undefined && defaultValue === data.buttonValue;\n    });\n    if (this.enableScripting && this.hasJSActions) {\n      const pdfButtonValue = data.buttonValue;\n      element.addEventListener(\"updatefromsandbox\", jsEvent => {\n        const actions = {\n          value: event => {\n            const checked = pdfButtonValue === event.detail.value;\n            for (const radio of this._getElementsByName(event.target.name)) {\n              const curChecked = checked && radio.id === id;\n              if (radio.domElement) {\n                radio.domElement.checked = curChecked;\n              }\n              storage.setValue(radio.id, {\n                value: curChecked\n              });\n            }\n          }\n        };\n        this._dispatchEventFromSandbox(actions, jsEvent);\n      });\n      this._setEventListeners(element, null, [[\"change\", \"Validate\"], [\"change\", \"Action\"], [\"focus\", \"Focus\"], [\"blur\", \"Blur\"], [\"mousedown\", \"Mouse Down\"], [\"mouseenter\", \"Mouse Enter\"], [\"mouseleave\", \"Mouse Exit\"], [\"mouseup\", \"Mouse Up\"]], event => event.target.checked);\n    }\n    this._setBackgroundColor(element);\n    this._setDefaultPropertiesFromJS(element);\n    this.container.append(element);\n    return this.container;\n  }\n}\nclass PushButtonWidgetAnnotationElement extends LinkAnnotationElement {\n  constructor(parameters) {\n    super(parameters, {\n      ignoreBorder: parameters.data.hasAppearance\n    });\n  }\n  render() {\n    const container = super.render();\n    container.classList.add(\"buttonWidgetAnnotation\", \"pushButton\");\n    if (this.data.alternativeText) {\n      container.title = this.data.alternativeText;\n    }\n    const linkElement = container.lastChild;\n    if (this.enableScripting && this.hasJSActions && linkElement) {\n      this._setDefaultPropertiesFromJS(linkElement);\n      linkElement.addEventListener(\"updatefromsandbox\", jsEvent => {\n        this._dispatchEventFromSandbox({}, jsEvent);\n      });\n    }\n    return container;\n  }\n}\nclass ChoiceWidgetAnnotationElement extends WidgetAnnotationElement {\n  constructor(parameters) {\n    super(parameters, {\n      isRenderable: parameters.renderForms\n    });\n  }\n  render() {\n    this.container.classList.add(\"choiceWidgetAnnotation\");\n    const storage = this.annotationStorage;\n    const id = this.data.id;\n    const storedData = storage.getValue(id, {\n      value: this.data.fieldValue\n    });\n    const selectElement = document.createElement(\"select\");\n    GetElementsByNameSet.add(selectElement);\n    selectElement.setAttribute(\"data-element-id\", id);\n    selectElement.disabled = this.data.readOnly;\n    this._setRequired(selectElement, this.data.required);\n    selectElement.name = this.data.fieldName;\n    selectElement.tabIndex = DEFAULT_TAB_INDEX;\n    let addAnEmptyEntry = this.data.combo && this.data.options.length > 0;\n    if (!this.data.combo) {\n      selectElement.size = this.data.options.length;\n      if (this.data.multiSelect) {\n        selectElement.multiple = true;\n      }\n    }\n    selectElement.addEventListener(\"resetform\", event => {\n      const defaultValue = this.data.defaultFieldValue;\n      for (const option of selectElement.options) {\n        option.selected = option.value === defaultValue;\n      }\n    });\n    for (const option of this.data.options) {\n      const optionElement = document.createElement(\"option\");\n      optionElement.textContent = option.displayValue;\n      optionElement.value = option.exportValue;\n      if (storedData.value.includes(option.exportValue)) {\n        optionElement.setAttribute(\"selected\", true);\n        addAnEmptyEntry = false;\n      }\n      selectElement.append(optionElement);\n    }\n    let removeEmptyEntry = null;\n    if (addAnEmptyEntry) {\n      const noneOptionElement = document.createElement(\"option\");\n      noneOptionElement.value = \" \";\n      noneOptionElement.setAttribute(\"hidden\", true);\n      noneOptionElement.setAttribute(\"selected\", true);\n      selectElement.prepend(noneOptionElement);\n      removeEmptyEntry = () => {\n        noneOptionElement.remove();\n        selectElement.removeEventListener(\"input\", removeEmptyEntry);\n        removeEmptyEntry = null;\n      };\n      selectElement.addEventListener(\"input\", removeEmptyEntry);\n    }\n    const getValue = isExport => {\n      const name = isExport ? \"value\" : \"textContent\";\n      const {\n        options,\n        multiple\n      } = selectElement;\n      if (!multiple) {\n        return options.selectedIndex === -1 ? null : options[options.selectedIndex][name];\n      }\n      return Array.prototype.filter.call(options, option => option.selected).map(option => option[name]);\n    };\n    let selectedValues = getValue(false);\n    const getItems = event => {\n      const options = event.target.options;\n      return Array.prototype.map.call(options, option => {\n        return {\n          displayValue: option.textContent,\n          exportValue: option.value\n        };\n      });\n    };\n    if (this.enableScripting && this.hasJSActions) {\n      selectElement.addEventListener(\"updatefromsandbox\", jsEvent => {\n        const actions = {\n          value(event) {\n            removeEmptyEntry?.();\n            const value = event.detail.value;\n            const values = new Set(Array.isArray(value) ? value : [value]);\n            for (const option of selectElement.options) {\n              option.selected = values.has(option.value);\n            }\n            storage.setValue(id, {\n              value: getValue(true)\n            });\n            selectedValues = getValue(false);\n          },\n          multipleSelection(event) {\n            selectElement.multiple = true;\n          },\n          remove(event) {\n            const options = selectElement.options;\n            const index = event.detail.remove;\n            options[index].selected = false;\n            selectElement.remove(index);\n            if (options.length > 0) {\n              const i = Array.prototype.findIndex.call(options, option => option.selected);\n              if (i === -1) {\n                options[0].selected = true;\n              }\n            }\n            storage.setValue(id, {\n              value: getValue(true),\n              items: getItems(event)\n            });\n            selectedValues = getValue(false);\n          },\n          clear(event) {\n            while (selectElement.length !== 0) {\n              selectElement.remove(0);\n            }\n            storage.setValue(id, {\n              value: null,\n              items: []\n            });\n            selectedValues = getValue(false);\n          },\n          insert(event) {\n            const {\n              index,\n              displayValue,\n              exportValue\n            } = event.detail.insert;\n            const selectChild = selectElement.children[index];\n            const optionElement = document.createElement(\"option\");\n            optionElement.textContent = displayValue;\n            optionElement.value = exportValue;\n            if (selectChild) {\n              selectChild.before(optionElement);\n            } else {\n              selectElement.append(optionElement);\n            }\n            storage.setValue(id, {\n              value: getValue(true),\n              items: getItems(event)\n            });\n            selectedValues = getValue(false);\n          },\n          items(event) {\n            const {\n              items\n            } = event.detail;\n            while (selectElement.length !== 0) {\n              selectElement.remove(0);\n            }\n            for (const item of items) {\n              const {\n                displayValue,\n                exportValue\n              } = item;\n              const optionElement = document.createElement(\"option\");\n              optionElement.textContent = displayValue;\n              optionElement.value = exportValue;\n              selectElement.append(optionElement);\n            }\n            if (selectElement.options.length > 0) {\n              selectElement.options[0].selected = true;\n            }\n            storage.setValue(id, {\n              value: getValue(true),\n              items: getItems(event)\n            });\n            selectedValues = getValue(false);\n          },\n          indices(event) {\n            const indices = new Set(event.detail.indices);\n            for (const option of event.target.options) {\n              option.selected = indices.has(option.index);\n            }\n            storage.setValue(id, {\n              value: getValue(true)\n            });\n            selectedValues = getValue(false);\n          },\n          editable(event) {\n            event.target.disabled = !event.detail.editable;\n          }\n        };\n        this._dispatchEventFromSandbox(actions, jsEvent);\n      });\n      selectElement.addEventListener(\"input\", event => {\n        const exportValue = getValue(true);\n        storage.setValue(id, {\n          value: exportValue\n        });\n        event.preventDefault();\n        this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n          source: this,\n          detail: {\n            id,\n            name: \"Keystroke\",\n            value: selectedValues,\n            changeEx: exportValue,\n            willCommit: false,\n            commitKey: 1,\n            keyDown: false\n          }\n        });\n      });\n      this._setEventListeners(selectElement, null, [[\"focus\", \"Focus\"], [\"blur\", \"Blur\"], [\"mousedown\", \"Mouse Down\"], [\"mouseenter\", \"Mouse Enter\"], [\"mouseleave\", \"Mouse Exit\"], [\"mouseup\", \"Mouse Up\"], [\"input\", \"Action\"], [\"input\", \"Validate\"]], event => event.target.value);\n    } else {\n      selectElement.addEventListener(\"input\", function (event) {\n        storage.setValue(id, {\n          value: getValue(true)\n        });\n      });\n    }\n    if (this.data.combo) {\n      this._setTextStyle(selectElement);\n    } else {}\n    this._setBackgroundColor(selectElement);\n    this._setDefaultPropertiesFromJS(selectElement);\n    this.container.append(selectElement);\n    return this.container;\n  }\n}\nclass PopupAnnotationElement extends AnnotationElement {\n  constructor(parameters) {\n    const {\n      data,\n      elements\n    } = parameters;\n    super(parameters, {\n      isRenderable: AnnotationElement._hasPopupData(data)\n    });\n    this.elements = elements;\n  }\n  render() {\n    this.container.classList.add(\"popupAnnotation\");\n    const popup = new PopupElement({\n      container: this.container,\n      color: this.data.color,\n      titleObj: this.data.titleObj,\n      modificationDate: this.data.modificationDate,\n      contentsObj: this.data.contentsObj,\n      richText: this.data.richText,\n      rect: this.data.rect,\n      parentRect: this.data.parentRect || null,\n      parent: this.parent,\n      elements: this.elements,\n      open: this.data.open\n    });\n    const elementIds = [];\n    for (const element of this.elements) {\n      element.popup = popup;\n      elementIds.push(element.data.id);\n      element.addHighlightArea();\n    }\n    this.container.setAttribute(\"aria-controls\", elementIds.map(id => `${_util.AnnotationPrefix}${id}`).join(\",\"));\n    return this.container;\n  }\n}\nclass PopupElement {\n  #dateTimePromise = null;\n  #boundKeyDown = this.#keyDown.bind(this);\n  #boundHide = this.#hide.bind(this);\n  #boundShow = this.#show.bind(this);\n  #boundToggle = this.#toggle.bind(this);\n  #color = null;\n  #container = null;\n  #contentsObj = null;\n  #elements = null;\n  #parent = null;\n  #parentRect = null;\n  #pinned = false;\n  #popup = null;\n  #rect = null;\n  #richText = null;\n  #titleObj = null;\n  #wasVisible = false;\n  constructor({\n    container,\n    color,\n    elements,\n    titleObj,\n    modificationDate,\n    contentsObj,\n    richText,\n    parent,\n    rect,\n    parentRect,\n    open\n  }) {\n    this.#container = container;\n    this.#titleObj = titleObj;\n    this.#contentsObj = contentsObj;\n    this.#richText = richText;\n    this.#parent = parent;\n    this.#color = color;\n    this.#rect = rect;\n    this.#parentRect = parentRect;\n    this.#elements = elements;\n    const dateObject = _display_utils.PDFDateString.toDateObject(modificationDate);\n    if (dateObject) {\n      this.#dateTimePromise = parent.l10n.get(\"annotation_date_string\", {\n        date: dateObject.toLocaleDateString(),\n        time: dateObject.toLocaleTimeString()\n      });\n    }\n    this.trigger = elements.flatMap(e => e.getElementsToTriggerPopup());\n    for (const element of this.trigger) {\n      element.addEventListener(\"click\", this.#boundToggle);\n      element.addEventListener(\"mouseenter\", this.#boundShow);\n      element.addEventListener(\"mouseleave\", this.#boundHide);\n      element.classList.add(\"popupTriggerArea\");\n    }\n    for (const element of elements) {\n      element.container?.addEventListener(\"keydown\", this.#boundKeyDown);\n    }\n    this.#container.hidden = true;\n    if (open) {\n      this.#toggle();\n    }\n  }\n  render() {\n    if (this.#popup) {\n      return;\n    }\n    const {\n      page: {\n        view\n      },\n      viewport: {\n        rawDims: {\n          pageWidth,\n          pageHeight,\n          pageX,\n          pageY\n        }\n      }\n    } = this.#parent;\n    const popup = this.#popup = document.createElement(\"div\");\n    popup.className = \"popup\";\n    if (this.#color) {\n      const baseColor = popup.style.outlineColor = _util.Util.makeHexColor(...this.#color);\n      if (CSS.supports(\"background-color\", \"color-mix(in srgb, red 30%, white)\")) {\n        popup.style.backgroundColor = `color-mix(in srgb, ${baseColor} 30%, white)`;\n      } else {\n        const BACKGROUND_ENLIGHT = 0.7;\n        popup.style.backgroundColor = _util.Util.makeHexColor(...this.#color.map(c => Math.floor(BACKGROUND_ENLIGHT * (255 - c) + c)));\n      }\n    }\n    const header = document.createElement(\"span\");\n    header.className = \"header\";\n    const title = document.createElement(\"h1\");\n    header.append(title);\n    ({\n      dir: title.dir,\n      str: title.textContent\n    } = this.#titleObj);\n    popup.append(header);\n    if (this.#dateTimePromise) {\n      const modificationDate = document.createElement(\"span\");\n      modificationDate.classList.add(\"popupDate\");\n      this.#dateTimePromise.then(localized => {\n        modificationDate.textContent = localized;\n      });\n      header.append(modificationDate);\n    }\n    const contentsObj = this.#contentsObj;\n    const richText = this.#richText;\n    if (richText?.str && (!contentsObj?.str || contentsObj.str === richText.str)) {\n      _xfa_layer.XfaLayer.render({\n        xfaHtml: richText.html,\n        intent: \"richText\",\n        div: popup\n      });\n      popup.lastChild.classList.add(\"richText\", \"popupContent\");\n    } else {\n      const contents = this._formatContents(contentsObj);\n      popup.append(contents);\n    }\n    let useParentRect = !!this.#parentRect;\n    let rect = useParentRect ? this.#parentRect : this.#rect;\n    for (const element of this.#elements) {\n      if (!rect || _util.Util.intersect(element.data.rect, rect) !== null) {\n        rect = element.data.rect;\n        useParentRect = true;\n        break;\n      }\n    }\n    const normalizedRect = _util.Util.normalizeRect([rect[0], view[3] - rect[1] + view[1], rect[2], view[3] - rect[3] + view[1]]);\n    const HORIZONTAL_SPACE_AFTER_ANNOTATION = 5;\n    const parentWidth = useParentRect ? rect[2] - rect[0] + HORIZONTAL_SPACE_AFTER_ANNOTATION : 0;\n    const popupLeft = normalizedRect[0] + parentWidth;\n    const popupTop = normalizedRect[1];\n    const {\n      style\n    } = this.#container;\n    style.left = `${100 * (popupLeft - pageX) / pageWidth}%`;\n    style.top = `${100 * (popupTop - pageY) / pageHeight}%`;\n    this.#container.append(popup);\n  }\n  _formatContents({\n    str,\n    dir\n  }) {\n    const p = document.createElement(\"p\");\n    p.classList.add(\"popupContent\");\n    p.dir = dir;\n    const lines = str.split(/(?:\\r\\n?|\\n)/);\n    for (let i = 0, ii = lines.length; i < ii; ++i) {\n      const line = lines[i];\n      p.append(document.createTextNode(line));\n      if (i < ii - 1) {\n        p.append(document.createElement(\"br\"));\n      }\n    }\n    return p;\n  }\n  #keyDown(event) {\n    if (event.altKey || event.shiftKey || event.ctrlKey || event.metaKey) {\n      return;\n    }\n    if (event.key === \"Enter\" || event.key === \"Escape\" && this.#pinned) {\n      this.#toggle();\n    }\n  }\n  #toggle() {\n    this.#pinned = !this.#pinned;\n    if (this.#pinned) {\n      this.#show();\n      this.#container.addEventListener(\"click\", this.#boundToggle);\n      this.#container.addEventListener(\"keydown\", this.#boundKeyDown);\n    } else {\n      this.#hide();\n      this.#container.removeEventListener(\"click\", this.#boundToggle);\n      this.#container.removeEventListener(\"keydown\", this.#boundKeyDown);\n    }\n  }\n  #show() {\n    if (!this.#popup) {\n      this.render();\n    }\n    if (!this.isVisible) {\n      this.#container.hidden = false;\n      this.#container.style.zIndex = parseInt(this.#container.style.zIndex) + 1000;\n    } else if (this.#pinned) {\n      this.#container.classList.add(\"focused\");\n    }\n  }\n  #hide() {\n    this.#container.classList.remove(\"focused\");\n    if (this.#pinned || !this.isVisible) {\n      return;\n    }\n    this.#container.hidden = true;\n    this.#container.style.zIndex = parseInt(this.#container.style.zIndex) - 1000;\n  }\n  forceHide() {\n    this.#wasVisible = this.isVisible;\n    if (!this.#wasVisible) {\n      return;\n    }\n    this.#container.hidden = true;\n  }\n  maybeShow() {\n    if (!this.#wasVisible) {\n      return;\n    }\n    this.#wasVisible = false;\n    this.#container.hidden = false;\n  }\n  get isVisible() {\n    return this.#container.hidden === false;\n  }\n}\nclass FreeTextAnnotationElement extends AnnotationElement {\n  constructor(parameters) {\n    super(parameters, {\n      isRenderable: true,\n      ignoreBorder: true\n    });\n    this.textContent = parameters.data.textContent;\n    this.textPosition = parameters.data.textPosition;\n    this.annotationEditorType = _util.AnnotationEditorType.FREETEXT;\n  }\n  render() {\n    this.container.classList.add(\"freeTextAnnotation\");\n    if (this.textContent) {\n      const content = document.createElement(\"div\");\n      content.classList.add(\"annotationTextContent\");\n      content.setAttribute(\"role\", \"comment\");\n      for (const line of this.textContent) {\n        const lineSpan = document.createElement(\"span\");\n        lineSpan.textContent = line;\n        content.append(lineSpan);\n      }\n      this.container.append(content);\n    }\n    if (!this.data.popupRef && this.hasPopupData) {\n      this._createPopup();\n    }\n    this._editOnDoubleClick();\n    return this.container;\n  }\n}\nexports.FreeTextAnnotationElement = FreeTextAnnotationElement;\nclass LineAnnotationElement extends AnnotationElement {\n  #line = null;\n  constructor(parameters) {\n    super(parameters, {\n      isRenderable: true,\n      ignoreBorder: true\n    });\n  }\n  render() {\n    this.container.classList.add(\"lineAnnotation\");\n    const data = this.data;\n    const {\n      width,\n      height\n    } = getRectDims(data.rect);\n    const svg = this.svgFactory.create(width, height, true);\n    const line = this.#line = this.svgFactory.createElement(\"svg:line\");\n    line.setAttribute(\"x1\", data.rect[2] - data.lineCoordinates[0]);\n    line.setAttribute(\"y1\", data.rect[3] - data.lineCoordinates[1]);\n    line.setAttribute(\"x2\", data.rect[2] - data.lineCoordinates[2]);\n    line.setAttribute(\"y2\", data.rect[3] - data.lineCoordinates[3]);\n    line.setAttribute(\"stroke-width\", data.borderStyle.width || 1);\n    line.setAttribute(\"stroke\", \"transparent\");\n    line.setAttribute(\"fill\", \"transparent\");\n    svg.append(line);\n    this.container.append(svg);\n    if (!data.popupRef && this.hasPopupData) {\n      this._createPopup();\n    }\n    return this.container;\n  }\n  getElementsToTriggerPopup() {\n    return this.#line;\n  }\n  addHighlightArea() {\n    this.container.classList.add(\"highlightArea\");\n  }\n}\nclass SquareAnnotationElement extends AnnotationElement {\n  #square = null;\n  constructor(parameters) {\n    super(parameters, {\n      isRenderable: true,\n      ignoreBorder: true\n    });\n  }\n  render() {\n    this.container.classList.add(\"squareAnnotation\");\n    const data = this.data;\n    const {\n      width,\n      height\n    } = getRectDims(data.rect);\n    const svg = this.svgFactory.create(width, height, true);\n    const borderWidth = data.borderStyle.width;\n    const square = this.#square = this.svgFactory.createElement(\"svg:rect\");\n    square.setAttribute(\"x\", borderWidth / 2);\n    square.setAttribute(\"y\", borderWidth / 2);\n    square.setAttribute(\"width\", width - borderWidth);\n    square.setAttribute(\"height\", height - borderWidth);\n    square.setAttribute(\"stroke-width\", borderWidth || 1);\n    square.setAttribute(\"stroke\", \"transparent\");\n    square.setAttribute(\"fill\", \"transparent\");\n    svg.append(square);\n    this.container.append(svg);\n    if (!data.popupRef && this.hasPopupData) {\n      this._createPopup();\n    }\n    return this.container;\n  }\n  getElementsToTriggerPopup() {\n    return this.#square;\n  }\n  addHighlightArea() {\n    this.container.classList.add(\"highlightArea\");\n  }\n}\nclass CircleAnnotationElement extends AnnotationElement {\n  #circle = null;\n  constructor(parameters) {\n    super(parameters, {\n      isRenderable: true,\n      ignoreBorder: true\n    });\n  }\n  render() {\n    this.container.classList.add(\"circleAnnotation\");\n    const data = this.data;\n    const {\n      width,\n      height\n    } = getRectDims(data.rect);\n    const svg = this.svgFactory.create(width, height, true);\n    const borderWidth = data.borderStyle.width;\n    const circle = this.#circle = this.svgFactory.createElement(\"svg:ellipse\");\n    circle.setAttribute(\"cx\", width / 2);\n    circle.setAttribute(\"cy\", height / 2);\n    circle.setAttribute(\"rx\", width / 2 - borderWidth / 2);\n    circle.setAttribute(\"ry\", height / 2 - borderWidth / 2);\n    circle.setAttribute(\"stroke-width\", borderWidth || 1);\n    circle.setAttribute(\"stroke\", \"transparent\");\n    circle.setAttribute(\"fill\", \"transparent\");\n    svg.append(circle);\n    this.container.append(svg);\n    if (!data.popupRef && this.hasPopupData) {\n      this._createPopup();\n    }\n    return this.container;\n  }\n  getElementsToTriggerPopup() {\n    return this.#circle;\n  }\n  addHighlightArea() {\n    this.container.classList.add(\"highlightArea\");\n  }\n}\nclass PolylineAnnotationElement extends AnnotationElement {\n  #polyline = null;\n  constructor(parameters) {\n    super(parameters, {\n      isRenderable: true,\n      ignoreBorder: true\n    });\n    this.containerClassName = \"polylineAnnotation\";\n    this.svgElementName = \"svg:polyline\";\n  }\n  render() {\n    this.container.classList.add(this.containerClassName);\n    const data = this.data;\n    const {\n      width,\n      height\n    } = getRectDims(data.rect);\n    const svg = this.svgFactory.create(width, height, true);\n    let points = [];\n    for (const coordinate of data.vertices) {\n      const x = coordinate.x - data.rect[0];\n      const y = data.rect[3] - coordinate.y;\n      points.push(x + \",\" + y);\n    }\n    points = points.join(\" \");\n    const polyline = this.#polyline = this.svgFactory.createElement(this.svgElementName);\n    polyline.setAttribute(\"points\", points);\n    polyline.setAttribute(\"stroke-width\", data.borderStyle.width || 1);\n    polyline.setAttribute(\"stroke\", \"transparent\");\n    polyline.setAttribute(\"fill\", \"transparent\");\n    svg.append(polyline);\n    this.container.append(svg);\n    if (!data.popupRef && this.hasPopupData) {\n      this._createPopup();\n    }\n    return this.container;\n  }\n  getElementsToTriggerPopup() {\n    return this.#polyline;\n  }\n  addHighlightArea() {\n    this.container.classList.add(\"highlightArea\");\n  }\n}\nclass PolygonAnnotationElement extends PolylineAnnotationElement {\n  constructor(parameters) {\n    super(parameters);\n    this.containerClassName = \"polygonAnnotation\";\n    this.svgElementName = \"svg:polygon\";\n  }\n}\nclass CaretAnnotationElement extends AnnotationElement {\n  constructor(parameters) {\n    super(parameters, {\n      isRenderable: true,\n      ignoreBorder: true\n    });\n  }\n  render() {\n    this.container.classList.add(\"caretAnnotation\");\n    if (!this.data.popupRef && this.hasPopupData) {\n      this._createPopup();\n    }\n    return this.container;\n  }\n}\nclass InkAnnotationElement extends AnnotationElement {\n  #polylines = [];\n  constructor(parameters) {\n    super(parameters, {\n      isRenderable: true,\n      ignoreBorder: true\n    });\n    this.containerClassName = \"inkAnnotation\";\n    this.svgElementName = \"svg:polyline\";\n    this.annotationEditorType = _util.AnnotationEditorType.INK;\n  }\n  render() {\n    this.container.classList.add(this.containerClassName);\n    const data = this.data;\n    const {\n      width,\n      height\n    } = getRectDims(data.rect);\n    const svg = this.svgFactory.create(width, height, true);\n    for (const inkList of data.inkLists) {\n      let points = [];\n      for (const coordinate of inkList) {\n        const x = coordinate.x - data.rect[0];\n        const y = data.rect[3] - coordinate.y;\n        points.push(`${x},${y}`);\n      }\n      points = points.join(\" \");\n      const polyline = this.svgFactory.createElement(this.svgElementName);\n      this.#polylines.push(polyline);\n      polyline.setAttribute(\"points\", points);\n      polyline.setAttribute(\"stroke-width\", data.borderStyle.width || 1);\n      polyline.setAttribute(\"stroke\", \"transparent\");\n      polyline.setAttribute(\"fill\", \"transparent\");\n      if (!data.popupRef && this.hasPopupData) {\n        this._createPopup();\n      }\n      svg.append(polyline);\n    }\n    this.container.append(svg);\n    return this.container;\n  }\n  getElementsToTriggerPopup() {\n    return this.#polylines;\n  }\n  addHighlightArea() {\n    this.container.classList.add(\"highlightArea\");\n  }\n}\nexports.InkAnnotationElement = InkAnnotationElement;\nclass HighlightAnnotationElement extends AnnotationElement {\n  constructor(parameters) {\n    super(parameters, {\n      isRenderable: true,\n      ignoreBorder: true,\n      createQuadrilaterals: true\n    });\n  }\n  render() {\n    if (!this.data.popupRef && this.hasPopupData) {\n      this._createPopup();\n    }\n    this.container.classList.add(\"highlightAnnotation\");\n    return this.container;\n  }\n}\nclass UnderlineAnnotationElement extends AnnotationElement {\n  constructor(parameters) {\n    super(parameters, {\n      isRenderable: true,\n      ignoreBorder: true,\n      createQuadrilaterals: true\n    });\n  }\n  render() {\n    if (!this.data.popupRef && this.hasPopupData) {\n      this._createPopup();\n    }\n    this.container.classList.add(\"underlineAnnotation\");\n    return this.container;\n  }\n}\nclass SquigglyAnnotationElement extends AnnotationElement {\n  constructor(parameters) {\n    super(parameters, {\n      isRenderable: true,\n      ignoreBorder: true,\n      createQuadrilaterals: true\n    });\n  }\n  render() {\n    if (!this.data.popupRef && this.hasPopupData) {\n      this._createPopup();\n    }\n    this.container.classList.add(\"squigglyAnnotation\");\n    return this.container;\n  }\n}\nclass StrikeOutAnnotationElement extends AnnotationElement {\n  constructor(parameters) {\n    super(parameters, {\n      isRenderable: true,\n      ignoreBorder: true,\n      createQuadrilaterals: true\n    });\n  }\n  render() {\n    if (!this.data.popupRef && this.hasPopupData) {\n      this._createPopup();\n    }\n    this.container.classList.add(\"strikeoutAnnotation\");\n    return this.container;\n  }\n}\nclass StampAnnotationElement extends AnnotationElement {\n  constructor(parameters) {\n    super(parameters, {\n      isRenderable: true,\n      ignoreBorder: true\n    });\n  }\n  render() {\n    this.container.classList.add(\"stampAnnotation\");\n    if (!this.data.popupRef && this.hasPopupData) {\n      this._createPopup();\n    }\n    return this.container;\n  }\n}\nexports.StampAnnotationElement = StampAnnotationElement;\nclass FileAttachmentAnnotationElement extends AnnotationElement {\n  #trigger = null;\n  constructor(parameters) {\n    super(parameters, {\n      isRenderable: true\n    });\n    const {\n      filename,\n      content\n    } = this.data.file;\n    this.filename = (0, _display_utils.getFilenameFromUrl)(filename, true);\n    this.content = content;\n    this.linkService.eventBus?.dispatch(\"fileattachmentannotation\", {\n      source: this,\n      filename,\n      content\n    });\n  }\n  render() {\n    this.container.classList.add(\"fileAttachmentAnnotation\");\n    const {\n      container,\n      data\n    } = this;\n    let trigger;\n    if (data.hasAppearance || data.fillAlpha === 0) {\n      trigger = document.createElement(\"div\");\n    } else {\n      trigger = document.createElement(\"img\");\n      trigger.src = `${this.imageResourcesPath}annotation-${/paperclip/i.test(data.name) ? \"paperclip\" : \"pushpin\"}.svg`;\n      if (data.fillAlpha && data.fillAlpha < 1) {\n        trigger.style = `filter: opacity(${Math.round(data.fillAlpha * 100)}%);`;\n      }\n    }\n    trigger.addEventListener(\"dblclick\", this.#download.bind(this));\n    this.#trigger = trigger;\n    const {\n      isMac\n    } = _util.FeatureTest.platform;\n    container.addEventListener(\"keydown\", evt => {\n      if (evt.key === \"Enter\" && (isMac ? evt.metaKey : evt.ctrlKey)) {\n        this.#download();\n      }\n    });\n    if (!data.popupRef && this.hasPopupData) {\n      this._createPopup();\n    } else {\n      trigger.classList.add(\"popupTriggerArea\");\n    }\n    container.append(trigger);\n    return container;\n  }\n  getElementsToTriggerPopup() {\n    return this.#trigger;\n  }\n  addHighlightArea() {\n    this.container.classList.add(\"highlightArea\");\n  }\n  #download() {\n    this.downloadManager?.openOrDownloadData(this.container, this.content, this.filename);\n  }\n}\nclass AnnotationLayer {\n  #accessibilityManager = null;\n  #annotationCanvasMap = null;\n  #editableAnnotations = new Map();\n  constructor({\n    div,\n    accessibilityManager,\n    annotationCanvasMap,\n    l10n,\n    page,\n    viewport\n  }) {\n    this.div = div;\n    this.#accessibilityManager = accessibilityManager;\n    this.#annotationCanvasMap = annotationCanvasMap;\n    this.l10n = l10n;\n    this.page = page;\n    this.viewport = viewport;\n    this.zIndex = 0;\n    this.l10n ||= _displayL10n_utils.NullL10n;\n  }\n  #appendElement(element, id) {\n    const contentElement = element.firstChild || element;\n    contentElement.id = `${_util.AnnotationPrefix}${id}`;\n    this.div.append(element);\n    this.#accessibilityManager?.moveElementInDOM(this.div, element, contentElement, false);\n  }\n  async render(params) {\n    const {\n      annotations\n    } = params;\n    const layer = this.div;\n    (0, _display_utils.setLayerDimensions)(layer, this.viewport);\n    const popupToElements = new Map();\n    const elementParams = {\n      data: null,\n      layer,\n      linkService: params.linkService,\n      downloadManager: params.downloadManager,\n      imageResourcesPath: params.imageResourcesPath || \"\",\n      renderForms: params.renderForms !== false,\n      svgFactory: new _display_utils.DOMSVGFactory(),\n      annotationStorage: params.annotationStorage || new _annotation_storage.AnnotationStorage(),\n      enableScripting: params.enableScripting === true,\n      hasJSActions: params.hasJSActions,\n      fieldObjects: params.fieldObjects,\n      parent: this,\n      elements: null\n    };\n    for (const data of annotations) {\n      if (data.noHTML) {\n        continue;\n      }\n      const isPopupAnnotation = data.annotationType === _util.AnnotationType.POPUP;\n      if (!isPopupAnnotation) {\n        const {\n          width,\n          height\n        } = getRectDims(data.rect);\n        if (width <= 0 || height <= 0) {\n          continue;\n        }\n      } else {\n        const elements = popupToElements.get(data.id);\n        if (!elements) {\n          continue;\n        }\n        elementParams.elements = elements;\n      }\n      elementParams.data = data;\n      const element = AnnotationElementFactory.create(elementParams);\n      if (!element.isRenderable) {\n        continue;\n      }\n      if (!isPopupAnnotation && data.popupRef) {\n        const elements = popupToElements.get(data.popupRef);\n        if (!elements) {\n          popupToElements.set(data.popupRef, [element]);\n        } else {\n          elements.push(element);\n        }\n      }\n      if (element.annotationEditorType > 0) {\n        this.#editableAnnotations.set(element.data.id, element);\n      }\n      const rendered = element.render();\n      if (data.hidden) {\n        rendered.style.visibility = \"hidden\";\n      }\n      this.#appendElement(rendered, data.id);\n    }\n    this.#setAnnotationCanvasMap();\n    await this.l10n.translate(layer);\n  }\n  update({\n    viewport\n  }) {\n    const layer = this.div;\n    this.viewport = viewport;\n    (0, _display_utils.setLayerDimensions)(layer, {\n      rotation: viewport.rotation\n    });\n    this.#setAnnotationCanvasMap();\n    layer.hidden = false;\n  }\n  #setAnnotationCanvasMap() {\n    if (!this.#annotationCanvasMap) {\n      return;\n    }\n    const layer = this.div;\n    for (const [id, canvas] of this.#annotationCanvasMap) {\n      const element = layer.querySelector(`[data-annotation-id=\"${id}\"]`);\n      if (!element) {\n        continue;\n      }\n      const {\n        firstChild\n      } = element;\n      if (!firstChild) {\n        element.append(canvas);\n      } else if (firstChild.nodeName === \"CANVAS\") {\n        firstChild.replaceWith(canvas);\n      } else {\n        firstChild.before(canvas);\n      }\n    }\n    this.#annotationCanvasMap.clear();\n  }\n  getEditableAnnotations() {\n    return Array.from(this.#editableAnnotations.values());\n  }\n  getEditableAnnotation(id) {\n    return this.#editableAnnotations.get(id);\n  }\n}\nexports.AnnotationLayer = AnnotationLayer;\n\n/***/ }),\n/* 30 */\n/***/ ((__unused_webpack_module, exports) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.ColorConverters = void 0;\nfunction makeColorComp(n) {\n  return Math.floor(Math.max(0, Math.min(1, n)) * 255).toString(16).padStart(2, \"0\");\n}\nfunction scaleAndClamp(x) {\n  return Math.max(0, Math.min(255, 255 * x));\n}\nclass ColorConverters {\n  static CMYK_G([c, y, m, k]) {\n    return [\"G\", 1 - Math.min(1, 0.3 * c + 0.59 * m + 0.11 * y + k)];\n  }\n  static G_CMYK([g]) {\n    return [\"CMYK\", 0, 0, 0, 1 - g];\n  }\n  static G_RGB([g]) {\n    return [\"RGB\", g, g, g];\n  }\n  static G_rgb([g]) {\n    g = scaleAndClamp(g);\n    return [g, g, g];\n  }\n  static G_HTML([g]) {\n    const G = makeColorComp(g);\n    return `#${G}${G}${G}`;\n  }\n  static RGB_G([r, g, b]) {\n    return [\"G\", 0.3 * r + 0.59 * g + 0.11 * b];\n  }\n  static RGB_rgb(color) {\n    return color.map(scaleAndClamp);\n  }\n  static RGB_HTML(color) {\n    return `#${color.map(makeColorComp).join(\"\")}`;\n  }\n  static T_HTML() {\n    return \"#00000000\";\n  }\n  static T_rgb() {\n    return [null];\n  }\n  static CMYK_RGB([c, y, m, k]) {\n    return [\"RGB\", 1 - Math.min(1, c + k), 1 - Math.min(1, m + k), 1 - Math.min(1, y + k)];\n  }\n  static CMYK_rgb([c, y, m, k]) {\n    return [scaleAndClamp(1 - Math.min(1, c + k)), scaleAndClamp(1 - Math.min(1, m + k)), scaleAndClamp(1 - Math.min(1, y + k))];\n  }\n  static CMYK_HTML(components) {\n    const rgb = this.CMYK_RGB(components).slice(1);\n    return this.RGB_HTML(rgb);\n  }\n  static RGB_CMYK([r, g, b]) {\n    const c = 1 - r;\n    const m = 1 - g;\n    const y = 1 - b;\n    const k = Math.min(c, m, y);\n    return [\"CMYK\", c, m, y, k];\n  }\n}\nexports.ColorConverters = ColorConverters;\n\n/***/ }),\n/* 31 */\n/***/ ((__unused_webpack_module, exports) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.NullL10n = void 0;\nexports.getL10nFallback = getL10nFallback;\nconst DEFAULT_L10N_STRINGS = {\n  of_pages: \"of {{pagesCount}}\",\n  page_of_pages: \"({{pageNumber}} of {{pagesCount}})\",\n  document_properties_kb: \"{{size_kb}} KB ({{size_b}} bytes)\",\n  document_properties_mb: \"{{size_mb}} MB ({{size_b}} bytes)\",\n  document_properties_date_string: \"{{date}}, {{time}}\",\n  document_properties_page_size_unit_inches: \"in\",\n  document_properties_page_size_unit_millimeters: \"mm\",\n  document_properties_page_size_orientation_portrait: \"portrait\",\n  document_properties_page_size_orientation_landscape: \"landscape\",\n  document_properties_page_size_name_a3: \"A3\",\n  document_properties_page_size_name_a4: \"A4\",\n  document_properties_page_size_name_letter: \"Letter\",\n  document_properties_page_size_name_legal: \"Legal\",\n  document_properties_page_size_dimension_string: \"{{width}}  {{height}} {{unit}} ({{orientation}})\",\n  document_properties_page_size_dimension_name_string: \"{{width}}  {{height}} {{unit}} ({{name}}, {{orientation}})\",\n  document_properties_linearized_yes: \"Yes\",\n  document_properties_linearized_no: \"No\",\n  additional_layers: \"Additional Layers\",\n  page_landmark: \"Page {{page}}\",\n  thumb_page_title: \"Page {{page}}\",\n  thumb_page_canvas: \"Thumbnail of Page {{page}}\",\n  find_reached_top: \"Reached top of document, continued from bottom\",\n  find_reached_bottom: \"Reached end of document, continued from top\",\n  \"find_match_count[one]\": \"{{current}} of {{total}} match\",\n  \"find_match_count[other]\": \"{{current}} of {{total}} matches\",\n  \"find_match_count_limit[one]\": \"More than {{limit}} match\",\n  \"find_match_count_limit[other]\": \"More than {{limit}} matches\",\n  find_not_found: \"Phrase not found\",\n  page_scale_width: \"Page Width\",\n  page_scale_fit: \"Page Fit\",\n  page_scale_auto: \"Automatic Zoom\",\n  page_scale_actual: \"Actual Size\",\n  page_scale_percent: \"{{scale}}%\",\n  loading_error: \"An error occurred while loading the PDF.\",\n  invalid_file_error: \"Invalid or corrupted PDF file.\",\n  missing_file_error: \"Missing PDF file.\",\n  unexpected_response_error: \"Unexpected server response.\",\n  rendering_error: \"An error occurred while rendering the page.\",\n  annotation_date_string: \"{{date}}, {{time}}\",\n  printing_not_supported: \"Warning: Printing is not fully supported by this browser.\",\n  printing_not_ready: \"Warning: The PDF is not fully loaded for printing.\",\n  web_fonts_disabled: \"Web fonts are disabled: unable to use embedded PDF fonts.\",\n  free_text2_default_content: \"Start typing\",\n  editor_free_text2_aria_label: \"Text Editor\",\n  editor_ink2_aria_label: \"Draw Editor\",\n  editor_ink_canvas_aria_label: \"User-created image\",\n  editor_alt_text_button_label: \"Alt text\",\n  editor_alt_text_edit_button_label: \"Edit alt text\",\n  editor_alt_text_decorative_tooltip: \"Marked as decorative\"\n};\n{\n  DEFAULT_L10N_STRINGS.print_progress_percent = \"{{progress}}%\";\n}\nfunction getL10nFallback(key, args) {\n  switch (key) {\n    case \"find_match_count\":\n      key = `find_match_count[${args.total === 1 ? \"one\" : \"other\"}]`;\n      break;\n    case \"find_match_count_limit\":\n      key = `find_match_count_limit[${args.limit === 1 ? \"one\" : \"other\"}]`;\n      break;\n  }\n  return DEFAULT_L10N_STRINGS[key] || \"\";\n}\nfunction formatL10nValue(text, args) {\n  if (!args) {\n    return text;\n  }\n  return text.replaceAll(/\\{\\{\\s*(\\w+)\\s*\\}\\}/g, (all, name) => {\n    return name in args ? args[name] : \"{{\" + name + \"}}\";\n  });\n}\nconst NullL10n = {\n  async getLanguage() {\n    return \"en-us\";\n  },\n  async getDirection() {\n    return \"ltr\";\n  },\n  async get(key, args = null, fallback = getL10nFallback(key, args)) {\n    return formatL10nValue(fallback, args);\n  },\n  async translate(element) {}\n};\nexports.NullL10n = NullL10n;\n\n/***/ }),\n/* 32 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.XfaLayer = void 0;\nvar _xfa_text = __w_pdfjs_require__(25);\nclass XfaLayer {\n  static setupStorage(html, id, element, storage, intent) {\n    const storedData = storage.getValue(id, {\n      value: null\n    });\n    switch (element.name) {\n      case \"textarea\":\n        if (storedData.value !== null) {\n          html.textContent = storedData.value;\n        }\n        if (intent === \"print\") {\n          break;\n        }\n        html.addEventListener(\"input\", event => {\n          storage.setValue(id, {\n            value: event.target.value\n          });\n        });\n        break;\n      case \"input\":\n        if (element.attributes.type === \"radio\" || element.attributes.type === \"checkbox\") {\n          if (storedData.value === element.attributes.xfaOn) {\n            html.setAttribute(\"checked\", true);\n          } else if (storedData.value === element.attributes.xfaOff) {\n            html.removeAttribute(\"checked\");\n          }\n          if (intent === \"print\") {\n            break;\n          }\n          html.addEventListener(\"change\", event => {\n            storage.setValue(id, {\n              value: event.target.checked ? event.target.getAttribute(\"xfaOn\") : event.target.getAttribute(\"xfaOff\")\n            });\n          });\n        } else {\n          if (storedData.value !== null) {\n            html.setAttribute(\"value\", storedData.value);\n          }\n          if (intent === \"print\") {\n            break;\n          }\n          html.addEventListener(\"input\", event => {\n            storage.setValue(id, {\n              value: event.target.value\n            });\n          });\n        }\n        break;\n      case \"select\":\n        if (storedData.value !== null) {\n          html.setAttribute(\"value\", storedData.value);\n          for (const option of element.children) {\n            if (option.attributes.value === storedData.value) {\n              option.attributes.selected = true;\n            } else if (option.attributes.hasOwnProperty(\"selected\")) {\n              delete option.attributes.selected;\n            }\n          }\n        }\n        html.addEventListener(\"input\", event => {\n          const options = event.target.options;\n          const value = options.selectedIndex === -1 ? \"\" : options[options.selectedIndex].value;\n          storage.setValue(id, {\n            value\n          });\n        });\n        break;\n    }\n  }\n  static setAttributes({\n    html,\n    element,\n    storage = null,\n    intent,\n    linkService\n  }) {\n    const {\n      attributes\n    } = element;\n    const isHTMLAnchorElement = html instanceof HTMLAnchorElement;\n    if (attributes.type === \"radio\") {\n      attributes.name = `${attributes.name}-${intent}`;\n    }\n    for (const [key, value] of Object.entries(attributes)) {\n      if (value === null || value === undefined) {\n        continue;\n      }\n      switch (key) {\n        case \"class\":\n          if (value.length) {\n            html.setAttribute(key, value.join(\" \"));\n          }\n          break;\n        case \"dataId\":\n          break;\n        case \"id\":\n          html.setAttribute(\"data-element-id\", value);\n          break;\n        case \"style\":\n          Object.assign(html.style, value);\n          break;\n        case \"textContent\":\n          html.textContent = value;\n          break;\n        default:\n          if (!isHTMLAnchorElement || key !== \"href\" && key !== \"newWindow\") {\n            html.setAttribute(key, value);\n          }\n      }\n    }\n    if (isHTMLAnchorElement) {\n      linkService.addLinkAttributes(html, attributes.href, attributes.newWindow);\n    }\n    if (storage && attributes.dataId) {\n      this.setupStorage(html, attributes.dataId, element, storage);\n    }\n  }\n  static render(parameters) {\n    const storage = parameters.annotationStorage;\n    const linkService = parameters.linkService;\n    const root = parameters.xfaHtml;\n    const intent = parameters.intent || \"display\";\n    const rootHtml = document.createElement(root.name);\n    if (root.attributes) {\n      this.setAttributes({\n        html: rootHtml,\n        element: root,\n        intent,\n        linkService\n      });\n    }\n    const stack = [[root, -1, rootHtml]];\n    const rootDiv = parameters.div;\n    rootDiv.append(rootHtml);\n    if (parameters.viewport) {\n      const transform = `matrix(${parameters.viewport.transform.join(\",\")})`;\n      rootDiv.style.transform = transform;\n    }\n    if (intent !== \"richText\") {\n      rootDiv.setAttribute(\"class\", \"xfaLayer xfaFont\");\n    }\n    const textDivs = [];\n    while (stack.length > 0) {\n      const [parent, i, html] = stack.at(-1);\n      if (i + 1 === parent.children.length) {\n        stack.pop();\n        continue;\n      }\n      const child = parent.children[++stack.at(-1)[1]];\n      if (child === null) {\n        continue;\n      }\n      const {\n        name\n      } = child;\n      if (name === \"#text\") {\n        const node = document.createTextNode(child.value);\n        textDivs.push(node);\n        html.append(node);\n        continue;\n      }\n      const childHtml = child?.attributes?.xmlns ? document.createElementNS(child.attributes.xmlns, name) : document.createElement(name);\n      html.append(childHtml);\n      if (child.attributes) {\n        this.setAttributes({\n          html: childHtml,\n          element: child,\n          storage,\n          intent,\n          linkService\n        });\n      }\n      if (child.children && child.children.length > 0) {\n        stack.push([child, -1, childHtml]);\n      } else if (child.value) {\n        const node = document.createTextNode(child.value);\n        if (_xfa_text.XfaText.shouldBuildText(name)) {\n          textDivs.push(node);\n        }\n        childHtml.append(node);\n      }\n    }\n    for (const el of rootDiv.querySelectorAll(\".xfaNonInteractive input, .xfaNonInteractive textarea\")) {\n      el.setAttribute(\"readOnly\", true);\n    }\n    return {\n      textDivs\n    };\n  }\n  static update(parameters) {\n    const transform = `matrix(${parameters.viewport.transform.join(\",\")})`;\n    parameters.div.style.transform = transform;\n    parameters.div.hidden = false;\n  }\n}\nexports.XfaLayer = XfaLayer;\n\n/***/ }),\n/* 33 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.InkEditor = void 0;\nvar _util = __w_pdfjs_require__(1);\nvar _editor = __w_pdfjs_require__(4);\nvar _annotation_layer = __w_pdfjs_require__(29);\nvar _display_utils = __w_pdfjs_require__(6);\nvar _tools = __w_pdfjs_require__(5);\nclass InkEditor extends _editor.AnnotationEditor {\n  #baseHeight = 0;\n  #baseWidth = 0;\n  #boundCanvasPointermove = this.canvasPointermove.bind(this);\n  #boundCanvasPointerleave = this.canvasPointerleave.bind(this);\n  #boundCanvasPointerup = this.canvasPointerup.bind(this);\n  #boundCanvasPointerdown = this.canvasPointerdown.bind(this);\n  #currentPath2D = new Path2D();\n  #disableEditing = false;\n  #hasSomethingToDraw = false;\n  #isCanvasInitialized = false;\n  #observer = null;\n  #realWidth = 0;\n  #realHeight = 0;\n  #requestFrameCallback = null;\n  static _defaultColor = null;\n  static _defaultOpacity = 1;\n  static _defaultThickness = 1;\n  static _type = \"ink\";\n  constructor(params) {\n    super({\n      ...params,\n      name: \"inkEditor\"\n    });\n    this.color = params.color || null;\n    this.thickness = params.thickness || null;\n    this.opacity = params.opacity || null;\n    this.paths = [];\n    this.bezierPath2D = [];\n    this.allRawPaths = [];\n    this.currentPath = [];\n    this.scaleFactor = 1;\n    this.translationX = this.translationY = 0;\n    this.x = 0;\n    this.y = 0;\n    this._willKeepAspectRatio = true;\n  }\n  static initialize(l10n) {\n    _editor.AnnotationEditor.initialize(l10n, {\n      strings: [\"editor_ink_canvas_aria_label\", \"editor_ink2_aria_label\"]\n    });\n  }\n  static updateDefaultParams(type, value) {\n    switch (type) {\n      case _util.AnnotationEditorParamsType.INK_THICKNESS:\n        InkEditor._defaultThickness = value;\n        break;\n      case _util.AnnotationEditorParamsType.INK_COLOR:\n        InkEditor._defaultColor = value;\n        break;\n      case _util.AnnotationEditorParamsType.INK_OPACITY:\n        InkEditor._defaultOpacity = value / 100;\n        break;\n    }\n  }\n  updateParams(type, value) {\n    switch (type) {\n      case _util.AnnotationEditorParamsType.INK_THICKNESS:\n        this.#updateThickness(value);\n        break;\n      case _util.AnnotationEditorParamsType.INK_COLOR:\n        this.#updateColor(value);\n        break;\n      case _util.AnnotationEditorParamsType.INK_OPACITY:\n        this.#updateOpacity(value);\n        break;\n    }\n  }\n  static get defaultPropertiesToUpdate() {\n    return [[_util.AnnotationEditorParamsType.INK_THICKNESS, InkEditor._defaultThickness], [_util.AnnotationEditorParamsType.INK_COLOR, InkEditor._defaultColor || _editor.AnnotationEditor._defaultLineColor], [_util.AnnotationEditorParamsType.INK_OPACITY, Math.round(InkEditor._defaultOpacity * 100)]];\n  }\n  get propertiesToUpdate() {\n    return [[_util.AnnotationEditorParamsType.INK_THICKNESS, this.thickness || InkEditor._defaultThickness], [_util.AnnotationEditorParamsType.INK_COLOR, this.color || InkEditor._defaultColor || _editor.AnnotationEditor._defaultLineColor], [_util.AnnotationEditorParamsType.INK_OPACITY, Math.round(100 * (this.opacity ?? InkEditor._defaultOpacity))]];\n  }\n  #updateThickness(thickness) {\n    const savedThickness = this.thickness;\n    this.addCommands({\n      cmd: () => {\n        this.thickness = thickness;\n        this.#fitToContent();\n      },\n      undo: () => {\n        this.thickness = savedThickness;\n        this.#fitToContent();\n      },\n      mustExec: true,\n      type: _util.AnnotationEditorParamsType.INK_THICKNESS,\n      overwriteIfSameType: true,\n      keepUndo: true\n    });\n  }\n  #updateColor(color) {\n    const savedColor = this.color;\n    this.addCommands({\n      cmd: () => {\n        this.color = color;\n        this.#redraw();\n      },\n      undo: () => {\n        this.color = savedColor;\n        this.#redraw();\n      },\n      mustExec: true,\n      type: _util.AnnotationEditorParamsType.INK_COLOR,\n      overwriteIfSameType: true,\n      keepUndo: true\n    });\n  }\n  #updateOpacity(opacity) {\n    opacity /= 100;\n    const savedOpacity = this.opacity;\n    this.addCommands({\n      cmd: () => {\n        this.opacity = opacity;\n        this.#redraw();\n      },\n      undo: () => {\n        this.opacity = savedOpacity;\n        this.#redraw();\n      },\n      mustExec: true,\n      type: _util.AnnotationEditorParamsType.INK_OPACITY,\n      overwriteIfSameType: true,\n      keepUndo: true\n    });\n  }\n  rebuild() {\n    if (!this.parent) {\n      return;\n    }\n    super.rebuild();\n    if (this.div === null) {\n      return;\n    }\n    if (!this.canvas) {\n      this.#createCanvas();\n      this.#createObserver();\n    }\n    if (!this.isAttachedToDOM) {\n      this.parent.add(this);\n      this.#setCanvasDims();\n    }\n    this.#fitToContent();\n  }\n  remove() {\n    if (this.canvas === null) {\n      return;\n    }\n    if (!this.isEmpty()) {\n      this.commit();\n    }\n    this.canvas.width = this.canvas.height = 0;\n    this.canvas.remove();\n    this.canvas = null;\n    this.#observer.disconnect();\n    this.#observer = null;\n    super.remove();\n  }\n  setParent(parent) {\n    if (!this.parent && parent) {\n      this._uiManager.removeShouldRescale(this);\n    } else if (this.parent && parent === null) {\n      this._uiManager.addShouldRescale(this);\n    }\n    super.setParent(parent);\n  }\n  onScaleChanging() {\n    const [parentWidth, parentHeight] = this.parentDimensions;\n    const width = this.width * parentWidth;\n    const height = this.height * parentHeight;\n    this.setDimensions(width, height);\n  }\n  enableEditMode() {\n    if (this.#disableEditing || this.canvas === null) {\n      return;\n    }\n    super.enableEditMode();\n    this._isDraggable = false;\n    this.canvas.addEventListener(\"pointerdown\", this.#boundCanvasPointerdown);\n  }\n  disableEditMode() {\n    if (!this.isInEditMode() || this.canvas === null) {\n      return;\n    }\n    super.disableEditMode();\n    this._isDraggable = !this.isEmpty();\n    this.div.classList.remove(\"editing\");\n    this.canvas.removeEventListener(\"pointerdown\", this.#boundCanvasPointerdown);\n  }\n  onceAdded() {\n    this._isDraggable = !this.isEmpty();\n  }\n  isEmpty() {\n    return this.paths.length === 0 || this.paths.length === 1 && this.paths[0].length === 0;\n  }\n  #getInitialBBox() {\n    const {\n      parentRotation,\n      parentDimensions: [width, height]\n    } = this;\n    switch (parentRotation) {\n      case 90:\n        return [0, height, height, width];\n      case 180:\n        return [width, height, width, height];\n      case 270:\n        return [width, 0, height, width];\n      default:\n        return [0, 0, width, height];\n    }\n  }\n  #setStroke() {\n    const {\n      ctx,\n      color,\n      opacity,\n      thickness,\n      parentScale,\n      scaleFactor\n    } = this;\n    ctx.lineWidth = thickness * parentScale / scaleFactor;\n    ctx.lineCap = \"round\";\n    ctx.lineJoin = \"round\";\n    ctx.miterLimit = 10;\n    ctx.strokeStyle = `${color}${(0, _tools.opacityToHex)(opacity)}`;\n  }\n  #startDrawing(x, y) {\n    this.canvas.addEventListener(\"contextmenu\", _display_utils.noContextMenu);\n    this.canvas.addEventListener(\"pointerleave\", this.#boundCanvasPointerleave);\n    this.canvas.addEventListener(\"pointermove\", this.#boundCanvasPointermove);\n    this.canvas.addEventListener(\"pointerup\", this.#boundCanvasPointerup);\n    this.canvas.removeEventListener(\"pointerdown\", this.#boundCanvasPointerdown);\n    this.isEditing = true;\n    if (!this.#isCanvasInitialized) {\n      this.#isCanvasInitialized = true;\n      this.#setCanvasDims();\n      this.thickness ||= InkEditor._defaultThickness;\n      this.color ||= InkEditor._defaultColor || _editor.AnnotationEditor._defaultLineColor;\n      this.opacity ??= InkEditor._defaultOpacity;\n    }\n    this.currentPath.push([x, y]);\n    this.#hasSomethingToDraw = false;\n    this.#setStroke();\n    this.#requestFrameCallback = () => {\n      this.#drawPoints();\n      if (this.#requestFrameCallback) {\n        window.requestAnimationFrame(this.#requestFrameCallback);\n      }\n    };\n    window.requestAnimationFrame(this.#requestFrameCallback);\n  }\n  #draw(x, y) {\n    const [lastX, lastY] = this.currentPath.at(-1);\n    if (this.currentPath.length > 1 && x === lastX && y === lastY) {\n      return;\n    }\n    const currentPath = this.currentPath;\n    let path2D = this.#currentPath2D;\n    currentPath.push([x, y]);\n    this.#hasSomethingToDraw = true;\n    if (currentPath.length <= 2) {\n      path2D.moveTo(...currentPath[0]);\n      path2D.lineTo(x, y);\n      return;\n    }\n    if (currentPath.length === 3) {\n      this.#currentPath2D = path2D = new Path2D();\n      path2D.moveTo(...currentPath[0]);\n    }\n    this.#makeBezierCurve(path2D, ...currentPath.at(-3), ...currentPath.at(-2), x, y);\n  }\n  #endPath() {\n    if (this.currentPath.length === 0) {\n      return;\n    }\n    const lastPoint = this.currentPath.at(-1);\n    this.#currentPath2D.lineTo(...lastPoint);\n  }\n  #stopDrawing(x, y) {\n    this.#requestFrameCallback = null;\n    x = Math.min(Math.max(x, 0), this.canvas.width);\n    y = Math.min(Math.max(y, 0), this.canvas.height);\n    this.#draw(x, y);\n    this.#endPath();\n    let bezier;\n    if (this.currentPath.length !== 1) {\n      bezier = this.#generateBezierPoints();\n    } else {\n      const xy = [x, y];\n      bezier = [[xy, xy.slice(), xy.slice(), xy]];\n    }\n    const path2D = this.#currentPath2D;\n    const currentPath = this.currentPath;\n    this.currentPath = [];\n    this.#currentPath2D = new Path2D();\n    const cmd = () => {\n      this.allRawPaths.push(currentPath);\n      this.paths.push(bezier);\n      this.bezierPath2D.push(path2D);\n      this.rebuild();\n    };\n    const undo = () => {\n      this.allRawPaths.pop();\n      this.paths.pop();\n      this.bezierPath2D.pop();\n      if (this.paths.length === 0) {\n        this.remove();\n      } else {\n        if (!this.canvas) {\n          this.#createCanvas();\n          this.#createObserver();\n        }\n        this.#fitToContent();\n      }\n    };\n    this.addCommands({\n      cmd,\n      undo,\n      mustExec: true\n    });\n  }\n  #drawPoints() {\n    if (!this.#hasSomethingToDraw) {\n      return;\n    }\n    this.#hasSomethingToDraw = false;\n    const thickness = Math.ceil(this.thickness * this.parentScale);\n    const lastPoints = this.currentPath.slice(-3);\n    const x = lastPoints.map(xy => xy[0]);\n    const y = lastPoints.map(xy => xy[1]);\n    const xMin = Math.min(...x) - thickness;\n    const xMax = Math.max(...x) + thickness;\n    const yMin = Math.min(...y) - thickness;\n    const yMax = Math.max(...y) + thickness;\n    const {\n      ctx\n    } = this;\n    ctx.save();\n    ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n    for (const path of this.bezierPath2D) {\n      ctx.stroke(path);\n    }\n    ctx.stroke(this.#currentPath2D);\n    ctx.restore();\n  }\n  #makeBezierCurve(path2D, x0, y0, x1, y1, x2, y2) {\n    const prevX = (x0 + x1) / 2;\n    const prevY = (y0 + y1) / 2;\n    const x3 = (x1 + x2) / 2;\n    const y3 = (y1 + y2) / 2;\n    path2D.bezierCurveTo(prevX + 2 * (x1 - prevX) / 3, prevY + 2 * (y1 - prevY) / 3, x3 + 2 * (x1 - x3) / 3, y3 + 2 * (y1 - y3) / 3, x3, y3);\n  }\n  #generateBezierPoints() {\n    const path = this.currentPath;\n    if (path.length <= 2) {\n      return [[path[0], path[0], path.at(-1), path.at(-1)]];\n    }\n    const bezierPoints = [];\n    let i;\n    let [x0, y0] = path[0];\n    for (i = 1; i < path.length - 2; i++) {\n      const [x1, y1] = path[i];\n      const [x2, y2] = path[i + 1];\n      const x3 = (x1 + x2) / 2;\n      const y3 = (y1 + y2) / 2;\n      const control1 = [x0 + 2 * (x1 - x0) / 3, y0 + 2 * (y1 - y0) / 3];\n      const control2 = [x3 + 2 * (x1 - x3) / 3, y3 + 2 * (y1 - y3) / 3];\n      bezierPoints.push([[x0, y0], control1, control2, [x3, y3]]);\n      [x0, y0] = [x3, y3];\n    }\n    const [x1, y1] = path[i];\n    const [x2, y2] = path[i + 1];\n    const control1 = [x0 + 2 * (x1 - x0) / 3, y0 + 2 * (y1 - y0) / 3];\n    const control2 = [x2 + 2 * (x1 - x2) / 3, y2 + 2 * (y1 - y2) / 3];\n    bezierPoints.push([[x0, y0], control1, control2, [x2, y2]]);\n    return bezierPoints;\n  }\n  #redraw() {\n    if (this.isEmpty()) {\n      this.#updateTransform();\n      return;\n    }\n    this.#setStroke();\n    const {\n      canvas,\n      ctx\n    } = this;\n    ctx.setTransform(1, 0, 0, 1, 0, 0);\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n    this.#updateTransform();\n    for (const path of this.bezierPath2D) {\n      ctx.stroke(path);\n    }\n  }\n  commit() {\n    if (this.#disableEditing) {\n      return;\n    }\n    super.commit();\n    this.isEditing = false;\n    this.disableEditMode();\n    this.setInForeground();\n    this.#disableEditing = true;\n    this.div.classList.add(\"disabled\");\n    this.#fitToContent(true);\n    this.makeResizable();\n    this.parent.addInkEditorIfNeeded(true);\n    this.moveInDOM();\n    this.div.focus({\n      preventScroll: true\n    });\n  }\n  focusin(event) {\n    if (!this._focusEventsAllowed) {\n      return;\n    }\n    super.focusin(event);\n    this.enableEditMode();\n  }\n  canvasPointerdown(event) {\n    if (event.button !== 0 || !this.isInEditMode() || this.#disableEditing) {\n      return;\n    }\n    this.setInForeground();\n    event.preventDefault();\n    if (event.type !== \"mouse\") {\n      this.div.focus();\n    }\n    this.#startDrawing(event.offsetX, event.offsetY);\n  }\n  canvasPointermove(event) {\n    event.preventDefault();\n    this.#draw(event.offsetX, event.offsetY);\n  }\n  canvasPointerup(event) {\n    event.preventDefault();\n    this.#endDrawing(event);\n  }\n  canvasPointerleave(event) {\n    this.#endDrawing(event);\n  }\n  #endDrawing(event) {\n    this.canvas.removeEventListener(\"pointerleave\", this.#boundCanvasPointerleave);\n    this.canvas.removeEventListener(\"pointermove\", this.#boundCanvasPointermove);\n    this.canvas.removeEventListener(\"pointerup\", this.#boundCanvasPointerup);\n    this.canvas.addEventListener(\"pointerdown\", this.#boundCanvasPointerdown);\n    setTimeout(() => {\n      this.canvas.removeEventListener(\"contextmenu\", _display_utils.noContextMenu);\n    }, 10);\n    this.#stopDrawing(event.offsetX, event.offsetY);\n    this.addToAnnotationStorage();\n    this.setInBackground();\n  }\n  #createCanvas() {\n    this.canvas = document.createElement(\"canvas\");\n    this.canvas.width = this.canvas.height = 0;\n    this.canvas.className = \"inkEditorCanvas\";\n    _editor.AnnotationEditor._l10nPromise.get(\"editor_ink_canvas_aria_label\").then(msg => this.canvas?.setAttribute(\"aria-label\", msg));\n    this.div.append(this.canvas);\n    this.ctx = this.canvas.getContext(\"2d\");\n  }\n  #createObserver() {\n    this.#observer = new ResizeObserver(entries => {\n      const rect = entries[0].contentRect;\n      if (rect.width && rect.height) {\n        this.setDimensions(rect.width, rect.height);\n      }\n    });\n    this.#observer.observe(this.div);\n  }\n  get isResizable() {\n    return !this.isEmpty() && this.#disableEditing;\n  }\n  render() {\n    if (this.div) {\n      return this.div;\n    }\n    let baseX, baseY;\n    if (this.width) {\n      baseX = this.x;\n      baseY = this.y;\n    }\n    super.render();\n    _editor.AnnotationEditor._l10nPromise.get(\"editor_ink2_aria_label\").then(msg => this.div?.setAttribute(\"aria-label\", msg));\n    const [x, y, w, h] = this.#getInitialBBox();\n    this.setAt(x, y, 0, 0);\n    this.setDims(w, h);\n    this.#createCanvas();\n    if (this.width) {\n      const [parentWidth, parentHeight] = this.parentDimensions;\n      this.setAspectRatio(this.width * parentWidth, this.height * parentHeight);\n      this.setAt(baseX * parentWidth, baseY * parentHeight, this.width * parentWidth, this.height * parentHeight);\n      this.#isCanvasInitialized = true;\n      this.#setCanvasDims();\n      this.setDims(this.width * parentWidth, this.height * parentHeight);\n      this.#redraw();\n      this.div.classList.add(\"disabled\");\n    } else {\n      this.div.classList.add(\"editing\");\n      this.enableEditMode();\n    }\n    this.#createObserver();\n    return this.div;\n  }\n  #setCanvasDims() {\n    if (!this.#isCanvasInitialized) {\n      return;\n    }\n    const [parentWidth, parentHeight] = this.parentDimensions;\n    this.canvas.width = Math.ceil(this.width * parentWidth);\n    this.canvas.height = Math.ceil(this.height * parentHeight);\n    this.#updateTransform();\n  }\n  setDimensions(width, height) {\n    const roundedWidth = Math.round(width);\n    const roundedHeight = Math.round(height);\n    if (this.#realWidth === roundedWidth && this.#realHeight === roundedHeight) {\n      return;\n    }\n    this.#realWidth = roundedWidth;\n    this.#realHeight = roundedHeight;\n    this.canvas.style.visibility = \"hidden\";\n    const [parentWidth, parentHeight] = this.parentDimensions;\n    this.width = width / parentWidth;\n    this.height = height / parentHeight;\n    this.fixAndSetPosition();\n    if (this.#disableEditing) {\n      this.#setScaleFactor(width, height);\n    }\n    this.#setCanvasDims();\n    this.#redraw();\n    this.canvas.style.visibility = \"visible\";\n    this.fixDims();\n  }\n  #setScaleFactor(width, height) {\n    const padding = this.#getPadding();\n    const scaleFactorW = (width - padding) / this.#baseWidth;\n    const scaleFactorH = (height - padding) / this.#baseHeight;\n    this.scaleFactor = Math.min(scaleFactorW, scaleFactorH);\n  }\n  #updateTransform() {\n    const padding = this.#getPadding() / 2;\n    this.ctx.setTransform(this.scaleFactor, 0, 0, this.scaleFactor, this.translationX * this.scaleFactor + padding, this.translationY * this.scaleFactor + padding);\n  }\n  static #buildPath2D(bezier) {\n    const path2D = new Path2D();\n    for (let i = 0, ii = bezier.length; i < ii; i++) {\n      const [first, control1, control2, second] = bezier[i];\n      if (i === 0) {\n        path2D.moveTo(...first);\n      }\n      path2D.bezierCurveTo(control1[0], control1[1], control2[0], control2[1], second[0], second[1]);\n    }\n    return path2D;\n  }\n  static #toPDFCoordinates(points, rect, rotation) {\n    const [blX, blY, trX, trY] = rect;\n    switch (rotation) {\n      case 0:\n        for (let i = 0, ii = points.length; i < ii; i += 2) {\n          points[i] += blX;\n          points[i + 1] = trY - points[i + 1];\n        }\n        break;\n      case 90:\n        for (let i = 0, ii = points.length; i < ii; i += 2) {\n          const x = points[i];\n          points[i] = points[i + 1] + blX;\n          points[i + 1] = x + blY;\n        }\n        break;\n      case 180:\n        for (let i = 0, ii = points.length; i < ii; i += 2) {\n          points[i] = trX - points[i];\n          points[i + 1] += blY;\n        }\n        break;\n      case 270:\n        for (let i = 0, ii = points.length; i < ii; i += 2) {\n          const x = points[i];\n          points[i] = trX - points[i + 1];\n          points[i + 1] = trY - x;\n        }\n        break;\n      default:\n        throw new Error(\"Invalid rotation\");\n    }\n    return points;\n  }\n  static #fromPDFCoordinates(points, rect, rotation) {\n    const [blX, blY, trX, trY] = rect;\n    switch (rotation) {\n      case 0:\n        for (let i = 0, ii = points.length; i < ii; i += 2) {\n          points[i] -= blX;\n          points[i + 1] = trY - points[i + 1];\n        }\n        break;\n      case 90:\n        for (let i = 0, ii = points.length; i < ii; i += 2) {\n          const x = points[i];\n          points[i] = points[i + 1] - blY;\n          points[i + 1] = x - blX;\n        }\n        break;\n      case 180:\n        for (let i = 0, ii = points.length; i < ii; i += 2) {\n          points[i] = trX - points[i];\n          points[i + 1] -= blY;\n        }\n        break;\n      case 270:\n        for (let i = 0, ii = points.length; i < ii; i += 2) {\n          const x = points[i];\n          points[i] = trY - points[i + 1];\n          points[i + 1] = trX - x;\n        }\n        break;\n      default:\n        throw new Error(\"Invalid rotation\");\n    }\n    return points;\n  }\n  #serializePaths(s, tx, ty, rect) {\n    const paths = [];\n    const padding = this.thickness / 2;\n    const shiftX = s * tx + padding;\n    const shiftY = s * ty + padding;\n    for (const bezier of this.paths) {\n      const buffer = [];\n      const points = [];\n      for (let j = 0, jj = bezier.length; j < jj; j++) {\n        const [first, control1, control2, second] = bezier[j];\n        const p10 = s * first[0] + shiftX;\n        const p11 = s * first[1] + shiftY;\n        const p20 = s * control1[0] + shiftX;\n        const p21 = s * control1[1] + shiftY;\n        const p30 = s * control2[0] + shiftX;\n        const p31 = s * control2[1] + shiftY;\n        const p40 = s * second[0] + shiftX;\n        const p41 = s * second[1] + shiftY;\n        if (j === 0) {\n          buffer.push(p10, p11);\n          points.push(p10, p11);\n        }\n        buffer.push(p20, p21, p30, p31, p40, p41);\n        points.push(p20, p21);\n        if (j === jj - 1) {\n          points.push(p40, p41);\n        }\n      }\n      paths.push({\n        bezier: InkEditor.#toPDFCoordinates(buffer, rect, this.rotation),\n        points: InkEditor.#toPDFCoordinates(points, rect, this.rotation)\n      });\n    }\n    return paths;\n  }\n  #getBbox() {\n    let xMin = Infinity;\n    let xMax = -Infinity;\n    let yMin = Infinity;\n    let yMax = -Infinity;\n    for (const path of this.paths) {\n      for (const [first, control1, control2, second] of path) {\n        const bbox = _util.Util.bezierBoundingBox(...first, ...control1, ...control2, ...second);\n        xMin = Math.min(xMin, bbox[0]);\n        yMin = Math.min(yMin, bbox[1]);\n        xMax = Math.max(xMax, bbox[2]);\n        yMax = Math.max(yMax, bbox[3]);\n      }\n    }\n    return [xMin, yMin, xMax, yMax];\n  }\n  #getPadding() {\n    return this.#disableEditing ? Math.ceil(this.thickness * this.parentScale) : 0;\n  }\n  #fitToContent(firstTime = false) {\n    if (this.isEmpty()) {\n      return;\n    }\n    if (!this.#disableEditing) {\n      this.#redraw();\n      return;\n    }\n    const bbox = this.#getBbox();\n    const padding = this.#getPadding();\n    this.#baseWidth = Math.max(_editor.AnnotationEditor.MIN_SIZE, bbox[2] - bbox[0]);\n    this.#baseHeight = Math.max(_editor.AnnotationEditor.MIN_SIZE, bbox[3] - bbox[1]);\n    const width = Math.ceil(padding + this.#baseWidth * this.scaleFactor);\n    const height = Math.ceil(padding + this.#baseHeight * this.scaleFactor);\n    const [parentWidth, parentHeight] = this.parentDimensions;\n    this.width = width / parentWidth;\n    this.height = height / parentHeight;\n    this.setAspectRatio(width, height);\n    const prevTranslationX = this.translationX;\n    const prevTranslationY = this.translationY;\n    this.translationX = -bbox[0];\n    this.translationY = -bbox[1];\n    this.#setCanvasDims();\n    this.#redraw();\n    this.#realWidth = width;\n    this.#realHeight = height;\n    this.setDims(width, height);\n    const unscaledPadding = firstTime ? padding / this.scaleFactor / 2 : 0;\n    this.translate(prevTranslationX - this.translationX - unscaledPadding, prevTranslationY - this.translationY - unscaledPadding);\n  }\n  static deserialize(data, parent, uiManager) {\n    if (data instanceof _annotation_layer.InkAnnotationElement) {\n      return null;\n    }\n    const editor = super.deserialize(data, parent, uiManager);\n    editor.thickness = data.thickness;\n    editor.color = _util.Util.makeHexColor(...data.color);\n    editor.opacity = data.opacity;\n    const [pageWidth, pageHeight] = editor.pageDimensions;\n    const width = editor.width * pageWidth;\n    const height = editor.height * pageHeight;\n    const scaleFactor = editor.parentScale;\n    const padding = data.thickness / 2;\n    editor.#disableEditing = true;\n    editor.#realWidth = Math.round(width);\n    editor.#realHeight = Math.round(height);\n    const {\n      paths,\n      rect,\n      rotation\n    } = data;\n    for (let {\n      bezier\n    } of paths) {\n      bezier = InkEditor.#fromPDFCoordinates(bezier, rect, rotation);\n      const path = [];\n      editor.paths.push(path);\n      let p0 = scaleFactor * (bezier[0] - padding);\n      let p1 = scaleFactor * (bezier[1] - padding);\n      for (let i = 2, ii = bezier.length; i < ii; i += 6) {\n        const p10 = scaleFactor * (bezier[i] - padding);\n        const p11 = scaleFactor * (bezier[i + 1] - padding);\n        const p20 = scaleFactor * (bezier[i + 2] - padding);\n        const p21 = scaleFactor * (bezier[i + 3] - padding);\n        const p30 = scaleFactor * (bezier[i + 4] - padding);\n        const p31 = scaleFactor * (bezier[i + 5] - padding);\n        path.push([[p0, p1], [p10, p11], [p20, p21], [p30, p31]]);\n        p0 = p30;\n        p1 = p31;\n      }\n      const path2D = this.#buildPath2D(path);\n      editor.bezierPath2D.push(path2D);\n    }\n    const bbox = editor.#getBbox();\n    editor.#baseWidth = Math.max(_editor.AnnotationEditor.MIN_SIZE, bbox[2] - bbox[0]);\n    editor.#baseHeight = Math.max(_editor.AnnotationEditor.MIN_SIZE, bbox[3] - bbox[1]);\n    editor.#setScaleFactor(width, height);\n    return editor;\n  }\n  serialize() {\n    if (this.isEmpty()) {\n      return null;\n    }\n    const rect = this.getRect(0, 0);\n    const color = _editor.AnnotationEditor._colorManager.convert(this.ctx.strokeStyle);\n    return {\n      annotationType: _util.AnnotationEditorType.INK,\n      color,\n      thickness: this.thickness,\n      opacity: this.opacity,\n      paths: this.#serializePaths(this.scaleFactor / this.parentScale, this.translationX, this.translationY, rect),\n      pageIndex: this.pageIndex,\n      rect,\n      rotation: this.rotation,\n      structTreeParentId: this._structTreeParentId\n    };\n  }\n}\nexports.InkEditor = InkEditor;\n\n/***/ }),\n/* 34 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.StampEditor = void 0;\nvar _util = __w_pdfjs_require__(1);\nvar _editor = __w_pdfjs_require__(4);\nvar _display_utils = __w_pdfjs_require__(6);\nvar _annotation_layer = __w_pdfjs_require__(29);\nclass StampEditor extends _editor.AnnotationEditor {\n  #bitmap = null;\n  #bitmapId = null;\n  #bitmapPromise = null;\n  #bitmapUrl = null;\n  #bitmapFile = null;\n  #canvas = null;\n  #observer = null;\n  #resizeTimeoutId = null;\n  #isSvg = false;\n  #hasBeenAddedInUndoStack = false;\n  static _type = \"stamp\";\n  constructor(params) {\n    super({\n      ...params,\n      name: \"stampEditor\"\n    });\n    this.#bitmapUrl = params.bitmapUrl;\n    this.#bitmapFile = params.bitmapFile;\n  }\n  static initialize(l10n) {\n    _editor.AnnotationEditor.initialize(l10n);\n  }\n  static get supportedTypes() {\n    const types = [\"apng\", \"avif\", \"bmp\", \"gif\", \"jpeg\", \"png\", \"svg+xml\", \"webp\", \"x-icon\"];\n    return (0, _util.shadow)(this, \"supportedTypes\", types.map(type => `image/${type}`));\n  }\n  static get supportedTypesStr() {\n    return (0, _util.shadow)(this, \"supportedTypesStr\", this.supportedTypes.join(\",\"));\n  }\n  static isHandlingMimeForPasting(mime) {\n    return this.supportedTypes.includes(mime);\n  }\n  static paste(item, parent) {\n    parent.pasteEditor(_util.AnnotationEditorType.STAMP, {\n      bitmapFile: item.getAsFile()\n    });\n  }\n  #getBitmapFetched(data, fromId = false) {\n    if (!data) {\n      this.remove();\n      return;\n    }\n    this.#bitmap = data.bitmap;\n    if (!fromId) {\n      this.#bitmapId = data.id;\n      this.#isSvg = data.isSvg;\n    }\n    this.#createCanvas();\n  }\n  #getBitmapDone() {\n    this.#bitmapPromise = null;\n    this._uiManager.enableWaiting(false);\n    if (this.#canvas) {\n      this.div.focus();\n    }\n  }\n  #getBitmap() {\n    if (this.#bitmapId) {\n      this._uiManager.enableWaiting(true);\n      this._uiManager.imageManager.getFromId(this.#bitmapId).then(data => this.#getBitmapFetched(data, true)).finally(() => this.#getBitmapDone());\n      return;\n    }\n    if (this.#bitmapUrl) {\n      const url = this.#bitmapUrl;\n      this.#bitmapUrl = null;\n      this._uiManager.enableWaiting(true);\n      this.#bitmapPromise = this._uiManager.imageManager.getFromUrl(url).then(data => this.#getBitmapFetched(data)).finally(() => this.#getBitmapDone());\n      return;\n    }\n    if (this.#bitmapFile) {\n      const file = this.#bitmapFile;\n      this.#bitmapFile = null;\n      this._uiManager.enableWaiting(true);\n      this.#bitmapPromise = this._uiManager.imageManager.getFromFile(file).then(data => this.#getBitmapFetched(data)).finally(() => this.#getBitmapDone());\n      return;\n    }\n    const input = document.createElement(\"input\");\n    input.type = \"file\";\n    input.accept = StampEditor.supportedTypesStr;\n    this.#bitmapPromise = new Promise(resolve => {\n      input.addEventListener(\"change\", async () => {\n        if (!input.files || input.files.length === 0) {\n          this.remove();\n        } else {\n          this._uiManager.enableWaiting(true);\n          const data = await this._uiManager.imageManager.getFromFile(input.files[0]);\n          this.#getBitmapFetched(data);\n        }\n        resolve();\n      });\n      input.addEventListener(\"cancel\", () => {\n        this.remove();\n        resolve();\n      });\n    }).finally(() => this.#getBitmapDone());\n    input.click();\n  }\n  remove() {\n    if (this.#bitmapId) {\n      this.#bitmap = null;\n      this._uiManager.imageManager.deleteId(this.#bitmapId);\n      this.#canvas?.remove();\n      this.#canvas = null;\n      this.#observer?.disconnect();\n      this.#observer = null;\n    }\n    super.remove();\n  }\n  rebuild() {\n    if (!this.parent) {\n      if (this.#bitmapId) {\n        this.#getBitmap();\n      }\n      return;\n    }\n    super.rebuild();\n    if (this.div === null) {\n      return;\n    }\n    if (this.#bitmapId) {\n      this.#getBitmap();\n    }\n    if (!this.isAttachedToDOM) {\n      this.parent.add(this);\n    }\n  }\n  onceAdded() {\n    this._isDraggable = true;\n    this.div.focus();\n  }\n  isEmpty() {\n    return !(this.#bitmapPromise || this.#bitmap || this.#bitmapUrl || this.#bitmapFile);\n  }\n  get isResizable() {\n    return true;\n  }\n  render() {\n    if (this.div) {\n      return this.div;\n    }\n    let baseX, baseY;\n    if (this.width) {\n      baseX = this.x;\n      baseY = this.y;\n    }\n    super.render();\n    this.div.hidden = true;\n    if (this.#bitmap) {\n      this.#createCanvas();\n    } else {\n      this.#getBitmap();\n    }\n    if (this.width) {\n      const [parentWidth, parentHeight] = this.parentDimensions;\n      this.setAt(baseX * parentWidth, baseY * parentHeight, this.width * parentWidth, this.height * parentHeight);\n    }\n    return this.div;\n  }\n  #createCanvas() {\n    const {\n      div\n    } = this;\n    let {\n      width,\n      height\n    } = this.#bitmap;\n    const [pageWidth, pageHeight] = this.pageDimensions;\n    const MAX_RATIO = 0.75;\n    if (this.width) {\n      width = this.width * pageWidth;\n      height = this.height * pageHeight;\n    } else if (width > MAX_RATIO * pageWidth || height > MAX_RATIO * pageHeight) {\n      const factor = Math.min(MAX_RATIO * pageWidth / width, MAX_RATIO * pageHeight / height);\n      width *= factor;\n      height *= factor;\n    }\n    const [parentWidth, parentHeight] = this.parentDimensions;\n    this.setDims(width * parentWidth / pageWidth, height * parentHeight / pageHeight);\n    this._uiManager.enableWaiting(false);\n    const canvas = this.#canvas = document.createElement(\"canvas\");\n    div.append(canvas);\n    div.hidden = false;\n    this.#drawBitmap(width, height);\n    this.#createObserver();\n    if (!this.#hasBeenAddedInUndoStack) {\n      this.parent.addUndoableEditor(this);\n      this.#hasBeenAddedInUndoStack = true;\n    }\n    this._uiManager._eventBus.dispatch(\"reporttelemetry\", {\n      source: this,\n      details: {\n        type: \"editing\",\n        subtype: this.editorType,\n        data: {\n          action: \"inserted_image\"\n        }\n      }\n    });\n    this.addAltTextButton();\n  }\n  #setDimensions(width, height) {\n    const [parentWidth, parentHeight] = this.parentDimensions;\n    this.width = width / parentWidth;\n    this.height = height / parentHeight;\n    this.setDims(width, height);\n    if (this._initialOptions?.isCentered) {\n      this.center();\n    } else {\n      this.fixAndSetPosition();\n    }\n    this._initialOptions = null;\n    if (this.#resizeTimeoutId !== null) {\n      clearTimeout(this.#resizeTimeoutId);\n    }\n    const TIME_TO_WAIT = 200;\n    this.#resizeTimeoutId = setTimeout(() => {\n      this.#resizeTimeoutId = null;\n      this.#drawBitmap(width, height);\n    }, TIME_TO_WAIT);\n  }\n  #scaleBitmap(width, height) {\n    const {\n      width: bitmapWidth,\n      height: bitmapHeight\n    } = this.#bitmap;\n    let newWidth = bitmapWidth;\n    let newHeight = bitmapHeight;\n    let bitmap = this.#bitmap;\n    while (newWidth > 2 * width || newHeight > 2 * height) {\n      const prevWidth = newWidth;\n      const prevHeight = newHeight;\n      if (newWidth > 2 * width) {\n        newWidth = newWidth >= 16384 ? Math.floor(newWidth / 2) - 1 : Math.ceil(newWidth / 2);\n      }\n      if (newHeight > 2 * height) {\n        newHeight = newHeight >= 16384 ? Math.floor(newHeight / 2) - 1 : Math.ceil(newHeight / 2);\n      }\n      const offscreen = new OffscreenCanvas(newWidth, newHeight);\n      const ctx = offscreen.getContext(\"2d\");\n      ctx.drawImage(bitmap, 0, 0, prevWidth, prevHeight, 0, 0, newWidth, newHeight);\n      bitmap = offscreen.transferToImageBitmap();\n    }\n    return bitmap;\n  }\n  #drawBitmap(width, height) {\n    width = Math.ceil(width);\n    height = Math.ceil(height);\n    const canvas = this.#canvas;\n    if (!canvas || canvas.width === width && canvas.height === height) {\n      return;\n    }\n    canvas.width = width;\n    canvas.height = height;\n    const bitmap = this.#isSvg ? this.#bitmap : this.#scaleBitmap(width, height);\n    const ctx = canvas.getContext(\"2d\");\n    ctx.filter = this._uiManager.hcmFilter;\n    ctx.drawImage(bitmap, 0, 0, bitmap.width, bitmap.height, 0, 0, width, height);\n  }\n  #serializeBitmap(toUrl) {\n    if (toUrl) {\n      if (this.#isSvg) {\n        const url = this._uiManager.imageManager.getSvgUrl(this.#bitmapId);\n        if (url) {\n          return url;\n        }\n      }\n      const canvas = document.createElement(\"canvas\");\n      ({\n        width: canvas.width,\n        height: canvas.height\n      } = this.#bitmap);\n      const ctx = canvas.getContext(\"2d\");\n      ctx.drawImage(this.#bitmap, 0, 0);\n      return canvas.toDataURL();\n    }\n    if (this.#isSvg) {\n      const [pageWidth, pageHeight] = this.pageDimensions;\n      const width = Math.round(this.width * pageWidth * _display_utils.PixelsPerInch.PDF_TO_CSS_UNITS);\n      const height = Math.round(this.height * pageHeight * _display_utils.PixelsPerInch.PDF_TO_CSS_UNITS);\n      const offscreen = new OffscreenCanvas(width, height);\n      const ctx = offscreen.getContext(\"2d\");\n      ctx.drawImage(this.#bitmap, 0, 0, this.#bitmap.width, this.#bitmap.height, 0, 0, width, height);\n      return offscreen.transferToImageBitmap();\n    }\n    return structuredClone(this.#bitmap);\n  }\n  #createObserver() {\n    this.#observer = new ResizeObserver(entries => {\n      const rect = entries[0].contentRect;\n      if (rect.width && rect.height) {\n        this.#setDimensions(rect.width, rect.height);\n      }\n    });\n    this.#observer.observe(this.div);\n  }\n  static deserialize(data, parent, uiManager) {\n    if (data instanceof _annotation_layer.StampAnnotationElement) {\n      return null;\n    }\n    const editor = super.deserialize(data, parent, uiManager);\n    const {\n      rect,\n      bitmapUrl,\n      bitmapId,\n      isSvg,\n      accessibilityData\n    } = data;\n    if (bitmapId && uiManager.imageManager.isValidId(bitmapId)) {\n      editor.#bitmapId = bitmapId;\n    } else {\n      editor.#bitmapUrl = bitmapUrl;\n    }\n    editor.#isSvg = isSvg;\n    const [parentWidth, parentHeight] = editor.pageDimensions;\n    editor.width = (rect[2] - rect[0]) / parentWidth;\n    editor.height = (rect[3] - rect[1]) / parentHeight;\n    if (accessibilityData) {\n      editor.altTextData = accessibilityData;\n    }\n    return editor;\n  }\n  serialize(isForCopying = false, context = null) {\n    if (this.isEmpty()) {\n      return null;\n    }\n    const serialized = {\n      annotationType: _util.AnnotationEditorType.STAMP,\n      bitmapId: this.#bitmapId,\n      pageIndex: this.pageIndex,\n      rect: this.getRect(0, 0),\n      rotation: this.rotation,\n      isSvg: this.#isSvg,\n      structTreeParentId: this._structTreeParentId\n    };\n    if (isForCopying) {\n      serialized.bitmapUrl = this.#serializeBitmap(true);\n      serialized.accessibilityData = this.altTextData;\n      return serialized;\n    }\n    const {\n      decorative,\n      altText\n    } = this.altTextData;\n    if (!decorative && altText) {\n      serialized.accessibilityData = {\n        type: \"Figure\",\n        alt: altText\n      };\n    }\n    if (context === null) {\n      return serialized;\n    }\n    context.stamps ||= new Map();\n    const area = this.#isSvg ? (serialized.rect[2] - serialized.rect[0]) * (serialized.rect[3] - serialized.rect[1]) : null;\n    if (!context.stamps.has(this.#bitmapId)) {\n      context.stamps.set(this.#bitmapId, {\n        area,\n        serialized\n      });\n      serialized.bitmap = this.#serializeBitmap(false);\n    } else if (this.#isSvg) {\n      const prevData = context.stamps.get(this.#bitmapId);\n      if (area > prevData.area) {\n        prevData.area = area;\n        prevData.serialized.bitmap.close();\n        prevData.serialized.bitmap = this.#serializeBitmap(false);\n      }\n    }\n    return serialized;\n  }\n}\nexports.StampEditor = StampEditor;\n\n/***/ })\n/******/ \t]);\n/************************************************************************/\n/******/ \t// The module cache\n/******/ \tvar __webpack_module_cache__ = {};\n/******/ \t\n/******/ \t// The require function\n/******/ \tfunction __w_pdfjs_require__(moduleId) {\n/******/ \t\t// Check if module is in cache\n/******/ \t\tvar cachedModule = __webpack_module_cache__[moduleId];\n/******/ \t\tif (cachedModule !== undefined) {\n/******/ \t\t\treturn cachedModule.exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = __webpack_module_cache__[moduleId] = {\n/******/ \t\t\t// no module.id needed\n/******/ \t\t\t// no module.loaded needed\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/ \t\n/******/ \t\t// Execute the module function\n/******/ \t\t__webpack_modules__[moduleId](module, module.exports, __w_pdfjs_require__);\n/******/ \t\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/ \t\n/************************************************************************/\nvar __nested_webpack_exports__ = {};\n// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.\n(() => {\nvar exports = __nested_webpack_exports__;\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nObject.defineProperty(exports, \"AbortException\", ({\n  enumerable: true,\n  get: function () {\n    return _util.AbortException;\n  }\n}));\nObject.defineProperty(exports, \"AnnotationEditorLayer\", ({\n  enumerable: true,\n  get: function () {\n    return _annotation_editor_layer.AnnotationEditorLayer;\n  }\n}));\nObject.defineProperty(exports, \"AnnotationEditorParamsType\", ({\n  enumerable: true,\n  get: function () {\n    return _util.AnnotationEditorParamsType;\n  }\n}));\nObject.defineProperty(exports, \"AnnotationEditorType\", ({\n  enumerable: true,\n  get: function () {\n    return _util.AnnotationEditorType;\n  }\n}));\nObject.defineProperty(exports, \"AnnotationEditorUIManager\", ({\n  enumerable: true,\n  get: function () {\n    return _tools.AnnotationEditorUIManager;\n  }\n}));\nObject.defineProperty(exports, \"AnnotationLayer\", ({\n  enumerable: true,\n  get: function () {\n    return _annotation_layer.AnnotationLayer;\n  }\n}));\nObject.defineProperty(exports, \"AnnotationMode\", ({\n  enumerable: true,\n  get: function () {\n    return _util.AnnotationMode;\n  }\n}));\nObject.defineProperty(exports, \"CMapCompressionType\", ({\n  enumerable: true,\n  get: function () {\n    return _util.CMapCompressionType;\n  }\n}));\nObject.defineProperty(exports, \"DOMSVGFactory\", ({\n  enumerable: true,\n  get: function () {\n    return _display_utils.DOMSVGFactory;\n  }\n}));\nObject.defineProperty(exports, \"FeatureTest\", ({\n  enumerable: true,\n  get: function () {\n    return _util.FeatureTest;\n  }\n}));\nObject.defineProperty(exports, \"GlobalWorkerOptions\", ({\n  enumerable: true,\n  get: function () {\n    return _worker_options.GlobalWorkerOptions;\n  }\n}));\nObject.defineProperty(exports, \"ImageKind\", ({\n  enumerable: true,\n  get: function () {\n    return _util.ImageKind;\n  }\n}));\nObject.defineProperty(exports, \"InvalidPDFException\", ({\n  enumerable: true,\n  get: function () {\n    return _util.InvalidPDFException;\n  }\n}));\nObject.defineProperty(exports, \"MissingPDFException\", ({\n  enumerable: true,\n  get: function () {\n    return _util.MissingPDFException;\n  }\n}));\nObject.defineProperty(exports, \"OPS\", ({\n  enumerable: true,\n  get: function () {\n    return _util.OPS;\n  }\n}));\nObject.defineProperty(exports, \"PDFDataRangeTransport\", ({\n  enumerable: true,\n  get: function () {\n    return _api.PDFDataRangeTransport;\n  }\n}));\nObject.defineProperty(exports, \"PDFDateString\", ({\n  enumerable: true,\n  get: function () {\n    return _display_utils.PDFDateString;\n  }\n}));\nObject.defineProperty(exports, \"PDFWorker\", ({\n  enumerable: true,\n  get: function () {\n    return _api.PDFWorker;\n  }\n}));\nObject.defineProperty(exports, \"PasswordResponses\", ({\n  enumerable: true,\n  get: function () {\n    return _util.PasswordResponses;\n  }\n}));\nObject.defineProperty(exports, \"PermissionFlag\", ({\n  enumerable: true,\n  get: function () {\n    return _util.PermissionFlag;\n  }\n}));\nObject.defineProperty(exports, \"PixelsPerInch\", ({\n  enumerable: true,\n  get: function () {\n    return _display_utils.PixelsPerInch;\n  }\n}));\nObject.defineProperty(exports, \"PromiseCapability\", ({\n  enumerable: true,\n  get: function () {\n    return _util.PromiseCapability;\n  }\n}));\nObject.defineProperty(exports, \"RenderingCancelledException\", ({\n  enumerable: true,\n  get: function () {\n    return _display_utils.RenderingCancelledException;\n  }\n}));\nObject.defineProperty(exports, \"SVGGraphics\", ({\n  enumerable: true,\n  get: function () {\n    return _api.SVGGraphics;\n  }\n}));\nObject.defineProperty(exports, \"UnexpectedResponseException\", ({\n  enumerable: true,\n  get: function () {\n    return _util.UnexpectedResponseException;\n  }\n}));\nObject.defineProperty(exports, \"Util\", ({\n  enumerable: true,\n  get: function () {\n    return _util.Util;\n  }\n}));\nObject.defineProperty(exports, \"VerbosityLevel\", ({\n  enumerable: true,\n  get: function () {\n    return _util.VerbosityLevel;\n  }\n}));\nObject.defineProperty(exports, \"XfaLayer\", ({\n  enumerable: true,\n  get: function () {\n    return _xfa_layer.XfaLayer;\n  }\n}));\nObject.defineProperty(exports, \"build\", ({\n  enumerable: true,\n  get: function () {\n    return _api.build;\n  }\n}));\nObject.defineProperty(exports, \"createValidAbsoluteUrl\", ({\n  enumerable: true,\n  get: function () {\n    return _util.createValidAbsoluteUrl;\n  }\n}));\nObject.defineProperty(exports, \"getDocument\", ({\n  enumerable: true,\n  get: function () {\n    return _api.getDocument;\n  }\n}));\nObject.defineProperty(exports, \"getFilenameFromUrl\", ({\n  enumerable: true,\n  get: function () {\n    return _display_utils.getFilenameFromUrl;\n  }\n}));\nObject.defineProperty(exports, \"getPdfFilenameFromUrl\", ({\n  enumerable: true,\n  get: function () {\n    return _display_utils.getPdfFilenameFromUrl;\n  }\n}));\nObject.defineProperty(exports, \"getXfaPageViewport\", ({\n  enumerable: true,\n  get: function () {\n    return _display_utils.getXfaPageViewport;\n  }\n}));\nObject.defineProperty(exports, \"isDataScheme\", ({\n  enumerable: true,\n  get: function () {\n    return _display_utils.isDataScheme;\n  }\n}));\nObject.defineProperty(exports, \"isPdfFile\", ({\n  enumerable: true,\n  get: function () {\n    return _display_utils.isPdfFile;\n  }\n}));\nObject.defineProperty(exports, \"loadScript\", ({\n  enumerable: true,\n  get: function () {\n    return _display_utils.loadScript;\n  }\n}));\nObject.defineProperty(exports, \"noContextMenu\", ({\n  enumerable: true,\n  get: function () {\n    return _display_utils.noContextMenu;\n  }\n}));\nObject.defineProperty(exports, \"normalizeUnicode\", ({\n  enumerable: true,\n  get: function () {\n    return _util.normalizeUnicode;\n  }\n}));\nObject.defineProperty(exports, \"renderTextLayer\", ({\n  enumerable: true,\n  get: function () {\n    return _text_layer.renderTextLayer;\n  }\n}));\nObject.defineProperty(exports, \"setLayerDimensions\", ({\n  enumerable: true,\n  get: function () {\n    return _display_utils.setLayerDimensions;\n  }\n}));\nObject.defineProperty(exports, \"shadow\", ({\n  enumerable: true,\n  get: function () {\n    return _util.shadow;\n  }\n}));\nObject.defineProperty(exports, \"updateTextLayer\", ({\n  enumerable: true,\n  get: function () {\n    return _text_layer.updateTextLayer;\n  }\n}));\nObject.defineProperty(exports, \"version\", ({\n  enumerable: true,\n  get: function () {\n    return _api.version;\n  }\n}));\nvar _util = __w_pdfjs_require__(1);\nvar _api = __w_pdfjs_require__(2);\nvar _display_utils = __w_pdfjs_require__(6);\nvar _text_layer = __w_pdfjs_require__(26);\nvar _annotation_editor_layer = __w_pdfjs_require__(27);\nvar _tools = __w_pdfjs_require__(5);\nvar _annotation_layer = __w_pdfjs_require__(29);\nvar _worker_options = __w_pdfjs_require__(14);\nvar _xfa_layer = __w_pdfjs_require__(32);\nconst pdfjsVersion = '3.11.174';\nconst pdfjsBuild = 'ce8716743';\n})();\n\n/******/ \treturn __nested_webpack_exports__;\n/******/ })()\n;\n});\n//# sourceMappingURL=pdf.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1wZGYvbm9kZV9tb2R1bGVzL3BkZmpzLWRpc3QvYnVpbGQvcGRmLmpzIiwibWFwcGluZ3MiOiI7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSSxJQUF5RDtBQUM3RDtBQUNBLE1BQU0sRUFLcUQ7QUFDM0QsQ0FBQztBQUNELHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLE9BQU8saUJBQWlCLE9BQU8saUNBQWlDLE9BQU8sa0JBQWtCLE9BQU8sc0JBQXNCLE9BQU8sU0FBUyxPQUFPO0FBQ3JLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLElBQUk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsSUFBSTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixJQUFJO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixZQUFZO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixZQUFZO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxjQUFjLEVBQUUsY0FBYyxFQUFFLGNBQWM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFFBQVE7QUFDUixvQ0FBb0MsR0FBRztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxRQUFRO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxRQUFRO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsTUFBTSxtQ0FBbUMsTUFBTTtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixnQ0FBZ0M7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLElBQUk7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxJQUFJLElBQUk7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxJQUFJO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksSUFBSTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsUUFBUTtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsNEZBQTRGO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFVBQWM7QUFDdEM7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLElBQUksR0FBRztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLElBQUk7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDZCQUE2QjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0wsZ0ZBQWdGLGVBQWU7QUFDL0YsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsVUFBYztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLE9BQU87QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0UsZUFBZTtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsZ0JBQWdCLEdBQUcsbUNBQW1DO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELGNBQWM7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsS0FBSztBQUNqRTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsS0FBSztBQUMxRDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGlCQUFpQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLE1BQU07QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVHQUF1RyxvQkFBb0I7QUFDM0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsSUFBSSxHQUFHLDJCQUEyQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixRQUFRO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHFCQUFxQjtBQUNsRCw0QkFBNEIscUJBQXFCO0FBQ2pEO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sb0JBQW9CLHFCQUFxQjtBQUN6QyxtQkFBbUIscUJBQXFCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsdUNBQXVDO0FBQ3JFO0FBQ0EsaUNBQWlDLHlDQUF5QztBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLG1EQUFtRDtBQUMxRTtBQUNBO0FBQ0Esd0JBQXdCLHFEQUFxRDtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsUUFBUTtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsOENBQThDO0FBQ2pGLG9DQUFvQyw4Q0FBOEM7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsNkJBQTZCLEVBQUUsV0FBVztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyx3SUFBd0k7QUFDNUs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGFBQWEsR0FBRyxXQUFXO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RSxJQUFJO0FBQzdFO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLHdCQUF3QixhQUFhLEdBQUcsS0FBSyxHQUFHLEtBQUssR0FBRyxLQUFLO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxhQUFhO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixpQ0FBaUMsV0FBVztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ04saUNBQWlDLFdBQVc7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLElBQUk7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsU0FBUztBQUMvQjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsU0FBUztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTyxFQUFFLE9BQU8sRUFBRSxPQUFPO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixZQUFZLGdCQUFnQixXQUFXO0FBQzNELHdCQUF3QixHQUFHO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVEsR0FBRyxRQUFRO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFlBQVk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsUUFBUTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLEdBQUc7QUFDOUI7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVEsR0FBRyxRQUFRLEdBQUcsV0FBVyxHQUFHLFdBQVc7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixRQUFRO0FBQzlCO0FBQ0E7QUFDQSwyQkFBMkIsUUFBUTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixTQUFTO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFlBQVk7QUFDaEM7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLEdBQUc7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxJQUFJO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLElBQUk7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsS0FBSztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELEtBQUs7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04scUJBQXFCLHNCQUFzQixFQUFFLFlBQVk7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsV0FBVztBQUM1RDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELEVBQUUsV0FBVyxFQUFFLFlBQVksRUFBRSxZQUFZLEVBQUUsWUFBWSxFQUFFLFlBQVksRUFBRSwyQkFBMkIsRUFBRSxtQkFBbUIsRUFBRTtBQUM3SztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxNQUFNO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsdUNBQXVDLFVBQVU7QUFDakQsbUNBQW1DLFdBQVc7QUFDOUMseUNBQXlDLEVBQUUsa0JBQWtCLEVBQUU7QUFDL0Qsc0NBQXNDLEVBQUUsa0JBQWtCLEVBQUU7QUFDNUQ7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLG1DQUFtQyxXQUFXLElBQUk7QUFDMUYsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsYUFBYSxFQUFFLFNBQVM7QUFDM0M7QUFDQSxzREFBc0QsSUFBSTtBQUMxRCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsTUFBTTtBQUN6QyxvQ0FBb0MsT0FBTztBQUMzQztBQUNBO0FBQ0EsdUNBQXVDLE9BQU8sRUFBRSxPQUFPO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsUUFBUTtBQUNqRDtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLG9EQUFvRCxrQkFBa0I7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLGtEQUFrRCxzQkFBc0IsTUFBTSxHQUFHO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLFdBQVcsRUFBRSxzQkFBc0I7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFFBQVE7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLFNBQVMsV0FBVyxFQUFFO0FBQzlELDhCQUE4QixlQUFlLGVBQWUsRUFBRSxNQUFNLEtBQUs7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRTtBQUNsRSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsNkJBQTZCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsZUFBZSxTQUFTLFdBQVcsRUFBRTtBQUNqRTtBQUNBO0FBQ0EsMEJBQTBCLGVBQWUsZ0JBQWdCLEVBQUUsTUFBTSxLQUFLO0FBQ3RFLE1BQU07QUFDTixnQ0FBZ0MsNkJBQTZCO0FBQzdEO0FBQ0Esc0NBQXNDLDZCQUE2QixJQUFJO0FBQ3ZFO0FBQ0EsMEJBQTBCLGVBQWUsNEJBQTRCLEVBQUUsRUFBRSxJQUFJLE1BQU0sS0FBSztBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSxHQUFHO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbUJBQU8sQ0FBQyxpQkFBSTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsbUJBQU8sQ0FBQyxxQkFBUTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsV0FBVztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsWUFBWTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixXQUFXO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsV0FBVztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHNCQUFzQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGlCQUFpQjtBQUNqQztBQUNBO0FBQ0Esa0JBQWtCLHFCQUFxQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGtCQUFrQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsZ0JBQWdCLGdCQUFnQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsZ0JBQWdCLGlCQUFpQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLElBQUk7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osdUNBQXVDLGFBQWE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsaUJBQWlCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixZQUFZO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsWUFBWTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsWUFBWTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsY0FBYztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFFBQVE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFlBQVk7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELEtBQUssS0FBSyxxQkFBcUI7QUFDdkY7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsUUFBUSxFQUFFLE1BQU0sRUFBRSxnQkFBZ0IsS0FBSyxTQUFTO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGtCQUFrQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixrQkFBa0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMscUJBQXFCO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFFBQVE7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxRQUFRO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsUUFBUTtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFdBQVc7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsVUFBVTtBQUNoQztBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFVBQVU7QUFDNUI7QUFDQSx3QkFBd0IsVUFBVTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsUUFBUTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsUUFBUTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxNQUFNO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0QsVUFBVTtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsWUFBWTtBQUM5Qiw2Q0FBNkMsY0FBYztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9CQUFvQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGVBQWU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxRQUFRO0FBQ2pEO0FBQ0E7QUFDQSxJQUFJO0FBQ0osV0FBVyxlQUFlO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsUUFBUTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxRQUFRO0FBQzdDO0FBQ0E7QUFDQSxJQUFJO0FBQ0oscUNBQXFDLFFBQVE7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELFdBQVc7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELFlBQVk7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSxXQUFXO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFlBQVk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1IsNkRBQTZELFFBQVE7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsU0FBUztBQUN0RTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLEdBQUc7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLGlFQUFpRSxHQUFHO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxpRUFBaUUsR0FBRztBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsaUVBQWlFLEdBQUc7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxhQUFhO0FBQ3RFO0FBQ0E7QUFDQSwwQ0FBMEMsV0FBVztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxHQUFHO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsR0FBRyxHQUFHLGNBQWM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELElBQUk7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsTUFBTSxHQUFHLFFBQVE7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFLE9BQU8sMEJBQTBCLElBQUk7QUFDbkg7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIscURBQXFELE9BQU87QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvQkFBb0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGtCQUFrQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxFQUFFO0FBQ2hEO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsV0FBVyxHQUFHLGFBQWE7QUFDeEU7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLG1CQUFPLENBQUMsc0ZBQUs7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxVQUFVO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FLFVBQVU7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixtQkFBTyxDQUFDLG1CQUFNO0FBQ2pDO0FBQ0EsTUFBTTtBQUNOLG9CQUFvQixtQkFBTyxDQUFDLG9CQUFPO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxNQUFNLEdBQUcsUUFBUTtBQUN4RDtBQUNBO0FBQ0Esb0VBQW9FLFVBQVU7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsbUJBQU8sQ0FBQyxtQkFBTTtBQUNqQztBQUNBLE1BQU07QUFDTixvQkFBb0IsbUJBQU8sQ0FBQyxvQkFBTztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbUJBQU8sQ0FBQyxpQkFBSTtBQUMzQjtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0UsS0FBSztBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbUJBQU8sQ0FBQyxpQkFBSTtBQUMzQjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsdUJBQXVCLGFBQWE7QUFDcEMsb0NBQW9DLFFBQVE7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFNBQVM7QUFDM0I7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsU0FBUztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsU0FBUztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixPQUFPLGtDQUFrQyxNQUFNO0FBQzVFLHFCQUFxQixzREFBMkI7QUFDaEQ7QUFDQSxPQUFPO0FBQ1A7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixZQUFZO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFlBQVk7QUFDbEM7QUFDQSx3QkFBd0IsY0FBYztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFVBQVUsRUFBRSxTQUFTO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixNQUFNO0FBQzdCO0FBQ0EsSUFBSTtBQUNKLHdCQUF3QixVQUFVLEVBQUUsU0FBUztBQUM3QztBQUNBLG1CQUFtQixVQUFVLEVBQUUsVUFBVSxFQUFFLFVBQVUsRUFBRSxVQUFVLEVBQUUsVUFBVSxPQUFPLFNBQVM7QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFFBQVE7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsUUFBUTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxHQUFHO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQscUJBQXFCO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELHFCQUFxQjtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsdURBQXVELHFCQUFxQjtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsZ0JBQWdCLFFBQVEsZUFBZTtBQUNuRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxnQkFBZ0IsbUJBQW1CLEVBQUUsaUJBQWlCLElBQUksSUFBSTtBQUM3RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsZUFBZTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsSUFBSTtBQUM1Qyx3Q0FBd0MsSUFBSTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGVBQWU7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELFFBQVE7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixVQUFVO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLFlBQVk7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxPQUFPO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsdUNBQXVDO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSxJQUFJO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsT0FBTztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsZUFBZSxFQUFFLGdCQUFnQjtBQUN0RjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFlBQVk7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxlQUFlO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGtCQUFrQixLQUFLLFdBQVc7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxRQUFRO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxRQUFRO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsMENBQTBDO0FBQ2pFLHNCQUFzQiwwQ0FBMEM7QUFDaEUsSUFBSTtBQUNKLHVCQUF1QixlQUFlLEVBQUUsZ0JBQWdCO0FBQ3hELHNCQUFzQixlQUFlLEVBQUUsZUFBZTtBQUN0RDtBQUNBLHlCQUF5QixlQUFlLEVBQUUsc0JBQXNCO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxvQkFBb0IsaUJBQWlCLEtBQUssV0FBVztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsNEJBQTRCLDRCQUE0QjtBQUN4RDtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsaUJBQWlCLE9BQU8sVUFBVTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLGdCQUFnQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtGQUErRjtBQUMvRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsUUFBUTtBQUMxRDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFdBQVc7QUFDWDtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsS0FBSztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLDZCQUE2QixlQUFlO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxJQUFJO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSx1Q0FBdUMsdUJBQXVCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixpQkFBaUIsbUNBQW1DLGVBQWU7QUFDbEc7QUFDQSxRQUFRO0FBQ1IsK0JBQStCLE1BQU0sbUNBQW1DLE9BQU87QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLG9DQUFvQztBQUNsRSw2QkFBNkIscUNBQXFDO0FBQ2xFO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxpQ0FBaUMsd0JBQXdCO0FBQ3pELGtDQUFrQywwQkFBMEI7QUFDNUQsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixhQUFhO0FBQzVDLGdDQUFnQyxjQUFjO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFLFVBQVU7QUFDcEY7QUFDQSx5REFBeUQsVUFBVTtBQUNuRSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsNENBQTRDLHNJQUFzSSxZQUFZLGtCQUFrQixZQUFZO0FBQzVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixhQUFhO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFLEVBQUUsT0FBTyxFQUFFLFdBQVcsVUFBVSxZQUFZLFdBQVc7QUFDNUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLEdBQUc7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixRQUFRO0FBQzdCO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RSxHQUFHO0FBQzVFO0FBQ0EseUVBQXlFLEdBQUc7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFLEdBQUc7QUFDMUU7QUFDQTtBQUNBLFVBQVU7QUFDVix5RUFBeUUsR0FBRztBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGlCQUFpQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsVUFBVTtBQUN4RDtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekMsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RSx1QkFBdUIsRUFBRSxHQUFHO0FBQ3JHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELFdBQVc7QUFDdkUsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixvQkFBb0Isc0NBQXNDO0FBQzFELG1CQUFtQixzQ0FBc0M7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxRQUFRO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLEVBQUUsR0FBRyxFQUFFO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSx1QkFBdUIsd0JBQXdCLGFBQWEsdURBQXVEO0FBQ25IO0FBQ0EsMkNBQTJDLGlDQUFpQyxHQUFHO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQix1QkFBdUIsRUFBRSxHQUFHO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSxHQUFHO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGtDQUFrQztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsWUFBWTtBQUM5QixxQkFBcUIsYUFBYSxLQUFLLFlBQVk7QUFDbkQsNkJBQTZCLFVBQVUsTUFBTSxTQUFTO0FBQ3RELDZCQUE2QixVQUFVLE1BQU0sU0FBUztBQUN0RCxzQ0FBc0MsTUFBTSxJQUFJLE1BQU07QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxRQUFRLElBQUksV0FBVyxPQUFPLEdBQUcsYUFBYTtBQUNuRywwREFBMEQsUUFBUSxJQUFJLFdBQVcsT0FBTyxHQUFHLE1BQU0sSUFBSSxhQUFhO0FBQ2xIO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixNQUFNO0FBQy9CLDRCQUE0QixNQUFNO0FBQ2xDLDBDQUEwQyxNQUFNO0FBQ2hEO0FBQ0E7QUFDQSw4QkFBOEIsVUFBVSxLQUFLLFFBQVE7QUFDckQsZ0NBQWdDLFVBQVUsS0FBSyxRQUFRO0FBQ3ZELDhDQUE4QyxRQUFRO0FBQ3RELGdEQUFnRCxRQUFRO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsT0FBTztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLE1BQU0sSUFBSSxNQUFNO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxVQUFVO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLG1DQUFtQztBQUNuRTtBQUNBO0FBQ0Esc0NBQXNDLG1DQUFtQztBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLEVBQUUsYUFBYSxFQUFFO0FBQzdDLDBDQUEwQyxjQUFjO0FBQ3hELEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWCxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLDJCQUEyQixnQkFBZ0IsR0FBRyxPQUFPO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyx3Q0FBd0M7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHdDQUF3QztBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixNQUFNLEVBQUUsa0NBQWtDO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHFCQUFxQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxRQUFRO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsUUFBUTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsUUFBUTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFFBQVE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsUUFBUTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsUUFBUTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFFBQVE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFFBQVE7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxRQUFRO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRkFBZ0YsS0FBSztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSwwQkFBbUI7QUFDdkI7QUFDQTtBQUNBLGNBQWMsMEJBQW1COzs7QUFHakM7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQsaUJBQWlCLDBCQUFtQjtBQUNwQyxVQUFVO0FBQ1Y7QUFDQSxDQUFDO0FBQ0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXBkZi9ub2RlX21vZHVsZXMvcGRmanMtZGlzdC9idWlsZC9wZGYuanM/NzY5ZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNzdGFydCBUaGUgZm9sbG93aW5nIGlzIHRoZSBlbnRpcmUgbGljZW5zZSBub3RpY2UgZm9yIHRoZVxuICogSmF2YVNjcmlwdCBjb2RlIGluIHRoaXMgcGFnZVxuICpcbiAqIENvcHlyaWdodCAyMDIzIE1vemlsbGEgRm91bmRhdGlvblxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBAbGljZW5kIFRoZSBhYm92ZSBpcyB0aGUgZW50aXJlIGxpY2Vuc2Ugbm90aWNlIGZvciB0aGVcbiAqIEphdmFTY3JpcHQgY29kZSBpbiB0aGlzIHBhZ2VcbiAqL1xuXG4oZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSByb290LnBkZmpzTGliID0gZmFjdG9yeSgpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoXCJwZGZqcy1kaXN0L2J1aWxkL3BkZlwiLCBbXSwgKCkgPT4geyByZXR1cm4gKHJvb3QucGRmanNMaWIgPSBmYWN0b3J5KCkpOyB9KTtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcInBkZmpzLWRpc3QvYnVpbGQvcGRmXCJdID0gcm9vdC5wZGZqc0xpYiA9IGZhY3RvcnkoKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJwZGZqcy1kaXN0L2J1aWxkL3BkZlwiXSA9IHJvb3QucGRmanNMaWIgPSBmYWN0b3J5KCk7XG59KShnbG9iYWxUaGlzLCAoKSA9PiB7XG5yZXR1cm4gLyoqKioqKi8gKCgpID0+IHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHRcInVzZSBzdHJpY3RcIjtcbi8qKioqKiovIFx0dmFyIF9fd2VicGFja19tb2R1bGVzX18gPSAoW1xuLyogMCAqLyxcbi8qIDEgKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMpID0+IHtcblxuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcbmV4cG9ydHMuVmVyYm9zaXR5TGV2ZWwgPSBleHBvcnRzLlV0aWwgPSBleHBvcnRzLlVua25vd25FcnJvckV4Y2VwdGlvbiA9IGV4cG9ydHMuVW5leHBlY3RlZFJlc3BvbnNlRXhjZXB0aW9uID0gZXhwb3J0cy5UZXh0UmVuZGVyaW5nTW9kZSA9IGV4cG9ydHMuUmVuZGVyaW5nSW50ZW50RmxhZyA9IGV4cG9ydHMuUHJvbWlzZUNhcGFiaWxpdHkgPSBleHBvcnRzLlBlcm1pc3Npb25GbGFnID0gZXhwb3J0cy5QYXNzd29yZFJlc3BvbnNlcyA9IGV4cG9ydHMuUGFzc3dvcmRFeGNlcHRpb24gPSBleHBvcnRzLlBhZ2VBY3Rpb25FdmVudFR5cGUgPSBleHBvcnRzLk9QUyA9IGV4cG9ydHMuTWlzc2luZ1BERkV4Y2VwdGlvbiA9IGV4cG9ydHMuTUFYX0lNQUdFX1NJWkVfVE9fQ0FDSEUgPSBleHBvcnRzLkxJTkVfRkFDVE9SID0gZXhwb3J0cy5MSU5FX0RFU0NFTlRfRkFDVE9SID0gZXhwb3J0cy5JbnZhbGlkUERGRXhjZXB0aW9uID0gZXhwb3J0cy5JbWFnZUtpbmQgPSBleHBvcnRzLklERU5USVRZX01BVFJJWCA9IGV4cG9ydHMuRm9ybWF0RXJyb3IgPSBleHBvcnRzLkZlYXR1cmVUZXN0ID0gZXhwb3J0cy5GT05UX0lERU5USVRZX01BVFJJWCA9IGV4cG9ydHMuRG9jdW1lbnRBY3Rpb25FdmVudFR5cGUgPSBleHBvcnRzLkNNYXBDb21wcmVzc2lvblR5cGUgPSBleHBvcnRzLkJhc2VFeGNlcHRpb24gPSBleHBvcnRzLkJBU0VMSU5FX0ZBQ1RPUiA9IGV4cG9ydHMuQW5ub3RhdGlvblR5cGUgPSBleHBvcnRzLkFubm90YXRpb25SZXBseVR5cGUgPSBleHBvcnRzLkFubm90YXRpb25QcmVmaXggPSBleHBvcnRzLkFubm90YXRpb25Nb2RlID0gZXhwb3J0cy5Bbm5vdGF0aW9uRmxhZyA9IGV4cG9ydHMuQW5ub3RhdGlvbkZpZWxkRmxhZyA9IGV4cG9ydHMuQW5ub3RhdGlvbkVkaXRvclR5cGUgPSBleHBvcnRzLkFubm90YXRpb25FZGl0b3JQcmVmaXggPSBleHBvcnRzLkFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlID0gZXhwb3J0cy5Bbm5vdGF0aW9uQm9yZGVyU3R5bGVUeXBlID0gZXhwb3J0cy5Bbm5vdGF0aW9uQWN0aW9uRXZlbnRUeXBlID0gZXhwb3J0cy5BYm9ydEV4Y2VwdGlvbiA9IHZvaWQgMDtcbmV4cG9ydHMuYXNzZXJ0ID0gYXNzZXJ0O1xuZXhwb3J0cy5ieXRlc1RvU3RyaW5nID0gYnl0ZXNUb1N0cmluZztcbmV4cG9ydHMuY3JlYXRlVmFsaWRBYnNvbHV0ZVVybCA9IGNyZWF0ZVZhbGlkQWJzb2x1dGVVcmw7XG5leHBvcnRzLmdldE1vZGlmaWNhdGlvbkRhdGUgPSBnZXRNb2RpZmljYXRpb25EYXRlO1xuZXhwb3J0cy5nZXRVdWlkID0gZ2V0VXVpZDtcbmV4cG9ydHMuZ2V0VmVyYm9zaXR5TGV2ZWwgPSBnZXRWZXJib3NpdHlMZXZlbDtcbmV4cG9ydHMuaW5mbyA9IGluZm87XG5leHBvcnRzLmlzQXJyYXlCdWZmZXIgPSBpc0FycmF5QnVmZmVyO1xuZXhwb3J0cy5pc0FycmF5RXF1YWwgPSBpc0FycmF5RXF1YWw7XG5leHBvcnRzLmlzTm9kZUpTID0gdm9pZCAwO1xuZXhwb3J0cy5ub3JtYWxpemVVbmljb2RlID0gbm9ybWFsaXplVW5pY29kZTtcbmV4cG9ydHMub2JqZWN0RnJvbU1hcCA9IG9iamVjdEZyb21NYXA7XG5leHBvcnRzLm9iamVjdFNpemUgPSBvYmplY3RTaXplO1xuZXhwb3J0cy5zZXRWZXJib3NpdHlMZXZlbCA9IHNldFZlcmJvc2l0eUxldmVsO1xuZXhwb3J0cy5zaGFkb3cgPSBzaGFkb3c7XG5leHBvcnRzLnN0cmluZzMyID0gc3RyaW5nMzI7XG5leHBvcnRzLnN0cmluZ1RvQnl0ZXMgPSBzdHJpbmdUb0J5dGVzO1xuZXhwb3J0cy5zdHJpbmdUb1BERlN0cmluZyA9IHN0cmluZ1RvUERGU3RyaW5nO1xuZXhwb3J0cy5zdHJpbmdUb1VURjhTdHJpbmcgPSBzdHJpbmdUb1VURjhTdHJpbmc7XG5leHBvcnRzLnVucmVhY2hhYmxlID0gdW5yZWFjaGFibGU7XG5leHBvcnRzLnV0ZjhTdHJpbmdUb1N0cmluZyA9IHV0ZjhTdHJpbmdUb1N0cmluZztcbmV4cG9ydHMud2FybiA9IHdhcm47XG5jb25zdCBpc05vZGVKUyA9IHR5cGVvZiBwcm9jZXNzID09PSBcIm9iamVjdFwiICYmIHByb2Nlc3MgKyBcIlwiID09PSBcIltvYmplY3QgcHJvY2Vzc11cIiAmJiAhcHJvY2Vzcy52ZXJzaW9ucy5udyAmJiAhKHByb2Nlc3MudmVyc2lvbnMuZWxlY3Ryb24gJiYgcHJvY2Vzcy50eXBlICYmIHByb2Nlc3MudHlwZSAhPT0gXCJicm93c2VyXCIpO1xuZXhwb3J0cy5pc05vZGVKUyA9IGlzTm9kZUpTO1xuY29uc3QgSURFTlRJVFlfTUFUUklYID0gWzEsIDAsIDAsIDEsIDAsIDBdO1xuZXhwb3J0cy5JREVOVElUWV9NQVRSSVggPSBJREVOVElUWV9NQVRSSVg7XG5jb25zdCBGT05UX0lERU5USVRZX01BVFJJWCA9IFswLjAwMSwgMCwgMCwgMC4wMDEsIDAsIDBdO1xuZXhwb3J0cy5GT05UX0lERU5USVRZX01BVFJJWCA9IEZPTlRfSURFTlRJVFlfTUFUUklYO1xuY29uc3QgTUFYX0lNQUdFX1NJWkVfVE9fQ0FDSEUgPSAxMGU2O1xuZXhwb3J0cy5NQVhfSU1BR0VfU0laRV9UT19DQUNIRSA9IE1BWF9JTUFHRV9TSVpFX1RPX0NBQ0hFO1xuY29uc3QgTElORV9GQUNUT1IgPSAxLjM1O1xuZXhwb3J0cy5MSU5FX0ZBQ1RPUiA9IExJTkVfRkFDVE9SO1xuY29uc3QgTElORV9ERVNDRU5UX0ZBQ1RPUiA9IDAuMzU7XG5leHBvcnRzLkxJTkVfREVTQ0VOVF9GQUNUT1IgPSBMSU5FX0RFU0NFTlRfRkFDVE9SO1xuY29uc3QgQkFTRUxJTkVfRkFDVE9SID0gTElORV9ERVNDRU5UX0ZBQ1RPUiAvIExJTkVfRkFDVE9SO1xuZXhwb3J0cy5CQVNFTElORV9GQUNUT1IgPSBCQVNFTElORV9GQUNUT1I7XG5jb25zdCBSZW5kZXJpbmdJbnRlbnRGbGFnID0ge1xuICBBTlk6IDB4MDEsXG4gIERJU1BMQVk6IDB4MDIsXG4gIFBSSU5UOiAweDA0LFxuICBTQVZFOiAweDA4LFxuICBBTk5PVEFUSU9OU19GT1JNUzogMHgxMCxcbiAgQU5OT1RBVElPTlNfU1RPUkFHRTogMHgyMCxcbiAgQU5OT1RBVElPTlNfRElTQUJMRTogMHg0MCxcbiAgT1BMSVNUOiAweDEwMFxufTtcbmV4cG9ydHMuUmVuZGVyaW5nSW50ZW50RmxhZyA9IFJlbmRlcmluZ0ludGVudEZsYWc7XG5jb25zdCBBbm5vdGF0aW9uTW9kZSA9IHtcbiAgRElTQUJMRTogMCxcbiAgRU5BQkxFOiAxLFxuICBFTkFCTEVfRk9STVM6IDIsXG4gIEVOQUJMRV9TVE9SQUdFOiAzXG59O1xuZXhwb3J0cy5Bbm5vdGF0aW9uTW9kZSA9IEFubm90YXRpb25Nb2RlO1xuY29uc3QgQW5ub3RhdGlvbkVkaXRvclByZWZpeCA9IFwicGRmanNfaW50ZXJuYWxfZWRpdG9yX1wiO1xuZXhwb3J0cy5Bbm5vdGF0aW9uRWRpdG9yUHJlZml4ID0gQW5ub3RhdGlvbkVkaXRvclByZWZpeDtcbmNvbnN0IEFubm90YXRpb25FZGl0b3JUeXBlID0ge1xuICBESVNBQkxFOiAtMSxcbiAgTk9ORTogMCxcbiAgRlJFRVRFWFQ6IDMsXG4gIFNUQU1QOiAxMyxcbiAgSU5LOiAxNVxufTtcbmV4cG9ydHMuQW5ub3RhdGlvbkVkaXRvclR5cGUgPSBBbm5vdGF0aW9uRWRpdG9yVHlwZTtcbmNvbnN0IEFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlID0ge1xuICBSRVNJWkU6IDEsXG4gIENSRUFURTogMixcbiAgRlJFRVRFWFRfU0laRTogMTEsXG4gIEZSRUVURVhUX0NPTE9SOiAxMixcbiAgRlJFRVRFWFRfT1BBQ0lUWTogMTMsXG4gIElOS19DT0xPUjogMjEsXG4gIElOS19USElDS05FU1M6IDIyLFxuICBJTktfT1BBQ0lUWTogMjNcbn07XG5leHBvcnRzLkFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlID0gQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGU7XG5jb25zdCBQZXJtaXNzaW9uRmxhZyA9IHtcbiAgUFJJTlQ6IDB4MDQsXG4gIE1PRElGWV9DT05URU5UUzogMHgwOCxcbiAgQ09QWTogMHgxMCxcbiAgTU9ESUZZX0FOTk9UQVRJT05TOiAweDIwLFxuICBGSUxMX0lOVEVSQUNUSVZFX0ZPUk1TOiAweDEwMCxcbiAgQ09QWV9GT1JfQUNDRVNTSUJJTElUWTogMHgyMDAsXG4gIEFTU0VNQkxFOiAweDQwMCxcbiAgUFJJTlRfSElHSF9RVUFMSVRZOiAweDgwMFxufTtcbmV4cG9ydHMuUGVybWlzc2lvbkZsYWcgPSBQZXJtaXNzaW9uRmxhZztcbmNvbnN0IFRleHRSZW5kZXJpbmdNb2RlID0ge1xuICBGSUxMOiAwLFxuICBTVFJPS0U6IDEsXG4gIEZJTExfU1RST0tFOiAyLFxuICBJTlZJU0lCTEU6IDMsXG4gIEZJTExfQUREX1RPX1BBVEg6IDQsXG4gIFNUUk9LRV9BRERfVE9fUEFUSDogNSxcbiAgRklMTF9TVFJPS0VfQUREX1RPX1BBVEg6IDYsXG4gIEFERF9UT19QQVRIOiA3LFxuICBGSUxMX1NUUk9LRV9NQVNLOiAzLFxuICBBRERfVE9fUEFUSF9GTEFHOiA0XG59O1xuZXhwb3J0cy5UZXh0UmVuZGVyaW5nTW9kZSA9IFRleHRSZW5kZXJpbmdNb2RlO1xuY29uc3QgSW1hZ2VLaW5kID0ge1xuICBHUkFZU0NBTEVfMUJQUDogMSxcbiAgUkdCXzI0QlBQOiAyLFxuICBSR0JBXzMyQlBQOiAzXG59O1xuZXhwb3J0cy5JbWFnZUtpbmQgPSBJbWFnZUtpbmQ7XG5jb25zdCBBbm5vdGF0aW9uVHlwZSA9IHtcbiAgVEVYVDogMSxcbiAgTElOSzogMixcbiAgRlJFRVRFWFQ6IDMsXG4gIExJTkU6IDQsXG4gIFNRVUFSRTogNSxcbiAgQ0lSQ0xFOiA2LFxuICBQT0xZR09OOiA3LFxuICBQT0xZTElORTogOCxcbiAgSElHSExJR0hUOiA5LFxuICBVTkRFUkxJTkU6IDEwLFxuICBTUVVJR0dMWTogMTEsXG4gIFNUUklLRU9VVDogMTIsXG4gIFNUQU1QOiAxMyxcbiAgQ0FSRVQ6IDE0LFxuICBJTks6IDE1LFxuICBQT1BVUDogMTYsXG4gIEZJTEVBVFRBQ0hNRU5UOiAxNyxcbiAgU09VTkQ6IDE4LFxuICBNT1ZJRTogMTksXG4gIFdJREdFVDogMjAsXG4gIFNDUkVFTjogMjEsXG4gIFBSSU5URVJNQVJLOiAyMixcbiAgVFJBUE5FVDogMjMsXG4gIFdBVEVSTUFSSzogMjQsXG4gIFRIUkVFRDogMjUsXG4gIFJFREFDVDogMjZcbn07XG5leHBvcnRzLkFubm90YXRpb25UeXBlID0gQW5ub3RhdGlvblR5cGU7XG5jb25zdCBBbm5vdGF0aW9uUmVwbHlUeXBlID0ge1xuICBHUk9VUDogXCJHcm91cFwiLFxuICBSRVBMWTogXCJSXCJcbn07XG5leHBvcnRzLkFubm90YXRpb25SZXBseVR5cGUgPSBBbm5vdGF0aW9uUmVwbHlUeXBlO1xuY29uc3QgQW5ub3RhdGlvbkZsYWcgPSB7XG4gIElOVklTSUJMRTogMHgwMSxcbiAgSElEREVOOiAweDAyLFxuICBQUklOVDogMHgwNCxcbiAgTk9aT09NOiAweDA4LFxuICBOT1JPVEFURTogMHgxMCxcbiAgTk9WSUVXOiAweDIwLFxuICBSRUFET05MWTogMHg0MCxcbiAgTE9DS0VEOiAweDgwLFxuICBUT0dHTEVOT1ZJRVc6IDB4MTAwLFxuICBMT0NLRURDT05URU5UUzogMHgyMDBcbn07XG5leHBvcnRzLkFubm90YXRpb25GbGFnID0gQW5ub3RhdGlvbkZsYWc7XG5jb25zdCBBbm5vdGF0aW9uRmllbGRGbGFnID0ge1xuICBSRUFET05MWTogMHgwMDAwMDAxLFxuICBSRVFVSVJFRDogMHgwMDAwMDAyLFxuICBOT0VYUE9SVDogMHgwMDAwMDA0LFxuICBNVUxUSUxJTkU6IDB4MDAwMTAwMCxcbiAgUEFTU1dPUkQ6IDB4MDAwMjAwMCxcbiAgTk9UT0dHTEVUT09GRjogMHgwMDA0MDAwLFxuICBSQURJTzogMHgwMDA4MDAwLFxuICBQVVNIQlVUVE9OOiAweDAwMTAwMDAsXG4gIENPTUJPOiAweDAwMjAwMDAsXG4gIEVESVQ6IDB4MDA0MDAwMCxcbiAgU09SVDogMHgwMDgwMDAwLFxuICBGSUxFU0VMRUNUOiAweDAxMDAwMDAsXG4gIE1VTFRJU0VMRUNUOiAweDAyMDAwMDAsXG4gIERPTk9UU1BFTExDSEVDSzogMHgwNDAwMDAwLFxuICBET05PVFNDUk9MTDogMHgwODAwMDAwLFxuICBDT01COiAweDEwMDAwMDAsXG4gIFJJQ0hURVhUOiAweDIwMDAwMDAsXG4gIFJBRElPU0lOVU5JU09OOiAweDIwMDAwMDAsXG4gIENPTU1JVE9OU0VMQ0hBTkdFOiAweDQwMDAwMDBcbn07XG5leHBvcnRzLkFubm90YXRpb25GaWVsZEZsYWcgPSBBbm5vdGF0aW9uRmllbGRGbGFnO1xuY29uc3QgQW5ub3RhdGlvbkJvcmRlclN0eWxlVHlwZSA9IHtcbiAgU09MSUQ6IDEsXG4gIERBU0hFRDogMixcbiAgQkVWRUxFRDogMyxcbiAgSU5TRVQ6IDQsXG4gIFVOREVSTElORTogNVxufTtcbmV4cG9ydHMuQW5ub3RhdGlvbkJvcmRlclN0eWxlVHlwZSA9IEFubm90YXRpb25Cb3JkZXJTdHlsZVR5cGU7XG5jb25zdCBBbm5vdGF0aW9uQWN0aW9uRXZlbnRUeXBlID0ge1xuICBFOiBcIk1vdXNlIEVudGVyXCIsXG4gIFg6IFwiTW91c2UgRXhpdFwiLFxuICBEOiBcIk1vdXNlIERvd25cIixcbiAgVTogXCJNb3VzZSBVcFwiLFxuICBGbzogXCJGb2N1c1wiLFxuICBCbDogXCJCbHVyXCIsXG4gIFBPOiBcIlBhZ2VPcGVuXCIsXG4gIFBDOiBcIlBhZ2VDbG9zZVwiLFxuICBQVjogXCJQYWdlVmlzaWJsZVwiLFxuICBQSTogXCJQYWdlSW52aXNpYmxlXCIsXG4gIEs6IFwiS2V5c3Ryb2tlXCIsXG4gIEY6IFwiRm9ybWF0XCIsXG4gIFY6IFwiVmFsaWRhdGVcIixcbiAgQzogXCJDYWxjdWxhdGVcIlxufTtcbmV4cG9ydHMuQW5ub3RhdGlvbkFjdGlvbkV2ZW50VHlwZSA9IEFubm90YXRpb25BY3Rpb25FdmVudFR5cGU7XG5jb25zdCBEb2N1bWVudEFjdGlvbkV2ZW50VHlwZSA9IHtcbiAgV0M6IFwiV2lsbENsb3NlXCIsXG4gIFdTOiBcIldpbGxTYXZlXCIsXG4gIERTOiBcIkRpZFNhdmVcIixcbiAgV1A6IFwiV2lsbFByaW50XCIsXG4gIERQOiBcIkRpZFByaW50XCJcbn07XG5leHBvcnRzLkRvY3VtZW50QWN0aW9uRXZlbnRUeXBlID0gRG9jdW1lbnRBY3Rpb25FdmVudFR5cGU7XG5jb25zdCBQYWdlQWN0aW9uRXZlbnRUeXBlID0ge1xuICBPOiBcIlBhZ2VPcGVuXCIsXG4gIEM6IFwiUGFnZUNsb3NlXCJcbn07XG5leHBvcnRzLlBhZ2VBY3Rpb25FdmVudFR5cGUgPSBQYWdlQWN0aW9uRXZlbnRUeXBlO1xuY29uc3QgVmVyYm9zaXR5TGV2ZWwgPSB7XG4gIEVSUk9SUzogMCxcbiAgV0FSTklOR1M6IDEsXG4gIElORk9TOiA1XG59O1xuZXhwb3J0cy5WZXJib3NpdHlMZXZlbCA9IFZlcmJvc2l0eUxldmVsO1xuY29uc3QgQ01hcENvbXByZXNzaW9uVHlwZSA9IHtcbiAgTk9ORTogMCxcbiAgQklOQVJZOiAxXG59O1xuZXhwb3J0cy5DTWFwQ29tcHJlc3Npb25UeXBlID0gQ01hcENvbXByZXNzaW9uVHlwZTtcbmNvbnN0IE9QUyA9IHtcbiAgZGVwZW5kZW5jeTogMSxcbiAgc2V0TGluZVdpZHRoOiAyLFxuICBzZXRMaW5lQ2FwOiAzLFxuICBzZXRMaW5lSm9pbjogNCxcbiAgc2V0TWl0ZXJMaW1pdDogNSxcbiAgc2V0RGFzaDogNixcbiAgc2V0UmVuZGVyaW5nSW50ZW50OiA3LFxuICBzZXRGbGF0bmVzczogOCxcbiAgc2V0R1N0YXRlOiA5LFxuICBzYXZlOiAxMCxcbiAgcmVzdG9yZTogMTEsXG4gIHRyYW5zZm9ybTogMTIsXG4gIG1vdmVUbzogMTMsXG4gIGxpbmVUbzogMTQsXG4gIGN1cnZlVG86IDE1LFxuICBjdXJ2ZVRvMjogMTYsXG4gIGN1cnZlVG8zOiAxNyxcbiAgY2xvc2VQYXRoOiAxOCxcbiAgcmVjdGFuZ2xlOiAxOSxcbiAgc3Ryb2tlOiAyMCxcbiAgY2xvc2VTdHJva2U6IDIxLFxuICBmaWxsOiAyMixcbiAgZW9GaWxsOiAyMyxcbiAgZmlsbFN0cm9rZTogMjQsXG4gIGVvRmlsbFN0cm9rZTogMjUsXG4gIGNsb3NlRmlsbFN0cm9rZTogMjYsXG4gIGNsb3NlRU9GaWxsU3Ryb2tlOiAyNyxcbiAgZW5kUGF0aDogMjgsXG4gIGNsaXA6IDI5LFxuICBlb0NsaXA6IDMwLFxuICBiZWdpblRleHQ6IDMxLFxuICBlbmRUZXh0OiAzMixcbiAgc2V0Q2hhclNwYWNpbmc6IDMzLFxuICBzZXRXb3JkU3BhY2luZzogMzQsXG4gIHNldEhTY2FsZTogMzUsXG4gIHNldExlYWRpbmc6IDM2LFxuICBzZXRGb250OiAzNyxcbiAgc2V0VGV4dFJlbmRlcmluZ01vZGU6IDM4LFxuICBzZXRUZXh0UmlzZTogMzksXG4gIG1vdmVUZXh0OiA0MCxcbiAgc2V0TGVhZGluZ01vdmVUZXh0OiA0MSxcbiAgc2V0VGV4dE1hdHJpeDogNDIsXG4gIG5leHRMaW5lOiA0MyxcbiAgc2hvd1RleHQ6IDQ0LFxuICBzaG93U3BhY2VkVGV4dDogNDUsXG4gIG5leHRMaW5lU2hvd1RleHQ6IDQ2LFxuICBuZXh0TGluZVNldFNwYWNpbmdTaG93VGV4dDogNDcsXG4gIHNldENoYXJXaWR0aDogNDgsXG4gIHNldENoYXJXaWR0aEFuZEJvdW5kczogNDksXG4gIHNldFN0cm9rZUNvbG9yU3BhY2U6IDUwLFxuICBzZXRGaWxsQ29sb3JTcGFjZTogNTEsXG4gIHNldFN0cm9rZUNvbG9yOiA1MixcbiAgc2V0U3Ryb2tlQ29sb3JOOiA1MyxcbiAgc2V0RmlsbENvbG9yOiA1NCxcbiAgc2V0RmlsbENvbG9yTjogNTUsXG4gIHNldFN0cm9rZUdyYXk6IDU2LFxuICBzZXRGaWxsR3JheTogNTcsXG4gIHNldFN0cm9rZVJHQkNvbG9yOiA1OCxcbiAgc2V0RmlsbFJHQkNvbG9yOiA1OSxcbiAgc2V0U3Ryb2tlQ01ZS0NvbG9yOiA2MCxcbiAgc2V0RmlsbENNWUtDb2xvcjogNjEsXG4gIHNoYWRpbmdGaWxsOiA2MixcbiAgYmVnaW5JbmxpbmVJbWFnZTogNjMsXG4gIGJlZ2luSW1hZ2VEYXRhOiA2NCxcbiAgZW5kSW5saW5lSW1hZ2U6IDY1LFxuICBwYWludFhPYmplY3Q6IDY2LFxuICBtYXJrUG9pbnQ6IDY3LFxuICBtYXJrUG9pbnRQcm9wczogNjgsXG4gIGJlZ2luTWFya2VkQ29udGVudDogNjksXG4gIGJlZ2luTWFya2VkQ29udGVudFByb3BzOiA3MCxcbiAgZW5kTWFya2VkQ29udGVudDogNzEsXG4gIGJlZ2luQ29tcGF0OiA3MixcbiAgZW5kQ29tcGF0OiA3MyxcbiAgcGFpbnRGb3JtWE9iamVjdEJlZ2luOiA3NCxcbiAgcGFpbnRGb3JtWE9iamVjdEVuZDogNzUsXG4gIGJlZ2luR3JvdXA6IDc2LFxuICBlbmRHcm91cDogNzcsXG4gIGJlZ2luQW5ub3RhdGlvbjogODAsXG4gIGVuZEFubm90YXRpb246IDgxLFxuICBwYWludEltYWdlTWFza1hPYmplY3Q6IDgzLFxuICBwYWludEltYWdlTWFza1hPYmplY3RHcm91cDogODQsXG4gIHBhaW50SW1hZ2VYT2JqZWN0OiA4NSxcbiAgcGFpbnRJbmxpbmVJbWFnZVhPYmplY3Q6IDg2LFxuICBwYWludElubGluZUltYWdlWE9iamVjdEdyb3VwOiA4NyxcbiAgcGFpbnRJbWFnZVhPYmplY3RSZXBlYXQ6IDg4LFxuICBwYWludEltYWdlTWFza1hPYmplY3RSZXBlYXQ6IDg5LFxuICBwYWludFNvbGlkQ29sb3JJbWFnZU1hc2s6IDkwLFxuICBjb25zdHJ1Y3RQYXRoOiA5MVxufTtcbmV4cG9ydHMuT1BTID0gT1BTO1xuY29uc3QgUGFzc3dvcmRSZXNwb25zZXMgPSB7XG4gIE5FRURfUEFTU1dPUkQ6IDEsXG4gIElOQ09SUkVDVF9QQVNTV09SRDogMlxufTtcbmV4cG9ydHMuUGFzc3dvcmRSZXNwb25zZXMgPSBQYXNzd29yZFJlc3BvbnNlcztcbmxldCB2ZXJib3NpdHkgPSBWZXJib3NpdHlMZXZlbC5XQVJOSU5HUztcbmZ1bmN0aW9uIHNldFZlcmJvc2l0eUxldmVsKGxldmVsKSB7XG4gIGlmIChOdW1iZXIuaXNJbnRlZ2VyKGxldmVsKSkge1xuICAgIHZlcmJvc2l0eSA9IGxldmVsO1xuICB9XG59XG5mdW5jdGlvbiBnZXRWZXJib3NpdHlMZXZlbCgpIHtcbiAgcmV0dXJuIHZlcmJvc2l0eTtcbn1cbmZ1bmN0aW9uIGluZm8obXNnKSB7XG4gIGlmICh2ZXJib3NpdHkgPj0gVmVyYm9zaXR5TGV2ZWwuSU5GT1MpIHtcbiAgICBjb25zb2xlLmxvZyhgSW5mbzogJHttc2d9YCk7XG4gIH1cbn1cbmZ1bmN0aW9uIHdhcm4obXNnKSB7XG4gIGlmICh2ZXJib3NpdHkgPj0gVmVyYm9zaXR5TGV2ZWwuV0FSTklOR1MpIHtcbiAgICBjb25zb2xlLmxvZyhgV2FybmluZzogJHttc2d9YCk7XG4gIH1cbn1cbmZ1bmN0aW9uIHVucmVhY2hhYmxlKG1zZykge1xuICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbn1cbmZ1bmN0aW9uIGFzc2VydChjb25kLCBtc2cpIHtcbiAgaWYgKCFjb25kKSB7XG4gICAgdW5yZWFjaGFibGUobXNnKTtcbiAgfVxufVxuZnVuY3Rpb24gX2lzVmFsaWRQcm90b2NvbCh1cmwpIHtcbiAgc3dpdGNoICh1cmw/LnByb3RvY29sKSB7XG4gICAgY2FzZSBcImh0dHA6XCI6XG4gICAgY2FzZSBcImh0dHBzOlwiOlxuICAgIGNhc2UgXCJmdHA6XCI6XG4gICAgY2FzZSBcIm1haWx0bzpcIjpcbiAgICBjYXNlIFwidGVsOlwiOlxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuZnVuY3Rpb24gY3JlYXRlVmFsaWRBYnNvbHV0ZVVybCh1cmwsIGJhc2VVcmwgPSBudWxsLCBvcHRpb25zID0gbnVsbCkge1xuICBpZiAoIXVybCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHRyeSB7XG4gICAgaWYgKG9wdGlvbnMgJiYgdHlwZW9mIHVybCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgaWYgKG9wdGlvbnMuYWRkRGVmYXVsdFByb3RvY29sICYmIHVybC5zdGFydHNXaXRoKFwid3d3LlwiKSkge1xuICAgICAgICBjb25zdCBkb3RzID0gdXJsLm1hdGNoKC9cXC4vZyk7XG4gICAgICAgIGlmIChkb3RzPy5sZW5ndGggPj0gMikge1xuICAgICAgICAgIHVybCA9IGBodHRwOi8vJHt1cmx9YDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMudHJ5Q29udmVydEVuY29kaW5nKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdXJsID0gc3RyaW5nVG9VVEY4U3RyaW5nKHVybCk7XG4gICAgICAgIH0gY2F0Y2gge31cbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgYWJzb2x1dGVVcmwgPSBiYXNlVXJsID8gbmV3IFVSTCh1cmwsIGJhc2VVcmwpIDogbmV3IFVSTCh1cmwpO1xuICAgIGlmIChfaXNWYWxpZFByb3RvY29sKGFic29sdXRlVXJsKSkge1xuICAgICAgcmV0dXJuIGFic29sdXRlVXJsO1xuICAgIH1cbiAgfSBjYXRjaCB7fVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIHNoYWRvdyhvYmosIHByb3AsIHZhbHVlLCBub25TZXJpYWxpemFibGUgPSBmYWxzZSkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBwcm9wLCB7XG4gICAgdmFsdWUsXG4gICAgZW51bWVyYWJsZTogIW5vblNlcmlhbGl6YWJsZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgd3JpdGFibGU6IGZhbHNlXG4gIH0pO1xuICByZXR1cm4gdmFsdWU7XG59XG5jb25zdCBCYXNlRXhjZXB0aW9uID0gZnVuY3Rpb24gQmFzZUV4Y2VwdGlvbkNsb3N1cmUoKSB7XG4gIGZ1bmN0aW9uIEJhc2VFeGNlcHRpb24obWVzc2FnZSwgbmFtZSkge1xuICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yID09PSBCYXNlRXhjZXB0aW9uKSB7XG4gICAgICB1bnJlYWNoYWJsZShcIkNhbm5vdCBpbml0aWFsaXplIEJhc2VFeGNlcHRpb24uXCIpO1xuICAgIH1cbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gIH1cbiAgQmFzZUV4Y2VwdGlvbi5wcm90b3R5cGUgPSBuZXcgRXJyb3IoKTtcbiAgQmFzZUV4Y2VwdGlvbi5jb25zdHJ1Y3RvciA9IEJhc2VFeGNlcHRpb247XG4gIHJldHVybiBCYXNlRXhjZXB0aW9uO1xufSgpO1xuZXhwb3J0cy5CYXNlRXhjZXB0aW9uID0gQmFzZUV4Y2VwdGlvbjtcbmNsYXNzIFBhc3N3b3JkRXhjZXB0aW9uIGV4dGVuZHMgQmFzZUV4Y2VwdGlvbiB7XG4gIGNvbnN0cnVjdG9yKG1zZywgY29kZSkge1xuICAgIHN1cGVyKG1zZywgXCJQYXNzd29yZEV4Y2VwdGlvblwiKTtcbiAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICB9XG59XG5leHBvcnRzLlBhc3N3b3JkRXhjZXB0aW9uID0gUGFzc3dvcmRFeGNlcHRpb247XG5jbGFzcyBVbmtub3duRXJyb3JFeGNlcHRpb24gZXh0ZW5kcyBCYXNlRXhjZXB0aW9uIHtcbiAgY29uc3RydWN0b3IobXNnLCBkZXRhaWxzKSB7XG4gICAgc3VwZXIobXNnLCBcIlVua25vd25FcnJvckV4Y2VwdGlvblwiKTtcbiAgICB0aGlzLmRldGFpbHMgPSBkZXRhaWxzO1xuICB9XG59XG5leHBvcnRzLlVua25vd25FcnJvckV4Y2VwdGlvbiA9IFVua25vd25FcnJvckV4Y2VwdGlvbjtcbmNsYXNzIEludmFsaWRQREZFeGNlcHRpb24gZXh0ZW5kcyBCYXNlRXhjZXB0aW9uIHtcbiAgY29uc3RydWN0b3IobXNnKSB7XG4gICAgc3VwZXIobXNnLCBcIkludmFsaWRQREZFeGNlcHRpb25cIik7XG4gIH1cbn1cbmV4cG9ydHMuSW52YWxpZFBERkV4Y2VwdGlvbiA9IEludmFsaWRQREZFeGNlcHRpb247XG5jbGFzcyBNaXNzaW5nUERGRXhjZXB0aW9uIGV4dGVuZHMgQmFzZUV4Y2VwdGlvbiB7XG4gIGNvbnN0cnVjdG9yKG1zZykge1xuICAgIHN1cGVyKG1zZywgXCJNaXNzaW5nUERGRXhjZXB0aW9uXCIpO1xuICB9XG59XG5leHBvcnRzLk1pc3NpbmdQREZFeGNlcHRpb24gPSBNaXNzaW5nUERGRXhjZXB0aW9uO1xuY2xhc3MgVW5leHBlY3RlZFJlc3BvbnNlRXhjZXB0aW9uIGV4dGVuZHMgQmFzZUV4Y2VwdGlvbiB7XG4gIGNvbnN0cnVjdG9yKG1zZywgc3RhdHVzKSB7XG4gICAgc3VwZXIobXNnLCBcIlVuZXhwZWN0ZWRSZXNwb25zZUV4Y2VwdGlvblwiKTtcbiAgICB0aGlzLnN0YXR1cyA9IHN0YXR1cztcbiAgfVxufVxuZXhwb3J0cy5VbmV4cGVjdGVkUmVzcG9uc2VFeGNlcHRpb24gPSBVbmV4cGVjdGVkUmVzcG9uc2VFeGNlcHRpb247XG5jbGFzcyBGb3JtYXRFcnJvciBleHRlbmRzIEJhc2VFeGNlcHRpb24ge1xuICBjb25zdHJ1Y3Rvcihtc2cpIHtcbiAgICBzdXBlcihtc2csIFwiRm9ybWF0RXJyb3JcIik7XG4gIH1cbn1cbmV4cG9ydHMuRm9ybWF0RXJyb3IgPSBGb3JtYXRFcnJvcjtcbmNsYXNzIEFib3J0RXhjZXB0aW9uIGV4dGVuZHMgQmFzZUV4Y2VwdGlvbiB7XG4gIGNvbnN0cnVjdG9yKG1zZykge1xuICAgIHN1cGVyKG1zZywgXCJBYm9ydEV4Y2VwdGlvblwiKTtcbiAgfVxufVxuZXhwb3J0cy5BYm9ydEV4Y2VwdGlvbiA9IEFib3J0RXhjZXB0aW9uO1xuZnVuY3Rpb24gYnl0ZXNUb1N0cmluZyhieXRlcykge1xuICBpZiAodHlwZW9mIGJ5dGVzICE9PSBcIm9iamVjdFwiIHx8IGJ5dGVzPy5sZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIHVucmVhY2hhYmxlKFwiSW52YWxpZCBhcmd1bWVudCBmb3IgYnl0ZXNUb1N0cmluZ1wiKTtcbiAgfVxuICBjb25zdCBsZW5ndGggPSBieXRlcy5sZW5ndGg7XG4gIGNvbnN0IE1BWF9BUkdVTUVOVF9DT1VOVCA9IDgxOTI7XG4gIGlmIChsZW5ndGggPCBNQVhfQVJHVU1FTlRfQ09VTlQpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBieXRlcyk7XG4gIH1cbiAgY29uc3Qgc3RyQnVmID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IE1BWF9BUkdVTUVOVF9DT1VOVCkge1xuICAgIGNvbnN0IGNodW5rRW5kID0gTWF0aC5taW4oaSArIE1BWF9BUkdVTUVOVF9DT1VOVCwgbGVuZ3RoKTtcbiAgICBjb25zdCBjaHVuayA9IGJ5dGVzLnN1YmFycmF5KGksIGNodW5rRW5kKTtcbiAgICBzdHJCdWYucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGNodW5rKSk7XG4gIH1cbiAgcmV0dXJuIHN0ckJ1Zi5qb2luKFwiXCIpO1xufVxuZnVuY3Rpb24gc3RyaW5nVG9CeXRlcyhzdHIpIHtcbiAgaWYgKHR5cGVvZiBzdHIgIT09IFwic3RyaW5nXCIpIHtcbiAgICB1bnJlYWNoYWJsZShcIkludmFsaWQgYXJndW1lbnQgZm9yIHN0cmluZ1RvQnl0ZXNcIik7XG4gIH1cbiAgY29uc3QgbGVuZ3RoID0gc3RyLmxlbmd0aDtcbiAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheShsZW5ndGgpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgYnl0ZXNbaV0gPSBzdHIuY2hhckNvZGVBdChpKSAmIDB4ZmY7XG4gIH1cbiAgcmV0dXJuIGJ5dGVzO1xufVxuZnVuY3Rpb24gc3RyaW5nMzIodmFsdWUpIHtcbiAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUodmFsdWUgPj4gMjQgJiAweGZmLCB2YWx1ZSA+PiAxNiAmIDB4ZmYsIHZhbHVlID4+IDggJiAweGZmLCB2YWx1ZSAmIDB4ZmYpO1xufVxuZnVuY3Rpb24gb2JqZWN0U2l6ZShvYmopIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKG9iaikubGVuZ3RoO1xufVxuZnVuY3Rpb24gb2JqZWN0RnJvbU1hcChtYXApIHtcbiAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgbWFwKSB7XG4gICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgfVxuICByZXR1cm4gb2JqO1xufVxuZnVuY3Rpb24gaXNMaXR0bGVFbmRpYW4oKSB7XG4gIGNvbnN0IGJ1ZmZlcjggPSBuZXcgVWludDhBcnJheSg0KTtcbiAgYnVmZmVyOFswXSA9IDE7XG4gIGNvbnN0IHZpZXczMiA9IG5ldyBVaW50MzJBcnJheShidWZmZXI4LmJ1ZmZlciwgMCwgMSk7XG4gIHJldHVybiB2aWV3MzJbMF0gPT09IDE7XG59XG5mdW5jdGlvbiBpc0V2YWxTdXBwb3J0ZWQoKSB7XG4gIHRyeSB7XG4gICAgbmV3IEZ1bmN0aW9uKFwiXCIpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbmNsYXNzIEZlYXR1cmVUZXN0IHtcbiAgc3RhdGljIGdldCBpc0xpdHRsZUVuZGlhbigpIHtcbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwiaXNMaXR0bGVFbmRpYW5cIiwgaXNMaXR0bGVFbmRpYW4oKSk7XG4gIH1cbiAgc3RhdGljIGdldCBpc0V2YWxTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuIHNoYWRvdyh0aGlzLCBcImlzRXZhbFN1cHBvcnRlZFwiLCBpc0V2YWxTdXBwb3J0ZWQoKSk7XG4gIH1cbiAgc3RhdGljIGdldCBpc09mZnNjcmVlbkNhbnZhc1N1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwiaXNPZmZzY3JlZW5DYW52YXNTdXBwb3J0ZWRcIiwgdHlwZW9mIE9mZnNjcmVlbkNhbnZhcyAhPT0gXCJ1bmRlZmluZWRcIik7XG4gIH1cbiAgc3RhdGljIGdldCBwbGF0Zm9ybSgpIHtcbiAgICBpZiAodHlwZW9mIG5hdmlnYXRvciA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHNoYWRvdyh0aGlzLCBcInBsYXRmb3JtXCIsIHtcbiAgICAgICAgaXNXaW46IGZhbHNlLFxuICAgICAgICBpc01hYzogZmFsc2VcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwicGxhdGZvcm1cIiwge1xuICAgICAgaXNXaW46IG5hdmlnYXRvci5wbGF0Zm9ybS5pbmNsdWRlcyhcIldpblwiKSxcbiAgICAgIGlzTWFjOiBuYXZpZ2F0b3IucGxhdGZvcm0uaW5jbHVkZXMoXCJNYWNcIilcbiAgICB9KTtcbiAgfVxuICBzdGF0aWMgZ2V0IGlzQ1NTUm91bmRTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuIHNoYWRvdyh0aGlzLCBcImlzQ1NTUm91bmRTdXBwb3J0ZWRcIiwgZ2xvYmFsVGhpcy5DU1M/LnN1cHBvcnRzPy4oXCJ3aWR0aDogcm91bmQoMS41cHgsIDFweClcIikpO1xuICB9XG59XG5leHBvcnRzLkZlYXR1cmVUZXN0ID0gRmVhdHVyZVRlc3Q7XG5jb25zdCBoZXhOdW1iZXJzID0gWy4uLkFycmF5KDI1Nikua2V5cygpXS5tYXAobiA9PiBuLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCBcIjBcIikpO1xuY2xhc3MgVXRpbCB7XG4gIHN0YXRpYyBtYWtlSGV4Q29sb3IociwgZywgYikge1xuICAgIHJldHVybiBgIyR7aGV4TnVtYmVyc1tyXX0ke2hleE51bWJlcnNbZ119JHtoZXhOdW1iZXJzW2JdfWA7XG4gIH1cbiAgc3RhdGljIHNjYWxlTWluTWF4KHRyYW5zZm9ybSwgbWluTWF4KSB7XG4gICAgbGV0IHRlbXA7XG4gICAgaWYgKHRyYW5zZm9ybVswXSkge1xuICAgICAgaWYgKHRyYW5zZm9ybVswXSA8IDApIHtcbiAgICAgICAgdGVtcCA9IG1pbk1heFswXTtcbiAgICAgICAgbWluTWF4WzBdID0gbWluTWF4WzFdO1xuICAgICAgICBtaW5NYXhbMV0gPSB0ZW1wO1xuICAgICAgfVxuICAgICAgbWluTWF4WzBdICo9IHRyYW5zZm9ybVswXTtcbiAgICAgIG1pbk1heFsxXSAqPSB0cmFuc2Zvcm1bMF07XG4gICAgICBpZiAodHJhbnNmb3JtWzNdIDwgMCkge1xuICAgICAgICB0ZW1wID0gbWluTWF4WzJdO1xuICAgICAgICBtaW5NYXhbMl0gPSBtaW5NYXhbM107XG4gICAgICAgIG1pbk1heFszXSA9IHRlbXA7XG4gICAgICB9XG4gICAgICBtaW5NYXhbMl0gKj0gdHJhbnNmb3JtWzNdO1xuICAgICAgbWluTWF4WzNdICo9IHRyYW5zZm9ybVszXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGVtcCA9IG1pbk1heFswXTtcbiAgICAgIG1pbk1heFswXSA9IG1pbk1heFsyXTtcbiAgICAgIG1pbk1heFsyXSA9IHRlbXA7XG4gICAgICB0ZW1wID0gbWluTWF4WzFdO1xuICAgICAgbWluTWF4WzFdID0gbWluTWF4WzNdO1xuICAgICAgbWluTWF4WzNdID0gdGVtcDtcbiAgICAgIGlmICh0cmFuc2Zvcm1bMV0gPCAwKSB7XG4gICAgICAgIHRlbXAgPSBtaW5NYXhbMl07XG4gICAgICAgIG1pbk1heFsyXSA9IG1pbk1heFszXTtcbiAgICAgICAgbWluTWF4WzNdID0gdGVtcDtcbiAgICAgIH1cbiAgICAgIG1pbk1heFsyXSAqPSB0cmFuc2Zvcm1bMV07XG4gICAgICBtaW5NYXhbM10gKj0gdHJhbnNmb3JtWzFdO1xuICAgICAgaWYgKHRyYW5zZm9ybVsyXSA8IDApIHtcbiAgICAgICAgdGVtcCA9IG1pbk1heFswXTtcbiAgICAgICAgbWluTWF4WzBdID0gbWluTWF4WzFdO1xuICAgICAgICBtaW5NYXhbMV0gPSB0ZW1wO1xuICAgICAgfVxuICAgICAgbWluTWF4WzBdICo9IHRyYW5zZm9ybVsyXTtcbiAgICAgIG1pbk1heFsxXSAqPSB0cmFuc2Zvcm1bMl07XG4gICAgfVxuICAgIG1pbk1heFswXSArPSB0cmFuc2Zvcm1bNF07XG4gICAgbWluTWF4WzFdICs9IHRyYW5zZm9ybVs0XTtcbiAgICBtaW5NYXhbMl0gKz0gdHJhbnNmb3JtWzVdO1xuICAgIG1pbk1heFszXSArPSB0cmFuc2Zvcm1bNV07XG4gIH1cbiAgc3RhdGljIHRyYW5zZm9ybShtMSwgbTIpIHtcbiAgICByZXR1cm4gW20xWzBdICogbTJbMF0gKyBtMVsyXSAqIG0yWzFdLCBtMVsxXSAqIG0yWzBdICsgbTFbM10gKiBtMlsxXSwgbTFbMF0gKiBtMlsyXSArIG0xWzJdICogbTJbM10sIG0xWzFdICogbTJbMl0gKyBtMVszXSAqIG0yWzNdLCBtMVswXSAqIG0yWzRdICsgbTFbMl0gKiBtMls1XSArIG0xWzRdLCBtMVsxXSAqIG0yWzRdICsgbTFbM10gKiBtMls1XSArIG0xWzVdXTtcbiAgfVxuICBzdGF0aWMgYXBwbHlUcmFuc2Zvcm0ocCwgbSkge1xuICAgIGNvbnN0IHh0ID0gcFswXSAqIG1bMF0gKyBwWzFdICogbVsyXSArIG1bNF07XG4gICAgY29uc3QgeXQgPSBwWzBdICogbVsxXSArIHBbMV0gKiBtWzNdICsgbVs1XTtcbiAgICByZXR1cm4gW3h0LCB5dF07XG4gIH1cbiAgc3RhdGljIGFwcGx5SW52ZXJzZVRyYW5zZm9ybShwLCBtKSB7XG4gICAgY29uc3QgZCA9IG1bMF0gKiBtWzNdIC0gbVsxXSAqIG1bMl07XG4gICAgY29uc3QgeHQgPSAocFswXSAqIG1bM10gLSBwWzFdICogbVsyXSArIG1bMl0gKiBtWzVdIC0gbVs0XSAqIG1bM10pIC8gZDtcbiAgICBjb25zdCB5dCA9ICgtcFswXSAqIG1bMV0gKyBwWzFdICogbVswXSArIG1bNF0gKiBtWzFdIC0gbVs1XSAqIG1bMF0pIC8gZDtcbiAgICByZXR1cm4gW3h0LCB5dF07XG4gIH1cbiAgc3RhdGljIGdldEF4aWFsQWxpZ25lZEJvdW5kaW5nQm94KHIsIG0pIHtcbiAgICBjb25zdCBwMSA9IHRoaXMuYXBwbHlUcmFuc2Zvcm0ociwgbSk7XG4gICAgY29uc3QgcDIgPSB0aGlzLmFwcGx5VHJhbnNmb3JtKHIuc2xpY2UoMiwgNCksIG0pO1xuICAgIGNvbnN0IHAzID0gdGhpcy5hcHBseVRyYW5zZm9ybShbclswXSwgclszXV0sIG0pO1xuICAgIGNvbnN0IHA0ID0gdGhpcy5hcHBseVRyYW5zZm9ybShbclsyXSwgclsxXV0sIG0pO1xuICAgIHJldHVybiBbTWF0aC5taW4ocDFbMF0sIHAyWzBdLCBwM1swXSwgcDRbMF0pLCBNYXRoLm1pbihwMVsxXSwgcDJbMV0sIHAzWzFdLCBwNFsxXSksIE1hdGgubWF4KHAxWzBdLCBwMlswXSwgcDNbMF0sIHA0WzBdKSwgTWF0aC5tYXgocDFbMV0sIHAyWzFdLCBwM1sxXSwgcDRbMV0pXTtcbiAgfVxuICBzdGF0aWMgaW52ZXJzZVRyYW5zZm9ybShtKSB7XG4gICAgY29uc3QgZCA9IG1bMF0gKiBtWzNdIC0gbVsxXSAqIG1bMl07XG4gICAgcmV0dXJuIFttWzNdIC8gZCwgLW1bMV0gLyBkLCAtbVsyXSAvIGQsIG1bMF0gLyBkLCAobVsyXSAqIG1bNV0gLSBtWzRdICogbVszXSkgLyBkLCAobVs0XSAqIG1bMV0gLSBtWzVdICogbVswXSkgLyBkXTtcbiAgfVxuICBzdGF0aWMgc2luZ3VsYXJWYWx1ZURlY29tcG9zZTJkU2NhbGUobSkge1xuICAgIGNvbnN0IHRyYW5zcG9zZSA9IFttWzBdLCBtWzJdLCBtWzFdLCBtWzNdXTtcbiAgICBjb25zdCBhID0gbVswXSAqIHRyYW5zcG9zZVswXSArIG1bMV0gKiB0cmFuc3Bvc2VbMl07XG4gICAgY29uc3QgYiA9IG1bMF0gKiB0cmFuc3Bvc2VbMV0gKyBtWzFdICogdHJhbnNwb3NlWzNdO1xuICAgIGNvbnN0IGMgPSBtWzJdICogdHJhbnNwb3NlWzBdICsgbVszXSAqIHRyYW5zcG9zZVsyXTtcbiAgICBjb25zdCBkID0gbVsyXSAqIHRyYW5zcG9zZVsxXSArIG1bM10gKiB0cmFuc3Bvc2VbM107XG4gICAgY29uc3QgZmlyc3QgPSAoYSArIGQpIC8gMjtcbiAgICBjb25zdCBzZWNvbmQgPSBNYXRoLnNxcnQoKGEgKyBkKSAqKiAyIC0gNCAqIChhICogZCAtIGMgKiBiKSkgLyAyO1xuICAgIGNvbnN0IHN4ID0gZmlyc3QgKyBzZWNvbmQgfHwgMTtcbiAgICBjb25zdCBzeSA9IGZpcnN0IC0gc2Vjb25kIHx8IDE7XG4gICAgcmV0dXJuIFtNYXRoLnNxcnQoc3gpLCBNYXRoLnNxcnQoc3kpXTtcbiAgfVxuICBzdGF0aWMgbm9ybWFsaXplUmVjdChyZWN0KSB7XG4gICAgY29uc3QgciA9IHJlY3Quc2xpY2UoMCk7XG4gICAgaWYgKHJlY3RbMF0gPiByZWN0WzJdKSB7XG4gICAgICByWzBdID0gcmVjdFsyXTtcbiAgICAgIHJbMl0gPSByZWN0WzBdO1xuICAgIH1cbiAgICBpZiAocmVjdFsxXSA+IHJlY3RbM10pIHtcbiAgICAgIHJbMV0gPSByZWN0WzNdO1xuICAgICAgclszXSA9IHJlY3RbMV07XG4gICAgfVxuICAgIHJldHVybiByO1xuICB9XG4gIHN0YXRpYyBpbnRlcnNlY3QocmVjdDEsIHJlY3QyKSB7XG4gICAgY29uc3QgeExvdyA9IE1hdGgubWF4KE1hdGgubWluKHJlY3QxWzBdLCByZWN0MVsyXSksIE1hdGgubWluKHJlY3QyWzBdLCByZWN0MlsyXSkpO1xuICAgIGNvbnN0IHhIaWdoID0gTWF0aC5taW4oTWF0aC5tYXgocmVjdDFbMF0sIHJlY3QxWzJdKSwgTWF0aC5tYXgocmVjdDJbMF0sIHJlY3QyWzJdKSk7XG4gICAgaWYgKHhMb3cgPiB4SGlnaCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHlMb3cgPSBNYXRoLm1heChNYXRoLm1pbihyZWN0MVsxXSwgcmVjdDFbM10pLCBNYXRoLm1pbihyZWN0MlsxXSwgcmVjdDJbM10pKTtcbiAgICBjb25zdCB5SGlnaCA9IE1hdGgubWluKE1hdGgubWF4KHJlY3QxWzFdLCByZWN0MVszXSksIE1hdGgubWF4KHJlY3QyWzFdLCByZWN0MlszXSkpO1xuICAgIGlmICh5TG93ID4geUhpZ2gpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gW3hMb3csIHlMb3csIHhIaWdoLCB5SGlnaF07XG4gIH1cbiAgc3RhdGljIGJlemllckJvdW5kaW5nQm94KHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIsIHgzLCB5Mykge1xuICAgIGNvbnN0IHR2YWx1ZXMgPSBbXSxcbiAgICAgIGJvdW5kcyA9IFtbXSwgW11dO1xuICAgIGxldCBhLCBiLCBjLCB0LCB0MSwgdDIsIGIyYWMsIHNxcnRiMmFjO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMjsgKytpKSB7XG4gICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICBiID0gNiAqIHgwIC0gMTIgKiB4MSArIDYgKiB4MjtcbiAgICAgICAgYSA9IC0zICogeDAgKyA5ICogeDEgLSA5ICogeDIgKyAzICogeDM7XG4gICAgICAgIGMgPSAzICogeDEgLSAzICogeDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBiID0gNiAqIHkwIC0gMTIgKiB5MSArIDYgKiB5MjtcbiAgICAgICAgYSA9IC0zICogeTAgKyA5ICogeTEgLSA5ICogeTIgKyAzICogeTM7XG4gICAgICAgIGMgPSAzICogeTEgLSAzICogeTA7XG4gICAgICB9XG4gICAgICBpZiAoTWF0aC5hYnMoYSkgPCAxZS0xMikge1xuICAgICAgICBpZiAoTWF0aC5hYnMoYikgPCAxZS0xMikge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHQgPSAtYyAvIGI7XG4gICAgICAgIGlmICgwIDwgdCAmJiB0IDwgMSkge1xuICAgICAgICAgIHR2YWx1ZXMucHVzaCh0KTtcbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGIyYWMgPSBiICogYiAtIDQgKiBjICogYTtcbiAgICAgIHNxcnRiMmFjID0gTWF0aC5zcXJ0KGIyYWMpO1xuICAgICAgaWYgKGIyYWMgPCAwKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdDEgPSAoLWIgKyBzcXJ0YjJhYykgLyAoMiAqIGEpO1xuICAgICAgaWYgKDAgPCB0MSAmJiB0MSA8IDEpIHtcbiAgICAgICAgdHZhbHVlcy5wdXNoKHQxKTtcbiAgICAgIH1cbiAgICAgIHQyID0gKC1iIC0gc3FydGIyYWMpIC8gKDIgKiBhKTtcbiAgICAgIGlmICgwIDwgdDIgJiYgdDIgPCAxKSB7XG4gICAgICAgIHR2YWx1ZXMucHVzaCh0Mik7XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBqID0gdHZhbHVlcy5sZW5ndGgsXG4gICAgICBtdDtcbiAgICBjb25zdCBqbGVuID0gajtcbiAgICB3aGlsZSAoai0tKSB7XG4gICAgICB0ID0gdHZhbHVlc1tqXTtcbiAgICAgIG10ID0gMSAtIHQ7XG4gICAgICBib3VuZHNbMF1bal0gPSBtdCAqIG10ICogbXQgKiB4MCArIDMgKiBtdCAqIG10ICogdCAqIHgxICsgMyAqIG10ICogdCAqIHQgKiB4MiArIHQgKiB0ICogdCAqIHgzO1xuICAgICAgYm91bmRzWzFdW2pdID0gbXQgKiBtdCAqIG10ICogeTAgKyAzICogbXQgKiBtdCAqIHQgKiB5MSArIDMgKiBtdCAqIHQgKiB0ICogeTIgKyB0ICogdCAqIHQgKiB5MztcbiAgICB9XG4gICAgYm91bmRzWzBdW2psZW5dID0geDA7XG4gICAgYm91bmRzWzFdW2psZW5dID0geTA7XG4gICAgYm91bmRzWzBdW2psZW4gKyAxXSA9IHgzO1xuICAgIGJvdW5kc1sxXVtqbGVuICsgMV0gPSB5MztcbiAgICBib3VuZHNbMF0ubGVuZ3RoID0gYm91bmRzWzFdLmxlbmd0aCA9IGpsZW4gKyAyO1xuICAgIHJldHVybiBbTWF0aC5taW4oLi4uYm91bmRzWzBdKSwgTWF0aC5taW4oLi4uYm91bmRzWzFdKSwgTWF0aC5tYXgoLi4uYm91bmRzWzBdKSwgTWF0aC5tYXgoLi4uYm91bmRzWzFdKV07XG4gIH1cbn1cbmV4cG9ydHMuVXRpbCA9IFV0aWw7XG5jb25zdCBQREZTdHJpbmdUcmFuc2xhdGVUYWJsZSA9IFswLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAweDJkOCwgMHgyYzcsIDB4MmM2LCAweDJkOSwgMHgyZGQsIDB4MmRiLCAweDJkYSwgMHgyZGMsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDB4MjAyMiwgMHgyMDIwLCAweDIwMjEsIDB4MjAyNiwgMHgyMDE0LCAweDIwMTMsIDB4MTkyLCAweDIwNDQsIDB4MjAzOSwgMHgyMDNhLCAweDIyMTIsIDB4MjAzMCwgMHgyMDFlLCAweDIwMWMsIDB4MjAxZCwgMHgyMDE4LCAweDIwMTksIDB4MjAxYSwgMHgyMTIyLCAweGZiMDEsIDB4ZmIwMiwgMHgxNDEsIDB4MTUyLCAweDE2MCwgMHgxNzgsIDB4MTdkLCAweDEzMSwgMHgxNDIsIDB4MTUzLCAweDE2MSwgMHgxN2UsIDAsIDB4MjBhY107XG5mdW5jdGlvbiBzdHJpbmdUb1BERlN0cmluZyhzdHIpIHtcbiAgaWYgKHN0clswXSA+PSBcIlxceEVGXCIpIHtcbiAgICBsZXQgZW5jb2Rpbmc7XG4gICAgaWYgKHN0clswXSA9PT0gXCJcXHhGRVwiICYmIHN0clsxXSA9PT0gXCJcXHhGRlwiKSB7XG4gICAgICBlbmNvZGluZyA9IFwidXRmLTE2YmVcIjtcbiAgICB9IGVsc2UgaWYgKHN0clswXSA9PT0gXCJcXHhGRlwiICYmIHN0clsxXSA9PT0gXCJcXHhGRVwiKSB7XG4gICAgICBlbmNvZGluZyA9IFwidXRmLTE2bGVcIjtcbiAgICB9IGVsc2UgaWYgKHN0clswXSA9PT0gXCJcXHhFRlwiICYmIHN0clsxXSA9PT0gXCJcXHhCQlwiICYmIHN0clsyXSA9PT0gXCJcXHhCRlwiKSB7XG4gICAgICBlbmNvZGluZyA9IFwidXRmLThcIjtcbiAgICB9XG4gICAgaWYgKGVuY29kaW5nKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKGVuY29kaW5nLCB7XG4gICAgICAgICAgZmF0YWw6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IHN0cmluZ1RvQnl0ZXMoc3RyKTtcbiAgICAgICAgcmV0dXJuIGRlY29kZXIuZGVjb2RlKGJ1ZmZlcik7XG4gICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICB3YXJuKGBzdHJpbmdUb1BERlN0cmluZzogXCIke2V4fVwiLmApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjb25zdCBzdHJCdWYgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDAsIGlpID0gc3RyLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICBjb25zdCBjb2RlID0gUERGU3RyaW5nVHJhbnNsYXRlVGFibGVbc3RyLmNoYXJDb2RlQXQoaSldO1xuICAgIHN0ckJ1Zi5wdXNoKGNvZGUgPyBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpIDogc3RyLmNoYXJBdChpKSk7XG4gIH1cbiAgcmV0dXJuIHN0ckJ1Zi5qb2luKFwiXCIpO1xufVxuZnVuY3Rpb24gc3RyaW5nVG9VVEY4U3RyaW5nKHN0cikge1xuICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KGVzY2FwZShzdHIpKTtcbn1cbmZ1bmN0aW9uIHV0ZjhTdHJpbmdUb1N0cmluZyhzdHIpIHtcbiAgcmV0dXJuIHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChzdHIpKTtcbn1cbmZ1bmN0aW9uIGlzQXJyYXlCdWZmZXIodikge1xuICByZXR1cm4gdHlwZW9mIHYgPT09IFwib2JqZWN0XCIgJiYgdj8uYnl0ZUxlbmd0aCAhPT0gdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gaXNBcnJheUVxdWFsKGFycjEsIGFycjIpIHtcbiAgaWYgKGFycjEubGVuZ3RoICE9PSBhcnIyLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmb3IgKGxldCBpID0gMCwgaWkgPSBhcnIxLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICBpZiAoYXJyMVtpXSAhPT0gYXJyMltpXSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGdldE1vZGlmaWNhdGlvbkRhdGUoZGF0ZSA9IG5ldyBEYXRlKCkpIHtcbiAgY29uc3QgYnVmZmVyID0gW2RhdGUuZ2V0VVRDRnVsbFllYXIoKS50b1N0cmluZygpLCAoZGF0ZS5nZXRVVENNb250aCgpICsgMSkudG9TdHJpbmcoKS5wYWRTdGFydCgyLCBcIjBcIiksIGRhdGUuZ2V0VVRDRGF0ZSgpLnRvU3RyaW5nKCkucGFkU3RhcnQoMiwgXCIwXCIpLCBkYXRlLmdldFVUQ0hvdXJzKCkudG9TdHJpbmcoKS5wYWRTdGFydCgyLCBcIjBcIiksIGRhdGUuZ2V0VVRDTWludXRlcygpLnRvU3RyaW5nKCkucGFkU3RhcnQoMiwgXCIwXCIpLCBkYXRlLmdldFVUQ1NlY29uZHMoKS50b1N0cmluZygpLnBhZFN0YXJ0KDIsIFwiMFwiKV07XG4gIHJldHVybiBidWZmZXIuam9pbihcIlwiKTtcbn1cbmNsYXNzIFByb21pc2VDYXBhYmlsaXR5IHtcbiAgI3NldHRsZWQgPSBmYWxzZTtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5wcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdGhpcy5yZXNvbHZlID0gZGF0YSA9PiB7XG4gICAgICAgIHRoaXMuI3NldHRsZWQgPSB0cnVlO1xuICAgICAgICByZXNvbHZlKGRhdGEpO1xuICAgICAgfTtcbiAgICAgIHRoaXMucmVqZWN0ID0gcmVhc29uID0+IHtcbiAgICAgICAgdGhpcy4jc2V0dGxlZCA9IHRydWU7XG4gICAgICAgIHJlamVjdChyZWFzb24pO1xuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuICBnZXQgc2V0dGxlZCgpIHtcbiAgICByZXR1cm4gdGhpcy4jc2V0dGxlZDtcbiAgfVxufVxuZXhwb3J0cy5Qcm9taXNlQ2FwYWJpbGl0eSA9IFByb21pc2VDYXBhYmlsaXR5O1xubGV0IE5vcm1hbGl6ZVJlZ2V4ID0gbnVsbDtcbmxldCBOb3JtYWxpemF0aW9uTWFwID0gbnVsbDtcbmZ1bmN0aW9uIG5vcm1hbGl6ZVVuaWNvZGUoc3RyKSB7XG4gIGlmICghTm9ybWFsaXplUmVnZXgpIHtcbiAgICBOb3JtYWxpemVSZWdleCA9IC8oW1xcdTAwYTBcXHUwMGI1XFx1MDM3ZVxcdTBlYjNcXHUyMDAwLVxcdTIwMGFcXHUyMDJmXFx1MjEyNlxcdWZiMDAtXFx1ZmIwNFxcdWZiMDZcXHVmYjIwLVxcdWZiMzZcXHVmYjM4LVxcdWZiM2NcXHVmYjNlXFx1ZmI0MC1cXHVmYjQxXFx1ZmI0My1cXHVmYjQ0XFx1ZmI0Ni1cXHVmYmExXFx1ZmJhNC1cXHVmYmE5XFx1ZmJhZS1cXHVmYmIxXFx1ZmJkMy1cXHVmYmRjXFx1ZmJkZS1cXHVmYmU3XFx1ZmJlYS1cXHVmYmY4XFx1ZmJmYy1cXHVmYmZkXFx1ZmMwMC1cXHVmYzVkXFx1ZmM2NC1cXHVmY2YxXFx1ZmNmNS1cXHVmZDNkXFx1ZmQ4OFxcdWZkZjRcXHVmZGZhLVxcdWZkZmJcXHVmZTcxXFx1ZmU3N1xcdWZlNzlcXHVmZTdiXFx1ZmU3ZF0rKXwoXFx1ZmIwNSspL2d1O1xuICAgIE5vcm1hbGl6YXRpb25NYXAgPSBuZXcgTWFwKFtbXCLvrIVcIiwgXCLFv3RcIl1dKTtcbiAgfVxuICByZXR1cm4gc3RyLnJlcGxhY2VBbGwoTm9ybWFsaXplUmVnZXgsIChfLCBwMSwgcDIpID0+IHtcbiAgICByZXR1cm4gcDEgPyBwMS5ub3JtYWxpemUoXCJORktDXCIpIDogTm9ybWFsaXphdGlvbk1hcC5nZXQocDIpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGdldFV1aWQoKSB7XG4gIGlmICh0eXBlb2YgY3J5cHRvICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiBjcnlwdG8/LnJhbmRvbVVVSUQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHJldHVybiBjcnlwdG8ucmFuZG9tVVVJRCgpO1xuICB9XG4gIGNvbnN0IGJ1ZiA9IG5ldyBVaW50OEFycmF5KDMyKTtcbiAgaWYgKHR5cGVvZiBjcnlwdG8gIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIGNyeXB0bz8uZ2V0UmFuZG9tVmFsdWVzID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKGJ1Zik7XG4gIH0gZWxzZSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAzMjsgaSsrKSB7XG4gICAgICBidWZbaV0gPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAyNTUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYnl0ZXNUb1N0cmluZyhidWYpO1xufVxuY29uc3QgQW5ub3RhdGlvblByZWZpeCA9IFwicGRmanNfaW50ZXJuYWxfaWRfXCI7XG5leHBvcnRzLkFubm90YXRpb25QcmVmaXggPSBBbm5vdGF0aW9uUHJlZml4O1xuXG4vKioqLyB9KSxcbi8qIDIgKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pID0+IHtcblxuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcbmV4cG9ydHMuUmVuZGVyVGFzayA9IGV4cG9ydHMuUERGV29ya2VyVXRpbCA9IGV4cG9ydHMuUERGV29ya2VyID0gZXhwb3J0cy5QREZQYWdlUHJveHkgPSBleHBvcnRzLlBERkRvY3VtZW50UHJveHkgPSBleHBvcnRzLlBERkRvY3VtZW50TG9hZGluZ1Rhc2sgPSBleHBvcnRzLlBERkRhdGFSYW5nZVRyYW5zcG9ydCA9IGV4cG9ydHMuTG9vcGJhY2tQb3J0ID0gZXhwb3J0cy5EZWZhdWx0U3RhbmRhcmRGb250RGF0YUZhY3RvcnkgPSBleHBvcnRzLkRlZmF1bHRGaWx0ZXJGYWN0b3J5ID0gZXhwb3J0cy5EZWZhdWx0Q2FudmFzRmFjdG9yeSA9IGV4cG9ydHMuRGVmYXVsdENNYXBSZWFkZXJGYWN0b3J5ID0gdm9pZCAwO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU1ZHR3JhcGhpY3NcIiwgKHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9kaXNwbGF5U3ZnLlNWR0dyYXBoaWNzO1xuICB9XG59KSk7XG5leHBvcnRzLmJ1aWxkID0gdm9pZCAwO1xuZXhwb3J0cy5nZXREb2N1bWVudCA9IGdldERvY3VtZW50O1xuZXhwb3J0cy52ZXJzaW9uID0gdm9pZCAwO1xudmFyIF91dGlsID0gX193X3BkZmpzX3JlcXVpcmVfXygxKTtcbnZhciBfYW5ub3RhdGlvbl9zdG9yYWdlID0gX193X3BkZmpzX3JlcXVpcmVfXygzKTtcbnZhciBfZGlzcGxheV91dGlscyA9IF9fd19wZGZqc19yZXF1aXJlX18oNik7XG52YXIgX2ZvbnRfbG9hZGVyID0gX193X3BkZmpzX3JlcXVpcmVfXyg5KTtcbnZhciBfZGlzcGxheU5vZGVfdXRpbHMgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEwKTtcbnZhciBfY2FudmFzID0gX193X3BkZmpzX3JlcXVpcmVfXygxMSk7XG52YXIgX3dvcmtlcl9vcHRpb25zID0gX193X3BkZmpzX3JlcXVpcmVfXygxNCk7XG52YXIgX21lc3NhZ2VfaGFuZGxlciA9IF9fd19wZGZqc19yZXF1aXJlX18oMTUpO1xudmFyIF9tZXRhZGF0YSA9IF9fd19wZGZqc19yZXF1aXJlX18oMTYpO1xudmFyIF9vcHRpb25hbF9jb250ZW50X2NvbmZpZyA9IF9fd19wZGZqc19yZXF1aXJlX18oMTcpO1xudmFyIF90cmFuc3BvcnRfc3RyZWFtID0gX193X3BkZmpzX3JlcXVpcmVfXygxOCk7XG52YXIgX2Rpc3BsYXlGZXRjaF9zdHJlYW0gPSBfX3dfcGRmanNfcmVxdWlyZV9fKDE5KTtcbnZhciBfZGlzcGxheU5ldHdvcmsgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDIyKTtcbnZhciBfZGlzcGxheU5vZGVfc3RyZWFtID0gX193X3BkZmpzX3JlcXVpcmVfXygyMyk7XG52YXIgX2Rpc3BsYXlTdmcgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDI0KTtcbnZhciBfeGZhX3RleHQgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDI1KTtcbmNvbnN0IERFRkFVTFRfUkFOR0VfQ0hVTktfU0laRSA9IDY1NTM2O1xuY29uc3QgUkVOREVSSU5HX0NBTkNFTExFRF9USU1FT1VUID0gMTAwO1xuY29uc3QgREVMQVlFRF9DTEVBTlVQX1RJTUVPVVQgPSA1MDAwO1xuY29uc3QgRGVmYXVsdENhbnZhc0ZhY3RvcnkgPSBfdXRpbC5pc05vZGVKUyA/IF9kaXNwbGF5Tm9kZV91dGlscy5Ob2RlQ2FudmFzRmFjdG9yeSA6IF9kaXNwbGF5X3V0aWxzLkRPTUNhbnZhc0ZhY3Rvcnk7XG5leHBvcnRzLkRlZmF1bHRDYW52YXNGYWN0b3J5ID0gRGVmYXVsdENhbnZhc0ZhY3Rvcnk7XG5jb25zdCBEZWZhdWx0Q01hcFJlYWRlckZhY3RvcnkgPSBfdXRpbC5pc05vZGVKUyA/IF9kaXNwbGF5Tm9kZV91dGlscy5Ob2RlQ01hcFJlYWRlckZhY3RvcnkgOiBfZGlzcGxheV91dGlscy5ET01DTWFwUmVhZGVyRmFjdG9yeTtcbmV4cG9ydHMuRGVmYXVsdENNYXBSZWFkZXJGYWN0b3J5ID0gRGVmYXVsdENNYXBSZWFkZXJGYWN0b3J5O1xuY29uc3QgRGVmYXVsdEZpbHRlckZhY3RvcnkgPSBfdXRpbC5pc05vZGVKUyA/IF9kaXNwbGF5Tm9kZV91dGlscy5Ob2RlRmlsdGVyRmFjdG9yeSA6IF9kaXNwbGF5X3V0aWxzLkRPTUZpbHRlckZhY3Rvcnk7XG5leHBvcnRzLkRlZmF1bHRGaWx0ZXJGYWN0b3J5ID0gRGVmYXVsdEZpbHRlckZhY3Rvcnk7XG5jb25zdCBEZWZhdWx0U3RhbmRhcmRGb250RGF0YUZhY3RvcnkgPSBfdXRpbC5pc05vZGVKUyA/IF9kaXNwbGF5Tm9kZV91dGlscy5Ob2RlU3RhbmRhcmRGb250RGF0YUZhY3RvcnkgOiBfZGlzcGxheV91dGlscy5ET01TdGFuZGFyZEZvbnREYXRhRmFjdG9yeTtcbmV4cG9ydHMuRGVmYXVsdFN0YW5kYXJkRm9udERhdGFGYWN0b3J5ID0gRGVmYXVsdFN0YW5kYXJkRm9udERhdGFGYWN0b3J5O1xuZnVuY3Rpb24gZ2V0RG9jdW1lbnQoc3JjKSB7XG4gIGlmICh0eXBlb2Ygc3JjID09PSBcInN0cmluZ1wiIHx8IHNyYyBpbnN0YW5jZW9mIFVSTCkge1xuICAgIHNyYyA9IHtcbiAgICAgIHVybDogc3JjXG4gICAgfTtcbiAgfSBlbHNlIGlmICgoMCwgX3V0aWwuaXNBcnJheUJ1ZmZlcikoc3JjKSkge1xuICAgIHNyYyA9IHtcbiAgICAgIGRhdGE6IHNyY1xuICAgIH07XG4gIH1cbiAgaWYgKHR5cGVvZiBzcmMgIT09IFwib2JqZWN0XCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHBhcmFtZXRlciBpbiBnZXREb2N1bWVudCwgbmVlZCBwYXJhbWV0ZXIgb2JqZWN0LlwiKTtcbiAgfVxuICBpZiAoIXNyYy51cmwgJiYgIXNyYy5kYXRhICYmICFzcmMucmFuZ2UpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHBhcmFtZXRlciBvYmplY3Q6IG5lZWQgZWl0aGVyIC5kYXRhLCAucmFuZ2Ugb3IgLnVybFwiKTtcbiAgfVxuICBjb25zdCB0YXNrID0gbmV3IFBERkRvY3VtZW50TG9hZGluZ1Rhc2soKTtcbiAgY29uc3Qge1xuICAgIGRvY0lkXG4gIH0gPSB0YXNrO1xuICBjb25zdCB1cmwgPSBzcmMudXJsID8gZ2V0VXJsUHJvcChzcmMudXJsKSA6IG51bGw7XG4gIGNvbnN0IGRhdGEgPSBzcmMuZGF0YSA/IGdldERhdGFQcm9wKHNyYy5kYXRhKSA6IG51bGw7XG4gIGNvbnN0IGh0dHBIZWFkZXJzID0gc3JjLmh0dHBIZWFkZXJzIHx8IG51bGw7XG4gIGNvbnN0IHdpdGhDcmVkZW50aWFscyA9IHNyYy53aXRoQ3JlZGVudGlhbHMgPT09IHRydWU7XG4gIGNvbnN0IHBhc3N3b3JkID0gc3JjLnBhc3N3b3JkID8/IG51bGw7XG4gIGNvbnN0IHJhbmdlVHJhbnNwb3J0ID0gc3JjLnJhbmdlIGluc3RhbmNlb2YgUERGRGF0YVJhbmdlVHJhbnNwb3J0ID8gc3JjLnJhbmdlIDogbnVsbDtcbiAgY29uc3QgcmFuZ2VDaHVua1NpemUgPSBOdW1iZXIuaXNJbnRlZ2VyKHNyYy5yYW5nZUNodW5rU2l6ZSkgJiYgc3JjLnJhbmdlQ2h1bmtTaXplID4gMCA/IHNyYy5yYW5nZUNodW5rU2l6ZSA6IERFRkFVTFRfUkFOR0VfQ0hVTktfU0laRTtcbiAgbGV0IHdvcmtlciA9IHNyYy53b3JrZXIgaW5zdGFuY2VvZiBQREZXb3JrZXIgPyBzcmMud29ya2VyIDogbnVsbDtcbiAgY29uc3QgdmVyYm9zaXR5ID0gc3JjLnZlcmJvc2l0eTtcbiAgY29uc3QgZG9jQmFzZVVybCA9IHR5cGVvZiBzcmMuZG9jQmFzZVVybCA9PT0gXCJzdHJpbmdcIiAmJiAhKDAsIF9kaXNwbGF5X3V0aWxzLmlzRGF0YVNjaGVtZSkoc3JjLmRvY0Jhc2VVcmwpID8gc3JjLmRvY0Jhc2VVcmwgOiBudWxsO1xuICBjb25zdCBjTWFwVXJsID0gdHlwZW9mIHNyYy5jTWFwVXJsID09PSBcInN0cmluZ1wiID8gc3JjLmNNYXBVcmwgOiBudWxsO1xuICBjb25zdCBjTWFwUGFja2VkID0gc3JjLmNNYXBQYWNrZWQgIT09IGZhbHNlO1xuICBjb25zdCBDTWFwUmVhZGVyRmFjdG9yeSA9IHNyYy5DTWFwUmVhZGVyRmFjdG9yeSB8fCBEZWZhdWx0Q01hcFJlYWRlckZhY3Rvcnk7XG4gIGNvbnN0IHN0YW5kYXJkRm9udERhdGFVcmwgPSB0eXBlb2Ygc3JjLnN0YW5kYXJkRm9udERhdGFVcmwgPT09IFwic3RyaW5nXCIgPyBzcmMuc3RhbmRhcmRGb250RGF0YVVybCA6IG51bGw7XG4gIGNvbnN0IFN0YW5kYXJkRm9udERhdGFGYWN0b3J5ID0gc3JjLlN0YW5kYXJkRm9udERhdGFGYWN0b3J5IHx8IERlZmF1bHRTdGFuZGFyZEZvbnREYXRhRmFjdG9yeTtcbiAgY29uc3QgaWdub3JlRXJyb3JzID0gc3JjLnN0b3BBdEVycm9ycyAhPT0gdHJ1ZTtcbiAgY29uc3QgbWF4SW1hZ2VTaXplID0gTnVtYmVyLmlzSW50ZWdlcihzcmMubWF4SW1hZ2VTaXplKSAmJiBzcmMubWF4SW1hZ2VTaXplID4gLTEgPyBzcmMubWF4SW1hZ2VTaXplIDogLTE7XG4gIGNvbnN0IGlzRXZhbFN1cHBvcnRlZCA9IHNyYy5pc0V2YWxTdXBwb3J0ZWQgIT09IGZhbHNlO1xuICBjb25zdCBpc09mZnNjcmVlbkNhbnZhc1N1cHBvcnRlZCA9IHR5cGVvZiBzcmMuaXNPZmZzY3JlZW5DYW52YXNTdXBwb3J0ZWQgPT09IFwiYm9vbGVhblwiID8gc3JjLmlzT2Zmc2NyZWVuQ2FudmFzU3VwcG9ydGVkIDogIV91dGlsLmlzTm9kZUpTO1xuICBjb25zdCBjYW52YXNNYXhBcmVhSW5CeXRlcyA9IE51bWJlci5pc0ludGVnZXIoc3JjLmNhbnZhc01heEFyZWFJbkJ5dGVzKSA/IHNyYy5jYW52YXNNYXhBcmVhSW5CeXRlcyA6IC0xO1xuICBjb25zdCBkaXNhYmxlRm9udEZhY2UgPSB0eXBlb2Ygc3JjLmRpc2FibGVGb250RmFjZSA9PT0gXCJib29sZWFuXCIgPyBzcmMuZGlzYWJsZUZvbnRGYWNlIDogX3V0aWwuaXNOb2RlSlM7XG4gIGNvbnN0IGZvbnRFeHRyYVByb3BlcnRpZXMgPSBzcmMuZm9udEV4dHJhUHJvcGVydGllcyA9PT0gdHJ1ZTtcbiAgY29uc3QgZW5hYmxlWGZhID0gc3JjLmVuYWJsZVhmYSA9PT0gdHJ1ZTtcbiAgY29uc3Qgb3duZXJEb2N1bWVudCA9IHNyYy5vd25lckRvY3VtZW50IHx8IGdsb2JhbFRoaXMuZG9jdW1lbnQ7XG4gIGNvbnN0IGRpc2FibGVSYW5nZSA9IHNyYy5kaXNhYmxlUmFuZ2UgPT09IHRydWU7XG4gIGNvbnN0IGRpc2FibGVTdHJlYW0gPSBzcmMuZGlzYWJsZVN0cmVhbSA9PT0gdHJ1ZTtcbiAgY29uc3QgZGlzYWJsZUF1dG9GZXRjaCA9IHNyYy5kaXNhYmxlQXV0b0ZldGNoID09PSB0cnVlO1xuICBjb25zdCBwZGZCdWcgPSBzcmMucGRmQnVnID09PSB0cnVlO1xuICBjb25zdCBsZW5ndGggPSByYW5nZVRyYW5zcG9ydCA/IHJhbmdlVHJhbnNwb3J0Lmxlbmd0aCA6IHNyYy5sZW5ndGggPz8gTmFOO1xuICBjb25zdCB1c2VTeXN0ZW1Gb250cyA9IHR5cGVvZiBzcmMudXNlU3lzdGVtRm9udHMgPT09IFwiYm9vbGVhblwiID8gc3JjLnVzZVN5c3RlbUZvbnRzIDogIV91dGlsLmlzTm9kZUpTICYmICFkaXNhYmxlRm9udEZhY2U7XG4gIGNvbnN0IHVzZVdvcmtlckZldGNoID0gdHlwZW9mIHNyYy51c2VXb3JrZXJGZXRjaCA9PT0gXCJib29sZWFuXCIgPyBzcmMudXNlV29ya2VyRmV0Y2ggOiBDTWFwUmVhZGVyRmFjdG9yeSA9PT0gX2Rpc3BsYXlfdXRpbHMuRE9NQ01hcFJlYWRlckZhY3RvcnkgJiYgU3RhbmRhcmRGb250RGF0YUZhY3RvcnkgPT09IF9kaXNwbGF5X3V0aWxzLkRPTVN0YW5kYXJkRm9udERhdGFGYWN0b3J5ICYmIGNNYXBVcmwgJiYgc3RhbmRhcmRGb250RGF0YVVybCAmJiAoMCwgX2Rpc3BsYXlfdXRpbHMuaXNWYWxpZEZldGNoVXJsKShjTWFwVXJsLCBkb2N1bWVudC5iYXNlVVJJKSAmJiAoMCwgX2Rpc3BsYXlfdXRpbHMuaXNWYWxpZEZldGNoVXJsKShzdGFuZGFyZEZvbnREYXRhVXJsLCBkb2N1bWVudC5iYXNlVVJJKTtcbiAgY29uc3QgY2FudmFzRmFjdG9yeSA9IHNyYy5jYW52YXNGYWN0b3J5IHx8IG5ldyBEZWZhdWx0Q2FudmFzRmFjdG9yeSh7XG4gICAgb3duZXJEb2N1bWVudFxuICB9KTtcbiAgY29uc3QgZmlsdGVyRmFjdG9yeSA9IHNyYy5maWx0ZXJGYWN0b3J5IHx8IG5ldyBEZWZhdWx0RmlsdGVyRmFjdG9yeSh7XG4gICAgZG9jSWQsXG4gICAgb3duZXJEb2N1bWVudFxuICB9KTtcbiAgY29uc3Qgc3R5bGVFbGVtZW50ID0gbnVsbDtcbiAgKDAsIF91dGlsLnNldFZlcmJvc2l0eUxldmVsKSh2ZXJib3NpdHkpO1xuICBjb25zdCB0cmFuc3BvcnRGYWN0b3J5ID0ge1xuICAgIGNhbnZhc0ZhY3RvcnksXG4gICAgZmlsdGVyRmFjdG9yeVxuICB9O1xuICBpZiAoIXVzZVdvcmtlckZldGNoKSB7XG4gICAgdHJhbnNwb3J0RmFjdG9yeS5jTWFwUmVhZGVyRmFjdG9yeSA9IG5ldyBDTWFwUmVhZGVyRmFjdG9yeSh7XG4gICAgICBiYXNlVXJsOiBjTWFwVXJsLFxuICAgICAgaXNDb21wcmVzc2VkOiBjTWFwUGFja2VkXG4gICAgfSk7XG4gICAgdHJhbnNwb3J0RmFjdG9yeS5zdGFuZGFyZEZvbnREYXRhRmFjdG9yeSA9IG5ldyBTdGFuZGFyZEZvbnREYXRhRmFjdG9yeSh7XG4gICAgICBiYXNlVXJsOiBzdGFuZGFyZEZvbnREYXRhVXJsXG4gICAgfSk7XG4gIH1cbiAgaWYgKCF3b3JrZXIpIHtcbiAgICBjb25zdCB3b3JrZXJQYXJhbXMgPSB7XG4gICAgICB2ZXJib3NpdHksXG4gICAgICBwb3J0OiBfd29ya2VyX29wdGlvbnMuR2xvYmFsV29ya2VyT3B0aW9ucy53b3JrZXJQb3J0XG4gICAgfTtcbiAgICB3b3JrZXIgPSB3b3JrZXJQYXJhbXMucG9ydCA/IFBERldvcmtlci5mcm9tUG9ydCh3b3JrZXJQYXJhbXMpIDogbmV3IFBERldvcmtlcih3b3JrZXJQYXJhbXMpO1xuICAgIHRhc2suX3dvcmtlciA9IHdvcmtlcjtcbiAgfVxuICBjb25zdCBmZXRjaERvY1BhcmFtcyA9IHtcbiAgICBkb2NJZCxcbiAgICBhcGlWZXJzaW9uOiAnMy4xMS4xNzQnLFxuICAgIGRhdGEsXG4gICAgcGFzc3dvcmQsXG4gICAgZGlzYWJsZUF1dG9GZXRjaCxcbiAgICByYW5nZUNodW5rU2l6ZSxcbiAgICBsZW5ndGgsXG4gICAgZG9jQmFzZVVybCxcbiAgICBlbmFibGVYZmEsXG4gICAgZXZhbHVhdG9yT3B0aW9uczoge1xuICAgICAgbWF4SW1hZ2VTaXplLFxuICAgICAgZGlzYWJsZUZvbnRGYWNlLFxuICAgICAgaWdub3JlRXJyb3JzLFxuICAgICAgaXNFdmFsU3VwcG9ydGVkLFxuICAgICAgaXNPZmZzY3JlZW5DYW52YXNTdXBwb3J0ZWQsXG4gICAgICBjYW52YXNNYXhBcmVhSW5CeXRlcyxcbiAgICAgIGZvbnRFeHRyYVByb3BlcnRpZXMsXG4gICAgICB1c2VTeXN0ZW1Gb250cyxcbiAgICAgIGNNYXBVcmw6IHVzZVdvcmtlckZldGNoID8gY01hcFVybCA6IG51bGwsXG4gICAgICBzdGFuZGFyZEZvbnREYXRhVXJsOiB1c2VXb3JrZXJGZXRjaCA/IHN0YW5kYXJkRm9udERhdGFVcmwgOiBudWxsXG4gICAgfVxuICB9O1xuICBjb25zdCB0cmFuc3BvcnRQYXJhbXMgPSB7XG4gICAgaWdub3JlRXJyb3JzLFxuICAgIGlzRXZhbFN1cHBvcnRlZCxcbiAgICBkaXNhYmxlRm9udEZhY2UsXG4gICAgZm9udEV4dHJhUHJvcGVydGllcyxcbiAgICBlbmFibGVYZmEsXG4gICAgb3duZXJEb2N1bWVudCxcbiAgICBkaXNhYmxlQXV0b0ZldGNoLFxuICAgIHBkZkJ1ZyxcbiAgICBzdHlsZUVsZW1lbnRcbiAgfTtcbiAgd29ya2VyLnByb21pc2UudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRhc2suZGVzdHJveWVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJMb2FkaW5nIGFib3J0ZWRcIik7XG4gICAgfVxuICAgIGNvbnN0IHdvcmtlcklkUHJvbWlzZSA9IF9mZXRjaERvY3VtZW50KHdvcmtlciwgZmV0Y2hEb2NQYXJhbXMpO1xuICAgIGNvbnN0IG5ldHdvcmtTdHJlYW1Qcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgIGxldCBuZXR3b3JrU3RyZWFtO1xuICAgICAgaWYgKHJhbmdlVHJhbnNwb3J0KSB7XG4gICAgICAgIG5ldHdvcmtTdHJlYW0gPSBuZXcgX3RyYW5zcG9ydF9zdHJlYW0uUERGRGF0YVRyYW5zcG9ydFN0cmVhbSh7XG4gICAgICAgICAgbGVuZ3RoLFxuICAgICAgICAgIGluaXRpYWxEYXRhOiByYW5nZVRyYW5zcG9ydC5pbml0aWFsRGF0YSxcbiAgICAgICAgICBwcm9ncmVzc2l2ZURvbmU6IHJhbmdlVHJhbnNwb3J0LnByb2dyZXNzaXZlRG9uZSxcbiAgICAgICAgICBjb250ZW50RGlzcG9zaXRpb25GaWxlbmFtZTogcmFuZ2VUcmFuc3BvcnQuY29udGVudERpc3Bvc2l0aW9uRmlsZW5hbWUsXG4gICAgICAgICAgZGlzYWJsZVJhbmdlLFxuICAgICAgICAgIGRpc2FibGVTdHJlYW1cbiAgICAgICAgfSwgcmFuZ2VUcmFuc3BvcnQpO1xuICAgICAgfSBlbHNlIGlmICghZGF0YSkge1xuICAgICAgICBjb25zdCBjcmVhdGVQREZOZXR3b3JrU3RyZWFtID0gcGFyYW1zID0+IHtcbiAgICAgICAgICBpZiAoX3V0aWwuaXNOb2RlSlMpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgX2Rpc3BsYXlOb2RlX3N0cmVhbS5QREZOb2RlU3RyZWFtKHBhcmFtcyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiAoMCwgX2Rpc3BsYXlfdXRpbHMuaXNWYWxpZEZldGNoVXJsKShwYXJhbXMudXJsKSA/IG5ldyBfZGlzcGxheUZldGNoX3N0cmVhbS5QREZGZXRjaFN0cmVhbShwYXJhbXMpIDogbmV3IF9kaXNwbGF5TmV0d29yay5QREZOZXR3b3JrU3RyZWFtKHBhcmFtcyk7XG4gICAgICAgIH07XG4gICAgICAgIG5ldHdvcmtTdHJlYW0gPSBjcmVhdGVQREZOZXR3b3JrU3RyZWFtKHtcbiAgICAgICAgICB1cmwsXG4gICAgICAgICAgbGVuZ3RoLFxuICAgICAgICAgIGh0dHBIZWFkZXJzLFxuICAgICAgICAgIHdpdGhDcmVkZW50aWFscyxcbiAgICAgICAgICByYW5nZUNodW5rU2l6ZSxcbiAgICAgICAgICBkaXNhYmxlUmFuZ2UsXG4gICAgICAgICAgZGlzYWJsZVN0cmVhbVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJlc29sdmUobmV0d29ya1N0cmVhbSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKFt3b3JrZXJJZFByb21pc2UsIG5ldHdvcmtTdHJlYW1Qcm9taXNlXSkudGhlbihmdW5jdGlvbiAoW3dvcmtlcklkLCBuZXR3b3JrU3RyZWFtXSkge1xuICAgICAgaWYgKHRhc2suZGVzdHJveWVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkxvYWRpbmcgYWJvcnRlZFwiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG1lc3NhZ2VIYW5kbGVyID0gbmV3IF9tZXNzYWdlX2hhbmRsZXIuTWVzc2FnZUhhbmRsZXIoZG9jSWQsIHdvcmtlcklkLCB3b3JrZXIucG9ydCk7XG4gICAgICBjb25zdCB0cmFuc3BvcnQgPSBuZXcgV29ya2VyVHJhbnNwb3J0KG1lc3NhZ2VIYW5kbGVyLCB0YXNrLCBuZXR3b3JrU3RyZWFtLCB0cmFuc3BvcnRQYXJhbXMsIHRyYW5zcG9ydEZhY3RvcnkpO1xuICAgICAgdGFzay5fdHJhbnNwb3J0ID0gdHJhbnNwb3J0O1xuICAgICAgbWVzc2FnZUhhbmRsZXIuc2VuZChcIlJlYWR5XCIsIG51bGwpO1xuICAgIH0pO1xuICB9KS5jYXRjaCh0YXNrLl9jYXBhYmlsaXR5LnJlamVjdCk7XG4gIHJldHVybiB0YXNrO1xufVxuYXN5bmMgZnVuY3Rpb24gX2ZldGNoRG9jdW1lbnQod29ya2VyLCBzb3VyY2UpIHtcbiAgaWYgKHdvcmtlci5kZXN0cm95ZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJXb3JrZXIgd2FzIGRlc3Ryb3llZFwiKTtcbiAgfVxuICBjb25zdCB3b3JrZXJJZCA9IGF3YWl0IHdvcmtlci5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJHZXREb2NSZXF1ZXN0XCIsIHNvdXJjZSwgc291cmNlLmRhdGEgPyBbc291cmNlLmRhdGEuYnVmZmVyXSA6IG51bGwpO1xuICBpZiAod29ya2VyLmRlc3Ryb3llZCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIldvcmtlciB3YXMgZGVzdHJveWVkXCIpO1xuICB9XG4gIHJldHVybiB3b3JrZXJJZDtcbn1cbmZ1bmN0aW9uIGdldFVybFByb3AodmFsKSB7XG4gIGlmICh2YWwgaW5zdGFuY2VvZiBVUkwpIHtcbiAgICByZXR1cm4gdmFsLmhyZWY7XG4gIH1cbiAgdHJ5IHtcbiAgICByZXR1cm4gbmV3IFVSTCh2YWwsIHdpbmRvdy5sb2NhdGlvbikuaHJlZjtcbiAgfSBjYXRjaCB7XG4gICAgaWYgKF91dGlsLmlzTm9kZUpTICYmIHR5cGVvZiB2YWwgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybiB2YWw7XG4gICAgfVxuICB9XG4gIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgUERGIHVybCBkYXRhOiBcIiArIFwiZWl0aGVyIHN0cmluZyBvciBVUkwtb2JqZWN0IGlzIGV4cGVjdGVkIGluIHRoZSB1cmwgcHJvcGVydHkuXCIpO1xufVxuZnVuY3Rpb24gZ2V0RGF0YVByb3AodmFsKSB7XG4gIGlmIChfdXRpbC5pc05vZGVKUyAmJiB0eXBlb2YgQnVmZmVyICE9PSBcInVuZGVmaW5lZFwiICYmIHZhbCBpbnN0YW5jZW9mIEJ1ZmZlcikge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlBsZWFzZSBwcm92aWRlIGJpbmFyeSBkYXRhIGFzIGBVaW50OEFycmF5YCwgcmF0aGVyIHRoYW4gYEJ1ZmZlcmAuXCIpO1xuICB9XG4gIGlmICh2YWwgaW5zdGFuY2VvZiBVaW50OEFycmF5ICYmIHZhbC5ieXRlTGVuZ3RoID09PSB2YWwuYnVmZmVyLmJ5dGVMZW5ndGgpIHtcbiAgICByZXR1cm4gdmFsO1xuICB9XG4gIGlmICh0eXBlb2YgdmFsID09PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuICgwLCBfdXRpbC5zdHJpbmdUb0J5dGVzKSh2YWwpO1xuICB9XG4gIGlmICh0eXBlb2YgdmFsID09PSBcIm9iamVjdFwiICYmICFpc05hTih2YWw/Lmxlbmd0aCkgfHwgKDAsIF91dGlsLmlzQXJyYXlCdWZmZXIpKHZhbCkpIHtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkodmFsKTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIFBERiBiaW5hcnkgZGF0YTogZWl0aGVyIFR5cGVkQXJyYXksIFwiICsgXCJzdHJpbmcsIG9yIGFycmF5LWxpa2Ugb2JqZWN0IGlzIGV4cGVjdGVkIGluIHRoZSBkYXRhIHByb3BlcnR5LlwiKTtcbn1cbmNsYXNzIFBERkRvY3VtZW50TG9hZGluZ1Rhc2sge1xuICBzdGF0aWMgI2RvY0lkID0gMDtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5fY2FwYWJpbGl0eSA9IG5ldyBfdXRpbC5Qcm9taXNlQ2FwYWJpbGl0eSgpO1xuICAgIHRoaXMuX3RyYW5zcG9ydCA9IG51bGw7XG4gICAgdGhpcy5fd29ya2VyID0gbnVsbDtcbiAgICB0aGlzLmRvY0lkID0gYGQke1BERkRvY3VtZW50TG9hZGluZ1Rhc2suI2RvY0lkKyt9YDtcbiAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgIHRoaXMub25QYXNzd29yZCA9IG51bGw7XG4gICAgdGhpcy5vblByb2dyZXNzID0gbnVsbDtcbiAgfVxuICBnZXQgcHJvbWlzZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fY2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG4gIGFzeW5jIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlO1xuICAgIHRyeSB7XG4gICAgICBpZiAodGhpcy5fd29ya2VyPy5wb3J0KSB7XG4gICAgICAgIHRoaXMuX3dvcmtlci5fcGVuZGluZ0Rlc3Ryb3kgPSB0cnVlO1xuICAgICAgfVxuICAgICAgYXdhaXQgdGhpcy5fdHJhbnNwb3J0Py5kZXN0cm95KCk7XG4gICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgIGlmICh0aGlzLl93b3JrZXI/LnBvcnQpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuX3dvcmtlci5fcGVuZGluZ0Rlc3Ryb3k7XG4gICAgICB9XG4gICAgICB0aHJvdyBleDtcbiAgICB9XG4gICAgdGhpcy5fdHJhbnNwb3J0ID0gbnVsbDtcbiAgICBpZiAodGhpcy5fd29ya2VyKSB7XG4gICAgICB0aGlzLl93b3JrZXIuZGVzdHJveSgpO1xuICAgICAgdGhpcy5fd29ya2VyID0gbnVsbDtcbiAgICB9XG4gIH1cbn1cbmV4cG9ydHMuUERGRG9jdW1lbnRMb2FkaW5nVGFzayA9IFBERkRvY3VtZW50TG9hZGluZ1Rhc2s7XG5jbGFzcyBQREZEYXRhUmFuZ2VUcmFuc3BvcnQge1xuICBjb25zdHJ1Y3RvcihsZW5ndGgsIGluaXRpYWxEYXRhLCBwcm9ncmVzc2l2ZURvbmUgPSBmYWxzZSwgY29udGVudERpc3Bvc2l0aW9uRmlsZW5hbWUgPSBudWxsKSB7XG4gICAgdGhpcy5sZW5ndGggPSBsZW5ndGg7XG4gICAgdGhpcy5pbml0aWFsRGF0YSA9IGluaXRpYWxEYXRhO1xuICAgIHRoaXMucHJvZ3Jlc3NpdmVEb25lID0gcHJvZ3Jlc3NpdmVEb25lO1xuICAgIHRoaXMuY29udGVudERpc3Bvc2l0aW9uRmlsZW5hbWUgPSBjb250ZW50RGlzcG9zaXRpb25GaWxlbmFtZTtcbiAgICB0aGlzLl9yYW5nZUxpc3RlbmVycyA9IFtdO1xuICAgIHRoaXMuX3Byb2dyZXNzTGlzdGVuZXJzID0gW107XG4gICAgdGhpcy5fcHJvZ3Jlc3NpdmVSZWFkTGlzdGVuZXJzID0gW107XG4gICAgdGhpcy5fcHJvZ3Jlc3NpdmVEb25lTGlzdGVuZXJzID0gW107XG4gICAgdGhpcy5fcmVhZHlDYXBhYmlsaXR5ID0gbmV3IF91dGlsLlByb21pc2VDYXBhYmlsaXR5KCk7XG4gIH1cbiAgYWRkUmFuZ2VMaXN0ZW5lcihsaXN0ZW5lcikge1xuICAgIHRoaXMuX3JhbmdlTGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICB9XG4gIGFkZFByb2dyZXNzTGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgICB0aGlzLl9wcm9ncmVzc0xpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgfVxuICBhZGRQcm9ncmVzc2l2ZVJlYWRMaXN0ZW5lcihsaXN0ZW5lcikge1xuICAgIHRoaXMuX3Byb2dyZXNzaXZlUmVhZExpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgfVxuICBhZGRQcm9ncmVzc2l2ZURvbmVMaXN0ZW5lcihsaXN0ZW5lcikge1xuICAgIHRoaXMuX3Byb2dyZXNzaXZlRG9uZUxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgfVxuICBvbkRhdGFSYW5nZShiZWdpbiwgY2h1bmspIHtcbiAgICBmb3IgKGNvbnN0IGxpc3RlbmVyIG9mIHRoaXMuX3JhbmdlTGlzdGVuZXJzKSB7XG4gICAgICBsaXN0ZW5lcihiZWdpbiwgY2h1bmspO1xuICAgIH1cbiAgfVxuICBvbkRhdGFQcm9ncmVzcyhsb2FkZWQsIHRvdGFsKSB7XG4gICAgdGhpcy5fcmVhZHlDYXBhYmlsaXR5LnByb21pc2UudGhlbigoKSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IGxpc3RlbmVyIG9mIHRoaXMuX3Byb2dyZXNzTGlzdGVuZXJzKSB7XG4gICAgICAgIGxpc3RlbmVyKGxvYWRlZCwgdG90YWwpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIG9uRGF0YVByb2dyZXNzaXZlUmVhZChjaHVuaykge1xuICAgIHRoaXMuX3JlYWR5Q2FwYWJpbGl0eS5wcm9taXNlLnRoZW4oKCkgPT4ge1xuICAgICAgZm9yIChjb25zdCBsaXN0ZW5lciBvZiB0aGlzLl9wcm9ncmVzc2l2ZVJlYWRMaXN0ZW5lcnMpIHtcbiAgICAgICAgbGlzdGVuZXIoY2h1bmspO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIG9uRGF0YVByb2dyZXNzaXZlRG9uZSgpIHtcbiAgICB0aGlzLl9yZWFkeUNhcGFiaWxpdHkucHJvbWlzZS50aGVuKCgpID0+IHtcbiAgICAgIGZvciAoY29uc3QgbGlzdGVuZXIgb2YgdGhpcy5fcHJvZ3Jlc3NpdmVEb25lTGlzdGVuZXJzKSB7XG4gICAgICAgIGxpc3RlbmVyKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgdHJhbnNwb3J0UmVhZHkoKSB7XG4gICAgdGhpcy5fcmVhZHlDYXBhYmlsaXR5LnJlc29sdmUoKTtcbiAgfVxuICByZXF1ZXN0RGF0YVJhbmdlKGJlZ2luLCBlbmQpIHtcbiAgICAoMCwgX3V0aWwudW5yZWFjaGFibGUpKFwiQWJzdHJhY3QgbWV0aG9kIFBERkRhdGFSYW5nZVRyYW5zcG9ydC5yZXF1ZXN0RGF0YVJhbmdlXCIpO1xuICB9XG4gIGFib3J0KCkge31cbn1cbmV4cG9ydHMuUERGRGF0YVJhbmdlVHJhbnNwb3J0ID0gUERGRGF0YVJhbmdlVHJhbnNwb3J0O1xuY2xhc3MgUERGRG9jdW1lbnRQcm94eSB7XG4gIGNvbnN0cnVjdG9yKHBkZkluZm8sIHRyYW5zcG9ydCkge1xuICAgIHRoaXMuX3BkZkluZm8gPSBwZGZJbmZvO1xuICAgIHRoaXMuX3RyYW5zcG9ydCA9IHRyYW5zcG9ydDtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJnZXRKYXZhU2NyaXB0XCIsIHtcbiAgICAgIHZhbHVlOiAoKSA9PiB7XG4gICAgICAgICgwLCBfZGlzcGxheV91dGlscy5kZXByZWNhdGVkKShcImBQREZEb2N1bWVudFByb3h5LmdldEphdmFTY3JpcHRgLCBcIiArIFwicGxlYXNlIHVzZSBgUERGRG9jdW1lbnRQcm94eS5nZXRKU0FjdGlvbnNgIGluc3RlYWQuXCIpO1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRKU0FjdGlvbnMoKS50aGVuKGpzID0+IHtcbiAgICAgICAgICBpZiAoIWpzKSB7XG4gICAgICAgICAgICByZXR1cm4ganM7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGpzQXJyID0gW107XG4gICAgICAgICAgZm9yIChjb25zdCBuYW1lIGluIGpzKSB7XG4gICAgICAgICAgICBqc0Fyci5wdXNoKC4uLmpzW25hbWVdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGpzQXJyO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBnZXQgYW5ub3RhdGlvblN0b3JhZ2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5hbm5vdGF0aW9uU3RvcmFnZTtcbiAgfVxuICBnZXQgZmlsdGVyRmFjdG9yeSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmZpbHRlckZhY3Rvcnk7XG4gIH1cbiAgZ2V0IG51bVBhZ2VzKCkge1xuICAgIHJldHVybiB0aGlzLl9wZGZJbmZvLm51bVBhZ2VzO1xuICB9XG4gIGdldCBmaW5nZXJwcmludHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BkZkluZm8uZmluZ2VycHJpbnRzO1xuICB9XG4gIGdldCBpc1B1cmVYZmEoKSB7XG4gICAgcmV0dXJuICgwLCBfdXRpbC5zaGFkb3cpKHRoaXMsIFwiaXNQdXJlWGZhXCIsICEhdGhpcy5fdHJhbnNwb3J0Ll9odG1sRm9yWGZhKTtcbiAgfVxuICBnZXQgYWxsWGZhSHRtbCgpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0Ll9odG1sRm9yWGZhO1xuICB9XG4gIGdldFBhZ2UocGFnZU51bWJlcikge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0UGFnZShwYWdlTnVtYmVyKTtcbiAgfVxuICBnZXRQYWdlSW5kZXgocmVmKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXRQYWdlSW5kZXgocmVmKTtcbiAgfVxuICBnZXREZXN0aW5hdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXREZXN0aW5hdGlvbnMoKTtcbiAgfVxuICBnZXREZXN0aW5hdGlvbihpZCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0RGVzdGluYXRpb24oaWQpO1xuICB9XG4gIGdldFBhZ2VMYWJlbHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXRQYWdlTGFiZWxzKCk7XG4gIH1cbiAgZ2V0UGFnZUxheW91dCgpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldFBhZ2VMYXlvdXQoKTtcbiAgfVxuICBnZXRQYWdlTW9kZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldFBhZ2VNb2RlKCk7XG4gIH1cbiAgZ2V0Vmlld2VyUHJlZmVyZW5jZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXRWaWV3ZXJQcmVmZXJlbmNlcygpO1xuICB9XG4gIGdldE9wZW5BY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXRPcGVuQWN0aW9uKCk7XG4gIH1cbiAgZ2V0QXR0YWNobWVudHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXRBdHRhY2htZW50cygpO1xuICB9XG4gIGdldEpTQWN0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldERvY0pTQWN0aW9ucygpO1xuICB9XG4gIGdldE91dGxpbmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXRPdXRsaW5lKCk7XG4gIH1cbiAgZ2V0T3B0aW9uYWxDb250ZW50Q29uZmlnKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0T3B0aW9uYWxDb250ZW50Q29uZmlnKCk7XG4gIH1cbiAgZ2V0UGVybWlzc2lvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXRQZXJtaXNzaW9ucygpO1xuICB9XG4gIGdldE1ldGFkYXRhKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0TWV0YWRhdGEoKTtcbiAgfVxuICBnZXRNYXJrSW5mbygpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldE1hcmtJbmZvKCk7XG4gIH1cbiAgZ2V0RGF0YSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldERhdGEoKTtcbiAgfVxuICBzYXZlRG9jdW1lbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5zYXZlRG9jdW1lbnQoKTtcbiAgfVxuICBnZXREb3dubG9hZEluZm8oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5kb3dubG9hZEluZm9DYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbiAgY2xlYW51cChrZWVwTG9hZGVkRm9udHMgPSBmYWxzZSkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuc3RhcnRDbGVhbnVwKGtlZXBMb2FkZWRGb250cyB8fCB0aGlzLmlzUHVyZVhmYSk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICByZXR1cm4gdGhpcy5sb2FkaW5nVGFzay5kZXN0cm95KCk7XG4gIH1cbiAgZ2V0IGxvYWRpbmdQYXJhbXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5sb2FkaW5nUGFyYW1zO1xuICB9XG4gIGdldCBsb2FkaW5nVGFzaygpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmxvYWRpbmdUYXNrO1xuICB9XG4gIGdldEZpZWxkT2JqZWN0cygpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldEZpZWxkT2JqZWN0cygpO1xuICB9XG4gIGhhc0pTQWN0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0Lmhhc0pTQWN0aW9ucygpO1xuICB9XG4gIGdldENhbGN1bGF0aW9uT3JkZXJJZHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXRDYWxjdWxhdGlvbk9yZGVySWRzKCk7XG4gIH1cbn1cbmV4cG9ydHMuUERGRG9jdW1lbnRQcm94eSA9IFBERkRvY3VtZW50UHJveHk7XG5jbGFzcyBQREZQYWdlUHJveHkge1xuICAjZGVsYXllZENsZWFudXBUaW1lb3V0ID0gbnVsbDtcbiAgI3BlbmRpbmdDbGVhbnVwID0gZmFsc2U7XG4gIGNvbnN0cnVjdG9yKHBhZ2VJbmRleCwgcGFnZUluZm8sIHRyYW5zcG9ydCwgcGRmQnVnID0gZmFsc2UpIHtcbiAgICB0aGlzLl9wYWdlSW5kZXggPSBwYWdlSW5kZXg7XG4gICAgdGhpcy5fcGFnZUluZm8gPSBwYWdlSW5mbztcbiAgICB0aGlzLl90cmFuc3BvcnQgPSB0cmFuc3BvcnQ7XG4gICAgdGhpcy5fc3RhdHMgPSBwZGZCdWcgPyBuZXcgX2Rpc3BsYXlfdXRpbHMuU3RhdFRpbWVyKCkgOiBudWxsO1xuICAgIHRoaXMuX3BkZkJ1ZyA9IHBkZkJ1ZztcbiAgICB0aGlzLmNvbW1vbk9ianMgPSB0cmFuc3BvcnQuY29tbW9uT2JqcztcbiAgICB0aGlzLm9ianMgPSBuZXcgUERGT2JqZWN0cygpO1xuICAgIHRoaXMuX21heWJlQ2xlYW51cEFmdGVyUmVuZGVyID0gZmFsc2U7XG4gICAgdGhpcy5faW50ZW50U3RhdGVzID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG4gIH1cbiAgZ2V0IHBhZ2VOdW1iZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhZ2VJbmRleCArIDE7XG4gIH1cbiAgZ2V0IHJvdGF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fcGFnZUluZm8ucm90YXRlO1xuICB9XG4gIGdldCByZWYoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhZ2VJbmZvLnJlZjtcbiAgfVxuICBnZXQgdXNlclVuaXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhZ2VJbmZvLnVzZXJVbml0O1xuICB9XG4gIGdldCB2aWV3KCkge1xuICAgIHJldHVybiB0aGlzLl9wYWdlSW5mby52aWV3O1xuICB9XG4gIGdldFZpZXdwb3J0KHtcbiAgICBzY2FsZSxcbiAgICByb3RhdGlvbiA9IHRoaXMucm90YXRlLFxuICAgIG9mZnNldFggPSAwLFxuICAgIG9mZnNldFkgPSAwLFxuICAgIGRvbnRGbGlwID0gZmFsc2VcbiAgfSA9IHt9KSB7XG4gICAgcmV0dXJuIG5ldyBfZGlzcGxheV91dGlscy5QYWdlVmlld3BvcnQoe1xuICAgICAgdmlld0JveDogdGhpcy52aWV3LFxuICAgICAgc2NhbGUsXG4gICAgICByb3RhdGlvbixcbiAgICAgIG9mZnNldFgsXG4gICAgICBvZmZzZXRZLFxuICAgICAgZG9udEZsaXBcbiAgICB9KTtcbiAgfVxuICBnZXRBbm5vdGF0aW9ucyh7XG4gICAgaW50ZW50ID0gXCJkaXNwbGF5XCJcbiAgfSA9IHt9KSB7XG4gICAgY29uc3QgaW50ZW50QXJncyA9IHRoaXMuX3RyYW5zcG9ydC5nZXRSZW5kZXJpbmdJbnRlbnQoaW50ZW50KTtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldEFubm90YXRpb25zKHRoaXMuX3BhZ2VJbmRleCwgaW50ZW50QXJncy5yZW5kZXJpbmdJbnRlbnQpO1xuICB9XG4gIGdldEpTQWN0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldFBhZ2VKU0FjdGlvbnModGhpcy5fcGFnZUluZGV4KTtcbiAgfVxuICBnZXQgZmlsdGVyRmFjdG9yeSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmZpbHRlckZhY3Rvcnk7XG4gIH1cbiAgZ2V0IGlzUHVyZVhmYSgpIHtcbiAgICByZXR1cm4gKDAsIF91dGlsLnNoYWRvdykodGhpcywgXCJpc1B1cmVYZmFcIiwgISF0aGlzLl90cmFuc3BvcnQuX2h0bWxGb3JYZmEpO1xuICB9XG4gIGFzeW5jIGdldFhmYSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0Ll9odG1sRm9yWGZhPy5jaGlsZHJlblt0aGlzLl9wYWdlSW5kZXhdIHx8IG51bGw7XG4gIH1cbiAgcmVuZGVyKHtcbiAgICBjYW52YXNDb250ZXh0LFxuICAgIHZpZXdwb3J0LFxuICAgIGludGVudCA9IFwiZGlzcGxheVwiLFxuICAgIGFubm90YXRpb25Nb2RlID0gX3V0aWwuQW5ub3RhdGlvbk1vZGUuRU5BQkxFLFxuICAgIHRyYW5zZm9ybSA9IG51bGwsXG4gICAgYmFja2dyb3VuZCA9IG51bGwsXG4gICAgb3B0aW9uYWxDb250ZW50Q29uZmlnUHJvbWlzZSA9IG51bGwsXG4gICAgYW5ub3RhdGlvbkNhbnZhc01hcCA9IG51bGwsXG4gICAgcGFnZUNvbG9ycyA9IG51bGwsXG4gICAgcHJpbnRBbm5vdGF0aW9uU3RvcmFnZSA9IG51bGxcbiAgfSkge1xuICAgIHRoaXMuX3N0YXRzPy50aW1lKFwiT3ZlcmFsbFwiKTtcbiAgICBjb25zdCBpbnRlbnRBcmdzID0gdGhpcy5fdHJhbnNwb3J0LmdldFJlbmRlcmluZ0ludGVudChpbnRlbnQsIGFubm90YXRpb25Nb2RlLCBwcmludEFubm90YXRpb25TdG9yYWdlKTtcbiAgICB0aGlzLiNwZW5kaW5nQ2xlYW51cCA9IGZhbHNlO1xuICAgIHRoaXMuI2Fib3J0RGVsYXllZENsZWFudXAoKTtcbiAgICBpZiAoIW9wdGlvbmFsQ29udGVudENvbmZpZ1Byb21pc2UpIHtcbiAgICAgIG9wdGlvbmFsQ29udGVudENvbmZpZ1Byb21pc2UgPSB0aGlzLl90cmFuc3BvcnQuZ2V0T3B0aW9uYWxDb250ZW50Q29uZmlnKCk7XG4gICAgfVxuICAgIGxldCBpbnRlbnRTdGF0ZSA9IHRoaXMuX2ludGVudFN0YXRlcy5nZXQoaW50ZW50QXJncy5jYWNoZUtleSk7XG4gICAgaWYgKCFpbnRlbnRTdGF0ZSkge1xuICAgICAgaW50ZW50U3RhdGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgdGhpcy5faW50ZW50U3RhdGVzLnNldChpbnRlbnRBcmdzLmNhY2hlS2V5LCBpbnRlbnRTdGF0ZSk7XG4gICAgfVxuICAgIGlmIChpbnRlbnRTdGF0ZS5zdHJlYW1SZWFkZXJDYW5jZWxUaW1lb3V0KSB7XG4gICAgICBjbGVhclRpbWVvdXQoaW50ZW50U3RhdGUuc3RyZWFtUmVhZGVyQ2FuY2VsVGltZW91dCk7XG4gICAgICBpbnRlbnRTdGF0ZS5zdHJlYW1SZWFkZXJDYW5jZWxUaW1lb3V0ID0gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgaW50ZW50UHJpbnQgPSAhIShpbnRlbnRBcmdzLnJlbmRlcmluZ0ludGVudCAmIF91dGlsLlJlbmRlcmluZ0ludGVudEZsYWcuUFJJTlQpO1xuICAgIGlmICghaW50ZW50U3RhdGUuZGlzcGxheVJlYWR5Q2FwYWJpbGl0eSkge1xuICAgICAgaW50ZW50U3RhdGUuZGlzcGxheVJlYWR5Q2FwYWJpbGl0eSA9IG5ldyBfdXRpbC5Qcm9taXNlQ2FwYWJpbGl0eSgpO1xuICAgICAgaW50ZW50U3RhdGUub3BlcmF0b3JMaXN0ID0ge1xuICAgICAgICBmbkFycmF5OiBbXSxcbiAgICAgICAgYXJnc0FycmF5OiBbXSxcbiAgICAgICAgbGFzdENodW5rOiBmYWxzZSxcbiAgICAgICAgc2VwYXJhdGVBbm5vdHM6IG51bGxcbiAgICAgIH07XG4gICAgICB0aGlzLl9zdGF0cz8udGltZShcIlBhZ2UgUmVxdWVzdFwiKTtcbiAgICAgIHRoaXMuX3B1bXBPcGVyYXRvckxpc3QoaW50ZW50QXJncyk7XG4gICAgfVxuICAgIGNvbnN0IGNvbXBsZXRlID0gZXJyb3IgPT4ge1xuICAgICAgaW50ZW50U3RhdGUucmVuZGVyVGFza3MuZGVsZXRlKGludGVybmFsUmVuZGVyVGFzayk7XG4gICAgICBpZiAodGhpcy5fbWF5YmVDbGVhbnVwQWZ0ZXJSZW5kZXIgfHwgaW50ZW50UHJpbnQpIHtcbiAgICAgICAgdGhpcy4jcGVuZGluZ0NsZWFudXAgPSB0cnVlO1xuICAgICAgfVxuICAgICAgdGhpcy4jdHJ5Q2xlYW51cCghaW50ZW50UHJpbnQpO1xuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIGludGVybmFsUmVuZGVyVGFzay5jYXBhYmlsaXR5LnJlamVjdChlcnJvcik7XG4gICAgICAgIHRoaXMuX2Fib3J0T3BlcmF0b3JMaXN0KHtcbiAgICAgICAgICBpbnRlbnRTdGF0ZSxcbiAgICAgICAgICByZWFzb246IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvciA6IG5ldyBFcnJvcihlcnJvcilcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnRlcm5hbFJlbmRlclRhc2suY2FwYWJpbGl0eS5yZXNvbHZlKCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9zdGF0cz8udGltZUVuZChcIlJlbmRlcmluZ1wiKTtcbiAgICAgIHRoaXMuX3N0YXRzPy50aW1lRW5kKFwiT3ZlcmFsbFwiKTtcbiAgICB9O1xuICAgIGNvbnN0IGludGVybmFsUmVuZGVyVGFzayA9IG5ldyBJbnRlcm5hbFJlbmRlclRhc2soe1xuICAgICAgY2FsbGJhY2s6IGNvbXBsZXRlLFxuICAgICAgcGFyYW1zOiB7XG4gICAgICAgIGNhbnZhc0NvbnRleHQsXG4gICAgICAgIHZpZXdwb3J0LFxuICAgICAgICB0cmFuc2Zvcm0sXG4gICAgICAgIGJhY2tncm91bmRcbiAgICAgIH0sXG4gICAgICBvYmpzOiB0aGlzLm9ianMsXG4gICAgICBjb21tb25PYmpzOiB0aGlzLmNvbW1vbk9ianMsXG4gICAgICBhbm5vdGF0aW9uQ2FudmFzTWFwLFxuICAgICAgb3BlcmF0b3JMaXN0OiBpbnRlbnRTdGF0ZS5vcGVyYXRvckxpc3QsXG4gICAgICBwYWdlSW5kZXg6IHRoaXMuX3BhZ2VJbmRleCxcbiAgICAgIGNhbnZhc0ZhY3Rvcnk6IHRoaXMuX3RyYW5zcG9ydC5jYW52YXNGYWN0b3J5LFxuICAgICAgZmlsdGVyRmFjdG9yeTogdGhpcy5fdHJhbnNwb3J0LmZpbHRlckZhY3RvcnksXG4gICAgICB1c2VSZXF1ZXN0QW5pbWF0aW9uRnJhbWU6ICFpbnRlbnRQcmludCxcbiAgICAgIHBkZkJ1ZzogdGhpcy5fcGRmQnVnLFxuICAgICAgcGFnZUNvbG9yc1xuICAgIH0pO1xuICAgIChpbnRlbnRTdGF0ZS5yZW5kZXJUYXNrcyB8fD0gbmV3IFNldCgpKS5hZGQoaW50ZXJuYWxSZW5kZXJUYXNrKTtcbiAgICBjb25zdCByZW5kZXJUYXNrID0gaW50ZXJuYWxSZW5kZXJUYXNrLnRhc2s7XG4gICAgUHJvbWlzZS5hbGwoW2ludGVudFN0YXRlLmRpc3BsYXlSZWFkeUNhcGFiaWxpdHkucHJvbWlzZSwgb3B0aW9uYWxDb250ZW50Q29uZmlnUHJvbWlzZV0pLnRoZW4oKFt0cmFuc3BhcmVuY3ksIG9wdGlvbmFsQ29udGVudENvbmZpZ10pID0+IHtcbiAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICBjb21wbGV0ZSgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLl9zdGF0cz8udGltZShcIlJlbmRlcmluZ1wiKTtcbiAgICAgIGludGVybmFsUmVuZGVyVGFzay5pbml0aWFsaXplR3JhcGhpY3Moe1xuICAgICAgICB0cmFuc3BhcmVuY3ksXG4gICAgICAgIG9wdGlvbmFsQ29udGVudENvbmZpZ1xuICAgICAgfSk7XG4gICAgICBpbnRlcm5hbFJlbmRlclRhc2sub3BlcmF0b3JMaXN0Q2hhbmdlZCgpO1xuICAgIH0pLmNhdGNoKGNvbXBsZXRlKTtcbiAgICByZXR1cm4gcmVuZGVyVGFzaztcbiAgfVxuICBnZXRPcGVyYXRvckxpc3Qoe1xuICAgIGludGVudCA9IFwiZGlzcGxheVwiLFxuICAgIGFubm90YXRpb25Nb2RlID0gX3V0aWwuQW5ub3RhdGlvbk1vZGUuRU5BQkxFLFxuICAgIHByaW50QW5ub3RhdGlvblN0b3JhZ2UgPSBudWxsXG4gIH0gPSB7fSkge1xuICAgIGZ1bmN0aW9uIG9wZXJhdG9yTGlzdENoYW5nZWQoKSB7XG4gICAgICBpZiAoaW50ZW50U3RhdGUub3BlcmF0b3JMaXN0Lmxhc3RDaHVuaykge1xuICAgICAgICBpbnRlbnRTdGF0ZS5vcExpc3RSZWFkQ2FwYWJpbGl0eS5yZXNvbHZlKGludGVudFN0YXRlLm9wZXJhdG9yTGlzdCk7XG4gICAgICAgIGludGVudFN0YXRlLnJlbmRlclRhc2tzLmRlbGV0ZShvcExpc3RUYXNrKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgaW50ZW50QXJncyA9IHRoaXMuX3RyYW5zcG9ydC5nZXRSZW5kZXJpbmdJbnRlbnQoaW50ZW50LCBhbm5vdGF0aW9uTW9kZSwgcHJpbnRBbm5vdGF0aW9uU3RvcmFnZSwgdHJ1ZSk7XG4gICAgbGV0IGludGVudFN0YXRlID0gdGhpcy5faW50ZW50U3RhdGVzLmdldChpbnRlbnRBcmdzLmNhY2hlS2V5KTtcbiAgICBpZiAoIWludGVudFN0YXRlKSB7XG4gICAgICBpbnRlbnRTdGF0ZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICB0aGlzLl9pbnRlbnRTdGF0ZXMuc2V0KGludGVudEFyZ3MuY2FjaGVLZXksIGludGVudFN0YXRlKTtcbiAgICB9XG4gICAgbGV0IG9wTGlzdFRhc2s7XG4gICAgaWYgKCFpbnRlbnRTdGF0ZS5vcExpc3RSZWFkQ2FwYWJpbGl0eSkge1xuICAgICAgb3BMaXN0VGFzayA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICBvcExpc3RUYXNrLm9wZXJhdG9yTGlzdENoYW5nZWQgPSBvcGVyYXRvckxpc3RDaGFuZ2VkO1xuICAgICAgaW50ZW50U3RhdGUub3BMaXN0UmVhZENhcGFiaWxpdHkgPSBuZXcgX3V0aWwuUHJvbWlzZUNhcGFiaWxpdHkoKTtcbiAgICAgIChpbnRlbnRTdGF0ZS5yZW5kZXJUYXNrcyB8fD0gbmV3IFNldCgpKS5hZGQob3BMaXN0VGFzayk7XG4gICAgICBpbnRlbnRTdGF0ZS5vcGVyYXRvckxpc3QgPSB7XG4gICAgICAgIGZuQXJyYXk6IFtdLFxuICAgICAgICBhcmdzQXJyYXk6IFtdLFxuICAgICAgICBsYXN0Q2h1bms6IGZhbHNlLFxuICAgICAgICBzZXBhcmF0ZUFubm90czogbnVsbFxuICAgICAgfTtcbiAgICAgIHRoaXMuX3N0YXRzPy50aW1lKFwiUGFnZSBSZXF1ZXN0XCIpO1xuICAgICAgdGhpcy5fcHVtcE9wZXJhdG9yTGlzdChpbnRlbnRBcmdzKTtcbiAgICB9XG4gICAgcmV0dXJuIGludGVudFN0YXRlLm9wTGlzdFJlYWRDYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbiAgc3RyZWFtVGV4dENvbnRlbnQoe1xuICAgIGluY2x1ZGVNYXJrZWRDb250ZW50ID0gZmFsc2UsXG4gICAgZGlzYWJsZU5vcm1hbGl6YXRpb24gPSBmYWxzZVxuICB9ID0ge30pIHtcbiAgICBjb25zdCBURVhUX0NPTlRFTlRfQ0hVTktfU0laRSA9IDEwMDtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0Lm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoU3RyZWFtKFwiR2V0VGV4dENvbnRlbnRcIiwge1xuICAgICAgcGFnZUluZGV4OiB0aGlzLl9wYWdlSW5kZXgsXG4gICAgICBpbmNsdWRlTWFya2VkQ29udGVudDogaW5jbHVkZU1hcmtlZENvbnRlbnQgPT09IHRydWUsXG4gICAgICBkaXNhYmxlTm9ybWFsaXphdGlvbjogZGlzYWJsZU5vcm1hbGl6YXRpb24gPT09IHRydWVcbiAgICB9LCB7XG4gICAgICBoaWdoV2F0ZXJNYXJrOiBURVhUX0NPTlRFTlRfQ0hVTktfU0laRSxcbiAgICAgIHNpemUodGV4dENvbnRlbnQpIHtcbiAgICAgICAgcmV0dXJuIHRleHRDb250ZW50Lml0ZW1zLmxlbmd0aDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBnZXRUZXh0Q29udGVudChwYXJhbXMgPSB7fSkge1xuICAgIGlmICh0aGlzLl90cmFuc3BvcnQuX2h0bWxGb3JYZmEpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFhmYSgpLnRoZW4oeGZhID0+IHtcbiAgICAgICAgcmV0dXJuIF94ZmFfdGV4dC5YZmFUZXh0LnRleHRDb250ZW50KHhmYSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgcmVhZGFibGVTdHJlYW0gPSB0aGlzLnN0cmVhbVRleHRDb250ZW50KHBhcmFtcyk7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIGZ1bmN0aW9uIHB1bXAoKSB7XG4gICAgICAgIHJlYWRlci5yZWFkKCkudGhlbihmdW5jdGlvbiAoe1xuICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgIGRvbmVcbiAgICAgICAgfSkge1xuICAgICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICByZXNvbHZlKHRleHRDb250ZW50KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgT2JqZWN0LmFzc2lnbih0ZXh0Q29udGVudC5zdHlsZXMsIHZhbHVlLnN0eWxlcyk7XG4gICAgICAgICAgdGV4dENvbnRlbnQuaXRlbXMucHVzaCguLi52YWx1ZS5pdGVtcyk7XG4gICAgICAgICAgcHVtcCgpO1xuICAgICAgICB9LCByZWplY3QpO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVhZGVyID0gcmVhZGFibGVTdHJlYW0uZ2V0UmVhZGVyKCk7XG4gICAgICBjb25zdCB0ZXh0Q29udGVudCA9IHtcbiAgICAgICAgaXRlbXM6IFtdLFxuICAgICAgICBzdHlsZXM6IE9iamVjdC5jcmVhdGUobnVsbClcbiAgICAgIH07XG4gICAgICBwdW1wKCk7XG4gICAgfSk7XG4gIH1cbiAgZ2V0U3RydWN0VHJlZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldFN0cnVjdFRyZWUodGhpcy5fcGFnZUluZGV4KTtcbiAgfVxuICBfZGVzdHJveSgpIHtcbiAgICB0aGlzLmRlc3Ryb3llZCA9IHRydWU7XG4gICAgY29uc3Qgd2FpdE9uID0gW107XG4gICAgZm9yIChjb25zdCBpbnRlbnRTdGF0ZSBvZiB0aGlzLl9pbnRlbnRTdGF0ZXMudmFsdWVzKCkpIHtcbiAgICAgIHRoaXMuX2Fib3J0T3BlcmF0b3JMaXN0KHtcbiAgICAgICAgaW50ZW50U3RhdGUsXG4gICAgICAgIHJlYXNvbjogbmV3IEVycm9yKFwiUGFnZSB3YXMgZGVzdHJveWVkLlwiKSxcbiAgICAgICAgZm9yY2U6IHRydWVcbiAgICAgIH0pO1xuICAgICAgaWYgKGludGVudFN0YXRlLm9wTGlzdFJlYWRDYXBhYmlsaXR5KSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBpbnRlcm5hbFJlbmRlclRhc2sgb2YgaW50ZW50U3RhdGUucmVuZGVyVGFza3MpIHtcbiAgICAgICAgd2FpdE9uLnB1c2goaW50ZXJuYWxSZW5kZXJUYXNrLmNvbXBsZXRlZCk7XG4gICAgICAgIGludGVybmFsUmVuZGVyVGFzay5jYW5jZWwoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5vYmpzLmNsZWFyKCk7XG4gICAgdGhpcy4jcGVuZGluZ0NsZWFudXAgPSBmYWxzZTtcbiAgICB0aGlzLiNhYm9ydERlbGF5ZWRDbGVhbnVwKCk7XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKHdhaXRPbik7XG4gIH1cbiAgY2xlYW51cChyZXNldFN0YXRzID0gZmFsc2UpIHtcbiAgICB0aGlzLiNwZW5kaW5nQ2xlYW51cCA9IHRydWU7XG4gICAgY29uc3Qgc3VjY2VzcyA9IHRoaXMuI3RyeUNsZWFudXAoZmFsc2UpO1xuICAgIGlmIChyZXNldFN0YXRzICYmIHN1Y2Nlc3MpIHtcbiAgICAgIHRoaXMuX3N0YXRzICYmPSBuZXcgX2Rpc3BsYXlfdXRpbHMuU3RhdFRpbWVyKCk7XG4gICAgfVxuICAgIHJldHVybiBzdWNjZXNzO1xuICB9XG4gICN0cnlDbGVhbnVwKGRlbGF5ZWQgPSBmYWxzZSkge1xuICAgIHRoaXMuI2Fib3J0RGVsYXllZENsZWFudXAoKTtcbiAgICBpZiAoIXRoaXMuI3BlbmRpbmdDbGVhbnVwIHx8IHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChkZWxheWVkKSB7XG4gICAgICB0aGlzLiNkZWxheWVkQ2xlYW51cFRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhpcy4jZGVsYXllZENsZWFudXBUaW1lb3V0ID0gbnVsbDtcbiAgICAgICAgdGhpcy4jdHJ5Q2xlYW51cChmYWxzZSk7XG4gICAgICB9LCBERUxBWUVEX0NMRUFOVVBfVElNRU9VVCk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvciAoY29uc3Qge1xuICAgICAgcmVuZGVyVGFza3MsXG4gICAgICBvcGVyYXRvckxpc3RcbiAgICB9IG9mIHRoaXMuX2ludGVudFN0YXRlcy52YWx1ZXMoKSkge1xuICAgICAgaWYgKHJlbmRlclRhc2tzLnNpemUgPiAwIHx8ICFvcGVyYXRvckxpc3QubGFzdENodW5rKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5faW50ZW50U3RhdGVzLmNsZWFyKCk7XG4gICAgdGhpcy5vYmpzLmNsZWFyKCk7XG4gICAgdGhpcy4jcGVuZGluZ0NsZWFudXAgPSBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICAjYWJvcnREZWxheWVkQ2xlYW51cCgpIHtcbiAgICBpZiAodGhpcy4jZGVsYXllZENsZWFudXBUaW1lb3V0KSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy4jZGVsYXllZENsZWFudXBUaW1lb3V0KTtcbiAgICAgIHRoaXMuI2RlbGF5ZWRDbGVhbnVwVGltZW91dCA9IG51bGw7XG4gICAgfVxuICB9XG4gIF9zdGFydFJlbmRlclBhZ2UodHJhbnNwYXJlbmN5LCBjYWNoZUtleSkge1xuICAgIGNvbnN0IGludGVudFN0YXRlID0gdGhpcy5faW50ZW50U3RhdGVzLmdldChjYWNoZUtleSk7XG4gICAgaWYgKCFpbnRlbnRTdGF0ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9zdGF0cz8udGltZUVuZChcIlBhZ2UgUmVxdWVzdFwiKTtcbiAgICBpbnRlbnRTdGF0ZS5kaXNwbGF5UmVhZHlDYXBhYmlsaXR5Py5yZXNvbHZlKHRyYW5zcGFyZW5jeSk7XG4gIH1cbiAgX3JlbmRlclBhZ2VDaHVuayhvcGVyYXRvckxpc3RDaHVuaywgaW50ZW50U3RhdGUpIHtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBvcGVyYXRvckxpc3RDaHVuay5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICBpbnRlbnRTdGF0ZS5vcGVyYXRvckxpc3QuZm5BcnJheS5wdXNoKG9wZXJhdG9yTGlzdENodW5rLmZuQXJyYXlbaV0pO1xuICAgICAgaW50ZW50U3RhdGUub3BlcmF0b3JMaXN0LmFyZ3NBcnJheS5wdXNoKG9wZXJhdG9yTGlzdENodW5rLmFyZ3NBcnJheVtpXSk7XG4gICAgfVxuICAgIGludGVudFN0YXRlLm9wZXJhdG9yTGlzdC5sYXN0Q2h1bmsgPSBvcGVyYXRvckxpc3RDaHVuay5sYXN0Q2h1bms7XG4gICAgaW50ZW50U3RhdGUub3BlcmF0b3JMaXN0LnNlcGFyYXRlQW5ub3RzID0gb3BlcmF0b3JMaXN0Q2h1bmsuc2VwYXJhdGVBbm5vdHM7XG4gICAgZm9yIChjb25zdCBpbnRlcm5hbFJlbmRlclRhc2sgb2YgaW50ZW50U3RhdGUucmVuZGVyVGFza3MpIHtcbiAgICAgIGludGVybmFsUmVuZGVyVGFzay5vcGVyYXRvckxpc3RDaGFuZ2VkKCk7XG4gICAgfVxuICAgIGlmIChvcGVyYXRvckxpc3RDaHVuay5sYXN0Q2h1bmspIHtcbiAgICAgIHRoaXMuI3RyeUNsZWFudXAodHJ1ZSk7XG4gICAgfVxuICB9XG4gIF9wdW1wT3BlcmF0b3JMaXN0KHtcbiAgICByZW5kZXJpbmdJbnRlbnQsXG4gICAgY2FjaGVLZXksXG4gICAgYW5ub3RhdGlvblN0b3JhZ2VTZXJpYWxpemFibGVcbiAgfSkge1xuICAgIGNvbnN0IHtcbiAgICAgIG1hcCxcbiAgICAgIHRyYW5zZmVyc1xuICAgIH0gPSBhbm5vdGF0aW9uU3RvcmFnZVNlcmlhbGl6YWJsZTtcbiAgICBjb25zdCByZWFkYWJsZVN0cmVhbSA9IHRoaXMuX3RyYW5zcG9ydC5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFN0cmVhbShcIkdldE9wZXJhdG9yTGlzdFwiLCB7XG4gICAgICBwYWdlSW5kZXg6IHRoaXMuX3BhZ2VJbmRleCxcbiAgICAgIGludGVudDogcmVuZGVyaW5nSW50ZW50LFxuICAgICAgY2FjaGVLZXksXG4gICAgICBhbm5vdGF0aW9uU3RvcmFnZTogbWFwXG4gICAgfSwgdHJhbnNmZXJzKTtcbiAgICBjb25zdCByZWFkZXIgPSByZWFkYWJsZVN0cmVhbS5nZXRSZWFkZXIoKTtcbiAgICBjb25zdCBpbnRlbnRTdGF0ZSA9IHRoaXMuX2ludGVudFN0YXRlcy5nZXQoY2FjaGVLZXkpO1xuICAgIGludGVudFN0YXRlLnN0cmVhbVJlYWRlciA9IHJlYWRlcjtcbiAgICBjb25zdCBwdW1wID0gKCkgPT4ge1xuICAgICAgcmVhZGVyLnJlYWQoKS50aGVuKCh7XG4gICAgICAgIHZhbHVlLFxuICAgICAgICBkb25lXG4gICAgICB9KSA9PiB7XG4gICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgaW50ZW50U3RhdGUuc3RyZWFtUmVhZGVyID0gbnVsbDtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3RyYW5zcG9ydC5kZXN0cm95ZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcmVuZGVyUGFnZUNodW5rKHZhbHVlLCBpbnRlbnRTdGF0ZSk7XG4gICAgICAgIHB1bXAoKTtcbiAgICAgIH0sIHJlYXNvbiA9PiB7XG4gICAgICAgIGludGVudFN0YXRlLnN0cmVhbVJlYWRlciA9IG51bGw7XG4gICAgICAgIGlmICh0aGlzLl90cmFuc3BvcnQuZGVzdHJveWVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbnRlbnRTdGF0ZS5vcGVyYXRvckxpc3QpIHtcbiAgICAgICAgICBpbnRlbnRTdGF0ZS5vcGVyYXRvckxpc3QubGFzdENodW5rID0gdHJ1ZTtcbiAgICAgICAgICBmb3IgKGNvbnN0IGludGVybmFsUmVuZGVyVGFzayBvZiBpbnRlbnRTdGF0ZS5yZW5kZXJUYXNrcykge1xuICAgICAgICAgICAgaW50ZXJuYWxSZW5kZXJUYXNrLm9wZXJhdG9yTGlzdENoYW5nZWQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy4jdHJ5Q2xlYW51cCh0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW50ZW50U3RhdGUuZGlzcGxheVJlYWR5Q2FwYWJpbGl0eSkge1xuICAgICAgICAgIGludGVudFN0YXRlLmRpc3BsYXlSZWFkeUNhcGFiaWxpdHkucmVqZWN0KHJlYXNvbik7XG4gICAgICAgIH0gZWxzZSBpZiAoaW50ZW50U3RhdGUub3BMaXN0UmVhZENhcGFiaWxpdHkpIHtcbiAgICAgICAgICBpbnRlbnRTdGF0ZS5vcExpc3RSZWFkQ2FwYWJpbGl0eS5yZWplY3QocmVhc29uKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyByZWFzb247XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG4gICAgcHVtcCgpO1xuICB9XG4gIF9hYm9ydE9wZXJhdG9yTGlzdCh7XG4gICAgaW50ZW50U3RhdGUsXG4gICAgcmVhc29uLFxuICAgIGZvcmNlID0gZmFsc2VcbiAgfSkge1xuICAgIGlmICghaW50ZW50U3RhdGUuc3RyZWFtUmVhZGVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChpbnRlbnRTdGF0ZS5zdHJlYW1SZWFkZXJDYW5jZWxUaW1lb3V0KSB7XG4gICAgICBjbGVhclRpbWVvdXQoaW50ZW50U3RhdGUuc3RyZWFtUmVhZGVyQ2FuY2VsVGltZW91dCk7XG4gICAgICBpbnRlbnRTdGF0ZS5zdHJlYW1SZWFkZXJDYW5jZWxUaW1lb3V0ID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKCFmb3JjZSkge1xuICAgICAgaWYgKGludGVudFN0YXRlLnJlbmRlclRhc2tzLnNpemUgPiAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChyZWFzb24gaW5zdGFuY2VvZiBfZGlzcGxheV91dGlscy5SZW5kZXJpbmdDYW5jZWxsZWRFeGNlcHRpb24pIHtcbiAgICAgICAgbGV0IGRlbGF5ID0gUkVOREVSSU5HX0NBTkNFTExFRF9USU1FT1VUO1xuICAgICAgICBpZiAocmVhc29uLmV4dHJhRGVsYXkgPiAwICYmIHJlYXNvbi5leHRyYURlbGF5IDwgMTAwMCkge1xuICAgICAgICAgIGRlbGF5ICs9IHJlYXNvbi5leHRyYURlbGF5O1xuICAgICAgICB9XG4gICAgICAgIGludGVudFN0YXRlLnN0cmVhbVJlYWRlckNhbmNlbFRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBpbnRlbnRTdGF0ZS5zdHJlYW1SZWFkZXJDYW5jZWxUaW1lb3V0ID0gbnVsbDtcbiAgICAgICAgICB0aGlzLl9hYm9ydE9wZXJhdG9yTGlzdCh7XG4gICAgICAgICAgICBpbnRlbnRTdGF0ZSxcbiAgICAgICAgICAgIHJlYXNvbixcbiAgICAgICAgICAgIGZvcmNlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sIGRlbGF5KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBpbnRlbnRTdGF0ZS5zdHJlYW1SZWFkZXIuY2FuY2VsKG5ldyBfdXRpbC5BYm9ydEV4Y2VwdGlvbihyZWFzb24ubWVzc2FnZSkpLmNhdGNoKCgpID0+IHt9KTtcbiAgICBpbnRlbnRTdGF0ZS5zdHJlYW1SZWFkZXIgPSBudWxsO1xuICAgIGlmICh0aGlzLl90cmFuc3BvcnQuZGVzdHJveWVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAoY29uc3QgW2N1ckNhY2hlS2V5LCBjdXJJbnRlbnRTdGF0ZV0gb2YgdGhpcy5faW50ZW50U3RhdGVzKSB7XG4gICAgICBpZiAoY3VySW50ZW50U3RhdGUgPT09IGludGVudFN0YXRlKSB7XG4gICAgICAgIHRoaXMuX2ludGVudFN0YXRlcy5kZWxldGUoY3VyQ2FjaGVLZXkpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5jbGVhbnVwKCk7XG4gIH1cbiAgZ2V0IHN0YXRzKCkge1xuICAgIHJldHVybiB0aGlzLl9zdGF0cztcbiAgfVxufVxuZXhwb3J0cy5QREZQYWdlUHJveHkgPSBQREZQYWdlUHJveHk7XG5jbGFzcyBMb29wYmFja1BvcnQge1xuICAjbGlzdGVuZXJzID0gbmV3IFNldCgpO1xuICAjZGVmZXJyZWQgPSBQcm9taXNlLnJlc29sdmUoKTtcbiAgcG9zdE1lc3NhZ2Uob2JqLCB0cmFuc2Zlcikge1xuICAgIGNvbnN0IGV2ZW50ID0ge1xuICAgICAgZGF0YTogc3RydWN0dXJlZENsb25lKG9iaiwgdHJhbnNmZXIgPyB7XG4gICAgICAgIHRyYW5zZmVyXG4gICAgICB9IDogbnVsbClcbiAgICB9O1xuICAgIHRoaXMuI2RlZmVycmVkLnRoZW4oKCkgPT4ge1xuICAgICAgZm9yIChjb25zdCBsaXN0ZW5lciBvZiB0aGlzLiNsaXN0ZW5lcnMpIHtcbiAgICAgICAgbGlzdGVuZXIuY2FsbCh0aGlzLCBldmVudCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgYWRkRXZlbnRMaXN0ZW5lcihuYW1lLCBsaXN0ZW5lcikge1xuICAgIHRoaXMuI2xpc3RlbmVycy5hZGQobGlzdGVuZXIpO1xuICB9XG4gIHJlbW92ZUV2ZW50TGlzdGVuZXIobmFtZSwgbGlzdGVuZXIpIHtcbiAgICB0aGlzLiNsaXN0ZW5lcnMuZGVsZXRlKGxpc3RlbmVyKTtcbiAgfVxuICB0ZXJtaW5hdGUoKSB7XG4gICAgdGhpcy4jbGlzdGVuZXJzLmNsZWFyKCk7XG4gIH1cbn1cbmV4cG9ydHMuTG9vcGJhY2tQb3J0ID0gTG9vcGJhY2tQb3J0O1xuY29uc3QgUERGV29ya2VyVXRpbCA9IHtcbiAgaXNXb3JrZXJEaXNhYmxlZDogZmFsc2UsXG4gIGZhbGxiYWNrV29ya2VyU3JjOiBudWxsLFxuICBmYWtlV29ya2VySWQ6IDBcbn07XG5leHBvcnRzLlBERldvcmtlclV0aWwgPSBQREZXb3JrZXJVdGlsO1xue1xuICBpZiAoX3V0aWwuaXNOb2RlSlMgJiYgdHlwZW9mIHJlcXVpcmUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIFBERldvcmtlclV0aWwuaXNXb3JrZXJEaXNhYmxlZCA9IHRydWU7XG4gICAgUERGV29ya2VyVXRpbC5mYWxsYmFja1dvcmtlclNyYyA9IFwiLi9wZGYud29ya2VyLmpzXCI7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGRvY3VtZW50ID09PSBcIm9iamVjdFwiKSB7XG4gICAgY29uc3QgcGRmanNGaWxlUGF0aCA9IGRvY3VtZW50Py5jdXJyZW50U2NyaXB0Py5zcmM7XG4gICAgaWYgKHBkZmpzRmlsZVBhdGgpIHtcbiAgICAgIFBERldvcmtlclV0aWwuZmFsbGJhY2tXb3JrZXJTcmMgPSBwZGZqc0ZpbGVQYXRoLnJlcGxhY2UoLyhcXC4oPzptaW5cXC4pP2pzKShcXD8uKik/JC9pLCBcIi53b3JrZXIkMSQyXCIpO1xuICAgIH1cbiAgfVxuICBQREZXb3JrZXJVdGlsLmlzU2FtZU9yaWdpbiA9IGZ1bmN0aW9uIChiYXNlVXJsLCBvdGhlclVybCkge1xuICAgIGxldCBiYXNlO1xuICAgIHRyeSB7XG4gICAgICBiYXNlID0gbmV3IFVSTChiYXNlVXJsKTtcbiAgICAgIGlmICghYmFzZS5vcmlnaW4gfHwgYmFzZS5vcmlnaW4gPT09IFwibnVsbFwiKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3Qgb3RoZXIgPSBuZXcgVVJMKG90aGVyVXJsLCBiYXNlKTtcbiAgICByZXR1cm4gYmFzZS5vcmlnaW4gPT09IG90aGVyLm9yaWdpbjtcbiAgfTtcbiAgUERGV29ya2VyVXRpbC5jcmVhdGVDRE5XcmFwcGVyID0gZnVuY3Rpb24gKHVybCkge1xuICAgIGNvbnN0IHdyYXBwZXIgPSBgaW1wb3J0U2NyaXB0cyhcIiR7dXJsfVwiKTtgO1xuICAgIHJldHVybiBVUkwuY3JlYXRlT2JqZWN0VVJMKG5ldyBCbG9iKFt3cmFwcGVyXSkpO1xuICB9O1xufVxuY2xhc3MgUERGV29ya2VyIHtcbiAgc3RhdGljICN3b3JrZXJQb3J0cztcbiAgY29uc3RydWN0b3Ioe1xuICAgIG5hbWUgPSBudWxsLFxuICAgIHBvcnQgPSBudWxsLFxuICAgIHZlcmJvc2l0eSA9ICgwLCBfdXRpbC5nZXRWZXJib3NpdHlMZXZlbCkoKVxuICB9ID0ge30pIHtcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgdGhpcy52ZXJib3NpdHkgPSB2ZXJib3NpdHk7XG4gICAgdGhpcy5fcmVhZHlDYXBhYmlsaXR5ID0gbmV3IF91dGlsLlByb21pc2VDYXBhYmlsaXR5KCk7XG4gICAgdGhpcy5fcG9ydCA9IG51bGw7XG4gICAgdGhpcy5fd2ViV29ya2VyID0gbnVsbDtcbiAgICB0aGlzLl9tZXNzYWdlSGFuZGxlciA9IG51bGw7XG4gICAgaWYgKHBvcnQpIHtcbiAgICAgIGlmIChQREZXb3JrZXIuI3dvcmtlclBvcnRzPy5oYXMocG9ydCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHVzZSBtb3JlIHRoYW4gb25lIFBERldvcmtlciBwZXIgcG9ydC5cIik7XG4gICAgICB9XG4gICAgICAoUERGV29ya2VyLiN3b3JrZXJQb3J0cyB8fD0gbmV3IFdlYWtNYXAoKSkuc2V0KHBvcnQsIHRoaXMpO1xuICAgICAgdGhpcy5faW5pdGlhbGl6ZUZyb21Qb3J0KHBvcnQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9pbml0aWFsaXplKCk7XG4gIH1cbiAgZ2V0IHByb21pc2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlYWR5Q2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG4gIGdldCBwb3J0KCkge1xuICAgIHJldHVybiB0aGlzLl9wb3J0O1xuICB9XG4gIGdldCBtZXNzYWdlSGFuZGxlcigpIHtcbiAgICByZXR1cm4gdGhpcy5fbWVzc2FnZUhhbmRsZXI7XG4gIH1cbiAgX2luaXRpYWxpemVGcm9tUG9ydChwb3J0KSB7XG4gICAgdGhpcy5fcG9ydCA9IHBvcnQ7XG4gICAgdGhpcy5fbWVzc2FnZUhhbmRsZXIgPSBuZXcgX21lc3NhZ2VfaGFuZGxlci5NZXNzYWdlSGFuZGxlcihcIm1haW5cIiwgXCJ3b3JrZXJcIiwgcG9ydCk7XG4gICAgdGhpcy5fbWVzc2FnZUhhbmRsZXIub24oXCJyZWFkeVwiLCBmdW5jdGlvbiAoKSB7fSk7XG4gICAgdGhpcy5fcmVhZHlDYXBhYmlsaXR5LnJlc29sdmUoKTtcbiAgICB0aGlzLl9tZXNzYWdlSGFuZGxlci5zZW5kKFwiY29uZmlndXJlXCIsIHtcbiAgICAgIHZlcmJvc2l0eTogdGhpcy52ZXJib3NpdHlcbiAgICB9KTtcbiAgfVxuICBfaW5pdGlhbGl6ZSgpIHtcbiAgICBpZiAoIVBERldvcmtlclV0aWwuaXNXb3JrZXJEaXNhYmxlZCAmJiAhUERGV29ya2VyLl9tYWluVGhyZWFkV29ya2VyTWVzc2FnZUhhbmRsZXIpIHtcbiAgICAgIGxldCB7XG4gICAgICAgIHdvcmtlclNyY1xuICAgICAgfSA9IFBERldvcmtlcjtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICghUERGV29ya2VyVXRpbC5pc1NhbWVPcmlnaW4od2luZG93LmxvY2F0aW9uLmhyZWYsIHdvcmtlclNyYykpIHtcbiAgICAgICAgICB3b3JrZXJTcmMgPSBQREZXb3JrZXJVdGlsLmNyZWF0ZUNETldyYXBwZXIobmV3IFVSTCh3b3JrZXJTcmMsIHdpbmRvdy5sb2NhdGlvbikuaHJlZik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgd29ya2VyID0gbmV3IFdvcmtlcih3b3JrZXJTcmMpO1xuICAgICAgICBjb25zdCBtZXNzYWdlSGFuZGxlciA9IG5ldyBfbWVzc2FnZV9oYW5kbGVyLk1lc3NhZ2VIYW5kbGVyKFwibWFpblwiLCBcIndvcmtlclwiLCB3b3JrZXIpO1xuICAgICAgICBjb25zdCB0ZXJtaW5hdGVFYXJseSA9ICgpID0+IHtcbiAgICAgICAgICB3b3JrZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIG9uV29ya2VyRXJyb3IpO1xuICAgICAgICAgIG1lc3NhZ2VIYW5kbGVyLmRlc3Ryb3koKTtcbiAgICAgICAgICB3b3JrZXIudGVybWluYXRlKCk7XG4gICAgICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgICAgICB0aGlzLl9yZWFkeUNhcGFiaWxpdHkucmVqZWN0KG5ldyBFcnJvcihcIldvcmtlciB3YXMgZGVzdHJveWVkXCIpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fc2V0dXBGYWtlV29ya2VyKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBvbldvcmtlckVycm9yID0gKCkgPT4ge1xuICAgICAgICAgIGlmICghdGhpcy5fd2ViV29ya2VyKSB7XG4gICAgICAgICAgICB0ZXJtaW5hdGVFYXJseSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgd29ya2VyLmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCBvbldvcmtlckVycm9yKTtcbiAgICAgICAgbWVzc2FnZUhhbmRsZXIub24oXCJ0ZXN0XCIsIGRhdGEgPT4ge1xuICAgICAgICAgIHdvcmtlci5yZW1vdmVFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgb25Xb3JrZXJFcnJvcik7XG4gICAgICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgICAgICB0ZXJtaW5hdGVFYXJseSgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgICAgdGhpcy5fbWVzc2FnZUhhbmRsZXIgPSBtZXNzYWdlSGFuZGxlcjtcbiAgICAgICAgICAgIHRoaXMuX3BvcnQgPSB3b3JrZXI7XG4gICAgICAgICAgICB0aGlzLl93ZWJXb3JrZXIgPSB3b3JrZXI7XG4gICAgICAgICAgICB0aGlzLl9yZWFkeUNhcGFiaWxpdHkucmVzb2x2ZSgpO1xuICAgICAgICAgICAgbWVzc2FnZUhhbmRsZXIuc2VuZChcImNvbmZpZ3VyZVwiLCB7XG4gICAgICAgICAgICAgIHZlcmJvc2l0eTogdGhpcy52ZXJib3NpdHlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9zZXR1cEZha2VXb3JrZXIoKTtcbiAgICAgICAgICAgIG1lc3NhZ2VIYW5kbGVyLmRlc3Ryb3koKTtcbiAgICAgICAgICAgIHdvcmtlci50ZXJtaW5hdGUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBtZXNzYWdlSGFuZGxlci5vbihcInJlYWR5XCIsIGRhdGEgPT4ge1xuICAgICAgICAgIHdvcmtlci5yZW1vdmVFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgb25Xb3JrZXJFcnJvcik7XG4gICAgICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgICAgICB0ZXJtaW5hdGVFYXJseSgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgc2VuZFRlc3QoKTtcbiAgICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICAgIHRoaXMuX3NldHVwRmFrZVdvcmtlcigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHNlbmRUZXN0ID0gKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHRlc3RPYmogPSBuZXcgVWludDhBcnJheSgpO1xuICAgICAgICAgIG1lc3NhZ2VIYW5kbGVyLnNlbmQoXCJ0ZXN0XCIsIHRlc3RPYmosIFt0ZXN0T2JqLmJ1ZmZlcl0pO1xuICAgICAgICB9O1xuICAgICAgICBzZW5kVGVzdCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGNhdGNoIHtcbiAgICAgICAgKDAsIF91dGlsLmluZm8pKFwiVGhlIHdvcmtlciBoYXMgYmVlbiBkaXNhYmxlZC5cIik7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX3NldHVwRmFrZVdvcmtlcigpO1xuICB9XG4gIF9zZXR1cEZha2VXb3JrZXIoKSB7XG4gICAgaWYgKCFQREZXb3JrZXJVdGlsLmlzV29ya2VyRGlzYWJsZWQpIHtcbiAgICAgICgwLCBfdXRpbC53YXJuKShcIlNldHRpbmcgdXAgZmFrZSB3b3JrZXIuXCIpO1xuICAgICAgUERGV29ya2VyVXRpbC5pc1dvcmtlckRpc2FibGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgUERGV29ya2VyLl9zZXR1cEZha2VXb3JrZXJHbG9iYWwudGhlbihXb3JrZXJNZXNzYWdlSGFuZGxlciA9PiB7XG4gICAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgICAgdGhpcy5fcmVhZHlDYXBhYmlsaXR5LnJlamVjdChuZXcgRXJyb3IoXCJXb3JrZXIgd2FzIGRlc3Ryb3llZFwiKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHBvcnQgPSBuZXcgTG9vcGJhY2tQb3J0KCk7XG4gICAgICB0aGlzLl9wb3J0ID0gcG9ydDtcbiAgICAgIGNvbnN0IGlkID0gYGZha2Uke1BERldvcmtlclV0aWwuZmFrZVdvcmtlcklkKyt9YDtcbiAgICAgIGNvbnN0IHdvcmtlckhhbmRsZXIgPSBuZXcgX21lc3NhZ2VfaGFuZGxlci5NZXNzYWdlSGFuZGxlcihpZCArIFwiX3dvcmtlclwiLCBpZCwgcG9ydCk7XG4gICAgICBXb3JrZXJNZXNzYWdlSGFuZGxlci5zZXR1cCh3b3JrZXJIYW5kbGVyLCBwb3J0KTtcbiAgICAgIGNvbnN0IG1lc3NhZ2VIYW5kbGVyID0gbmV3IF9tZXNzYWdlX2hhbmRsZXIuTWVzc2FnZUhhbmRsZXIoaWQsIGlkICsgXCJfd29ya2VyXCIsIHBvcnQpO1xuICAgICAgdGhpcy5fbWVzc2FnZUhhbmRsZXIgPSBtZXNzYWdlSGFuZGxlcjtcbiAgICAgIHRoaXMuX3JlYWR5Q2FwYWJpbGl0eS5yZXNvbHZlKCk7XG4gICAgICBtZXNzYWdlSGFuZGxlci5zZW5kKFwiY29uZmlndXJlXCIsIHtcbiAgICAgICAgdmVyYm9zaXR5OiB0aGlzLnZlcmJvc2l0eVxuICAgICAgfSk7XG4gICAgfSkuY2F0Y2gocmVhc29uID0+IHtcbiAgICAgIHRoaXMuX3JlYWR5Q2FwYWJpbGl0eS5yZWplY3QobmV3IEVycm9yKGBTZXR0aW5nIHVwIGZha2Ugd29ya2VyIGZhaWxlZDogXCIke3JlYXNvbi5tZXNzYWdlfVwiLmApKTtcbiAgICB9KTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZTtcbiAgICBpZiAodGhpcy5fd2ViV29ya2VyKSB7XG4gICAgICB0aGlzLl93ZWJXb3JrZXIudGVybWluYXRlKCk7XG4gICAgICB0aGlzLl93ZWJXb3JrZXIgPSBudWxsO1xuICAgIH1cbiAgICBQREZXb3JrZXIuI3dvcmtlclBvcnRzPy5kZWxldGUodGhpcy5fcG9ydCk7XG4gICAgdGhpcy5fcG9ydCA9IG51bGw7XG4gICAgaWYgKHRoaXMuX21lc3NhZ2VIYW5kbGVyKSB7XG4gICAgICB0aGlzLl9tZXNzYWdlSGFuZGxlci5kZXN0cm95KCk7XG4gICAgICB0aGlzLl9tZXNzYWdlSGFuZGxlciA9IG51bGw7XG4gICAgfVxuICB9XG4gIHN0YXRpYyBmcm9tUG9ydChwYXJhbXMpIHtcbiAgICBpZiAoIXBhcmFtcz8ucG9ydCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUERGV29ya2VyLmZyb21Qb3J0IC0gaW52YWxpZCBtZXRob2Qgc2lnbmF0dXJlLlwiKTtcbiAgICB9XG4gICAgY29uc3QgY2FjaGVkUG9ydCA9IHRoaXMuI3dvcmtlclBvcnRzPy5nZXQocGFyYW1zLnBvcnQpO1xuICAgIGlmIChjYWNoZWRQb3J0KSB7XG4gICAgICBpZiAoY2FjaGVkUG9ydC5fcGVuZGluZ0Rlc3Ryb3kpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUERGV29ya2VyLmZyb21Qb3J0IC0gdGhlIHdvcmtlciBpcyBiZWluZyBkZXN0cm95ZWQuXFxuXCIgKyBcIlBsZWFzZSByZW1lbWJlciB0byBhd2FpdCBgUERGRG9jdW1lbnRMb2FkaW5nVGFzay5kZXN0cm95KClgLWNhbGxzLlwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjYWNoZWRQb3J0O1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFBERldvcmtlcihwYXJhbXMpO1xuICB9XG4gIHN0YXRpYyBnZXQgd29ya2VyU3JjKCkge1xuICAgIGlmIChfd29ya2VyX29wdGlvbnMuR2xvYmFsV29ya2VyT3B0aW9ucy53b3JrZXJTcmMpIHtcbiAgICAgIHJldHVybiBfd29ya2VyX29wdGlvbnMuR2xvYmFsV29ya2VyT3B0aW9ucy53b3JrZXJTcmM7XG4gICAgfVxuICAgIGlmIChQREZXb3JrZXJVdGlsLmZhbGxiYWNrV29ya2VyU3JjICE9PSBudWxsKSB7XG4gICAgICBpZiAoIV91dGlsLmlzTm9kZUpTKSB7XG4gICAgICAgICgwLCBfZGlzcGxheV91dGlscy5kZXByZWNhdGVkKSgnTm8gXCJHbG9iYWxXb3JrZXJPcHRpb25zLndvcmtlclNyY1wiIHNwZWNpZmllZC4nKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBQREZXb3JrZXJVdGlsLmZhbGxiYWNrV29ya2VyU3JjO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIFwiR2xvYmFsV29ya2VyT3B0aW9ucy53b3JrZXJTcmNcIiBzcGVjaWZpZWQuJyk7XG4gIH1cbiAgc3RhdGljIGdldCBfbWFpblRocmVhZFdvcmtlck1lc3NhZ2VIYW5kbGVyKCkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZ2xvYmFsVGhpcy5wZGZqc1dvcmtlcj8uV29ya2VyTWVzc2FnZUhhbmRsZXIgfHwgbnVsbDtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgZ2V0IF9zZXR1cEZha2VXb3JrZXJHbG9iYWwoKSB7XG4gICAgY29uc3QgbG9hZGVyID0gYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbWFpbldvcmtlck1lc3NhZ2VIYW5kbGVyID0gdGhpcy5fbWFpblRocmVhZFdvcmtlck1lc3NhZ2VIYW5kbGVyO1xuICAgICAgaWYgKG1haW5Xb3JrZXJNZXNzYWdlSGFuZGxlcikge1xuICAgICAgICByZXR1cm4gbWFpbldvcmtlck1lc3NhZ2VIYW5kbGVyO1xuICAgICAgfVxuICAgICAgaWYgKF91dGlsLmlzTm9kZUpTICYmIHR5cGVvZiByZXF1aXJlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgY29uc3Qgd29ya2VyID0gZXZhbChcInJlcXVpcmVcIikodGhpcy53b3JrZXJTcmMpO1xuICAgICAgICByZXR1cm4gd29ya2VyLldvcmtlck1lc3NhZ2VIYW5kbGVyO1xuICAgICAgfVxuICAgICAgYXdhaXQgKDAsIF9kaXNwbGF5X3V0aWxzLmxvYWRTY3JpcHQpKHRoaXMud29ya2VyU3JjKTtcbiAgICAgIHJldHVybiB3aW5kb3cucGRmanNXb3JrZXIuV29ya2VyTWVzc2FnZUhhbmRsZXI7XG4gICAgfTtcbiAgICByZXR1cm4gKDAsIF91dGlsLnNoYWRvdykodGhpcywgXCJfc2V0dXBGYWtlV29ya2VyR2xvYmFsXCIsIGxvYWRlcigpKTtcbiAgfVxufVxuZXhwb3J0cy5QREZXb3JrZXIgPSBQREZXb3JrZXI7XG5jbGFzcyBXb3JrZXJUcmFuc3BvcnQge1xuICAjbWV0aG9kUHJvbWlzZXMgPSBuZXcgTWFwKCk7XG4gICNwYWdlQ2FjaGUgPSBuZXcgTWFwKCk7XG4gICNwYWdlUHJvbWlzZXMgPSBuZXcgTWFwKCk7XG4gICNwYXNzd29yZENhcGFiaWxpdHkgPSBudWxsO1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlSGFuZGxlciwgbG9hZGluZ1Rhc2ssIG5ldHdvcmtTdHJlYW0sIHBhcmFtcywgZmFjdG9yeSkge1xuICAgIHRoaXMubWVzc2FnZUhhbmRsZXIgPSBtZXNzYWdlSGFuZGxlcjtcbiAgICB0aGlzLmxvYWRpbmdUYXNrID0gbG9hZGluZ1Rhc2s7XG4gICAgdGhpcy5jb21tb25PYmpzID0gbmV3IFBERk9iamVjdHMoKTtcbiAgICB0aGlzLmZvbnRMb2FkZXIgPSBuZXcgX2ZvbnRfbG9hZGVyLkZvbnRMb2FkZXIoe1xuICAgICAgb3duZXJEb2N1bWVudDogcGFyYW1zLm93bmVyRG9jdW1lbnQsXG4gICAgICBzdHlsZUVsZW1lbnQ6IHBhcmFtcy5zdHlsZUVsZW1lbnRcbiAgICB9KTtcbiAgICB0aGlzLl9wYXJhbXMgPSBwYXJhbXM7XG4gICAgdGhpcy5jYW52YXNGYWN0b3J5ID0gZmFjdG9yeS5jYW52YXNGYWN0b3J5O1xuICAgIHRoaXMuZmlsdGVyRmFjdG9yeSA9IGZhY3RvcnkuZmlsdGVyRmFjdG9yeTtcbiAgICB0aGlzLmNNYXBSZWFkZXJGYWN0b3J5ID0gZmFjdG9yeS5jTWFwUmVhZGVyRmFjdG9yeTtcbiAgICB0aGlzLnN0YW5kYXJkRm9udERhdGFGYWN0b3J5ID0gZmFjdG9yeS5zdGFuZGFyZEZvbnREYXRhRmFjdG9yeTtcbiAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgIHRoaXMuZGVzdHJveUNhcGFiaWxpdHkgPSBudWxsO1xuICAgIHRoaXMuX25ldHdvcmtTdHJlYW0gPSBuZXR3b3JrU3RyZWFtO1xuICAgIHRoaXMuX2Z1bGxSZWFkZXIgPSBudWxsO1xuICAgIHRoaXMuX2xhc3RQcm9ncmVzcyA9IG51bGw7XG4gICAgdGhpcy5kb3dubG9hZEluZm9DYXBhYmlsaXR5ID0gbmV3IF91dGlsLlByb21pc2VDYXBhYmlsaXR5KCk7XG4gICAgdGhpcy5zZXR1cE1lc3NhZ2VIYW5kbGVyKCk7XG4gIH1cbiAgI2NhY2hlU2ltcGxlTWV0aG9kKG5hbWUsIGRhdGEgPSBudWxsKSB7XG4gICAgY29uc3QgY2FjaGVkUHJvbWlzZSA9IHRoaXMuI21ldGhvZFByb21pc2VzLmdldChuYW1lKTtcbiAgICBpZiAoY2FjaGVkUHJvbWlzZSkge1xuICAgICAgcmV0dXJuIGNhY2hlZFByb21pc2U7XG4gICAgfVxuICAgIGNvbnN0IHByb21pc2UgPSB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShuYW1lLCBkYXRhKTtcbiAgICB0aGlzLiNtZXRob2RQcm9taXNlcy5zZXQobmFtZSwgcHJvbWlzZSk7XG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH1cbiAgZ2V0IGFubm90YXRpb25TdG9yYWdlKCkge1xuICAgIHJldHVybiAoMCwgX3V0aWwuc2hhZG93KSh0aGlzLCBcImFubm90YXRpb25TdG9yYWdlXCIsIG5ldyBfYW5ub3RhdGlvbl9zdG9yYWdlLkFubm90YXRpb25TdG9yYWdlKCkpO1xuICB9XG4gIGdldFJlbmRlcmluZ0ludGVudChpbnRlbnQsIGFubm90YXRpb25Nb2RlID0gX3V0aWwuQW5ub3RhdGlvbk1vZGUuRU5BQkxFLCBwcmludEFubm90YXRpb25TdG9yYWdlID0gbnVsbCwgaXNPcExpc3QgPSBmYWxzZSkge1xuICAgIGxldCByZW5kZXJpbmdJbnRlbnQgPSBfdXRpbC5SZW5kZXJpbmdJbnRlbnRGbGFnLkRJU1BMQVk7XG4gICAgbGV0IGFubm90YXRpb25TdG9yYWdlU2VyaWFsaXphYmxlID0gX2Fubm90YXRpb25fc3RvcmFnZS5TZXJpYWxpemFibGVFbXB0eTtcbiAgICBzd2l0Y2ggKGludGVudCkge1xuICAgICAgY2FzZSBcImFueVwiOlxuICAgICAgICByZW5kZXJpbmdJbnRlbnQgPSBfdXRpbC5SZW5kZXJpbmdJbnRlbnRGbGFnLkFOWTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiZGlzcGxheVwiOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJwcmludFwiOlxuICAgICAgICByZW5kZXJpbmdJbnRlbnQgPSBfdXRpbC5SZW5kZXJpbmdJbnRlbnRGbGFnLlBSSU5UO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgICgwLCBfdXRpbC53YXJuKShgZ2V0UmVuZGVyaW5nSW50ZW50IC0gaW52YWxpZCBpbnRlbnQ6ICR7aW50ZW50fWApO1xuICAgIH1cbiAgICBzd2l0Y2ggKGFubm90YXRpb25Nb2RlKSB7XG4gICAgICBjYXNlIF91dGlsLkFubm90YXRpb25Nb2RlLkRJU0FCTEU6XG4gICAgICAgIHJlbmRlcmluZ0ludGVudCArPSBfdXRpbC5SZW5kZXJpbmdJbnRlbnRGbGFnLkFOTk9UQVRJT05TX0RJU0FCTEU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBfdXRpbC5Bbm5vdGF0aW9uTW9kZS5FTkFCTEU6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBfdXRpbC5Bbm5vdGF0aW9uTW9kZS5FTkFCTEVfRk9STVM6XG4gICAgICAgIHJlbmRlcmluZ0ludGVudCArPSBfdXRpbC5SZW5kZXJpbmdJbnRlbnRGbGFnLkFOTk9UQVRJT05TX0ZPUk1TO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgX3V0aWwuQW5ub3RhdGlvbk1vZGUuRU5BQkxFX1NUT1JBR0U6XG4gICAgICAgIHJlbmRlcmluZ0ludGVudCArPSBfdXRpbC5SZW5kZXJpbmdJbnRlbnRGbGFnLkFOTk9UQVRJT05TX1NUT1JBR0U7XG4gICAgICAgIGNvbnN0IGFubm90YXRpb25TdG9yYWdlID0gcmVuZGVyaW5nSW50ZW50ICYgX3V0aWwuUmVuZGVyaW5nSW50ZW50RmxhZy5QUklOVCAmJiBwcmludEFubm90YXRpb25TdG9yYWdlIGluc3RhbmNlb2YgX2Fubm90YXRpb25fc3RvcmFnZS5QcmludEFubm90YXRpb25TdG9yYWdlID8gcHJpbnRBbm5vdGF0aW9uU3RvcmFnZSA6IHRoaXMuYW5ub3RhdGlvblN0b3JhZ2U7XG4gICAgICAgIGFubm90YXRpb25TdG9yYWdlU2VyaWFsaXphYmxlID0gYW5ub3RhdGlvblN0b3JhZ2Uuc2VyaWFsaXphYmxlO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgICgwLCBfdXRpbC53YXJuKShgZ2V0UmVuZGVyaW5nSW50ZW50IC0gaW52YWxpZCBhbm5vdGF0aW9uTW9kZTogJHthbm5vdGF0aW9uTW9kZX1gKTtcbiAgICB9XG4gICAgaWYgKGlzT3BMaXN0KSB7XG4gICAgICByZW5kZXJpbmdJbnRlbnQgKz0gX3V0aWwuUmVuZGVyaW5nSW50ZW50RmxhZy5PUExJU1Q7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICByZW5kZXJpbmdJbnRlbnQsXG4gICAgICBjYWNoZUtleTogYCR7cmVuZGVyaW5nSW50ZW50fV8ke2Fubm90YXRpb25TdG9yYWdlU2VyaWFsaXphYmxlLmhhc2h9YCxcbiAgICAgIGFubm90YXRpb25TdG9yYWdlU2VyaWFsaXphYmxlXG4gICAgfTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIGlmICh0aGlzLmRlc3Ryb3lDYXBhYmlsaXR5KSB7XG4gICAgICByZXR1cm4gdGhpcy5kZXN0cm95Q2FwYWJpbGl0eS5wcm9taXNlO1xuICAgIH1cbiAgICB0aGlzLmRlc3Ryb3llZCA9IHRydWU7XG4gICAgdGhpcy5kZXN0cm95Q2FwYWJpbGl0eSA9IG5ldyBfdXRpbC5Qcm9taXNlQ2FwYWJpbGl0eSgpO1xuICAgIHRoaXMuI3Bhc3N3b3JkQ2FwYWJpbGl0eT8ucmVqZWN0KG5ldyBFcnJvcihcIldvcmtlciB3YXMgZGVzdHJveWVkIGR1cmluZyBvblBhc3N3b3JkIGNhbGxiYWNrXCIpKTtcbiAgICBjb25zdCB3YWl0T24gPSBbXTtcbiAgICBmb3IgKGNvbnN0IHBhZ2Ugb2YgdGhpcy4jcGFnZUNhY2hlLnZhbHVlcygpKSB7XG4gICAgICB3YWl0T24ucHVzaChwYWdlLl9kZXN0cm95KCkpO1xuICAgIH1cbiAgICB0aGlzLiNwYWdlQ2FjaGUuY2xlYXIoKTtcbiAgICB0aGlzLiNwYWdlUHJvbWlzZXMuY2xlYXIoKTtcbiAgICBpZiAodGhpcy5oYXNPd25Qcm9wZXJ0eShcImFubm90YXRpb25TdG9yYWdlXCIpKSB7XG4gICAgICB0aGlzLmFubm90YXRpb25TdG9yYWdlLnJlc2V0TW9kaWZpZWQoKTtcbiAgICB9XG4gICAgY29uc3QgdGVybWluYXRlZCA9IHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiVGVybWluYXRlXCIsIG51bGwpO1xuICAgIHdhaXRPbi5wdXNoKHRlcm1pbmF0ZWQpO1xuICAgIFByb21pc2UuYWxsKHdhaXRPbikudGhlbigoKSA9PiB7XG4gICAgICB0aGlzLmNvbW1vbk9ianMuY2xlYXIoKTtcbiAgICAgIHRoaXMuZm9udExvYWRlci5jbGVhcigpO1xuICAgICAgdGhpcy4jbWV0aG9kUHJvbWlzZXMuY2xlYXIoKTtcbiAgICAgIHRoaXMuZmlsdGVyRmFjdG9yeS5kZXN0cm95KCk7XG4gICAgICB0aGlzLl9uZXR3b3JrU3RyZWFtPy5jYW5jZWxBbGxSZXF1ZXN0cyhuZXcgX3V0aWwuQWJvcnRFeGNlcHRpb24oXCJXb3JrZXIgd2FzIHRlcm1pbmF0ZWQuXCIpKTtcbiAgICAgIGlmICh0aGlzLm1lc3NhZ2VIYW5kbGVyKSB7XG4gICAgICAgIHRoaXMubWVzc2FnZUhhbmRsZXIuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLm1lc3NhZ2VIYW5kbGVyID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHRoaXMuZGVzdHJveUNhcGFiaWxpdHkucmVzb2x2ZSgpO1xuICAgIH0sIHRoaXMuZGVzdHJveUNhcGFiaWxpdHkucmVqZWN0KTtcbiAgICByZXR1cm4gdGhpcy5kZXN0cm95Q2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG4gIHNldHVwTWVzc2FnZUhhbmRsZXIoKSB7XG4gICAgY29uc3Qge1xuICAgICAgbWVzc2FnZUhhbmRsZXIsXG4gICAgICBsb2FkaW5nVGFza1xuICAgIH0gPSB0aGlzO1xuICAgIG1lc3NhZ2VIYW5kbGVyLm9uKFwiR2V0UmVhZGVyXCIsIChkYXRhLCBzaW5rKSA9PiB7XG4gICAgICAoMCwgX3V0aWwuYXNzZXJ0KSh0aGlzLl9uZXR3b3JrU3RyZWFtLCBcIkdldFJlYWRlciAtIG5vIGBJUERGU3RyZWFtYCBpbnN0YW5jZSBhdmFpbGFibGUuXCIpO1xuICAgICAgdGhpcy5fZnVsbFJlYWRlciA9IHRoaXMuX25ldHdvcmtTdHJlYW0uZ2V0RnVsbFJlYWRlcigpO1xuICAgICAgdGhpcy5fZnVsbFJlYWRlci5vblByb2dyZXNzID0gZXZ0ID0+IHtcbiAgICAgICAgdGhpcy5fbGFzdFByb2dyZXNzID0ge1xuICAgICAgICAgIGxvYWRlZDogZXZ0LmxvYWRlZCxcbiAgICAgICAgICB0b3RhbDogZXZ0LnRvdGFsXG4gICAgICAgIH07XG4gICAgICB9O1xuICAgICAgc2luay5vblB1bGwgPSAoKSA9PiB7XG4gICAgICAgIHRoaXMuX2Z1bGxSZWFkZXIucmVhZCgpLnRoZW4oZnVuY3Rpb24gKHtcbiAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICBkb25lXG4gICAgICAgIH0pIHtcbiAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgc2luay5jbG9zZSgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICAoMCwgX3V0aWwuYXNzZXJ0KSh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyLCBcIkdldFJlYWRlciAtIGV4cGVjdGVkIGFuIEFycmF5QnVmZmVyLlwiKTtcbiAgICAgICAgICBzaW5rLmVucXVldWUobmV3IFVpbnQ4QXJyYXkodmFsdWUpLCAxLCBbdmFsdWVdKTtcbiAgICAgICAgfSkuY2F0Y2gocmVhc29uID0+IHtcbiAgICAgICAgICBzaW5rLmVycm9yKHJlYXNvbik7XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIHNpbmsub25DYW5jZWwgPSByZWFzb24gPT4ge1xuICAgICAgICB0aGlzLl9mdWxsUmVhZGVyLmNhbmNlbChyZWFzb24pO1xuICAgICAgICBzaW5rLnJlYWR5LmNhdGNoKHJlYWR5UmVhc29uID0+IHtcbiAgICAgICAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhyb3cgcmVhZHlSZWFzb247XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICB9KTtcbiAgICBtZXNzYWdlSGFuZGxlci5vbihcIlJlYWRlckhlYWRlcnNSZWFkeVwiLCBkYXRhID0+IHtcbiAgICAgIGNvbnN0IGhlYWRlcnNDYXBhYmlsaXR5ID0gbmV3IF91dGlsLlByb21pc2VDYXBhYmlsaXR5KCk7XG4gICAgICBjb25zdCBmdWxsUmVhZGVyID0gdGhpcy5fZnVsbFJlYWRlcjtcbiAgICAgIGZ1bGxSZWFkZXIuaGVhZGVyc1JlYWR5LnRoZW4oKCkgPT4ge1xuICAgICAgICBpZiAoIWZ1bGxSZWFkZXIuaXNTdHJlYW1pbmdTdXBwb3J0ZWQgfHwgIWZ1bGxSZWFkZXIuaXNSYW5nZVN1cHBvcnRlZCkge1xuICAgICAgICAgIGlmICh0aGlzLl9sYXN0UHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgIGxvYWRpbmdUYXNrLm9uUHJvZ3Jlc3M/Lih0aGlzLl9sYXN0UHJvZ3Jlc3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdWxsUmVhZGVyLm9uUHJvZ3Jlc3MgPSBldnQgPT4ge1xuICAgICAgICAgICAgbG9hZGluZ1Rhc2sub25Qcm9ncmVzcz8uKHtcbiAgICAgICAgICAgICAgbG9hZGVkOiBldnQubG9hZGVkLFxuICAgICAgICAgICAgICB0b3RhbDogZXZ0LnRvdGFsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGhlYWRlcnNDYXBhYmlsaXR5LnJlc29sdmUoe1xuICAgICAgICAgIGlzU3RyZWFtaW5nU3VwcG9ydGVkOiBmdWxsUmVhZGVyLmlzU3RyZWFtaW5nU3VwcG9ydGVkLFxuICAgICAgICAgIGlzUmFuZ2VTdXBwb3J0ZWQ6IGZ1bGxSZWFkZXIuaXNSYW5nZVN1cHBvcnRlZCxcbiAgICAgICAgICBjb250ZW50TGVuZ3RoOiBmdWxsUmVhZGVyLmNvbnRlbnRMZW5ndGhcbiAgICAgICAgfSk7XG4gICAgICB9LCBoZWFkZXJzQ2FwYWJpbGl0eS5yZWplY3QpO1xuICAgICAgcmV0dXJuIGhlYWRlcnNDYXBhYmlsaXR5LnByb21pc2U7XG4gICAgfSk7XG4gICAgbWVzc2FnZUhhbmRsZXIub24oXCJHZXRSYW5nZVJlYWRlclwiLCAoZGF0YSwgc2luaykgPT4ge1xuICAgICAgKDAsIF91dGlsLmFzc2VydCkodGhpcy5fbmV0d29ya1N0cmVhbSwgXCJHZXRSYW5nZVJlYWRlciAtIG5vIGBJUERGU3RyZWFtYCBpbnN0YW5jZSBhdmFpbGFibGUuXCIpO1xuICAgICAgY29uc3QgcmFuZ2VSZWFkZXIgPSB0aGlzLl9uZXR3b3JrU3RyZWFtLmdldFJhbmdlUmVhZGVyKGRhdGEuYmVnaW4sIGRhdGEuZW5kKTtcbiAgICAgIGlmICghcmFuZ2VSZWFkZXIpIHtcbiAgICAgICAgc2luay5jbG9zZSgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzaW5rLm9uUHVsbCA9ICgpID0+IHtcbiAgICAgICAgcmFuZ2VSZWFkZXIucmVhZCgpLnRoZW4oZnVuY3Rpb24gKHtcbiAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICBkb25lXG4gICAgICAgIH0pIHtcbiAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgc2luay5jbG9zZSgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICAoMCwgX3V0aWwuYXNzZXJ0KSh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyLCBcIkdldFJhbmdlUmVhZGVyIC0gZXhwZWN0ZWQgYW4gQXJyYXlCdWZmZXIuXCIpO1xuICAgICAgICAgIHNpbmsuZW5xdWV1ZShuZXcgVWludDhBcnJheSh2YWx1ZSksIDEsIFt2YWx1ZV0pO1xuICAgICAgICB9KS5jYXRjaChyZWFzb24gPT4ge1xuICAgICAgICAgIHNpbmsuZXJyb3IocmVhc29uKTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgc2luay5vbkNhbmNlbCA9IHJlYXNvbiA9PiB7XG4gICAgICAgIHJhbmdlUmVhZGVyLmNhbmNlbChyZWFzb24pO1xuICAgICAgICBzaW5rLnJlYWR5LmNhdGNoKHJlYWR5UmVhc29uID0+IHtcbiAgICAgICAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhyb3cgcmVhZHlSZWFzb247XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICB9KTtcbiAgICBtZXNzYWdlSGFuZGxlci5vbihcIkdldERvY1wiLCAoe1xuICAgICAgcGRmSW5mb1xuICAgIH0pID0+IHtcbiAgICAgIHRoaXMuX251bVBhZ2VzID0gcGRmSW5mby5udW1QYWdlcztcbiAgICAgIHRoaXMuX2h0bWxGb3JYZmEgPSBwZGZJbmZvLmh0bWxGb3JYZmE7XG4gICAgICBkZWxldGUgcGRmSW5mby5odG1sRm9yWGZhO1xuICAgICAgbG9hZGluZ1Rhc2suX2NhcGFiaWxpdHkucmVzb2x2ZShuZXcgUERGRG9jdW1lbnRQcm94eShwZGZJbmZvLCB0aGlzKSk7XG4gICAgfSk7XG4gICAgbWVzc2FnZUhhbmRsZXIub24oXCJEb2NFeGNlcHRpb25cIiwgZnVuY3Rpb24gKGV4KSB7XG4gICAgICBsZXQgcmVhc29uO1xuICAgICAgc3dpdGNoIChleC5uYW1lKSB7XG4gICAgICAgIGNhc2UgXCJQYXNzd29yZEV4Y2VwdGlvblwiOlxuICAgICAgICAgIHJlYXNvbiA9IG5ldyBfdXRpbC5QYXNzd29yZEV4Y2VwdGlvbihleC5tZXNzYWdlLCBleC5jb2RlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIkludmFsaWRQREZFeGNlcHRpb25cIjpcbiAgICAgICAgICByZWFzb24gPSBuZXcgX3V0aWwuSW52YWxpZFBERkV4Y2VwdGlvbihleC5tZXNzYWdlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIk1pc3NpbmdQREZFeGNlcHRpb25cIjpcbiAgICAgICAgICByZWFzb24gPSBuZXcgX3V0aWwuTWlzc2luZ1BERkV4Y2VwdGlvbihleC5tZXNzYWdlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIlVuZXhwZWN0ZWRSZXNwb25zZUV4Y2VwdGlvblwiOlxuICAgICAgICAgIHJlYXNvbiA9IG5ldyBfdXRpbC5VbmV4cGVjdGVkUmVzcG9uc2VFeGNlcHRpb24oZXgubWVzc2FnZSwgZXguc3RhdHVzKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIlVua25vd25FcnJvckV4Y2VwdGlvblwiOlxuICAgICAgICAgIHJlYXNvbiA9IG5ldyBfdXRpbC5Vbmtub3duRXJyb3JFeGNlcHRpb24oZXgubWVzc2FnZSwgZXguZGV0YWlscyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgKDAsIF91dGlsLnVucmVhY2hhYmxlKShcIkRvY0V4Y2VwdGlvbiAtIGV4cGVjdGVkIGEgdmFsaWQgRXJyb3IuXCIpO1xuICAgICAgfVxuICAgICAgbG9hZGluZ1Rhc2suX2NhcGFiaWxpdHkucmVqZWN0KHJlYXNvbik7XG4gICAgfSk7XG4gICAgbWVzc2FnZUhhbmRsZXIub24oXCJQYXNzd29yZFJlcXVlc3RcIiwgZXhjZXB0aW9uID0+IHtcbiAgICAgIHRoaXMuI3Bhc3N3b3JkQ2FwYWJpbGl0eSA9IG5ldyBfdXRpbC5Qcm9taXNlQ2FwYWJpbGl0eSgpO1xuICAgICAgaWYgKGxvYWRpbmdUYXNrLm9uUGFzc3dvcmQpIHtcbiAgICAgICAgY29uc3QgdXBkYXRlUGFzc3dvcmQgPSBwYXNzd29yZCA9PiB7XG4gICAgICAgICAgaWYgKHBhc3N3b3JkIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgIHRoaXMuI3Bhc3N3b3JkQ2FwYWJpbGl0eS5yZWplY3QocGFzc3dvcmQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLiNwYXNzd29yZENhcGFiaWxpdHkucmVzb2x2ZSh7XG4gICAgICAgICAgICAgIHBhc3N3b3JkXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgbG9hZGluZ1Rhc2sub25QYXNzd29yZCh1cGRhdGVQYXNzd29yZCwgZXhjZXB0aW9uLmNvZGUpO1xuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgIHRoaXMuI3Bhc3N3b3JkQ2FwYWJpbGl0eS5yZWplY3QoZXgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLiNwYXNzd29yZENhcGFiaWxpdHkucmVqZWN0KG5ldyBfdXRpbC5QYXNzd29yZEV4Y2VwdGlvbihleGNlcHRpb24ubWVzc2FnZSwgZXhjZXB0aW9uLmNvZGUpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLiNwYXNzd29yZENhcGFiaWxpdHkucHJvbWlzZTtcbiAgICB9KTtcbiAgICBtZXNzYWdlSGFuZGxlci5vbihcIkRhdGFMb2FkZWRcIiwgZGF0YSA9PiB7XG4gICAgICBsb2FkaW5nVGFzay5vblByb2dyZXNzPy4oe1xuICAgICAgICBsb2FkZWQ6IGRhdGEubGVuZ3RoLFxuICAgICAgICB0b3RhbDogZGF0YS5sZW5ndGhcbiAgICAgIH0pO1xuICAgICAgdGhpcy5kb3dubG9hZEluZm9DYXBhYmlsaXR5LnJlc29sdmUoZGF0YSk7XG4gICAgfSk7XG4gICAgbWVzc2FnZUhhbmRsZXIub24oXCJTdGFydFJlbmRlclBhZ2VcIiwgZGF0YSA9PiB7XG4gICAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgcGFnZSA9IHRoaXMuI3BhZ2VDYWNoZS5nZXQoZGF0YS5wYWdlSW5kZXgpO1xuICAgICAgcGFnZS5fc3RhcnRSZW5kZXJQYWdlKGRhdGEudHJhbnNwYXJlbmN5LCBkYXRhLmNhY2hlS2V5KTtcbiAgICB9KTtcbiAgICBtZXNzYWdlSGFuZGxlci5vbihcImNvbW1vbm9ialwiLCAoW2lkLCB0eXBlLCBleHBvcnRlZERhdGFdKSA9PiB7XG4gICAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuY29tbW9uT2Jqcy5oYXMoaWQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIFwiRm9udFwiOlxuICAgICAgICAgIGNvbnN0IHBhcmFtcyA9IHRoaXMuX3BhcmFtcztcbiAgICAgICAgICBpZiAoXCJlcnJvclwiIGluIGV4cG9ydGVkRGF0YSkge1xuICAgICAgICAgICAgY29uc3QgZXhwb3J0ZWRFcnJvciA9IGV4cG9ydGVkRGF0YS5lcnJvcjtcbiAgICAgICAgICAgICgwLCBfdXRpbC53YXJuKShgRXJyb3IgZHVyaW5nIGZvbnQgbG9hZGluZzogJHtleHBvcnRlZEVycm9yfWApO1xuICAgICAgICAgICAgdGhpcy5jb21tb25PYmpzLnJlc29sdmUoaWQsIGV4cG9ydGVkRXJyb3IpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGluc3BlY3RGb250ID0gcGFyYW1zLnBkZkJ1ZyAmJiBnbG9iYWxUaGlzLkZvbnRJbnNwZWN0b3I/LmVuYWJsZWQgPyAoZm9udCwgdXJsKSA9PiBnbG9iYWxUaGlzLkZvbnRJbnNwZWN0b3IuZm9udEFkZGVkKGZvbnQsIHVybCkgOiBudWxsO1xuICAgICAgICAgIGNvbnN0IGZvbnQgPSBuZXcgX2ZvbnRfbG9hZGVyLkZvbnRGYWNlT2JqZWN0KGV4cG9ydGVkRGF0YSwge1xuICAgICAgICAgICAgaXNFdmFsU3VwcG9ydGVkOiBwYXJhbXMuaXNFdmFsU3VwcG9ydGVkLFxuICAgICAgICAgICAgZGlzYWJsZUZvbnRGYWNlOiBwYXJhbXMuZGlzYWJsZUZvbnRGYWNlLFxuICAgICAgICAgICAgaWdub3JlRXJyb3JzOiBwYXJhbXMuaWdub3JlRXJyb3JzLFxuICAgICAgICAgICAgaW5zcGVjdEZvbnRcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0aGlzLmZvbnRMb2FkZXIuYmluZChmb250KS5jYXRjaChyZWFzb24gPT4ge1xuICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShcIkZvbnRGYWxsYmFja1wiLCB7XG4gICAgICAgICAgICAgIGlkXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KS5maW5hbGx5KCgpID0+IHtcbiAgICAgICAgICAgIGlmICghcGFyYW1zLmZvbnRFeHRyYVByb3BlcnRpZXMgJiYgZm9udC5kYXRhKSB7XG4gICAgICAgICAgICAgIGZvbnQuZGF0YSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNvbW1vbk9ianMucmVzb2x2ZShpZCwgZm9udCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJGb250UGF0aFwiOlxuICAgICAgICBjYXNlIFwiSW1hZ2VcIjpcbiAgICAgICAgY2FzZSBcIlBhdHRlcm5cIjpcbiAgICAgICAgICB0aGlzLmNvbW1vbk9ianMucmVzb2x2ZShpZCwgZXhwb3J0ZWREYXRhKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEdvdCB1bmtub3duIGNvbW1vbiBvYmplY3QgdHlwZSAke3R5cGV9YCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgbWVzc2FnZUhhbmRsZXIub24oXCJvYmpcIiwgKFtpZCwgcGFnZUluZGV4LCB0eXBlLCBpbWFnZURhdGFdKSA9PiB7XG4gICAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgcGFnZVByb3h5ID0gdGhpcy4jcGFnZUNhY2hlLmdldChwYWdlSW5kZXgpO1xuICAgICAgaWYgKHBhZ2VQcm94eS5vYmpzLmhhcyhpZCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgXCJJbWFnZVwiOlxuICAgICAgICAgIHBhZ2VQcm94eS5vYmpzLnJlc29sdmUoaWQsIGltYWdlRGF0YSk7XG4gICAgICAgICAgaWYgKGltYWdlRGF0YSkge1xuICAgICAgICAgICAgbGV0IGxlbmd0aDtcbiAgICAgICAgICAgIGlmIChpbWFnZURhdGEuYml0bWFwKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgICB3aWR0aCxcbiAgICAgICAgICAgICAgICBoZWlnaHRcbiAgICAgICAgICAgICAgfSA9IGltYWdlRGF0YTtcbiAgICAgICAgICAgICAgbGVuZ3RoID0gd2lkdGggKiBoZWlnaHQgKiA0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbGVuZ3RoID0gaW1hZ2VEYXRhLmRhdGE/Lmxlbmd0aCB8fCAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxlbmd0aCA+IF91dGlsLk1BWF9JTUFHRV9TSVpFX1RPX0NBQ0hFKSB7XG4gICAgICAgICAgICAgIHBhZ2VQcm94eS5fbWF5YmVDbGVhbnVwQWZ0ZXJSZW5kZXIgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIlBhdHRlcm5cIjpcbiAgICAgICAgICBwYWdlUHJveHkub2Jqcy5yZXNvbHZlKGlkLCBpbWFnZURhdGEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgR290IHVua25vd24gb2JqZWN0IHR5cGUgJHt0eXBlfWApO1xuICAgICAgfVxuICAgIH0pO1xuICAgIG1lc3NhZ2VIYW5kbGVyLm9uKFwiRG9jUHJvZ3Jlc3NcIiwgZGF0YSA9PiB7XG4gICAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbG9hZGluZ1Rhc2sub25Qcm9ncmVzcz8uKHtcbiAgICAgICAgbG9hZGVkOiBkYXRhLmxvYWRlZCxcbiAgICAgICAgdG90YWw6IGRhdGEudG90YWxcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIG1lc3NhZ2VIYW5kbGVyLm9uKFwiRmV0Y2hCdWlsdEluQ01hcFwiLCBkYXRhID0+IHtcbiAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiV29ya2VyIHdhcyBkZXN0cm95ZWQuXCIpKTtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5jTWFwUmVhZGVyRmFjdG9yeSkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiQ01hcFJlYWRlckZhY3Rvcnkgbm90IGluaXRpYWxpemVkLCBzZWUgdGhlIGB1c2VXb3JrZXJGZXRjaGAgcGFyYW1ldGVyLlwiKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5jTWFwUmVhZGVyRmFjdG9yeS5mZXRjaChkYXRhKTtcbiAgICB9KTtcbiAgICBtZXNzYWdlSGFuZGxlci5vbihcIkZldGNoU3RhbmRhcmRGb250RGF0YVwiLCBkYXRhID0+IHtcbiAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiV29ya2VyIHdhcyBkZXN0cm95ZWQuXCIpKTtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5zdGFuZGFyZEZvbnREYXRhRmFjdG9yeSkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiU3RhbmRhcmRGb250RGF0YUZhY3Rvcnkgbm90IGluaXRpYWxpemVkLCBzZWUgdGhlIGB1c2VXb3JrZXJGZXRjaGAgcGFyYW1ldGVyLlwiKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5zdGFuZGFyZEZvbnREYXRhRmFjdG9yeS5mZXRjaChkYXRhKTtcbiAgICB9KTtcbiAgfVxuICBnZXREYXRhKCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShcIkdldERhdGFcIiwgbnVsbCk7XG4gIH1cbiAgc2F2ZURvY3VtZW50KCkge1xuICAgIGlmICh0aGlzLmFubm90YXRpb25TdG9yYWdlLnNpemUgPD0gMCkge1xuICAgICAgKDAsIF91dGlsLndhcm4pKFwic2F2ZURvY3VtZW50IGNhbGxlZCB3aGlsZSBgYW5ub3RhdGlvblN0b3JhZ2VgIGlzIGVtcHR5LCBcIiArIFwicGxlYXNlIHVzZSB0aGUgZ2V0RGF0YS1tZXRob2QgaW5zdGVhZC5cIik7XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIG1hcCxcbiAgICAgIHRyYW5zZmVyc1xuICAgIH0gPSB0aGlzLmFubm90YXRpb25TdG9yYWdlLnNlcmlhbGl6YWJsZTtcbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJTYXZlRG9jdW1lbnRcIiwge1xuICAgICAgaXNQdXJlWGZhOiAhIXRoaXMuX2h0bWxGb3JYZmEsXG4gICAgICBudW1QYWdlczogdGhpcy5fbnVtUGFnZXMsXG4gICAgICBhbm5vdGF0aW9uU3RvcmFnZTogbWFwLFxuICAgICAgZmlsZW5hbWU6IHRoaXMuX2Z1bGxSZWFkZXI/LmZpbGVuYW1lID8/IG51bGxcbiAgICB9LCB0cmFuc2ZlcnMpLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgdGhpcy5hbm5vdGF0aW9uU3RvcmFnZS5yZXNldE1vZGlmaWVkKCk7XG4gICAgfSk7XG4gIH1cbiAgZ2V0UGFnZShwYWdlTnVtYmVyKSB7XG4gICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKHBhZ2VOdW1iZXIpIHx8IHBhZ2VOdW1iZXIgPD0gMCB8fCBwYWdlTnVtYmVyID4gdGhpcy5fbnVtUGFnZXMpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJJbnZhbGlkIHBhZ2UgcmVxdWVzdC5cIikpO1xuICAgIH1cbiAgICBjb25zdCBwYWdlSW5kZXggPSBwYWdlTnVtYmVyIC0gMSxcbiAgICAgIGNhY2hlZFByb21pc2UgPSB0aGlzLiNwYWdlUHJvbWlzZXMuZ2V0KHBhZ2VJbmRleCk7XG4gICAgaWYgKGNhY2hlZFByb21pc2UpIHtcbiAgICAgIHJldHVybiBjYWNoZWRQcm9taXNlO1xuICAgIH1cbiAgICBjb25zdCBwcm9taXNlID0gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJHZXRQYWdlXCIsIHtcbiAgICAgIHBhZ2VJbmRleFxuICAgIH0pLnRoZW4ocGFnZUluZm8gPT4ge1xuICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRyYW5zcG9ydCBkZXN0cm95ZWRcIik7XG4gICAgICB9XG4gICAgICBjb25zdCBwYWdlID0gbmV3IFBERlBhZ2VQcm94eShwYWdlSW5kZXgsIHBhZ2VJbmZvLCB0aGlzLCB0aGlzLl9wYXJhbXMucGRmQnVnKTtcbiAgICAgIHRoaXMuI3BhZ2VDYWNoZS5zZXQocGFnZUluZGV4LCBwYWdlKTtcbiAgICAgIHJldHVybiBwYWdlO1xuICAgIH0pO1xuICAgIHRoaXMuI3BhZ2VQcm9taXNlcy5zZXQocGFnZUluZGV4LCBwcm9taXNlKTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfVxuICBnZXRQYWdlSW5kZXgocmVmKSB7XG4gICAgaWYgKHR5cGVvZiByZWYgIT09IFwib2JqZWN0XCIgfHwgcmVmID09PSBudWxsIHx8ICFOdW1iZXIuaXNJbnRlZ2VyKHJlZi5udW0pIHx8IHJlZi5udW0gPCAwIHx8ICFOdW1iZXIuaXNJbnRlZ2VyKHJlZi5nZW4pIHx8IHJlZi5nZW4gPCAwKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiSW52YWxpZCBwYWdlSW5kZXggcmVxdWVzdC5cIikpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJHZXRQYWdlSW5kZXhcIiwge1xuICAgICAgbnVtOiByZWYubnVtLFxuICAgICAgZ2VuOiByZWYuZ2VuXG4gICAgfSk7XG4gIH1cbiAgZ2V0QW5ub3RhdGlvbnMocGFnZUluZGV4LCBpbnRlbnQpIHtcbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJHZXRBbm5vdGF0aW9uc1wiLCB7XG4gICAgICBwYWdlSW5kZXgsXG4gICAgICBpbnRlbnRcbiAgICB9KTtcbiAgfVxuICBnZXRGaWVsZE9iamVjdHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2NhY2hlU2ltcGxlTWV0aG9kKFwiR2V0RmllbGRPYmplY3RzXCIpO1xuICB9XG4gIGhhc0pTQWN0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy4jY2FjaGVTaW1wbGVNZXRob2QoXCJIYXNKU0FjdGlvbnNcIik7XG4gIH1cbiAgZ2V0Q2FsY3VsYXRpb25PcmRlcklkcygpIHtcbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJHZXRDYWxjdWxhdGlvbk9yZGVySWRzXCIsIG51bGwpO1xuICB9XG4gIGdldERlc3RpbmF0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJHZXREZXN0aW5hdGlvbnNcIiwgbnVsbCk7XG4gIH1cbiAgZ2V0RGVzdGluYXRpb24oaWQpIHtcbiAgICBpZiAodHlwZW9mIGlkICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiSW52YWxpZCBkZXN0aW5hdGlvbiByZXF1ZXN0LlwiKSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShcIkdldERlc3RpbmF0aW9uXCIsIHtcbiAgICAgIGlkXG4gICAgfSk7XG4gIH1cbiAgZ2V0UGFnZUxhYmVscygpIHtcbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJHZXRQYWdlTGFiZWxzXCIsIG51bGwpO1xuICB9XG4gIGdldFBhZ2VMYXlvdXQoKSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0UGFnZUxheW91dFwiLCBudWxsKTtcbiAgfVxuICBnZXRQYWdlTW9kZSgpIHtcbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJHZXRQYWdlTW9kZVwiLCBudWxsKTtcbiAgfVxuICBnZXRWaWV3ZXJQcmVmZXJlbmNlcygpIHtcbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJHZXRWaWV3ZXJQcmVmZXJlbmNlc1wiLCBudWxsKTtcbiAgfVxuICBnZXRPcGVuQWN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShcIkdldE9wZW5BY3Rpb25cIiwgbnVsbCk7XG4gIH1cbiAgZ2V0QXR0YWNobWVudHMoKSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0QXR0YWNobWVudHNcIiwgbnVsbCk7XG4gIH1cbiAgZ2V0RG9jSlNBY3Rpb25zKCkge1xuICAgIHJldHVybiB0aGlzLiNjYWNoZVNpbXBsZU1ldGhvZChcIkdldERvY0pTQWN0aW9uc1wiKTtcbiAgfVxuICBnZXRQYWdlSlNBY3Rpb25zKHBhZ2VJbmRleCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShcIkdldFBhZ2VKU0FjdGlvbnNcIiwge1xuICAgICAgcGFnZUluZGV4XG4gICAgfSk7XG4gIH1cbiAgZ2V0U3RydWN0VHJlZShwYWdlSW5kZXgpIHtcbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJHZXRTdHJ1Y3RUcmVlXCIsIHtcbiAgICAgIHBhZ2VJbmRleFxuICAgIH0pO1xuICB9XG4gIGdldE91dGxpbmUoKSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0T3V0bGluZVwiLCBudWxsKTtcbiAgfVxuICBnZXRPcHRpb25hbENvbnRlbnRDb25maWcoKSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0T3B0aW9uYWxDb250ZW50Q29uZmlnXCIsIG51bGwpLnRoZW4ocmVzdWx0cyA9PiB7XG4gICAgICByZXR1cm4gbmV3IF9vcHRpb25hbF9jb250ZW50X2NvbmZpZy5PcHRpb25hbENvbnRlbnRDb25maWcocmVzdWx0cyk7XG4gICAgfSk7XG4gIH1cbiAgZ2V0UGVybWlzc2lvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0UGVybWlzc2lvbnNcIiwgbnVsbCk7XG4gIH1cbiAgZ2V0TWV0YWRhdGEoKSB7XG4gICAgY29uc3QgbmFtZSA9IFwiR2V0TWV0YWRhdGFcIixcbiAgICAgIGNhY2hlZFByb21pc2UgPSB0aGlzLiNtZXRob2RQcm9taXNlcy5nZXQobmFtZSk7XG4gICAgaWYgKGNhY2hlZFByb21pc2UpIHtcbiAgICAgIHJldHVybiBjYWNoZWRQcm9taXNlO1xuICAgIH1cbiAgICBjb25zdCBwcm9taXNlID0gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UobmFtZSwgbnVsbCkudGhlbihyZXN1bHRzID0+IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGluZm86IHJlc3VsdHNbMF0sXG4gICAgICAgIG1ldGFkYXRhOiByZXN1bHRzWzFdID8gbmV3IF9tZXRhZGF0YS5NZXRhZGF0YShyZXN1bHRzWzFdKSA6IG51bGwsXG4gICAgICAgIGNvbnRlbnREaXNwb3NpdGlvbkZpbGVuYW1lOiB0aGlzLl9mdWxsUmVhZGVyPy5maWxlbmFtZSA/PyBudWxsLFxuICAgICAgICBjb250ZW50TGVuZ3RoOiB0aGlzLl9mdWxsUmVhZGVyPy5jb250ZW50TGVuZ3RoID8/IG51bGxcbiAgICAgIH07XG4gICAgfSk7XG4gICAgdGhpcy4jbWV0aG9kUHJvbWlzZXMuc2V0KG5hbWUsIHByb21pc2UpO1xuICAgIHJldHVybiBwcm9taXNlO1xuICB9XG4gIGdldE1hcmtJbmZvKCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShcIkdldE1hcmtJbmZvXCIsIG51bGwpO1xuICB9XG4gIGFzeW5jIHN0YXJ0Q2xlYW51cChrZWVwTG9hZGVkRm9udHMgPSBmYWxzZSkge1xuICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBhd2FpdCB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShcIkNsZWFudXBcIiwgbnVsbCk7XG4gICAgZm9yIChjb25zdCBwYWdlIG9mIHRoaXMuI3BhZ2VDYWNoZS52YWx1ZXMoKSkge1xuICAgICAgY29uc3QgY2xlYW51cFN1Y2Nlc3NmdWwgPSBwYWdlLmNsZWFudXAoKTtcbiAgICAgIGlmICghY2xlYW51cFN1Y2Nlc3NmdWwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBzdGFydENsZWFudXA6IFBhZ2UgJHtwYWdlLnBhZ2VOdW1iZXJ9IGlzIGN1cnJlbnRseSByZW5kZXJpbmcuYCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuY29tbW9uT2Jqcy5jbGVhcigpO1xuICAgIGlmICgha2VlcExvYWRlZEZvbnRzKSB7XG4gICAgICB0aGlzLmZvbnRMb2FkZXIuY2xlYXIoKTtcbiAgICB9XG4gICAgdGhpcy4jbWV0aG9kUHJvbWlzZXMuY2xlYXIoKTtcbiAgICB0aGlzLmZpbHRlckZhY3RvcnkuZGVzdHJveSh0cnVlKTtcbiAgfVxuICBnZXQgbG9hZGluZ1BhcmFtcygpIHtcbiAgICBjb25zdCB7XG4gICAgICBkaXNhYmxlQXV0b0ZldGNoLFxuICAgICAgZW5hYmxlWGZhXG4gICAgfSA9IHRoaXMuX3BhcmFtcztcbiAgICByZXR1cm4gKDAsIF91dGlsLnNoYWRvdykodGhpcywgXCJsb2FkaW5nUGFyYW1zXCIsIHtcbiAgICAgIGRpc2FibGVBdXRvRmV0Y2gsXG4gICAgICBlbmFibGVYZmFcbiAgICB9KTtcbiAgfVxufVxuY2xhc3MgUERGT2JqZWN0cyB7XG4gICNvYmpzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgI2Vuc3VyZU9iaihvYmpJZCkge1xuICAgIHJldHVybiB0aGlzLiNvYmpzW29iaklkXSB8fD0ge1xuICAgICAgY2FwYWJpbGl0eTogbmV3IF91dGlsLlByb21pc2VDYXBhYmlsaXR5KCksXG4gICAgICBkYXRhOiBudWxsXG4gICAgfTtcbiAgfVxuICBnZXQob2JqSWQsIGNhbGxiYWNrID0gbnVsbCkge1xuICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgY29uc3Qgb2JqID0gdGhpcy4jZW5zdXJlT2JqKG9iaklkKTtcbiAgICAgIG9iai5jYXBhYmlsaXR5LnByb21pc2UudGhlbigoKSA9PiBjYWxsYmFjayhvYmouZGF0YSkpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IG9iaiA9IHRoaXMuI29ianNbb2JqSWRdO1xuICAgIGlmICghb2JqPy5jYXBhYmlsaXR5LnNldHRsZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgUmVxdWVzdGluZyBvYmplY3QgdGhhdCBpc24ndCByZXNvbHZlZCB5ZXQgJHtvYmpJZH0uYCk7XG4gICAgfVxuICAgIHJldHVybiBvYmouZGF0YTtcbiAgfVxuICBoYXMob2JqSWQpIHtcbiAgICBjb25zdCBvYmogPSB0aGlzLiNvYmpzW29iaklkXTtcbiAgICByZXR1cm4gb2JqPy5jYXBhYmlsaXR5LnNldHRsZWQgfHwgZmFsc2U7XG4gIH1cbiAgcmVzb2x2ZShvYmpJZCwgZGF0YSA9IG51bGwpIHtcbiAgICBjb25zdCBvYmogPSB0aGlzLiNlbnN1cmVPYmoob2JqSWQpO1xuICAgIG9iai5kYXRhID0gZGF0YTtcbiAgICBvYmouY2FwYWJpbGl0eS5yZXNvbHZlKCk7XG4gIH1cbiAgY2xlYXIoKSB7XG4gICAgZm9yIChjb25zdCBvYmpJZCBpbiB0aGlzLiNvYmpzKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGRhdGFcbiAgICAgIH0gPSB0aGlzLiNvYmpzW29iaklkXTtcbiAgICAgIGRhdGE/LmJpdG1hcD8uY2xvc2UoKTtcbiAgICB9XG4gICAgdGhpcy4jb2JqcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIH1cbn1cbmNsYXNzIFJlbmRlclRhc2sge1xuICAjaW50ZXJuYWxSZW5kZXJUYXNrID0gbnVsbDtcbiAgY29uc3RydWN0b3IoaW50ZXJuYWxSZW5kZXJUYXNrKSB7XG4gICAgdGhpcy4jaW50ZXJuYWxSZW5kZXJUYXNrID0gaW50ZXJuYWxSZW5kZXJUYXNrO1xuICAgIHRoaXMub25Db250aW51ZSA9IG51bGw7XG4gIH1cbiAgZ2V0IHByb21pc2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2ludGVybmFsUmVuZGVyVGFzay5jYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbiAgY2FuY2VsKGV4dHJhRGVsYXkgPSAwKSB7XG4gICAgdGhpcy4jaW50ZXJuYWxSZW5kZXJUYXNrLmNhbmNlbChudWxsLCBleHRyYURlbGF5KTtcbiAgfVxuICBnZXQgc2VwYXJhdGVBbm5vdHMoKSB7XG4gICAgY29uc3Qge1xuICAgICAgc2VwYXJhdGVBbm5vdHNcbiAgICB9ID0gdGhpcy4jaW50ZXJuYWxSZW5kZXJUYXNrLm9wZXJhdG9yTGlzdDtcbiAgICBpZiAoIXNlcGFyYXRlQW5ub3RzKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGFubm90YXRpb25DYW52YXNNYXBcbiAgICB9ID0gdGhpcy4jaW50ZXJuYWxSZW5kZXJUYXNrO1xuICAgIHJldHVybiBzZXBhcmF0ZUFubm90cy5mb3JtIHx8IHNlcGFyYXRlQW5ub3RzLmNhbnZhcyAmJiBhbm5vdGF0aW9uQ2FudmFzTWFwPy5zaXplID4gMDtcbiAgfVxufVxuZXhwb3J0cy5SZW5kZXJUYXNrID0gUmVuZGVyVGFzaztcbmNsYXNzIEludGVybmFsUmVuZGVyVGFzayB7XG4gIHN0YXRpYyAjY2FudmFzSW5Vc2UgPSBuZXcgV2Vha1NldCgpO1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgY2FsbGJhY2ssXG4gICAgcGFyYW1zLFxuICAgIG9ianMsXG4gICAgY29tbW9uT2JqcyxcbiAgICBhbm5vdGF0aW9uQ2FudmFzTWFwLFxuICAgIG9wZXJhdG9yTGlzdCxcbiAgICBwYWdlSW5kZXgsXG4gICAgY2FudmFzRmFjdG9yeSxcbiAgICBmaWx0ZXJGYWN0b3J5LFxuICAgIHVzZVJlcXVlc3RBbmltYXRpb25GcmFtZSA9IGZhbHNlLFxuICAgIHBkZkJ1ZyA9IGZhbHNlLFxuICAgIHBhZ2VDb2xvcnMgPSBudWxsXG4gIH0pIHtcbiAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgdGhpcy5wYXJhbXMgPSBwYXJhbXM7XG4gICAgdGhpcy5vYmpzID0gb2JqcztcbiAgICB0aGlzLmNvbW1vbk9ianMgPSBjb21tb25PYmpzO1xuICAgIHRoaXMuYW5ub3RhdGlvbkNhbnZhc01hcCA9IGFubm90YXRpb25DYW52YXNNYXA7XG4gICAgdGhpcy5vcGVyYXRvckxpc3RJZHggPSBudWxsO1xuICAgIHRoaXMub3BlcmF0b3JMaXN0ID0gb3BlcmF0b3JMaXN0O1xuICAgIHRoaXMuX3BhZ2VJbmRleCA9IHBhZ2VJbmRleDtcbiAgICB0aGlzLmNhbnZhc0ZhY3RvcnkgPSBjYW52YXNGYWN0b3J5O1xuICAgIHRoaXMuZmlsdGVyRmFjdG9yeSA9IGZpbHRlckZhY3Rvcnk7XG4gICAgdGhpcy5fcGRmQnVnID0gcGRmQnVnO1xuICAgIHRoaXMucGFnZUNvbG9ycyA9IHBhZ2VDb2xvcnM7XG4gICAgdGhpcy5ydW5uaW5nID0gZmFsc2U7XG4gICAgdGhpcy5ncmFwaGljc1JlYWR5Q2FsbGJhY2sgPSBudWxsO1xuICAgIHRoaXMuZ3JhcGhpY3NSZWFkeSA9IGZhbHNlO1xuICAgIHRoaXMuX3VzZVJlcXVlc3RBbmltYXRpb25GcmFtZSA9IHVzZVJlcXVlc3RBbmltYXRpb25GcmFtZSA9PT0gdHJ1ZSAmJiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiO1xuICAgIHRoaXMuY2FuY2VsbGVkID0gZmFsc2U7XG4gICAgdGhpcy5jYXBhYmlsaXR5ID0gbmV3IF91dGlsLlByb21pc2VDYXBhYmlsaXR5KCk7XG4gICAgdGhpcy50YXNrID0gbmV3IFJlbmRlclRhc2sodGhpcyk7XG4gICAgdGhpcy5fY2FuY2VsQm91bmQgPSB0aGlzLmNhbmNlbC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX2NvbnRpbnVlQm91bmQgPSB0aGlzLl9jb250aW51ZS5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX3NjaGVkdWxlTmV4dEJvdW5kID0gdGhpcy5fc2NoZWR1bGVOZXh0LmJpbmQodGhpcyk7XG4gICAgdGhpcy5fbmV4dEJvdW5kID0gdGhpcy5fbmV4dC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX2NhbnZhcyA9IHBhcmFtcy5jYW52YXNDb250ZXh0LmNhbnZhcztcbiAgfVxuICBnZXQgY29tcGxldGVkKCkge1xuICAgIHJldHVybiB0aGlzLmNhcGFiaWxpdHkucHJvbWlzZS5jYXRjaChmdW5jdGlvbiAoKSB7fSk7XG4gIH1cbiAgaW5pdGlhbGl6ZUdyYXBoaWNzKHtcbiAgICB0cmFuc3BhcmVuY3kgPSBmYWxzZSxcbiAgICBvcHRpb25hbENvbnRlbnRDb25maWdcbiAgfSkge1xuICAgIGlmICh0aGlzLmNhbmNlbGxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5fY2FudmFzKSB7XG4gICAgICBpZiAoSW50ZXJuYWxSZW5kZXJUYXNrLiNjYW52YXNJblVzZS5oYXModGhpcy5fY2FudmFzKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgdXNlIHRoZSBzYW1lIGNhbnZhcyBkdXJpbmcgbXVsdGlwbGUgcmVuZGVyKCkgb3BlcmF0aW9ucy4gXCIgKyBcIlVzZSBkaWZmZXJlbnQgY2FudmFzIG9yIGVuc3VyZSBwcmV2aW91cyBvcGVyYXRpb25zIHdlcmUgXCIgKyBcImNhbmNlbGxlZCBvciBjb21wbGV0ZWQuXCIpO1xuICAgICAgfVxuICAgICAgSW50ZXJuYWxSZW5kZXJUYXNrLiNjYW52YXNJblVzZS5hZGQodGhpcy5fY2FudmFzKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3BkZkJ1ZyAmJiBnbG9iYWxUaGlzLlN0ZXBwZXJNYW5hZ2VyPy5lbmFibGVkKSB7XG4gICAgICB0aGlzLnN0ZXBwZXIgPSBnbG9iYWxUaGlzLlN0ZXBwZXJNYW5hZ2VyLmNyZWF0ZSh0aGlzLl9wYWdlSW5kZXgpO1xuICAgICAgdGhpcy5zdGVwcGVyLmluaXQodGhpcy5vcGVyYXRvckxpc3QpO1xuICAgICAgdGhpcy5zdGVwcGVyLm5leHRCcmVha1BvaW50ID0gdGhpcy5zdGVwcGVyLmdldE5leHRCcmVha1BvaW50KCk7XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGNhbnZhc0NvbnRleHQsXG4gICAgICB2aWV3cG9ydCxcbiAgICAgIHRyYW5zZm9ybSxcbiAgICAgIGJhY2tncm91bmRcbiAgICB9ID0gdGhpcy5wYXJhbXM7XG4gICAgdGhpcy5nZnggPSBuZXcgX2NhbnZhcy5DYW52YXNHcmFwaGljcyhjYW52YXNDb250ZXh0LCB0aGlzLmNvbW1vbk9ianMsIHRoaXMub2JqcywgdGhpcy5jYW52YXNGYWN0b3J5LCB0aGlzLmZpbHRlckZhY3RvcnksIHtcbiAgICAgIG9wdGlvbmFsQ29udGVudENvbmZpZ1xuICAgIH0sIHRoaXMuYW5ub3RhdGlvbkNhbnZhc01hcCwgdGhpcy5wYWdlQ29sb3JzKTtcbiAgICB0aGlzLmdmeC5iZWdpbkRyYXdpbmcoe1xuICAgICAgdHJhbnNmb3JtLFxuICAgICAgdmlld3BvcnQsXG4gICAgICB0cmFuc3BhcmVuY3ksXG4gICAgICBiYWNrZ3JvdW5kXG4gICAgfSk7XG4gICAgdGhpcy5vcGVyYXRvckxpc3RJZHggPSAwO1xuICAgIHRoaXMuZ3JhcGhpY3NSZWFkeSA9IHRydWU7XG4gICAgdGhpcy5ncmFwaGljc1JlYWR5Q2FsbGJhY2s/LigpO1xuICB9XG4gIGNhbmNlbChlcnJvciA9IG51bGwsIGV4dHJhRGVsYXkgPSAwKSB7XG4gICAgdGhpcy5ydW5uaW5nID0gZmFsc2U7XG4gICAgdGhpcy5jYW5jZWxsZWQgPSB0cnVlO1xuICAgIHRoaXMuZ2Z4Py5lbmREcmF3aW5nKCk7XG4gICAgSW50ZXJuYWxSZW5kZXJUYXNrLiNjYW52YXNJblVzZS5kZWxldGUodGhpcy5fY2FudmFzKTtcbiAgICB0aGlzLmNhbGxiYWNrKGVycm9yIHx8IG5ldyBfZGlzcGxheV91dGlscy5SZW5kZXJpbmdDYW5jZWxsZWRFeGNlcHRpb24oYFJlbmRlcmluZyBjYW5jZWxsZWQsIHBhZ2UgJHt0aGlzLl9wYWdlSW5kZXggKyAxfWAsIGV4dHJhRGVsYXkpKTtcbiAgfVxuICBvcGVyYXRvckxpc3RDaGFuZ2VkKCkge1xuICAgIGlmICghdGhpcy5ncmFwaGljc1JlYWR5KSB7XG4gICAgICB0aGlzLmdyYXBoaWNzUmVhZHlDYWxsYmFjayB8fD0gdGhpcy5fY29udGludWVCb3VuZDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5zdGVwcGVyPy51cGRhdGVPcGVyYXRvckxpc3QodGhpcy5vcGVyYXRvckxpc3QpO1xuICAgIGlmICh0aGlzLnJ1bm5pbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fY29udGludWUoKTtcbiAgfVxuICBfY29udGludWUoKSB7XG4gICAgdGhpcy5ydW5uaW5nID0gdHJ1ZTtcbiAgICBpZiAodGhpcy5jYW5jZWxsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMudGFzay5vbkNvbnRpbnVlKSB7XG4gICAgICB0aGlzLnRhc2sub25Db250aW51ZSh0aGlzLl9zY2hlZHVsZU5leHRCb3VuZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3NjaGVkdWxlTmV4dCgpO1xuICAgIH1cbiAgfVxuICBfc2NoZWR1bGVOZXh0KCkge1xuICAgIGlmICh0aGlzLl91c2VSZXF1ZXN0QW5pbWF0aW9uRnJhbWUpIHtcbiAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICB0aGlzLl9uZXh0Qm91bmQoKS5jYXRjaCh0aGlzLl9jYW5jZWxCb3VuZCk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbih0aGlzLl9uZXh0Qm91bmQpLmNhdGNoKHRoaXMuX2NhbmNlbEJvdW5kKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgX25leHQoKSB7XG4gICAgaWYgKHRoaXMuY2FuY2VsbGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMub3BlcmF0b3JMaXN0SWR4ID0gdGhpcy5nZnguZXhlY3V0ZU9wZXJhdG9yTGlzdCh0aGlzLm9wZXJhdG9yTGlzdCwgdGhpcy5vcGVyYXRvckxpc3RJZHgsIHRoaXMuX2NvbnRpbnVlQm91bmQsIHRoaXMuc3RlcHBlcik7XG4gICAgaWYgKHRoaXMub3BlcmF0b3JMaXN0SWR4ID09PSB0aGlzLm9wZXJhdG9yTGlzdC5hcmdzQXJyYXkubGVuZ3RoKSB7XG4gICAgICB0aGlzLnJ1bm5pbmcgPSBmYWxzZTtcbiAgICAgIGlmICh0aGlzLm9wZXJhdG9yTGlzdC5sYXN0Q2h1bmspIHtcbiAgICAgICAgdGhpcy5nZnguZW5kRHJhd2luZygpO1xuICAgICAgICBJbnRlcm5hbFJlbmRlclRhc2suI2NhbnZhc0luVXNlLmRlbGV0ZSh0aGlzLl9jYW52YXMpO1xuICAgICAgICB0aGlzLmNhbGxiYWNrKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5jb25zdCB2ZXJzaW9uID0gJzMuMTEuMTc0JztcbmV4cG9ydHMudmVyc2lvbiA9IHZlcnNpb247XG5jb25zdCBidWlsZCA9ICdjZTg3MTY3NDMnO1xuZXhwb3J0cy5idWlsZCA9IGJ1aWxkO1xuXG4vKioqLyB9KSxcbi8qIDMgKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pID0+IHtcblxuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcbmV4cG9ydHMuU2VyaWFsaXphYmxlRW1wdHkgPSBleHBvcnRzLlByaW50QW5ub3RhdGlvblN0b3JhZ2UgPSBleHBvcnRzLkFubm90YXRpb25TdG9yYWdlID0gdm9pZCAwO1xudmFyIF91dGlsID0gX193X3BkZmpzX3JlcXVpcmVfXygxKTtcbnZhciBfZWRpdG9yID0gX193X3BkZmpzX3JlcXVpcmVfXyg0KTtcbnZhciBfbXVybXVyaGFzaCA9IF9fd19wZGZqc19yZXF1aXJlX18oOCk7XG5jb25zdCBTZXJpYWxpemFibGVFbXB0eSA9IE9iamVjdC5mcmVlemUoe1xuICBtYXA6IG51bGwsXG4gIGhhc2g6IFwiXCIsXG4gIHRyYW5zZmVyczogdW5kZWZpbmVkXG59KTtcbmV4cG9ydHMuU2VyaWFsaXphYmxlRW1wdHkgPSBTZXJpYWxpemFibGVFbXB0eTtcbmNsYXNzIEFubm90YXRpb25TdG9yYWdlIHtcbiAgI21vZGlmaWVkID0gZmFsc2U7XG4gICNzdG9yYWdlID0gbmV3IE1hcCgpO1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLm9uU2V0TW9kaWZpZWQgPSBudWxsO1xuICAgIHRoaXMub25SZXNldE1vZGlmaWVkID0gbnVsbDtcbiAgICB0aGlzLm9uQW5ub3RhdGlvbkVkaXRvciA9IG51bGw7XG4gIH1cbiAgZ2V0VmFsdWUoa2V5LCBkZWZhdWx0VmFsdWUpIHtcbiAgICBjb25zdCB2YWx1ZSA9IHRoaXMuI3N0b3JhZ2UuZ2V0KGtleSk7XG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBkZWZhdWx0VmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBPYmplY3QuYXNzaWduKGRlZmF1bHRWYWx1ZSwgdmFsdWUpO1xuICB9XG4gIGdldFJhd1ZhbHVlKGtleSkge1xuICAgIHJldHVybiB0aGlzLiNzdG9yYWdlLmdldChrZXkpO1xuICB9XG4gIHJlbW92ZShrZXkpIHtcbiAgICB0aGlzLiNzdG9yYWdlLmRlbGV0ZShrZXkpO1xuICAgIGlmICh0aGlzLiNzdG9yYWdlLnNpemUgPT09IDApIHtcbiAgICAgIHRoaXMucmVzZXRNb2RpZmllZCgpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHRoaXMub25Bbm5vdGF0aW9uRWRpdG9yID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGZvciAoY29uc3QgdmFsdWUgb2YgdGhpcy4jc3RvcmFnZS52YWx1ZXMoKSkge1xuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBfZWRpdG9yLkFubm90YXRpb25FZGl0b3IpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMub25Bbm5vdGF0aW9uRWRpdG9yKG51bGwpO1xuICAgIH1cbiAgfVxuICBzZXRWYWx1ZShrZXksIHZhbHVlKSB7XG4gICAgY29uc3Qgb2JqID0gdGhpcy4jc3RvcmFnZS5nZXQoa2V5KTtcbiAgICBsZXQgbW9kaWZpZWQgPSBmYWxzZTtcbiAgICBpZiAob2JqICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGZvciAoY29uc3QgW2VudHJ5LCB2YWxdIG9mIE9iamVjdC5lbnRyaWVzKHZhbHVlKSkge1xuICAgICAgICBpZiAob2JqW2VudHJ5XSAhPT0gdmFsKSB7XG4gICAgICAgICAgbW9kaWZpZWQgPSB0cnVlO1xuICAgICAgICAgIG9ialtlbnRyeV0gPSB2YWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbW9kaWZpZWQgPSB0cnVlO1xuICAgICAgdGhpcy4jc3RvcmFnZS5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgfVxuICAgIGlmIChtb2RpZmllZCkge1xuICAgICAgdGhpcy4jc2V0TW9kaWZpZWQoKTtcbiAgICB9XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgX2VkaXRvci5Bbm5vdGF0aW9uRWRpdG9yICYmIHR5cGVvZiB0aGlzLm9uQW5ub3RhdGlvbkVkaXRvciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICB0aGlzLm9uQW5ub3RhdGlvbkVkaXRvcih2YWx1ZS5jb25zdHJ1Y3Rvci5fdHlwZSk7XG4gICAgfVxuICB9XG4gIGhhcyhrZXkpIHtcbiAgICByZXR1cm4gdGhpcy4jc3RvcmFnZS5oYXMoa2V5KTtcbiAgfVxuICBnZXRBbGwoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3N0b3JhZ2Uuc2l6ZSA+IDAgPyAoMCwgX3V0aWwub2JqZWN0RnJvbU1hcCkodGhpcy4jc3RvcmFnZSkgOiBudWxsO1xuICB9XG4gIHNldEFsbChvYmopIHtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbF0gb2YgT2JqZWN0LmVudHJpZXMob2JqKSkge1xuICAgICAgdGhpcy5zZXRWYWx1ZShrZXksIHZhbCk7XG4gICAgfVxuICB9XG4gIGdldCBzaXplKCkge1xuICAgIHJldHVybiB0aGlzLiNzdG9yYWdlLnNpemU7XG4gIH1cbiAgI3NldE1vZGlmaWVkKCkge1xuICAgIGlmICghdGhpcy4jbW9kaWZpZWQpIHtcbiAgICAgIHRoaXMuI21vZGlmaWVkID0gdHJ1ZTtcbiAgICAgIGlmICh0eXBlb2YgdGhpcy5vblNldE1vZGlmaWVkID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhpcy5vblNldE1vZGlmaWVkKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJlc2V0TW9kaWZpZWQoKSB7XG4gICAgaWYgKHRoaXMuI21vZGlmaWVkKSB7XG4gICAgICB0aGlzLiNtb2RpZmllZCA9IGZhbHNlO1xuICAgICAgaWYgKHR5cGVvZiB0aGlzLm9uUmVzZXRNb2RpZmllZCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRoaXMub25SZXNldE1vZGlmaWVkKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGdldCBwcmludCgpIHtcbiAgICByZXR1cm4gbmV3IFByaW50QW5ub3RhdGlvblN0b3JhZ2UodGhpcyk7XG4gIH1cbiAgZ2V0IHNlcmlhbGl6YWJsZSgpIHtcbiAgICBpZiAodGhpcy4jc3RvcmFnZS5zaXplID09PSAwKSB7XG4gICAgICByZXR1cm4gU2VyaWFsaXphYmxlRW1wdHk7XG4gICAgfVxuICAgIGNvbnN0IG1hcCA9IG5ldyBNYXAoKSxcbiAgICAgIGhhc2ggPSBuZXcgX211cm11cmhhc2guTXVybXVySGFzaDNfNjQoKSxcbiAgICAgIHRyYW5zZmVycyA9IFtdO1xuICAgIGNvbnN0IGNvbnRleHQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGxldCBoYXNCaXRtYXAgPSBmYWxzZTtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbF0gb2YgdGhpcy4jc3RvcmFnZSkge1xuICAgICAgY29uc3Qgc2VyaWFsaXplZCA9IHZhbCBpbnN0YW5jZW9mIF9lZGl0b3IuQW5ub3RhdGlvbkVkaXRvciA/IHZhbC5zZXJpYWxpemUoZmFsc2UsIGNvbnRleHQpIDogdmFsO1xuICAgICAgaWYgKHNlcmlhbGl6ZWQpIHtcbiAgICAgICAgbWFwLnNldChrZXksIHNlcmlhbGl6ZWQpO1xuICAgICAgICBoYXNoLnVwZGF0ZShgJHtrZXl9OiR7SlNPTi5zdHJpbmdpZnkoc2VyaWFsaXplZCl9YCk7XG4gICAgICAgIGhhc0JpdG1hcCB8fD0gISFzZXJpYWxpemVkLmJpdG1hcDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGhhc0JpdG1hcCkge1xuICAgICAgZm9yIChjb25zdCB2YWx1ZSBvZiBtYXAudmFsdWVzKCkpIHtcbiAgICAgICAgaWYgKHZhbHVlLmJpdG1hcCkge1xuICAgICAgICAgIHRyYW5zZmVycy5wdXNoKHZhbHVlLmJpdG1hcCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1hcC5zaXplID4gMCA/IHtcbiAgICAgIG1hcCxcbiAgICAgIGhhc2g6IGhhc2guaGV4ZGlnZXN0KCksXG4gICAgICB0cmFuc2ZlcnNcbiAgICB9IDogU2VyaWFsaXphYmxlRW1wdHk7XG4gIH1cbn1cbmV4cG9ydHMuQW5ub3RhdGlvblN0b3JhZ2UgPSBBbm5vdGF0aW9uU3RvcmFnZTtcbmNsYXNzIFByaW50QW5ub3RhdGlvblN0b3JhZ2UgZXh0ZW5kcyBBbm5vdGF0aW9uU3RvcmFnZSB7XG4gICNzZXJpYWxpemFibGU7XG4gIGNvbnN0cnVjdG9yKHBhcmVudCkge1xuICAgIHN1cGVyKCk7XG4gICAgY29uc3Qge1xuICAgICAgbWFwLFxuICAgICAgaGFzaCxcbiAgICAgIHRyYW5zZmVyc1xuICAgIH0gPSBwYXJlbnQuc2VyaWFsaXphYmxlO1xuICAgIGNvbnN0IGNsb25lID0gc3RydWN0dXJlZENsb25lKG1hcCwgdHJhbnNmZXJzID8ge1xuICAgICAgdHJhbnNmZXI6IHRyYW5zZmVyc1xuICAgIH0gOiBudWxsKTtcbiAgICB0aGlzLiNzZXJpYWxpemFibGUgPSB7XG4gICAgICBtYXA6IGNsb25lLFxuICAgICAgaGFzaCxcbiAgICAgIHRyYW5zZmVyc1xuICAgIH07XG4gIH1cbiAgZ2V0IHByaW50KCkge1xuICAgICgwLCBfdXRpbC51bnJlYWNoYWJsZSkoXCJTaG91bGQgbm90IGNhbGwgUHJpbnRBbm5vdGF0aW9uU3RvcmFnZS5wcmludFwiKTtcbiAgfVxuICBnZXQgc2VyaWFsaXphYmxlKCkge1xuICAgIHJldHVybiB0aGlzLiNzZXJpYWxpemFibGU7XG4gIH1cbn1cbmV4cG9ydHMuUHJpbnRBbm5vdGF0aW9uU3RvcmFnZSA9IFByaW50QW5ub3RhdGlvblN0b3JhZ2U7XG5cbi8qKiovIH0pLFxuLyogNCAqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykgPT4ge1xuXG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xuZXhwb3J0cy5Bbm5vdGF0aW9uRWRpdG9yID0gdm9pZCAwO1xudmFyIF90b29scyA9IF9fd19wZGZqc19yZXF1aXJlX18oNSk7XG52YXIgX3V0aWwgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEpO1xudmFyIF9kaXNwbGF5X3V0aWxzID0gX193X3BkZmpzX3JlcXVpcmVfXyg2KTtcbmNsYXNzIEFubm90YXRpb25FZGl0b3Ige1xuICAjYWx0VGV4dCA9IFwiXCI7XG4gICNhbHRUZXh0RGVjb3JhdGl2ZSA9IGZhbHNlO1xuICAjYWx0VGV4dEJ1dHRvbiA9IG51bGw7XG4gICNhbHRUZXh0VG9vbHRpcCA9IG51bGw7XG4gICNhbHRUZXh0VG9vbHRpcFRpbWVvdXQgPSBudWxsO1xuICAja2VlcEFzcGVjdFJhdGlvID0gZmFsc2U7XG4gICNyZXNpemVyc0RpdiA9IG51bGw7XG4gICNib3VuZEZvY3VzaW4gPSB0aGlzLmZvY3VzaW4uYmluZCh0aGlzKTtcbiAgI2JvdW5kRm9jdXNvdXQgPSB0aGlzLmZvY3Vzb3V0LmJpbmQodGhpcyk7XG4gICNoYXNCZWVuQ2xpY2tlZCA9IGZhbHNlO1xuICAjaXNFZGl0aW5nID0gZmFsc2U7XG4gICNpc0luRWRpdE1vZGUgPSBmYWxzZTtcbiAgX2luaXRpYWxPcHRpb25zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgX3VpTWFuYWdlciA9IG51bGw7XG4gIF9mb2N1c0V2ZW50c0FsbG93ZWQgPSB0cnVlO1xuICBfbDEwblByb21pc2UgPSBudWxsO1xuICAjaXNEcmFnZ2FibGUgPSBmYWxzZTtcbiAgI3pJbmRleCA9IEFubm90YXRpb25FZGl0b3IuX3pJbmRleCsrO1xuICBzdGF0aWMgX2JvcmRlckxpbmVXaWR0aCA9IC0xO1xuICBzdGF0aWMgX2NvbG9yTWFuYWdlciA9IG5ldyBfdG9vbHMuQ29sb3JNYW5hZ2VyKCk7XG4gIHN0YXRpYyBfekluZGV4ID0gMTtcbiAgc3RhdGljIFNNQUxMX0VESVRPUl9TSVpFID0gMDtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVycykge1xuICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yID09PSBBbm5vdGF0aW9uRWRpdG9yKSB7XG4gICAgICAoMCwgX3V0aWwudW5yZWFjaGFibGUpKFwiQ2Fubm90IGluaXRpYWxpemUgQW5ub3RhdGlvbkVkaXRvci5cIik7XG4gICAgfVxuICAgIHRoaXMucGFyZW50ID0gcGFyYW1ldGVycy5wYXJlbnQ7XG4gICAgdGhpcy5pZCA9IHBhcmFtZXRlcnMuaWQ7XG4gICAgdGhpcy53aWR0aCA9IHRoaXMuaGVpZ2h0ID0gbnVsbDtcbiAgICB0aGlzLnBhZ2VJbmRleCA9IHBhcmFtZXRlcnMucGFyZW50LnBhZ2VJbmRleDtcbiAgICB0aGlzLm5hbWUgPSBwYXJhbWV0ZXJzLm5hbWU7XG4gICAgdGhpcy5kaXYgPSBudWxsO1xuICAgIHRoaXMuX3VpTWFuYWdlciA9IHBhcmFtZXRlcnMudWlNYW5hZ2VyO1xuICAgIHRoaXMuYW5ub3RhdGlvbkVsZW1lbnRJZCA9IG51bGw7XG4gICAgdGhpcy5fd2lsbEtlZXBBc3BlY3RSYXRpbyA9IGZhbHNlO1xuICAgIHRoaXMuX2luaXRpYWxPcHRpb25zLmlzQ2VudGVyZWQgPSBwYXJhbWV0ZXJzLmlzQ2VudGVyZWQ7XG4gICAgdGhpcy5fc3RydWN0VHJlZVBhcmVudElkID0gbnVsbDtcbiAgICBjb25zdCB7XG4gICAgICByb3RhdGlvbixcbiAgICAgIHJhd0RpbXM6IHtcbiAgICAgICAgcGFnZVdpZHRoLFxuICAgICAgICBwYWdlSGVpZ2h0LFxuICAgICAgICBwYWdlWCxcbiAgICAgICAgcGFnZVlcbiAgICAgIH1cbiAgICB9ID0gdGhpcy5wYXJlbnQudmlld3BvcnQ7XG4gICAgdGhpcy5yb3RhdGlvbiA9IHJvdGF0aW9uO1xuICAgIHRoaXMucGFnZVJvdGF0aW9uID0gKDM2MCArIHJvdGF0aW9uIC0gdGhpcy5fdWlNYW5hZ2VyLnZpZXdQYXJhbWV0ZXJzLnJvdGF0aW9uKSAlIDM2MDtcbiAgICB0aGlzLnBhZ2VEaW1lbnNpb25zID0gW3BhZ2VXaWR0aCwgcGFnZUhlaWdodF07XG4gICAgdGhpcy5wYWdlVHJhbnNsYXRpb24gPSBbcGFnZVgsIHBhZ2VZXTtcbiAgICBjb25zdCBbd2lkdGgsIGhlaWdodF0gPSB0aGlzLnBhcmVudERpbWVuc2lvbnM7XG4gICAgdGhpcy54ID0gcGFyYW1ldGVycy54IC8gd2lkdGg7XG4gICAgdGhpcy55ID0gcGFyYW1ldGVycy55IC8gaGVpZ2h0O1xuICAgIHRoaXMuaXNBdHRhY2hlZFRvRE9NID0gZmFsc2U7XG4gICAgdGhpcy5kZWxldGVkID0gZmFsc2U7XG4gIH1cbiAgZ2V0IGVkaXRvclR5cGUoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3Rvci5fdHlwZTtcbiAgfVxuICBzdGF0aWMgZ2V0IF9kZWZhdWx0TGluZUNvbG9yKCkge1xuICAgIHJldHVybiAoMCwgX3V0aWwuc2hhZG93KSh0aGlzLCBcIl9kZWZhdWx0TGluZUNvbG9yXCIsIHRoaXMuX2NvbG9yTWFuYWdlci5nZXRIZXhDb2RlKFwiQ2FudmFzVGV4dFwiKSk7XG4gIH1cbiAgc3RhdGljIGRlbGV0ZUFubm90YXRpb25FbGVtZW50KGVkaXRvcikge1xuICAgIGNvbnN0IGZha2VFZGl0b3IgPSBuZXcgRmFrZUVkaXRvcih7XG4gICAgICBpZDogZWRpdG9yLnBhcmVudC5nZXROZXh0SWQoKSxcbiAgICAgIHBhcmVudDogZWRpdG9yLnBhcmVudCxcbiAgICAgIHVpTWFuYWdlcjogZWRpdG9yLl91aU1hbmFnZXJcbiAgICB9KTtcbiAgICBmYWtlRWRpdG9yLmFubm90YXRpb25FbGVtZW50SWQgPSBlZGl0b3IuYW5ub3RhdGlvbkVsZW1lbnRJZDtcbiAgICBmYWtlRWRpdG9yLmRlbGV0ZWQgPSB0cnVlO1xuICAgIGZha2VFZGl0b3IuX3VpTWFuYWdlci5hZGRUb0Fubm90YXRpb25TdG9yYWdlKGZha2VFZGl0b3IpO1xuICB9XG4gIHN0YXRpYyBpbml0aWFsaXplKGwxMG4sIG9wdGlvbnMgPSBudWxsKSB7XG4gICAgQW5ub3RhdGlvbkVkaXRvci5fbDEwblByb21pc2UgfHw9IG5ldyBNYXAoW1wiZWRpdG9yX2FsdF90ZXh0X2J1dHRvbl9sYWJlbFwiLCBcImVkaXRvcl9hbHRfdGV4dF9lZGl0X2J1dHRvbl9sYWJlbFwiLCBcImVkaXRvcl9hbHRfdGV4dF9kZWNvcmF0aXZlX3Rvb2x0aXBcIl0ubWFwKHN0ciA9PiBbc3RyLCBsMTBuLmdldChzdHIpXSkpO1xuICAgIGlmIChvcHRpb25zPy5zdHJpbmdzKSB7XG4gICAgICBmb3IgKGNvbnN0IHN0ciBvZiBvcHRpb25zLnN0cmluZ3MpIHtcbiAgICAgICAgQW5ub3RhdGlvbkVkaXRvci5fbDEwblByb21pc2Uuc2V0KHN0ciwgbDEwbi5nZXQoc3RyKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChBbm5vdGF0aW9uRWRpdG9yLl9ib3JkZXJMaW5lV2lkdGggIT09IC0xKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpO1xuICAgIEFubm90YXRpb25FZGl0b3IuX2JvcmRlckxpbmVXaWR0aCA9IHBhcnNlRmxvYXQoc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShcIi0tb3V0bGluZS13aWR0aFwiKSkgfHwgMDtcbiAgfVxuICBzdGF0aWMgdXBkYXRlRGVmYXVsdFBhcmFtcyhfdHlwZSwgX3ZhbHVlKSB7fVxuICBzdGF0aWMgZ2V0IGRlZmF1bHRQcm9wZXJ0aWVzVG9VcGRhdGUoKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIHN0YXRpYyBpc0hhbmRsaW5nTWltZUZvclBhc3RpbmcobWltZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBzdGF0aWMgcGFzdGUoaXRlbSwgcGFyZW50KSB7XG4gICAgKDAsIF91dGlsLnVucmVhY2hhYmxlKShcIk5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgfVxuICBnZXQgcHJvcGVydGllc1RvVXBkYXRlKCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBnZXQgX2lzRHJhZ2dhYmxlKCkge1xuICAgIHJldHVybiB0aGlzLiNpc0RyYWdnYWJsZTtcbiAgfVxuICBzZXQgX2lzRHJhZ2dhYmxlKHZhbHVlKSB7XG4gICAgdGhpcy4jaXNEcmFnZ2FibGUgPSB2YWx1ZTtcbiAgICB0aGlzLmRpdj8uY2xhc3NMaXN0LnRvZ2dsZShcImRyYWdnYWJsZVwiLCB2YWx1ZSk7XG4gIH1cbiAgY2VudGVyKCkge1xuICAgIGNvbnN0IFtwYWdlV2lkdGgsIHBhZ2VIZWlnaHRdID0gdGhpcy5wYWdlRGltZW5zaW9ucztcbiAgICBzd2l0Y2ggKHRoaXMucGFyZW50Um90YXRpb24pIHtcbiAgICAgIGNhc2UgOTA6XG4gICAgICAgIHRoaXMueCAtPSB0aGlzLmhlaWdodCAqIHBhZ2VIZWlnaHQgLyAocGFnZVdpZHRoICogMik7XG4gICAgICAgIHRoaXMueSArPSB0aGlzLndpZHRoICogcGFnZVdpZHRoIC8gKHBhZ2VIZWlnaHQgKiAyKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDE4MDpcbiAgICAgICAgdGhpcy54ICs9IHRoaXMud2lkdGggLyAyO1xuICAgICAgICB0aGlzLnkgKz0gdGhpcy5oZWlnaHQgLyAyO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjcwOlxuICAgICAgICB0aGlzLnggKz0gdGhpcy5oZWlnaHQgKiBwYWdlSGVpZ2h0IC8gKHBhZ2VXaWR0aCAqIDIpO1xuICAgICAgICB0aGlzLnkgLT0gdGhpcy53aWR0aCAqIHBhZ2VXaWR0aCAvIChwYWdlSGVpZ2h0ICogMik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhpcy54IC09IHRoaXMud2lkdGggLyAyO1xuICAgICAgICB0aGlzLnkgLT0gdGhpcy5oZWlnaHQgLyAyO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgdGhpcy5maXhBbmRTZXRQb3NpdGlvbigpO1xuICB9XG4gIGFkZENvbW1hbmRzKHBhcmFtcykge1xuICAgIHRoaXMuX3VpTWFuYWdlci5hZGRDb21tYW5kcyhwYXJhbXMpO1xuICB9XG4gIGdldCBjdXJyZW50TGF5ZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3VpTWFuYWdlci5jdXJyZW50TGF5ZXI7XG4gIH1cbiAgc2V0SW5CYWNrZ3JvdW5kKCkge1xuICAgIHRoaXMuZGl2LnN0eWxlLnpJbmRleCA9IDA7XG4gIH1cbiAgc2V0SW5Gb3JlZ3JvdW5kKCkge1xuICAgIHRoaXMuZGl2LnN0eWxlLnpJbmRleCA9IHRoaXMuI3pJbmRleDtcbiAgfVxuICBzZXRQYXJlbnQocGFyZW50KSB7XG4gICAgaWYgKHBhcmVudCAhPT0gbnVsbCkge1xuICAgICAgdGhpcy5wYWdlSW5kZXggPSBwYXJlbnQucGFnZUluZGV4O1xuICAgICAgdGhpcy5wYWdlRGltZW5zaW9ucyA9IHBhcmVudC5wYWdlRGltZW5zaW9ucztcbiAgICB9XG4gICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gIH1cbiAgZm9jdXNpbihldmVudCkge1xuICAgIGlmICghdGhpcy5fZm9jdXNFdmVudHNBbGxvd2VkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghdGhpcy4jaGFzQmVlbkNsaWNrZWQpIHtcbiAgICAgIHRoaXMucGFyZW50LnNldFNlbGVjdGVkKHRoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLiNoYXNCZWVuQ2xpY2tlZCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICBmb2N1c291dChldmVudCkge1xuICAgIGlmICghdGhpcy5fZm9jdXNFdmVudHNBbGxvd2VkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghdGhpcy5pc0F0dGFjaGVkVG9ET00pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdGFyZ2V0ID0gZXZlbnQucmVsYXRlZFRhcmdldDtcbiAgICBpZiAodGFyZ2V0Py5jbG9zZXN0KGAjJHt0aGlzLmlkfWApKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgaWYgKCF0aGlzLnBhcmVudD8uaXNNdWx0aXBsZVNlbGVjdGlvbikge1xuICAgICAgdGhpcy5jb21taXRPclJlbW92ZSgpO1xuICAgIH1cbiAgfVxuICBjb21taXRPclJlbW92ZSgpIHtcbiAgICBpZiAodGhpcy5pc0VtcHR5KCkpIHtcbiAgICAgIHRoaXMucmVtb3ZlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY29tbWl0KCk7XG4gICAgfVxuICB9XG4gIGNvbW1pdCgpIHtcbiAgICB0aGlzLmFkZFRvQW5ub3RhdGlvblN0b3JhZ2UoKTtcbiAgfVxuICBhZGRUb0Fubm90YXRpb25TdG9yYWdlKCkge1xuICAgIHRoaXMuX3VpTWFuYWdlci5hZGRUb0Fubm90YXRpb25TdG9yYWdlKHRoaXMpO1xuICB9XG4gIHNldEF0KHgsIHksIHR4LCB0eSkge1xuICAgIGNvbnN0IFt3aWR0aCwgaGVpZ2h0XSA9IHRoaXMucGFyZW50RGltZW5zaW9ucztcbiAgICBbdHgsIHR5XSA9IHRoaXMuc2NyZWVuVG9QYWdlVHJhbnNsYXRpb24odHgsIHR5KTtcbiAgICB0aGlzLnggPSAoeCArIHR4KSAvIHdpZHRoO1xuICAgIHRoaXMueSA9ICh5ICsgdHkpIC8gaGVpZ2h0O1xuICAgIHRoaXMuZml4QW5kU2V0UG9zaXRpb24oKTtcbiAgfVxuICAjdHJhbnNsYXRlKFt3aWR0aCwgaGVpZ2h0XSwgeCwgeSkge1xuICAgIFt4LCB5XSA9IHRoaXMuc2NyZWVuVG9QYWdlVHJhbnNsYXRpb24oeCwgeSk7XG4gICAgdGhpcy54ICs9IHggLyB3aWR0aDtcbiAgICB0aGlzLnkgKz0geSAvIGhlaWdodDtcbiAgICB0aGlzLmZpeEFuZFNldFBvc2l0aW9uKCk7XG4gIH1cbiAgdHJhbnNsYXRlKHgsIHkpIHtcbiAgICB0aGlzLiN0cmFuc2xhdGUodGhpcy5wYXJlbnREaW1lbnNpb25zLCB4LCB5KTtcbiAgfVxuICB0cmFuc2xhdGVJblBhZ2UoeCwgeSkge1xuICAgIHRoaXMuI3RyYW5zbGF0ZSh0aGlzLnBhZ2VEaW1lbnNpb25zLCB4LCB5KTtcbiAgICB0aGlzLmRpdi5zY3JvbGxJbnRvVmlldyh7XG4gICAgICBibG9jazogXCJuZWFyZXN0XCJcbiAgICB9KTtcbiAgfVxuICBkcmFnKHR4LCB0eSkge1xuICAgIGNvbnN0IFtwYXJlbnRXaWR0aCwgcGFyZW50SGVpZ2h0XSA9IHRoaXMucGFyZW50RGltZW5zaW9ucztcbiAgICB0aGlzLnggKz0gdHggLyBwYXJlbnRXaWR0aDtcbiAgICB0aGlzLnkgKz0gdHkgLyBwYXJlbnRIZWlnaHQ7XG4gICAgaWYgKHRoaXMucGFyZW50ICYmICh0aGlzLnggPCAwIHx8IHRoaXMueCA+IDEgfHwgdGhpcy55IDwgMCB8fCB0aGlzLnkgPiAxKSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICB4LFxuICAgICAgICB5XG4gICAgICB9ID0gdGhpcy5kaXYuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBpZiAodGhpcy5wYXJlbnQuZmluZE5ld1BhcmVudCh0aGlzLCB4LCB5KSkge1xuICAgICAgICB0aGlzLnggLT0gTWF0aC5mbG9vcih0aGlzLngpO1xuICAgICAgICB0aGlzLnkgLT0gTWF0aC5mbG9vcih0aGlzLnkpO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQge1xuICAgICAgeCxcbiAgICAgIHlcbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCBbYngsIGJ5XSA9IHRoaXMuI2dldEJhc2VUcmFuc2xhdGlvbigpO1xuICAgIHggKz0gYng7XG4gICAgeSArPSBieTtcbiAgICB0aGlzLmRpdi5zdHlsZS5sZWZ0ID0gYCR7KDEwMCAqIHgpLnRvRml4ZWQoMil9JWA7XG4gICAgdGhpcy5kaXYuc3R5bGUudG9wID0gYCR7KDEwMCAqIHkpLnRvRml4ZWQoMil9JWA7XG4gICAgdGhpcy5kaXYuc2Nyb2xsSW50b1ZpZXcoe1xuICAgICAgYmxvY2s6IFwibmVhcmVzdFwiXG4gICAgfSk7XG4gIH1cbiAgI2dldEJhc2VUcmFuc2xhdGlvbigpIHtcbiAgICBjb25zdCBbcGFyZW50V2lkdGgsIHBhcmVudEhlaWdodF0gPSB0aGlzLnBhcmVudERpbWVuc2lvbnM7XG4gICAgY29uc3Qge1xuICAgICAgX2JvcmRlckxpbmVXaWR0aFxuICAgIH0gPSBBbm5vdGF0aW9uRWRpdG9yO1xuICAgIGNvbnN0IHggPSBfYm9yZGVyTGluZVdpZHRoIC8gcGFyZW50V2lkdGg7XG4gICAgY29uc3QgeSA9IF9ib3JkZXJMaW5lV2lkdGggLyBwYXJlbnRIZWlnaHQ7XG4gICAgc3dpdGNoICh0aGlzLnJvdGF0aW9uKSB7XG4gICAgICBjYXNlIDkwOlxuICAgICAgICByZXR1cm4gWy14LCB5XTtcbiAgICAgIGNhc2UgMTgwOlxuICAgICAgICByZXR1cm4gW3gsIHldO1xuICAgICAgY2FzZSAyNzA6XG4gICAgICAgIHJldHVybiBbeCwgLXldO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIFsteCwgLXldO1xuICAgIH1cbiAgfVxuICBmaXhBbmRTZXRQb3NpdGlvbigpIHtcbiAgICBjb25zdCBbcGFnZVdpZHRoLCBwYWdlSGVpZ2h0XSA9IHRoaXMucGFnZURpbWVuc2lvbnM7XG4gICAgbGV0IHtcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHRcbiAgICB9ID0gdGhpcztcbiAgICB3aWR0aCAqPSBwYWdlV2lkdGg7XG4gICAgaGVpZ2h0ICo9IHBhZ2VIZWlnaHQ7XG4gICAgeCAqPSBwYWdlV2lkdGg7XG4gICAgeSAqPSBwYWdlSGVpZ2h0O1xuICAgIHN3aXRjaCAodGhpcy5yb3RhdGlvbikge1xuICAgICAgY2FzZSAwOlxuICAgICAgICB4ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4ocGFnZVdpZHRoIC0gd2lkdGgsIHgpKTtcbiAgICAgICAgeSA9IE1hdGgubWF4KDAsIE1hdGgubWluKHBhZ2VIZWlnaHQgLSBoZWlnaHQsIHkpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDkwOlxuICAgICAgICB4ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4ocGFnZVdpZHRoIC0gaGVpZ2h0LCB4KSk7XG4gICAgICAgIHkgPSBNYXRoLm1pbihwYWdlSGVpZ2h0LCBNYXRoLm1heCh3aWR0aCwgeSkpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTgwOlxuICAgICAgICB4ID0gTWF0aC5taW4ocGFnZVdpZHRoLCBNYXRoLm1heCh3aWR0aCwgeCkpO1xuICAgICAgICB5ID0gTWF0aC5taW4ocGFnZUhlaWdodCwgTWF0aC5tYXgoaGVpZ2h0LCB5KSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyNzA6XG4gICAgICAgIHggPSBNYXRoLm1pbihwYWdlV2lkdGgsIE1hdGgubWF4KGhlaWdodCwgeCkpO1xuICAgICAgICB5ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4ocGFnZUhlaWdodCAtIHdpZHRoLCB5KSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICB0aGlzLnggPSB4IC89IHBhZ2VXaWR0aDtcbiAgICB0aGlzLnkgPSB5IC89IHBhZ2VIZWlnaHQ7XG4gICAgY29uc3QgW2J4LCBieV0gPSB0aGlzLiNnZXRCYXNlVHJhbnNsYXRpb24oKTtcbiAgICB4ICs9IGJ4O1xuICAgIHkgKz0gYnk7XG4gICAgY29uc3Qge1xuICAgICAgc3R5bGVcbiAgICB9ID0gdGhpcy5kaXY7XG4gICAgc3R5bGUubGVmdCA9IGAkeygxMDAgKiB4KS50b0ZpeGVkKDIpfSVgO1xuICAgIHN0eWxlLnRvcCA9IGAkeygxMDAgKiB5KS50b0ZpeGVkKDIpfSVgO1xuICAgIHRoaXMubW92ZUluRE9NKCk7XG4gIH1cbiAgc3RhdGljICNyb3RhdGVQb2ludCh4LCB5LCBhbmdsZSkge1xuICAgIHN3aXRjaCAoYW5nbGUpIHtcbiAgICAgIGNhc2UgOTA6XG4gICAgICAgIHJldHVybiBbeSwgLXhdO1xuICAgICAgY2FzZSAxODA6XG4gICAgICAgIHJldHVybiBbLXgsIC15XTtcbiAgICAgIGNhc2UgMjcwOlxuICAgICAgICByZXR1cm4gWy15LCB4XTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBbeCwgeV07XG4gICAgfVxuICB9XG4gIHNjcmVlblRvUGFnZVRyYW5zbGF0aW9uKHgsIHkpIHtcbiAgICByZXR1cm4gQW5ub3RhdGlvbkVkaXRvci4jcm90YXRlUG9pbnQoeCwgeSwgdGhpcy5wYXJlbnRSb3RhdGlvbik7XG4gIH1cbiAgcGFnZVRyYW5zbGF0aW9uVG9TY3JlZW4oeCwgeSkge1xuICAgIHJldHVybiBBbm5vdGF0aW9uRWRpdG9yLiNyb3RhdGVQb2ludCh4LCB5LCAzNjAgLSB0aGlzLnBhcmVudFJvdGF0aW9uKTtcbiAgfVxuICAjZ2V0Um90YXRpb25NYXRyaXgocm90YXRpb24pIHtcbiAgICBzd2l0Y2ggKHJvdGF0aW9uKSB7XG4gICAgICBjYXNlIDkwOlxuICAgICAgICB7XG4gICAgICAgICAgY29uc3QgW3BhZ2VXaWR0aCwgcGFnZUhlaWdodF0gPSB0aGlzLnBhZ2VEaW1lbnNpb25zO1xuICAgICAgICAgIHJldHVybiBbMCwgLXBhZ2VXaWR0aCAvIHBhZ2VIZWlnaHQsIHBhZ2VIZWlnaHQgLyBwYWdlV2lkdGgsIDBdO1xuICAgICAgICB9XG4gICAgICBjYXNlIDE4MDpcbiAgICAgICAgcmV0dXJuIFstMSwgMCwgMCwgLTFdO1xuICAgICAgY2FzZSAyNzA6XG4gICAgICAgIHtcbiAgICAgICAgICBjb25zdCBbcGFnZVdpZHRoLCBwYWdlSGVpZ2h0XSA9IHRoaXMucGFnZURpbWVuc2lvbnM7XG4gICAgICAgICAgcmV0dXJuIFswLCBwYWdlV2lkdGggLyBwYWdlSGVpZ2h0LCAtcGFnZUhlaWdodCAvIHBhZ2VXaWR0aCwgMF07XG4gICAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBbMSwgMCwgMCwgMV07XG4gICAgfVxuICB9XG4gIGdldCBwYXJlbnRTY2FsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdWlNYW5hZ2VyLnZpZXdQYXJhbWV0ZXJzLnJlYWxTY2FsZTtcbiAgfVxuICBnZXQgcGFyZW50Um90YXRpb24oKSB7XG4gICAgcmV0dXJuICh0aGlzLl91aU1hbmFnZXIudmlld1BhcmFtZXRlcnMucm90YXRpb24gKyB0aGlzLnBhZ2VSb3RhdGlvbikgJSAzNjA7XG4gIH1cbiAgZ2V0IHBhcmVudERpbWVuc2lvbnMoKSB7XG4gICAgY29uc3Qge1xuICAgICAgcGFyZW50U2NhbGUsXG4gICAgICBwYWdlRGltZW5zaW9uczogW3BhZ2VXaWR0aCwgcGFnZUhlaWdodF1cbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCBzY2FsZWRXaWR0aCA9IHBhZ2VXaWR0aCAqIHBhcmVudFNjYWxlO1xuICAgIGNvbnN0IHNjYWxlZEhlaWdodCA9IHBhZ2VIZWlnaHQgKiBwYXJlbnRTY2FsZTtcbiAgICByZXR1cm4gX3V0aWwuRmVhdHVyZVRlc3QuaXNDU1NSb3VuZFN1cHBvcnRlZCA/IFtNYXRoLnJvdW5kKHNjYWxlZFdpZHRoKSwgTWF0aC5yb3VuZChzY2FsZWRIZWlnaHQpXSA6IFtzY2FsZWRXaWR0aCwgc2NhbGVkSGVpZ2h0XTtcbiAgfVxuICBzZXREaW1zKHdpZHRoLCBoZWlnaHQpIHtcbiAgICBjb25zdCBbcGFyZW50V2lkdGgsIHBhcmVudEhlaWdodF0gPSB0aGlzLnBhcmVudERpbWVuc2lvbnM7XG4gICAgdGhpcy5kaXYuc3R5bGUud2lkdGggPSBgJHsoMTAwICogd2lkdGggLyBwYXJlbnRXaWR0aCkudG9GaXhlZCgyKX0lYDtcbiAgICBpZiAoIXRoaXMuI2tlZXBBc3BlY3RSYXRpbykge1xuICAgICAgdGhpcy5kaXYuc3R5bGUuaGVpZ2h0ID0gYCR7KDEwMCAqIGhlaWdodCAvIHBhcmVudEhlaWdodCkudG9GaXhlZCgyKX0lYDtcbiAgICB9XG4gICAgdGhpcy4jYWx0VGV4dEJ1dHRvbj8uY2xhc3NMaXN0LnRvZ2dsZShcInNtYWxsXCIsIHdpZHRoIDwgQW5ub3RhdGlvbkVkaXRvci5TTUFMTF9FRElUT1JfU0laRSB8fCBoZWlnaHQgPCBBbm5vdGF0aW9uRWRpdG9yLlNNQUxMX0VESVRPUl9TSVpFKTtcbiAgfVxuICBmaXhEaW1zKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHN0eWxlXG4gICAgfSA9IHRoaXMuZGl2O1xuICAgIGNvbnN0IHtcbiAgICAgIGhlaWdodCxcbiAgICAgIHdpZHRoXG4gICAgfSA9IHN0eWxlO1xuICAgIGNvbnN0IHdpZHRoUGVyY2VudCA9IHdpZHRoLmVuZHNXaXRoKFwiJVwiKTtcbiAgICBjb25zdCBoZWlnaHRQZXJjZW50ID0gIXRoaXMuI2tlZXBBc3BlY3RSYXRpbyAmJiBoZWlnaHQuZW5kc1dpdGgoXCIlXCIpO1xuICAgIGlmICh3aWR0aFBlcmNlbnQgJiYgaGVpZ2h0UGVyY2VudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBbcGFyZW50V2lkdGgsIHBhcmVudEhlaWdodF0gPSB0aGlzLnBhcmVudERpbWVuc2lvbnM7XG4gICAgaWYgKCF3aWR0aFBlcmNlbnQpIHtcbiAgICAgIHN0eWxlLndpZHRoID0gYCR7KDEwMCAqIHBhcnNlRmxvYXQod2lkdGgpIC8gcGFyZW50V2lkdGgpLnRvRml4ZWQoMil9JWA7XG4gICAgfVxuICAgIGlmICghdGhpcy4ja2VlcEFzcGVjdFJhdGlvICYmICFoZWlnaHRQZXJjZW50KSB7XG4gICAgICBzdHlsZS5oZWlnaHQgPSBgJHsoMTAwICogcGFyc2VGbG9hdChoZWlnaHQpIC8gcGFyZW50SGVpZ2h0KS50b0ZpeGVkKDIpfSVgO1xuICAgIH1cbiAgfVxuICBnZXRJbml0aWFsVHJhbnNsYXRpb24oKSB7XG4gICAgcmV0dXJuIFswLCAwXTtcbiAgfVxuICAjY3JlYXRlUmVzaXplcnMoKSB7XG4gICAgaWYgKHRoaXMuI3Jlc2l6ZXJzRGl2KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI3Jlc2l6ZXJzRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICB0aGlzLiNyZXNpemVyc0Rpdi5jbGFzc0xpc3QuYWRkKFwicmVzaXplcnNcIik7XG4gICAgY29uc3QgY2xhc3NlcyA9IFtcInRvcExlZnRcIiwgXCJ0b3BSaWdodFwiLCBcImJvdHRvbVJpZ2h0XCIsIFwiYm90dG9tTGVmdFwiXTtcbiAgICBpZiAoIXRoaXMuX3dpbGxLZWVwQXNwZWN0UmF0aW8pIHtcbiAgICAgIGNsYXNzZXMucHVzaChcInRvcE1pZGRsZVwiLCBcIm1pZGRsZVJpZ2h0XCIsIFwiYm90dG9tTWlkZGxlXCIsIFwibWlkZGxlTGVmdFwiKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBuYW1lIG9mIGNsYXNzZXMpIHtcbiAgICAgIGNvbnN0IGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICB0aGlzLiNyZXNpemVyc0Rpdi5hcHBlbmQoZGl2KTtcbiAgICAgIGRpdi5jbGFzc0xpc3QuYWRkKFwicmVzaXplclwiLCBuYW1lKTtcbiAgICAgIGRpdi5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcmRvd25cIiwgdGhpcy4jcmVzaXplclBvaW50ZXJkb3duLmJpbmQodGhpcywgbmFtZSkpO1xuICAgICAgZGl2LmFkZEV2ZW50TGlzdGVuZXIoXCJjb250ZXh0bWVudVwiLCBfZGlzcGxheV91dGlscy5ub0NvbnRleHRNZW51KTtcbiAgICB9XG4gICAgdGhpcy5kaXYucHJlcGVuZCh0aGlzLiNyZXNpemVyc0Rpdik7XG4gIH1cbiAgI3Jlc2l6ZXJQb2ludGVyZG93bihuYW1lLCBldmVudCkge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgY29uc3Qge1xuICAgICAgaXNNYWNcbiAgICB9ID0gX3V0aWwuRmVhdHVyZVRlc3QucGxhdGZvcm07XG4gICAgaWYgKGV2ZW50LmJ1dHRvbiAhPT0gMCB8fCBldmVudC5jdHJsS2V5ICYmIGlzTWFjKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGJvdW5kUmVzaXplclBvaW50ZXJtb3ZlID0gdGhpcy4jcmVzaXplclBvaW50ZXJtb3ZlLmJpbmQodGhpcywgbmFtZSk7XG4gICAgY29uc3Qgc2F2ZWREcmFnZ2FibGUgPSB0aGlzLl9pc0RyYWdnYWJsZTtcbiAgICB0aGlzLl9pc0RyYWdnYWJsZSA9IGZhbHNlO1xuICAgIGNvbnN0IHBvaW50ZXJNb3ZlT3B0aW9ucyA9IHtcbiAgICAgIHBhc3NpdmU6IHRydWUsXG4gICAgICBjYXB0dXJlOiB0cnVlXG4gICAgfTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJtb3ZlXCIsIGJvdW5kUmVzaXplclBvaW50ZXJtb3ZlLCBwb2ludGVyTW92ZU9wdGlvbnMpO1xuICAgIGNvbnN0IHNhdmVkWCA9IHRoaXMueDtcbiAgICBjb25zdCBzYXZlZFkgPSB0aGlzLnk7XG4gICAgY29uc3Qgc2F2ZWRXaWR0aCA9IHRoaXMud2lkdGg7XG4gICAgY29uc3Qgc2F2ZWRIZWlnaHQgPSB0aGlzLmhlaWdodDtcbiAgICBjb25zdCBzYXZlZFBhcmVudEN1cnNvciA9IHRoaXMucGFyZW50LmRpdi5zdHlsZS5jdXJzb3I7XG4gICAgY29uc3Qgc2F2ZWRDdXJzb3IgPSB0aGlzLmRpdi5zdHlsZS5jdXJzb3I7XG4gICAgdGhpcy5kaXYuc3R5bGUuY3Vyc29yID0gdGhpcy5wYXJlbnQuZGl2LnN0eWxlLmN1cnNvciA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGV2ZW50LnRhcmdldCkuY3Vyc29yO1xuICAgIGNvbnN0IHBvaW50ZXJVcENhbGxiYWNrID0gKCkgPT4ge1xuICAgICAgdGhpcy5faXNEcmFnZ2FibGUgPSBzYXZlZERyYWdnYWJsZTtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwicG9pbnRlcnVwXCIsIHBvaW50ZXJVcENhbGxiYWNrKTtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwiYmx1clwiLCBwb2ludGVyVXBDYWxsYmFjayk7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJtb3ZlXCIsIGJvdW5kUmVzaXplclBvaW50ZXJtb3ZlLCBwb2ludGVyTW92ZU9wdGlvbnMpO1xuICAgICAgdGhpcy5wYXJlbnQuZGl2LnN0eWxlLmN1cnNvciA9IHNhdmVkUGFyZW50Q3Vyc29yO1xuICAgICAgdGhpcy5kaXYuc3R5bGUuY3Vyc29yID0gc2F2ZWRDdXJzb3I7XG4gICAgICBjb25zdCBuZXdYID0gdGhpcy54O1xuICAgICAgY29uc3QgbmV3WSA9IHRoaXMueTtcbiAgICAgIGNvbnN0IG5ld1dpZHRoID0gdGhpcy53aWR0aDtcbiAgICAgIGNvbnN0IG5ld0hlaWdodCA9IHRoaXMuaGVpZ2h0O1xuICAgICAgaWYgKG5ld1ggPT09IHNhdmVkWCAmJiBuZXdZID09PSBzYXZlZFkgJiYgbmV3V2lkdGggPT09IHNhdmVkV2lkdGggJiYgbmV3SGVpZ2h0ID09PSBzYXZlZEhlaWdodCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLmFkZENvbW1hbmRzKHtcbiAgICAgICAgY21kOiAoKSA9PiB7XG4gICAgICAgICAgdGhpcy53aWR0aCA9IG5ld1dpZHRoO1xuICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gbmV3SGVpZ2h0O1xuICAgICAgICAgIHRoaXMueCA9IG5ld1g7XG4gICAgICAgICAgdGhpcy55ID0gbmV3WTtcbiAgICAgICAgICBjb25zdCBbcGFyZW50V2lkdGgsIHBhcmVudEhlaWdodF0gPSB0aGlzLnBhcmVudERpbWVuc2lvbnM7XG4gICAgICAgICAgdGhpcy5zZXREaW1zKHBhcmVudFdpZHRoICogbmV3V2lkdGgsIHBhcmVudEhlaWdodCAqIG5ld0hlaWdodCk7XG4gICAgICAgICAgdGhpcy5maXhBbmRTZXRQb3NpdGlvbigpO1xuICAgICAgICB9LFxuICAgICAgICB1bmRvOiAoKSA9PiB7XG4gICAgICAgICAgdGhpcy53aWR0aCA9IHNhdmVkV2lkdGg7XG4gICAgICAgICAgdGhpcy5oZWlnaHQgPSBzYXZlZEhlaWdodDtcbiAgICAgICAgICB0aGlzLnggPSBzYXZlZFg7XG4gICAgICAgICAgdGhpcy55ID0gc2F2ZWRZO1xuICAgICAgICAgIGNvbnN0IFtwYXJlbnRXaWR0aCwgcGFyZW50SGVpZ2h0XSA9IHRoaXMucGFyZW50RGltZW5zaW9ucztcbiAgICAgICAgICB0aGlzLnNldERpbXMocGFyZW50V2lkdGggKiBzYXZlZFdpZHRoLCBwYXJlbnRIZWlnaHQgKiBzYXZlZEhlaWdodCk7XG4gICAgICAgICAgdGhpcy5maXhBbmRTZXRQb3NpdGlvbigpO1xuICAgICAgICB9LFxuICAgICAgICBtdXN0RXhlYzogdHJ1ZVxuICAgICAgfSk7XG4gICAgfTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJ1cFwiLCBwb2ludGVyVXBDYWxsYmFjayk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJibHVyXCIsIHBvaW50ZXJVcENhbGxiYWNrKTtcbiAgfVxuICAjcmVzaXplclBvaW50ZXJtb3ZlKG5hbWUsIGV2ZW50KSB7XG4gICAgY29uc3QgW3BhcmVudFdpZHRoLCBwYXJlbnRIZWlnaHRdID0gdGhpcy5wYXJlbnREaW1lbnNpb25zO1xuICAgIGNvbnN0IHNhdmVkWCA9IHRoaXMueDtcbiAgICBjb25zdCBzYXZlZFkgPSB0aGlzLnk7XG4gICAgY29uc3Qgc2F2ZWRXaWR0aCA9IHRoaXMud2lkdGg7XG4gICAgY29uc3Qgc2F2ZWRIZWlnaHQgPSB0aGlzLmhlaWdodDtcbiAgICBjb25zdCBtaW5XaWR0aCA9IEFubm90YXRpb25FZGl0b3IuTUlOX1NJWkUgLyBwYXJlbnRXaWR0aDtcbiAgICBjb25zdCBtaW5IZWlnaHQgPSBBbm5vdGF0aW9uRWRpdG9yLk1JTl9TSVpFIC8gcGFyZW50SGVpZ2h0O1xuICAgIGNvbnN0IHJvdW5kID0geCA9PiBNYXRoLnJvdW5kKHggKiAxMDAwMCkgLyAxMDAwMDtcbiAgICBjb25zdCByb3RhdGlvbk1hdHJpeCA9IHRoaXMuI2dldFJvdGF0aW9uTWF0cml4KHRoaXMucm90YXRpb24pO1xuICAgIGNvbnN0IHRyYW5zZiA9ICh4LCB5KSA9PiBbcm90YXRpb25NYXRyaXhbMF0gKiB4ICsgcm90YXRpb25NYXRyaXhbMl0gKiB5LCByb3RhdGlvbk1hdHJpeFsxXSAqIHggKyByb3RhdGlvbk1hdHJpeFszXSAqIHldO1xuICAgIGNvbnN0IGludlJvdGF0aW9uTWF0cml4ID0gdGhpcy4jZ2V0Um90YXRpb25NYXRyaXgoMzYwIC0gdGhpcy5yb3RhdGlvbik7XG4gICAgY29uc3QgaW52VHJhbnNmID0gKHgsIHkpID0+IFtpbnZSb3RhdGlvbk1hdHJpeFswXSAqIHggKyBpbnZSb3RhdGlvbk1hdHJpeFsyXSAqIHksIGludlJvdGF0aW9uTWF0cml4WzFdICogeCArIGludlJvdGF0aW9uTWF0cml4WzNdICogeV07XG4gICAgbGV0IGdldFBvaW50O1xuICAgIGxldCBnZXRPcHBvc2l0ZTtcbiAgICBsZXQgaXNEaWFnb25hbCA9IGZhbHNlO1xuICAgIGxldCBpc0hvcml6b250YWwgPSBmYWxzZTtcbiAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgIGNhc2UgXCJ0b3BMZWZ0XCI6XG4gICAgICAgIGlzRGlhZ29uYWwgPSB0cnVlO1xuICAgICAgICBnZXRQb2ludCA9ICh3LCBoKSA9PiBbMCwgMF07XG4gICAgICAgIGdldE9wcG9zaXRlID0gKHcsIGgpID0+IFt3LCBoXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwidG9wTWlkZGxlXCI6XG4gICAgICAgIGdldFBvaW50ID0gKHcsIGgpID0+IFt3IC8gMiwgMF07XG4gICAgICAgIGdldE9wcG9zaXRlID0gKHcsIGgpID0+IFt3IC8gMiwgaF07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInRvcFJpZ2h0XCI6XG4gICAgICAgIGlzRGlhZ29uYWwgPSB0cnVlO1xuICAgICAgICBnZXRQb2ludCA9ICh3LCBoKSA9PiBbdywgMF07XG4gICAgICAgIGdldE9wcG9zaXRlID0gKHcsIGgpID0+IFswLCBoXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwibWlkZGxlUmlnaHRcIjpcbiAgICAgICAgaXNIb3Jpem9udGFsID0gdHJ1ZTtcbiAgICAgICAgZ2V0UG9pbnQgPSAodywgaCkgPT4gW3csIGggLyAyXTtcbiAgICAgICAgZ2V0T3Bwb3NpdGUgPSAodywgaCkgPT4gWzAsIGggLyAyXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiYm90dG9tUmlnaHRcIjpcbiAgICAgICAgaXNEaWFnb25hbCA9IHRydWU7XG4gICAgICAgIGdldFBvaW50ID0gKHcsIGgpID0+IFt3LCBoXTtcbiAgICAgICAgZ2V0T3Bwb3NpdGUgPSAodywgaCkgPT4gWzAsIDBdO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJib3R0b21NaWRkbGVcIjpcbiAgICAgICAgZ2V0UG9pbnQgPSAodywgaCkgPT4gW3cgLyAyLCBoXTtcbiAgICAgICAgZ2V0T3Bwb3NpdGUgPSAodywgaCkgPT4gW3cgLyAyLCAwXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiYm90dG9tTGVmdFwiOlxuICAgICAgICBpc0RpYWdvbmFsID0gdHJ1ZTtcbiAgICAgICAgZ2V0UG9pbnQgPSAodywgaCkgPT4gWzAsIGhdO1xuICAgICAgICBnZXRPcHBvc2l0ZSA9ICh3LCBoKSA9PiBbdywgMF07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIm1pZGRsZUxlZnRcIjpcbiAgICAgICAgaXNIb3Jpem9udGFsID0gdHJ1ZTtcbiAgICAgICAgZ2V0UG9pbnQgPSAodywgaCkgPT4gWzAsIGggLyAyXTtcbiAgICAgICAgZ2V0T3Bwb3NpdGUgPSAodywgaCkgPT4gW3csIGggLyAyXTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNvbnN0IHBvaW50ID0gZ2V0UG9pbnQoc2F2ZWRXaWR0aCwgc2F2ZWRIZWlnaHQpO1xuICAgIGNvbnN0IG9wcG9zaXRlUG9pbnQgPSBnZXRPcHBvc2l0ZShzYXZlZFdpZHRoLCBzYXZlZEhlaWdodCk7XG4gICAgbGV0IHRyYW5zZk9wcG9zaXRlUG9pbnQgPSB0cmFuc2YoLi4ub3Bwb3NpdGVQb2ludCk7XG4gICAgY29uc3Qgb3Bwb3NpdGVYID0gcm91bmQoc2F2ZWRYICsgdHJhbnNmT3Bwb3NpdGVQb2ludFswXSk7XG4gICAgY29uc3Qgb3Bwb3NpdGVZID0gcm91bmQoc2F2ZWRZICsgdHJhbnNmT3Bwb3NpdGVQb2ludFsxXSk7XG4gICAgbGV0IHJhdGlvWCA9IDE7XG4gICAgbGV0IHJhdGlvWSA9IDE7XG4gICAgbGV0IFtkZWx0YVgsIGRlbHRhWV0gPSB0aGlzLnNjcmVlblRvUGFnZVRyYW5zbGF0aW9uKGV2ZW50Lm1vdmVtZW50WCwgZXZlbnQubW92ZW1lbnRZKTtcbiAgICBbZGVsdGFYLCBkZWx0YVldID0gaW52VHJhbnNmKGRlbHRhWCAvIHBhcmVudFdpZHRoLCBkZWx0YVkgLyBwYXJlbnRIZWlnaHQpO1xuICAgIGlmIChpc0RpYWdvbmFsKSB7XG4gICAgICBjb25zdCBvbGREaWFnID0gTWF0aC5oeXBvdChzYXZlZFdpZHRoLCBzYXZlZEhlaWdodCk7XG4gICAgICByYXRpb1ggPSByYXRpb1kgPSBNYXRoLm1heChNYXRoLm1pbihNYXRoLmh5cG90KG9wcG9zaXRlUG9pbnRbMF0gLSBwb2ludFswXSAtIGRlbHRhWCwgb3Bwb3NpdGVQb2ludFsxXSAtIHBvaW50WzFdIC0gZGVsdGFZKSAvIG9sZERpYWcsIDEgLyBzYXZlZFdpZHRoLCAxIC8gc2F2ZWRIZWlnaHQpLCBtaW5XaWR0aCAvIHNhdmVkV2lkdGgsIG1pbkhlaWdodCAvIHNhdmVkSGVpZ2h0KTtcbiAgICB9IGVsc2UgaWYgKGlzSG9yaXpvbnRhbCkge1xuICAgICAgcmF0aW9YID0gTWF0aC5tYXgobWluV2lkdGgsIE1hdGgubWluKDEsIE1hdGguYWJzKG9wcG9zaXRlUG9pbnRbMF0gLSBwb2ludFswXSAtIGRlbHRhWCkpKSAvIHNhdmVkV2lkdGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJhdGlvWSA9IE1hdGgubWF4KG1pbkhlaWdodCwgTWF0aC5taW4oMSwgTWF0aC5hYnMob3Bwb3NpdGVQb2ludFsxXSAtIHBvaW50WzFdIC0gZGVsdGFZKSkpIC8gc2F2ZWRIZWlnaHQ7XG4gICAgfVxuICAgIGNvbnN0IG5ld1dpZHRoID0gcm91bmQoc2F2ZWRXaWR0aCAqIHJhdGlvWCk7XG4gICAgY29uc3QgbmV3SGVpZ2h0ID0gcm91bmQoc2F2ZWRIZWlnaHQgKiByYXRpb1kpO1xuICAgIHRyYW5zZk9wcG9zaXRlUG9pbnQgPSB0cmFuc2YoLi4uZ2V0T3Bwb3NpdGUobmV3V2lkdGgsIG5ld0hlaWdodCkpO1xuICAgIGNvbnN0IG5ld1ggPSBvcHBvc2l0ZVggLSB0cmFuc2ZPcHBvc2l0ZVBvaW50WzBdO1xuICAgIGNvbnN0IG5ld1kgPSBvcHBvc2l0ZVkgLSB0cmFuc2ZPcHBvc2l0ZVBvaW50WzFdO1xuICAgIHRoaXMud2lkdGggPSBuZXdXaWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IG5ld0hlaWdodDtcbiAgICB0aGlzLnggPSBuZXdYO1xuICAgIHRoaXMueSA9IG5ld1k7XG4gICAgdGhpcy5zZXREaW1zKHBhcmVudFdpZHRoICogbmV3V2lkdGgsIHBhcmVudEhlaWdodCAqIG5ld0hlaWdodCk7XG4gICAgdGhpcy5maXhBbmRTZXRQb3NpdGlvbigpO1xuICB9XG4gIGFzeW5jIGFkZEFsdFRleHRCdXR0b24oKSB7XG4gICAgaWYgKHRoaXMuI2FsdFRleHRCdXR0b24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgYWx0VGV4dCA9IHRoaXMuI2FsdFRleHRCdXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIpO1xuICAgIGFsdFRleHQuY2xhc3NOYW1lID0gXCJhbHRUZXh0XCI7XG4gICAgY29uc3QgbXNnID0gYXdhaXQgQW5ub3RhdGlvbkVkaXRvci5fbDEwblByb21pc2UuZ2V0KFwiZWRpdG9yX2FsdF90ZXh0X2J1dHRvbl9sYWJlbFwiKTtcbiAgICBhbHRUZXh0LnRleHRDb250ZW50ID0gbXNnO1xuICAgIGFsdFRleHQuc2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiLCBtc2cpO1xuICAgIGFsdFRleHQudGFiSW5kZXggPSBcIjBcIjtcbiAgICBhbHRUZXh0LmFkZEV2ZW50TGlzdGVuZXIoXCJjb250ZXh0bWVudVwiLCBfZGlzcGxheV91dGlscy5ub0NvbnRleHRNZW51KTtcbiAgICBhbHRUZXh0LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVyZG93blwiLCBldmVudCA9PiBldmVudC5zdG9wUHJvcGFnYXRpb24oKSk7XG4gICAgYWx0VGV4dC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZXZlbnQgPT4ge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHRoaXMuX3VpTWFuYWdlci5lZGl0QWx0VGV4dCh0aGlzKTtcbiAgICB9LCB7XG4gICAgICBjYXB0dXJlOiB0cnVlXG4gICAgfSk7XG4gICAgYWx0VGV4dC5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBldmVudCA9PiB7XG4gICAgICBpZiAoZXZlbnQudGFyZ2V0ID09PSBhbHRUZXh0ICYmIGV2ZW50LmtleSA9PT0gXCJFbnRlclwiKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHRoaXMuX3VpTWFuYWdlci5lZGl0QWx0VGV4dCh0aGlzKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLiNzZXRBbHRUZXh0QnV0dG9uU3RhdGUoKTtcbiAgICB0aGlzLmRpdi5hcHBlbmQoYWx0VGV4dCk7XG4gICAgaWYgKCFBbm5vdGF0aW9uRWRpdG9yLlNNQUxMX0VESVRPUl9TSVpFKSB7XG4gICAgICBjb25zdCBQRVJDRU5UID0gNDA7XG4gICAgICBBbm5vdGF0aW9uRWRpdG9yLlNNQUxMX0VESVRPUl9TSVpFID0gTWF0aC5taW4oMTI4LCBNYXRoLnJvdW5kKGFsdFRleHQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggKiAoMSArIFBFUkNFTlQgLyAxMDApKSk7XG4gICAgfVxuICB9XG4gIGFzeW5jICNzZXRBbHRUZXh0QnV0dG9uU3RhdGUoKSB7XG4gICAgY29uc3QgYnV0dG9uID0gdGhpcy4jYWx0VGV4dEJ1dHRvbjtcbiAgICBpZiAoIWJ1dHRvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuI2FsdFRleHQgJiYgIXRoaXMuI2FsdFRleHREZWNvcmF0aXZlKSB7XG4gICAgICBidXR0b24uY2xhc3NMaXN0LnJlbW92ZShcImRvbmVcIik7XG4gICAgICB0aGlzLiNhbHRUZXh0VG9vbHRpcD8ucmVtb3ZlKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIEFubm90YXRpb25FZGl0b3IuX2wxMG5Qcm9taXNlLmdldChcImVkaXRvcl9hbHRfdGV4dF9lZGl0X2J1dHRvbl9sYWJlbFwiKS50aGVuKG1zZyA9PiB7XG4gICAgICBidXR0b24uc2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiLCBtc2cpO1xuICAgIH0pO1xuICAgIGxldCB0b29sdGlwID0gdGhpcy4jYWx0VGV4dFRvb2x0aXA7XG4gICAgaWYgKCF0b29sdGlwKSB7XG4gICAgICB0aGlzLiNhbHRUZXh0VG9vbHRpcCA9IHRvb2x0aXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICAgIHRvb2x0aXAuY2xhc3NOYW1lID0gXCJ0b29sdGlwXCI7XG4gICAgICB0b29sdGlwLnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJ0b29sdGlwXCIpO1xuICAgICAgY29uc3QgaWQgPSB0b29sdGlwLmlkID0gYGFsdC10ZXh0LXRvb2x0aXAtJHt0aGlzLmlkfWA7XG4gICAgICBidXR0b24uc2V0QXR0cmlidXRlKFwiYXJpYS1kZXNjcmliZWRieVwiLCBpZCk7XG4gICAgICBjb25zdCBERUxBWV9UT19TSE9XX1RPT0xUSVAgPSAxMDA7XG4gICAgICBidXR0b24uYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZW50ZXJcIiwgKCkgPT4ge1xuICAgICAgICB0aGlzLiNhbHRUZXh0VG9vbHRpcFRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICB0aGlzLiNhbHRUZXh0VG9vbHRpcFRpbWVvdXQgPSBudWxsO1xuICAgICAgICAgIHRoaXMuI2FsdFRleHRUb29sdGlwLmNsYXNzTGlzdC5hZGQoXCJzaG93XCIpO1xuICAgICAgICAgIHRoaXMuX3VpTWFuYWdlci5fZXZlbnRCdXMuZGlzcGF0Y2goXCJyZXBvcnR0ZWxlbWV0cnlcIiwge1xuICAgICAgICAgICAgc291cmNlOiB0aGlzLFxuICAgICAgICAgICAgZGV0YWlsczoge1xuICAgICAgICAgICAgICB0eXBlOiBcImVkaXRpbmdcIixcbiAgICAgICAgICAgICAgc3VidHlwZTogdGhpcy5lZGl0b3JUeXBlLFxuICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgYWN0aW9uOiBcImFsdF90ZXh0X3Rvb2x0aXBcIlxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sIERFTEFZX1RPX1NIT1dfVE9PTFRJUCk7XG4gICAgICB9KTtcbiAgICAgIGJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKFwibW91c2VsZWF2ZVwiLCAoKSA9PiB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLiNhbHRUZXh0VG9vbHRpcFRpbWVvdXQpO1xuICAgICAgICB0aGlzLiNhbHRUZXh0VG9vbHRpcFRpbWVvdXQgPSBudWxsO1xuICAgICAgICB0aGlzLiNhbHRUZXh0VG9vbHRpcD8uY2xhc3NMaXN0LnJlbW92ZShcInNob3dcIik7XG4gICAgICB9KTtcbiAgICB9XG4gICAgYnV0dG9uLmNsYXNzTGlzdC5hZGQoXCJkb25lXCIpO1xuICAgIHRvb2x0aXAuaW5uZXJUZXh0ID0gdGhpcy4jYWx0VGV4dERlY29yYXRpdmUgPyBhd2FpdCBBbm5vdGF0aW9uRWRpdG9yLl9sMTBuUHJvbWlzZS5nZXQoXCJlZGl0b3JfYWx0X3RleHRfZGVjb3JhdGl2ZV90b29sdGlwXCIpIDogdGhpcy4jYWx0VGV4dDtcbiAgICBpZiAoIXRvb2x0aXAucGFyZW50Tm9kZSkge1xuICAgICAgYnV0dG9uLmFwcGVuZCh0b29sdGlwKTtcbiAgICB9XG4gIH1cbiAgZ2V0Q2xpZW50RGltZW5zaW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5kaXYuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIH1cbiAgZ2V0IGFsdFRleHREYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICBhbHRUZXh0OiB0aGlzLiNhbHRUZXh0LFxuICAgICAgZGVjb3JhdGl2ZTogdGhpcy4jYWx0VGV4dERlY29yYXRpdmVcbiAgICB9O1xuICB9XG4gIHNldCBhbHRUZXh0RGF0YSh7XG4gICAgYWx0VGV4dCxcbiAgICBkZWNvcmF0aXZlXG4gIH0pIHtcbiAgICBpZiAodGhpcy4jYWx0VGV4dCA9PT0gYWx0VGV4dCAmJiB0aGlzLiNhbHRUZXh0RGVjb3JhdGl2ZSA9PT0gZGVjb3JhdGl2ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNhbHRUZXh0ID0gYWx0VGV4dDtcbiAgICB0aGlzLiNhbHRUZXh0RGVjb3JhdGl2ZSA9IGRlY29yYXRpdmU7XG4gICAgdGhpcy4jc2V0QWx0VGV4dEJ1dHRvblN0YXRlKCk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIHRoaXMuZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICB0aGlzLmRpdi5zZXRBdHRyaWJ1dGUoXCJkYXRhLWVkaXRvci1yb3RhdGlvblwiLCAoMzYwIC0gdGhpcy5yb3RhdGlvbikgJSAzNjApO1xuICAgIHRoaXMuZGl2LmNsYXNzTmFtZSA9IHRoaXMubmFtZTtcbiAgICB0aGlzLmRpdi5zZXRBdHRyaWJ1dGUoXCJpZFwiLCB0aGlzLmlkKTtcbiAgICB0aGlzLmRpdi5zZXRBdHRyaWJ1dGUoXCJ0YWJJbmRleFwiLCAwKTtcbiAgICB0aGlzLnNldEluRm9yZWdyb3VuZCgpO1xuICAgIHRoaXMuZGl2LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c2luXCIsIHRoaXMuI2JvdW5kRm9jdXNpbik7XG4gICAgdGhpcy5kaXYuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3Vzb3V0XCIsIHRoaXMuI2JvdW5kRm9jdXNvdXQpO1xuICAgIGNvbnN0IFtwYXJlbnRXaWR0aCwgcGFyZW50SGVpZ2h0XSA9IHRoaXMucGFyZW50RGltZW5zaW9ucztcbiAgICBpZiAodGhpcy5wYXJlbnRSb3RhdGlvbiAlIDE4MCAhPT0gMCkge1xuICAgICAgdGhpcy5kaXYuc3R5bGUubWF4V2lkdGggPSBgJHsoMTAwICogcGFyZW50SGVpZ2h0IC8gcGFyZW50V2lkdGgpLnRvRml4ZWQoMil9JWA7XG4gICAgICB0aGlzLmRpdi5zdHlsZS5tYXhIZWlnaHQgPSBgJHsoMTAwICogcGFyZW50V2lkdGggLyBwYXJlbnRIZWlnaHQpLnRvRml4ZWQoMil9JWA7XG4gICAgfVxuICAgIGNvbnN0IFt0eCwgdHldID0gdGhpcy5nZXRJbml0aWFsVHJhbnNsYXRpb24oKTtcbiAgICB0aGlzLnRyYW5zbGF0ZSh0eCwgdHkpO1xuICAgICgwLCBfdG9vbHMuYmluZEV2ZW50cykodGhpcywgdGhpcy5kaXYsIFtcInBvaW50ZXJkb3duXCJdKTtcbiAgICByZXR1cm4gdGhpcy5kaXY7XG4gIH1cbiAgcG9pbnRlcmRvd24oZXZlbnQpIHtcbiAgICBjb25zdCB7XG4gICAgICBpc01hY1xuICAgIH0gPSBfdXRpbC5GZWF0dXJlVGVzdC5wbGF0Zm9ybTtcbiAgICBpZiAoZXZlbnQuYnV0dG9uICE9PSAwIHx8IGV2ZW50LmN0cmxLZXkgJiYgaXNNYWMpIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2hhc0JlZW5DbGlja2VkID0gdHJ1ZTtcbiAgICB0aGlzLiNzZXRVcERyYWdTZXNzaW9uKGV2ZW50KTtcbiAgfVxuICAjc2V0VXBEcmFnU2Vzc2lvbihldmVudCkge1xuICAgIGlmICghdGhpcy5faXNEcmFnZ2FibGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaXNTZWxlY3RlZCA9IHRoaXMuX3VpTWFuYWdlci5pc1NlbGVjdGVkKHRoaXMpO1xuICAgIHRoaXMuX3VpTWFuYWdlci5zZXRVcERyYWdTZXNzaW9uKCk7XG4gICAgbGV0IHBvaW50ZXJNb3ZlT3B0aW9ucywgcG9pbnRlck1vdmVDYWxsYmFjaztcbiAgICBpZiAoaXNTZWxlY3RlZCkge1xuICAgICAgcG9pbnRlck1vdmVPcHRpb25zID0ge1xuICAgICAgICBwYXNzaXZlOiB0cnVlLFxuICAgICAgICBjYXB0dXJlOiB0cnVlXG4gICAgICB9O1xuICAgICAgcG9pbnRlck1vdmVDYWxsYmFjayA9IGUgPT4ge1xuICAgICAgICBjb25zdCBbdHgsIHR5XSA9IHRoaXMuc2NyZWVuVG9QYWdlVHJhbnNsYXRpb24oZS5tb3ZlbWVudFgsIGUubW92ZW1lbnRZKTtcbiAgICAgICAgdGhpcy5fdWlNYW5hZ2VyLmRyYWdTZWxlY3RlZEVkaXRvcnModHgsIHR5KTtcbiAgICAgIH07XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJtb3ZlXCIsIHBvaW50ZXJNb3ZlQ2FsbGJhY2ssIHBvaW50ZXJNb3ZlT3B0aW9ucyk7XG4gICAgfVxuICAgIGNvbnN0IHBvaW50ZXJVcENhbGxiYWNrID0gKCkgPT4ge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJwb2ludGVydXBcIiwgcG9pbnRlclVwQ2FsbGJhY2spO1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJibHVyXCIsIHBvaW50ZXJVcENhbGxiYWNrKTtcbiAgICAgIGlmIChpc1NlbGVjdGVkKSB7XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwicG9pbnRlcm1vdmVcIiwgcG9pbnRlck1vdmVDYWxsYmFjaywgcG9pbnRlck1vdmVPcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuI2hhc0JlZW5DbGlja2VkID0gZmFsc2U7XG4gICAgICBpZiAoIXRoaXMuX3VpTWFuYWdlci5lbmREcmFnU2Vzc2lvbigpKSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBpc01hY1xuICAgICAgICB9ID0gX3V0aWwuRmVhdHVyZVRlc3QucGxhdGZvcm07XG4gICAgICAgIGlmIChldmVudC5jdHJsS2V5ICYmICFpc01hYyB8fCBldmVudC5zaGlmdEtleSB8fCBldmVudC5tZXRhS2V5ICYmIGlzTWFjKSB7XG4gICAgICAgICAgdGhpcy5wYXJlbnQudG9nZ2xlU2VsZWN0ZWQodGhpcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5wYXJlbnQuc2V0U2VsZWN0ZWQodGhpcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcnVwXCIsIHBvaW50ZXJVcENhbGxiYWNrKTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImJsdXJcIiwgcG9pbnRlclVwQ2FsbGJhY2spO1xuICB9XG4gIG1vdmVJbkRPTSgpIHtcbiAgICB0aGlzLnBhcmVudD8ubW92ZUVkaXRvckluRE9NKHRoaXMpO1xuICB9XG4gIF9zZXRQYXJlbnRBbmRQb3NpdGlvbihwYXJlbnQsIHgsIHkpIHtcbiAgICBwYXJlbnQuY2hhbmdlUGFyZW50KHRoaXMpO1xuICAgIHRoaXMueCA9IHg7XG4gICAgdGhpcy55ID0geTtcbiAgICB0aGlzLmZpeEFuZFNldFBvc2l0aW9uKCk7XG4gIH1cbiAgZ2V0UmVjdCh0eCwgdHkpIHtcbiAgICBjb25zdCBzY2FsZSA9IHRoaXMucGFyZW50U2NhbGU7XG4gICAgY29uc3QgW3BhZ2VXaWR0aCwgcGFnZUhlaWdodF0gPSB0aGlzLnBhZ2VEaW1lbnNpb25zO1xuICAgIGNvbnN0IFtwYWdlWCwgcGFnZVldID0gdGhpcy5wYWdlVHJhbnNsYXRpb247XG4gICAgY29uc3Qgc2hpZnRYID0gdHggLyBzY2FsZTtcbiAgICBjb25zdCBzaGlmdFkgPSB0eSAvIHNjYWxlO1xuICAgIGNvbnN0IHggPSB0aGlzLnggKiBwYWdlV2lkdGg7XG4gICAgY29uc3QgeSA9IHRoaXMueSAqIHBhZ2VIZWlnaHQ7XG4gICAgY29uc3Qgd2lkdGggPSB0aGlzLndpZHRoICogcGFnZVdpZHRoO1xuICAgIGNvbnN0IGhlaWdodCA9IHRoaXMuaGVpZ2h0ICogcGFnZUhlaWdodDtcbiAgICBzd2l0Y2ggKHRoaXMucm90YXRpb24pIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgcmV0dXJuIFt4ICsgc2hpZnRYICsgcGFnZVgsIHBhZ2VIZWlnaHQgLSB5IC0gc2hpZnRZIC0gaGVpZ2h0ICsgcGFnZVksIHggKyBzaGlmdFggKyB3aWR0aCArIHBhZ2VYLCBwYWdlSGVpZ2h0IC0geSAtIHNoaWZ0WSArIHBhZ2VZXTtcbiAgICAgIGNhc2UgOTA6XG4gICAgICAgIHJldHVybiBbeCArIHNoaWZ0WSArIHBhZ2VYLCBwYWdlSGVpZ2h0IC0geSArIHNoaWZ0WCArIHBhZ2VZLCB4ICsgc2hpZnRZICsgaGVpZ2h0ICsgcGFnZVgsIHBhZ2VIZWlnaHQgLSB5ICsgc2hpZnRYICsgd2lkdGggKyBwYWdlWV07XG4gICAgICBjYXNlIDE4MDpcbiAgICAgICAgcmV0dXJuIFt4IC0gc2hpZnRYIC0gd2lkdGggKyBwYWdlWCwgcGFnZUhlaWdodCAtIHkgKyBzaGlmdFkgKyBwYWdlWSwgeCAtIHNoaWZ0WCArIHBhZ2VYLCBwYWdlSGVpZ2h0IC0geSArIHNoaWZ0WSArIGhlaWdodCArIHBhZ2VZXTtcbiAgICAgIGNhc2UgMjcwOlxuICAgICAgICByZXR1cm4gW3ggLSBzaGlmdFkgLSBoZWlnaHQgKyBwYWdlWCwgcGFnZUhlaWdodCAtIHkgLSBzaGlmdFggLSB3aWR0aCArIHBhZ2VZLCB4IC0gc2hpZnRZICsgcGFnZVgsIHBhZ2VIZWlnaHQgLSB5IC0gc2hpZnRYICsgcGFnZVldO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCByb3RhdGlvblwiKTtcbiAgICB9XG4gIH1cbiAgZ2V0UmVjdEluQ3VycmVudENvb3JkcyhyZWN0LCBwYWdlSGVpZ2h0KSB7XG4gICAgY29uc3QgW3gxLCB5MSwgeDIsIHkyXSA9IHJlY3Q7XG4gICAgY29uc3Qgd2lkdGggPSB4MiAtIHgxO1xuICAgIGNvbnN0IGhlaWdodCA9IHkyIC0geTE7XG4gICAgc3dpdGNoICh0aGlzLnJvdGF0aW9uKSB7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIHJldHVybiBbeDEsIHBhZ2VIZWlnaHQgLSB5Miwgd2lkdGgsIGhlaWdodF07XG4gICAgICBjYXNlIDkwOlxuICAgICAgICByZXR1cm4gW3gxLCBwYWdlSGVpZ2h0IC0geTEsIGhlaWdodCwgd2lkdGhdO1xuICAgICAgY2FzZSAxODA6XG4gICAgICAgIHJldHVybiBbeDIsIHBhZ2VIZWlnaHQgLSB5MSwgd2lkdGgsIGhlaWdodF07XG4gICAgICBjYXNlIDI3MDpcbiAgICAgICAgcmV0dXJuIFt4MiwgcGFnZUhlaWdodCAtIHkyLCBoZWlnaHQsIHdpZHRoXTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgcm90YXRpb25cIik7XG4gICAgfVxuICB9XG4gIG9uY2VBZGRlZCgpIHt9XG4gIGlzRW1wdHkoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGVuYWJsZUVkaXRNb2RlKCkge1xuICAgIHRoaXMuI2lzSW5FZGl0TW9kZSA9IHRydWU7XG4gIH1cbiAgZGlzYWJsZUVkaXRNb2RlKCkge1xuICAgIHRoaXMuI2lzSW5FZGl0TW9kZSA9IGZhbHNlO1xuICB9XG4gIGlzSW5FZGl0TW9kZSgpIHtcbiAgICByZXR1cm4gdGhpcy4jaXNJbkVkaXRNb2RlO1xuICB9XG4gIHNob3VsZEdldEtleWJvYXJkRXZlbnRzKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBuZWVkc1RvQmVSZWJ1aWx0KCkge1xuICAgIHJldHVybiB0aGlzLmRpdiAmJiAhdGhpcy5pc0F0dGFjaGVkVG9ET007XG4gIH1cbiAgcmVidWlsZCgpIHtcbiAgICB0aGlzLmRpdj8uYWRkRXZlbnRMaXN0ZW5lcihcImZvY3VzaW5cIiwgdGhpcy4jYm91bmRGb2N1c2luKTtcbiAgICB0aGlzLmRpdj8uYWRkRXZlbnRMaXN0ZW5lcihcImZvY3Vzb3V0XCIsIHRoaXMuI2JvdW5kRm9jdXNvdXQpO1xuICB9XG4gIHNlcmlhbGl6ZShpc0ZvckNvcHlpbmcgPSBmYWxzZSwgY29udGV4dCA9IG51bGwpIHtcbiAgICAoMCwgX3V0aWwudW5yZWFjaGFibGUpKFwiQW4gZWRpdG9yIG11c3QgYmUgc2VyaWFsaXphYmxlXCIpO1xuICB9XG4gIHN0YXRpYyBkZXNlcmlhbGl6ZShkYXRhLCBwYXJlbnQsIHVpTWFuYWdlcikge1xuICAgIGNvbnN0IGVkaXRvciA9IG5ldyB0aGlzLnByb3RvdHlwZS5jb25zdHJ1Y3Rvcih7XG4gICAgICBwYXJlbnQsXG4gICAgICBpZDogcGFyZW50LmdldE5leHRJZCgpLFxuICAgICAgdWlNYW5hZ2VyXG4gICAgfSk7XG4gICAgZWRpdG9yLnJvdGF0aW9uID0gZGF0YS5yb3RhdGlvbjtcbiAgICBjb25zdCBbcGFnZVdpZHRoLCBwYWdlSGVpZ2h0XSA9IGVkaXRvci5wYWdlRGltZW5zaW9ucztcbiAgICBjb25zdCBbeCwgeSwgd2lkdGgsIGhlaWdodF0gPSBlZGl0b3IuZ2V0UmVjdEluQ3VycmVudENvb3JkcyhkYXRhLnJlY3QsIHBhZ2VIZWlnaHQpO1xuICAgIGVkaXRvci54ID0geCAvIHBhZ2VXaWR0aDtcbiAgICBlZGl0b3IueSA9IHkgLyBwYWdlSGVpZ2h0O1xuICAgIGVkaXRvci53aWR0aCA9IHdpZHRoIC8gcGFnZVdpZHRoO1xuICAgIGVkaXRvci5oZWlnaHQgPSBoZWlnaHQgLyBwYWdlSGVpZ2h0O1xuICAgIHJldHVybiBlZGl0b3I7XG4gIH1cbiAgcmVtb3ZlKCkge1xuICAgIHRoaXMuZGl2LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJmb2N1c2luXCIsIHRoaXMuI2JvdW5kRm9jdXNpbik7XG4gICAgdGhpcy5kaXYucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImZvY3Vzb3V0XCIsIHRoaXMuI2JvdW5kRm9jdXNvdXQpO1xuICAgIGlmICghdGhpcy5pc0VtcHR5KCkpIHtcbiAgICAgIHRoaXMuY29tbWl0KCk7XG4gICAgfVxuICAgIGlmICh0aGlzLnBhcmVudCkge1xuICAgICAgdGhpcy5wYXJlbnQucmVtb3ZlKHRoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl91aU1hbmFnZXIucmVtb3ZlRWRpdG9yKHRoaXMpO1xuICAgIH1cbiAgICB0aGlzLiNhbHRUZXh0QnV0dG9uPy5yZW1vdmUoKTtcbiAgICB0aGlzLiNhbHRUZXh0QnV0dG9uID0gbnVsbDtcbiAgICB0aGlzLiNhbHRUZXh0VG9vbHRpcCA9IG51bGw7XG4gIH1cbiAgZ2V0IGlzUmVzaXphYmxlKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBtYWtlUmVzaXphYmxlKCkge1xuICAgIGlmICh0aGlzLmlzUmVzaXphYmxlKSB7XG4gICAgICB0aGlzLiNjcmVhdGVSZXNpemVycygpO1xuICAgICAgdGhpcy4jcmVzaXplcnNEaXYuY2xhc3NMaXN0LnJlbW92ZShcImhpZGRlblwiKTtcbiAgICB9XG4gIH1cbiAgc2VsZWN0KCkge1xuICAgIHRoaXMubWFrZVJlc2l6YWJsZSgpO1xuICAgIHRoaXMuZGl2Py5jbGFzc0xpc3QuYWRkKFwic2VsZWN0ZWRFZGl0b3JcIik7XG4gIH1cbiAgdW5zZWxlY3QoKSB7XG4gICAgdGhpcy4jcmVzaXplcnNEaXY/LmNsYXNzTGlzdC5hZGQoXCJoaWRkZW5cIik7XG4gICAgdGhpcy5kaXY/LmNsYXNzTGlzdC5yZW1vdmUoXCJzZWxlY3RlZEVkaXRvclwiKTtcbiAgICBpZiAodGhpcy5kaXY/LmNvbnRhaW5zKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpKSB7XG4gICAgICB0aGlzLl91aU1hbmFnZXIuY3VycmVudExheWVyLmRpdi5mb2N1cygpO1xuICAgIH1cbiAgfVxuICB1cGRhdGVQYXJhbXModHlwZSwgdmFsdWUpIHt9XG4gIGRpc2FibGVFZGl0aW5nKCkge1xuICAgIGlmICh0aGlzLiNhbHRUZXh0QnV0dG9uKSB7XG4gICAgICB0aGlzLiNhbHRUZXh0QnV0dG9uLmhpZGRlbiA9IHRydWU7XG4gICAgfVxuICB9XG4gIGVuYWJsZUVkaXRpbmcoKSB7XG4gICAgaWYgKHRoaXMuI2FsdFRleHRCdXR0b24pIHtcbiAgICAgIHRoaXMuI2FsdFRleHRCdXR0b24uaGlkZGVuID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIGVudGVySW5FZGl0TW9kZSgpIHt9XG4gIGdldCBjb250ZW50RGl2KCkge1xuICAgIHJldHVybiB0aGlzLmRpdjtcbiAgfVxuICBnZXQgaXNFZGl0aW5nKCkge1xuICAgIHJldHVybiB0aGlzLiNpc0VkaXRpbmc7XG4gIH1cbiAgc2V0IGlzRWRpdGluZyh2YWx1ZSkge1xuICAgIHRoaXMuI2lzRWRpdGluZyA9IHZhbHVlO1xuICAgIGlmICghdGhpcy5wYXJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICB0aGlzLnBhcmVudC5zZXRTZWxlY3RlZCh0aGlzKTtcbiAgICAgIHRoaXMucGFyZW50LnNldEFjdGl2ZUVkaXRvcih0aGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wYXJlbnQuc2V0QWN0aXZlRWRpdG9yKG51bGwpO1xuICAgIH1cbiAgfVxuICBzZXRBc3BlY3RSYXRpbyh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgdGhpcy4ja2VlcEFzcGVjdFJhdGlvID0gdHJ1ZTtcbiAgICBjb25zdCBhc3BlY3RSYXRpbyA9IHdpZHRoIC8gaGVpZ2h0O1xuICAgIGNvbnN0IHtcbiAgICAgIHN0eWxlXG4gICAgfSA9IHRoaXMuZGl2O1xuICAgIHN0eWxlLmFzcGVjdFJhdGlvID0gYXNwZWN0UmF0aW87XG4gICAgc3R5bGUuaGVpZ2h0ID0gXCJhdXRvXCI7XG4gIH1cbiAgc3RhdGljIGdldCBNSU5fU0laRSgpIHtcbiAgICByZXR1cm4gMTY7XG4gIH1cbn1cbmV4cG9ydHMuQW5ub3RhdGlvbkVkaXRvciA9IEFubm90YXRpb25FZGl0b3I7XG5jbGFzcyBGYWtlRWRpdG9yIGV4dGVuZHMgQW5ub3RhdGlvbkVkaXRvciB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtcykge1xuICAgIHN1cGVyKHBhcmFtcyk7XG4gICAgdGhpcy5hbm5vdGF0aW9uRWxlbWVudElkID0gcGFyYW1zLmFubm90YXRpb25FbGVtZW50SWQ7XG4gICAgdGhpcy5kZWxldGVkID0gdHJ1ZTtcbiAgfVxuICBzZXJpYWxpemUoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlkOiB0aGlzLmFubm90YXRpb25FbGVtZW50SWQsXG4gICAgICBkZWxldGVkOiB0cnVlLFxuICAgICAgcGFnZUluZGV4OiB0aGlzLnBhZ2VJbmRleFxuICAgIH07XG4gIH1cbn1cblxuLyoqKi8gfSksXG4vKiA1ICovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSA9PiB7XG5cblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5leHBvcnRzLktleWJvYXJkTWFuYWdlciA9IGV4cG9ydHMuQ29tbWFuZE1hbmFnZXIgPSBleHBvcnRzLkNvbG9yTWFuYWdlciA9IGV4cG9ydHMuQW5ub3RhdGlvbkVkaXRvclVJTWFuYWdlciA9IHZvaWQgMDtcbmV4cG9ydHMuYmluZEV2ZW50cyA9IGJpbmRFdmVudHM7XG5leHBvcnRzLm9wYWNpdHlUb0hleCA9IG9wYWNpdHlUb0hleDtcbnZhciBfdXRpbCA9IF9fd19wZGZqc19yZXF1aXJlX18oMSk7XG52YXIgX2Rpc3BsYXlfdXRpbHMgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDYpO1xuZnVuY3Rpb24gYmluZEV2ZW50cyhvYmosIGVsZW1lbnQsIG5hbWVzKSB7XG4gIGZvciAoY29uc3QgbmFtZSBvZiBuYW1lcykge1xuICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihuYW1lLCBvYmpbbmFtZV0uYmluZChvYmopKTtcbiAgfVxufVxuZnVuY3Rpb24gb3BhY2l0eVRvSGV4KG9wYWNpdHkpIHtcbiAgcmV0dXJuIE1hdGgucm91bmQoTWF0aC5taW4oMjU1LCBNYXRoLm1heCgxLCAyNTUgKiBvcGFjaXR5KSkpLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCBcIjBcIik7XG59XG5jbGFzcyBJZE1hbmFnZXIge1xuICAjaWQgPSAwO1xuICBnZXRJZCgpIHtcbiAgICByZXR1cm4gYCR7X3V0aWwuQW5ub3RhdGlvbkVkaXRvclByZWZpeH0ke3RoaXMuI2lkKyt9YDtcbiAgfVxufVxuY2xhc3MgSW1hZ2VNYW5hZ2VyIHtcbiAgI2Jhc2VJZCA9ICgwLCBfdXRpbC5nZXRVdWlkKSgpO1xuICAjaWQgPSAwO1xuICAjY2FjaGUgPSBudWxsO1xuICBzdGF0aWMgZ2V0IF9pc1NWR0ZpdHRpbmdDYW52YXMoKSB7XG4gICAgY29uc3Qgc3ZnID0gYGRhdGE6aW1hZ2Uvc3ZnK3htbDtjaGFyc2V0PVVURi04LDxzdmcgdmlld0JveD1cIjAgMCAxIDFcIiB3aWR0aD1cIjFcIiBoZWlnaHQ9XCIxXCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiPjxyZWN0IHdpZHRoPVwiMVwiIGhlaWdodD1cIjFcIiBzdHlsZT1cImZpbGw6cmVkO1wiLz48L3N2Zz5gO1xuICAgIGNvbnN0IGNhbnZhcyA9IG5ldyBPZmZzY3JlZW5DYW52YXMoMSwgMyk7XG4gICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICBjb25zdCBpbWFnZSA9IG5ldyBJbWFnZSgpO1xuICAgIGltYWdlLnNyYyA9IHN2ZztcbiAgICBjb25zdCBwcm9taXNlID0gaW1hZ2UuZGVjb2RlKCkudGhlbigoKSA9PiB7XG4gICAgICBjdHguZHJhd0ltYWdlKGltYWdlLCAwLCAwLCAxLCAxLCAwLCAwLCAxLCAzKTtcbiAgICAgIHJldHVybiBuZXcgVWludDMyQXJyYXkoY3R4LmdldEltYWdlRGF0YSgwLCAwLCAxLCAxKS5kYXRhLmJ1ZmZlcilbMF0gPT09IDA7XG4gICAgfSk7XG4gICAgcmV0dXJuICgwLCBfdXRpbC5zaGFkb3cpKHRoaXMsIFwiX2lzU1ZHRml0dGluZ0NhbnZhc1wiLCBwcm9taXNlKTtcbiAgfVxuICBhc3luYyAjZ2V0KGtleSwgcmF3RGF0YSkge1xuICAgIHRoaXMuI2NhY2hlIHx8PSBuZXcgTWFwKCk7XG4gICAgbGV0IGRhdGEgPSB0aGlzLiNjYWNoZS5nZXQoa2V5KTtcbiAgICBpZiAoZGF0YSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChkYXRhPy5iaXRtYXApIHtcbiAgICAgIGRhdGEucmVmQ291bnRlciArPSAxO1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBkYXRhIHx8PSB7XG4gICAgICAgIGJpdG1hcDogbnVsbCxcbiAgICAgICAgaWQ6IGBpbWFnZV8ke3RoaXMuI2Jhc2VJZH1fJHt0aGlzLiNpZCsrfWAsXG4gICAgICAgIHJlZkNvdW50ZXI6IDAsXG4gICAgICAgIGlzU3ZnOiBmYWxzZVxuICAgICAgfTtcbiAgICAgIGxldCBpbWFnZTtcbiAgICAgIGlmICh0eXBlb2YgcmF3RGF0YSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBkYXRhLnVybCA9IHJhd0RhdGE7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2gocmF3RGF0YSk7XG4gICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocmVzcG9uc2Uuc3RhdHVzVGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgaW1hZ2UgPSBhd2FpdCByZXNwb25zZS5ibG9iKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbWFnZSA9IGRhdGEuZmlsZSA9IHJhd0RhdGE7XG4gICAgICB9XG4gICAgICBpZiAoaW1hZ2UudHlwZSA9PT0gXCJpbWFnZS9zdmcreG1sXCIpIHtcbiAgICAgICAgY29uc3QgbXVzdFJlbW92ZUFzcGVjdFJhdGlvUHJvbWlzZSA9IEltYWdlTWFuYWdlci5faXNTVkdGaXR0aW5nQ2FudmFzO1xuICAgICAgICBjb25zdCBmaWxlUmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICAgICAgY29uc3QgaW1hZ2VFbGVtZW50ID0gbmV3IEltYWdlKCk7XG4gICAgICAgIGNvbnN0IGltYWdlUHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICBpbWFnZUVsZW1lbnQub25sb2FkID0gKCkgPT4ge1xuICAgICAgICAgICAgZGF0YS5iaXRtYXAgPSBpbWFnZUVsZW1lbnQ7XG4gICAgICAgICAgICBkYXRhLmlzU3ZnID0gdHJ1ZTtcbiAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIGZpbGVSZWFkZXIub25sb2FkID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdXJsID0gZGF0YS5zdmdVcmwgPSBmaWxlUmVhZGVyLnJlc3VsdDtcbiAgICAgICAgICAgIGltYWdlRWxlbWVudC5zcmMgPSAoYXdhaXQgbXVzdFJlbW92ZUFzcGVjdFJhdGlvUHJvbWlzZSkgPyBgJHt1cmx9I3N2Z1ZpZXcocHJlc2VydmVBc3BlY3RSYXRpbyhub25lKSlgIDogdXJsO1xuICAgICAgICAgIH07XG4gICAgICAgICAgaW1hZ2VFbGVtZW50Lm9uZXJyb3IgPSBmaWxlUmVhZGVyLm9uZXJyb3IgPSByZWplY3Q7XG4gICAgICAgIH0pO1xuICAgICAgICBmaWxlUmVhZGVyLnJlYWRBc0RhdGFVUkwoaW1hZ2UpO1xuICAgICAgICBhd2FpdCBpbWFnZVByb21pc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkYXRhLmJpdG1hcCA9IGF3YWl0IGNyZWF0ZUltYWdlQml0bWFwKGltYWdlKTtcbiAgICAgIH1cbiAgICAgIGRhdGEucmVmQ291bnRlciA9IDE7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICAgIGRhdGEgPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLiNjYWNoZS5zZXQoa2V5LCBkYXRhKTtcbiAgICBpZiAoZGF0YSkge1xuICAgICAgdGhpcy4jY2FjaGUuc2V0KGRhdGEuaWQsIGRhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuICBhc3luYyBnZXRGcm9tRmlsZShmaWxlKSB7XG4gICAgY29uc3Qge1xuICAgICAgbGFzdE1vZGlmaWVkLFxuICAgICAgbmFtZSxcbiAgICAgIHNpemUsXG4gICAgICB0eXBlXG4gICAgfSA9IGZpbGU7XG4gICAgcmV0dXJuIHRoaXMuI2dldChgJHtsYXN0TW9kaWZpZWR9XyR7bmFtZX1fJHtzaXplfV8ke3R5cGV9YCwgZmlsZSk7XG4gIH1cbiAgYXN5bmMgZ2V0RnJvbVVybCh1cmwpIHtcbiAgICByZXR1cm4gdGhpcy4jZ2V0KHVybCwgdXJsKTtcbiAgfVxuICBhc3luYyBnZXRGcm9tSWQoaWQpIHtcbiAgICB0aGlzLiNjYWNoZSB8fD0gbmV3IE1hcCgpO1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLiNjYWNoZS5nZXQoaWQpO1xuICAgIGlmICghZGF0YSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChkYXRhLmJpdG1hcCkge1xuICAgICAgZGF0YS5yZWZDb3VudGVyICs9IDE7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgaWYgKGRhdGEuZmlsZSkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0RnJvbUZpbGUoZGF0YS5maWxlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZ2V0RnJvbVVybChkYXRhLnVybCk7XG4gIH1cbiAgZ2V0U3ZnVXJsKGlkKSB7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMuI2NhY2hlLmdldChpZCk7XG4gICAgaWYgKCFkYXRhPy5pc1N2Zykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBkYXRhLnN2Z1VybDtcbiAgfVxuICBkZWxldGVJZChpZCkge1xuICAgIHRoaXMuI2NhY2hlIHx8PSBuZXcgTWFwKCk7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMuI2NhY2hlLmdldChpZCk7XG4gICAgaWYgKCFkYXRhKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGRhdGEucmVmQ291bnRlciAtPSAxO1xuICAgIGlmIChkYXRhLnJlZkNvdW50ZXIgIT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZGF0YS5iaXRtYXAgPSBudWxsO1xuICB9XG4gIGlzVmFsaWRJZChpZCkge1xuICAgIHJldHVybiBpZC5zdGFydHNXaXRoKGBpbWFnZV8ke3RoaXMuI2Jhc2VJZH1fYCk7XG4gIH1cbn1cbmNsYXNzIENvbW1hbmRNYW5hZ2VyIHtcbiAgI2NvbW1hbmRzID0gW107XG4gICNsb2NrZWQgPSBmYWxzZTtcbiAgI21heFNpemU7XG4gICNwb3NpdGlvbiA9IC0xO1xuICBjb25zdHJ1Y3RvcihtYXhTaXplID0gMTI4KSB7XG4gICAgdGhpcy4jbWF4U2l6ZSA9IG1heFNpemU7XG4gIH1cbiAgYWRkKHtcbiAgICBjbWQsXG4gICAgdW5kbyxcbiAgICBtdXN0RXhlYyxcbiAgICB0eXBlID0gTmFOLFxuICAgIG92ZXJ3cml0ZUlmU2FtZVR5cGUgPSBmYWxzZSxcbiAgICBrZWVwVW5kbyA9IGZhbHNlXG4gIH0pIHtcbiAgICBpZiAobXVzdEV4ZWMpIHtcbiAgICAgIGNtZCgpO1xuICAgIH1cbiAgICBpZiAodGhpcy4jbG9ja2VkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHNhdmUgPSB7XG4gICAgICBjbWQsXG4gICAgICB1bmRvLFxuICAgICAgdHlwZVxuICAgIH07XG4gICAgaWYgKHRoaXMuI3Bvc2l0aW9uID09PSAtMSkge1xuICAgICAgaWYgKHRoaXMuI2NvbW1hbmRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhpcy4jY29tbWFuZHMubGVuZ3RoID0gMDtcbiAgICAgIH1cbiAgICAgIHRoaXMuI3Bvc2l0aW9uID0gMDtcbiAgICAgIHRoaXMuI2NvbW1hbmRzLnB1c2goc2F2ZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChvdmVyd3JpdGVJZlNhbWVUeXBlICYmIHRoaXMuI2NvbW1hbmRzW3RoaXMuI3Bvc2l0aW9uXS50eXBlID09PSB0eXBlKSB7XG4gICAgICBpZiAoa2VlcFVuZG8pIHtcbiAgICAgICAgc2F2ZS51bmRvID0gdGhpcy4jY29tbWFuZHNbdGhpcy4jcG9zaXRpb25dLnVuZG87XG4gICAgICB9XG4gICAgICB0aGlzLiNjb21tYW5kc1t0aGlzLiNwb3NpdGlvbl0gPSBzYXZlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBuZXh0ID0gdGhpcy4jcG9zaXRpb24gKyAxO1xuICAgIGlmIChuZXh0ID09PSB0aGlzLiNtYXhTaXplKSB7XG4gICAgICB0aGlzLiNjb21tYW5kcy5zcGxpY2UoMCwgMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuI3Bvc2l0aW9uID0gbmV4dDtcbiAgICAgIGlmIChuZXh0IDwgdGhpcy4jY29tbWFuZHMubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuI2NvbW1hbmRzLnNwbGljZShuZXh0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy4jY29tbWFuZHMucHVzaChzYXZlKTtcbiAgfVxuICB1bmRvKCkge1xuICAgIGlmICh0aGlzLiNwb3NpdGlvbiA9PT0gLTEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jbG9ja2VkID0gdHJ1ZTtcbiAgICB0aGlzLiNjb21tYW5kc1t0aGlzLiNwb3NpdGlvbl0udW5kbygpO1xuICAgIHRoaXMuI2xvY2tlZCA9IGZhbHNlO1xuICAgIHRoaXMuI3Bvc2l0aW9uIC09IDE7XG4gIH1cbiAgcmVkbygpIHtcbiAgICBpZiAodGhpcy4jcG9zaXRpb24gPCB0aGlzLiNjb21tYW5kcy5sZW5ndGggLSAxKSB7XG4gICAgICB0aGlzLiNwb3NpdGlvbiArPSAxO1xuICAgICAgdGhpcy4jbG9ja2VkID0gdHJ1ZTtcbiAgICAgIHRoaXMuI2NvbW1hbmRzW3RoaXMuI3Bvc2l0aW9uXS5jbWQoKTtcbiAgICAgIHRoaXMuI2xvY2tlZCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICBoYXNTb21ldGhpbmdUb1VuZG8oKSB7XG4gICAgcmV0dXJuIHRoaXMuI3Bvc2l0aW9uICE9PSAtMTtcbiAgfVxuICBoYXNTb21ldGhpbmdUb1JlZG8oKSB7XG4gICAgcmV0dXJuIHRoaXMuI3Bvc2l0aW9uIDwgdGhpcy4jY29tbWFuZHMubGVuZ3RoIC0gMTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuI2NvbW1hbmRzID0gbnVsbDtcbiAgfVxufVxuZXhwb3J0cy5Db21tYW5kTWFuYWdlciA9IENvbW1hbmRNYW5hZ2VyO1xuY2xhc3MgS2V5Ym9hcmRNYW5hZ2VyIHtcbiAgY29uc3RydWN0b3IoY2FsbGJhY2tzKSB7XG4gICAgdGhpcy5idWZmZXIgPSBbXTtcbiAgICB0aGlzLmNhbGxiYWNrcyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLmFsbEtleXMgPSBuZXcgU2V0KCk7XG4gICAgY29uc3Qge1xuICAgICAgaXNNYWNcbiAgICB9ID0gX3V0aWwuRmVhdHVyZVRlc3QucGxhdGZvcm07XG4gICAgZm9yIChjb25zdCBba2V5cywgY2FsbGJhY2ssIG9wdGlvbnMgPSB7fV0gb2YgY2FsbGJhY2tzKSB7XG4gICAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgICAgIGNvbnN0IGlzTWFjS2V5ID0ga2V5LnN0YXJ0c1dpdGgoXCJtYWMrXCIpO1xuICAgICAgICBpZiAoaXNNYWMgJiYgaXNNYWNLZXkpIHtcbiAgICAgICAgICB0aGlzLmNhbGxiYWNrcy5zZXQoa2V5LnNsaWNlKDQpLCB7XG4gICAgICAgICAgICBjYWxsYmFjayxcbiAgICAgICAgICAgIG9wdGlvbnNcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0aGlzLmFsbEtleXMuYWRkKGtleS5zcGxpdChcIitcIikuYXQoLTEpKTtcbiAgICAgICAgfSBlbHNlIGlmICghaXNNYWMgJiYgIWlzTWFjS2V5KSB7XG4gICAgICAgICAgdGhpcy5jYWxsYmFja3Muc2V0KGtleSwge1xuICAgICAgICAgICAgY2FsbGJhY2ssXG4gICAgICAgICAgICBvcHRpb25zXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGhpcy5hbGxLZXlzLmFkZChrZXkuc3BsaXQoXCIrXCIpLmF0KC0xKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgI3NlcmlhbGl6ZShldmVudCkge1xuICAgIGlmIChldmVudC5hbHRLZXkpIHtcbiAgICAgIHRoaXMuYnVmZmVyLnB1c2goXCJhbHRcIik7XG4gICAgfVxuICAgIGlmIChldmVudC5jdHJsS2V5KSB7XG4gICAgICB0aGlzLmJ1ZmZlci5wdXNoKFwiY3RybFwiKTtcbiAgICB9XG4gICAgaWYgKGV2ZW50Lm1ldGFLZXkpIHtcbiAgICAgIHRoaXMuYnVmZmVyLnB1c2goXCJtZXRhXCIpO1xuICAgIH1cbiAgICBpZiAoZXZlbnQuc2hpZnRLZXkpIHtcbiAgICAgIHRoaXMuYnVmZmVyLnB1c2goXCJzaGlmdFwiKTtcbiAgICB9XG4gICAgdGhpcy5idWZmZXIucHVzaChldmVudC5rZXkpO1xuICAgIGNvbnN0IHN0ciA9IHRoaXMuYnVmZmVyLmpvaW4oXCIrXCIpO1xuICAgIHRoaXMuYnVmZmVyLmxlbmd0aCA9IDA7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxuICBleGVjKHNlbGYsIGV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLmFsbEtleXMuaGFzKGV2ZW50LmtleSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaW5mbyA9IHRoaXMuY2FsbGJhY2tzLmdldCh0aGlzLiNzZXJpYWxpemUoZXZlbnQpKTtcbiAgICBpZiAoIWluZm8pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgY2FsbGJhY2ssXG4gICAgICBvcHRpb25zOiB7XG4gICAgICAgIGJ1YmJsZXMgPSBmYWxzZSxcbiAgICAgICAgYXJncyA9IFtdLFxuICAgICAgICBjaGVja2VyID0gbnVsbFxuICAgICAgfVxuICAgIH0gPSBpbmZvO1xuICAgIGlmIChjaGVja2VyICYmICFjaGVja2VyKHNlbGYsIGV2ZW50KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjYWxsYmFjay5iaW5kKHNlbGYsIC4uLmFyZ3MpKCk7XG4gICAgaWYgKCFidWJibGVzKSB7XG4gICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICB9XG59XG5leHBvcnRzLktleWJvYXJkTWFuYWdlciA9IEtleWJvYXJkTWFuYWdlcjtcbmNsYXNzIENvbG9yTWFuYWdlciB7XG4gIHN0YXRpYyBfY29sb3JzTWFwcGluZyA9IG5ldyBNYXAoW1tcIkNhbnZhc1RleHRcIiwgWzAsIDAsIDBdXSwgW1wiQ2FudmFzXCIsIFsyNTUsIDI1NSwgMjU1XV1dKTtcbiAgZ2V0IF9jb2xvcnMoKSB7XG4gICAgY29uc3QgY29sb3JzID0gbmV3IE1hcChbW1wiQ2FudmFzVGV4dFwiLCBudWxsXSwgW1wiQ2FudmFzXCIsIG51bGxdXSk7XG4gICAgKDAsIF9kaXNwbGF5X3V0aWxzLmdldENvbG9yVmFsdWVzKShjb2xvcnMpO1xuICAgIHJldHVybiAoMCwgX3V0aWwuc2hhZG93KSh0aGlzLCBcIl9jb2xvcnNcIiwgY29sb3JzKTtcbiAgfVxuICBjb252ZXJ0KGNvbG9yKSB7XG4gICAgY29uc3QgcmdiID0gKDAsIF9kaXNwbGF5X3V0aWxzLmdldFJHQikoY29sb3IpO1xuICAgIGlmICghd2luZG93Lm1hdGNoTWVkaWEoXCIoZm9yY2VkLWNvbG9yczogYWN0aXZlKVwiKS5tYXRjaGVzKSB7XG4gICAgICByZXR1cm4gcmdiO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IFtuYW1lLCBSR0JdIG9mIHRoaXMuX2NvbG9ycykge1xuICAgICAgaWYgKFJHQi5ldmVyeSgoeCwgaSkgPT4geCA9PT0gcmdiW2ldKSkge1xuICAgICAgICByZXR1cm4gQ29sb3JNYW5hZ2VyLl9jb2xvcnNNYXBwaW5nLmdldChuYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJnYjtcbiAgfVxuICBnZXRIZXhDb2RlKG5hbWUpIHtcbiAgICBjb25zdCByZ2IgPSB0aGlzLl9jb2xvcnMuZ2V0KG5hbWUpO1xuICAgIGlmICghcmdiKSB7XG4gICAgICByZXR1cm4gbmFtZTtcbiAgICB9XG4gICAgcmV0dXJuIF91dGlsLlV0aWwubWFrZUhleENvbG9yKC4uLnJnYik7XG4gIH1cbn1cbmV4cG9ydHMuQ29sb3JNYW5hZ2VyID0gQ29sb3JNYW5hZ2VyO1xuY2xhc3MgQW5ub3RhdGlvbkVkaXRvclVJTWFuYWdlciB7XG4gICNhY3RpdmVFZGl0b3IgPSBudWxsO1xuICAjYWxsRWRpdG9ycyA9IG5ldyBNYXAoKTtcbiAgI2FsbExheWVycyA9IG5ldyBNYXAoKTtcbiAgI2FsdFRleHRNYW5hZ2VyID0gbnVsbDtcbiAgI2Fubm90YXRpb25TdG9yYWdlID0gbnVsbDtcbiAgI2NvbW1hbmRNYW5hZ2VyID0gbmV3IENvbW1hbmRNYW5hZ2VyKCk7XG4gICNjdXJyZW50UGFnZUluZGV4ID0gMDtcbiAgI2RlbGV0ZWRBbm5vdGF0aW9uc0VsZW1lbnRJZHMgPSBuZXcgU2V0KCk7XG4gICNkcmFnZ2luZ0VkaXRvcnMgPSBudWxsO1xuICAjZWRpdG9yVHlwZXMgPSBudWxsO1xuICAjZWRpdG9yc1RvUmVzY2FsZSA9IG5ldyBTZXQoKTtcbiAgI2ZpbHRlckZhY3RvcnkgPSBudWxsO1xuICAjaWRNYW5hZ2VyID0gbmV3IElkTWFuYWdlcigpO1xuICAjaXNFbmFibGVkID0gZmFsc2U7XG4gICNpc1dhaXRpbmcgPSBmYWxzZTtcbiAgI2xhc3RBY3RpdmVFbGVtZW50ID0gbnVsbDtcbiAgI21vZGUgPSBfdXRpbC5Bbm5vdGF0aW9uRWRpdG9yVHlwZS5OT05FO1xuICAjc2VsZWN0ZWRFZGl0b3JzID0gbmV3IFNldCgpO1xuICAjcGFnZUNvbG9ycyA9IG51bGw7XG4gICNib3VuZEJsdXIgPSB0aGlzLmJsdXIuYmluZCh0aGlzKTtcbiAgI2JvdW5kRm9jdXMgPSB0aGlzLmZvY3VzLmJpbmQodGhpcyk7XG4gICNib3VuZENvcHkgPSB0aGlzLmNvcHkuYmluZCh0aGlzKTtcbiAgI2JvdW5kQ3V0ID0gdGhpcy5jdXQuYmluZCh0aGlzKTtcbiAgI2JvdW5kUGFzdGUgPSB0aGlzLnBhc3RlLmJpbmQodGhpcyk7XG4gICNib3VuZEtleWRvd24gPSB0aGlzLmtleWRvd24uYmluZCh0aGlzKTtcbiAgI2JvdW5kT25FZGl0aW5nQWN0aW9uID0gdGhpcy5vbkVkaXRpbmdBY3Rpb24uYmluZCh0aGlzKTtcbiAgI2JvdW5kT25QYWdlQ2hhbmdpbmcgPSB0aGlzLm9uUGFnZUNoYW5naW5nLmJpbmQodGhpcyk7XG4gICNib3VuZE9uU2NhbGVDaGFuZ2luZyA9IHRoaXMub25TY2FsZUNoYW5naW5nLmJpbmQodGhpcyk7XG4gICNib3VuZE9uUm90YXRpb25DaGFuZ2luZyA9IHRoaXMub25Sb3RhdGlvbkNoYW5naW5nLmJpbmQodGhpcyk7XG4gICNwcmV2aW91c1N0YXRlcyA9IHtcbiAgICBpc0VkaXRpbmc6IGZhbHNlLFxuICAgIGlzRW1wdHk6IHRydWUsXG4gICAgaGFzU29tZXRoaW5nVG9VbmRvOiBmYWxzZSxcbiAgICBoYXNTb21ldGhpbmdUb1JlZG86IGZhbHNlLFxuICAgIGhhc1NlbGVjdGVkRWRpdG9yOiBmYWxzZVxuICB9O1xuICAjdHJhbnNsYXRpb24gPSBbMCwgMF07XG4gICN0cmFuc2xhdGlvblRpbWVvdXRJZCA9IG51bGw7XG4gICNjb250YWluZXIgPSBudWxsO1xuICAjdmlld2VyID0gbnVsbDtcbiAgc3RhdGljIFRSQU5TTEFURV9TTUFMTCA9IDE7XG4gIHN0YXRpYyBUUkFOU0xBVEVfQklHID0gMTA7XG4gIHN0YXRpYyBnZXQgX2tleWJvYXJkTWFuYWdlcigpIHtcbiAgICBjb25zdCBwcm90byA9IEFubm90YXRpb25FZGl0b3JVSU1hbmFnZXIucHJvdG90eXBlO1xuICAgIGNvbnN0IGFycm93Q2hlY2tlciA9IHNlbGYgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBhY3RpdmVFbGVtZW50XG4gICAgICB9ID0gZG9jdW1lbnQ7XG4gICAgICByZXR1cm4gYWN0aXZlRWxlbWVudCAmJiBzZWxmLiNjb250YWluZXIuY29udGFpbnMoYWN0aXZlRWxlbWVudCkgJiYgc2VsZi5oYXNTb21ldGhpbmdUb0NvbnRyb2woKTtcbiAgICB9O1xuICAgIGNvbnN0IHNtYWxsID0gdGhpcy5UUkFOU0xBVEVfU01BTEw7XG4gICAgY29uc3QgYmlnID0gdGhpcy5UUkFOU0xBVEVfQklHO1xuICAgIHJldHVybiAoMCwgX3V0aWwuc2hhZG93KSh0aGlzLCBcIl9rZXlib2FyZE1hbmFnZXJcIiwgbmV3IEtleWJvYXJkTWFuYWdlcihbW1tcImN0cmwrYVwiLCBcIm1hYyttZXRhK2FcIl0sIHByb3RvLnNlbGVjdEFsbF0sIFtbXCJjdHJsK3pcIiwgXCJtYWMrbWV0YSt6XCJdLCBwcm90by51bmRvXSwgW1tcImN0cmwreVwiLCBcImN0cmwrc2hpZnQrelwiLCBcIm1hYyttZXRhK3NoaWZ0K3pcIiwgXCJjdHJsK3NoaWZ0K1pcIiwgXCJtYWMrbWV0YStzaGlmdCtaXCJdLCBwcm90by5yZWRvXSwgW1tcIkJhY2tzcGFjZVwiLCBcImFsdCtCYWNrc3BhY2VcIiwgXCJjdHJsK0JhY2tzcGFjZVwiLCBcInNoaWZ0K0JhY2tzcGFjZVwiLCBcIm1hYytCYWNrc3BhY2VcIiwgXCJtYWMrYWx0K0JhY2tzcGFjZVwiLCBcIm1hYytjdHJsK0JhY2tzcGFjZVwiLCBcIkRlbGV0ZVwiLCBcImN0cmwrRGVsZXRlXCIsIFwic2hpZnQrRGVsZXRlXCIsIFwibWFjK0RlbGV0ZVwiXSwgcHJvdG8uZGVsZXRlXSwgW1tcIkVzY2FwZVwiLCBcIm1hYytFc2NhcGVcIl0sIHByb3RvLnVuc2VsZWN0QWxsXSwgW1tcIkFycm93TGVmdFwiLCBcIm1hYytBcnJvd0xlZnRcIl0sIHByb3RvLnRyYW5zbGF0ZVNlbGVjdGVkRWRpdG9ycywge1xuICAgICAgYXJnczogWy1zbWFsbCwgMF0sXG4gICAgICBjaGVja2VyOiBhcnJvd0NoZWNrZXJcbiAgICB9XSwgW1tcImN0cmwrQXJyb3dMZWZ0XCIsIFwibWFjK3NoaWZ0K0Fycm93TGVmdFwiXSwgcHJvdG8udHJhbnNsYXRlU2VsZWN0ZWRFZGl0b3JzLCB7XG4gICAgICBhcmdzOiBbLWJpZywgMF0sXG4gICAgICBjaGVja2VyOiBhcnJvd0NoZWNrZXJcbiAgICB9XSwgW1tcIkFycm93UmlnaHRcIiwgXCJtYWMrQXJyb3dSaWdodFwiXSwgcHJvdG8udHJhbnNsYXRlU2VsZWN0ZWRFZGl0b3JzLCB7XG4gICAgICBhcmdzOiBbc21hbGwsIDBdLFxuICAgICAgY2hlY2tlcjogYXJyb3dDaGVja2VyXG4gICAgfV0sIFtbXCJjdHJsK0Fycm93UmlnaHRcIiwgXCJtYWMrc2hpZnQrQXJyb3dSaWdodFwiXSwgcHJvdG8udHJhbnNsYXRlU2VsZWN0ZWRFZGl0b3JzLCB7XG4gICAgICBhcmdzOiBbYmlnLCAwXSxcbiAgICAgIGNoZWNrZXI6IGFycm93Q2hlY2tlclxuICAgIH1dLCBbW1wiQXJyb3dVcFwiLCBcIm1hYytBcnJvd1VwXCJdLCBwcm90by50cmFuc2xhdGVTZWxlY3RlZEVkaXRvcnMsIHtcbiAgICAgIGFyZ3M6IFswLCAtc21hbGxdLFxuICAgICAgY2hlY2tlcjogYXJyb3dDaGVja2VyXG4gICAgfV0sIFtbXCJjdHJsK0Fycm93VXBcIiwgXCJtYWMrc2hpZnQrQXJyb3dVcFwiXSwgcHJvdG8udHJhbnNsYXRlU2VsZWN0ZWRFZGl0b3JzLCB7XG4gICAgICBhcmdzOiBbMCwgLWJpZ10sXG4gICAgICBjaGVja2VyOiBhcnJvd0NoZWNrZXJcbiAgICB9XSwgW1tcIkFycm93RG93blwiLCBcIm1hYytBcnJvd0Rvd25cIl0sIHByb3RvLnRyYW5zbGF0ZVNlbGVjdGVkRWRpdG9ycywge1xuICAgICAgYXJnczogWzAsIHNtYWxsXSxcbiAgICAgIGNoZWNrZXI6IGFycm93Q2hlY2tlclxuICAgIH1dLCBbW1wiY3RybCtBcnJvd0Rvd25cIiwgXCJtYWMrc2hpZnQrQXJyb3dEb3duXCJdLCBwcm90by50cmFuc2xhdGVTZWxlY3RlZEVkaXRvcnMsIHtcbiAgICAgIGFyZ3M6IFswLCBiaWddLFxuICAgICAgY2hlY2tlcjogYXJyb3dDaGVja2VyXG4gICAgfV1dKSk7XG4gIH1cbiAgY29uc3RydWN0b3IoY29udGFpbmVyLCB2aWV3ZXIsIGFsdFRleHRNYW5hZ2VyLCBldmVudEJ1cywgcGRmRG9jdW1lbnQsIHBhZ2VDb2xvcnMpIHtcbiAgICB0aGlzLiNjb250YWluZXIgPSBjb250YWluZXI7XG4gICAgdGhpcy4jdmlld2VyID0gdmlld2VyO1xuICAgIHRoaXMuI2FsdFRleHRNYW5hZ2VyID0gYWx0VGV4dE1hbmFnZXI7XG4gICAgdGhpcy5fZXZlbnRCdXMgPSBldmVudEJ1cztcbiAgICB0aGlzLl9ldmVudEJ1cy5fb24oXCJlZGl0aW5nYWN0aW9uXCIsIHRoaXMuI2JvdW5kT25FZGl0aW5nQWN0aW9uKTtcbiAgICB0aGlzLl9ldmVudEJ1cy5fb24oXCJwYWdlY2hhbmdpbmdcIiwgdGhpcy4jYm91bmRPblBhZ2VDaGFuZ2luZyk7XG4gICAgdGhpcy5fZXZlbnRCdXMuX29uKFwic2NhbGVjaGFuZ2luZ1wiLCB0aGlzLiNib3VuZE9uU2NhbGVDaGFuZ2luZyk7XG4gICAgdGhpcy5fZXZlbnRCdXMuX29uKFwicm90YXRpb25jaGFuZ2luZ1wiLCB0aGlzLiNib3VuZE9uUm90YXRpb25DaGFuZ2luZyk7XG4gICAgdGhpcy4jYW5ub3RhdGlvblN0b3JhZ2UgPSBwZGZEb2N1bWVudC5hbm5vdGF0aW9uU3RvcmFnZTtcbiAgICB0aGlzLiNmaWx0ZXJGYWN0b3J5ID0gcGRmRG9jdW1lbnQuZmlsdGVyRmFjdG9yeTtcbiAgICB0aGlzLiNwYWdlQ29sb3JzID0gcGFnZUNvbG9ycztcbiAgICB0aGlzLnZpZXdQYXJhbWV0ZXJzID0ge1xuICAgICAgcmVhbFNjYWxlOiBfZGlzcGxheV91dGlscy5QaXhlbHNQZXJJbmNoLlBERl9UT19DU1NfVU5JVFMsXG4gICAgICByb3RhdGlvbjogMFxuICAgIH07XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLiNyZW1vdmVLZXlib2FyZE1hbmFnZXIoKTtcbiAgICB0aGlzLiNyZW1vdmVGb2N1c01hbmFnZXIoKTtcbiAgICB0aGlzLl9ldmVudEJ1cy5fb2ZmKFwiZWRpdGluZ2FjdGlvblwiLCB0aGlzLiNib3VuZE9uRWRpdGluZ0FjdGlvbik7XG4gICAgdGhpcy5fZXZlbnRCdXMuX29mZihcInBhZ2VjaGFuZ2luZ1wiLCB0aGlzLiNib3VuZE9uUGFnZUNoYW5naW5nKTtcbiAgICB0aGlzLl9ldmVudEJ1cy5fb2ZmKFwic2NhbGVjaGFuZ2luZ1wiLCB0aGlzLiNib3VuZE9uU2NhbGVDaGFuZ2luZyk7XG4gICAgdGhpcy5fZXZlbnRCdXMuX29mZihcInJvdGF0aW9uY2hhbmdpbmdcIiwgdGhpcy4jYm91bmRPblJvdGF0aW9uQ2hhbmdpbmcpO1xuICAgIGZvciAoY29uc3QgbGF5ZXIgb2YgdGhpcy4jYWxsTGF5ZXJzLnZhbHVlcygpKSB7XG4gICAgICBsYXllci5kZXN0cm95KCk7XG4gICAgfVxuICAgIHRoaXMuI2FsbExheWVycy5jbGVhcigpO1xuICAgIHRoaXMuI2FsbEVkaXRvcnMuY2xlYXIoKTtcbiAgICB0aGlzLiNlZGl0b3JzVG9SZXNjYWxlLmNsZWFyKCk7XG4gICAgdGhpcy4jYWN0aXZlRWRpdG9yID0gbnVsbDtcbiAgICB0aGlzLiNzZWxlY3RlZEVkaXRvcnMuY2xlYXIoKTtcbiAgICB0aGlzLiNjb21tYW5kTWFuYWdlci5kZXN0cm95KCk7XG4gICAgdGhpcy4jYWx0VGV4dE1hbmFnZXIuZGVzdHJveSgpO1xuICB9XG4gIGdldCBoY21GaWx0ZXIoKSB7XG4gICAgcmV0dXJuICgwLCBfdXRpbC5zaGFkb3cpKHRoaXMsIFwiaGNtRmlsdGVyXCIsIHRoaXMuI3BhZ2VDb2xvcnMgPyB0aGlzLiNmaWx0ZXJGYWN0b3J5LmFkZEhDTUZpbHRlcih0aGlzLiNwYWdlQ29sb3JzLmZvcmVncm91bmQsIHRoaXMuI3BhZ2VDb2xvcnMuYmFja2dyb3VuZCkgOiBcIm5vbmVcIik7XG4gIH1cbiAgZ2V0IGRpcmVjdGlvbigpIHtcbiAgICByZXR1cm4gKDAsIF91dGlsLnNoYWRvdykodGhpcywgXCJkaXJlY3Rpb25cIiwgZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLiNjb250YWluZXIpLmRpcmVjdGlvbik7XG4gIH1cbiAgZWRpdEFsdFRleHQoZWRpdG9yKSB7XG4gICAgdGhpcy4jYWx0VGV4dE1hbmFnZXI/LmVkaXRBbHRUZXh0KHRoaXMsIGVkaXRvcik7XG4gIH1cbiAgb25QYWdlQ2hhbmdpbmcoe1xuICAgIHBhZ2VOdW1iZXJcbiAgfSkge1xuICAgIHRoaXMuI2N1cnJlbnRQYWdlSW5kZXggPSBwYWdlTnVtYmVyIC0gMTtcbiAgfVxuICBmb2N1c01haW5Db250YWluZXIoKSB7XG4gICAgdGhpcy4jY29udGFpbmVyLmZvY3VzKCk7XG4gIH1cbiAgZmluZFBhcmVudCh4LCB5KSB7XG4gICAgZm9yIChjb25zdCBsYXllciBvZiB0aGlzLiNhbGxMYXllcnMudmFsdWVzKCkpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgeDogbGF5ZXJYLFxuICAgICAgICB5OiBsYXllclksXG4gICAgICAgIHdpZHRoLFxuICAgICAgICBoZWlnaHRcbiAgICAgIH0gPSBsYXllci5kaXYuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBpZiAoeCA+PSBsYXllclggJiYgeCA8PSBsYXllclggKyB3aWR0aCAmJiB5ID49IGxheWVyWSAmJiB5IDw9IGxheWVyWSArIGhlaWdodCkge1xuICAgICAgICByZXR1cm4gbGF5ZXI7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGRpc2FibGVVc2VyU2VsZWN0KHZhbHVlID0gZmFsc2UpIHtcbiAgICB0aGlzLiN2aWV3ZXIuY2xhc3NMaXN0LnRvZ2dsZShcIm5vVXNlclNlbGVjdFwiLCB2YWx1ZSk7XG4gIH1cbiAgYWRkU2hvdWxkUmVzY2FsZShlZGl0b3IpIHtcbiAgICB0aGlzLiNlZGl0b3JzVG9SZXNjYWxlLmFkZChlZGl0b3IpO1xuICB9XG4gIHJlbW92ZVNob3VsZFJlc2NhbGUoZWRpdG9yKSB7XG4gICAgdGhpcy4jZWRpdG9yc1RvUmVzY2FsZS5kZWxldGUoZWRpdG9yKTtcbiAgfVxuICBvblNjYWxlQ2hhbmdpbmcoe1xuICAgIHNjYWxlXG4gIH0pIHtcbiAgICB0aGlzLmNvbW1pdE9yUmVtb3ZlKCk7XG4gICAgdGhpcy52aWV3UGFyYW1ldGVycy5yZWFsU2NhbGUgPSBzY2FsZSAqIF9kaXNwbGF5X3V0aWxzLlBpeGVsc1BlckluY2guUERGX1RPX0NTU19VTklUUztcbiAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiB0aGlzLiNlZGl0b3JzVG9SZXNjYWxlKSB7XG4gICAgICBlZGl0b3Iub25TY2FsZUNoYW5naW5nKCk7XG4gICAgfVxuICB9XG4gIG9uUm90YXRpb25DaGFuZ2luZyh7XG4gICAgcGFnZXNSb3RhdGlvblxuICB9KSB7XG4gICAgdGhpcy5jb21taXRPclJlbW92ZSgpO1xuICAgIHRoaXMudmlld1BhcmFtZXRlcnMucm90YXRpb24gPSBwYWdlc1JvdGF0aW9uO1xuICB9XG4gIGFkZFRvQW5ub3RhdGlvblN0b3JhZ2UoZWRpdG9yKSB7XG4gICAgaWYgKCFlZGl0b3IuaXNFbXB0eSgpICYmIHRoaXMuI2Fubm90YXRpb25TdG9yYWdlICYmICF0aGlzLiNhbm5vdGF0aW9uU3RvcmFnZS5oYXMoZWRpdG9yLmlkKSkge1xuICAgICAgdGhpcy4jYW5ub3RhdGlvblN0b3JhZ2Uuc2V0VmFsdWUoZWRpdG9yLmlkLCBlZGl0b3IpO1xuICAgIH1cbiAgfVxuICAjYWRkRm9jdXNNYW5hZ2VyKCkge1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNcIiwgdGhpcy4jYm91bmRGb2N1cyk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJibHVyXCIsIHRoaXMuI2JvdW5kQmx1cik7XG4gIH1cbiAgI3JlbW92ZUZvY3VzTWFuYWdlcigpIHtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImZvY3VzXCIsIHRoaXMuI2JvdW5kRm9jdXMpO1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwiYmx1clwiLCB0aGlzLiNib3VuZEJsdXIpO1xuICB9XG4gIGJsdXIoKSB7XG4gICAgaWYgKCF0aGlzLmhhc1NlbGVjdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBhY3RpdmVFbGVtZW50XG4gICAgfSA9IGRvY3VtZW50O1xuICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIHRoaXMuI3NlbGVjdGVkRWRpdG9ycykge1xuICAgICAgaWYgKGVkaXRvci5kaXYuY29udGFpbnMoYWN0aXZlRWxlbWVudCkpIHtcbiAgICAgICAgdGhpcy4jbGFzdEFjdGl2ZUVsZW1lbnQgPSBbZWRpdG9yLCBhY3RpdmVFbGVtZW50XTtcbiAgICAgICAgZWRpdG9yLl9mb2N1c0V2ZW50c0FsbG93ZWQgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZvY3VzKCkge1xuICAgIGlmICghdGhpcy4jbGFzdEFjdGl2ZUVsZW1lbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgW2xhc3RFZGl0b3IsIGxhc3RBY3RpdmVFbGVtZW50XSA9IHRoaXMuI2xhc3RBY3RpdmVFbGVtZW50O1xuICAgIHRoaXMuI2xhc3RBY3RpdmVFbGVtZW50ID0gbnVsbDtcbiAgICBsYXN0QWN0aXZlRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNpblwiLCAoKSA9PiB7XG4gICAgICBsYXN0RWRpdG9yLl9mb2N1c0V2ZW50c0FsbG93ZWQgPSB0cnVlO1xuICAgIH0sIHtcbiAgICAgIG9uY2U6IHRydWVcbiAgICB9KTtcbiAgICBsYXN0QWN0aXZlRWxlbWVudC5mb2N1cygpO1xuICB9XG4gICNhZGRLZXlib2FyZE1hbmFnZXIoKSB7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHRoaXMuI2JvdW5kS2V5ZG93biwge1xuICAgICAgY2FwdHVyZTogdHJ1ZVxuICAgIH0pO1xuICB9XG4gICNyZW1vdmVLZXlib2FyZE1hbmFnZXIoKSB7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHRoaXMuI2JvdW5kS2V5ZG93biwge1xuICAgICAgY2FwdHVyZTogdHJ1ZVxuICAgIH0pO1xuICB9XG4gICNhZGRDb3B5UGFzdGVMaXN0ZW5lcnMoKSB7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImNvcHlcIiwgdGhpcy4jYm91bmRDb3B5KTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiY3V0XCIsIHRoaXMuI2JvdW5kQ3V0KTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwicGFzdGVcIiwgdGhpcy4jYm91bmRQYXN0ZSk7XG4gIH1cbiAgI3JlbW92ZUNvcHlQYXN0ZUxpc3RlbmVycygpIHtcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwiY29weVwiLCB0aGlzLiNib3VuZENvcHkpO1xuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjdXRcIiwgdGhpcy4jYm91bmRDdXQpO1xuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJwYXN0ZVwiLCB0aGlzLiNib3VuZFBhc3RlKTtcbiAgfVxuICBhZGRFZGl0TGlzdGVuZXJzKCkge1xuICAgIHRoaXMuI2FkZEtleWJvYXJkTWFuYWdlcigpO1xuICAgIHRoaXMuI2FkZENvcHlQYXN0ZUxpc3RlbmVycygpO1xuICB9XG4gIHJlbW92ZUVkaXRMaXN0ZW5lcnMoKSB7XG4gICAgdGhpcy4jcmVtb3ZlS2V5Ym9hcmRNYW5hZ2VyKCk7XG4gICAgdGhpcy4jcmVtb3ZlQ29weVBhc3RlTGlzdGVuZXJzKCk7XG4gIH1cbiAgY29weShldmVudCkge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgdGhpcy4jYWN0aXZlRWRpdG9yPy5jb21taXRPclJlbW92ZSgpO1xuICAgIGlmICghdGhpcy5oYXNTZWxlY3Rpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZWRpdG9ycyA9IFtdO1xuICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIHRoaXMuI3NlbGVjdGVkRWRpdG9ycykge1xuICAgICAgY29uc3Qgc2VyaWFsaXplZCA9IGVkaXRvci5zZXJpYWxpemUodHJ1ZSk7XG4gICAgICBpZiAoc2VyaWFsaXplZCkge1xuICAgICAgICBlZGl0b3JzLnB1c2goc2VyaWFsaXplZCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChlZGl0b3JzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBldmVudC5jbGlwYm9hcmREYXRhLnNldERhdGEoXCJhcHBsaWNhdGlvbi9wZGZqc1wiLCBKU09OLnN0cmluZ2lmeShlZGl0b3JzKSk7XG4gIH1cbiAgY3V0KGV2ZW50KSB7XG4gICAgdGhpcy5jb3B5KGV2ZW50KTtcbiAgICB0aGlzLmRlbGV0ZSgpO1xuICB9XG4gIHBhc3RlKGV2ZW50KSB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICBjb25zdCB7XG4gICAgICBjbGlwYm9hcmREYXRhXG4gICAgfSA9IGV2ZW50O1xuICAgIGZvciAoY29uc3QgaXRlbSBvZiBjbGlwYm9hcmREYXRhLml0ZW1zKSB7XG4gICAgICBmb3IgKGNvbnN0IGVkaXRvclR5cGUgb2YgdGhpcy4jZWRpdG9yVHlwZXMpIHtcbiAgICAgICAgaWYgKGVkaXRvclR5cGUuaXNIYW5kbGluZ01pbWVGb3JQYXN0aW5nKGl0ZW0udHlwZSkpIHtcbiAgICAgICAgICBlZGl0b3JUeXBlLnBhc3RlKGl0ZW0sIHRoaXMuY3VycmVudExheWVyKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IGRhdGEgPSBjbGlwYm9hcmREYXRhLmdldERhdGEoXCJhcHBsaWNhdGlvbi9wZGZqc1wiKTtcbiAgICBpZiAoIWRhdGEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGRhdGEgPSBKU09OLnBhcnNlKGRhdGEpO1xuICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAoMCwgX3V0aWwud2FybikoYHBhc3RlOiBcIiR7ZXgubWVzc2FnZX1cIi5gKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMudW5zZWxlY3RBbGwoKTtcbiAgICBjb25zdCBsYXllciA9IHRoaXMuY3VycmVudExheWVyO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBuZXdFZGl0b3JzID0gW107XG4gICAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiBkYXRhKSB7XG4gICAgICAgIGNvbnN0IGRlc2VyaWFsaXplZEVkaXRvciA9IGxheWVyLmRlc2VyaWFsaXplKGVkaXRvcik7XG4gICAgICAgIGlmICghZGVzZXJpYWxpemVkRWRpdG9yKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG5ld0VkaXRvcnMucHVzaChkZXNlcmlhbGl6ZWRFZGl0b3IpO1xuICAgICAgfVxuICAgICAgY29uc3QgY21kID0gKCkgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiBuZXdFZGl0b3JzKSB7XG4gICAgICAgICAgdGhpcy4jYWRkRWRpdG9yVG9MYXllcihlZGl0b3IpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI3NlbGVjdEVkaXRvcnMobmV3RWRpdG9ycyk7XG4gICAgICB9O1xuICAgICAgY29uc3QgdW5kbyA9ICgpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBlZGl0b3Igb2YgbmV3RWRpdG9ycykge1xuICAgICAgICAgIGVkaXRvci5yZW1vdmUoKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHRoaXMuYWRkQ29tbWFuZHMoe1xuICAgICAgICBjbWQsXG4gICAgICAgIHVuZG8sXG4gICAgICAgIG11c3RFeGVjOiB0cnVlXG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChleCkge1xuICAgICAgKDAsIF91dGlsLndhcm4pKGBwYXN0ZTogXCIke2V4Lm1lc3NhZ2V9XCIuYCk7XG4gICAgfVxuICB9XG4gIGtleWRvd24oZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuZ2V0QWN0aXZlKCk/LnNob3VsZEdldEtleWJvYXJkRXZlbnRzKCkpIHtcbiAgICAgIEFubm90YXRpb25FZGl0b3JVSU1hbmFnZXIuX2tleWJvYXJkTWFuYWdlci5leGVjKHRoaXMsIGV2ZW50KTtcbiAgICB9XG4gIH1cbiAgb25FZGl0aW5nQWN0aW9uKGRldGFpbHMpIHtcbiAgICBpZiAoW1widW5kb1wiLCBcInJlZG9cIiwgXCJkZWxldGVcIiwgXCJzZWxlY3RBbGxcIl0uaW5jbHVkZXMoZGV0YWlscy5uYW1lKSkge1xuICAgICAgdGhpc1tkZXRhaWxzLm5hbWVdKCk7XG4gICAgfVxuICB9XG4gICNkaXNwYXRjaFVwZGF0ZVN0YXRlcyhkZXRhaWxzKSB7XG4gICAgY29uc3QgaGFzQ2hhbmdlZCA9IE9iamVjdC5lbnRyaWVzKGRldGFpbHMpLnNvbWUoKFtrZXksIHZhbHVlXSkgPT4gdGhpcy4jcHJldmlvdXNTdGF0ZXNba2V5XSAhPT0gdmFsdWUpO1xuICAgIGlmIChoYXNDaGFuZ2VkKSB7XG4gICAgICB0aGlzLl9ldmVudEJ1cy5kaXNwYXRjaChcImFubm90YXRpb25lZGl0b3JzdGF0ZXNjaGFuZ2VkXCIsIHtcbiAgICAgICAgc291cmNlOiB0aGlzLFxuICAgICAgICBkZXRhaWxzOiBPYmplY3QuYXNzaWduKHRoaXMuI3ByZXZpb3VzU3RhdGVzLCBkZXRhaWxzKVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gICNkaXNwYXRjaFVwZGF0ZVVJKGRldGFpbHMpIHtcbiAgICB0aGlzLl9ldmVudEJ1cy5kaXNwYXRjaChcImFubm90YXRpb25lZGl0b3JwYXJhbXNjaGFuZ2VkXCIsIHtcbiAgICAgIHNvdXJjZTogdGhpcyxcbiAgICAgIGRldGFpbHNcbiAgICB9KTtcbiAgfVxuICBzZXRFZGl0aW5nU3RhdGUoaXNFZGl0aW5nKSB7XG4gICAgaWYgKGlzRWRpdGluZykge1xuICAgICAgdGhpcy4jYWRkRm9jdXNNYW5hZ2VyKCk7XG4gICAgICB0aGlzLiNhZGRLZXlib2FyZE1hbmFnZXIoKTtcbiAgICAgIHRoaXMuI2FkZENvcHlQYXN0ZUxpc3RlbmVycygpO1xuICAgICAgdGhpcy4jZGlzcGF0Y2hVcGRhdGVTdGF0ZXMoe1xuICAgICAgICBpc0VkaXRpbmc6IHRoaXMuI21vZGUgIT09IF91dGlsLkFubm90YXRpb25FZGl0b3JUeXBlLk5PTkUsXG4gICAgICAgIGlzRW1wdHk6IHRoaXMuI2lzRW1wdHkoKSxcbiAgICAgICAgaGFzU29tZXRoaW5nVG9VbmRvOiB0aGlzLiNjb21tYW5kTWFuYWdlci5oYXNTb21ldGhpbmdUb1VuZG8oKSxcbiAgICAgICAgaGFzU29tZXRoaW5nVG9SZWRvOiB0aGlzLiNjb21tYW5kTWFuYWdlci5oYXNTb21ldGhpbmdUb1JlZG8oKSxcbiAgICAgICAgaGFzU2VsZWN0ZWRFZGl0b3I6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy4jcmVtb3ZlRm9jdXNNYW5hZ2VyKCk7XG4gICAgICB0aGlzLiNyZW1vdmVLZXlib2FyZE1hbmFnZXIoKTtcbiAgICAgIHRoaXMuI3JlbW92ZUNvcHlQYXN0ZUxpc3RlbmVycygpO1xuICAgICAgdGhpcy4jZGlzcGF0Y2hVcGRhdGVTdGF0ZXMoe1xuICAgICAgICBpc0VkaXRpbmc6IGZhbHNlXG4gICAgICB9KTtcbiAgICAgIHRoaXMuZGlzYWJsZVVzZXJTZWxlY3QoZmFsc2UpO1xuICAgIH1cbiAgfVxuICByZWdpc3RlckVkaXRvclR5cGVzKHR5cGVzKSB7XG4gICAgaWYgKHRoaXMuI2VkaXRvclR5cGVzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2VkaXRvclR5cGVzID0gdHlwZXM7XG4gICAgZm9yIChjb25zdCBlZGl0b3JUeXBlIG9mIHRoaXMuI2VkaXRvclR5cGVzKSB7XG4gICAgICB0aGlzLiNkaXNwYXRjaFVwZGF0ZVVJKGVkaXRvclR5cGUuZGVmYXVsdFByb3BlcnRpZXNUb1VwZGF0ZSk7XG4gICAgfVxuICB9XG4gIGdldElkKCkge1xuICAgIHJldHVybiB0aGlzLiNpZE1hbmFnZXIuZ2V0SWQoKTtcbiAgfVxuICBnZXQgY3VycmVudExheWVyKCkge1xuICAgIHJldHVybiB0aGlzLiNhbGxMYXllcnMuZ2V0KHRoaXMuI2N1cnJlbnRQYWdlSW5kZXgpO1xuICB9XG4gIGdldExheWVyKHBhZ2VJbmRleCkge1xuICAgIHJldHVybiB0aGlzLiNhbGxMYXllcnMuZ2V0KHBhZ2VJbmRleCk7XG4gIH1cbiAgZ2V0IGN1cnJlbnRQYWdlSW5kZXgoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2N1cnJlbnRQYWdlSW5kZXg7XG4gIH1cbiAgYWRkTGF5ZXIobGF5ZXIpIHtcbiAgICB0aGlzLiNhbGxMYXllcnMuc2V0KGxheWVyLnBhZ2VJbmRleCwgbGF5ZXIpO1xuICAgIGlmICh0aGlzLiNpc0VuYWJsZWQpIHtcbiAgICAgIGxheWVyLmVuYWJsZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsYXllci5kaXNhYmxlKCk7XG4gICAgfVxuICB9XG4gIHJlbW92ZUxheWVyKGxheWVyKSB7XG4gICAgdGhpcy4jYWxsTGF5ZXJzLmRlbGV0ZShsYXllci5wYWdlSW5kZXgpO1xuICB9XG4gIHVwZGF0ZU1vZGUobW9kZSwgZWRpdElkID0gbnVsbCkge1xuICAgIGlmICh0aGlzLiNtb2RlID09PSBtb2RlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI21vZGUgPSBtb2RlO1xuICAgIGlmIChtb2RlID09PSBfdXRpbC5Bbm5vdGF0aW9uRWRpdG9yVHlwZS5OT05FKSB7XG4gICAgICB0aGlzLnNldEVkaXRpbmdTdGF0ZShmYWxzZSk7XG4gICAgICB0aGlzLiNkaXNhYmxlQWxsKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuc2V0RWRpdGluZ1N0YXRlKHRydWUpO1xuICAgIHRoaXMuI2VuYWJsZUFsbCgpO1xuICAgIHRoaXMudW5zZWxlY3RBbGwoKTtcbiAgICBmb3IgKGNvbnN0IGxheWVyIG9mIHRoaXMuI2FsbExheWVycy52YWx1ZXMoKSkge1xuICAgICAgbGF5ZXIudXBkYXRlTW9kZShtb2RlKTtcbiAgICB9XG4gICAgaWYgKCFlZGl0SWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yIChjb25zdCBlZGl0b3Igb2YgdGhpcy4jYWxsRWRpdG9ycy52YWx1ZXMoKSkge1xuICAgICAgaWYgKGVkaXRvci5hbm5vdGF0aW9uRWxlbWVudElkID09PSBlZGl0SWQpIHtcbiAgICAgICAgdGhpcy5zZXRTZWxlY3RlZChlZGl0b3IpO1xuICAgICAgICBlZGl0b3IuZW50ZXJJbkVkaXRNb2RlKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICB1cGRhdGVUb29sYmFyKG1vZGUpIHtcbiAgICBpZiAobW9kZSA9PT0gdGhpcy4jbW9kZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9ldmVudEJ1cy5kaXNwYXRjaChcInN3aXRjaGFubm90YXRpb25lZGl0b3Jtb2RlXCIsIHtcbiAgICAgIHNvdXJjZTogdGhpcyxcbiAgICAgIG1vZGVcbiAgICB9KTtcbiAgfVxuICB1cGRhdGVQYXJhbXModHlwZSwgdmFsdWUpIHtcbiAgICBpZiAoIXRoaXMuI2VkaXRvclR5cGVzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0eXBlID09PSBfdXRpbC5Bbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5DUkVBVEUpIHtcbiAgICAgIHRoaXMuY3VycmVudExheWVyLmFkZE5ld0VkaXRvcih0eXBlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yIChjb25zdCBlZGl0b3Igb2YgdGhpcy4jc2VsZWN0ZWRFZGl0b3JzKSB7XG4gICAgICBlZGl0b3IudXBkYXRlUGFyYW1zKHR5cGUsIHZhbHVlKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBlZGl0b3JUeXBlIG9mIHRoaXMuI2VkaXRvclR5cGVzKSB7XG4gICAgICBlZGl0b3JUeXBlLnVwZGF0ZURlZmF1bHRQYXJhbXModHlwZSwgdmFsdWUpO1xuICAgIH1cbiAgfVxuICBlbmFibGVXYWl0aW5nKG11c3RXYWl0ID0gZmFsc2UpIHtcbiAgICBpZiAodGhpcy4jaXNXYWl0aW5nID09PSBtdXN0V2FpdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNpc1dhaXRpbmcgPSBtdXN0V2FpdDtcbiAgICBmb3IgKGNvbnN0IGxheWVyIG9mIHRoaXMuI2FsbExheWVycy52YWx1ZXMoKSkge1xuICAgICAgaWYgKG11c3RXYWl0KSB7XG4gICAgICAgIGxheWVyLmRpc2FibGVDbGljaygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGF5ZXIuZW5hYmxlQ2xpY2soKTtcbiAgICAgIH1cbiAgICAgIGxheWVyLmRpdi5jbGFzc0xpc3QudG9nZ2xlKFwid2FpdGluZ1wiLCBtdXN0V2FpdCk7XG4gICAgfVxuICB9XG4gICNlbmFibGVBbGwoKSB7XG4gICAgaWYgKCF0aGlzLiNpc0VuYWJsZWQpIHtcbiAgICAgIHRoaXMuI2lzRW5hYmxlZCA9IHRydWU7XG4gICAgICBmb3IgKGNvbnN0IGxheWVyIG9mIHRoaXMuI2FsbExheWVycy52YWx1ZXMoKSkge1xuICAgICAgICBsYXllci5lbmFibGUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgI2Rpc2FibGVBbGwoKSB7XG4gICAgdGhpcy51bnNlbGVjdEFsbCgpO1xuICAgIGlmICh0aGlzLiNpc0VuYWJsZWQpIHtcbiAgICAgIHRoaXMuI2lzRW5hYmxlZCA9IGZhbHNlO1xuICAgICAgZm9yIChjb25zdCBsYXllciBvZiB0aGlzLiNhbGxMYXllcnMudmFsdWVzKCkpIHtcbiAgICAgICAgbGF5ZXIuZGlzYWJsZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBnZXRFZGl0b3JzKHBhZ2VJbmRleCkge1xuICAgIGNvbnN0IGVkaXRvcnMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiB0aGlzLiNhbGxFZGl0b3JzLnZhbHVlcygpKSB7XG4gICAgICBpZiAoZWRpdG9yLnBhZ2VJbmRleCA9PT0gcGFnZUluZGV4KSB7XG4gICAgICAgIGVkaXRvcnMucHVzaChlZGl0b3IpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZWRpdG9ycztcbiAgfVxuICBnZXRFZGl0b3IoaWQpIHtcbiAgICByZXR1cm4gdGhpcy4jYWxsRWRpdG9ycy5nZXQoaWQpO1xuICB9XG4gIGFkZEVkaXRvcihlZGl0b3IpIHtcbiAgICB0aGlzLiNhbGxFZGl0b3JzLnNldChlZGl0b3IuaWQsIGVkaXRvcik7XG4gIH1cbiAgcmVtb3ZlRWRpdG9yKGVkaXRvcikge1xuICAgIHRoaXMuI2FsbEVkaXRvcnMuZGVsZXRlKGVkaXRvci5pZCk7XG4gICAgdGhpcy51bnNlbGVjdChlZGl0b3IpO1xuICAgIGlmICghZWRpdG9yLmFubm90YXRpb25FbGVtZW50SWQgfHwgIXRoaXMuI2RlbGV0ZWRBbm5vdGF0aW9uc0VsZW1lbnRJZHMuaGFzKGVkaXRvci5hbm5vdGF0aW9uRWxlbWVudElkKSkge1xuICAgICAgdGhpcy4jYW5ub3RhdGlvblN0b3JhZ2U/LnJlbW92ZShlZGl0b3IuaWQpO1xuICAgIH1cbiAgfVxuICBhZGREZWxldGVkQW5ub3RhdGlvbkVsZW1lbnQoZWRpdG9yKSB7XG4gICAgdGhpcy4jZGVsZXRlZEFubm90YXRpb25zRWxlbWVudElkcy5hZGQoZWRpdG9yLmFubm90YXRpb25FbGVtZW50SWQpO1xuICAgIGVkaXRvci5kZWxldGVkID0gdHJ1ZTtcbiAgfVxuICBpc0RlbGV0ZWRBbm5vdGF0aW9uRWxlbWVudChhbm5vdGF0aW9uRWxlbWVudElkKSB7XG4gICAgcmV0dXJuIHRoaXMuI2RlbGV0ZWRBbm5vdGF0aW9uc0VsZW1lbnRJZHMuaGFzKGFubm90YXRpb25FbGVtZW50SWQpO1xuICB9XG4gIHJlbW92ZURlbGV0ZWRBbm5vdGF0aW9uRWxlbWVudChlZGl0b3IpIHtcbiAgICB0aGlzLiNkZWxldGVkQW5ub3RhdGlvbnNFbGVtZW50SWRzLmRlbGV0ZShlZGl0b3IuYW5ub3RhdGlvbkVsZW1lbnRJZCk7XG4gICAgZWRpdG9yLmRlbGV0ZWQgPSBmYWxzZTtcbiAgfVxuICAjYWRkRWRpdG9yVG9MYXllcihlZGl0b3IpIHtcbiAgICBjb25zdCBsYXllciA9IHRoaXMuI2FsbExheWVycy5nZXQoZWRpdG9yLnBhZ2VJbmRleCk7XG4gICAgaWYgKGxheWVyKSB7XG4gICAgICBsYXllci5hZGRPclJlYnVpbGQoZWRpdG9yKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hZGRFZGl0b3IoZWRpdG9yKTtcbiAgICB9XG4gIH1cbiAgc2V0QWN0aXZlRWRpdG9yKGVkaXRvcikge1xuICAgIGlmICh0aGlzLiNhY3RpdmVFZGl0b3IgPT09IGVkaXRvcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNhY3RpdmVFZGl0b3IgPSBlZGl0b3I7XG4gICAgaWYgKGVkaXRvcikge1xuICAgICAgdGhpcy4jZGlzcGF0Y2hVcGRhdGVVSShlZGl0b3IucHJvcGVydGllc1RvVXBkYXRlKTtcbiAgICB9XG4gIH1cbiAgdG9nZ2xlU2VsZWN0ZWQoZWRpdG9yKSB7XG4gICAgaWYgKHRoaXMuI3NlbGVjdGVkRWRpdG9ycy5oYXMoZWRpdG9yKSkge1xuICAgICAgdGhpcy4jc2VsZWN0ZWRFZGl0b3JzLmRlbGV0ZShlZGl0b3IpO1xuICAgICAgZWRpdG9yLnVuc2VsZWN0KCk7XG4gICAgICB0aGlzLiNkaXNwYXRjaFVwZGF0ZVN0YXRlcyh7XG4gICAgICAgIGhhc1NlbGVjdGVkRWRpdG9yOiB0aGlzLmhhc1NlbGVjdGlvblxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI3NlbGVjdGVkRWRpdG9ycy5hZGQoZWRpdG9yKTtcbiAgICBlZGl0b3Iuc2VsZWN0KCk7XG4gICAgdGhpcy4jZGlzcGF0Y2hVcGRhdGVVSShlZGl0b3IucHJvcGVydGllc1RvVXBkYXRlKTtcbiAgICB0aGlzLiNkaXNwYXRjaFVwZGF0ZVN0YXRlcyh7XG4gICAgICBoYXNTZWxlY3RlZEVkaXRvcjogdHJ1ZVxuICAgIH0pO1xuICB9XG4gIHNldFNlbGVjdGVkKGVkaXRvcikge1xuICAgIGZvciAoY29uc3QgZWQgb2YgdGhpcy4jc2VsZWN0ZWRFZGl0b3JzKSB7XG4gICAgICBpZiAoZWQgIT09IGVkaXRvcikge1xuICAgICAgICBlZC51bnNlbGVjdCgpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLiNzZWxlY3RlZEVkaXRvcnMuY2xlYXIoKTtcbiAgICB0aGlzLiNzZWxlY3RlZEVkaXRvcnMuYWRkKGVkaXRvcik7XG4gICAgZWRpdG9yLnNlbGVjdCgpO1xuICAgIHRoaXMuI2Rpc3BhdGNoVXBkYXRlVUkoZWRpdG9yLnByb3BlcnRpZXNUb1VwZGF0ZSk7XG4gICAgdGhpcy4jZGlzcGF0Y2hVcGRhdGVTdGF0ZXMoe1xuICAgICAgaGFzU2VsZWN0ZWRFZGl0b3I6IHRydWVcbiAgICB9KTtcbiAgfVxuICBpc1NlbGVjdGVkKGVkaXRvcikge1xuICAgIHJldHVybiB0aGlzLiNzZWxlY3RlZEVkaXRvcnMuaGFzKGVkaXRvcik7XG4gIH1cbiAgdW5zZWxlY3QoZWRpdG9yKSB7XG4gICAgZWRpdG9yLnVuc2VsZWN0KCk7XG4gICAgdGhpcy4jc2VsZWN0ZWRFZGl0b3JzLmRlbGV0ZShlZGl0b3IpO1xuICAgIHRoaXMuI2Rpc3BhdGNoVXBkYXRlU3RhdGVzKHtcbiAgICAgIGhhc1NlbGVjdGVkRWRpdG9yOiB0aGlzLmhhc1NlbGVjdGlvblxuICAgIH0pO1xuICB9XG4gIGdldCBoYXNTZWxlY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuI3NlbGVjdGVkRWRpdG9ycy5zaXplICE9PSAwO1xuICB9XG4gIHVuZG8oKSB7XG4gICAgdGhpcy4jY29tbWFuZE1hbmFnZXIudW5kbygpO1xuICAgIHRoaXMuI2Rpc3BhdGNoVXBkYXRlU3RhdGVzKHtcbiAgICAgIGhhc1NvbWV0aGluZ1RvVW5kbzogdGhpcy4jY29tbWFuZE1hbmFnZXIuaGFzU29tZXRoaW5nVG9VbmRvKCksXG4gICAgICBoYXNTb21ldGhpbmdUb1JlZG86IHRydWUsXG4gICAgICBpc0VtcHR5OiB0aGlzLiNpc0VtcHR5KClcbiAgICB9KTtcbiAgfVxuICByZWRvKCkge1xuICAgIHRoaXMuI2NvbW1hbmRNYW5hZ2VyLnJlZG8oKTtcbiAgICB0aGlzLiNkaXNwYXRjaFVwZGF0ZVN0YXRlcyh7XG4gICAgICBoYXNTb21ldGhpbmdUb1VuZG86IHRydWUsXG4gICAgICBoYXNTb21ldGhpbmdUb1JlZG86IHRoaXMuI2NvbW1hbmRNYW5hZ2VyLmhhc1NvbWV0aGluZ1RvUmVkbygpLFxuICAgICAgaXNFbXB0eTogdGhpcy4jaXNFbXB0eSgpXG4gICAgfSk7XG4gIH1cbiAgYWRkQ29tbWFuZHMocGFyYW1zKSB7XG4gICAgdGhpcy4jY29tbWFuZE1hbmFnZXIuYWRkKHBhcmFtcyk7XG4gICAgdGhpcy4jZGlzcGF0Y2hVcGRhdGVTdGF0ZXMoe1xuICAgICAgaGFzU29tZXRoaW5nVG9VbmRvOiB0cnVlLFxuICAgICAgaGFzU29tZXRoaW5nVG9SZWRvOiBmYWxzZSxcbiAgICAgIGlzRW1wdHk6IHRoaXMuI2lzRW1wdHkoKVxuICAgIH0pO1xuICB9XG4gICNpc0VtcHR5KCkge1xuICAgIGlmICh0aGlzLiNhbGxFZGl0b3JzLnNpemUgPT09IDApIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAodGhpcy4jYWxsRWRpdG9ycy5zaXplID09PSAxKSB7XG4gICAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiB0aGlzLiNhbGxFZGl0b3JzLnZhbHVlcygpKSB7XG4gICAgICAgIHJldHVybiBlZGl0b3IuaXNFbXB0eSgpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZGVsZXRlKCkge1xuICAgIHRoaXMuY29tbWl0T3JSZW1vdmUoKTtcbiAgICBpZiAoIXRoaXMuaGFzU2VsZWN0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGVkaXRvcnMgPSBbLi4udGhpcy4jc2VsZWN0ZWRFZGl0b3JzXTtcbiAgICBjb25zdCBjbWQgPSAoKSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiBlZGl0b3JzKSB7XG4gICAgICAgIGVkaXRvci5yZW1vdmUoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHVuZG8gPSAoKSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiBlZGl0b3JzKSB7XG4gICAgICAgIHRoaXMuI2FkZEVkaXRvclRvTGF5ZXIoZWRpdG9yKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuYWRkQ29tbWFuZHMoe1xuICAgICAgY21kLFxuICAgICAgdW5kbyxcbiAgICAgIG11c3RFeGVjOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgY29tbWl0T3JSZW1vdmUoKSB7XG4gICAgdGhpcy4jYWN0aXZlRWRpdG9yPy5jb21taXRPclJlbW92ZSgpO1xuICB9XG4gIGhhc1NvbWV0aGluZ1RvQ29udHJvbCgpIHtcbiAgICByZXR1cm4gdGhpcy4jYWN0aXZlRWRpdG9yIHx8IHRoaXMuaGFzU2VsZWN0aW9uO1xuICB9XG4gICNzZWxlY3RFZGl0b3JzKGVkaXRvcnMpIHtcbiAgICB0aGlzLiNzZWxlY3RlZEVkaXRvcnMuY2xlYXIoKTtcbiAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiBlZGl0b3JzKSB7XG4gICAgICBpZiAoZWRpdG9yLmlzRW1wdHkoKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHRoaXMuI3NlbGVjdGVkRWRpdG9ycy5hZGQoZWRpdG9yKTtcbiAgICAgIGVkaXRvci5zZWxlY3QoKTtcbiAgICB9XG4gICAgdGhpcy4jZGlzcGF0Y2hVcGRhdGVTdGF0ZXMoe1xuICAgICAgaGFzU2VsZWN0ZWRFZGl0b3I6IHRydWVcbiAgICB9KTtcbiAgfVxuICBzZWxlY3RBbGwoKSB7XG4gICAgZm9yIChjb25zdCBlZGl0b3Igb2YgdGhpcy4jc2VsZWN0ZWRFZGl0b3JzKSB7XG4gICAgICBlZGl0b3IuY29tbWl0KCk7XG4gICAgfVxuICAgIHRoaXMuI3NlbGVjdEVkaXRvcnModGhpcy4jYWxsRWRpdG9ycy52YWx1ZXMoKSk7XG4gIH1cbiAgdW5zZWxlY3RBbGwoKSB7XG4gICAgaWYgKHRoaXMuI2FjdGl2ZUVkaXRvcikge1xuICAgICAgdGhpcy4jYWN0aXZlRWRpdG9yLmNvbW1pdE9yUmVtb3ZlKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghdGhpcy5oYXNTZWxlY3Rpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yIChjb25zdCBlZGl0b3Igb2YgdGhpcy4jc2VsZWN0ZWRFZGl0b3JzKSB7XG4gICAgICBlZGl0b3IudW5zZWxlY3QoKTtcbiAgICB9XG4gICAgdGhpcy4jc2VsZWN0ZWRFZGl0b3JzLmNsZWFyKCk7XG4gICAgdGhpcy4jZGlzcGF0Y2hVcGRhdGVTdGF0ZXMoe1xuICAgICAgaGFzU2VsZWN0ZWRFZGl0b3I6IGZhbHNlXG4gICAgfSk7XG4gIH1cbiAgdHJhbnNsYXRlU2VsZWN0ZWRFZGl0b3JzKHgsIHksIG5vQ29tbWl0ID0gZmFsc2UpIHtcbiAgICBpZiAoIW5vQ29tbWl0KSB7XG4gICAgICB0aGlzLmNvbW1pdE9yUmVtb3ZlKCk7XG4gICAgfVxuICAgIGlmICghdGhpcy5oYXNTZWxlY3Rpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jdHJhbnNsYXRpb25bMF0gKz0geDtcbiAgICB0aGlzLiN0cmFuc2xhdGlvblsxXSArPSB5O1xuICAgIGNvbnN0IFt0b3RhbFgsIHRvdGFsWV0gPSB0aGlzLiN0cmFuc2xhdGlvbjtcbiAgICBjb25zdCBlZGl0b3JzID0gWy4uLnRoaXMuI3NlbGVjdGVkRWRpdG9yc107XG4gICAgY29uc3QgVElNRV9UT19XQUlUID0gMTAwMDtcbiAgICBpZiAodGhpcy4jdHJhbnNsYXRpb25UaW1lb3V0SWQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLiN0cmFuc2xhdGlvblRpbWVvdXRJZCk7XG4gICAgfVxuICAgIHRoaXMuI3RyYW5zbGF0aW9uVGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLiN0cmFuc2xhdGlvblRpbWVvdXRJZCA9IG51bGw7XG4gICAgICB0aGlzLiN0cmFuc2xhdGlvblswXSA9IHRoaXMuI3RyYW5zbGF0aW9uWzFdID0gMDtcbiAgICAgIHRoaXMuYWRkQ29tbWFuZHMoe1xuICAgICAgICBjbWQ6ICgpID0+IHtcbiAgICAgICAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiBlZGl0b3JzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy4jYWxsRWRpdG9ycy5oYXMoZWRpdG9yLmlkKSkge1xuICAgICAgICAgICAgICBlZGl0b3IudHJhbnNsYXRlSW5QYWdlKHRvdGFsWCwgdG90YWxZKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHVuZG86ICgpID0+IHtcbiAgICAgICAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiBlZGl0b3JzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy4jYWxsRWRpdG9ycy5oYXMoZWRpdG9yLmlkKSkge1xuICAgICAgICAgICAgICBlZGl0b3IudHJhbnNsYXRlSW5QYWdlKC10b3RhbFgsIC10b3RhbFkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgbXVzdEV4ZWM6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9LCBUSU1FX1RPX1dBSVQpO1xuICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIGVkaXRvcnMpIHtcbiAgICAgIGVkaXRvci50cmFuc2xhdGVJblBhZ2UoeCwgeSk7XG4gICAgfVxuICB9XG4gIHNldFVwRHJhZ1Nlc3Npb24oKSB7XG4gICAgaWYgKCF0aGlzLmhhc1NlbGVjdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmRpc2FibGVVc2VyU2VsZWN0KHRydWUpO1xuICAgIHRoaXMuI2RyYWdnaW5nRWRpdG9ycyA9IG5ldyBNYXAoKTtcbiAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiB0aGlzLiNzZWxlY3RlZEVkaXRvcnMpIHtcbiAgICAgIHRoaXMuI2RyYWdnaW5nRWRpdG9ycy5zZXQoZWRpdG9yLCB7XG4gICAgICAgIHNhdmVkWDogZWRpdG9yLngsXG4gICAgICAgIHNhdmVkWTogZWRpdG9yLnksXG4gICAgICAgIHNhdmVkUGFnZUluZGV4OiBlZGl0b3IucGFnZUluZGV4LFxuICAgICAgICBuZXdYOiAwLFxuICAgICAgICBuZXdZOiAwLFxuICAgICAgICBuZXdQYWdlSW5kZXg6IC0xXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgZW5kRHJhZ1Nlc3Npb24oKSB7XG4gICAgaWYgKCF0aGlzLiNkcmFnZ2luZ0VkaXRvcnMpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5kaXNhYmxlVXNlclNlbGVjdChmYWxzZSk7XG4gICAgY29uc3QgbWFwID0gdGhpcy4jZHJhZ2dpbmdFZGl0b3JzO1xuICAgIHRoaXMuI2RyYWdnaW5nRWRpdG9ycyA9IG51bGw7XG4gICAgbGV0IG11c3RCZUFkZGVkSW5VbmRvU3RhY2sgPSBmYWxzZTtcbiAgICBmb3IgKGNvbnN0IFt7XG4gICAgICB4LFxuICAgICAgeSxcbiAgICAgIHBhZ2VJbmRleFxuICAgIH0sIHZhbHVlXSBvZiBtYXApIHtcbiAgICAgIHZhbHVlLm5ld1ggPSB4O1xuICAgICAgdmFsdWUubmV3WSA9IHk7XG4gICAgICB2YWx1ZS5uZXdQYWdlSW5kZXggPSBwYWdlSW5kZXg7XG4gICAgICBtdXN0QmVBZGRlZEluVW5kb1N0YWNrIHx8PSB4ICE9PSB2YWx1ZS5zYXZlZFggfHwgeSAhPT0gdmFsdWUuc2F2ZWRZIHx8IHBhZ2VJbmRleCAhPT0gdmFsdWUuc2F2ZWRQYWdlSW5kZXg7XG4gICAgfVxuICAgIGlmICghbXVzdEJlQWRkZWRJblVuZG9TdGFjaykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBtb3ZlID0gKGVkaXRvciwgeCwgeSwgcGFnZUluZGV4KSA9PiB7XG4gICAgICBpZiAodGhpcy4jYWxsRWRpdG9ycy5oYXMoZWRpdG9yLmlkKSkge1xuICAgICAgICBjb25zdCBwYXJlbnQgPSB0aGlzLiNhbGxMYXllcnMuZ2V0KHBhZ2VJbmRleCk7XG4gICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICBlZGl0b3IuX3NldFBhcmVudEFuZFBvc2l0aW9uKHBhcmVudCwgeCwgeSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZWRpdG9yLnBhZ2VJbmRleCA9IHBhZ2VJbmRleDtcbiAgICAgICAgICBlZGl0b3IueCA9IHg7XG4gICAgICAgICAgZWRpdG9yLnkgPSB5O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmFkZENvbW1hbmRzKHtcbiAgICAgIGNtZDogKCkgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IFtlZGl0b3IsIHtcbiAgICAgICAgICBuZXdYLFxuICAgICAgICAgIG5ld1ksXG4gICAgICAgICAgbmV3UGFnZUluZGV4XG4gICAgICAgIH1dIG9mIG1hcCkge1xuICAgICAgICAgIG1vdmUoZWRpdG9yLCBuZXdYLCBuZXdZLCBuZXdQYWdlSW5kZXgpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdW5kbzogKCkgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IFtlZGl0b3IsIHtcbiAgICAgICAgICBzYXZlZFgsXG4gICAgICAgICAgc2F2ZWRZLFxuICAgICAgICAgIHNhdmVkUGFnZUluZGV4XG4gICAgICAgIH1dIG9mIG1hcCkge1xuICAgICAgICAgIG1vdmUoZWRpdG9yLCBzYXZlZFgsIHNhdmVkWSwgc2F2ZWRQYWdlSW5kZXgpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgbXVzdEV4ZWM6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBkcmFnU2VsZWN0ZWRFZGl0b3JzKHR4LCB0eSkge1xuICAgIGlmICghdGhpcy4jZHJhZ2dpbmdFZGl0b3JzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIHRoaXMuI2RyYWdnaW5nRWRpdG9ycy5rZXlzKCkpIHtcbiAgICAgIGVkaXRvci5kcmFnKHR4LCB0eSk7XG4gICAgfVxuICB9XG4gIHJlYnVpbGQoZWRpdG9yKSB7XG4gICAgaWYgKGVkaXRvci5wYXJlbnQgPT09IG51bGwpIHtcbiAgICAgIGNvbnN0IHBhcmVudCA9IHRoaXMuZ2V0TGF5ZXIoZWRpdG9yLnBhZ2VJbmRleCk7XG4gICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgIHBhcmVudC5jaGFuZ2VQYXJlbnQoZWRpdG9yKTtcbiAgICAgICAgcGFyZW50LmFkZE9yUmVidWlsZChlZGl0b3IpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5hZGRFZGl0b3IoZWRpdG9yKTtcbiAgICAgICAgdGhpcy5hZGRUb0Fubm90YXRpb25TdG9yYWdlKGVkaXRvcik7XG4gICAgICAgIGVkaXRvci5yZWJ1aWxkKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVkaXRvci5wYXJlbnQuYWRkT3JSZWJ1aWxkKGVkaXRvcik7XG4gICAgfVxuICB9XG4gIGlzQWN0aXZlKGVkaXRvcikge1xuICAgIHJldHVybiB0aGlzLiNhY3RpdmVFZGl0b3IgPT09IGVkaXRvcjtcbiAgfVxuICBnZXRBY3RpdmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2FjdGl2ZUVkaXRvcjtcbiAgfVxuICBnZXRNb2RlKCkge1xuICAgIHJldHVybiB0aGlzLiNtb2RlO1xuICB9XG4gIGdldCBpbWFnZU1hbmFnZXIoKSB7XG4gICAgcmV0dXJuICgwLCBfdXRpbC5zaGFkb3cpKHRoaXMsIFwiaW1hZ2VNYW5hZ2VyXCIsIG5ldyBJbWFnZU1hbmFnZXIoKSk7XG4gIH1cbn1cbmV4cG9ydHMuQW5ub3RhdGlvbkVkaXRvclVJTWFuYWdlciA9IEFubm90YXRpb25FZGl0b3JVSU1hbmFnZXI7XG5cbi8qKiovIH0pLFxuLyogNiAqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykgPT4ge1xuXG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xuZXhwb3J0cy5TdGF0VGltZXIgPSBleHBvcnRzLlJlbmRlcmluZ0NhbmNlbGxlZEV4Y2VwdGlvbiA9IGV4cG9ydHMuUGl4ZWxzUGVySW5jaCA9IGV4cG9ydHMuUGFnZVZpZXdwb3J0ID0gZXhwb3J0cy5QREZEYXRlU3RyaW5nID0gZXhwb3J0cy5ET01TdGFuZGFyZEZvbnREYXRhRmFjdG9yeSA9IGV4cG9ydHMuRE9NU1ZHRmFjdG9yeSA9IGV4cG9ydHMuRE9NRmlsdGVyRmFjdG9yeSA9IGV4cG9ydHMuRE9NQ2FudmFzRmFjdG9yeSA9IGV4cG9ydHMuRE9NQ01hcFJlYWRlckZhY3RvcnkgPSB2b2lkIDA7XG5leHBvcnRzLmRlcHJlY2F0ZWQgPSBkZXByZWNhdGVkO1xuZXhwb3J0cy5nZXRDb2xvclZhbHVlcyA9IGdldENvbG9yVmFsdWVzO1xuZXhwb3J0cy5nZXRDdXJyZW50VHJhbnNmb3JtID0gZ2V0Q3VycmVudFRyYW5zZm9ybTtcbmV4cG9ydHMuZ2V0Q3VycmVudFRyYW5zZm9ybUludmVyc2UgPSBnZXRDdXJyZW50VHJhbnNmb3JtSW52ZXJzZTtcbmV4cG9ydHMuZ2V0RmlsZW5hbWVGcm9tVXJsID0gZ2V0RmlsZW5hbWVGcm9tVXJsO1xuZXhwb3J0cy5nZXRQZGZGaWxlbmFtZUZyb21VcmwgPSBnZXRQZGZGaWxlbmFtZUZyb21Vcmw7XG5leHBvcnRzLmdldFJHQiA9IGdldFJHQjtcbmV4cG9ydHMuZ2V0WGZhUGFnZVZpZXdwb3J0ID0gZ2V0WGZhUGFnZVZpZXdwb3J0O1xuZXhwb3J0cy5pc0RhdGFTY2hlbWUgPSBpc0RhdGFTY2hlbWU7XG5leHBvcnRzLmlzUGRmRmlsZSA9IGlzUGRmRmlsZTtcbmV4cG9ydHMuaXNWYWxpZEZldGNoVXJsID0gaXNWYWxpZEZldGNoVXJsO1xuZXhwb3J0cy5sb2FkU2NyaXB0ID0gbG9hZFNjcmlwdDtcbmV4cG9ydHMubm9Db250ZXh0TWVudSA9IG5vQ29udGV4dE1lbnU7XG5leHBvcnRzLnNldExheWVyRGltZW5zaW9ucyA9IHNldExheWVyRGltZW5zaW9ucztcbnZhciBfYmFzZV9mYWN0b3J5ID0gX193X3BkZmpzX3JlcXVpcmVfXyg3KTtcbnZhciBfdXRpbCA9IF9fd19wZGZqc19yZXF1aXJlX18oMSk7XG5jb25zdCBTVkdfTlMgPSBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCI7XG5jbGFzcyBQaXhlbHNQZXJJbmNoIHtcbiAgc3RhdGljIENTUyA9IDk2LjA7XG4gIHN0YXRpYyBQREYgPSA3Mi4wO1xuICBzdGF0aWMgUERGX1RPX0NTU19VTklUUyA9IHRoaXMuQ1NTIC8gdGhpcy5QREY7XG59XG5leHBvcnRzLlBpeGVsc1BlckluY2ggPSBQaXhlbHNQZXJJbmNoO1xuY2xhc3MgRE9NRmlsdGVyRmFjdG9yeSBleHRlbmRzIF9iYXNlX2ZhY3RvcnkuQmFzZUZpbHRlckZhY3Rvcnkge1xuICAjX2NhY2hlO1xuICAjX2RlZnM7XG4gICNkb2NJZDtcbiAgI2RvY3VtZW50O1xuICAjaGNtRmlsdGVyO1xuICAjaGNtS2V5O1xuICAjaGNtVXJsO1xuICAjaGNtSGlnaGxpZ2h0RmlsdGVyO1xuICAjaGNtSGlnaGxpZ2h0S2V5O1xuICAjaGNtSGlnaGxpZ2h0VXJsO1xuICAjaWQgPSAwO1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgZG9jSWQsXG4gICAgb3duZXJEb2N1bWVudCA9IGdsb2JhbFRoaXMuZG9jdW1lbnRcbiAgfSA9IHt9KSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLiNkb2NJZCA9IGRvY0lkO1xuICAgIHRoaXMuI2RvY3VtZW50ID0gb3duZXJEb2N1bWVudDtcbiAgfVxuICBnZXQgI2NhY2hlKCkge1xuICAgIHJldHVybiB0aGlzLiNfY2FjaGUgfHw9IG5ldyBNYXAoKTtcbiAgfVxuICBnZXQgI2RlZnMoKSB7XG4gICAgaWYgKCF0aGlzLiNfZGVmcykge1xuICAgICAgY29uc3QgZGl2ID0gdGhpcy4jZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgc3R5bGVcbiAgICAgIH0gPSBkaXY7XG4gICAgICBzdHlsZS52aXNpYmlsaXR5ID0gXCJoaWRkZW5cIjtcbiAgICAgIHN0eWxlLmNvbnRhaW4gPSBcInN0cmljdFwiO1xuICAgICAgc3R5bGUud2lkdGggPSBzdHlsZS5oZWlnaHQgPSAwO1xuICAgICAgc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCI7XG4gICAgICBzdHlsZS50b3AgPSBzdHlsZS5sZWZ0ID0gMDtcbiAgICAgIHN0eWxlLnpJbmRleCA9IC0xO1xuICAgICAgY29uc3Qgc3ZnID0gdGhpcy4jZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFNWR19OUywgXCJzdmdcIik7XG4gICAgICBzdmcuc2V0QXR0cmlidXRlKFwid2lkdGhcIiwgMCk7XG4gICAgICBzdmcuc2V0QXR0cmlidXRlKFwiaGVpZ2h0XCIsIDApO1xuICAgICAgdGhpcy4jX2RlZnMgPSB0aGlzLiNkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoU1ZHX05TLCBcImRlZnNcIik7XG4gICAgICBkaXYuYXBwZW5kKHN2Zyk7XG4gICAgICBzdmcuYXBwZW5kKHRoaXMuI19kZWZzKTtcbiAgICAgIHRoaXMuI2RvY3VtZW50LmJvZHkuYXBwZW5kKGRpdik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLiNfZGVmcztcbiAgfVxuICBhZGRGaWx0ZXIobWFwcykge1xuICAgIGlmICghbWFwcykge1xuICAgICAgcmV0dXJuIFwibm9uZVwiO1xuICAgIH1cbiAgICBsZXQgdmFsdWUgPSB0aGlzLiNjYWNoZS5nZXQobWFwcyk7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGxldCB0YWJsZVIsIHRhYmxlRywgdGFibGVCLCBrZXk7XG4gICAgaWYgKG1hcHMubGVuZ3RoID09PSAxKSB7XG4gICAgICBjb25zdCBtYXBSID0gbWFwc1swXTtcbiAgICAgIGNvbnN0IGJ1ZmZlciA9IG5ldyBBcnJheSgyNTYpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAyNTY7IGkrKykge1xuICAgICAgICBidWZmZXJbaV0gPSBtYXBSW2ldIC8gMjU1O1xuICAgICAgfVxuICAgICAga2V5ID0gdGFibGVSID0gdGFibGVHID0gdGFibGVCID0gYnVmZmVyLmpvaW4oXCIsXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBbbWFwUiwgbWFwRywgbWFwQl0gPSBtYXBzO1xuICAgICAgY29uc3QgYnVmZmVyUiA9IG5ldyBBcnJheSgyNTYpO1xuICAgICAgY29uc3QgYnVmZmVyRyA9IG5ldyBBcnJheSgyNTYpO1xuICAgICAgY29uc3QgYnVmZmVyQiA9IG5ldyBBcnJheSgyNTYpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAyNTY7IGkrKykge1xuICAgICAgICBidWZmZXJSW2ldID0gbWFwUltpXSAvIDI1NTtcbiAgICAgICAgYnVmZmVyR1tpXSA9IG1hcEdbaV0gLyAyNTU7XG4gICAgICAgIGJ1ZmZlckJbaV0gPSBtYXBCW2ldIC8gMjU1O1xuICAgICAgfVxuICAgICAgdGFibGVSID0gYnVmZmVyUi5qb2luKFwiLFwiKTtcbiAgICAgIHRhYmxlRyA9IGJ1ZmZlckcuam9pbihcIixcIik7XG4gICAgICB0YWJsZUIgPSBidWZmZXJCLmpvaW4oXCIsXCIpO1xuICAgICAga2V5ID0gYCR7dGFibGVSfSR7dGFibGVHfSR7dGFibGVCfWA7XG4gICAgfVxuICAgIHZhbHVlID0gdGhpcy4jY2FjaGUuZ2V0KGtleSk7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICB0aGlzLiNjYWNoZS5zZXQobWFwcywgdmFsdWUpO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBjb25zdCBpZCA9IGBnXyR7dGhpcy4jZG9jSWR9X3RyYW5zZmVyX21hcF8ke3RoaXMuI2lkKyt9YDtcbiAgICBjb25zdCB1cmwgPSBgdXJsKCMke2lkfSlgO1xuICAgIHRoaXMuI2NhY2hlLnNldChtYXBzLCB1cmwpO1xuICAgIHRoaXMuI2NhY2hlLnNldChrZXksIHVybCk7XG4gICAgY29uc3QgZmlsdGVyID0gdGhpcy4jY3JlYXRlRmlsdGVyKGlkKTtcbiAgICB0aGlzLiNhZGRUcmFuc2Zlck1hcENvbnZlcnNpb24odGFibGVSLCB0YWJsZUcsIHRhYmxlQiwgZmlsdGVyKTtcbiAgICByZXR1cm4gdXJsO1xuICB9XG4gIGFkZEhDTUZpbHRlcihmZ0NvbG9yLCBiZ0NvbG9yKSB7XG4gICAgY29uc3Qga2V5ID0gYCR7ZmdDb2xvcn0tJHtiZ0NvbG9yfWA7XG4gICAgaWYgKHRoaXMuI2hjbUtleSA9PT0ga2V5KSB7XG4gICAgICByZXR1cm4gdGhpcy4jaGNtVXJsO1xuICAgIH1cbiAgICB0aGlzLiNoY21LZXkgPSBrZXk7XG4gICAgdGhpcy4jaGNtVXJsID0gXCJub25lXCI7XG4gICAgdGhpcy4jaGNtRmlsdGVyPy5yZW1vdmUoKTtcbiAgICBpZiAoIWZnQ29sb3IgfHwgIWJnQ29sb3IpIHtcbiAgICAgIHJldHVybiB0aGlzLiNoY21Vcmw7XG4gICAgfVxuICAgIGNvbnN0IGZnUkdCID0gdGhpcy4jZ2V0UkdCKGZnQ29sb3IpO1xuICAgIGZnQ29sb3IgPSBfdXRpbC5VdGlsLm1ha2VIZXhDb2xvciguLi5mZ1JHQik7XG4gICAgY29uc3QgYmdSR0IgPSB0aGlzLiNnZXRSR0IoYmdDb2xvcik7XG4gICAgYmdDb2xvciA9IF91dGlsLlV0aWwubWFrZUhleENvbG9yKC4uLmJnUkdCKTtcbiAgICB0aGlzLiNkZWZzLnN0eWxlLmNvbG9yID0gXCJcIjtcbiAgICBpZiAoZmdDb2xvciA9PT0gXCIjMDAwMDAwXCIgJiYgYmdDb2xvciA9PT0gXCIjZmZmZmZmXCIgfHwgZmdDb2xvciA9PT0gYmdDb2xvcikge1xuICAgICAgcmV0dXJuIHRoaXMuI2hjbVVybDtcbiAgICB9XG4gICAgY29uc3QgbWFwID0gbmV3IEFycmF5KDI1Nik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gMjU1OyBpKyspIHtcbiAgICAgIGNvbnN0IHggPSBpIC8gMjU1O1xuICAgICAgbWFwW2ldID0geCA8PSAwLjAzOTI4ID8geCAvIDEyLjkyIDogKCh4ICsgMC4wNTUpIC8gMS4wNTUpICoqIDIuNDtcbiAgICB9XG4gICAgY29uc3QgdGFibGUgPSBtYXAuam9pbihcIixcIik7XG4gICAgY29uc3QgaWQgPSBgZ18ke3RoaXMuI2RvY0lkfV9oY21fZmlsdGVyYDtcbiAgICBjb25zdCBmaWx0ZXIgPSB0aGlzLiNoY21IaWdobGlnaHRGaWx0ZXIgPSB0aGlzLiNjcmVhdGVGaWx0ZXIoaWQpO1xuICAgIHRoaXMuI2FkZFRyYW5zZmVyTWFwQ29udmVyc2lvbih0YWJsZSwgdGFibGUsIHRhYmxlLCBmaWx0ZXIpO1xuICAgIHRoaXMuI2FkZEdyYXlDb252ZXJzaW9uKGZpbHRlcik7XG4gICAgY29uc3QgZ2V0U3RlcHMgPSAoYywgbikgPT4ge1xuICAgICAgY29uc3Qgc3RhcnQgPSBmZ1JHQltjXSAvIDI1NTtcbiAgICAgIGNvbnN0IGVuZCA9IGJnUkdCW2NdIC8gMjU1O1xuICAgICAgY29uc3QgYXJyID0gbmV3IEFycmF5KG4gKyAxKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IG47IGkrKykge1xuICAgICAgICBhcnJbaV0gPSBzdGFydCArIGkgLyBuICogKGVuZCAtIHN0YXJ0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnIuam9pbihcIixcIik7XG4gICAgfTtcbiAgICB0aGlzLiNhZGRUcmFuc2Zlck1hcENvbnZlcnNpb24oZ2V0U3RlcHMoMCwgNSksIGdldFN0ZXBzKDEsIDUpLCBnZXRTdGVwcygyLCA1KSwgZmlsdGVyKTtcbiAgICB0aGlzLiNoY21VcmwgPSBgdXJsKCMke2lkfSlgO1xuICAgIHJldHVybiB0aGlzLiNoY21Vcmw7XG4gIH1cbiAgYWRkSGlnaGxpZ2h0SENNRmlsdGVyKGZnQ29sb3IsIGJnQ29sb3IsIG5ld0ZnQ29sb3IsIG5ld0JnQ29sb3IpIHtcbiAgICBjb25zdCBrZXkgPSBgJHtmZ0NvbG9yfS0ke2JnQ29sb3J9LSR7bmV3RmdDb2xvcn0tJHtuZXdCZ0NvbG9yfWA7XG4gICAgaWYgKHRoaXMuI2hjbUhpZ2hsaWdodEtleSA9PT0ga2V5KSB7XG4gICAgICByZXR1cm4gdGhpcy4jaGNtSGlnaGxpZ2h0VXJsO1xuICAgIH1cbiAgICB0aGlzLiNoY21IaWdobGlnaHRLZXkgPSBrZXk7XG4gICAgdGhpcy4jaGNtSGlnaGxpZ2h0VXJsID0gXCJub25lXCI7XG4gICAgdGhpcy4jaGNtSGlnaGxpZ2h0RmlsdGVyPy5yZW1vdmUoKTtcbiAgICBpZiAoIWZnQ29sb3IgfHwgIWJnQ29sb3IpIHtcbiAgICAgIHJldHVybiB0aGlzLiNoY21IaWdobGlnaHRVcmw7XG4gICAgfVxuICAgIGNvbnN0IFtmZ1JHQiwgYmdSR0JdID0gW2ZnQ29sb3IsIGJnQ29sb3JdLm1hcCh0aGlzLiNnZXRSR0IuYmluZCh0aGlzKSk7XG4gICAgbGV0IGZnR3JheSA9IE1hdGgucm91bmQoMC4yMTI2ICogZmdSR0JbMF0gKyAwLjcxNTIgKiBmZ1JHQlsxXSArIDAuMDcyMiAqIGZnUkdCWzJdKTtcbiAgICBsZXQgYmdHcmF5ID0gTWF0aC5yb3VuZCgwLjIxMjYgKiBiZ1JHQlswXSArIDAuNzE1MiAqIGJnUkdCWzFdICsgMC4wNzIyICogYmdSR0JbMl0pO1xuICAgIGxldCBbbmV3RmdSR0IsIG5ld0JnUkdCXSA9IFtuZXdGZ0NvbG9yLCBuZXdCZ0NvbG9yXS5tYXAodGhpcy4jZ2V0UkdCLmJpbmQodGhpcykpO1xuICAgIGlmIChiZ0dyYXkgPCBmZ0dyYXkpIHtcbiAgICAgIFtmZ0dyYXksIGJnR3JheSwgbmV3RmdSR0IsIG5ld0JnUkdCXSA9IFtiZ0dyYXksIGZnR3JheSwgbmV3QmdSR0IsIG5ld0ZnUkdCXTtcbiAgICB9XG4gICAgdGhpcy4jZGVmcy5zdHlsZS5jb2xvciA9IFwiXCI7XG4gICAgY29uc3QgZ2V0U3RlcHMgPSAoZmcsIGJnLCBuKSA9PiB7XG4gICAgICBjb25zdCBhcnIgPSBuZXcgQXJyYXkoMjU2KTtcbiAgICAgIGNvbnN0IHN0ZXAgPSAoYmdHcmF5IC0gZmdHcmF5KSAvIG47XG4gICAgICBjb25zdCBuZXdTdGFydCA9IGZnIC8gMjU1O1xuICAgICAgY29uc3QgbmV3U3RlcCA9IChiZyAtIGZnKSAvICgyNTUgKiBuKTtcbiAgICAgIGxldCBwcmV2ID0gMDtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IG47IGkrKykge1xuICAgICAgICBjb25zdCBrID0gTWF0aC5yb3VuZChmZ0dyYXkgKyBpICogc3RlcCk7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gbmV3U3RhcnQgKyBpICogbmV3U3RlcDtcbiAgICAgICAgZm9yIChsZXQgaiA9IHByZXY7IGogPD0gazsgaisrKSB7XG4gICAgICAgICAgYXJyW2pdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcHJldiA9IGsgKyAxO1xuICAgICAgfVxuICAgICAgZm9yIChsZXQgaSA9IHByZXY7IGkgPCAyNTY7IGkrKykge1xuICAgICAgICBhcnJbaV0gPSBhcnJbcHJldiAtIDFdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFyci5qb2luKFwiLFwiKTtcbiAgICB9O1xuICAgIGNvbnN0IGlkID0gYGdfJHt0aGlzLiNkb2NJZH1faGNtX2hpZ2hsaWdodF9maWx0ZXJgO1xuICAgIGNvbnN0IGZpbHRlciA9IHRoaXMuI2hjbUhpZ2hsaWdodEZpbHRlciA9IHRoaXMuI2NyZWF0ZUZpbHRlcihpZCk7XG4gICAgdGhpcy4jYWRkR3JheUNvbnZlcnNpb24oZmlsdGVyKTtcbiAgICB0aGlzLiNhZGRUcmFuc2Zlck1hcENvbnZlcnNpb24oZ2V0U3RlcHMobmV3RmdSR0JbMF0sIG5ld0JnUkdCWzBdLCA1KSwgZ2V0U3RlcHMobmV3RmdSR0JbMV0sIG5ld0JnUkdCWzFdLCA1KSwgZ2V0U3RlcHMobmV3RmdSR0JbMl0sIG5ld0JnUkdCWzJdLCA1KSwgZmlsdGVyKTtcbiAgICB0aGlzLiNoY21IaWdobGlnaHRVcmwgPSBgdXJsKCMke2lkfSlgO1xuICAgIHJldHVybiB0aGlzLiNoY21IaWdobGlnaHRVcmw7XG4gIH1cbiAgZGVzdHJveShrZWVwSENNID0gZmFsc2UpIHtcbiAgICBpZiAoa2VlcEhDTSAmJiAodGhpcy4jaGNtVXJsIHx8IHRoaXMuI2hjbUhpZ2hsaWdodFVybCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuI19kZWZzKSB7XG4gICAgICB0aGlzLiNfZGVmcy5wYXJlbnROb2RlLnBhcmVudE5vZGUucmVtb3ZlKCk7XG4gICAgICB0aGlzLiNfZGVmcyA9IG51bGw7XG4gICAgfVxuICAgIGlmICh0aGlzLiNfY2FjaGUpIHtcbiAgICAgIHRoaXMuI19jYWNoZS5jbGVhcigpO1xuICAgICAgdGhpcy4jX2NhY2hlID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy4jaWQgPSAwO1xuICB9XG4gICNhZGRHcmF5Q29udmVyc2lvbihmaWx0ZXIpIHtcbiAgICBjb25zdCBmZUNvbG9yTWF0cml4ID0gdGhpcy4jZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFNWR19OUywgXCJmZUNvbG9yTWF0cml4XCIpO1xuICAgIGZlQ29sb3JNYXRyaXguc2V0QXR0cmlidXRlKFwidHlwZVwiLCBcIm1hdHJpeFwiKTtcbiAgICBmZUNvbG9yTWF0cml4LnNldEF0dHJpYnV0ZShcInZhbHVlc1wiLCBcIjAuMjEyNiAwLjcxNTIgMC4wNzIyIDAgMCAwLjIxMjYgMC43MTUyIDAuMDcyMiAwIDAgMC4yMTI2IDAuNzE1MiAwLjA3MjIgMCAwIDAgMCAwIDEgMFwiKTtcbiAgICBmaWx0ZXIuYXBwZW5kKGZlQ29sb3JNYXRyaXgpO1xuICB9XG4gICNjcmVhdGVGaWx0ZXIoaWQpIHtcbiAgICBjb25zdCBmaWx0ZXIgPSB0aGlzLiNkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoU1ZHX05TLCBcImZpbHRlclwiKTtcbiAgICBmaWx0ZXIuc2V0QXR0cmlidXRlKFwiY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzXCIsIFwic1JHQlwiKTtcbiAgICBmaWx0ZXIuc2V0QXR0cmlidXRlKFwiaWRcIiwgaWQpO1xuICAgIHRoaXMuI2RlZnMuYXBwZW5kKGZpbHRlcik7XG4gICAgcmV0dXJuIGZpbHRlcjtcbiAgfVxuICAjYXBwZW5kRmVGdW5jKGZlQ29tcG9uZW50VHJhbnNmZXIsIGZ1bmMsIHRhYmxlKSB7XG4gICAgY29uc3QgZmVGdW5jID0gdGhpcy4jZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFNWR19OUywgZnVuYyk7XG4gICAgZmVGdW5jLnNldEF0dHJpYnV0ZShcInR5cGVcIiwgXCJkaXNjcmV0ZVwiKTtcbiAgICBmZUZ1bmMuc2V0QXR0cmlidXRlKFwidGFibGVWYWx1ZXNcIiwgdGFibGUpO1xuICAgIGZlQ29tcG9uZW50VHJhbnNmZXIuYXBwZW5kKGZlRnVuYyk7XG4gIH1cbiAgI2FkZFRyYW5zZmVyTWFwQ29udmVyc2lvbihyVGFibGUsIGdUYWJsZSwgYlRhYmxlLCBmaWx0ZXIpIHtcbiAgICBjb25zdCBmZUNvbXBvbmVudFRyYW5zZmVyID0gdGhpcy4jZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFNWR19OUywgXCJmZUNvbXBvbmVudFRyYW5zZmVyXCIpO1xuICAgIGZpbHRlci5hcHBlbmQoZmVDb21wb25lbnRUcmFuc2Zlcik7XG4gICAgdGhpcy4jYXBwZW5kRmVGdW5jKGZlQ29tcG9uZW50VHJhbnNmZXIsIFwiZmVGdW5jUlwiLCByVGFibGUpO1xuICAgIHRoaXMuI2FwcGVuZEZlRnVuYyhmZUNvbXBvbmVudFRyYW5zZmVyLCBcImZlRnVuY0dcIiwgZ1RhYmxlKTtcbiAgICB0aGlzLiNhcHBlbmRGZUZ1bmMoZmVDb21wb25lbnRUcmFuc2ZlciwgXCJmZUZ1bmNCXCIsIGJUYWJsZSk7XG4gIH1cbiAgI2dldFJHQihjb2xvcikge1xuICAgIHRoaXMuI2RlZnMuc3R5bGUuY29sb3IgPSBjb2xvcjtcbiAgICByZXR1cm4gZ2V0UkdCKGdldENvbXB1dGVkU3R5bGUodGhpcy4jZGVmcykuZ2V0UHJvcGVydHlWYWx1ZShcImNvbG9yXCIpKTtcbiAgfVxufVxuZXhwb3J0cy5ET01GaWx0ZXJGYWN0b3J5ID0gRE9NRmlsdGVyRmFjdG9yeTtcbmNsYXNzIERPTUNhbnZhc0ZhY3RvcnkgZXh0ZW5kcyBfYmFzZV9mYWN0b3J5LkJhc2VDYW52YXNGYWN0b3J5IHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIG93bmVyRG9jdW1lbnQgPSBnbG9iYWxUaGlzLmRvY3VtZW50XG4gIH0gPSB7fSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5fZG9jdW1lbnQgPSBvd25lckRvY3VtZW50O1xuICB9XG4gIF9jcmVhdGVDYW52YXMod2lkdGgsIGhlaWdodCkge1xuICAgIGNvbnN0IGNhbnZhcyA9IHRoaXMuX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gICAgY2FudmFzLndpZHRoID0gd2lkdGg7XG4gICAgY2FudmFzLmhlaWdodCA9IGhlaWdodDtcbiAgICByZXR1cm4gY2FudmFzO1xuICB9XG59XG5leHBvcnRzLkRPTUNhbnZhc0ZhY3RvcnkgPSBET01DYW52YXNGYWN0b3J5O1xuYXN5bmMgZnVuY3Rpb24gZmV0Y2hEYXRhKHVybCwgYXNUeXBlZEFycmF5ID0gZmFsc2UpIHtcbiAgaWYgKGlzVmFsaWRGZXRjaFVybCh1cmwsIGRvY3VtZW50LmJhc2VVUkkpKSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwpO1xuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihyZXNwb25zZS5zdGF0dXNUZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIGFzVHlwZWRBcnJheSA/IG5ldyBVaW50OEFycmF5KGF3YWl0IHJlc3BvbnNlLmFycmF5QnVmZmVyKCkpIDogKDAsIF91dGlsLnN0cmluZ1RvQnl0ZXMpKGF3YWl0IHJlc3BvbnNlLnRleHQoKSk7XG4gIH1cbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBjb25zdCByZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgcmVxdWVzdC5vcGVuKFwiR0VUXCIsIHVybCwgdHJ1ZSk7XG4gICAgaWYgKGFzVHlwZWRBcnJheSkge1xuICAgICAgcmVxdWVzdC5yZXNwb25zZVR5cGUgPSBcImFycmF5YnVmZmVyXCI7XG4gICAgfVxuICAgIHJlcXVlc3Qub25yZWFkeXN0YXRlY2hhbmdlID0gKCkgPT4ge1xuICAgICAgaWYgKHJlcXVlc3QucmVhZHlTdGF0ZSAhPT0gWE1MSHR0cFJlcXVlc3QuRE9ORSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAocmVxdWVzdC5zdGF0dXMgPT09IDIwMCB8fCByZXF1ZXN0LnN0YXR1cyA9PT0gMCkge1xuICAgICAgICBsZXQgZGF0YTtcbiAgICAgICAgaWYgKGFzVHlwZWRBcnJheSAmJiByZXF1ZXN0LnJlc3BvbnNlKSB7XG4gICAgICAgICAgZGF0YSA9IG5ldyBVaW50OEFycmF5KHJlcXVlc3QucmVzcG9uc2UpO1xuICAgICAgICB9IGVsc2UgaWYgKCFhc1R5cGVkQXJyYXkgJiYgcmVxdWVzdC5yZXNwb25zZVRleHQpIHtcbiAgICAgICAgICBkYXRhID0gKDAsIF91dGlsLnN0cmluZ1RvQnl0ZXMpKHJlcXVlc3QucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgIHJlc29sdmUoZGF0YSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZWplY3QobmV3IEVycm9yKHJlcXVlc3Quc3RhdHVzVGV4dCkpO1xuICAgIH07XG4gICAgcmVxdWVzdC5zZW5kKG51bGwpO1xuICB9KTtcbn1cbmNsYXNzIERPTUNNYXBSZWFkZXJGYWN0b3J5IGV4dGVuZHMgX2Jhc2VfZmFjdG9yeS5CYXNlQ01hcFJlYWRlckZhY3Rvcnkge1xuICBfZmV0Y2hEYXRhKHVybCwgY29tcHJlc3Npb25UeXBlKSB7XG4gICAgcmV0dXJuIGZldGNoRGF0YSh1cmwsIHRoaXMuaXNDb21wcmVzc2VkKS50aGVuKGRhdGEgPT4ge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY01hcERhdGE6IGRhdGEsXG4gICAgICAgIGNvbXByZXNzaW9uVHlwZVxuICAgICAgfTtcbiAgICB9KTtcbiAgfVxufVxuZXhwb3J0cy5ET01DTWFwUmVhZGVyRmFjdG9yeSA9IERPTUNNYXBSZWFkZXJGYWN0b3J5O1xuY2xhc3MgRE9NU3RhbmRhcmRGb250RGF0YUZhY3RvcnkgZXh0ZW5kcyBfYmFzZV9mYWN0b3J5LkJhc2VTdGFuZGFyZEZvbnREYXRhRmFjdG9yeSB7XG4gIF9mZXRjaERhdGEodXJsKSB7XG4gICAgcmV0dXJuIGZldGNoRGF0YSh1cmwsIHRydWUpO1xuICB9XG59XG5leHBvcnRzLkRPTVN0YW5kYXJkRm9udERhdGFGYWN0b3J5ID0gRE9NU3RhbmRhcmRGb250RGF0YUZhY3Rvcnk7XG5jbGFzcyBET01TVkdGYWN0b3J5IGV4dGVuZHMgX2Jhc2VfZmFjdG9yeS5CYXNlU1ZHRmFjdG9yeSB7XG4gIF9jcmVhdGVTVkcodHlwZSkge1xuICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoU1ZHX05TLCB0eXBlKTtcbiAgfVxufVxuZXhwb3J0cy5ET01TVkdGYWN0b3J5ID0gRE9NU1ZHRmFjdG9yeTtcbmNsYXNzIFBhZ2VWaWV3cG9ydCB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICB2aWV3Qm94LFxuICAgIHNjYWxlLFxuICAgIHJvdGF0aW9uLFxuICAgIG9mZnNldFggPSAwLFxuICAgIG9mZnNldFkgPSAwLFxuICAgIGRvbnRGbGlwID0gZmFsc2VcbiAgfSkge1xuICAgIHRoaXMudmlld0JveCA9IHZpZXdCb3g7XG4gICAgdGhpcy5zY2FsZSA9IHNjYWxlO1xuICAgIHRoaXMucm90YXRpb24gPSByb3RhdGlvbjtcbiAgICB0aGlzLm9mZnNldFggPSBvZmZzZXRYO1xuICAgIHRoaXMub2Zmc2V0WSA9IG9mZnNldFk7XG4gICAgY29uc3QgY2VudGVyWCA9ICh2aWV3Qm94WzJdICsgdmlld0JveFswXSkgLyAyO1xuICAgIGNvbnN0IGNlbnRlclkgPSAodmlld0JveFszXSArIHZpZXdCb3hbMV0pIC8gMjtcbiAgICBsZXQgcm90YXRlQSwgcm90YXRlQiwgcm90YXRlQywgcm90YXRlRDtcbiAgICByb3RhdGlvbiAlPSAzNjA7XG4gICAgaWYgKHJvdGF0aW9uIDwgMCkge1xuICAgICAgcm90YXRpb24gKz0gMzYwO1xuICAgIH1cbiAgICBzd2l0Y2ggKHJvdGF0aW9uKSB7XG4gICAgICBjYXNlIDE4MDpcbiAgICAgICAgcm90YXRlQSA9IC0xO1xuICAgICAgICByb3RhdGVCID0gMDtcbiAgICAgICAgcm90YXRlQyA9IDA7XG4gICAgICAgIHJvdGF0ZUQgPSAxO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgOTA6XG4gICAgICAgIHJvdGF0ZUEgPSAwO1xuICAgICAgICByb3RhdGVCID0gMTtcbiAgICAgICAgcm90YXRlQyA9IDE7XG4gICAgICAgIHJvdGF0ZUQgPSAwO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjcwOlxuICAgICAgICByb3RhdGVBID0gMDtcbiAgICAgICAgcm90YXRlQiA9IC0xO1xuICAgICAgICByb3RhdGVDID0gLTE7XG4gICAgICAgIHJvdGF0ZUQgPSAwO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgcm90YXRlQSA9IDE7XG4gICAgICAgIHJvdGF0ZUIgPSAwO1xuICAgICAgICByb3RhdGVDID0gMDtcbiAgICAgICAgcm90YXRlRCA9IC0xO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBhZ2VWaWV3cG9ydDogSW52YWxpZCByb3RhdGlvbiwgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDkwIGRlZ3JlZXMuXCIpO1xuICAgIH1cbiAgICBpZiAoZG9udEZsaXApIHtcbiAgICAgIHJvdGF0ZUMgPSAtcm90YXRlQztcbiAgICAgIHJvdGF0ZUQgPSAtcm90YXRlRDtcbiAgICB9XG4gICAgbGV0IG9mZnNldENhbnZhc1gsIG9mZnNldENhbnZhc1k7XG4gICAgbGV0IHdpZHRoLCBoZWlnaHQ7XG4gICAgaWYgKHJvdGF0ZUEgPT09IDApIHtcbiAgICAgIG9mZnNldENhbnZhc1ggPSBNYXRoLmFicyhjZW50ZXJZIC0gdmlld0JveFsxXSkgKiBzY2FsZSArIG9mZnNldFg7XG4gICAgICBvZmZzZXRDYW52YXNZID0gTWF0aC5hYnMoY2VudGVyWCAtIHZpZXdCb3hbMF0pICogc2NhbGUgKyBvZmZzZXRZO1xuICAgICAgd2lkdGggPSAodmlld0JveFszXSAtIHZpZXdCb3hbMV0pICogc2NhbGU7XG4gICAgICBoZWlnaHQgPSAodmlld0JveFsyXSAtIHZpZXdCb3hbMF0pICogc2NhbGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9mZnNldENhbnZhc1ggPSBNYXRoLmFicyhjZW50ZXJYIC0gdmlld0JveFswXSkgKiBzY2FsZSArIG9mZnNldFg7XG4gICAgICBvZmZzZXRDYW52YXNZID0gTWF0aC5hYnMoY2VudGVyWSAtIHZpZXdCb3hbMV0pICogc2NhbGUgKyBvZmZzZXRZO1xuICAgICAgd2lkdGggPSAodmlld0JveFsyXSAtIHZpZXdCb3hbMF0pICogc2NhbGU7XG4gICAgICBoZWlnaHQgPSAodmlld0JveFszXSAtIHZpZXdCb3hbMV0pICogc2NhbGU7XG4gICAgfVxuICAgIHRoaXMudHJhbnNmb3JtID0gW3JvdGF0ZUEgKiBzY2FsZSwgcm90YXRlQiAqIHNjYWxlLCByb3RhdGVDICogc2NhbGUsIHJvdGF0ZUQgKiBzY2FsZSwgb2Zmc2V0Q2FudmFzWCAtIHJvdGF0ZUEgKiBzY2FsZSAqIGNlbnRlclggLSByb3RhdGVDICogc2NhbGUgKiBjZW50ZXJZLCBvZmZzZXRDYW52YXNZIC0gcm90YXRlQiAqIHNjYWxlICogY2VudGVyWCAtIHJvdGF0ZUQgKiBzY2FsZSAqIGNlbnRlclldO1xuICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgfVxuICBnZXQgcmF3RGltcygpIHtcbiAgICBjb25zdCB7XG4gICAgICB2aWV3Qm94XG4gICAgfSA9IHRoaXM7XG4gICAgcmV0dXJuICgwLCBfdXRpbC5zaGFkb3cpKHRoaXMsIFwicmF3RGltc1wiLCB7XG4gICAgICBwYWdlV2lkdGg6IHZpZXdCb3hbMl0gLSB2aWV3Qm94WzBdLFxuICAgICAgcGFnZUhlaWdodDogdmlld0JveFszXSAtIHZpZXdCb3hbMV0sXG4gICAgICBwYWdlWDogdmlld0JveFswXSxcbiAgICAgIHBhZ2VZOiB2aWV3Qm94WzFdXG4gICAgfSk7XG4gIH1cbiAgY2xvbmUoe1xuICAgIHNjYWxlID0gdGhpcy5zY2FsZSxcbiAgICByb3RhdGlvbiA9IHRoaXMucm90YXRpb24sXG4gICAgb2Zmc2V0WCA9IHRoaXMub2Zmc2V0WCxcbiAgICBvZmZzZXRZID0gdGhpcy5vZmZzZXRZLFxuICAgIGRvbnRGbGlwID0gZmFsc2VcbiAgfSA9IHt9KSB7XG4gICAgcmV0dXJuIG5ldyBQYWdlVmlld3BvcnQoe1xuICAgICAgdmlld0JveDogdGhpcy52aWV3Qm94LnNsaWNlKCksXG4gICAgICBzY2FsZSxcbiAgICAgIHJvdGF0aW9uLFxuICAgICAgb2Zmc2V0WCxcbiAgICAgIG9mZnNldFksXG4gICAgICBkb250RmxpcFxuICAgIH0pO1xuICB9XG4gIGNvbnZlcnRUb1ZpZXdwb3J0UG9pbnQoeCwgeSkge1xuICAgIHJldHVybiBfdXRpbC5VdGlsLmFwcGx5VHJhbnNmb3JtKFt4LCB5XSwgdGhpcy50cmFuc2Zvcm0pO1xuICB9XG4gIGNvbnZlcnRUb1ZpZXdwb3J0UmVjdGFuZ2xlKHJlY3QpIHtcbiAgICBjb25zdCB0b3BMZWZ0ID0gX3V0aWwuVXRpbC5hcHBseVRyYW5zZm9ybShbcmVjdFswXSwgcmVjdFsxXV0sIHRoaXMudHJhbnNmb3JtKTtcbiAgICBjb25zdCBib3R0b21SaWdodCA9IF91dGlsLlV0aWwuYXBwbHlUcmFuc2Zvcm0oW3JlY3RbMl0sIHJlY3RbM11dLCB0aGlzLnRyYW5zZm9ybSk7XG4gICAgcmV0dXJuIFt0b3BMZWZ0WzBdLCB0b3BMZWZ0WzFdLCBib3R0b21SaWdodFswXSwgYm90dG9tUmlnaHRbMV1dO1xuICB9XG4gIGNvbnZlcnRUb1BkZlBvaW50KHgsIHkpIHtcbiAgICByZXR1cm4gX3V0aWwuVXRpbC5hcHBseUludmVyc2VUcmFuc2Zvcm0oW3gsIHldLCB0aGlzLnRyYW5zZm9ybSk7XG4gIH1cbn1cbmV4cG9ydHMuUGFnZVZpZXdwb3J0ID0gUGFnZVZpZXdwb3J0O1xuY2xhc3MgUmVuZGVyaW5nQ2FuY2VsbGVkRXhjZXB0aW9uIGV4dGVuZHMgX3V0aWwuQmFzZUV4Y2VwdGlvbiB7XG4gIGNvbnN0cnVjdG9yKG1zZywgZXh0cmFEZWxheSA9IDApIHtcbiAgICBzdXBlcihtc2csIFwiUmVuZGVyaW5nQ2FuY2VsbGVkRXhjZXB0aW9uXCIpO1xuICAgIHRoaXMuZXh0cmFEZWxheSA9IGV4dHJhRGVsYXk7XG4gIH1cbn1cbmV4cG9ydHMuUmVuZGVyaW5nQ2FuY2VsbGVkRXhjZXB0aW9uID0gUmVuZGVyaW5nQ2FuY2VsbGVkRXhjZXB0aW9uO1xuZnVuY3Rpb24gaXNEYXRhU2NoZW1lKHVybCkge1xuICBjb25zdCBpaSA9IHVybC5sZW5ndGg7XG4gIGxldCBpID0gMDtcbiAgd2hpbGUgKGkgPCBpaSAmJiB1cmxbaV0udHJpbSgpID09PSBcIlwiKSB7XG4gICAgaSsrO1xuICB9XG4gIHJldHVybiB1cmwuc3Vic3RyaW5nKGksIGkgKyA1KS50b0xvd2VyQ2FzZSgpID09PSBcImRhdGE6XCI7XG59XG5mdW5jdGlvbiBpc1BkZkZpbGUoZmlsZW5hbWUpIHtcbiAgcmV0dXJuIHR5cGVvZiBmaWxlbmFtZSA9PT0gXCJzdHJpbmdcIiAmJiAvXFwucGRmJC9pLnRlc3QoZmlsZW5hbWUpO1xufVxuZnVuY3Rpb24gZ2V0RmlsZW5hbWVGcm9tVXJsKHVybCwgb25seVN0cmlwUGF0aCA9IGZhbHNlKSB7XG4gIGlmICghb25seVN0cmlwUGF0aCkge1xuICAgIFt1cmxdID0gdXJsLnNwbGl0KC9bIz9dLywgMSk7XG4gIH1cbiAgcmV0dXJuIHVybC5zdWJzdHJpbmcodXJsLmxhc3RJbmRleE9mKFwiL1wiKSArIDEpO1xufVxuZnVuY3Rpb24gZ2V0UGRmRmlsZW5hbWVGcm9tVXJsKHVybCwgZGVmYXVsdEZpbGVuYW1lID0gXCJkb2N1bWVudC5wZGZcIikge1xuICBpZiAodHlwZW9mIHVybCAhPT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBkZWZhdWx0RmlsZW5hbWU7XG4gIH1cbiAgaWYgKGlzRGF0YVNjaGVtZSh1cmwpKSB7XG4gICAgKDAsIF91dGlsLndhcm4pKCdnZXRQZGZGaWxlbmFtZUZyb21Vcmw6IGlnbm9yZSBcImRhdGE6XCItVVJMIGZvciBwZXJmb3JtYW5jZSByZWFzb25zLicpO1xuICAgIHJldHVybiBkZWZhdWx0RmlsZW5hbWU7XG4gIH1cbiAgY29uc3QgcmVVUkkgPSAvXig/Oig/OlteOl0rOik/XFwvXFwvW14vXSspPyhbXj8jXSopKFxcP1teI10qKT8oIy4qKT8kLztcbiAgY29uc3QgcmVGaWxlbmFtZSA9IC9bXi8/Iz1dK1xcLnBkZlxcYig/IS4qXFwucGRmXFxiKS9pO1xuICBjb25zdCBzcGxpdFVSSSA9IHJlVVJJLmV4ZWModXJsKTtcbiAgbGV0IHN1Z2dlc3RlZEZpbGVuYW1lID0gcmVGaWxlbmFtZS5leGVjKHNwbGl0VVJJWzFdKSB8fCByZUZpbGVuYW1lLmV4ZWMoc3BsaXRVUklbMl0pIHx8IHJlRmlsZW5hbWUuZXhlYyhzcGxpdFVSSVszXSk7XG4gIGlmIChzdWdnZXN0ZWRGaWxlbmFtZSkge1xuICAgIHN1Z2dlc3RlZEZpbGVuYW1lID0gc3VnZ2VzdGVkRmlsZW5hbWVbMF07XG4gICAgaWYgKHN1Z2dlc3RlZEZpbGVuYW1lLmluY2x1ZGVzKFwiJVwiKSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgc3VnZ2VzdGVkRmlsZW5hbWUgPSByZUZpbGVuYW1lLmV4ZWMoZGVjb2RlVVJJQ29tcG9uZW50KHN1Z2dlc3RlZEZpbGVuYW1lKSlbMF07XG4gICAgICB9IGNhdGNoIHt9XG4gICAgfVxuICB9XG4gIHJldHVybiBzdWdnZXN0ZWRGaWxlbmFtZSB8fCBkZWZhdWx0RmlsZW5hbWU7XG59XG5jbGFzcyBTdGF0VGltZXIge1xuICBzdGFydGVkID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgdGltZXMgPSBbXTtcbiAgdGltZShuYW1lKSB7XG4gICAgaWYgKG5hbWUgaW4gdGhpcy5zdGFydGVkKSB7XG4gICAgICAoMCwgX3V0aWwud2FybikoYFRpbWVyIGlzIGFscmVhZHkgcnVubmluZyBmb3IgJHtuYW1lfWApO1xuICAgIH1cbiAgICB0aGlzLnN0YXJ0ZWRbbmFtZV0gPSBEYXRlLm5vdygpO1xuICB9XG4gIHRpbWVFbmQobmFtZSkge1xuICAgIGlmICghKG5hbWUgaW4gdGhpcy5zdGFydGVkKSkge1xuICAgICAgKDAsIF91dGlsLndhcm4pKGBUaW1lciBoYXMgbm90IGJlZW4gc3RhcnRlZCBmb3IgJHtuYW1lfWApO1xuICAgIH1cbiAgICB0aGlzLnRpbWVzLnB1c2goe1xuICAgICAgbmFtZSxcbiAgICAgIHN0YXJ0OiB0aGlzLnN0YXJ0ZWRbbmFtZV0sXG4gICAgICBlbmQ6IERhdGUubm93KClcbiAgICB9KTtcbiAgICBkZWxldGUgdGhpcy5zdGFydGVkW25hbWVdO1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIGNvbnN0IG91dEJ1ZiA9IFtdO1xuICAgIGxldCBsb25nZXN0ID0gMDtcbiAgICBmb3IgKGNvbnN0IHtcbiAgICAgIG5hbWVcbiAgICB9IG9mIHRoaXMudGltZXMpIHtcbiAgICAgIGxvbmdlc3QgPSBNYXRoLm1heChuYW1lLmxlbmd0aCwgbG9uZ2VzdCk7XG4gICAgfVxuICAgIGZvciAoY29uc3Qge1xuICAgICAgbmFtZSxcbiAgICAgIHN0YXJ0LFxuICAgICAgZW5kXG4gICAgfSBvZiB0aGlzLnRpbWVzKSB7XG4gICAgICBvdXRCdWYucHVzaChgJHtuYW1lLnBhZEVuZChsb25nZXN0KX0gJHtlbmQgLSBzdGFydH1tc1xcbmApO1xuICAgIH1cbiAgICByZXR1cm4gb3V0QnVmLmpvaW4oXCJcIik7XG4gIH1cbn1cbmV4cG9ydHMuU3RhdFRpbWVyID0gU3RhdFRpbWVyO1xuZnVuY3Rpb24gaXNWYWxpZEZldGNoVXJsKHVybCwgYmFzZVVybCkge1xuICB0cnkge1xuICAgIGNvbnN0IHtcbiAgICAgIHByb3RvY29sXG4gICAgfSA9IGJhc2VVcmwgPyBuZXcgVVJMKHVybCwgYmFzZVVybCkgOiBuZXcgVVJMKHVybCk7XG4gICAgcmV0dXJuIHByb3RvY29sID09PSBcImh0dHA6XCIgfHwgcHJvdG9jb2wgPT09IFwiaHR0cHM6XCI7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuZnVuY3Rpb24gbm9Db250ZXh0TWVudShlKSB7XG4gIGUucHJldmVudERlZmF1bHQoKTtcbn1cbmZ1bmN0aW9uIGxvYWRTY3JpcHQoc3JjLCByZW1vdmVTY3JpcHRFbGVtZW50ID0gZmFsc2UpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBjb25zdCBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpO1xuICAgIHNjcmlwdC5zcmMgPSBzcmM7XG4gICAgc2NyaXB0Lm9ubG9hZCA9IGZ1bmN0aW9uIChldnQpIHtcbiAgICAgIGlmIChyZW1vdmVTY3JpcHRFbGVtZW50KSB7XG4gICAgICAgIHNjcmlwdC5yZW1vdmUoKTtcbiAgICAgIH1cbiAgICAgIHJlc29sdmUoZXZ0KTtcbiAgICB9O1xuICAgIHNjcmlwdC5vbmVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmVqZWN0KG5ldyBFcnJvcihgQ2Fubm90IGxvYWQgc2NyaXB0IGF0OiAke3NjcmlwdC5zcmN9YCkpO1xuICAgIH07XG4gICAgKGRvY3VtZW50LmhlYWQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KS5hcHBlbmQoc2NyaXB0KTtcbiAgfSk7XG59XG5mdW5jdGlvbiBkZXByZWNhdGVkKGRldGFpbHMpIHtcbiAgY29uc29sZS5sb2coXCJEZXByZWNhdGVkIEFQSSB1c2FnZTogXCIgKyBkZXRhaWxzKTtcbn1cbmxldCBwZGZEYXRlU3RyaW5nUmVnZXg7XG5jbGFzcyBQREZEYXRlU3RyaW5nIHtcbiAgc3RhdGljIHRvRGF0ZU9iamVjdChpbnB1dCkge1xuICAgIGlmICghaW5wdXQgfHwgdHlwZW9mIGlucHV0ICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcGRmRGF0ZVN0cmluZ1JlZ2V4IHx8PSBuZXcgUmVnRXhwKFwiXkQ6XCIgKyBcIihcXFxcZHs0fSlcIiArIFwiKFxcXFxkezJ9KT9cIiArIFwiKFxcXFxkezJ9KT9cIiArIFwiKFxcXFxkezJ9KT9cIiArIFwiKFxcXFxkezJ9KT9cIiArIFwiKFxcXFxkezJ9KT9cIiArIFwiKFtafCt8LV0pP1wiICsgXCIoXFxcXGR7Mn0pP1wiICsgXCInP1wiICsgXCIoXFxcXGR7Mn0pP1wiICsgXCInP1wiKTtcbiAgICBjb25zdCBtYXRjaGVzID0gcGRmRGF0ZVN0cmluZ1JlZ2V4LmV4ZWMoaW5wdXQpO1xuICAgIGlmICghbWF0Y2hlcykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHllYXIgPSBwYXJzZUludChtYXRjaGVzWzFdLCAxMCk7XG4gICAgbGV0IG1vbnRoID0gcGFyc2VJbnQobWF0Y2hlc1syXSwgMTApO1xuICAgIG1vbnRoID0gbW9udGggPj0gMSAmJiBtb250aCA8PSAxMiA/IG1vbnRoIC0gMSA6IDA7XG4gICAgbGV0IGRheSA9IHBhcnNlSW50KG1hdGNoZXNbM10sIDEwKTtcbiAgICBkYXkgPSBkYXkgPj0gMSAmJiBkYXkgPD0gMzEgPyBkYXkgOiAxO1xuICAgIGxldCBob3VyID0gcGFyc2VJbnQobWF0Y2hlc1s0XSwgMTApO1xuICAgIGhvdXIgPSBob3VyID49IDAgJiYgaG91ciA8PSAyMyA/IGhvdXIgOiAwO1xuICAgIGxldCBtaW51dGUgPSBwYXJzZUludChtYXRjaGVzWzVdLCAxMCk7XG4gICAgbWludXRlID0gbWludXRlID49IDAgJiYgbWludXRlIDw9IDU5ID8gbWludXRlIDogMDtcbiAgICBsZXQgc2Vjb25kID0gcGFyc2VJbnQobWF0Y2hlc1s2XSwgMTApO1xuICAgIHNlY29uZCA9IHNlY29uZCA+PSAwICYmIHNlY29uZCA8PSA1OSA/IHNlY29uZCA6IDA7XG4gICAgY29uc3QgdW5pdmVyc2FsVGltZVJlbGF0aW9uID0gbWF0Y2hlc1s3XSB8fCBcIlpcIjtcbiAgICBsZXQgb2Zmc2V0SG91ciA9IHBhcnNlSW50KG1hdGNoZXNbOF0sIDEwKTtcbiAgICBvZmZzZXRIb3VyID0gb2Zmc2V0SG91ciA+PSAwICYmIG9mZnNldEhvdXIgPD0gMjMgPyBvZmZzZXRIb3VyIDogMDtcbiAgICBsZXQgb2Zmc2V0TWludXRlID0gcGFyc2VJbnQobWF0Y2hlc1s5XSwgMTApIHx8IDA7XG4gICAgb2Zmc2V0TWludXRlID0gb2Zmc2V0TWludXRlID49IDAgJiYgb2Zmc2V0TWludXRlIDw9IDU5ID8gb2Zmc2V0TWludXRlIDogMDtcbiAgICBpZiAodW5pdmVyc2FsVGltZVJlbGF0aW9uID09PSBcIi1cIikge1xuICAgICAgaG91ciArPSBvZmZzZXRIb3VyO1xuICAgICAgbWludXRlICs9IG9mZnNldE1pbnV0ZTtcbiAgICB9IGVsc2UgaWYgKHVuaXZlcnNhbFRpbWVSZWxhdGlvbiA9PT0gXCIrXCIpIHtcbiAgICAgIGhvdXIgLT0gb2Zmc2V0SG91cjtcbiAgICAgIG1pbnV0ZSAtPSBvZmZzZXRNaW51dGU7XG4gICAgfVxuICAgIHJldHVybiBuZXcgRGF0ZShEYXRlLlVUQyh5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCkpO1xuICB9XG59XG5leHBvcnRzLlBERkRhdGVTdHJpbmcgPSBQREZEYXRlU3RyaW5nO1xuZnVuY3Rpb24gZ2V0WGZhUGFnZVZpZXdwb3J0KHhmYVBhZ2UsIHtcbiAgc2NhbGUgPSAxLFxuICByb3RhdGlvbiA9IDBcbn0pIHtcbiAgY29uc3Qge1xuICAgIHdpZHRoLFxuICAgIGhlaWdodFxuICB9ID0geGZhUGFnZS5hdHRyaWJ1dGVzLnN0eWxlO1xuICBjb25zdCB2aWV3Qm94ID0gWzAsIDAsIHBhcnNlSW50KHdpZHRoKSwgcGFyc2VJbnQoaGVpZ2h0KV07XG4gIHJldHVybiBuZXcgUGFnZVZpZXdwb3J0KHtcbiAgICB2aWV3Qm94LFxuICAgIHNjYWxlLFxuICAgIHJvdGF0aW9uXG4gIH0pO1xufVxuZnVuY3Rpb24gZ2V0UkdCKGNvbG9yKSB7XG4gIGlmIChjb2xvci5zdGFydHNXaXRoKFwiI1wiKSkge1xuICAgIGNvbnN0IGNvbG9yUkdCID0gcGFyc2VJbnQoY29sb3Iuc2xpY2UoMSksIDE2KTtcbiAgICByZXR1cm4gWyhjb2xvclJHQiAmIDB4ZmYwMDAwKSA+PiAxNiwgKGNvbG9yUkdCICYgMHgwMGZmMDApID4+IDgsIGNvbG9yUkdCICYgMHgwMDAwZmZdO1xuICB9XG4gIGlmIChjb2xvci5zdGFydHNXaXRoKFwicmdiKFwiKSkge1xuICAgIHJldHVybiBjb2xvci5zbGljZSg0LCAtMSkuc3BsaXQoXCIsXCIpLm1hcCh4ID0+IHBhcnNlSW50KHgpKTtcbiAgfVxuICBpZiAoY29sb3Iuc3RhcnRzV2l0aChcInJnYmEoXCIpKSB7XG4gICAgcmV0dXJuIGNvbG9yLnNsaWNlKDUsIC0xKS5zcGxpdChcIixcIikubWFwKHggPT4gcGFyc2VJbnQoeCkpLnNsaWNlKDAsIDMpO1xuICB9XG4gICgwLCBfdXRpbC53YXJuKShgTm90IGEgdmFsaWQgY29sb3IgZm9ybWF0OiBcIiR7Y29sb3J9XCJgKTtcbiAgcmV0dXJuIFswLCAwLCAwXTtcbn1cbmZ1bmN0aW9uIGdldENvbG9yVmFsdWVzKGNvbG9ycykge1xuICBjb25zdCBzcGFuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gIHNwYW4uc3R5bGUudmlzaWJpbGl0eSA9IFwiaGlkZGVuXCI7XG4gIGRvY3VtZW50LmJvZHkuYXBwZW5kKHNwYW4pO1xuICBmb3IgKGNvbnN0IG5hbWUgb2YgY29sb3JzLmtleXMoKSkge1xuICAgIHNwYW4uc3R5bGUuY29sb3IgPSBuYW1lO1xuICAgIGNvbnN0IGNvbXB1dGVkQ29sb3IgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShzcGFuKS5jb2xvcjtcbiAgICBjb2xvcnMuc2V0KG5hbWUsIGdldFJHQihjb21wdXRlZENvbG9yKSk7XG4gIH1cbiAgc3Bhbi5yZW1vdmUoKTtcbn1cbmZ1bmN0aW9uIGdldEN1cnJlbnRUcmFuc2Zvcm0oY3R4KSB7XG4gIGNvbnN0IHtcbiAgICBhLFxuICAgIGIsXG4gICAgYyxcbiAgICBkLFxuICAgIGUsXG4gICAgZlxuICB9ID0gY3R4LmdldFRyYW5zZm9ybSgpO1xuICByZXR1cm4gW2EsIGIsIGMsIGQsIGUsIGZdO1xufVxuZnVuY3Rpb24gZ2V0Q3VycmVudFRyYW5zZm9ybUludmVyc2UoY3R4KSB7XG4gIGNvbnN0IHtcbiAgICBhLFxuICAgIGIsXG4gICAgYyxcbiAgICBkLFxuICAgIGUsXG4gICAgZlxuICB9ID0gY3R4LmdldFRyYW5zZm9ybSgpLmludmVydFNlbGYoKTtcbiAgcmV0dXJuIFthLCBiLCBjLCBkLCBlLCBmXTtcbn1cbmZ1bmN0aW9uIHNldExheWVyRGltZW5zaW9ucyhkaXYsIHZpZXdwb3J0LCBtdXN0RmxpcCA9IGZhbHNlLCBtdXN0Um90YXRlID0gdHJ1ZSkge1xuICBpZiAodmlld3BvcnQgaW5zdGFuY2VvZiBQYWdlVmlld3BvcnQpIHtcbiAgICBjb25zdCB7XG4gICAgICBwYWdlV2lkdGgsXG4gICAgICBwYWdlSGVpZ2h0XG4gICAgfSA9IHZpZXdwb3J0LnJhd0RpbXM7XG4gICAgY29uc3Qge1xuICAgICAgc3R5bGVcbiAgICB9ID0gZGl2O1xuICAgIGNvbnN0IHVzZVJvdW5kID0gX3V0aWwuRmVhdHVyZVRlc3QuaXNDU1NSb3VuZFN1cHBvcnRlZDtcbiAgICBjb25zdCB3ID0gYHZhcigtLXNjYWxlLWZhY3RvcikgKiAke3BhZ2VXaWR0aH1weGAsXG4gICAgICBoID0gYHZhcigtLXNjYWxlLWZhY3RvcikgKiAke3BhZ2VIZWlnaHR9cHhgO1xuICAgIGNvbnN0IHdpZHRoU3RyID0gdXNlUm91bmQgPyBgcm91bmQoJHt3fSwgMXB4KWAgOiBgY2FsYygke3d9KWAsXG4gICAgICBoZWlnaHRTdHIgPSB1c2VSb3VuZCA/IGByb3VuZCgke2h9LCAxcHgpYCA6IGBjYWxjKCR7aH0pYDtcbiAgICBpZiAoIW11c3RGbGlwIHx8IHZpZXdwb3J0LnJvdGF0aW9uICUgMTgwID09PSAwKSB7XG4gICAgICBzdHlsZS53aWR0aCA9IHdpZHRoU3RyO1xuICAgICAgc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0U3RyO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHlsZS53aWR0aCA9IGhlaWdodFN0cjtcbiAgICAgIHN0eWxlLmhlaWdodCA9IHdpZHRoU3RyO1xuICAgIH1cbiAgfVxuICBpZiAobXVzdFJvdGF0ZSkge1xuICAgIGRpdi5zZXRBdHRyaWJ1dGUoXCJkYXRhLW1haW4tcm90YXRpb25cIiwgdmlld3BvcnQucm90YXRpb24pO1xuICB9XG59XG5cbi8qKiovIH0pLFxuLyogNyAqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykgPT4ge1xuXG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xuZXhwb3J0cy5CYXNlU3RhbmRhcmRGb250RGF0YUZhY3RvcnkgPSBleHBvcnRzLkJhc2VTVkdGYWN0b3J5ID0gZXhwb3J0cy5CYXNlRmlsdGVyRmFjdG9yeSA9IGV4cG9ydHMuQmFzZUNhbnZhc0ZhY3RvcnkgPSBleHBvcnRzLkJhc2VDTWFwUmVhZGVyRmFjdG9yeSA9IHZvaWQgMDtcbnZhciBfdXRpbCA9IF9fd19wZGZqc19yZXF1aXJlX18oMSk7XG5jbGFzcyBCYXNlRmlsdGVyRmFjdG9yeSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yID09PSBCYXNlRmlsdGVyRmFjdG9yeSkge1xuICAgICAgKDAsIF91dGlsLnVucmVhY2hhYmxlKShcIkNhbm5vdCBpbml0aWFsaXplIEJhc2VGaWx0ZXJGYWN0b3J5LlwiKTtcbiAgICB9XG4gIH1cbiAgYWRkRmlsdGVyKG1hcHMpIHtcbiAgICByZXR1cm4gXCJub25lXCI7XG4gIH1cbiAgYWRkSENNRmlsdGVyKGZnQ29sb3IsIGJnQ29sb3IpIHtcbiAgICByZXR1cm4gXCJub25lXCI7XG4gIH1cbiAgYWRkSGlnaGxpZ2h0SENNRmlsdGVyKGZnQ29sb3IsIGJnQ29sb3IsIG5ld0ZnQ29sb3IsIG5ld0JnQ29sb3IpIHtcbiAgICByZXR1cm4gXCJub25lXCI7XG4gIH1cbiAgZGVzdHJveShrZWVwSENNID0gZmFsc2UpIHt9XG59XG5leHBvcnRzLkJhc2VGaWx0ZXJGYWN0b3J5ID0gQmFzZUZpbHRlckZhY3Rvcnk7XG5jbGFzcyBCYXNlQ2FudmFzRmFjdG9yeSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yID09PSBCYXNlQ2FudmFzRmFjdG9yeSkge1xuICAgICAgKDAsIF91dGlsLnVucmVhY2hhYmxlKShcIkNhbm5vdCBpbml0aWFsaXplIEJhc2VDYW52YXNGYWN0b3J5LlwiKTtcbiAgICB9XG4gIH1cbiAgY3JlYXRlKHdpZHRoLCBoZWlnaHQpIHtcbiAgICBpZiAod2lkdGggPD0gMCB8fCBoZWlnaHQgPD0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBjYW52YXMgc2l6ZVwiKTtcbiAgICB9XG4gICAgY29uc3QgY2FudmFzID0gdGhpcy5fY3JlYXRlQ2FudmFzKHdpZHRoLCBoZWlnaHQpO1xuICAgIHJldHVybiB7XG4gICAgICBjYW52YXMsXG4gICAgICBjb250ZXh0OiBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpXG4gICAgfTtcbiAgfVxuICByZXNldChjYW52YXNBbmRDb250ZXh0LCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgaWYgKCFjYW52YXNBbmRDb250ZXh0LmNhbnZhcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FudmFzIGlzIG5vdCBzcGVjaWZpZWRcIik7XG4gICAgfVxuICAgIGlmICh3aWR0aCA8PSAwIHx8IGhlaWdodCA8PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGNhbnZhcyBzaXplXCIpO1xuICAgIH1cbiAgICBjYW52YXNBbmRDb250ZXh0LmNhbnZhcy53aWR0aCA9IHdpZHRoO1xuICAgIGNhbnZhc0FuZENvbnRleHQuY2FudmFzLmhlaWdodCA9IGhlaWdodDtcbiAgfVxuICBkZXN0cm95KGNhbnZhc0FuZENvbnRleHQpIHtcbiAgICBpZiAoIWNhbnZhc0FuZENvbnRleHQuY2FudmFzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW52YXMgaXMgbm90IHNwZWNpZmllZFwiKTtcbiAgICB9XG4gICAgY2FudmFzQW5kQ29udGV4dC5jYW52YXMud2lkdGggPSAwO1xuICAgIGNhbnZhc0FuZENvbnRleHQuY2FudmFzLmhlaWdodCA9IDA7XG4gICAgY2FudmFzQW5kQ29udGV4dC5jYW52YXMgPSBudWxsO1xuICAgIGNhbnZhc0FuZENvbnRleHQuY29udGV4dCA9IG51bGw7XG4gIH1cbiAgX2NyZWF0ZUNhbnZhcyh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgKDAsIF91dGlsLnVucmVhY2hhYmxlKShcIkFic3RyYWN0IG1ldGhvZCBgX2NyZWF0ZUNhbnZhc2AgY2FsbGVkLlwiKTtcbiAgfVxufVxuZXhwb3J0cy5CYXNlQ2FudmFzRmFjdG9yeSA9IEJhc2VDYW52YXNGYWN0b3J5O1xuY2xhc3MgQmFzZUNNYXBSZWFkZXJGYWN0b3J5IHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIGJhc2VVcmwgPSBudWxsLFxuICAgIGlzQ29tcHJlc3NlZCA9IHRydWVcbiAgfSkge1xuICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yID09PSBCYXNlQ01hcFJlYWRlckZhY3RvcnkpIHtcbiAgICAgICgwLCBfdXRpbC51bnJlYWNoYWJsZSkoXCJDYW5ub3QgaW5pdGlhbGl6ZSBCYXNlQ01hcFJlYWRlckZhY3RvcnkuXCIpO1xuICAgIH1cbiAgICB0aGlzLmJhc2VVcmwgPSBiYXNlVXJsO1xuICAgIHRoaXMuaXNDb21wcmVzc2VkID0gaXNDb21wcmVzc2VkO1xuICB9XG4gIGFzeW5jIGZldGNoKHtcbiAgICBuYW1lXG4gIH0pIHtcbiAgICBpZiAoIXRoaXMuYmFzZVVybCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgQ01hcCBcImJhc2VVcmxcIiBwYXJhbWV0ZXIgbXVzdCBiZSBzcGVjaWZpZWQsIGVuc3VyZSB0aGF0ICcgKyAndGhlIFwiY01hcFVybFwiIGFuZCBcImNNYXBQYWNrZWRcIiBBUEkgcGFyYW1ldGVycyBhcmUgcHJvdmlkZWQuJyk7XG4gICAgfVxuICAgIGlmICghbmFtZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ01hcCBuYW1lIG11c3QgYmUgc3BlY2lmaWVkLlwiKTtcbiAgICB9XG4gICAgY29uc3QgdXJsID0gdGhpcy5iYXNlVXJsICsgbmFtZSArICh0aGlzLmlzQ29tcHJlc3NlZCA/IFwiLmJjbWFwXCIgOiBcIlwiKTtcbiAgICBjb25zdCBjb21wcmVzc2lvblR5cGUgPSB0aGlzLmlzQ29tcHJlc3NlZCA/IF91dGlsLkNNYXBDb21wcmVzc2lvblR5cGUuQklOQVJZIDogX3V0aWwuQ01hcENvbXByZXNzaW9uVHlwZS5OT05FO1xuICAgIHJldHVybiB0aGlzLl9mZXRjaERhdGEodXJsLCBjb21wcmVzc2lvblR5cGUpLmNhdGNoKHJlYXNvbiA9PiB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuYWJsZSB0byBsb2FkICR7dGhpcy5pc0NvbXByZXNzZWQgPyBcImJpbmFyeSBcIiA6IFwiXCJ9Q01hcCBhdDogJHt1cmx9YCk7XG4gICAgfSk7XG4gIH1cbiAgX2ZldGNoRGF0YSh1cmwsIGNvbXByZXNzaW9uVHlwZSkge1xuICAgICgwLCBfdXRpbC51bnJlYWNoYWJsZSkoXCJBYnN0cmFjdCBtZXRob2QgYF9mZXRjaERhdGFgIGNhbGxlZC5cIik7XG4gIH1cbn1cbmV4cG9ydHMuQmFzZUNNYXBSZWFkZXJGYWN0b3J5ID0gQmFzZUNNYXBSZWFkZXJGYWN0b3J5O1xuY2xhc3MgQmFzZVN0YW5kYXJkRm9udERhdGFGYWN0b3J5IHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIGJhc2VVcmwgPSBudWxsXG4gIH0pIHtcbiAgICBpZiAodGhpcy5jb25zdHJ1Y3RvciA9PT0gQmFzZVN0YW5kYXJkRm9udERhdGFGYWN0b3J5KSB7XG4gICAgICAoMCwgX3V0aWwudW5yZWFjaGFibGUpKFwiQ2Fubm90IGluaXRpYWxpemUgQmFzZVN0YW5kYXJkRm9udERhdGFGYWN0b3J5LlwiKTtcbiAgICB9XG4gICAgdGhpcy5iYXNlVXJsID0gYmFzZVVybDtcbiAgfVxuICBhc3luYyBmZXRjaCh7XG4gICAgZmlsZW5hbWVcbiAgfSkge1xuICAgIGlmICghdGhpcy5iYXNlVXJsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBzdGFuZGFyZCBmb250IFwiYmFzZVVybFwiIHBhcmFtZXRlciBtdXN0IGJlIHNwZWNpZmllZCwgZW5zdXJlIHRoYXQgJyArICd0aGUgXCJzdGFuZGFyZEZvbnREYXRhVXJsXCIgQVBJIHBhcmFtZXRlciBpcyBwcm92aWRlZC4nKTtcbiAgICB9XG4gICAgaWYgKCFmaWxlbmFtZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRm9udCBmaWxlbmFtZSBtdXN0IGJlIHNwZWNpZmllZC5cIik7XG4gICAgfVxuICAgIGNvbnN0IHVybCA9IGAke3RoaXMuYmFzZVVybH0ke2ZpbGVuYW1lfWA7XG4gICAgcmV0dXJuIHRoaXMuX2ZldGNoRGF0YSh1cmwpLmNhdGNoKHJlYXNvbiA9PiB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuYWJsZSB0byBsb2FkIGZvbnQgZGF0YSBhdDogJHt1cmx9YCk7XG4gICAgfSk7XG4gIH1cbiAgX2ZldGNoRGF0YSh1cmwpIHtcbiAgICAoMCwgX3V0aWwudW5yZWFjaGFibGUpKFwiQWJzdHJhY3QgbWV0aG9kIGBfZmV0Y2hEYXRhYCBjYWxsZWQuXCIpO1xuICB9XG59XG5leHBvcnRzLkJhc2VTdGFuZGFyZEZvbnREYXRhRmFjdG9yeSA9IEJhc2VTdGFuZGFyZEZvbnREYXRhRmFjdG9yeTtcbmNsYXNzIEJhc2VTVkdGYWN0b3J5IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgaWYgKHRoaXMuY29uc3RydWN0b3IgPT09IEJhc2VTVkdGYWN0b3J5KSB7XG4gICAgICAoMCwgX3V0aWwudW5yZWFjaGFibGUpKFwiQ2Fubm90IGluaXRpYWxpemUgQmFzZVNWR0ZhY3RvcnkuXCIpO1xuICAgIH1cbiAgfVxuICBjcmVhdGUod2lkdGgsIGhlaWdodCwgc2tpcERpbWVuc2lvbnMgPSBmYWxzZSkge1xuICAgIGlmICh3aWR0aCA8PSAwIHx8IGhlaWdodCA8PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIFNWRyBkaW1lbnNpb25zXCIpO1xuICAgIH1cbiAgICBjb25zdCBzdmcgPSB0aGlzLl9jcmVhdGVTVkcoXCJzdmc6c3ZnXCIpO1xuICAgIHN2Zy5zZXRBdHRyaWJ1dGUoXCJ2ZXJzaW9uXCIsIFwiMS4xXCIpO1xuICAgIGlmICghc2tpcERpbWVuc2lvbnMpIHtcbiAgICAgIHN2Zy5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLCBgJHt3aWR0aH1weGApO1xuICAgICAgc3ZnLnNldEF0dHJpYnV0ZShcImhlaWdodFwiLCBgJHtoZWlnaHR9cHhgKTtcbiAgICB9XG4gICAgc3ZnLnNldEF0dHJpYnV0ZShcInByZXNlcnZlQXNwZWN0UmF0aW9cIiwgXCJub25lXCIpO1xuICAgIHN2Zy5zZXRBdHRyaWJ1dGUoXCJ2aWV3Qm94XCIsIGAwIDAgJHt3aWR0aH0gJHtoZWlnaHR9YCk7XG4gICAgcmV0dXJuIHN2ZztcbiAgfVxuICBjcmVhdGVFbGVtZW50KHR5cGUpIHtcbiAgICBpZiAodHlwZW9mIHR5cGUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgU1ZHIGVsZW1lbnQgdHlwZVwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2NyZWF0ZVNWRyh0eXBlKTtcbiAgfVxuICBfY3JlYXRlU1ZHKHR5cGUpIHtcbiAgICAoMCwgX3V0aWwudW5yZWFjaGFibGUpKFwiQWJzdHJhY3QgbWV0aG9kIGBfY3JlYXRlU1ZHYCBjYWxsZWQuXCIpO1xuICB9XG59XG5leHBvcnRzLkJhc2VTVkdGYWN0b3J5ID0gQmFzZVNWR0ZhY3Rvcnk7XG5cbi8qKiovIH0pLFxuLyogOCAqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykgPT4ge1xuXG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xuZXhwb3J0cy5NdXJtdXJIYXNoM182NCA9IHZvaWQgMDtcbnZhciBfdXRpbCA9IF9fd19wZGZqc19yZXF1aXJlX18oMSk7XG5jb25zdCBTRUVEID0gMHhjM2QyZTFmMDtcbmNvbnN0IE1BU0tfSElHSCA9IDB4ZmZmZjAwMDA7XG5jb25zdCBNQVNLX0xPVyA9IDB4ZmZmZjtcbmNsYXNzIE11cm11ckhhc2gzXzY0IHtcbiAgY29uc3RydWN0b3Ioc2VlZCkge1xuICAgIHRoaXMuaDEgPSBzZWVkID8gc2VlZCAmIDB4ZmZmZmZmZmYgOiBTRUVEO1xuICAgIHRoaXMuaDIgPSBzZWVkID8gc2VlZCAmIDB4ZmZmZmZmZmYgOiBTRUVEO1xuICB9XG4gIHVwZGF0ZShpbnB1dCkge1xuICAgIGxldCBkYXRhLCBsZW5ndGg7XG4gICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgZGF0YSA9IG5ldyBVaW50OEFycmF5KGlucHV0Lmxlbmd0aCAqIDIpO1xuICAgICAgbGVuZ3RoID0gMDtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IGlucHV0Lmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgY29uc3QgY29kZSA9IGlucHV0LmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGlmIChjb2RlIDw9IDB4ZmYpIHtcbiAgICAgICAgICBkYXRhW2xlbmd0aCsrXSA9IGNvZGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGF0YVtsZW5ndGgrK10gPSBjb2RlID4+PiA4O1xuICAgICAgICAgIGRhdGFbbGVuZ3RoKytdID0gY29kZSAmIDB4ZmY7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCgwLCBfdXRpbC5pc0FycmF5QnVmZmVyKShpbnB1dCkpIHtcbiAgICAgIGRhdGEgPSBpbnB1dC5zbGljZSgpO1xuICAgICAgbGVuZ3RoID0gZGF0YS5ieXRlTGVuZ3RoO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJXcm9uZyBkYXRhIGZvcm1hdCBpbiBNdXJtdXJIYXNoM182NF91cGRhdGUuIFwiICsgXCJJbnB1dCBtdXN0IGJlIGEgc3RyaW5nIG9yIGFycmF5LlwiKTtcbiAgICB9XG4gICAgY29uc3QgYmxvY2tDb3VudHMgPSBsZW5ndGggPj4gMjtcbiAgICBjb25zdCB0YWlsTGVuZ3RoID0gbGVuZ3RoIC0gYmxvY2tDb3VudHMgKiA0O1xuICAgIGNvbnN0IGRhdGFVaW50MzIgPSBuZXcgVWludDMyQXJyYXkoZGF0YS5idWZmZXIsIDAsIGJsb2NrQ291bnRzKTtcbiAgICBsZXQgazEgPSAwLFxuICAgICAgazIgPSAwO1xuICAgIGxldCBoMSA9IHRoaXMuaDEsXG4gICAgICBoMiA9IHRoaXMuaDI7XG4gICAgY29uc3QgQzEgPSAweGNjOWUyZDUxLFxuICAgICAgQzIgPSAweDFiODczNTkzO1xuICAgIGNvbnN0IEMxX0xPVyA9IEMxICYgTUFTS19MT1csXG4gICAgICBDMl9MT1cgPSBDMiAmIE1BU0tfTE9XO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmxvY2tDb3VudHM7IGkrKykge1xuICAgICAgaWYgKGkgJiAxKSB7XG4gICAgICAgIGsxID0gZGF0YVVpbnQzMltpXTtcbiAgICAgICAgazEgPSBrMSAqIEMxICYgTUFTS19ISUdIIHwgazEgKiBDMV9MT1cgJiBNQVNLX0xPVztcbiAgICAgICAgazEgPSBrMSA8PCAxNSB8IGsxID4+PiAxNztcbiAgICAgICAgazEgPSBrMSAqIEMyICYgTUFTS19ISUdIIHwgazEgKiBDMl9MT1cgJiBNQVNLX0xPVztcbiAgICAgICAgaDEgXj0gazE7XG4gICAgICAgIGgxID0gaDEgPDwgMTMgfCBoMSA+Pj4gMTk7XG4gICAgICAgIGgxID0gaDEgKiA1ICsgMHhlNjU0NmI2NDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGsyID0gZGF0YVVpbnQzMltpXTtcbiAgICAgICAgazIgPSBrMiAqIEMxICYgTUFTS19ISUdIIHwgazIgKiBDMV9MT1cgJiBNQVNLX0xPVztcbiAgICAgICAgazIgPSBrMiA8PCAxNSB8IGsyID4+PiAxNztcbiAgICAgICAgazIgPSBrMiAqIEMyICYgTUFTS19ISUdIIHwgazIgKiBDMl9MT1cgJiBNQVNLX0xPVztcbiAgICAgICAgaDIgXj0gazI7XG4gICAgICAgIGgyID0gaDIgPDwgMTMgfCBoMiA+Pj4gMTk7XG4gICAgICAgIGgyID0gaDIgKiA1ICsgMHhlNjU0NmI2NDtcbiAgICAgIH1cbiAgICB9XG4gICAgazEgPSAwO1xuICAgIHN3aXRjaCAodGFpbExlbmd0aCkge1xuICAgICAgY2FzZSAzOlxuICAgICAgICBrMSBePSBkYXRhW2Jsb2NrQ291bnRzICogNCArIDJdIDw8IDE2O1xuICAgICAgY2FzZSAyOlxuICAgICAgICBrMSBePSBkYXRhW2Jsb2NrQ291bnRzICogNCArIDFdIDw8IDg7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIGsxIF49IGRhdGFbYmxvY2tDb3VudHMgKiA0XTtcbiAgICAgICAgazEgPSBrMSAqIEMxICYgTUFTS19ISUdIIHwgazEgKiBDMV9MT1cgJiBNQVNLX0xPVztcbiAgICAgICAgazEgPSBrMSA8PCAxNSB8IGsxID4+PiAxNztcbiAgICAgICAgazEgPSBrMSAqIEMyICYgTUFTS19ISUdIIHwgazEgKiBDMl9MT1cgJiBNQVNLX0xPVztcbiAgICAgICAgaWYgKGJsb2NrQ291bnRzICYgMSkge1xuICAgICAgICAgIGgxIF49IGsxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGgyIF49IGsxO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRoaXMuaDEgPSBoMTtcbiAgICB0aGlzLmgyID0gaDI7XG4gIH1cbiAgaGV4ZGlnZXN0KCkge1xuICAgIGxldCBoMSA9IHRoaXMuaDEsXG4gICAgICBoMiA9IHRoaXMuaDI7XG4gICAgaDEgXj0gaDIgPj4+IDE7XG4gICAgaDEgPSBoMSAqIDB4ZWQ1NThjY2QgJiBNQVNLX0hJR0ggfCBoMSAqIDB4OGNjZCAmIE1BU0tfTE9XO1xuICAgIGgyID0gaDIgKiAweGZmNTFhZmQ3ICYgTUFTS19ISUdIIHwgKChoMiA8PCAxNiB8IGgxID4+PiAxNikgKiAweGFmZDdlZDU1ICYgTUFTS19ISUdIKSA+Pj4gMTY7XG4gICAgaDEgXj0gaDIgPj4+IDE7XG4gICAgaDEgPSBoMSAqIDB4MWE4NWVjNTMgJiBNQVNLX0hJR0ggfCBoMSAqIDB4ZWM1MyAmIE1BU0tfTE9XO1xuICAgIGgyID0gaDIgKiAweGM0Y2ViOWZlICYgTUFTS19ISUdIIHwgKChoMiA8PCAxNiB8IGgxID4+PiAxNikgKiAweGI5ZmUxYTg1ICYgTUFTS19ISUdIKSA+Pj4gMTY7XG4gICAgaDEgXj0gaDIgPj4+IDE7XG4gICAgcmV0dXJuIChoMSA+Pj4gMCkudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDgsIFwiMFwiKSArIChoMiA+Pj4gMCkudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDgsIFwiMFwiKTtcbiAgfVxufVxuZXhwb3J0cy5NdXJtdXJIYXNoM182NCA9IE11cm11ckhhc2gzXzY0O1xuXG4vKioqLyB9KSxcbi8qIDkgKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pID0+IHtcblxuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcbmV4cG9ydHMuRm9udExvYWRlciA9IGV4cG9ydHMuRm9udEZhY2VPYmplY3QgPSB2b2lkIDA7XG52YXIgX3V0aWwgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEpO1xuY2xhc3MgRm9udExvYWRlciB7XG4gICNzeXN0ZW1Gb250cyA9IG5ldyBTZXQoKTtcbiAgY29uc3RydWN0b3Ioe1xuICAgIG93bmVyRG9jdW1lbnQgPSBnbG9iYWxUaGlzLmRvY3VtZW50LFxuICAgIHN0eWxlRWxlbWVudCA9IG51bGxcbiAgfSkge1xuICAgIHRoaXMuX2RvY3VtZW50ID0gb3duZXJEb2N1bWVudDtcbiAgICB0aGlzLm5hdGl2ZUZvbnRGYWNlcyA9IG5ldyBTZXQoKTtcbiAgICB0aGlzLnN0eWxlRWxlbWVudCA9IG51bGw7XG4gICAgdGhpcy5sb2FkaW5nUmVxdWVzdHMgPSBbXTtcbiAgICB0aGlzLmxvYWRUZXN0Rm9udElkID0gMDtcbiAgfVxuICBhZGROYXRpdmVGb250RmFjZShuYXRpdmVGb250RmFjZSkge1xuICAgIHRoaXMubmF0aXZlRm9udEZhY2VzLmFkZChuYXRpdmVGb250RmFjZSk7XG4gICAgdGhpcy5fZG9jdW1lbnQuZm9udHMuYWRkKG5hdGl2ZUZvbnRGYWNlKTtcbiAgfVxuICByZW1vdmVOYXRpdmVGb250RmFjZShuYXRpdmVGb250RmFjZSkge1xuICAgIHRoaXMubmF0aXZlRm9udEZhY2VzLmRlbGV0ZShuYXRpdmVGb250RmFjZSk7XG4gICAgdGhpcy5fZG9jdW1lbnQuZm9udHMuZGVsZXRlKG5hdGl2ZUZvbnRGYWNlKTtcbiAgfVxuICBpbnNlcnRSdWxlKHJ1bGUpIHtcbiAgICBpZiAoIXRoaXMuc3R5bGVFbGVtZW50KSB7XG4gICAgICB0aGlzLnN0eWxlRWxlbWVudCA9IHRoaXMuX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcbiAgICAgIHRoaXMuX2RvY3VtZW50LmRvY3VtZW50RWxlbWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImhlYWRcIilbMF0uYXBwZW5kKHRoaXMuc3R5bGVFbGVtZW50KTtcbiAgICB9XG4gICAgY29uc3Qgc3R5bGVTaGVldCA9IHRoaXMuc3R5bGVFbGVtZW50LnNoZWV0O1xuICAgIHN0eWxlU2hlZXQuaW5zZXJ0UnVsZShydWxlLCBzdHlsZVNoZWV0LmNzc1J1bGVzLmxlbmd0aCk7XG4gIH1cbiAgY2xlYXIoKSB7XG4gICAgZm9yIChjb25zdCBuYXRpdmVGb250RmFjZSBvZiB0aGlzLm5hdGl2ZUZvbnRGYWNlcykge1xuICAgICAgdGhpcy5fZG9jdW1lbnQuZm9udHMuZGVsZXRlKG5hdGl2ZUZvbnRGYWNlKTtcbiAgICB9XG4gICAgdGhpcy5uYXRpdmVGb250RmFjZXMuY2xlYXIoKTtcbiAgICB0aGlzLiNzeXN0ZW1Gb250cy5jbGVhcigpO1xuICAgIGlmICh0aGlzLnN0eWxlRWxlbWVudCkge1xuICAgICAgdGhpcy5zdHlsZUVsZW1lbnQucmVtb3ZlKCk7XG4gICAgICB0aGlzLnN0eWxlRWxlbWVudCA9IG51bGw7XG4gICAgfVxuICB9XG4gIGFzeW5jIGxvYWRTeXN0ZW1Gb250KGluZm8pIHtcbiAgICBpZiAoIWluZm8gfHwgdGhpcy4jc3lzdGVtRm9udHMuaGFzKGluZm8ubG9hZGVkTmFtZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgKDAsIF91dGlsLmFzc2VydCkoIXRoaXMuZGlzYWJsZUZvbnRGYWNlLCBcImxvYWRTeXN0ZW1Gb250IHNob3VsZG4ndCBiZSBjYWxsZWQgd2hlbiBgZGlzYWJsZUZvbnRGYWNlYCBpcyBzZXQuXCIpO1xuICAgIGlmICh0aGlzLmlzRm9udExvYWRpbmdBUElTdXBwb3J0ZWQpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbG9hZGVkTmFtZSxcbiAgICAgICAgc3JjLFxuICAgICAgICBzdHlsZVxuICAgICAgfSA9IGluZm87XG4gICAgICBjb25zdCBmb250RmFjZSA9IG5ldyBGb250RmFjZShsb2FkZWROYW1lLCBzcmMsIHN0eWxlKTtcbiAgICAgIHRoaXMuYWRkTmF0aXZlRm9udEZhY2UoZm9udEZhY2UpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgZm9udEZhY2UubG9hZCgpO1xuICAgICAgICB0aGlzLiNzeXN0ZW1Gb250cy5hZGQobG9hZGVkTmFtZSk7XG4gICAgICB9IGNhdGNoIHtcbiAgICAgICAgKDAsIF91dGlsLndhcm4pKGBDYW5ub3QgbG9hZCBzeXN0ZW0gZm9udDogJHtpbmZvLmJhc2VGb250TmFtZX0sIGluc3RhbGxpbmcgaXQgY291bGQgaGVscCB0byBpbXByb3ZlIFBERiByZW5kZXJpbmcuYCk7XG4gICAgICAgIHRoaXMucmVtb3ZlTmF0aXZlRm9udEZhY2UoZm9udEZhY2UpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAoMCwgX3V0aWwudW5yZWFjaGFibGUpKFwiTm90IGltcGxlbWVudGVkOiBsb2FkU3lzdGVtRm9udCB3aXRob3V0IHRoZSBGb250IExvYWRpbmcgQVBJLlwiKTtcbiAgfVxuICBhc3luYyBiaW5kKGZvbnQpIHtcbiAgICBpZiAoZm9udC5hdHRhY2hlZCB8fCBmb250Lm1pc3NpbmdGaWxlICYmICFmb250LnN5c3RlbUZvbnRJbmZvKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvbnQuYXR0YWNoZWQgPSB0cnVlO1xuICAgIGlmIChmb250LnN5c3RlbUZvbnRJbmZvKSB7XG4gICAgICBhd2FpdCB0aGlzLmxvYWRTeXN0ZW1Gb250KGZvbnQuc3lzdGVtRm9udEluZm8pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc0ZvbnRMb2FkaW5nQVBJU3VwcG9ydGVkKSB7XG4gICAgICBjb25zdCBuYXRpdmVGb250RmFjZSA9IGZvbnQuY3JlYXRlTmF0aXZlRm9udEZhY2UoKTtcbiAgICAgIGlmIChuYXRpdmVGb250RmFjZSkge1xuICAgICAgICB0aGlzLmFkZE5hdGl2ZUZvbnRGYWNlKG5hdGl2ZUZvbnRGYWNlKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBhd2FpdCBuYXRpdmVGb250RmFjZS5sb2FkZWQ7XG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgKDAsIF91dGlsLndhcm4pKGBGYWlsZWQgdG8gbG9hZCBmb250ICcke25hdGl2ZUZvbnRGYWNlLmZhbWlseX0nOiAnJHtleH0nLmApO1xuICAgICAgICAgIGZvbnQuZGlzYWJsZUZvbnRGYWNlID0gdHJ1ZTtcbiAgICAgICAgICB0aHJvdyBleDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBydWxlID0gZm9udC5jcmVhdGVGb250RmFjZVJ1bGUoKTtcbiAgICBpZiAocnVsZSkge1xuICAgICAgdGhpcy5pbnNlcnRSdWxlKHJ1bGUpO1xuICAgICAgaWYgKHRoaXMuaXNTeW5jRm9udExvYWRpbmdTdXBwb3J0ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSB0aGlzLl9xdWV1ZUxvYWRpbmdDYWxsYmFjayhyZXNvbHZlKTtcbiAgICAgICAgdGhpcy5fcHJlcGFyZUZvbnRMb2FkRXZlbnQoZm9udCwgcmVxdWVzdCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgZ2V0IGlzRm9udExvYWRpbmdBUElTdXBwb3J0ZWQoKSB7XG4gICAgY29uc3QgaGFzRm9udHMgPSAhIXRoaXMuX2RvY3VtZW50Py5mb250cztcbiAgICByZXR1cm4gKDAsIF91dGlsLnNoYWRvdykodGhpcywgXCJpc0ZvbnRMb2FkaW5nQVBJU3VwcG9ydGVkXCIsIGhhc0ZvbnRzKTtcbiAgfVxuICBnZXQgaXNTeW5jRm9udExvYWRpbmdTdXBwb3J0ZWQoKSB7XG4gICAgbGV0IHN1cHBvcnRlZCA9IGZhbHNlO1xuICAgIGlmIChfdXRpbC5pc05vZGVKUykge1xuICAgICAgc3VwcG9ydGVkID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT09IFwidW5kZWZpbmVkXCIgJiYgL01vemlsbGFcXC81LjAuKj9ydjpcXGQrLio/IEdlY2tvLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpKSB7XG4gICAgICBzdXBwb3J0ZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gKDAsIF91dGlsLnNoYWRvdykodGhpcywgXCJpc1N5bmNGb250TG9hZGluZ1N1cHBvcnRlZFwiLCBzdXBwb3J0ZWQpO1xuICB9XG4gIF9xdWV1ZUxvYWRpbmdDYWxsYmFjayhjYWxsYmFjaykge1xuICAgIGZ1bmN0aW9uIGNvbXBsZXRlUmVxdWVzdCgpIHtcbiAgICAgICgwLCBfdXRpbC5hc3NlcnQpKCFyZXF1ZXN0LmRvbmUsIFwiY29tcGxldGVSZXF1ZXN0KCkgY2Fubm90IGJlIGNhbGxlZCB0d2ljZS5cIik7XG4gICAgICByZXF1ZXN0LmRvbmUgPSB0cnVlO1xuICAgICAgd2hpbGUgKGxvYWRpbmdSZXF1ZXN0cy5sZW5ndGggPiAwICYmIGxvYWRpbmdSZXF1ZXN0c1swXS5kb25lKSB7XG4gICAgICAgIGNvbnN0IG90aGVyUmVxdWVzdCA9IGxvYWRpbmdSZXF1ZXN0cy5zaGlmdCgpO1xuICAgICAgICBzZXRUaW1lb3V0KG90aGVyUmVxdWVzdC5jYWxsYmFjaywgMCk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGxvYWRpbmdSZXF1ZXN0c1xuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IHJlcXVlc3QgPSB7XG4gICAgICBkb25lOiBmYWxzZSxcbiAgICAgIGNvbXBsZXRlOiBjb21wbGV0ZVJlcXVlc3QsXG4gICAgICBjYWxsYmFja1xuICAgIH07XG4gICAgbG9hZGluZ1JlcXVlc3RzLnB1c2gocmVxdWVzdCk7XG4gICAgcmV0dXJuIHJlcXVlc3Q7XG4gIH1cbiAgZ2V0IF9sb2FkVGVzdEZvbnQoKSB7XG4gICAgY29uc3QgdGVzdEZvbnQgPSBhdG9iKFwiVDFSVVR3QUxBSUFBQXdBd1EwWkdJREh0Wmc0QUFBT1lBQUFBZ1VaR1ZFMWxrelp3QUFBRUhBQUFBQnhIUkVWR0FCUUFcIiArIFwiRlFBQUJEZ0FBQUFlVDFNdk1sWU5Zd2tBQUFFZ0FBQUFZR050WVhBQkRRTFVBQUFDTkFBQUFVSm9aV0ZrL3hWRkRRQUFcIiArIFwiQUx3QUFBQTJhR2hsWVFka0Erb0FBQUQwQUFBQUpHaHRkSGdENkFBQUFBQUVXQUFBQUFadFlYaHdBQUpRQUFBQUFSZ0FcIiArIFwiQUFBR2JtRnRaVmptZEg0QUFBR0FBQUFBc1hCdmMzVC9oZ0F6QUFBRGVBQUFBQ0FBQVFBQUFBRUFBTFpSRnNSZkR6ejFcIiArIFwiQUFzRDZBQUFBQURPQk9UTEFBQUFBTTRLSER3QUFBQUFBK2dESVFBQUFBZ0FBZ0FBQUFBQUFBQUJBQUFESVFBQUFGb0RcIiArIFwiNkFBQUFBQUQ2QUFCQUFBQUFBQUFBQUFBQUFBQUFBQUFBUUFBVUFBQUFnQUFBQVFENkFIMEFBVUFBQUtLQXJ3QUFBQ01cIiArIFwiQW9vQ3ZBQUFBZUFBTVFFQ0FBQUNBQVlKQUFBQUFBQUFBQUFBQVFBQUFBQUFBQUFBQUFBQUFGQm1SV1FBd0FBdUFDNERcIiArIFwiSVA4NEFGb0RJUUFBQUFBQUFRQUFBQUFBQUFBQUFDQUFJQUFCQUFBQURnQ3VBQUVBQUFBQUFBQUFBUUFBQUFFQUFBQUFcIiArIFwiQUFFQUFRQUFBQUVBQUFBQUFBSUFBUUFBQUFFQUFBQUFBQU1BQVFBQUFBRUFBQUFBQUFRQUFRQUFBQUVBQUFBQUFBVUFcIiArIFwiQVFBQUFBRUFBQUFBQUFZQUFRQUFBQU1BQVFRSkFBQUFBZ0FCQUFNQUFRUUpBQUVBQWdBQkFBTUFBUVFKQUFJQUFnQUJcIiArIFwiQUFNQUFRUUpBQU1BQWdBQkFBTUFBUVFKQUFRQUFnQUJBQU1BQVFRSkFBVUFBZ0FCQUFNQUFRUUpBQVlBQWdBQldBQllcIiArIFwiQUFBQUFBQUFBd0FBQUFNQUFBQWNBQUVBQUFBQUFEd0FBd0FCQUFBQUhBQUVBQ0FBQUFBRUFBUUFBUUFBQUM3Ly93QUFcIiArIFwiQUM3Ly8vL1RBQUVBQUFBQUFBQUJCZ0FBQVFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFcIiArIFwiQUFBQUFBQUFBQUFBQUFBQUFBRUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFcIiArIFwiQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFcIiArIFwiQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFcIiArIFwiQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFcIiArIFwiQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBTUFBQUFBQUFEL2d3QXlBQUFBQVFBQUFBQUFBQUFBQUFBQUFBQUFcIiArIFwiQUFBQkFBUUVBQUVCQVFKWUFBRUJBU0g0RHdENEd3SEVBdmdjQS9nWEJJd01BWXVMK256NXRRWGtENWozQ0JMbkVRQUNcIiArIFwiQVFFQklWaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZQUFBQkFRQUFEd0FDQVFFRUUvdDNcIiArIFwiRG92NmZBSDZmQVQrZlBwOCtud0hEb3NNQ3ZtMUN2bTFEQXo2ZkJRQUFBQUFBQUFCQUFBQUFNbUpiekVBQUFBQXpnVGpcIiArIFwiRlFBQUFBRE9CT1FwQUFFQUFBQUFBQUFBREFBVUFBUUFBQUFCQUFBQUFnQUJBQUFBQUFBQUFBQUQ2QUFBQUFBQUFBPT1cIik7XG4gICAgcmV0dXJuICgwLCBfdXRpbC5zaGFkb3cpKHRoaXMsIFwiX2xvYWRUZXN0Rm9udFwiLCB0ZXN0Rm9udCk7XG4gIH1cbiAgX3ByZXBhcmVGb250TG9hZEV2ZW50KGZvbnQsIHJlcXVlc3QpIHtcbiAgICBmdW5jdGlvbiBpbnQzMihkYXRhLCBvZmZzZXQpIHtcbiAgICAgIHJldHVybiBkYXRhLmNoYXJDb2RlQXQob2Zmc2V0KSA8PCAyNCB8IGRhdGEuY2hhckNvZGVBdChvZmZzZXQgKyAxKSA8PCAxNiB8IGRhdGEuY2hhckNvZGVBdChvZmZzZXQgKyAyKSA8PCA4IHwgZGF0YS5jaGFyQ29kZUF0KG9mZnNldCArIDMpICYgMHhmZjtcbiAgICB9XG4gICAgZnVuY3Rpb24gc3BsaWNlU3RyaW5nKHMsIG9mZnNldCwgcmVtb3ZlLCBpbnNlcnQpIHtcbiAgICAgIGNvbnN0IGNodW5rMSA9IHMuc3Vic3RyaW5nKDAsIG9mZnNldCk7XG4gICAgICBjb25zdCBjaHVuazIgPSBzLnN1YnN0cmluZyhvZmZzZXQgKyByZW1vdmUpO1xuICAgICAgcmV0dXJuIGNodW5rMSArIGluc2VydCArIGNodW5rMjtcbiAgICB9XG4gICAgbGV0IGksIGlpO1xuICAgIGNvbnN0IGNhbnZhcyA9IHRoaXMuX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gICAgY2FudmFzLndpZHRoID0gMTtcbiAgICBjYW52YXMuaGVpZ2h0ID0gMTtcbiAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgIGxldCBjYWxsZWQgPSAwO1xuICAgIGZ1bmN0aW9uIGlzRm9udFJlYWR5KG5hbWUsIGNhbGxiYWNrKSB7XG4gICAgICBpZiAoKytjYWxsZWQgPiAzMCkge1xuICAgICAgICAoMCwgX3V0aWwud2FybikoXCJMb2FkIHRlc3QgZm9udCBuZXZlciBsb2FkZWQuXCIpO1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjdHguZm9udCA9IFwiMzBweCBcIiArIG5hbWU7XG4gICAgICBjdHguZmlsbFRleHQoXCIuXCIsIDAsIDIwKTtcbiAgICAgIGNvbnN0IGltYWdlRGF0YSA9IGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgMSwgMSk7XG4gICAgICBpZiAoaW1hZ2VEYXRhLmRhdGFbM10gPiAwKSB7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHNldFRpbWVvdXQoaXNGb250UmVhZHkuYmluZChudWxsLCBuYW1lLCBjYWxsYmFjaykpO1xuICAgIH1cbiAgICBjb25zdCBsb2FkVGVzdEZvbnRJZCA9IGBsdCR7RGF0ZS5ub3coKX0ke3RoaXMubG9hZFRlc3RGb250SWQrK31gO1xuICAgIGxldCBkYXRhID0gdGhpcy5fbG9hZFRlc3RGb250O1xuICAgIGNvbnN0IENPTU1FTlRfT0ZGU0VUID0gOTc2O1xuICAgIGRhdGEgPSBzcGxpY2VTdHJpbmcoZGF0YSwgQ09NTUVOVF9PRkZTRVQsIGxvYWRUZXN0Rm9udElkLmxlbmd0aCwgbG9hZFRlc3RGb250SWQpO1xuICAgIGNvbnN0IENGRl9DSEVDS1NVTV9PRkZTRVQgPSAxNjtcbiAgICBjb25zdCBYWFhYX1ZBTFVFID0gMHg1ODU4NTg1ODtcbiAgICBsZXQgY2hlY2tzdW0gPSBpbnQzMihkYXRhLCBDRkZfQ0hFQ0tTVU1fT0ZGU0VUKTtcbiAgICBmb3IgKGkgPSAwLCBpaSA9IGxvYWRUZXN0Rm9udElkLmxlbmd0aCAtIDM7IGkgPCBpaTsgaSArPSA0KSB7XG4gICAgICBjaGVja3N1bSA9IGNoZWNrc3VtIC0gWFhYWF9WQUxVRSArIGludDMyKGxvYWRUZXN0Rm9udElkLCBpKSB8IDA7XG4gICAgfVxuICAgIGlmIChpIDwgbG9hZFRlc3RGb250SWQubGVuZ3RoKSB7XG4gICAgICBjaGVja3N1bSA9IGNoZWNrc3VtIC0gWFhYWF9WQUxVRSArIGludDMyKGxvYWRUZXN0Rm9udElkICsgXCJYWFhcIiwgaSkgfCAwO1xuICAgIH1cbiAgICBkYXRhID0gc3BsaWNlU3RyaW5nKGRhdGEsIENGRl9DSEVDS1NVTV9PRkZTRVQsIDQsICgwLCBfdXRpbC5zdHJpbmczMikoY2hlY2tzdW0pKTtcbiAgICBjb25zdCB1cmwgPSBgdXJsKGRhdGE6Zm9udC9vcGVudHlwZTtiYXNlNjQsJHtidG9hKGRhdGEpfSk7YDtcbiAgICBjb25zdCBydWxlID0gYEBmb250LWZhY2Uge2ZvbnQtZmFtaWx5OlwiJHtsb2FkVGVzdEZvbnRJZH1cIjtzcmM6JHt1cmx9fWA7XG4gICAgdGhpcy5pbnNlcnRSdWxlKHJ1bGUpO1xuICAgIGNvbnN0IGRpdiA9IHRoaXMuX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgZGl2LnN0eWxlLnZpc2liaWxpdHkgPSBcImhpZGRlblwiO1xuICAgIGRpdi5zdHlsZS53aWR0aCA9IGRpdi5zdHlsZS5oZWlnaHQgPSBcIjEwcHhcIjtcbiAgICBkaXYuc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCI7XG4gICAgZGl2LnN0eWxlLnRvcCA9IGRpdi5zdHlsZS5sZWZ0ID0gXCIwcHhcIjtcbiAgICBmb3IgKGNvbnN0IG5hbWUgb2YgW2ZvbnQubG9hZGVkTmFtZSwgbG9hZFRlc3RGb250SWRdKSB7XG4gICAgICBjb25zdCBzcGFuID0gdGhpcy5fZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICBzcGFuLnRleHRDb250ZW50ID0gXCJIaVwiO1xuICAgICAgc3Bhbi5zdHlsZS5mb250RmFtaWx5ID0gbmFtZTtcbiAgICAgIGRpdi5hcHBlbmQoc3Bhbik7XG4gICAgfVxuICAgIHRoaXMuX2RvY3VtZW50LmJvZHkuYXBwZW5kKGRpdik7XG4gICAgaXNGb250UmVhZHkobG9hZFRlc3RGb250SWQsICgpID0+IHtcbiAgICAgIGRpdi5yZW1vdmUoKTtcbiAgICAgIHJlcXVlc3QuY29tcGxldGUoKTtcbiAgICB9KTtcbiAgfVxufVxuZXhwb3J0cy5Gb250TG9hZGVyID0gRm9udExvYWRlcjtcbmNsYXNzIEZvbnRGYWNlT2JqZWN0IHtcbiAgY29uc3RydWN0b3IodHJhbnNsYXRlZERhdGEsIHtcbiAgICBpc0V2YWxTdXBwb3J0ZWQgPSB0cnVlLFxuICAgIGRpc2FibGVGb250RmFjZSA9IGZhbHNlLFxuICAgIGlnbm9yZUVycm9ycyA9IGZhbHNlLFxuICAgIGluc3BlY3RGb250ID0gbnVsbFxuICB9KSB7XG4gICAgdGhpcy5jb21waWxlZEdseXBocyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgZm9yIChjb25zdCBpIGluIHRyYW5zbGF0ZWREYXRhKSB7XG4gICAgICB0aGlzW2ldID0gdHJhbnNsYXRlZERhdGFbaV07XG4gICAgfVxuICAgIHRoaXMuaXNFdmFsU3VwcG9ydGVkID0gaXNFdmFsU3VwcG9ydGVkICE9PSBmYWxzZTtcbiAgICB0aGlzLmRpc2FibGVGb250RmFjZSA9IGRpc2FibGVGb250RmFjZSA9PT0gdHJ1ZTtcbiAgICB0aGlzLmlnbm9yZUVycm9ycyA9IGlnbm9yZUVycm9ycyA9PT0gdHJ1ZTtcbiAgICB0aGlzLl9pbnNwZWN0Rm9udCA9IGluc3BlY3RGb250O1xuICB9XG4gIGNyZWF0ZU5hdGl2ZUZvbnRGYWNlKCkge1xuICAgIGlmICghdGhpcy5kYXRhIHx8IHRoaXMuZGlzYWJsZUZvbnRGYWNlKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgbGV0IG5hdGl2ZUZvbnRGYWNlO1xuICAgIGlmICghdGhpcy5jc3NGb250SW5mbykge1xuICAgICAgbmF0aXZlRm9udEZhY2UgPSBuZXcgRm9udEZhY2UodGhpcy5sb2FkZWROYW1lLCB0aGlzLmRhdGEsIHt9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgY3NzID0ge1xuICAgICAgICB3ZWlnaHQ6IHRoaXMuY3NzRm9udEluZm8uZm9udFdlaWdodFxuICAgICAgfTtcbiAgICAgIGlmICh0aGlzLmNzc0ZvbnRJbmZvLml0YWxpY0FuZ2xlKSB7XG4gICAgICAgIGNzcy5zdHlsZSA9IGBvYmxpcXVlICR7dGhpcy5jc3NGb250SW5mby5pdGFsaWNBbmdsZX1kZWdgO1xuICAgICAgfVxuICAgICAgbmF0aXZlRm9udEZhY2UgPSBuZXcgRm9udEZhY2UodGhpcy5jc3NGb250SW5mby5mb250RmFtaWx5LCB0aGlzLmRhdGEsIGNzcyk7XG4gICAgfVxuICAgIHRoaXMuX2luc3BlY3RGb250Py4odGhpcyk7XG4gICAgcmV0dXJuIG5hdGl2ZUZvbnRGYWNlO1xuICB9XG4gIGNyZWF0ZUZvbnRGYWNlUnVsZSgpIHtcbiAgICBpZiAoIXRoaXMuZGF0YSB8fCB0aGlzLmRpc2FibGVGb250RmFjZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGRhdGEgPSAoMCwgX3V0aWwuYnl0ZXNUb1N0cmluZykodGhpcy5kYXRhKTtcbiAgICBjb25zdCB1cmwgPSBgdXJsKGRhdGE6JHt0aGlzLm1pbWV0eXBlfTtiYXNlNjQsJHtidG9hKGRhdGEpfSk7YDtcbiAgICBsZXQgcnVsZTtcbiAgICBpZiAoIXRoaXMuY3NzRm9udEluZm8pIHtcbiAgICAgIHJ1bGUgPSBgQGZvbnQtZmFjZSB7Zm9udC1mYW1pbHk6XCIke3RoaXMubG9hZGVkTmFtZX1cIjtzcmM6JHt1cmx9fWA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBjc3MgPSBgZm9udC13ZWlnaHQ6ICR7dGhpcy5jc3NGb250SW5mby5mb250V2VpZ2h0fTtgO1xuICAgICAgaWYgKHRoaXMuY3NzRm9udEluZm8uaXRhbGljQW5nbGUpIHtcbiAgICAgICAgY3NzICs9IGBmb250LXN0eWxlOiBvYmxpcXVlICR7dGhpcy5jc3NGb250SW5mby5pdGFsaWNBbmdsZX1kZWc7YDtcbiAgICAgIH1cbiAgICAgIHJ1bGUgPSBgQGZvbnQtZmFjZSB7Zm9udC1mYW1pbHk6XCIke3RoaXMuY3NzRm9udEluZm8uZm9udEZhbWlseX1cIjske2Nzc31zcmM6JHt1cmx9fWA7XG4gICAgfVxuICAgIHRoaXMuX2luc3BlY3RGb250Py4odGhpcywgdXJsKTtcbiAgICByZXR1cm4gcnVsZTtcbiAgfVxuICBnZXRQYXRoR2VuZXJhdG9yKG9ianMsIGNoYXJhY3Rlcikge1xuICAgIGlmICh0aGlzLmNvbXBpbGVkR2x5cGhzW2NoYXJhY3Rlcl0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZWRHbHlwaHNbY2hhcmFjdGVyXTtcbiAgICB9XG4gICAgbGV0IGNtZHM7XG4gICAgdHJ5IHtcbiAgICAgIGNtZHMgPSBvYmpzLmdldCh0aGlzLmxvYWRlZE5hbWUgKyBcIl9wYXRoX1wiICsgY2hhcmFjdGVyKTtcbiAgICB9IGNhdGNoIChleCkge1xuICAgICAgaWYgKCF0aGlzLmlnbm9yZUVycm9ycykge1xuICAgICAgICB0aHJvdyBleDtcbiAgICAgIH1cbiAgICAgICgwLCBfdXRpbC53YXJuKShgZ2V0UGF0aEdlbmVyYXRvciAtIGlnbm9yaW5nIGNoYXJhY3RlcjogXCIke2V4fVwiLmApO1xuICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZWRHbHlwaHNbY2hhcmFjdGVyXSA9IGZ1bmN0aW9uIChjLCBzaXplKSB7fTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNFdmFsU3VwcG9ydGVkICYmIF91dGlsLkZlYXR1cmVUZXN0LmlzRXZhbFN1cHBvcnRlZCkge1xuICAgICAgY29uc3QganNCdWYgPSBbXTtcbiAgICAgIGZvciAoY29uc3QgY3VycmVudCBvZiBjbWRzKSB7XG4gICAgICAgIGNvbnN0IGFyZ3MgPSBjdXJyZW50LmFyZ3MgIT09IHVuZGVmaW5lZCA/IGN1cnJlbnQuYXJncy5qb2luKFwiLFwiKSA6IFwiXCI7XG4gICAgICAgIGpzQnVmLnB1c2goXCJjLlwiLCBjdXJyZW50LmNtZCwgXCIoXCIsIGFyZ3MsIFwiKTtcXG5cIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5jb21waWxlZEdseXBoc1tjaGFyYWN0ZXJdID0gbmV3IEZ1bmN0aW9uKFwiY1wiLCBcInNpemVcIiwganNCdWYuam9pbihcIlwiKSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNvbXBpbGVkR2x5cGhzW2NoYXJhY3Rlcl0gPSBmdW5jdGlvbiAoYywgc2l6ZSkge1xuICAgICAgZm9yIChjb25zdCBjdXJyZW50IG9mIGNtZHMpIHtcbiAgICAgICAgaWYgKGN1cnJlbnQuY21kID09PSBcInNjYWxlXCIpIHtcbiAgICAgICAgICBjdXJyZW50LmFyZ3MgPSBbc2l6ZSwgLXNpemVdO1xuICAgICAgICB9XG4gICAgICAgIGNbY3VycmVudC5jbWRdLmFwcGx5KGMsIGN1cnJlbnQuYXJncyk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxufVxuZXhwb3J0cy5Gb250RmFjZU9iamVjdCA9IEZvbnRGYWNlT2JqZWN0O1xuXG4vKioqLyB9KSxcbi8qIDEwICovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSA9PiB7XG5cblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5leHBvcnRzLk5vZGVTdGFuZGFyZEZvbnREYXRhRmFjdG9yeSA9IGV4cG9ydHMuTm9kZUZpbHRlckZhY3RvcnkgPSBleHBvcnRzLk5vZGVDYW52YXNGYWN0b3J5ID0gZXhwb3J0cy5Ob2RlQ01hcFJlYWRlckZhY3RvcnkgPSB2b2lkIDA7XG52YXIgX2Jhc2VfZmFjdG9yeSA9IF9fd19wZGZqc19yZXF1aXJlX18oNyk7XG52YXIgX3V0aWwgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEpO1xuO1xuO1xuY29uc3QgZmV0Y2hEYXRhID0gZnVuY3Rpb24gKHVybCkge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGNvbnN0IGZzID0gcmVxdWlyZShcImZzXCIpO1xuICAgIGZzLnJlYWRGaWxlKHVybCwgKGVycm9yLCBkYXRhKSA9PiB7XG4gICAgICBpZiAoZXJyb3IgfHwgIWRhdGEpIHtcbiAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihlcnJvcikpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICByZXNvbHZlKG5ldyBVaW50OEFycmF5KGRhdGEpKTtcbiAgICB9KTtcbiAgfSk7XG59O1xuY2xhc3MgTm9kZUZpbHRlckZhY3RvcnkgZXh0ZW5kcyBfYmFzZV9mYWN0b3J5LkJhc2VGaWx0ZXJGYWN0b3J5IHt9XG5leHBvcnRzLk5vZGVGaWx0ZXJGYWN0b3J5ID0gTm9kZUZpbHRlckZhY3Rvcnk7XG5jbGFzcyBOb2RlQ2FudmFzRmFjdG9yeSBleHRlbmRzIF9iYXNlX2ZhY3RvcnkuQmFzZUNhbnZhc0ZhY3Rvcnkge1xuICBfY3JlYXRlQ2FudmFzKHdpZHRoLCBoZWlnaHQpIHtcbiAgICBjb25zdCBDYW52YXMgPSByZXF1aXJlKFwiY2FudmFzXCIpO1xuICAgIHJldHVybiBDYW52YXMuY3JlYXRlQ2FudmFzKHdpZHRoLCBoZWlnaHQpO1xuICB9XG59XG5leHBvcnRzLk5vZGVDYW52YXNGYWN0b3J5ID0gTm9kZUNhbnZhc0ZhY3Rvcnk7XG5jbGFzcyBOb2RlQ01hcFJlYWRlckZhY3RvcnkgZXh0ZW5kcyBfYmFzZV9mYWN0b3J5LkJhc2VDTWFwUmVhZGVyRmFjdG9yeSB7XG4gIF9mZXRjaERhdGEodXJsLCBjb21wcmVzc2lvblR5cGUpIHtcbiAgICByZXR1cm4gZmV0Y2hEYXRhKHVybCkudGhlbihkYXRhID0+IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNNYXBEYXRhOiBkYXRhLFxuICAgICAgICBjb21wcmVzc2lvblR5cGVcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cbn1cbmV4cG9ydHMuTm9kZUNNYXBSZWFkZXJGYWN0b3J5ID0gTm9kZUNNYXBSZWFkZXJGYWN0b3J5O1xuY2xhc3MgTm9kZVN0YW5kYXJkRm9udERhdGFGYWN0b3J5IGV4dGVuZHMgX2Jhc2VfZmFjdG9yeS5CYXNlU3RhbmRhcmRGb250RGF0YUZhY3Rvcnkge1xuICBfZmV0Y2hEYXRhKHVybCkge1xuICAgIHJldHVybiBmZXRjaERhdGEodXJsKTtcbiAgfVxufVxuZXhwb3J0cy5Ob2RlU3RhbmRhcmRGb250RGF0YUZhY3RvcnkgPSBOb2RlU3RhbmRhcmRGb250RGF0YUZhY3Rvcnk7XG5cbi8qKiovIH0pLFxuLyogMTEgKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pID0+IHtcblxuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcbmV4cG9ydHMuQ2FudmFzR3JhcGhpY3MgPSB2b2lkIDA7XG52YXIgX3V0aWwgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEpO1xudmFyIF9kaXNwbGF5X3V0aWxzID0gX193X3BkZmpzX3JlcXVpcmVfXyg2KTtcbnZhciBfcGF0dGVybl9oZWxwZXIgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEyKTtcbnZhciBfaW1hZ2VfdXRpbHMgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEzKTtcbmNvbnN0IE1JTl9GT05UX1NJWkUgPSAxNjtcbmNvbnN0IE1BWF9GT05UX1NJWkUgPSAxMDA7XG5jb25zdCBNQVhfR1JPVVBfU0laRSA9IDQwOTY7XG5jb25zdCBFWEVDVVRJT05fVElNRSA9IDE1O1xuY29uc3QgRVhFQ1VUSU9OX1NURVBTID0gMTA7XG5jb25zdCBNQVhfU0laRV9UT19DT01QSUxFID0gMTAwMDtcbmNvbnN0IEZVTExfQ0hVTktfSEVJR0hUID0gMTY7XG5mdW5jdGlvbiBtaXJyb3JDb250ZXh0T3BlcmF0aW9ucyhjdHgsIGRlc3RDdHgpIHtcbiAgaWYgKGN0eC5fcmVtb3ZlTWlycm9yaW5nKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQ29udGV4dCBpcyBhbHJlYWR5IGZvcndhcmRpbmcgb3BlcmF0aW9ucy5cIik7XG4gIH1cbiAgY3R4Ll9fb3JpZ2luYWxTYXZlID0gY3R4LnNhdmU7XG4gIGN0eC5fX29yaWdpbmFsUmVzdG9yZSA9IGN0eC5yZXN0b3JlO1xuICBjdHguX19vcmlnaW5hbFJvdGF0ZSA9IGN0eC5yb3RhdGU7XG4gIGN0eC5fX29yaWdpbmFsU2NhbGUgPSBjdHguc2NhbGU7XG4gIGN0eC5fX29yaWdpbmFsVHJhbnNsYXRlID0gY3R4LnRyYW5zbGF0ZTtcbiAgY3R4Ll9fb3JpZ2luYWxUcmFuc2Zvcm0gPSBjdHgudHJhbnNmb3JtO1xuICBjdHguX19vcmlnaW5hbFNldFRyYW5zZm9ybSA9IGN0eC5zZXRUcmFuc2Zvcm07XG4gIGN0eC5fX29yaWdpbmFsUmVzZXRUcmFuc2Zvcm0gPSBjdHgucmVzZXRUcmFuc2Zvcm07XG4gIGN0eC5fX29yaWdpbmFsQ2xpcCA9IGN0eC5jbGlwO1xuICBjdHguX19vcmlnaW5hbE1vdmVUbyA9IGN0eC5tb3ZlVG87XG4gIGN0eC5fX29yaWdpbmFsTGluZVRvID0gY3R4LmxpbmVUbztcbiAgY3R4Ll9fb3JpZ2luYWxCZXppZXJDdXJ2ZVRvID0gY3R4LmJlemllckN1cnZlVG87XG4gIGN0eC5fX29yaWdpbmFsUmVjdCA9IGN0eC5yZWN0O1xuICBjdHguX19vcmlnaW5hbENsb3NlUGF0aCA9IGN0eC5jbG9zZVBhdGg7XG4gIGN0eC5fX29yaWdpbmFsQmVnaW5QYXRoID0gY3R4LmJlZ2luUGF0aDtcbiAgY3R4Ll9yZW1vdmVNaXJyb3JpbmcgPSAoKSA9PiB7XG4gICAgY3R4LnNhdmUgPSBjdHguX19vcmlnaW5hbFNhdmU7XG4gICAgY3R4LnJlc3RvcmUgPSBjdHguX19vcmlnaW5hbFJlc3RvcmU7XG4gICAgY3R4LnJvdGF0ZSA9IGN0eC5fX29yaWdpbmFsUm90YXRlO1xuICAgIGN0eC5zY2FsZSA9IGN0eC5fX29yaWdpbmFsU2NhbGU7XG4gICAgY3R4LnRyYW5zbGF0ZSA9IGN0eC5fX29yaWdpbmFsVHJhbnNsYXRlO1xuICAgIGN0eC50cmFuc2Zvcm0gPSBjdHguX19vcmlnaW5hbFRyYW5zZm9ybTtcbiAgICBjdHguc2V0VHJhbnNmb3JtID0gY3R4Ll9fb3JpZ2luYWxTZXRUcmFuc2Zvcm07XG4gICAgY3R4LnJlc2V0VHJhbnNmb3JtID0gY3R4Ll9fb3JpZ2luYWxSZXNldFRyYW5zZm9ybTtcbiAgICBjdHguY2xpcCA9IGN0eC5fX29yaWdpbmFsQ2xpcDtcbiAgICBjdHgubW92ZVRvID0gY3R4Ll9fb3JpZ2luYWxNb3ZlVG87XG4gICAgY3R4LmxpbmVUbyA9IGN0eC5fX29yaWdpbmFsTGluZVRvO1xuICAgIGN0eC5iZXppZXJDdXJ2ZVRvID0gY3R4Ll9fb3JpZ2luYWxCZXppZXJDdXJ2ZVRvO1xuICAgIGN0eC5yZWN0ID0gY3R4Ll9fb3JpZ2luYWxSZWN0O1xuICAgIGN0eC5jbG9zZVBhdGggPSBjdHguX19vcmlnaW5hbENsb3NlUGF0aDtcbiAgICBjdHguYmVnaW5QYXRoID0gY3R4Ll9fb3JpZ2luYWxCZWdpblBhdGg7XG4gICAgZGVsZXRlIGN0eC5fcmVtb3ZlTWlycm9yaW5nO1xuICB9O1xuICBjdHguc2F2ZSA9IGZ1bmN0aW9uIGN0eFNhdmUoKSB7XG4gICAgZGVzdEN0eC5zYXZlKCk7XG4gICAgdGhpcy5fX29yaWdpbmFsU2F2ZSgpO1xuICB9O1xuICBjdHgucmVzdG9yZSA9IGZ1bmN0aW9uIGN0eFJlc3RvcmUoKSB7XG4gICAgZGVzdEN0eC5yZXN0b3JlKCk7XG4gICAgdGhpcy5fX29yaWdpbmFsUmVzdG9yZSgpO1xuICB9O1xuICBjdHgudHJhbnNsYXRlID0gZnVuY3Rpb24gY3R4VHJhbnNsYXRlKHgsIHkpIHtcbiAgICBkZXN0Q3R4LnRyYW5zbGF0ZSh4LCB5KTtcbiAgICB0aGlzLl9fb3JpZ2luYWxUcmFuc2xhdGUoeCwgeSk7XG4gIH07XG4gIGN0eC5zY2FsZSA9IGZ1bmN0aW9uIGN0eFNjYWxlKHgsIHkpIHtcbiAgICBkZXN0Q3R4LnNjYWxlKHgsIHkpO1xuICAgIHRoaXMuX19vcmlnaW5hbFNjYWxlKHgsIHkpO1xuICB9O1xuICBjdHgudHJhbnNmb3JtID0gZnVuY3Rpb24gY3R4VHJhbnNmb3JtKGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgICBkZXN0Q3R4LnRyYW5zZm9ybShhLCBiLCBjLCBkLCBlLCBmKTtcbiAgICB0aGlzLl9fb3JpZ2luYWxUcmFuc2Zvcm0oYSwgYiwgYywgZCwgZSwgZik7XG4gIH07XG4gIGN0eC5zZXRUcmFuc2Zvcm0gPSBmdW5jdGlvbiBjdHhTZXRUcmFuc2Zvcm0oYSwgYiwgYywgZCwgZSwgZikge1xuICAgIGRlc3RDdHguc2V0VHJhbnNmb3JtKGEsIGIsIGMsIGQsIGUsIGYpO1xuICAgIHRoaXMuX19vcmlnaW5hbFNldFRyYW5zZm9ybShhLCBiLCBjLCBkLCBlLCBmKTtcbiAgfTtcbiAgY3R4LnJlc2V0VHJhbnNmb3JtID0gZnVuY3Rpb24gY3R4UmVzZXRUcmFuc2Zvcm0oKSB7XG4gICAgZGVzdEN0eC5yZXNldFRyYW5zZm9ybSgpO1xuICAgIHRoaXMuX19vcmlnaW5hbFJlc2V0VHJhbnNmb3JtKCk7XG4gIH07XG4gIGN0eC5yb3RhdGUgPSBmdW5jdGlvbiBjdHhSb3RhdGUoYW5nbGUpIHtcbiAgICBkZXN0Q3R4LnJvdGF0ZShhbmdsZSk7XG4gICAgdGhpcy5fX29yaWdpbmFsUm90YXRlKGFuZ2xlKTtcbiAgfTtcbiAgY3R4LmNsaXAgPSBmdW5jdGlvbiBjdHhSb3RhdGUocnVsZSkge1xuICAgIGRlc3RDdHguY2xpcChydWxlKTtcbiAgICB0aGlzLl9fb3JpZ2luYWxDbGlwKHJ1bGUpO1xuICB9O1xuICBjdHgubW92ZVRvID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICBkZXN0Q3R4Lm1vdmVUbyh4LCB5KTtcbiAgICB0aGlzLl9fb3JpZ2luYWxNb3ZlVG8oeCwgeSk7XG4gIH07XG4gIGN0eC5saW5lVG8gPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgIGRlc3RDdHgubGluZVRvKHgsIHkpO1xuICAgIHRoaXMuX19vcmlnaW5hbExpbmVUbyh4LCB5KTtcbiAgfTtcbiAgY3R4LmJlemllckN1cnZlVG8gPSBmdW5jdGlvbiAoY3AxeCwgY3AxeSwgY3AyeCwgY3AyeSwgeCwgeSkge1xuICAgIGRlc3RDdHguYmV6aWVyQ3VydmVUbyhjcDF4LCBjcDF5LCBjcDJ4LCBjcDJ5LCB4LCB5KTtcbiAgICB0aGlzLl9fb3JpZ2luYWxCZXppZXJDdXJ2ZVRvKGNwMXgsIGNwMXksIGNwMngsIGNwMnksIHgsIHkpO1xuICB9O1xuICBjdHgucmVjdCA9IGZ1bmN0aW9uICh4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgZGVzdEN0eC5yZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgIHRoaXMuX19vcmlnaW5hbFJlY3QoeCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gIH07XG4gIGN0eC5jbG9zZVBhdGggPSBmdW5jdGlvbiAoKSB7XG4gICAgZGVzdEN0eC5jbG9zZVBhdGgoKTtcbiAgICB0aGlzLl9fb3JpZ2luYWxDbG9zZVBhdGgoKTtcbiAgfTtcbiAgY3R4LmJlZ2luUGF0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICBkZXN0Q3R4LmJlZ2luUGF0aCgpO1xuICAgIHRoaXMuX19vcmlnaW5hbEJlZ2luUGF0aCgpO1xuICB9O1xufVxuY2xhc3MgQ2FjaGVkQ2FudmFzZXMge1xuICBjb25zdHJ1Y3RvcihjYW52YXNGYWN0b3J5KSB7XG4gICAgdGhpcy5jYW52YXNGYWN0b3J5ID0gY2FudmFzRmFjdG9yeTtcbiAgICB0aGlzLmNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgfVxuICBnZXRDYW52YXMoaWQsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICBsZXQgY2FudmFzRW50cnk7XG4gICAgaWYgKHRoaXMuY2FjaGVbaWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNhbnZhc0VudHJ5ID0gdGhpcy5jYWNoZVtpZF07XG4gICAgICB0aGlzLmNhbnZhc0ZhY3RvcnkucmVzZXQoY2FudmFzRW50cnksIHdpZHRoLCBoZWlnaHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYW52YXNFbnRyeSA9IHRoaXMuY2FudmFzRmFjdG9yeS5jcmVhdGUod2lkdGgsIGhlaWdodCk7XG4gICAgICB0aGlzLmNhY2hlW2lkXSA9IGNhbnZhc0VudHJ5O1xuICAgIH1cbiAgICByZXR1cm4gY2FudmFzRW50cnk7XG4gIH1cbiAgZGVsZXRlKGlkKSB7XG4gICAgZGVsZXRlIHRoaXMuY2FjaGVbaWRdO1xuICB9XG4gIGNsZWFyKCkge1xuICAgIGZvciAoY29uc3QgaWQgaW4gdGhpcy5jYWNoZSkge1xuICAgICAgY29uc3QgY2FudmFzRW50cnkgPSB0aGlzLmNhY2hlW2lkXTtcbiAgICAgIHRoaXMuY2FudmFzRmFjdG9yeS5kZXN0cm95KGNhbnZhc0VudHJ5KTtcbiAgICAgIGRlbGV0ZSB0aGlzLmNhY2hlW2lkXTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGRyYXdJbWFnZUF0SW50ZWdlckNvb3JkcyhjdHgsIHNyY0ltZywgc3JjWCwgc3JjWSwgc3JjVywgc3JjSCwgZGVzdFgsIGRlc3RZLCBkZXN0VywgZGVzdEgpIHtcbiAgY29uc3QgW2EsIGIsIGMsIGQsIHR4LCB0eV0gPSAoMCwgX2Rpc3BsYXlfdXRpbHMuZ2V0Q3VycmVudFRyYW5zZm9ybSkoY3R4KTtcbiAgaWYgKGIgPT09IDAgJiYgYyA9PT0gMCkge1xuICAgIGNvbnN0IHRsWCA9IGRlc3RYICogYSArIHR4O1xuICAgIGNvbnN0IHJUbFggPSBNYXRoLnJvdW5kKHRsWCk7XG4gICAgY29uc3QgdGxZID0gZGVzdFkgKiBkICsgdHk7XG4gICAgY29uc3QgclRsWSA9IE1hdGgucm91bmQodGxZKTtcbiAgICBjb25zdCBiclggPSAoZGVzdFggKyBkZXN0VykgKiBhICsgdHg7XG4gICAgY29uc3QgcldpZHRoID0gTWF0aC5hYnMoTWF0aC5yb3VuZChiclgpIC0gclRsWCkgfHwgMTtcbiAgICBjb25zdCBiclkgPSAoZGVzdFkgKyBkZXN0SCkgKiBkICsgdHk7XG4gICAgY29uc3QgckhlaWdodCA9IE1hdGguYWJzKE1hdGgucm91bmQoYnJZKSAtIHJUbFkpIHx8IDE7XG4gICAgY3R4LnNldFRyYW5zZm9ybShNYXRoLnNpZ24oYSksIDAsIDAsIE1hdGguc2lnbihkKSwgclRsWCwgclRsWSk7XG4gICAgY3R4LmRyYXdJbWFnZShzcmNJbWcsIHNyY1gsIHNyY1ksIHNyY1csIHNyY0gsIDAsIDAsIHJXaWR0aCwgckhlaWdodCk7XG4gICAgY3R4LnNldFRyYW5zZm9ybShhLCBiLCBjLCBkLCB0eCwgdHkpO1xuICAgIHJldHVybiBbcldpZHRoLCBySGVpZ2h0XTtcbiAgfVxuICBpZiAoYSA9PT0gMCAmJiBkID09PSAwKSB7XG4gICAgY29uc3QgdGxYID0gZGVzdFkgKiBjICsgdHg7XG4gICAgY29uc3QgclRsWCA9IE1hdGgucm91bmQodGxYKTtcbiAgICBjb25zdCB0bFkgPSBkZXN0WCAqIGIgKyB0eTtcbiAgICBjb25zdCByVGxZID0gTWF0aC5yb3VuZCh0bFkpO1xuICAgIGNvbnN0IGJyWCA9IChkZXN0WSArIGRlc3RIKSAqIGMgKyB0eDtcbiAgICBjb25zdCByV2lkdGggPSBNYXRoLmFicyhNYXRoLnJvdW5kKGJyWCkgLSByVGxYKSB8fCAxO1xuICAgIGNvbnN0IGJyWSA9IChkZXN0WCArIGRlc3RXKSAqIGIgKyB0eTtcbiAgICBjb25zdCBySGVpZ2h0ID0gTWF0aC5hYnMoTWF0aC5yb3VuZChiclkpIC0gclRsWSkgfHwgMTtcbiAgICBjdHguc2V0VHJhbnNmb3JtKDAsIE1hdGguc2lnbihiKSwgTWF0aC5zaWduKGMpLCAwLCByVGxYLCByVGxZKTtcbiAgICBjdHguZHJhd0ltYWdlKHNyY0ltZywgc3JjWCwgc3JjWSwgc3JjVywgc3JjSCwgMCwgMCwgckhlaWdodCwgcldpZHRoKTtcbiAgICBjdHguc2V0VHJhbnNmb3JtKGEsIGIsIGMsIGQsIHR4LCB0eSk7XG4gICAgcmV0dXJuIFtySGVpZ2h0LCByV2lkdGhdO1xuICB9XG4gIGN0eC5kcmF3SW1hZ2Uoc3JjSW1nLCBzcmNYLCBzcmNZLCBzcmNXLCBzcmNILCBkZXN0WCwgZGVzdFksIGRlc3RXLCBkZXN0SCk7XG4gIGNvbnN0IHNjYWxlWCA9IE1hdGguaHlwb3QoYSwgYik7XG4gIGNvbnN0IHNjYWxlWSA9IE1hdGguaHlwb3QoYywgZCk7XG4gIHJldHVybiBbc2NhbGVYICogZGVzdFcsIHNjYWxlWSAqIGRlc3RIXTtcbn1cbmZ1bmN0aW9uIGNvbXBpbGVUeXBlM0dseXBoKGltZ0RhdGEpIHtcbiAgY29uc3Qge1xuICAgIHdpZHRoLFxuICAgIGhlaWdodFxuICB9ID0gaW1nRGF0YTtcbiAgaWYgKHdpZHRoID4gTUFYX1NJWkVfVE9fQ09NUElMRSB8fCBoZWlnaHQgPiBNQVhfU0laRV9UT19DT01QSUxFKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgUE9JTlRfVE9fUFJPQ0VTU19MSU1JVCA9IDEwMDA7XG4gIGNvbnN0IFBPSU5UX1RZUEVTID0gbmV3IFVpbnQ4QXJyYXkoWzAsIDIsIDQsIDAsIDEsIDAsIDUsIDQsIDgsIDEwLCAwLCA4LCAwLCAyLCAxLCAwXSk7XG4gIGNvbnN0IHdpZHRoMSA9IHdpZHRoICsgMTtcbiAgbGV0IHBvaW50cyA9IG5ldyBVaW50OEFycmF5KHdpZHRoMSAqIChoZWlnaHQgKyAxKSk7XG4gIGxldCBpLCBqLCBqMDtcbiAgY29uc3QgbGluZVNpemUgPSB3aWR0aCArIDcgJiB+NztcbiAgbGV0IGRhdGEgPSBuZXcgVWludDhBcnJheShsaW5lU2l6ZSAqIGhlaWdodCksXG4gICAgcG9zID0gMDtcbiAgZm9yIChjb25zdCBlbGVtIG9mIGltZ0RhdGEuZGF0YSkge1xuICAgIGxldCBtYXNrID0gMTI4O1xuICAgIHdoaWxlIChtYXNrID4gMCkge1xuICAgICAgZGF0YVtwb3MrK10gPSBlbGVtICYgbWFzayA/IDAgOiAyNTU7XG4gICAgICBtYXNrID4+PSAxO1xuICAgIH1cbiAgfVxuICBsZXQgY291bnQgPSAwO1xuICBwb3MgPSAwO1xuICBpZiAoZGF0YVtwb3NdICE9PSAwKSB7XG4gICAgcG9pbnRzWzBdID0gMTtcbiAgICArK2NvdW50O1xuICB9XG4gIGZvciAoaiA9IDE7IGogPCB3aWR0aDsgaisrKSB7XG4gICAgaWYgKGRhdGFbcG9zXSAhPT0gZGF0YVtwb3MgKyAxXSkge1xuICAgICAgcG9pbnRzW2pdID0gZGF0YVtwb3NdID8gMiA6IDE7XG4gICAgICArK2NvdW50O1xuICAgIH1cbiAgICBwb3MrKztcbiAgfVxuICBpZiAoZGF0YVtwb3NdICE9PSAwKSB7XG4gICAgcG9pbnRzW2pdID0gMjtcbiAgICArK2NvdW50O1xuICB9XG4gIGZvciAoaSA9IDE7IGkgPCBoZWlnaHQ7IGkrKykge1xuICAgIHBvcyA9IGkgKiBsaW5lU2l6ZTtcbiAgICBqMCA9IGkgKiB3aWR0aDE7XG4gICAgaWYgKGRhdGFbcG9zIC0gbGluZVNpemVdICE9PSBkYXRhW3Bvc10pIHtcbiAgICAgIHBvaW50c1tqMF0gPSBkYXRhW3Bvc10gPyAxIDogODtcbiAgICAgICsrY291bnQ7XG4gICAgfVxuICAgIGxldCBzdW0gPSAoZGF0YVtwb3NdID8gNCA6IDApICsgKGRhdGFbcG9zIC0gbGluZVNpemVdID8gOCA6IDApO1xuICAgIGZvciAoaiA9IDE7IGogPCB3aWR0aDsgaisrKSB7XG4gICAgICBzdW0gPSAoc3VtID4+IDIpICsgKGRhdGFbcG9zICsgMV0gPyA0IDogMCkgKyAoZGF0YVtwb3MgLSBsaW5lU2l6ZSArIDFdID8gOCA6IDApO1xuICAgICAgaWYgKFBPSU5UX1RZUEVTW3N1bV0pIHtcbiAgICAgICAgcG9pbnRzW2owICsgal0gPSBQT0lOVF9UWVBFU1tzdW1dO1xuICAgICAgICArK2NvdW50O1xuICAgICAgfVxuICAgICAgcG9zKys7XG4gICAgfVxuICAgIGlmIChkYXRhW3BvcyAtIGxpbmVTaXplXSAhPT0gZGF0YVtwb3NdKSB7XG4gICAgICBwb2ludHNbajAgKyBqXSA9IGRhdGFbcG9zXSA/IDIgOiA0O1xuICAgICAgKytjb3VudDtcbiAgICB9XG4gICAgaWYgKGNvdW50ID4gUE9JTlRfVE9fUFJPQ0VTU19MSU1JVCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG4gIHBvcyA9IGxpbmVTaXplICogKGhlaWdodCAtIDEpO1xuICBqMCA9IGkgKiB3aWR0aDE7XG4gIGlmIChkYXRhW3Bvc10gIT09IDApIHtcbiAgICBwb2ludHNbajBdID0gODtcbiAgICArK2NvdW50O1xuICB9XG4gIGZvciAoaiA9IDE7IGogPCB3aWR0aDsgaisrKSB7XG4gICAgaWYgKGRhdGFbcG9zXSAhPT0gZGF0YVtwb3MgKyAxXSkge1xuICAgICAgcG9pbnRzW2owICsgal0gPSBkYXRhW3Bvc10gPyA0IDogODtcbiAgICAgICsrY291bnQ7XG4gICAgfVxuICAgIHBvcysrO1xuICB9XG4gIGlmIChkYXRhW3Bvc10gIT09IDApIHtcbiAgICBwb2ludHNbajAgKyBqXSA9IDQ7XG4gICAgKytjb3VudDtcbiAgfVxuICBpZiAoY291bnQgPiBQT0lOVF9UT19QUk9DRVNTX0xJTUlUKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3Qgc3RlcHMgPSBuZXcgSW50MzJBcnJheShbMCwgd2lkdGgxLCAtMSwgMCwgLXdpZHRoMSwgMCwgMCwgMCwgMV0pO1xuICBjb25zdCBwYXRoID0gbmV3IFBhdGgyRCgpO1xuICBmb3IgKGkgPSAwOyBjb3VudCAmJiBpIDw9IGhlaWdodDsgaSsrKSB7XG4gICAgbGV0IHAgPSBpICogd2lkdGgxO1xuICAgIGNvbnN0IGVuZCA9IHAgKyB3aWR0aDtcbiAgICB3aGlsZSAocCA8IGVuZCAmJiAhcG9pbnRzW3BdKSB7XG4gICAgICBwKys7XG4gICAgfVxuICAgIGlmIChwID09PSBlbmQpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBwYXRoLm1vdmVUbyhwICUgd2lkdGgxLCBpKTtcbiAgICBjb25zdCBwMCA9IHA7XG4gICAgbGV0IHR5cGUgPSBwb2ludHNbcF07XG4gICAgZG8ge1xuICAgICAgY29uc3Qgc3RlcCA9IHN0ZXBzW3R5cGVdO1xuICAgICAgZG8ge1xuICAgICAgICBwICs9IHN0ZXA7XG4gICAgICB9IHdoaWxlICghcG9pbnRzW3BdKTtcbiAgICAgIGNvbnN0IHBwID0gcG9pbnRzW3BdO1xuICAgICAgaWYgKHBwICE9PSA1ICYmIHBwICE9PSAxMCkge1xuICAgICAgICB0eXBlID0gcHA7XG4gICAgICAgIHBvaW50c1twXSA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0eXBlID0gcHAgJiAweDMzICogdHlwZSA+PiA0O1xuICAgICAgICBwb2ludHNbcF0gJj0gdHlwZSA+PiAyIHwgdHlwZSA8PCAyO1xuICAgICAgfVxuICAgICAgcGF0aC5saW5lVG8ocCAlIHdpZHRoMSwgcCAvIHdpZHRoMSB8IDApO1xuICAgICAgaWYgKCFwb2ludHNbcF0pIHtcbiAgICAgICAgLS1jb3VudDtcbiAgICAgIH1cbiAgICB9IHdoaWxlIChwMCAhPT0gcCk7XG4gICAgLS1pO1xuICB9XG4gIGRhdGEgPSBudWxsO1xuICBwb2ludHMgPSBudWxsO1xuICBjb25zdCBkcmF3T3V0bGluZSA9IGZ1bmN0aW9uIChjKSB7XG4gICAgYy5zYXZlKCk7XG4gICAgYy5zY2FsZSgxIC8gd2lkdGgsIC0xIC8gaGVpZ2h0KTtcbiAgICBjLnRyYW5zbGF0ZSgwLCAtaGVpZ2h0KTtcbiAgICBjLmZpbGwocGF0aCk7XG4gICAgYy5iZWdpblBhdGgoKTtcbiAgICBjLnJlc3RvcmUoKTtcbiAgfTtcbiAgcmV0dXJuIGRyYXdPdXRsaW5lO1xufVxuY2xhc3MgQ2FudmFzRXh0cmFTdGF0ZSB7XG4gIGNvbnN0cnVjdG9yKHdpZHRoLCBoZWlnaHQpIHtcbiAgICB0aGlzLmFscGhhSXNTaGFwZSA9IGZhbHNlO1xuICAgIHRoaXMuZm9udFNpemUgPSAwO1xuICAgIHRoaXMuZm9udFNpemVTY2FsZSA9IDE7XG4gICAgdGhpcy50ZXh0TWF0cml4ID0gX3V0aWwuSURFTlRJVFlfTUFUUklYO1xuICAgIHRoaXMudGV4dE1hdHJpeFNjYWxlID0gMTtcbiAgICB0aGlzLmZvbnRNYXRyaXggPSBfdXRpbC5GT05UX0lERU5USVRZX01BVFJJWDtcbiAgICB0aGlzLmxlYWRpbmcgPSAwO1xuICAgIHRoaXMueCA9IDA7XG4gICAgdGhpcy55ID0gMDtcbiAgICB0aGlzLmxpbmVYID0gMDtcbiAgICB0aGlzLmxpbmVZID0gMDtcbiAgICB0aGlzLmNoYXJTcGFjaW5nID0gMDtcbiAgICB0aGlzLndvcmRTcGFjaW5nID0gMDtcbiAgICB0aGlzLnRleHRIU2NhbGUgPSAxO1xuICAgIHRoaXMudGV4dFJlbmRlcmluZ01vZGUgPSBfdXRpbC5UZXh0UmVuZGVyaW5nTW9kZS5GSUxMO1xuICAgIHRoaXMudGV4dFJpc2UgPSAwO1xuICAgIHRoaXMuZmlsbENvbG9yID0gXCIjMDAwMDAwXCI7XG4gICAgdGhpcy5zdHJva2VDb2xvciA9IFwiIzAwMDAwMFwiO1xuICAgIHRoaXMucGF0dGVybkZpbGwgPSBmYWxzZTtcbiAgICB0aGlzLmZpbGxBbHBoYSA9IDE7XG4gICAgdGhpcy5zdHJva2VBbHBoYSA9IDE7XG4gICAgdGhpcy5saW5lV2lkdGggPSAxO1xuICAgIHRoaXMuYWN0aXZlU01hc2sgPSBudWxsO1xuICAgIHRoaXMudHJhbnNmZXJNYXBzID0gXCJub25lXCI7XG4gICAgdGhpcy5zdGFydE5ld1BhdGhBbmRDbGlwQm94KFswLCAwLCB3aWR0aCwgaGVpZ2h0XSk7XG4gIH1cbiAgY2xvbmUoKSB7XG4gICAgY29uc3QgY2xvbmUgPSBPYmplY3QuY3JlYXRlKHRoaXMpO1xuICAgIGNsb25lLmNsaXBCb3ggPSB0aGlzLmNsaXBCb3guc2xpY2UoKTtcbiAgICByZXR1cm4gY2xvbmU7XG4gIH1cbiAgc2V0Q3VycmVudFBvaW50KHgsIHkpIHtcbiAgICB0aGlzLnggPSB4O1xuICAgIHRoaXMueSA9IHk7XG4gIH1cbiAgdXBkYXRlUGF0aE1pbk1heCh0cmFuc2Zvcm0sIHgsIHkpIHtcbiAgICBbeCwgeV0gPSBfdXRpbC5VdGlsLmFwcGx5VHJhbnNmb3JtKFt4LCB5XSwgdHJhbnNmb3JtKTtcbiAgICB0aGlzLm1pblggPSBNYXRoLm1pbih0aGlzLm1pblgsIHgpO1xuICAgIHRoaXMubWluWSA9IE1hdGgubWluKHRoaXMubWluWSwgeSk7XG4gICAgdGhpcy5tYXhYID0gTWF0aC5tYXgodGhpcy5tYXhYLCB4KTtcbiAgICB0aGlzLm1heFkgPSBNYXRoLm1heCh0aGlzLm1heFksIHkpO1xuICB9XG4gIHVwZGF0ZVJlY3RNaW5NYXgodHJhbnNmb3JtLCByZWN0KSB7XG4gICAgY29uc3QgcDEgPSBfdXRpbC5VdGlsLmFwcGx5VHJhbnNmb3JtKHJlY3QsIHRyYW5zZm9ybSk7XG4gICAgY29uc3QgcDIgPSBfdXRpbC5VdGlsLmFwcGx5VHJhbnNmb3JtKHJlY3Quc2xpY2UoMiksIHRyYW5zZm9ybSk7XG4gICAgdGhpcy5taW5YID0gTWF0aC5taW4odGhpcy5taW5YLCBwMVswXSwgcDJbMF0pO1xuICAgIHRoaXMubWluWSA9IE1hdGgubWluKHRoaXMubWluWSwgcDFbMV0sIHAyWzFdKTtcbiAgICB0aGlzLm1heFggPSBNYXRoLm1heCh0aGlzLm1heFgsIHAxWzBdLCBwMlswXSk7XG4gICAgdGhpcy5tYXhZID0gTWF0aC5tYXgodGhpcy5tYXhZLCBwMVsxXSwgcDJbMV0pO1xuICB9XG4gIHVwZGF0ZVNjYWxpbmdQYXRoTWluTWF4KHRyYW5zZm9ybSwgbWluTWF4KSB7XG4gICAgX3V0aWwuVXRpbC5zY2FsZU1pbk1heCh0cmFuc2Zvcm0sIG1pbk1heCk7XG4gICAgdGhpcy5taW5YID0gTWF0aC5taW4odGhpcy5taW5YLCBtaW5NYXhbMF0pO1xuICAgIHRoaXMubWF4WCA9IE1hdGgubWF4KHRoaXMubWF4WCwgbWluTWF4WzFdKTtcbiAgICB0aGlzLm1pblkgPSBNYXRoLm1pbih0aGlzLm1pblksIG1pbk1heFsyXSk7XG4gICAgdGhpcy5tYXhZID0gTWF0aC5tYXgodGhpcy5tYXhZLCBtaW5NYXhbM10pO1xuICB9XG4gIHVwZGF0ZUN1cnZlUGF0aE1pbk1heCh0cmFuc2Zvcm0sIHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIsIHgzLCB5MywgbWluTWF4KSB7XG4gICAgY29uc3QgYm94ID0gX3V0aWwuVXRpbC5iZXppZXJCb3VuZGluZ0JveCh4MCwgeTAsIHgxLCB5MSwgeDIsIHkyLCB4MywgeTMpO1xuICAgIGlmIChtaW5NYXgpIHtcbiAgICAgIG1pbk1heFswXSA9IE1hdGgubWluKG1pbk1heFswXSwgYm94WzBdLCBib3hbMl0pO1xuICAgICAgbWluTWF4WzFdID0gTWF0aC5tYXgobWluTWF4WzFdLCBib3hbMF0sIGJveFsyXSk7XG4gICAgICBtaW5NYXhbMl0gPSBNYXRoLm1pbihtaW5NYXhbMl0sIGJveFsxXSwgYm94WzNdKTtcbiAgICAgIG1pbk1heFszXSA9IE1hdGgubWF4KG1pbk1heFszXSwgYm94WzFdLCBib3hbM10pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnVwZGF0ZVJlY3RNaW5NYXgodHJhbnNmb3JtLCBib3gpO1xuICB9XG4gIGdldFBhdGhCb3VuZGluZ0JveChwYXRoVHlwZSA9IF9wYXR0ZXJuX2hlbHBlci5QYXRoVHlwZS5GSUxMLCB0cmFuc2Zvcm0gPSBudWxsKSB7XG4gICAgY29uc3QgYm94ID0gW3RoaXMubWluWCwgdGhpcy5taW5ZLCB0aGlzLm1heFgsIHRoaXMubWF4WV07XG4gICAgaWYgKHBhdGhUeXBlID09PSBfcGF0dGVybl9oZWxwZXIuUGF0aFR5cGUuU1RST0tFKSB7XG4gICAgICBpZiAoIXRyYW5zZm9ybSkge1xuICAgICAgICAoMCwgX3V0aWwudW5yZWFjaGFibGUpKFwiU3Ryb2tlIGJvdW5kaW5nIGJveCBtdXN0IGluY2x1ZGUgdHJhbnNmb3JtLlwiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNjYWxlID0gX3V0aWwuVXRpbC5zaW5ndWxhclZhbHVlRGVjb21wb3NlMmRTY2FsZSh0cmFuc2Zvcm0pO1xuICAgICAgY29uc3QgeFN0cm9rZVBhZCA9IHNjYWxlWzBdICogdGhpcy5saW5lV2lkdGggLyAyO1xuICAgICAgY29uc3QgeVN0cm9rZVBhZCA9IHNjYWxlWzFdICogdGhpcy5saW5lV2lkdGggLyAyO1xuICAgICAgYm94WzBdIC09IHhTdHJva2VQYWQ7XG4gICAgICBib3hbMV0gLT0geVN0cm9rZVBhZDtcbiAgICAgIGJveFsyXSArPSB4U3Ryb2tlUGFkO1xuICAgICAgYm94WzNdICs9IHlTdHJva2VQYWQ7XG4gICAgfVxuICAgIHJldHVybiBib3g7XG4gIH1cbiAgdXBkYXRlQ2xpcEZyb21QYXRoKCkge1xuICAgIGNvbnN0IGludGVyc2VjdCA9IF91dGlsLlV0aWwuaW50ZXJzZWN0KHRoaXMuY2xpcEJveCwgdGhpcy5nZXRQYXRoQm91bmRpbmdCb3goKSk7XG4gICAgdGhpcy5zdGFydE5ld1BhdGhBbmRDbGlwQm94KGludGVyc2VjdCB8fCBbMCwgMCwgMCwgMF0pO1xuICB9XG4gIGlzRW1wdHlDbGlwKCkge1xuICAgIHJldHVybiB0aGlzLm1pblggPT09IEluZmluaXR5O1xuICB9XG4gIHN0YXJ0TmV3UGF0aEFuZENsaXBCb3goYm94KSB7XG4gICAgdGhpcy5jbGlwQm94ID0gYm94O1xuICAgIHRoaXMubWluWCA9IEluZmluaXR5O1xuICAgIHRoaXMubWluWSA9IEluZmluaXR5O1xuICAgIHRoaXMubWF4WCA9IDA7XG4gICAgdGhpcy5tYXhZID0gMDtcbiAgfVxuICBnZXRDbGlwcGVkUGF0aEJvdW5kaW5nQm94KHBhdGhUeXBlID0gX3BhdHRlcm5faGVscGVyLlBhdGhUeXBlLkZJTEwsIHRyYW5zZm9ybSA9IG51bGwpIHtcbiAgICByZXR1cm4gX3V0aWwuVXRpbC5pbnRlcnNlY3QodGhpcy5jbGlwQm94LCB0aGlzLmdldFBhdGhCb3VuZGluZ0JveChwYXRoVHlwZSwgdHJhbnNmb3JtKSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHB1dEJpbmFyeUltYWdlRGF0YShjdHgsIGltZ0RhdGEpIHtcbiAgaWYgKHR5cGVvZiBJbWFnZURhdGEgIT09IFwidW5kZWZpbmVkXCIgJiYgaW1nRGF0YSBpbnN0YW5jZW9mIEltYWdlRGF0YSkge1xuICAgIGN0eC5wdXRJbWFnZURhdGEoaW1nRGF0YSwgMCwgMCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGhlaWdodCA9IGltZ0RhdGEuaGVpZ2h0LFxuICAgIHdpZHRoID0gaW1nRGF0YS53aWR0aDtcbiAgY29uc3QgcGFydGlhbENodW5rSGVpZ2h0ID0gaGVpZ2h0ICUgRlVMTF9DSFVOS19IRUlHSFQ7XG4gIGNvbnN0IGZ1bGxDaHVua3MgPSAoaGVpZ2h0IC0gcGFydGlhbENodW5rSGVpZ2h0KSAvIEZVTExfQ0hVTktfSEVJR0hUO1xuICBjb25zdCB0b3RhbENodW5rcyA9IHBhcnRpYWxDaHVua0hlaWdodCA9PT0gMCA/IGZ1bGxDaHVua3MgOiBmdWxsQ2h1bmtzICsgMTtcbiAgY29uc3QgY2h1bmtJbWdEYXRhID0gY3R4LmNyZWF0ZUltYWdlRGF0YSh3aWR0aCwgRlVMTF9DSFVOS19IRUlHSFQpO1xuICBsZXQgc3JjUG9zID0gMCxcbiAgICBkZXN0UG9zO1xuICBjb25zdCBzcmMgPSBpbWdEYXRhLmRhdGE7XG4gIGNvbnN0IGRlc3QgPSBjaHVua0ltZ0RhdGEuZGF0YTtcbiAgbGV0IGksIGosIHRoaXNDaHVua0hlaWdodCwgZWxlbXNJblRoaXNDaHVuaztcbiAgaWYgKGltZ0RhdGEua2luZCA9PT0gX3V0aWwuSW1hZ2VLaW5kLkdSQVlTQ0FMRV8xQlBQKSB7XG4gICAgY29uc3Qgc3JjTGVuZ3RoID0gc3JjLmJ5dGVMZW5ndGg7XG4gICAgY29uc3QgZGVzdDMyID0gbmV3IFVpbnQzMkFycmF5KGRlc3QuYnVmZmVyLCAwLCBkZXN0LmJ5dGVMZW5ndGggPj4gMik7XG4gICAgY29uc3QgZGVzdDMyRGF0YUxlbmd0aCA9IGRlc3QzMi5sZW5ndGg7XG4gICAgY29uc3QgZnVsbFNyY0RpZmYgPSB3aWR0aCArIDcgPj4gMztcbiAgICBjb25zdCB3aGl0ZSA9IDB4ZmZmZmZmZmY7XG4gICAgY29uc3QgYmxhY2sgPSBfdXRpbC5GZWF0dXJlVGVzdC5pc0xpdHRsZUVuZGlhbiA/IDB4ZmYwMDAwMDAgOiAweDAwMDAwMGZmO1xuICAgIGZvciAoaSA9IDA7IGkgPCB0b3RhbENodW5rczsgaSsrKSB7XG4gICAgICB0aGlzQ2h1bmtIZWlnaHQgPSBpIDwgZnVsbENodW5rcyA/IEZVTExfQ0hVTktfSEVJR0hUIDogcGFydGlhbENodW5rSGVpZ2h0O1xuICAgICAgZGVzdFBvcyA9IDA7XG4gICAgICBmb3IgKGogPSAwOyBqIDwgdGhpc0NodW5rSGVpZ2h0OyBqKyspIHtcbiAgICAgICAgY29uc3Qgc3JjRGlmZiA9IHNyY0xlbmd0aCAtIHNyY1BvcztcbiAgICAgICAgbGV0IGsgPSAwO1xuICAgICAgICBjb25zdCBrRW5kID0gc3JjRGlmZiA+IGZ1bGxTcmNEaWZmID8gd2lkdGggOiBzcmNEaWZmICogOCAtIDc7XG4gICAgICAgIGNvbnN0IGtFbmRVbnJvbGxlZCA9IGtFbmQgJiB+NztcbiAgICAgICAgbGV0IG1hc2sgPSAwO1xuICAgICAgICBsZXQgc3JjQnl0ZSA9IDA7XG4gICAgICAgIGZvciAoOyBrIDwga0VuZFVucm9sbGVkOyBrICs9IDgpIHtcbiAgICAgICAgICBzcmNCeXRlID0gc3JjW3NyY1BvcysrXTtcbiAgICAgICAgICBkZXN0MzJbZGVzdFBvcysrXSA9IHNyY0J5dGUgJiAxMjggPyB3aGl0ZSA6IGJsYWNrO1xuICAgICAgICAgIGRlc3QzMltkZXN0UG9zKytdID0gc3JjQnl0ZSAmIDY0ID8gd2hpdGUgOiBibGFjaztcbiAgICAgICAgICBkZXN0MzJbZGVzdFBvcysrXSA9IHNyY0J5dGUgJiAzMiA/IHdoaXRlIDogYmxhY2s7XG4gICAgICAgICAgZGVzdDMyW2Rlc3RQb3MrK10gPSBzcmNCeXRlICYgMTYgPyB3aGl0ZSA6IGJsYWNrO1xuICAgICAgICAgIGRlc3QzMltkZXN0UG9zKytdID0gc3JjQnl0ZSAmIDggPyB3aGl0ZSA6IGJsYWNrO1xuICAgICAgICAgIGRlc3QzMltkZXN0UG9zKytdID0gc3JjQnl0ZSAmIDQgPyB3aGl0ZSA6IGJsYWNrO1xuICAgICAgICAgIGRlc3QzMltkZXN0UG9zKytdID0gc3JjQnl0ZSAmIDIgPyB3aGl0ZSA6IGJsYWNrO1xuICAgICAgICAgIGRlc3QzMltkZXN0UG9zKytdID0gc3JjQnl0ZSAmIDEgPyB3aGl0ZSA6IGJsYWNrO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoOyBrIDwga0VuZDsgaysrKSB7XG4gICAgICAgICAgaWYgKG1hc2sgPT09IDApIHtcbiAgICAgICAgICAgIHNyY0J5dGUgPSBzcmNbc3JjUG9zKytdO1xuICAgICAgICAgICAgbWFzayA9IDEyODtcbiAgICAgICAgICB9XG4gICAgICAgICAgZGVzdDMyW2Rlc3RQb3MrK10gPSBzcmNCeXRlICYgbWFzayA/IHdoaXRlIDogYmxhY2s7XG4gICAgICAgICAgbWFzayA+Pj0gMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgd2hpbGUgKGRlc3RQb3MgPCBkZXN0MzJEYXRhTGVuZ3RoKSB7XG4gICAgICAgIGRlc3QzMltkZXN0UG9zKytdID0gMDtcbiAgICAgIH1cbiAgICAgIGN0eC5wdXRJbWFnZURhdGEoY2h1bmtJbWdEYXRhLCAwLCBpICogRlVMTF9DSFVOS19IRUlHSFQpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpbWdEYXRhLmtpbmQgPT09IF91dGlsLkltYWdlS2luZC5SR0JBXzMyQlBQKSB7XG4gICAgaiA9IDA7XG4gICAgZWxlbXNJblRoaXNDaHVuayA9IHdpZHRoICogRlVMTF9DSFVOS19IRUlHSFQgKiA0O1xuICAgIGZvciAoaSA9IDA7IGkgPCBmdWxsQ2h1bmtzOyBpKyspIHtcbiAgICAgIGRlc3Quc2V0KHNyYy5zdWJhcnJheShzcmNQb3MsIHNyY1BvcyArIGVsZW1zSW5UaGlzQ2h1bmspKTtcbiAgICAgIHNyY1BvcyArPSBlbGVtc0luVGhpc0NodW5rO1xuICAgICAgY3R4LnB1dEltYWdlRGF0YShjaHVua0ltZ0RhdGEsIDAsIGopO1xuICAgICAgaiArPSBGVUxMX0NIVU5LX0hFSUdIVDtcbiAgICB9XG4gICAgaWYgKGkgPCB0b3RhbENodW5rcykge1xuICAgICAgZWxlbXNJblRoaXNDaHVuayA9IHdpZHRoICogcGFydGlhbENodW5rSGVpZ2h0ICogNDtcbiAgICAgIGRlc3Quc2V0KHNyYy5zdWJhcnJheShzcmNQb3MsIHNyY1BvcyArIGVsZW1zSW5UaGlzQ2h1bmspKTtcbiAgICAgIGN0eC5wdXRJbWFnZURhdGEoY2h1bmtJbWdEYXRhLCAwLCBqKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaW1nRGF0YS5raW5kID09PSBfdXRpbC5JbWFnZUtpbmQuUkdCXzI0QlBQKSB7XG4gICAgdGhpc0NodW5rSGVpZ2h0ID0gRlVMTF9DSFVOS19IRUlHSFQ7XG4gICAgZWxlbXNJblRoaXNDaHVuayA9IHdpZHRoICogdGhpc0NodW5rSGVpZ2h0O1xuICAgIGZvciAoaSA9IDA7IGkgPCB0b3RhbENodW5rczsgaSsrKSB7XG4gICAgICBpZiAoaSA+PSBmdWxsQ2h1bmtzKSB7XG4gICAgICAgIHRoaXNDaHVua0hlaWdodCA9IHBhcnRpYWxDaHVua0hlaWdodDtcbiAgICAgICAgZWxlbXNJblRoaXNDaHVuayA9IHdpZHRoICogdGhpc0NodW5rSGVpZ2h0O1xuICAgICAgfVxuICAgICAgZGVzdFBvcyA9IDA7XG4gICAgICBmb3IgKGogPSBlbGVtc0luVGhpc0NodW5rOyBqLS07KSB7XG4gICAgICAgIGRlc3RbZGVzdFBvcysrXSA9IHNyY1tzcmNQb3MrK107XG4gICAgICAgIGRlc3RbZGVzdFBvcysrXSA9IHNyY1tzcmNQb3MrK107XG4gICAgICAgIGRlc3RbZGVzdFBvcysrXSA9IHNyY1tzcmNQb3MrK107XG4gICAgICAgIGRlc3RbZGVzdFBvcysrXSA9IDI1NTtcbiAgICAgIH1cbiAgICAgIGN0eC5wdXRJbWFnZURhdGEoY2h1bmtJbWdEYXRhLCAwLCBpICogRlVMTF9DSFVOS19IRUlHSFQpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYGJhZCBpbWFnZSBraW5kOiAke2ltZ0RhdGEua2luZH1gKTtcbiAgfVxufVxuZnVuY3Rpb24gcHV0QmluYXJ5SW1hZ2VNYXNrKGN0eCwgaW1nRGF0YSkge1xuICBpZiAoaW1nRGF0YS5iaXRtYXApIHtcbiAgICBjdHguZHJhd0ltYWdlKGltZ0RhdGEuYml0bWFwLCAwLCAwKTtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgaGVpZ2h0ID0gaW1nRGF0YS5oZWlnaHQsXG4gICAgd2lkdGggPSBpbWdEYXRhLndpZHRoO1xuICBjb25zdCBwYXJ0aWFsQ2h1bmtIZWlnaHQgPSBoZWlnaHQgJSBGVUxMX0NIVU5LX0hFSUdIVDtcbiAgY29uc3QgZnVsbENodW5rcyA9IChoZWlnaHQgLSBwYXJ0aWFsQ2h1bmtIZWlnaHQpIC8gRlVMTF9DSFVOS19IRUlHSFQ7XG4gIGNvbnN0IHRvdGFsQ2h1bmtzID0gcGFydGlhbENodW5rSGVpZ2h0ID09PSAwID8gZnVsbENodW5rcyA6IGZ1bGxDaHVua3MgKyAxO1xuICBjb25zdCBjaHVua0ltZ0RhdGEgPSBjdHguY3JlYXRlSW1hZ2VEYXRhKHdpZHRoLCBGVUxMX0NIVU5LX0hFSUdIVCk7XG4gIGxldCBzcmNQb3MgPSAwO1xuICBjb25zdCBzcmMgPSBpbWdEYXRhLmRhdGE7XG4gIGNvbnN0IGRlc3QgPSBjaHVua0ltZ0RhdGEuZGF0YTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b3RhbENodW5rczsgaSsrKSB7XG4gICAgY29uc3QgdGhpc0NodW5rSGVpZ2h0ID0gaSA8IGZ1bGxDaHVua3MgPyBGVUxMX0NIVU5LX0hFSUdIVCA6IHBhcnRpYWxDaHVua0hlaWdodDtcbiAgICAoe1xuICAgICAgc3JjUG9zXG4gICAgfSA9ICgwLCBfaW1hZ2VfdXRpbHMuY29udmVydEJsYWNrQW5kV2hpdGVUb1JHQkEpKHtcbiAgICAgIHNyYyxcbiAgICAgIHNyY1BvcyxcbiAgICAgIGRlc3QsXG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodDogdGhpc0NodW5rSGVpZ2h0LFxuICAgICAgbm9uQmxhY2tDb2xvcjogMFxuICAgIH0pKTtcbiAgICBjdHgucHV0SW1hZ2VEYXRhKGNodW5rSW1nRGF0YSwgMCwgaSAqIEZVTExfQ0hVTktfSEVJR0hUKTtcbiAgfVxufVxuZnVuY3Rpb24gY29weUN0eFN0YXRlKHNvdXJjZUN0eCwgZGVzdEN0eCkge1xuICBjb25zdCBwcm9wZXJ0aWVzID0gW1wic3Ryb2tlU3R5bGVcIiwgXCJmaWxsU3R5bGVcIiwgXCJmaWxsUnVsZVwiLCBcImdsb2JhbEFscGhhXCIsIFwibGluZVdpZHRoXCIsIFwibGluZUNhcFwiLCBcImxpbmVKb2luXCIsIFwibWl0ZXJMaW1pdFwiLCBcImdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvblwiLCBcImZvbnRcIiwgXCJmaWx0ZXJcIl07XG4gIGZvciAoY29uc3QgcHJvcGVydHkgb2YgcHJvcGVydGllcykge1xuICAgIGlmIChzb3VyY2VDdHhbcHJvcGVydHldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGRlc3RDdHhbcHJvcGVydHldID0gc291cmNlQ3R4W3Byb3BlcnR5XTtcbiAgICB9XG4gIH1cbiAgaWYgKHNvdXJjZUN0eC5zZXRMaW5lRGFzaCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZGVzdEN0eC5zZXRMaW5lRGFzaChzb3VyY2VDdHguZ2V0TGluZURhc2goKSk7XG4gICAgZGVzdEN0eC5saW5lRGFzaE9mZnNldCA9IHNvdXJjZUN0eC5saW5lRGFzaE9mZnNldDtcbiAgfVxufVxuZnVuY3Rpb24gcmVzZXRDdHhUb0RlZmF1bHQoY3R4KSB7XG4gIGN0eC5zdHJva2VTdHlsZSA9IGN0eC5maWxsU3R5bGUgPSBcIiMwMDAwMDBcIjtcbiAgY3R4LmZpbGxSdWxlID0gXCJub256ZXJvXCI7XG4gIGN0eC5nbG9iYWxBbHBoYSA9IDE7XG4gIGN0eC5saW5lV2lkdGggPSAxO1xuICBjdHgubGluZUNhcCA9IFwiYnV0dFwiO1xuICBjdHgubGluZUpvaW4gPSBcIm1pdGVyXCI7XG4gIGN0eC5taXRlckxpbWl0ID0gMTA7XG4gIGN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBcInNvdXJjZS1vdmVyXCI7XG4gIGN0eC5mb250ID0gXCIxMHB4IHNhbnMtc2VyaWZcIjtcbiAgaWYgKGN0eC5zZXRMaW5lRGFzaCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY3R4LnNldExpbmVEYXNoKFtdKTtcbiAgICBjdHgubGluZURhc2hPZmZzZXQgPSAwO1xuICB9XG4gIGlmICghX3V0aWwuaXNOb2RlSlMpIHtcbiAgICBjb25zdCB7XG4gICAgICBmaWx0ZXJcbiAgICB9ID0gY3R4O1xuICAgIGlmIChmaWx0ZXIgIT09IFwibm9uZVwiICYmIGZpbHRlciAhPT0gXCJcIikge1xuICAgICAgY3R4LmZpbHRlciA9IFwibm9uZVwiO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gY29tcG9zZVNNYXNrQmFja2Ryb3AoYnl0ZXMsIHIwLCBnMCwgYjApIHtcbiAgY29uc3QgbGVuZ3RoID0gYnl0ZXMubGVuZ3RoO1xuICBmb3IgKGxldCBpID0gMzsgaSA8IGxlbmd0aDsgaSArPSA0KSB7XG4gICAgY29uc3QgYWxwaGEgPSBieXRlc1tpXTtcbiAgICBpZiAoYWxwaGEgPT09IDApIHtcbiAgICAgIGJ5dGVzW2kgLSAzXSA9IHIwO1xuICAgICAgYnl0ZXNbaSAtIDJdID0gZzA7XG4gICAgICBieXRlc1tpIC0gMV0gPSBiMDtcbiAgICB9IGVsc2UgaWYgKGFscGhhIDwgMjU1KSB7XG4gICAgICBjb25zdCBhbHBoYV8gPSAyNTUgLSBhbHBoYTtcbiAgICAgIGJ5dGVzW2kgLSAzXSA9IGJ5dGVzW2kgLSAzXSAqIGFscGhhICsgcjAgKiBhbHBoYV8gPj4gODtcbiAgICAgIGJ5dGVzW2kgLSAyXSA9IGJ5dGVzW2kgLSAyXSAqIGFscGhhICsgZzAgKiBhbHBoYV8gPj4gODtcbiAgICAgIGJ5dGVzW2kgLSAxXSA9IGJ5dGVzW2kgLSAxXSAqIGFscGhhICsgYjAgKiBhbHBoYV8gPj4gODtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGNvbXBvc2VTTWFza0FscGhhKG1hc2tEYXRhLCBsYXllckRhdGEsIHRyYW5zZmVyTWFwKSB7XG4gIGNvbnN0IGxlbmd0aCA9IG1hc2tEYXRhLmxlbmd0aDtcbiAgY29uc3Qgc2NhbGUgPSAxIC8gMjU1O1xuICBmb3IgKGxldCBpID0gMzsgaSA8IGxlbmd0aDsgaSArPSA0KSB7XG4gICAgY29uc3QgYWxwaGEgPSB0cmFuc2Zlck1hcCA/IHRyYW5zZmVyTWFwW21hc2tEYXRhW2ldXSA6IG1hc2tEYXRhW2ldO1xuICAgIGxheWVyRGF0YVtpXSA9IGxheWVyRGF0YVtpXSAqIGFscGhhICogc2NhbGUgfCAwO1xuICB9XG59XG5mdW5jdGlvbiBjb21wb3NlU01hc2tMdW1pbm9zaXR5KG1hc2tEYXRhLCBsYXllckRhdGEsIHRyYW5zZmVyTWFwKSB7XG4gIGNvbnN0IGxlbmd0aCA9IG1hc2tEYXRhLmxlbmd0aDtcbiAgZm9yIChsZXQgaSA9IDM7IGkgPCBsZW5ndGg7IGkgKz0gNCkge1xuICAgIGNvbnN0IHkgPSBtYXNrRGF0YVtpIC0gM10gKiA3NyArIG1hc2tEYXRhW2kgLSAyXSAqIDE1MiArIG1hc2tEYXRhW2kgLSAxXSAqIDI4O1xuICAgIGxheWVyRGF0YVtpXSA9IHRyYW5zZmVyTWFwID8gbGF5ZXJEYXRhW2ldICogdHJhbnNmZXJNYXBbeSA+PiA4XSA+PiA4IDogbGF5ZXJEYXRhW2ldICogeSA+PiAxNjtcbiAgfVxufVxuZnVuY3Rpb24gZ2VuZXJpY0NvbXBvc2VTTWFzayhtYXNrQ3R4LCBsYXllckN0eCwgd2lkdGgsIGhlaWdodCwgc3VidHlwZSwgYmFja2Ryb3AsIHRyYW5zZmVyTWFwLCBsYXllck9mZnNldFgsIGxheWVyT2Zmc2V0WSwgbWFza09mZnNldFgsIG1hc2tPZmZzZXRZKSB7XG4gIGNvbnN0IGhhc0JhY2tkcm9wID0gISFiYWNrZHJvcDtcbiAgY29uc3QgcjAgPSBoYXNCYWNrZHJvcCA/IGJhY2tkcm9wWzBdIDogMDtcbiAgY29uc3QgZzAgPSBoYXNCYWNrZHJvcCA/IGJhY2tkcm9wWzFdIDogMDtcbiAgY29uc3QgYjAgPSBoYXNCYWNrZHJvcCA/IGJhY2tkcm9wWzJdIDogMDtcbiAgY29uc3QgY29tcG9zZUZuID0gc3VidHlwZSA9PT0gXCJMdW1pbm9zaXR5XCIgPyBjb21wb3NlU01hc2tMdW1pbm9zaXR5IDogY29tcG9zZVNNYXNrQWxwaGE7XG4gIGNvbnN0IFBJWEVMU19UT19QUk9DRVNTID0gMTA0ODU3NjtcbiAgY29uc3QgY2h1bmtTaXplID0gTWF0aC5taW4oaGVpZ2h0LCBNYXRoLmNlaWwoUElYRUxTX1RPX1BST0NFU1MgLyB3aWR0aCkpO1xuICBmb3IgKGxldCByb3cgPSAwOyByb3cgPCBoZWlnaHQ7IHJvdyArPSBjaHVua1NpemUpIHtcbiAgICBjb25zdCBjaHVua0hlaWdodCA9IE1hdGgubWluKGNodW5rU2l6ZSwgaGVpZ2h0IC0gcm93KTtcbiAgICBjb25zdCBtYXNrRGF0YSA9IG1hc2tDdHguZ2V0SW1hZ2VEYXRhKGxheWVyT2Zmc2V0WCAtIG1hc2tPZmZzZXRYLCByb3cgKyAobGF5ZXJPZmZzZXRZIC0gbWFza09mZnNldFkpLCB3aWR0aCwgY2h1bmtIZWlnaHQpO1xuICAgIGNvbnN0IGxheWVyRGF0YSA9IGxheWVyQ3R4LmdldEltYWdlRGF0YShsYXllck9mZnNldFgsIHJvdyArIGxheWVyT2Zmc2V0WSwgd2lkdGgsIGNodW5rSGVpZ2h0KTtcbiAgICBpZiAoaGFzQmFja2Ryb3ApIHtcbiAgICAgIGNvbXBvc2VTTWFza0JhY2tkcm9wKG1hc2tEYXRhLmRhdGEsIHIwLCBnMCwgYjApO1xuICAgIH1cbiAgICBjb21wb3NlRm4obWFza0RhdGEuZGF0YSwgbGF5ZXJEYXRhLmRhdGEsIHRyYW5zZmVyTWFwKTtcbiAgICBsYXllckN0eC5wdXRJbWFnZURhdGEobGF5ZXJEYXRhLCBsYXllck9mZnNldFgsIHJvdyArIGxheWVyT2Zmc2V0WSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGNvbXBvc2VTTWFzayhjdHgsIHNtYXNrLCBsYXllckN0eCwgbGF5ZXJCb3gpIHtcbiAgY29uc3QgbGF5ZXJPZmZzZXRYID0gbGF5ZXJCb3hbMF07XG4gIGNvbnN0IGxheWVyT2Zmc2V0WSA9IGxheWVyQm94WzFdO1xuICBjb25zdCBsYXllcldpZHRoID0gbGF5ZXJCb3hbMl0gLSBsYXllck9mZnNldFg7XG4gIGNvbnN0IGxheWVySGVpZ2h0ID0gbGF5ZXJCb3hbM10gLSBsYXllck9mZnNldFk7XG4gIGlmIChsYXllcldpZHRoID09PSAwIHx8IGxheWVySGVpZ2h0ID09PSAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGdlbmVyaWNDb21wb3NlU01hc2soc21hc2suY29udGV4dCwgbGF5ZXJDdHgsIGxheWVyV2lkdGgsIGxheWVySGVpZ2h0LCBzbWFzay5zdWJ0eXBlLCBzbWFzay5iYWNrZHJvcCwgc21hc2sudHJhbnNmZXJNYXAsIGxheWVyT2Zmc2V0WCwgbGF5ZXJPZmZzZXRZLCBzbWFzay5vZmZzZXRYLCBzbWFzay5vZmZzZXRZKTtcbiAgY3R4LnNhdmUoKTtcbiAgY3R4Lmdsb2JhbEFscGhhID0gMTtcbiAgY3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IFwic291cmNlLW92ZXJcIjtcbiAgY3R4LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcbiAgY3R4LmRyYXdJbWFnZShsYXllckN0eC5jYW52YXMsIDAsIDApO1xuICBjdHgucmVzdG9yZSgpO1xufVxuZnVuY3Rpb24gZ2V0SW1hZ2VTbW9vdGhpbmdFbmFibGVkKHRyYW5zZm9ybSwgaW50ZXJwb2xhdGUpIHtcbiAgY29uc3Qgc2NhbGUgPSBfdXRpbC5VdGlsLnNpbmd1bGFyVmFsdWVEZWNvbXBvc2UyZFNjYWxlKHRyYW5zZm9ybSk7XG4gIHNjYWxlWzBdID0gTWF0aC5mcm91bmQoc2NhbGVbMF0pO1xuICBzY2FsZVsxXSA9IE1hdGguZnJvdW5kKHNjYWxlWzFdKTtcbiAgY29uc3QgYWN0dWFsU2NhbGUgPSBNYXRoLmZyb3VuZCgoZ2xvYmFsVGhpcy5kZXZpY2VQaXhlbFJhdGlvIHx8IDEpICogX2Rpc3BsYXlfdXRpbHMuUGl4ZWxzUGVySW5jaC5QREZfVE9fQ1NTX1VOSVRTKTtcbiAgaWYgKGludGVycG9sYXRlICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gaW50ZXJwb2xhdGU7XG4gIH0gZWxzZSBpZiAoc2NhbGVbMF0gPD0gYWN0dWFsU2NhbGUgfHwgc2NhbGVbMV0gPD0gYWN0dWFsU2NhbGUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5jb25zdCBMSU5FX0NBUF9TVFlMRVMgPSBbXCJidXR0XCIsIFwicm91bmRcIiwgXCJzcXVhcmVcIl07XG5jb25zdCBMSU5FX0pPSU5fU1RZTEVTID0gW1wibWl0ZXJcIiwgXCJyb3VuZFwiLCBcImJldmVsXCJdO1xuY29uc3QgTk9STUFMX0NMSVAgPSB7fTtcbmNvbnN0IEVPX0NMSVAgPSB7fTtcbmNsYXNzIENhbnZhc0dyYXBoaWNzIHtcbiAgY29uc3RydWN0b3IoY2FudmFzQ3R4LCBjb21tb25PYmpzLCBvYmpzLCBjYW52YXNGYWN0b3J5LCBmaWx0ZXJGYWN0b3J5LCB7XG4gICAgb3B0aW9uYWxDb250ZW50Q29uZmlnLFxuICAgIG1hcmtlZENvbnRlbnRTdGFjayA9IG51bGxcbiAgfSwgYW5ub3RhdGlvbkNhbnZhc01hcCwgcGFnZUNvbG9ycykge1xuICAgIHRoaXMuY3R4ID0gY2FudmFzQ3R4O1xuICAgIHRoaXMuY3VycmVudCA9IG5ldyBDYW52YXNFeHRyYVN0YXRlKHRoaXMuY3R4LmNhbnZhcy53aWR0aCwgdGhpcy5jdHguY2FudmFzLmhlaWdodCk7XG4gICAgdGhpcy5zdGF0ZVN0YWNrID0gW107XG4gICAgdGhpcy5wZW5kaW5nQ2xpcCA9IG51bGw7XG4gICAgdGhpcy5wZW5kaW5nRU9GaWxsID0gZmFsc2U7XG4gICAgdGhpcy5yZXMgPSBudWxsO1xuICAgIHRoaXMueG9ianMgPSBudWxsO1xuICAgIHRoaXMuY29tbW9uT2JqcyA9IGNvbW1vbk9ianM7XG4gICAgdGhpcy5vYmpzID0gb2JqcztcbiAgICB0aGlzLmNhbnZhc0ZhY3RvcnkgPSBjYW52YXNGYWN0b3J5O1xuICAgIHRoaXMuZmlsdGVyRmFjdG9yeSA9IGZpbHRlckZhY3Rvcnk7XG4gICAgdGhpcy5ncm91cFN0YWNrID0gW107XG4gICAgdGhpcy5wcm9jZXNzaW5nVHlwZTMgPSBudWxsO1xuICAgIHRoaXMuYmFzZVRyYW5zZm9ybSA9IG51bGw7XG4gICAgdGhpcy5iYXNlVHJhbnNmb3JtU3RhY2sgPSBbXTtcbiAgICB0aGlzLmdyb3VwTGV2ZWwgPSAwO1xuICAgIHRoaXMuc21hc2tTdGFjayA9IFtdO1xuICAgIHRoaXMuc21hc2tDb3VudGVyID0gMDtcbiAgICB0aGlzLnRlbXBTTWFzayA9IG51bGw7XG4gICAgdGhpcy5zdXNwZW5kZWRDdHggPSBudWxsO1xuICAgIHRoaXMuY29udGVudFZpc2libGUgPSB0cnVlO1xuICAgIHRoaXMubWFya2VkQ29udGVudFN0YWNrID0gbWFya2VkQ29udGVudFN0YWNrIHx8IFtdO1xuICAgIHRoaXMub3B0aW9uYWxDb250ZW50Q29uZmlnID0gb3B0aW9uYWxDb250ZW50Q29uZmlnO1xuICAgIHRoaXMuY2FjaGVkQ2FudmFzZXMgPSBuZXcgQ2FjaGVkQ2FudmFzZXModGhpcy5jYW52YXNGYWN0b3J5KTtcbiAgICB0aGlzLmNhY2hlZFBhdHRlcm5zID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuYW5ub3RhdGlvbkNhbnZhc01hcCA9IGFubm90YXRpb25DYW52YXNNYXA7XG4gICAgdGhpcy52aWV3cG9ydFNjYWxlID0gMTtcbiAgICB0aGlzLm91dHB1dFNjYWxlWCA9IDE7XG4gICAgdGhpcy5vdXRwdXRTY2FsZVkgPSAxO1xuICAgIHRoaXMucGFnZUNvbG9ycyA9IHBhZ2VDb2xvcnM7XG4gICAgdGhpcy5fY2FjaGVkU2NhbGVGb3JTdHJva2luZyA9IFstMSwgMF07XG4gICAgdGhpcy5fY2FjaGVkR2V0U2luZ2xlUGl4ZWxXaWR0aCA9IG51bGw7XG4gICAgdGhpcy5fY2FjaGVkQml0bWFwc01hcCA9IG5ldyBNYXAoKTtcbiAgfVxuICBnZXRPYmplY3QoZGF0YSwgZmFsbGJhY2sgPSBudWxsKSB7XG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiKSB7XG4gICAgICByZXR1cm4gZGF0YS5zdGFydHNXaXRoKFwiZ19cIikgPyB0aGlzLmNvbW1vbk9ianMuZ2V0KGRhdGEpIDogdGhpcy5vYmpzLmdldChkYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbGxiYWNrO1xuICB9XG4gIGJlZ2luRHJhd2luZyh7XG4gICAgdHJhbnNmb3JtLFxuICAgIHZpZXdwb3J0LFxuICAgIHRyYW5zcGFyZW5jeSA9IGZhbHNlLFxuICAgIGJhY2tncm91bmQgPSBudWxsXG4gIH0pIHtcbiAgICBjb25zdCB3aWR0aCA9IHRoaXMuY3R4LmNhbnZhcy53aWR0aDtcbiAgICBjb25zdCBoZWlnaHQgPSB0aGlzLmN0eC5jYW52YXMuaGVpZ2h0O1xuICAgIGNvbnN0IHNhdmVkRmlsbFN0eWxlID0gdGhpcy5jdHguZmlsbFN0eWxlO1xuICAgIHRoaXMuY3R4LmZpbGxTdHlsZSA9IGJhY2tncm91bmQgfHwgXCIjZmZmZmZmXCI7XG4gICAgdGhpcy5jdHguZmlsbFJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgdGhpcy5jdHguZmlsbFN0eWxlID0gc2F2ZWRGaWxsU3R5bGU7XG4gICAgaWYgKHRyYW5zcGFyZW5jeSkge1xuICAgICAgY29uc3QgdHJhbnNwYXJlbnRDYW52YXMgPSB0aGlzLmNhY2hlZENhbnZhc2VzLmdldENhbnZhcyhcInRyYW5zcGFyZW50XCIsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgdGhpcy5jb21wb3NpdGVDdHggPSB0aGlzLmN0eDtcbiAgICAgIHRoaXMudHJhbnNwYXJlbnRDYW52YXMgPSB0cmFuc3BhcmVudENhbnZhcy5jYW52YXM7XG4gICAgICB0aGlzLmN0eCA9IHRyYW5zcGFyZW50Q2FudmFzLmNvbnRleHQ7XG4gICAgICB0aGlzLmN0eC5zYXZlKCk7XG4gICAgICB0aGlzLmN0eC50cmFuc2Zvcm0oLi4uKDAsIF9kaXNwbGF5X3V0aWxzLmdldEN1cnJlbnRUcmFuc2Zvcm0pKHRoaXMuY29tcG9zaXRlQ3R4KSk7XG4gICAgfVxuICAgIHRoaXMuY3R4LnNhdmUoKTtcbiAgICByZXNldEN0eFRvRGVmYXVsdCh0aGlzLmN0eCk7XG4gICAgaWYgKHRyYW5zZm9ybSkge1xuICAgICAgdGhpcy5jdHgudHJhbnNmb3JtKC4uLnRyYW5zZm9ybSk7XG4gICAgICB0aGlzLm91dHB1dFNjYWxlWCA9IHRyYW5zZm9ybVswXTtcbiAgICAgIHRoaXMub3V0cHV0U2NhbGVZID0gdHJhbnNmb3JtWzBdO1xuICAgIH1cbiAgICB0aGlzLmN0eC50cmFuc2Zvcm0oLi4udmlld3BvcnQudHJhbnNmb3JtKTtcbiAgICB0aGlzLnZpZXdwb3J0U2NhbGUgPSB2aWV3cG9ydC5zY2FsZTtcbiAgICB0aGlzLmJhc2VUcmFuc2Zvcm0gPSAoMCwgX2Rpc3BsYXlfdXRpbHMuZ2V0Q3VycmVudFRyYW5zZm9ybSkodGhpcy5jdHgpO1xuICB9XG4gIGV4ZWN1dGVPcGVyYXRvckxpc3Qob3BlcmF0b3JMaXN0LCBleGVjdXRpb25TdGFydElkeCwgY29udGludWVDYWxsYmFjaywgc3RlcHBlcikge1xuICAgIGNvbnN0IGFyZ3NBcnJheSA9IG9wZXJhdG9yTGlzdC5hcmdzQXJyYXk7XG4gICAgY29uc3QgZm5BcnJheSA9IG9wZXJhdG9yTGlzdC5mbkFycmF5O1xuICAgIGxldCBpID0gZXhlY3V0aW9uU3RhcnRJZHggfHwgMDtcbiAgICBjb25zdCBhcmdzQXJyYXlMZW4gPSBhcmdzQXJyYXkubGVuZ3RoO1xuICAgIGlmIChhcmdzQXJyYXlMZW4gPT09IGkpIHtcbiAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgICBjb25zdCBjaHVua09wZXJhdGlvbnMgPSBhcmdzQXJyYXlMZW4gLSBpID4gRVhFQ1VUSU9OX1NURVBTICYmIHR5cGVvZiBjb250aW51ZUNhbGxiYWNrID09PSBcImZ1bmN0aW9uXCI7XG4gICAgY29uc3QgZW5kVGltZSA9IGNodW5rT3BlcmF0aW9ucyA/IERhdGUubm93KCkgKyBFWEVDVVRJT05fVElNRSA6IDA7XG4gICAgbGV0IHN0ZXBzID0gMDtcbiAgICBjb25zdCBjb21tb25PYmpzID0gdGhpcy5jb21tb25PYmpzO1xuICAgIGNvbnN0IG9ianMgPSB0aGlzLm9ianM7XG4gICAgbGV0IGZuSWQ7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGlmIChzdGVwcGVyICE9PSB1bmRlZmluZWQgJiYgaSA9PT0gc3RlcHBlci5uZXh0QnJlYWtQb2ludCkge1xuICAgICAgICBzdGVwcGVyLmJyZWFrSXQoaSwgY29udGludWVDYWxsYmFjayk7XG4gICAgICAgIHJldHVybiBpO1xuICAgICAgfVxuICAgICAgZm5JZCA9IGZuQXJyYXlbaV07XG4gICAgICBpZiAoZm5JZCAhPT0gX3V0aWwuT1BTLmRlcGVuZGVuY3kpIHtcbiAgICAgICAgdGhpc1tmbklkXS5hcHBseSh0aGlzLCBhcmdzQXJyYXlbaV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChjb25zdCBkZXBPYmpJZCBvZiBhcmdzQXJyYXlbaV0pIHtcbiAgICAgICAgICBjb25zdCBvYmpzUG9vbCA9IGRlcE9iaklkLnN0YXJ0c1dpdGgoXCJnX1wiKSA/IGNvbW1vbk9ianMgOiBvYmpzO1xuICAgICAgICAgIGlmICghb2Jqc1Bvb2wuaGFzKGRlcE9iaklkKSkge1xuICAgICAgICAgICAgb2Jqc1Bvb2wuZ2V0KGRlcE9iaklkLCBjb250aW51ZUNhbGxiYWNrKTtcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaSsrO1xuICAgICAgaWYgKGkgPT09IGFyZ3NBcnJheUxlbikge1xuICAgICAgICByZXR1cm4gaTtcbiAgICAgIH1cbiAgICAgIGlmIChjaHVua09wZXJhdGlvbnMgJiYgKytzdGVwcyA+IEVYRUNVVElPTl9TVEVQUykge1xuICAgICAgICBpZiAoRGF0ZS5ub3coKSA+IGVuZFRpbWUpIHtcbiAgICAgICAgICBjb250aW51ZUNhbGxiYWNrKCk7XG4gICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICAgICAgc3RlcHMgPSAwO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAjcmVzdG9yZUluaXRpYWxTdGF0ZSgpIHtcbiAgICB3aGlsZSAodGhpcy5zdGF0ZVN0YWNrLmxlbmd0aCB8fCB0aGlzLmluU01hc2tNb2RlKSB7XG4gICAgICB0aGlzLnJlc3RvcmUoKTtcbiAgICB9XG4gICAgdGhpcy5jdHgucmVzdG9yZSgpO1xuICAgIGlmICh0aGlzLnRyYW5zcGFyZW50Q2FudmFzKSB7XG4gICAgICB0aGlzLmN0eCA9IHRoaXMuY29tcG9zaXRlQ3R4O1xuICAgICAgdGhpcy5jdHguc2F2ZSgpO1xuICAgICAgdGhpcy5jdHguc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuICAgICAgdGhpcy5jdHguZHJhd0ltYWdlKHRoaXMudHJhbnNwYXJlbnRDYW52YXMsIDAsIDApO1xuICAgICAgdGhpcy5jdHgucmVzdG9yZSgpO1xuICAgICAgdGhpcy50cmFuc3BhcmVudENhbnZhcyA9IG51bGw7XG4gICAgfVxuICB9XG4gIGVuZERyYXdpbmcoKSB7XG4gICAgdGhpcy4jcmVzdG9yZUluaXRpYWxTdGF0ZSgpO1xuICAgIHRoaXMuY2FjaGVkQ2FudmFzZXMuY2xlYXIoKTtcbiAgICB0aGlzLmNhY2hlZFBhdHRlcm5zLmNsZWFyKCk7XG4gICAgZm9yIChjb25zdCBjYWNoZSBvZiB0aGlzLl9jYWNoZWRCaXRtYXBzTWFwLnZhbHVlcygpKSB7XG4gICAgICBmb3IgKGNvbnN0IGNhbnZhcyBvZiBjYWNoZS52YWx1ZXMoKSkge1xuICAgICAgICBpZiAodHlwZW9mIEhUTUxDYW52YXNFbGVtZW50ICE9PSBcInVuZGVmaW5lZFwiICYmIGNhbnZhcyBpbnN0YW5jZW9mIEhUTUxDYW52YXNFbGVtZW50KSB7XG4gICAgICAgICAgY2FudmFzLndpZHRoID0gY2FudmFzLmhlaWdodCA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNhY2hlLmNsZWFyKCk7XG4gICAgfVxuICAgIHRoaXMuX2NhY2hlZEJpdG1hcHNNYXAuY2xlYXIoKTtcbiAgICB0aGlzLiNkcmF3RmlsdGVyKCk7XG4gIH1cbiAgI2RyYXdGaWx0ZXIoKSB7XG4gICAgaWYgKHRoaXMucGFnZUNvbG9ycykge1xuICAgICAgY29uc3QgaGNtRmlsdGVySWQgPSB0aGlzLmZpbHRlckZhY3RvcnkuYWRkSENNRmlsdGVyKHRoaXMucGFnZUNvbG9ycy5mb3JlZ3JvdW5kLCB0aGlzLnBhZ2VDb2xvcnMuYmFja2dyb3VuZCk7XG4gICAgICBpZiAoaGNtRmlsdGVySWQgIT09IFwibm9uZVwiKSB7XG4gICAgICAgIGNvbnN0IHNhdmVkRmlsdGVyID0gdGhpcy5jdHguZmlsdGVyO1xuICAgICAgICB0aGlzLmN0eC5maWx0ZXIgPSBoY21GaWx0ZXJJZDtcbiAgICAgICAgdGhpcy5jdHguZHJhd0ltYWdlKHRoaXMuY3R4LmNhbnZhcywgMCwgMCk7XG4gICAgICAgIHRoaXMuY3R4LmZpbHRlciA9IHNhdmVkRmlsdGVyO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBfc2NhbGVJbWFnZShpbWcsIGludmVyc2VUcmFuc2Zvcm0pIHtcbiAgICBjb25zdCB3aWR0aCA9IGltZy53aWR0aDtcbiAgICBjb25zdCBoZWlnaHQgPSBpbWcuaGVpZ2h0O1xuICAgIGxldCB3aWR0aFNjYWxlID0gTWF0aC5tYXgoTWF0aC5oeXBvdChpbnZlcnNlVHJhbnNmb3JtWzBdLCBpbnZlcnNlVHJhbnNmb3JtWzFdKSwgMSk7XG4gICAgbGV0IGhlaWdodFNjYWxlID0gTWF0aC5tYXgoTWF0aC5oeXBvdChpbnZlcnNlVHJhbnNmb3JtWzJdLCBpbnZlcnNlVHJhbnNmb3JtWzNdKSwgMSk7XG4gICAgbGV0IHBhaW50V2lkdGggPSB3aWR0aCxcbiAgICAgIHBhaW50SGVpZ2h0ID0gaGVpZ2h0O1xuICAgIGxldCB0bXBDYW52YXNJZCA9IFwicHJlc2NhbGUxXCI7XG4gICAgbGV0IHRtcENhbnZhcywgdG1wQ3R4O1xuICAgIHdoaWxlICh3aWR0aFNjYWxlID4gMiAmJiBwYWludFdpZHRoID4gMSB8fCBoZWlnaHRTY2FsZSA+IDIgJiYgcGFpbnRIZWlnaHQgPiAxKSB7XG4gICAgICBsZXQgbmV3V2lkdGggPSBwYWludFdpZHRoLFxuICAgICAgICBuZXdIZWlnaHQgPSBwYWludEhlaWdodDtcbiAgICAgIGlmICh3aWR0aFNjYWxlID4gMiAmJiBwYWludFdpZHRoID4gMSkge1xuICAgICAgICBuZXdXaWR0aCA9IHBhaW50V2lkdGggPj0gMTYzODQgPyBNYXRoLmZsb29yKHBhaW50V2lkdGggLyAyKSAtIDEgfHwgMSA6IE1hdGguY2VpbChwYWludFdpZHRoIC8gMik7XG4gICAgICAgIHdpZHRoU2NhbGUgLz0gcGFpbnRXaWR0aCAvIG5ld1dpZHRoO1xuICAgICAgfVxuICAgICAgaWYgKGhlaWdodFNjYWxlID4gMiAmJiBwYWludEhlaWdodCA+IDEpIHtcbiAgICAgICAgbmV3SGVpZ2h0ID0gcGFpbnRIZWlnaHQgPj0gMTYzODQgPyBNYXRoLmZsb29yKHBhaW50SGVpZ2h0IC8gMikgLSAxIHx8IDEgOiBNYXRoLmNlaWwocGFpbnRIZWlnaHQpIC8gMjtcbiAgICAgICAgaGVpZ2h0U2NhbGUgLz0gcGFpbnRIZWlnaHQgLyBuZXdIZWlnaHQ7XG4gICAgICB9XG4gICAgICB0bXBDYW52YXMgPSB0aGlzLmNhY2hlZENhbnZhc2VzLmdldENhbnZhcyh0bXBDYW52YXNJZCwgbmV3V2lkdGgsIG5ld0hlaWdodCk7XG4gICAgICB0bXBDdHggPSB0bXBDYW52YXMuY29udGV4dDtcbiAgICAgIHRtcEN0eC5jbGVhclJlY3QoMCwgMCwgbmV3V2lkdGgsIG5ld0hlaWdodCk7XG4gICAgICB0bXBDdHguZHJhd0ltYWdlKGltZywgMCwgMCwgcGFpbnRXaWR0aCwgcGFpbnRIZWlnaHQsIDAsIDAsIG5ld1dpZHRoLCBuZXdIZWlnaHQpO1xuICAgICAgaW1nID0gdG1wQ2FudmFzLmNhbnZhcztcbiAgICAgIHBhaW50V2lkdGggPSBuZXdXaWR0aDtcbiAgICAgIHBhaW50SGVpZ2h0ID0gbmV3SGVpZ2h0O1xuICAgICAgdG1wQ2FudmFzSWQgPSB0bXBDYW52YXNJZCA9PT0gXCJwcmVzY2FsZTFcIiA/IFwicHJlc2NhbGUyXCIgOiBcInByZXNjYWxlMVwiO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgaW1nLFxuICAgICAgcGFpbnRXaWR0aCxcbiAgICAgIHBhaW50SGVpZ2h0XG4gICAgfTtcbiAgfVxuICBfY3JlYXRlTWFza0NhbnZhcyhpbWcpIHtcbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICBjb25zdCB7XG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodFxuICAgIH0gPSBpbWc7XG4gICAgY29uc3QgZmlsbENvbG9yID0gdGhpcy5jdXJyZW50LmZpbGxDb2xvcjtcbiAgICBjb25zdCBpc1BhdHRlcm5GaWxsID0gdGhpcy5jdXJyZW50LnBhdHRlcm5GaWxsO1xuICAgIGNvbnN0IGN1cnJlbnRUcmFuc2Zvcm0gPSAoMCwgX2Rpc3BsYXlfdXRpbHMuZ2V0Q3VycmVudFRyYW5zZm9ybSkoY3R4KTtcbiAgICBsZXQgY2FjaGUsIGNhY2hlS2V5LCBzY2FsZWQsIG1hc2tDYW52YXM7XG4gICAgaWYgKChpbWcuYml0bWFwIHx8IGltZy5kYXRhKSAmJiBpbWcuY291bnQgPiAxKSB7XG4gICAgICBjb25zdCBtYWluS2V5ID0gaW1nLmJpdG1hcCB8fCBpbWcuZGF0YS5idWZmZXI7XG4gICAgICBjYWNoZUtleSA9IEpTT04uc3RyaW5naWZ5KGlzUGF0dGVybkZpbGwgPyBjdXJyZW50VHJhbnNmb3JtIDogW2N1cnJlbnRUcmFuc2Zvcm0uc2xpY2UoMCwgNCksIGZpbGxDb2xvcl0pO1xuICAgICAgY2FjaGUgPSB0aGlzLl9jYWNoZWRCaXRtYXBzTWFwLmdldChtYWluS2V5KTtcbiAgICAgIGlmICghY2FjaGUpIHtcbiAgICAgICAgY2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX2NhY2hlZEJpdG1hcHNNYXAuc2V0KG1haW5LZXksIGNhY2hlKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNhY2hlZEltYWdlID0gY2FjaGUuZ2V0KGNhY2hlS2V5KTtcbiAgICAgIGlmIChjYWNoZWRJbWFnZSAmJiAhaXNQYXR0ZXJuRmlsbCkge1xuICAgICAgICBjb25zdCBvZmZzZXRYID0gTWF0aC5yb3VuZChNYXRoLm1pbihjdXJyZW50VHJhbnNmb3JtWzBdLCBjdXJyZW50VHJhbnNmb3JtWzJdKSArIGN1cnJlbnRUcmFuc2Zvcm1bNF0pO1xuICAgICAgICBjb25zdCBvZmZzZXRZID0gTWF0aC5yb3VuZChNYXRoLm1pbihjdXJyZW50VHJhbnNmb3JtWzFdLCBjdXJyZW50VHJhbnNmb3JtWzNdKSArIGN1cnJlbnRUcmFuc2Zvcm1bNV0pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGNhbnZhczogY2FjaGVkSW1hZ2UsXG4gICAgICAgICAgb2Zmc2V0WCxcbiAgICAgICAgICBvZmZzZXRZXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBzY2FsZWQgPSBjYWNoZWRJbWFnZTtcbiAgICB9XG4gICAgaWYgKCFzY2FsZWQpIHtcbiAgICAgIG1hc2tDYW52YXMgPSB0aGlzLmNhY2hlZENhbnZhc2VzLmdldENhbnZhcyhcIm1hc2tDYW52YXNcIiwgd2lkdGgsIGhlaWdodCk7XG4gICAgICBwdXRCaW5hcnlJbWFnZU1hc2sobWFza0NhbnZhcy5jb250ZXh0LCBpbWcpO1xuICAgIH1cbiAgICBsZXQgbWFza1RvQ2FudmFzID0gX3V0aWwuVXRpbC50cmFuc2Zvcm0oY3VycmVudFRyYW5zZm9ybSwgWzEgLyB3aWR0aCwgMCwgMCwgLTEgLyBoZWlnaHQsIDAsIDBdKTtcbiAgICBtYXNrVG9DYW52YXMgPSBfdXRpbC5VdGlsLnRyYW5zZm9ybShtYXNrVG9DYW52YXMsIFsxLCAwLCAwLCAxLCAwLCAtaGVpZ2h0XSk7XG4gICAgY29uc3QgY29yZDEgPSBfdXRpbC5VdGlsLmFwcGx5VHJhbnNmb3JtKFswLCAwXSwgbWFza1RvQ2FudmFzKTtcbiAgICBjb25zdCBjb3JkMiA9IF91dGlsLlV0aWwuYXBwbHlUcmFuc2Zvcm0oW3dpZHRoLCBoZWlnaHRdLCBtYXNrVG9DYW52YXMpO1xuICAgIGNvbnN0IHJlY3QgPSBfdXRpbC5VdGlsLm5vcm1hbGl6ZVJlY3QoW2NvcmQxWzBdLCBjb3JkMVsxXSwgY29yZDJbMF0sIGNvcmQyWzFdXSk7XG4gICAgY29uc3QgZHJhd25XaWR0aCA9IE1hdGgucm91bmQocmVjdFsyXSAtIHJlY3RbMF0pIHx8IDE7XG4gICAgY29uc3QgZHJhd25IZWlnaHQgPSBNYXRoLnJvdW5kKHJlY3RbM10gLSByZWN0WzFdKSB8fCAxO1xuICAgIGNvbnN0IGZpbGxDYW52YXMgPSB0aGlzLmNhY2hlZENhbnZhc2VzLmdldENhbnZhcyhcImZpbGxDYW52YXNcIiwgZHJhd25XaWR0aCwgZHJhd25IZWlnaHQpO1xuICAgIGNvbnN0IGZpbGxDdHggPSBmaWxsQ2FudmFzLmNvbnRleHQ7XG4gICAgY29uc3Qgb2Zmc2V0WCA9IE1hdGgubWluKGNvcmQxWzBdLCBjb3JkMlswXSk7XG4gICAgY29uc3Qgb2Zmc2V0WSA9IE1hdGgubWluKGNvcmQxWzFdLCBjb3JkMlsxXSk7XG4gICAgZmlsbEN0eC50cmFuc2xhdGUoLW9mZnNldFgsIC1vZmZzZXRZKTtcbiAgICBmaWxsQ3R4LnRyYW5zZm9ybSguLi5tYXNrVG9DYW52YXMpO1xuICAgIGlmICghc2NhbGVkKSB7XG4gICAgICBzY2FsZWQgPSB0aGlzLl9zY2FsZUltYWdlKG1hc2tDYW52YXMuY2FudmFzLCAoMCwgX2Rpc3BsYXlfdXRpbHMuZ2V0Q3VycmVudFRyYW5zZm9ybUludmVyc2UpKGZpbGxDdHgpKTtcbiAgICAgIHNjYWxlZCA9IHNjYWxlZC5pbWc7XG4gICAgICBpZiAoY2FjaGUgJiYgaXNQYXR0ZXJuRmlsbCkge1xuICAgICAgICBjYWNoZS5zZXQoY2FjaGVLZXksIHNjYWxlZCk7XG4gICAgICB9XG4gICAgfVxuICAgIGZpbGxDdHguaW1hZ2VTbW9vdGhpbmdFbmFibGVkID0gZ2V0SW1hZ2VTbW9vdGhpbmdFbmFibGVkKCgwLCBfZGlzcGxheV91dGlscy5nZXRDdXJyZW50VHJhbnNmb3JtKShmaWxsQ3R4KSwgaW1nLmludGVycG9sYXRlKTtcbiAgICBkcmF3SW1hZ2VBdEludGVnZXJDb29yZHMoZmlsbEN0eCwgc2NhbGVkLCAwLCAwLCBzY2FsZWQud2lkdGgsIHNjYWxlZC5oZWlnaHQsIDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgIGZpbGxDdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gXCJzb3VyY2UtaW5cIjtcbiAgICBjb25zdCBpbnZlcnNlID0gX3V0aWwuVXRpbC50cmFuc2Zvcm0oKDAsIF9kaXNwbGF5X3V0aWxzLmdldEN1cnJlbnRUcmFuc2Zvcm1JbnZlcnNlKShmaWxsQ3R4KSwgWzEsIDAsIDAsIDEsIC1vZmZzZXRYLCAtb2Zmc2V0WV0pO1xuICAgIGZpbGxDdHguZmlsbFN0eWxlID0gaXNQYXR0ZXJuRmlsbCA/IGZpbGxDb2xvci5nZXRQYXR0ZXJuKGN0eCwgdGhpcywgaW52ZXJzZSwgX3BhdHRlcm5faGVscGVyLlBhdGhUeXBlLkZJTEwpIDogZmlsbENvbG9yO1xuICAgIGZpbGxDdHguZmlsbFJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgaWYgKGNhY2hlICYmICFpc1BhdHRlcm5GaWxsKSB7XG4gICAgICB0aGlzLmNhY2hlZENhbnZhc2VzLmRlbGV0ZShcImZpbGxDYW52YXNcIik7XG4gICAgICBjYWNoZS5zZXQoY2FjaGVLZXksIGZpbGxDYW52YXMuY2FudmFzKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGNhbnZhczogZmlsbENhbnZhcy5jYW52YXMsXG4gICAgICBvZmZzZXRYOiBNYXRoLnJvdW5kKG9mZnNldFgpLFxuICAgICAgb2Zmc2V0WTogTWF0aC5yb3VuZChvZmZzZXRZKVxuICAgIH07XG4gIH1cbiAgc2V0TGluZVdpZHRoKHdpZHRoKSB7XG4gICAgaWYgKHdpZHRoICE9PSB0aGlzLmN1cnJlbnQubGluZVdpZHRoKSB7XG4gICAgICB0aGlzLl9jYWNoZWRTY2FsZUZvclN0cm9raW5nWzBdID0gLTE7XG4gICAgfVxuICAgIHRoaXMuY3VycmVudC5saW5lV2lkdGggPSB3aWR0aDtcbiAgICB0aGlzLmN0eC5saW5lV2lkdGggPSB3aWR0aDtcbiAgfVxuICBzZXRMaW5lQ2FwKHN0eWxlKSB7XG4gICAgdGhpcy5jdHgubGluZUNhcCA9IExJTkVfQ0FQX1NUWUxFU1tzdHlsZV07XG4gIH1cbiAgc2V0TGluZUpvaW4oc3R5bGUpIHtcbiAgICB0aGlzLmN0eC5saW5lSm9pbiA9IExJTkVfSk9JTl9TVFlMRVNbc3R5bGVdO1xuICB9XG4gIHNldE1pdGVyTGltaXQobGltaXQpIHtcbiAgICB0aGlzLmN0eC5taXRlckxpbWl0ID0gbGltaXQ7XG4gIH1cbiAgc2V0RGFzaChkYXNoQXJyYXksIGRhc2hQaGFzZSkge1xuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgIGlmIChjdHguc2V0TGluZURhc2ggIT09IHVuZGVmaW5lZCkge1xuICAgICAgY3R4LnNldExpbmVEYXNoKGRhc2hBcnJheSk7XG4gICAgICBjdHgubGluZURhc2hPZmZzZXQgPSBkYXNoUGhhc2U7XG4gICAgfVxuICB9XG4gIHNldFJlbmRlcmluZ0ludGVudChpbnRlbnQpIHt9XG4gIHNldEZsYXRuZXNzKGZsYXRuZXNzKSB7fVxuICBzZXRHU3RhdGUoc3RhdGVzKSB7XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2Ygc3RhdGVzKSB7XG4gICAgICBzd2l0Y2ggKGtleSkge1xuICAgICAgICBjYXNlIFwiTFdcIjpcbiAgICAgICAgICB0aGlzLnNldExpbmVXaWR0aCh2YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJMQ1wiOlxuICAgICAgICAgIHRoaXMuc2V0TGluZUNhcCh2YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJMSlwiOlxuICAgICAgICAgIHRoaXMuc2V0TGluZUpvaW4odmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiTUxcIjpcbiAgICAgICAgICB0aGlzLnNldE1pdGVyTGltaXQodmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiRFwiOlxuICAgICAgICAgIHRoaXMuc2V0RGFzaCh2YWx1ZVswXSwgdmFsdWVbMV0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiUklcIjpcbiAgICAgICAgICB0aGlzLnNldFJlbmRlcmluZ0ludGVudCh2YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJGTFwiOlxuICAgICAgICAgIHRoaXMuc2V0RmxhdG5lc3ModmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiRm9udFwiOlxuICAgICAgICAgIHRoaXMuc2V0Rm9udCh2YWx1ZVswXSwgdmFsdWVbMV0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiQ0FcIjpcbiAgICAgICAgICB0aGlzLmN1cnJlbnQuc3Ryb2tlQWxwaGEgPSB2YWx1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImNhXCI6XG4gICAgICAgICAgdGhpcy5jdXJyZW50LmZpbGxBbHBoYSA9IHZhbHVlO1xuICAgICAgICAgIHRoaXMuY3R4Lmdsb2JhbEFscGhhID0gdmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJCTVwiOlxuICAgICAgICAgIHRoaXMuY3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IHZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiU01hc2tcIjpcbiAgICAgICAgICB0aGlzLmN1cnJlbnQuYWN0aXZlU01hc2sgPSB2YWx1ZSA/IHRoaXMudGVtcFNNYXNrIDogbnVsbDtcbiAgICAgICAgICB0aGlzLnRlbXBTTWFzayA9IG51bGw7XG4gICAgICAgICAgdGhpcy5jaGVja1NNYXNrU3RhdGUoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIlRSXCI6XG4gICAgICAgICAgdGhpcy5jdHguZmlsdGVyID0gdGhpcy5jdXJyZW50LnRyYW5zZmVyTWFwcyA9IHRoaXMuZmlsdGVyRmFjdG9yeS5hZGRGaWx0ZXIodmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBnZXQgaW5TTWFza01vZGUoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5zdXNwZW5kZWRDdHg7XG4gIH1cbiAgY2hlY2tTTWFza1N0YXRlKCkge1xuICAgIGNvbnN0IGluU01hc2tNb2RlID0gdGhpcy5pblNNYXNrTW9kZTtcbiAgICBpZiAodGhpcy5jdXJyZW50LmFjdGl2ZVNNYXNrICYmICFpblNNYXNrTW9kZSkge1xuICAgICAgdGhpcy5iZWdpblNNYXNrTW9kZSgpO1xuICAgIH0gZWxzZSBpZiAoIXRoaXMuY3VycmVudC5hY3RpdmVTTWFzayAmJiBpblNNYXNrTW9kZSkge1xuICAgICAgdGhpcy5lbmRTTWFza01vZGUoKTtcbiAgICB9XG4gIH1cbiAgYmVnaW5TTWFza01vZGUoKSB7XG4gICAgaWYgKHRoaXMuaW5TTWFza01vZGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImJlZ2luU01hc2tNb2RlIGNhbGxlZCB3aGlsZSBhbHJlYWR5IGluIHNtYXNrIG1vZGVcIik7XG4gICAgfVxuICAgIGNvbnN0IGRyYXduV2lkdGggPSB0aGlzLmN0eC5jYW52YXMud2lkdGg7XG4gICAgY29uc3QgZHJhd25IZWlnaHQgPSB0aGlzLmN0eC5jYW52YXMuaGVpZ2h0O1xuICAgIGNvbnN0IGNhY2hlSWQgPSBcInNtYXNrR3JvdXBBdFwiICsgdGhpcy5ncm91cExldmVsO1xuICAgIGNvbnN0IHNjcmF0Y2hDYW52YXMgPSB0aGlzLmNhY2hlZENhbnZhc2VzLmdldENhbnZhcyhjYWNoZUlkLCBkcmF3bldpZHRoLCBkcmF3bkhlaWdodCk7XG4gICAgdGhpcy5zdXNwZW5kZWRDdHggPSB0aGlzLmN0eDtcbiAgICB0aGlzLmN0eCA9IHNjcmF0Y2hDYW52YXMuY29udGV4dDtcbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICBjdHguc2V0VHJhbnNmb3JtKC4uLigwLCBfZGlzcGxheV91dGlscy5nZXRDdXJyZW50VHJhbnNmb3JtKSh0aGlzLnN1c3BlbmRlZEN0eCkpO1xuICAgIGNvcHlDdHhTdGF0ZSh0aGlzLnN1c3BlbmRlZEN0eCwgY3R4KTtcbiAgICBtaXJyb3JDb250ZXh0T3BlcmF0aW9ucyhjdHgsIHRoaXMuc3VzcGVuZGVkQ3R4KTtcbiAgICB0aGlzLnNldEdTdGF0ZShbW1wiQk1cIiwgXCJzb3VyY2Utb3ZlclwiXSwgW1wiY2FcIiwgMV0sIFtcIkNBXCIsIDFdXSk7XG4gIH1cbiAgZW5kU01hc2tNb2RlKCkge1xuICAgIGlmICghdGhpcy5pblNNYXNrTW9kZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZW5kU01hc2tNb2RlIGNhbGxlZCB3aGlsZSBub3QgaW4gc21hc2sgbW9kZVwiKTtcbiAgICB9XG4gICAgdGhpcy5jdHguX3JlbW92ZU1pcnJvcmluZygpO1xuICAgIGNvcHlDdHhTdGF0ZSh0aGlzLmN0eCwgdGhpcy5zdXNwZW5kZWRDdHgpO1xuICAgIHRoaXMuY3R4ID0gdGhpcy5zdXNwZW5kZWRDdHg7XG4gICAgdGhpcy5zdXNwZW5kZWRDdHggPSBudWxsO1xuICB9XG4gIGNvbXBvc2UoZGlydHlCb3gpIHtcbiAgICBpZiAoIXRoaXMuY3VycmVudC5hY3RpdmVTTWFzaykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIWRpcnR5Qm94KSB7XG4gICAgICBkaXJ0eUJveCA9IFswLCAwLCB0aGlzLmN0eC5jYW52YXMud2lkdGgsIHRoaXMuY3R4LmNhbnZhcy5oZWlnaHRdO1xuICAgIH0gZWxzZSB7XG4gICAgICBkaXJ0eUJveFswXSA9IE1hdGguZmxvb3IoZGlydHlCb3hbMF0pO1xuICAgICAgZGlydHlCb3hbMV0gPSBNYXRoLmZsb29yKGRpcnR5Qm94WzFdKTtcbiAgICAgIGRpcnR5Qm94WzJdID0gTWF0aC5jZWlsKGRpcnR5Qm94WzJdKTtcbiAgICAgIGRpcnR5Qm94WzNdID0gTWF0aC5jZWlsKGRpcnR5Qm94WzNdKTtcbiAgICB9XG4gICAgY29uc3Qgc21hc2sgPSB0aGlzLmN1cnJlbnQuYWN0aXZlU01hc2s7XG4gICAgY29uc3Qgc3VzcGVuZGVkQ3R4ID0gdGhpcy5zdXNwZW5kZWRDdHg7XG4gICAgY29tcG9zZVNNYXNrKHN1c3BlbmRlZEN0eCwgc21hc2ssIHRoaXMuY3R4LCBkaXJ0eUJveCk7XG4gICAgdGhpcy5jdHguc2F2ZSgpO1xuICAgIHRoaXMuY3R4LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcbiAgICB0aGlzLmN0eC5jbGVhclJlY3QoMCwgMCwgdGhpcy5jdHguY2FudmFzLndpZHRoLCB0aGlzLmN0eC5jYW52YXMuaGVpZ2h0KTtcbiAgICB0aGlzLmN0eC5yZXN0b3JlKCk7XG4gIH1cbiAgc2F2ZSgpIHtcbiAgICBpZiAodGhpcy5pblNNYXNrTW9kZSkge1xuICAgICAgY29weUN0eFN0YXRlKHRoaXMuY3R4LCB0aGlzLnN1c3BlbmRlZEN0eCk7XG4gICAgICB0aGlzLnN1c3BlbmRlZEN0eC5zYXZlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY3R4LnNhdmUoKTtcbiAgICB9XG4gICAgY29uc3Qgb2xkID0gdGhpcy5jdXJyZW50O1xuICAgIHRoaXMuc3RhdGVTdGFjay5wdXNoKG9sZCk7XG4gICAgdGhpcy5jdXJyZW50ID0gb2xkLmNsb25lKCk7XG4gIH1cbiAgcmVzdG9yZSgpIHtcbiAgICBpZiAodGhpcy5zdGF0ZVN0YWNrLmxlbmd0aCA9PT0gMCAmJiB0aGlzLmluU01hc2tNb2RlKSB7XG4gICAgICB0aGlzLmVuZFNNYXNrTW9kZSgpO1xuICAgIH1cbiAgICBpZiAodGhpcy5zdGF0ZVN0YWNrLmxlbmd0aCAhPT0gMCkge1xuICAgICAgdGhpcy5jdXJyZW50ID0gdGhpcy5zdGF0ZVN0YWNrLnBvcCgpO1xuICAgICAgaWYgKHRoaXMuaW5TTWFza01vZGUpIHtcbiAgICAgICAgdGhpcy5zdXNwZW5kZWRDdHgucmVzdG9yZSgpO1xuICAgICAgICBjb3B5Q3R4U3RhdGUodGhpcy5zdXNwZW5kZWRDdHgsIHRoaXMuY3R4KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY3R4LnJlc3RvcmUoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuY2hlY2tTTWFza1N0YXRlKCk7XG4gICAgICB0aGlzLnBlbmRpbmdDbGlwID0gbnVsbDtcbiAgICAgIHRoaXMuX2NhY2hlZFNjYWxlRm9yU3Ryb2tpbmdbMF0gPSAtMTtcbiAgICAgIHRoaXMuX2NhY2hlZEdldFNpbmdsZVBpeGVsV2lkdGggPSBudWxsO1xuICAgIH1cbiAgfVxuICB0cmFuc2Zvcm0oYSwgYiwgYywgZCwgZSwgZikge1xuICAgIHRoaXMuY3R4LnRyYW5zZm9ybShhLCBiLCBjLCBkLCBlLCBmKTtcbiAgICB0aGlzLl9jYWNoZWRTY2FsZUZvclN0cm9raW5nWzBdID0gLTE7XG4gICAgdGhpcy5fY2FjaGVkR2V0U2luZ2xlUGl4ZWxXaWR0aCA9IG51bGw7XG4gIH1cbiAgY29uc3RydWN0UGF0aChvcHMsIGFyZ3MsIG1pbk1heCkge1xuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgIGNvbnN0IGN1cnJlbnQgPSB0aGlzLmN1cnJlbnQ7XG4gICAgbGV0IHggPSBjdXJyZW50LngsXG4gICAgICB5ID0gY3VycmVudC55O1xuICAgIGxldCBzdGFydFgsIHN0YXJ0WTtcbiAgICBjb25zdCBjdXJyZW50VHJhbnNmb3JtID0gKDAsIF9kaXNwbGF5X3V0aWxzLmdldEN1cnJlbnRUcmFuc2Zvcm0pKGN0eCk7XG4gICAgY29uc3QgaXNTY2FsaW5nTWF0cml4ID0gY3VycmVudFRyYW5zZm9ybVswXSA9PT0gMCAmJiBjdXJyZW50VHJhbnNmb3JtWzNdID09PSAwIHx8IGN1cnJlbnRUcmFuc2Zvcm1bMV0gPT09IDAgJiYgY3VycmVudFRyYW5zZm9ybVsyXSA9PT0gMDtcbiAgICBjb25zdCBtaW5NYXhGb3JCZXppZXIgPSBpc1NjYWxpbmdNYXRyaXggPyBtaW5NYXguc2xpY2UoMCkgOiBudWxsO1xuICAgIGZvciAobGV0IGkgPSAwLCBqID0gMCwgaWkgPSBvcHMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgc3dpdGNoIChvcHNbaV0gfCAwKSB7XG4gICAgICAgIGNhc2UgX3V0aWwuT1BTLnJlY3RhbmdsZTpcbiAgICAgICAgICB4ID0gYXJnc1tqKytdO1xuICAgICAgICAgIHkgPSBhcmdzW2orK107XG4gICAgICAgICAgY29uc3Qgd2lkdGggPSBhcmdzW2orK107XG4gICAgICAgICAgY29uc3QgaGVpZ2h0ID0gYXJnc1tqKytdO1xuICAgICAgICAgIGNvbnN0IHh3ID0geCArIHdpZHRoO1xuICAgICAgICAgIGNvbnN0IHloID0geSArIGhlaWdodDtcbiAgICAgICAgICBjdHgubW92ZVRvKHgsIHkpO1xuICAgICAgICAgIGlmICh3aWR0aCA9PT0gMCB8fCBoZWlnaHQgPT09IDApIHtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oeHcsIHloKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY3R4LmxpbmVUbyh4dywgeSk7XG4gICAgICAgICAgICBjdHgubGluZVRvKHh3LCB5aCk7XG4gICAgICAgICAgICBjdHgubGluZVRvKHgsIHloKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFpc1NjYWxpbmdNYXRyaXgpIHtcbiAgICAgICAgICAgIGN1cnJlbnQudXBkYXRlUmVjdE1pbk1heChjdXJyZW50VHJhbnNmb3JtLCBbeCwgeSwgeHcsIHloXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBfdXRpbC5PUFMubW92ZVRvOlxuICAgICAgICAgIHggPSBhcmdzW2orK107XG4gICAgICAgICAgeSA9IGFyZ3NbaisrXTtcbiAgICAgICAgICBjdHgubW92ZVRvKHgsIHkpO1xuICAgICAgICAgIGlmICghaXNTY2FsaW5nTWF0cml4KSB7XG4gICAgICAgICAgICBjdXJyZW50LnVwZGF0ZVBhdGhNaW5NYXgoY3VycmVudFRyYW5zZm9ybSwgeCwgeSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIF91dGlsLk9QUy5saW5lVG86XG4gICAgICAgICAgeCA9IGFyZ3NbaisrXTtcbiAgICAgICAgICB5ID0gYXJnc1tqKytdO1xuICAgICAgICAgIGN0eC5saW5lVG8oeCwgeSk7XG4gICAgICAgICAgaWYgKCFpc1NjYWxpbmdNYXRyaXgpIHtcbiAgICAgICAgICAgIGN1cnJlbnQudXBkYXRlUGF0aE1pbk1heChjdXJyZW50VHJhbnNmb3JtLCB4LCB5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgX3V0aWwuT1BTLmN1cnZlVG86XG4gICAgICAgICAgc3RhcnRYID0geDtcbiAgICAgICAgICBzdGFydFkgPSB5O1xuICAgICAgICAgIHggPSBhcmdzW2ogKyA0XTtcbiAgICAgICAgICB5ID0gYXJnc1tqICsgNV07XG4gICAgICAgICAgY3R4LmJlemllckN1cnZlVG8oYXJnc1tqXSwgYXJnc1tqICsgMV0sIGFyZ3NbaiArIDJdLCBhcmdzW2ogKyAzXSwgeCwgeSk7XG4gICAgICAgICAgY3VycmVudC51cGRhdGVDdXJ2ZVBhdGhNaW5NYXgoY3VycmVudFRyYW5zZm9ybSwgc3RhcnRYLCBzdGFydFksIGFyZ3Nbal0sIGFyZ3NbaiArIDFdLCBhcmdzW2ogKyAyXSwgYXJnc1tqICsgM10sIHgsIHksIG1pbk1heEZvckJlemllcik7XG4gICAgICAgICAgaiArPSA2O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIF91dGlsLk9QUy5jdXJ2ZVRvMjpcbiAgICAgICAgICBzdGFydFggPSB4O1xuICAgICAgICAgIHN0YXJ0WSA9IHk7XG4gICAgICAgICAgY3R4LmJlemllckN1cnZlVG8oeCwgeSwgYXJnc1tqXSwgYXJnc1tqICsgMV0sIGFyZ3NbaiArIDJdLCBhcmdzW2ogKyAzXSk7XG4gICAgICAgICAgY3VycmVudC51cGRhdGVDdXJ2ZVBhdGhNaW5NYXgoY3VycmVudFRyYW5zZm9ybSwgc3RhcnRYLCBzdGFydFksIHgsIHksIGFyZ3Nbal0sIGFyZ3NbaiArIDFdLCBhcmdzW2ogKyAyXSwgYXJnc1tqICsgM10sIG1pbk1heEZvckJlemllcik7XG4gICAgICAgICAgeCA9IGFyZ3NbaiArIDJdO1xuICAgICAgICAgIHkgPSBhcmdzW2ogKyAzXTtcbiAgICAgICAgICBqICs9IDQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgX3V0aWwuT1BTLmN1cnZlVG8zOlxuICAgICAgICAgIHN0YXJ0WCA9IHg7XG4gICAgICAgICAgc3RhcnRZID0geTtcbiAgICAgICAgICB4ID0gYXJnc1tqICsgMl07XG4gICAgICAgICAgeSA9IGFyZ3NbaiArIDNdO1xuICAgICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKGFyZ3Nbal0sIGFyZ3NbaiArIDFdLCB4LCB5LCB4LCB5KTtcbiAgICAgICAgICBjdXJyZW50LnVwZGF0ZUN1cnZlUGF0aE1pbk1heChjdXJyZW50VHJhbnNmb3JtLCBzdGFydFgsIHN0YXJ0WSwgYXJnc1tqXSwgYXJnc1tqICsgMV0sIHgsIHksIHgsIHksIG1pbk1heEZvckJlemllcik7XG4gICAgICAgICAgaiArPSA0O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIF91dGlsLk9QUy5jbG9zZVBhdGg6XG4gICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNTY2FsaW5nTWF0cml4KSB7XG4gICAgICBjdXJyZW50LnVwZGF0ZVNjYWxpbmdQYXRoTWluTWF4KGN1cnJlbnRUcmFuc2Zvcm0sIG1pbk1heEZvckJlemllcik7XG4gICAgfVxuICAgIGN1cnJlbnQuc2V0Q3VycmVudFBvaW50KHgsIHkpO1xuICB9XG4gIGNsb3NlUGF0aCgpIHtcbiAgICB0aGlzLmN0eC5jbG9zZVBhdGgoKTtcbiAgfVxuICBzdHJva2UoY29uc3VtZVBhdGggPSB0cnVlKSB7XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgY29uc3Qgc3Ryb2tlQ29sb3IgPSB0aGlzLmN1cnJlbnQuc3Ryb2tlQ29sb3I7XG4gICAgY3R4Lmdsb2JhbEFscGhhID0gdGhpcy5jdXJyZW50LnN0cm9rZUFscGhhO1xuICAgIGlmICh0aGlzLmNvbnRlbnRWaXNpYmxlKSB7XG4gICAgICBpZiAodHlwZW9mIHN0cm9rZUNvbG9yID09PSBcIm9iamVjdFwiICYmIHN0cm9rZUNvbG9yPy5nZXRQYXR0ZXJuKSB7XG4gICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHN0cm9rZUNvbG9yLmdldFBhdHRlcm4oY3R4LCB0aGlzLCAoMCwgX2Rpc3BsYXlfdXRpbHMuZ2V0Q3VycmVudFRyYW5zZm9ybUludmVyc2UpKGN0eCksIF9wYXR0ZXJuX2hlbHBlci5QYXRoVHlwZS5TVFJPS0UpO1xuICAgICAgICB0aGlzLnJlc2NhbGVBbmRTdHJva2UoZmFsc2UpO1xuICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5yZXNjYWxlQW5kU3Ryb2tlKHRydWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoY29uc3VtZVBhdGgpIHtcbiAgICAgIHRoaXMuY29uc3VtZVBhdGgodGhpcy5jdXJyZW50LmdldENsaXBwZWRQYXRoQm91bmRpbmdCb3goKSk7XG4gICAgfVxuICAgIGN0eC5nbG9iYWxBbHBoYSA9IHRoaXMuY3VycmVudC5maWxsQWxwaGE7XG4gIH1cbiAgY2xvc2VTdHJva2UoKSB7XG4gICAgdGhpcy5jbG9zZVBhdGgoKTtcbiAgICB0aGlzLnN0cm9rZSgpO1xuICB9XG4gIGZpbGwoY29uc3VtZVBhdGggPSB0cnVlKSB7XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgY29uc3QgZmlsbENvbG9yID0gdGhpcy5jdXJyZW50LmZpbGxDb2xvcjtcbiAgICBjb25zdCBpc1BhdHRlcm5GaWxsID0gdGhpcy5jdXJyZW50LnBhdHRlcm5GaWxsO1xuICAgIGxldCBuZWVkUmVzdG9yZSA9IGZhbHNlO1xuICAgIGlmIChpc1BhdHRlcm5GaWxsKSB7XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IGZpbGxDb2xvci5nZXRQYXR0ZXJuKGN0eCwgdGhpcywgKDAsIF9kaXNwbGF5X3V0aWxzLmdldEN1cnJlbnRUcmFuc2Zvcm1JbnZlcnNlKShjdHgpLCBfcGF0dGVybl9oZWxwZXIuUGF0aFR5cGUuRklMTCk7XG4gICAgICBuZWVkUmVzdG9yZSA9IHRydWU7XG4gICAgfVxuICAgIGNvbnN0IGludGVyc2VjdCA9IHRoaXMuY3VycmVudC5nZXRDbGlwcGVkUGF0aEJvdW5kaW5nQm94KCk7XG4gICAgaWYgKHRoaXMuY29udGVudFZpc2libGUgJiYgaW50ZXJzZWN0ICE9PSBudWxsKSB7XG4gICAgICBpZiAodGhpcy5wZW5kaW5nRU9GaWxsKSB7XG4gICAgICAgIGN0eC5maWxsKFwiZXZlbm9kZFwiKTtcbiAgICAgICAgdGhpcy5wZW5kaW5nRU9GaWxsID0gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobmVlZFJlc3RvcmUpIHtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfVxuICAgIGlmIChjb25zdW1lUGF0aCkge1xuICAgICAgdGhpcy5jb25zdW1lUGF0aChpbnRlcnNlY3QpO1xuICAgIH1cbiAgfVxuICBlb0ZpbGwoKSB7XG4gICAgdGhpcy5wZW5kaW5nRU9GaWxsID0gdHJ1ZTtcbiAgICB0aGlzLmZpbGwoKTtcbiAgfVxuICBmaWxsU3Ryb2tlKCkge1xuICAgIHRoaXMuZmlsbChmYWxzZSk7XG4gICAgdGhpcy5zdHJva2UoZmFsc2UpO1xuICAgIHRoaXMuY29uc3VtZVBhdGgoKTtcbiAgfVxuICBlb0ZpbGxTdHJva2UoKSB7XG4gICAgdGhpcy5wZW5kaW5nRU9GaWxsID0gdHJ1ZTtcbiAgICB0aGlzLmZpbGxTdHJva2UoKTtcbiAgfVxuICBjbG9zZUZpbGxTdHJva2UoKSB7XG4gICAgdGhpcy5jbG9zZVBhdGgoKTtcbiAgICB0aGlzLmZpbGxTdHJva2UoKTtcbiAgfVxuICBjbG9zZUVPRmlsbFN0cm9rZSgpIHtcbiAgICB0aGlzLnBlbmRpbmdFT0ZpbGwgPSB0cnVlO1xuICAgIHRoaXMuY2xvc2VQYXRoKCk7XG4gICAgdGhpcy5maWxsU3Ryb2tlKCk7XG4gIH1cbiAgZW5kUGF0aCgpIHtcbiAgICB0aGlzLmNvbnN1bWVQYXRoKCk7XG4gIH1cbiAgY2xpcCgpIHtcbiAgICB0aGlzLnBlbmRpbmdDbGlwID0gTk9STUFMX0NMSVA7XG4gIH1cbiAgZW9DbGlwKCkge1xuICAgIHRoaXMucGVuZGluZ0NsaXAgPSBFT19DTElQO1xuICB9XG4gIGJlZ2luVGV4dCgpIHtcbiAgICB0aGlzLmN1cnJlbnQudGV4dE1hdHJpeCA9IF91dGlsLklERU5USVRZX01BVFJJWDtcbiAgICB0aGlzLmN1cnJlbnQudGV4dE1hdHJpeFNjYWxlID0gMTtcbiAgICB0aGlzLmN1cnJlbnQueCA9IHRoaXMuY3VycmVudC5saW5lWCA9IDA7XG4gICAgdGhpcy5jdXJyZW50LnkgPSB0aGlzLmN1cnJlbnQubGluZVkgPSAwO1xuICB9XG4gIGVuZFRleHQoKSB7XG4gICAgY29uc3QgcGF0aHMgPSB0aGlzLnBlbmRpbmdUZXh0UGF0aHM7XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgaWYgKHBhdGhzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY3R4LnNhdmUoKTtcbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgZm9yIChjb25zdCBwYXRoIG9mIHBhdGhzKSB7XG4gICAgICBjdHguc2V0VHJhbnNmb3JtKC4uLnBhdGgudHJhbnNmb3JtKTtcbiAgICAgIGN0eC50cmFuc2xhdGUocGF0aC54LCBwYXRoLnkpO1xuICAgICAgcGF0aC5hZGRUb1BhdGgoY3R4LCBwYXRoLmZvbnRTaXplKTtcbiAgICB9XG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgICBjdHguY2xpcCgpO1xuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICBkZWxldGUgdGhpcy5wZW5kaW5nVGV4dFBhdGhzO1xuICB9XG4gIHNldENoYXJTcGFjaW5nKHNwYWNpbmcpIHtcbiAgICB0aGlzLmN1cnJlbnQuY2hhclNwYWNpbmcgPSBzcGFjaW5nO1xuICB9XG4gIHNldFdvcmRTcGFjaW5nKHNwYWNpbmcpIHtcbiAgICB0aGlzLmN1cnJlbnQud29yZFNwYWNpbmcgPSBzcGFjaW5nO1xuICB9XG4gIHNldEhTY2FsZShzY2FsZSkge1xuICAgIHRoaXMuY3VycmVudC50ZXh0SFNjYWxlID0gc2NhbGUgLyAxMDA7XG4gIH1cbiAgc2V0TGVhZGluZyhsZWFkaW5nKSB7XG4gICAgdGhpcy5jdXJyZW50LmxlYWRpbmcgPSAtbGVhZGluZztcbiAgfVxuICBzZXRGb250KGZvbnRSZWZOYW1lLCBzaXplKSB7XG4gICAgY29uc3QgZm9udE9iaiA9IHRoaXMuY29tbW9uT2Jqcy5nZXQoZm9udFJlZk5hbWUpO1xuICAgIGNvbnN0IGN1cnJlbnQgPSB0aGlzLmN1cnJlbnQ7XG4gICAgaWYgKCFmb250T2JqKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbid0IGZpbmQgZm9udCBmb3IgJHtmb250UmVmTmFtZX1gKTtcbiAgICB9XG4gICAgY3VycmVudC5mb250TWF0cml4ID0gZm9udE9iai5mb250TWF0cml4IHx8IF91dGlsLkZPTlRfSURFTlRJVFlfTUFUUklYO1xuICAgIGlmIChjdXJyZW50LmZvbnRNYXRyaXhbMF0gPT09IDAgfHwgY3VycmVudC5mb250TWF0cml4WzNdID09PSAwKSB7XG4gICAgICAoMCwgX3V0aWwud2FybikoXCJJbnZhbGlkIGZvbnQgbWF0cml4IGZvciBmb250IFwiICsgZm9udFJlZk5hbWUpO1xuICAgIH1cbiAgICBpZiAoc2l6ZSA8IDApIHtcbiAgICAgIHNpemUgPSAtc2l6ZTtcbiAgICAgIGN1cnJlbnQuZm9udERpcmVjdGlvbiA9IC0xO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdXJyZW50LmZvbnREaXJlY3Rpb24gPSAxO1xuICAgIH1cbiAgICB0aGlzLmN1cnJlbnQuZm9udCA9IGZvbnRPYmo7XG4gICAgdGhpcy5jdXJyZW50LmZvbnRTaXplID0gc2l6ZTtcbiAgICBpZiAoZm9udE9iai5pc1R5cGUzRm9udCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBuYW1lID0gZm9udE9iai5sb2FkZWROYW1lIHx8IFwic2Fucy1zZXJpZlwiO1xuICAgIGNvbnN0IHR5cGVmYWNlID0gZm9udE9iai5zeXN0ZW1Gb250SW5mbz8uY3NzIHx8IGBcIiR7bmFtZX1cIiwgJHtmb250T2JqLmZhbGxiYWNrTmFtZX1gO1xuICAgIGxldCBib2xkID0gXCJub3JtYWxcIjtcbiAgICBpZiAoZm9udE9iai5ibGFjaykge1xuICAgICAgYm9sZCA9IFwiOTAwXCI7XG4gICAgfSBlbHNlIGlmIChmb250T2JqLmJvbGQpIHtcbiAgICAgIGJvbGQgPSBcImJvbGRcIjtcbiAgICB9XG4gICAgY29uc3QgaXRhbGljID0gZm9udE9iai5pdGFsaWMgPyBcIml0YWxpY1wiIDogXCJub3JtYWxcIjtcbiAgICBsZXQgYnJvd3NlckZvbnRTaXplID0gc2l6ZTtcbiAgICBpZiAoc2l6ZSA8IE1JTl9GT05UX1NJWkUpIHtcbiAgICAgIGJyb3dzZXJGb250U2l6ZSA9IE1JTl9GT05UX1NJWkU7XG4gICAgfSBlbHNlIGlmIChzaXplID4gTUFYX0ZPTlRfU0laRSkge1xuICAgICAgYnJvd3NlckZvbnRTaXplID0gTUFYX0ZPTlRfU0laRTtcbiAgICB9XG4gICAgdGhpcy5jdXJyZW50LmZvbnRTaXplU2NhbGUgPSBzaXplIC8gYnJvd3NlckZvbnRTaXplO1xuICAgIHRoaXMuY3R4LmZvbnQgPSBgJHtpdGFsaWN9ICR7Ym9sZH0gJHticm93c2VyRm9udFNpemV9cHggJHt0eXBlZmFjZX1gO1xuICB9XG4gIHNldFRleHRSZW5kZXJpbmdNb2RlKG1vZGUpIHtcbiAgICB0aGlzLmN1cnJlbnQudGV4dFJlbmRlcmluZ01vZGUgPSBtb2RlO1xuICB9XG4gIHNldFRleHRSaXNlKHJpc2UpIHtcbiAgICB0aGlzLmN1cnJlbnQudGV4dFJpc2UgPSByaXNlO1xuICB9XG4gIG1vdmVUZXh0KHgsIHkpIHtcbiAgICB0aGlzLmN1cnJlbnQueCA9IHRoaXMuY3VycmVudC5saW5lWCArPSB4O1xuICAgIHRoaXMuY3VycmVudC55ID0gdGhpcy5jdXJyZW50LmxpbmVZICs9IHk7XG4gIH1cbiAgc2V0TGVhZGluZ01vdmVUZXh0KHgsIHkpIHtcbiAgICB0aGlzLnNldExlYWRpbmcoLXkpO1xuICAgIHRoaXMubW92ZVRleHQoeCwgeSk7XG4gIH1cbiAgc2V0VGV4dE1hdHJpeChhLCBiLCBjLCBkLCBlLCBmKSB7XG4gICAgdGhpcy5jdXJyZW50LnRleHRNYXRyaXggPSBbYSwgYiwgYywgZCwgZSwgZl07XG4gICAgdGhpcy5jdXJyZW50LnRleHRNYXRyaXhTY2FsZSA9IE1hdGguaHlwb3QoYSwgYik7XG4gICAgdGhpcy5jdXJyZW50LnggPSB0aGlzLmN1cnJlbnQubGluZVggPSAwO1xuICAgIHRoaXMuY3VycmVudC55ID0gdGhpcy5jdXJyZW50LmxpbmVZID0gMDtcbiAgfVxuICBuZXh0TGluZSgpIHtcbiAgICB0aGlzLm1vdmVUZXh0KDAsIHRoaXMuY3VycmVudC5sZWFkaW5nKTtcbiAgfVxuICBwYWludENoYXIoY2hhcmFjdGVyLCB4LCB5LCBwYXR0ZXJuVHJhbnNmb3JtKSB7XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgY29uc3QgY3VycmVudCA9IHRoaXMuY3VycmVudDtcbiAgICBjb25zdCBmb250ID0gY3VycmVudC5mb250O1xuICAgIGNvbnN0IHRleHRSZW5kZXJpbmdNb2RlID0gY3VycmVudC50ZXh0UmVuZGVyaW5nTW9kZTtcbiAgICBjb25zdCBmb250U2l6ZSA9IGN1cnJlbnQuZm9udFNpemUgLyBjdXJyZW50LmZvbnRTaXplU2NhbGU7XG4gICAgY29uc3QgZmlsbFN0cm9rZU1vZGUgPSB0ZXh0UmVuZGVyaW5nTW9kZSAmIF91dGlsLlRleHRSZW5kZXJpbmdNb2RlLkZJTExfU1RST0tFX01BU0s7XG4gICAgY29uc3QgaXNBZGRUb1BhdGhTZXQgPSAhISh0ZXh0UmVuZGVyaW5nTW9kZSAmIF91dGlsLlRleHRSZW5kZXJpbmdNb2RlLkFERF9UT19QQVRIX0ZMQUcpO1xuICAgIGNvbnN0IHBhdHRlcm5GaWxsID0gY3VycmVudC5wYXR0ZXJuRmlsbCAmJiAhZm9udC5taXNzaW5nRmlsZTtcbiAgICBsZXQgYWRkVG9QYXRoO1xuICAgIGlmIChmb250LmRpc2FibGVGb250RmFjZSB8fCBpc0FkZFRvUGF0aFNldCB8fCBwYXR0ZXJuRmlsbCkge1xuICAgICAgYWRkVG9QYXRoID0gZm9udC5nZXRQYXRoR2VuZXJhdG9yKHRoaXMuY29tbW9uT2JqcywgY2hhcmFjdGVyKTtcbiAgICB9XG4gICAgaWYgKGZvbnQuZGlzYWJsZUZvbnRGYWNlIHx8IHBhdHRlcm5GaWxsKSB7XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY3R4LnRyYW5zbGF0ZSh4LCB5KTtcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIGFkZFRvUGF0aChjdHgsIGZvbnRTaXplKTtcbiAgICAgIGlmIChwYXR0ZXJuVHJhbnNmb3JtKSB7XG4gICAgICAgIGN0eC5zZXRUcmFuc2Zvcm0oLi4ucGF0dGVyblRyYW5zZm9ybSk7XG4gICAgICB9XG4gICAgICBpZiAoZmlsbFN0cm9rZU1vZGUgPT09IF91dGlsLlRleHRSZW5kZXJpbmdNb2RlLkZJTEwgfHwgZmlsbFN0cm9rZU1vZGUgPT09IF91dGlsLlRleHRSZW5kZXJpbmdNb2RlLkZJTExfU1RST0tFKSB7XG4gICAgICAgIGN0eC5maWxsKCk7XG4gICAgICB9XG4gICAgICBpZiAoZmlsbFN0cm9rZU1vZGUgPT09IF91dGlsLlRleHRSZW5kZXJpbmdNb2RlLlNUUk9LRSB8fCBmaWxsU3Ryb2tlTW9kZSA9PT0gX3V0aWwuVGV4dFJlbmRlcmluZ01vZGUuRklMTF9TVFJPS0UpIHtcbiAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgfVxuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGZpbGxTdHJva2VNb2RlID09PSBfdXRpbC5UZXh0UmVuZGVyaW5nTW9kZS5GSUxMIHx8IGZpbGxTdHJva2VNb2RlID09PSBfdXRpbC5UZXh0UmVuZGVyaW5nTW9kZS5GSUxMX1NUUk9LRSkge1xuICAgICAgICBjdHguZmlsbFRleHQoY2hhcmFjdGVyLCB4LCB5KTtcbiAgICAgIH1cbiAgICAgIGlmIChmaWxsU3Ryb2tlTW9kZSA9PT0gX3V0aWwuVGV4dFJlbmRlcmluZ01vZGUuU1RST0tFIHx8IGZpbGxTdHJva2VNb2RlID09PSBfdXRpbC5UZXh0UmVuZGVyaW5nTW9kZS5GSUxMX1NUUk9LRSkge1xuICAgICAgICBjdHguc3Ryb2tlVGV4dChjaGFyYWN0ZXIsIHgsIHkpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNBZGRUb1BhdGhTZXQpIHtcbiAgICAgIGNvbnN0IHBhdGhzID0gdGhpcy5wZW5kaW5nVGV4dFBhdGhzIHx8PSBbXTtcbiAgICAgIHBhdGhzLnB1c2goe1xuICAgICAgICB0cmFuc2Zvcm06ICgwLCBfZGlzcGxheV91dGlscy5nZXRDdXJyZW50VHJhbnNmb3JtKShjdHgpLFxuICAgICAgICB4LFxuICAgICAgICB5LFxuICAgICAgICBmb250U2l6ZSxcbiAgICAgICAgYWRkVG9QYXRoXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgZ2V0IGlzRm9udFN1YnBpeGVsQUFFbmFibGVkKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbnRleHQ6IGN0eFxuICAgIH0gPSB0aGlzLmNhY2hlZENhbnZhc2VzLmdldENhbnZhcyhcImlzRm9udFN1YnBpeGVsQUFFbmFibGVkXCIsIDEwLCAxMCk7XG4gICAgY3R4LnNjYWxlKDEuNSwgMSk7XG4gICAgY3R4LmZpbGxUZXh0KFwiSVwiLCAwLCAxMCk7XG4gICAgY29uc3QgZGF0YSA9IGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgMTAsIDEwKS5kYXRhO1xuICAgIGxldCBlbmFibGVkID0gZmFsc2U7XG4gICAgZm9yIChsZXQgaSA9IDM7IGkgPCBkYXRhLmxlbmd0aDsgaSArPSA0KSB7XG4gICAgICBpZiAoZGF0YVtpXSA+IDAgJiYgZGF0YVtpXSA8IDI1NSkge1xuICAgICAgICBlbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAoMCwgX3V0aWwuc2hhZG93KSh0aGlzLCBcImlzRm9udFN1YnBpeGVsQUFFbmFibGVkXCIsIGVuYWJsZWQpO1xuICB9XG4gIHNob3dUZXh0KGdseXBocykge1xuICAgIGNvbnN0IGN1cnJlbnQgPSB0aGlzLmN1cnJlbnQ7XG4gICAgY29uc3QgZm9udCA9IGN1cnJlbnQuZm9udDtcbiAgICBpZiAoZm9udC5pc1R5cGUzRm9udCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2hvd1R5cGUzVGV4dChnbHlwaHMpO1xuICAgIH1cbiAgICBjb25zdCBmb250U2l6ZSA9IGN1cnJlbnQuZm9udFNpemU7XG4gICAgaWYgKGZvbnRTaXplID09PSAwKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICBjb25zdCBmb250U2l6ZVNjYWxlID0gY3VycmVudC5mb250U2l6ZVNjYWxlO1xuICAgIGNvbnN0IGNoYXJTcGFjaW5nID0gY3VycmVudC5jaGFyU3BhY2luZztcbiAgICBjb25zdCB3b3JkU3BhY2luZyA9IGN1cnJlbnQud29yZFNwYWNpbmc7XG4gICAgY29uc3QgZm9udERpcmVjdGlvbiA9IGN1cnJlbnQuZm9udERpcmVjdGlvbjtcbiAgICBjb25zdCB0ZXh0SFNjYWxlID0gY3VycmVudC50ZXh0SFNjYWxlICogZm9udERpcmVjdGlvbjtcbiAgICBjb25zdCBnbHlwaHNMZW5ndGggPSBnbHlwaHMubGVuZ3RoO1xuICAgIGNvbnN0IHZlcnRpY2FsID0gZm9udC52ZXJ0aWNhbDtcbiAgICBjb25zdCBzcGFjaW5nRGlyID0gdmVydGljYWwgPyAxIDogLTE7XG4gICAgY29uc3QgZGVmYXVsdFZNZXRyaWNzID0gZm9udC5kZWZhdWx0Vk1ldHJpY3M7XG4gICAgY29uc3Qgd2lkdGhBZHZhbmNlU2NhbGUgPSBmb250U2l6ZSAqIGN1cnJlbnQuZm9udE1hdHJpeFswXTtcbiAgICBjb25zdCBzaW1wbGVGaWxsVGV4dCA9IGN1cnJlbnQudGV4dFJlbmRlcmluZ01vZGUgPT09IF91dGlsLlRleHRSZW5kZXJpbmdNb2RlLkZJTEwgJiYgIWZvbnQuZGlzYWJsZUZvbnRGYWNlICYmICFjdXJyZW50LnBhdHRlcm5GaWxsO1xuICAgIGN0eC5zYXZlKCk7XG4gICAgY3R4LnRyYW5zZm9ybSguLi5jdXJyZW50LnRleHRNYXRyaXgpO1xuICAgIGN0eC50cmFuc2xhdGUoY3VycmVudC54LCBjdXJyZW50LnkgKyBjdXJyZW50LnRleHRSaXNlKTtcbiAgICBpZiAoZm9udERpcmVjdGlvbiA+IDApIHtcbiAgICAgIGN0eC5zY2FsZSh0ZXh0SFNjYWxlLCAtMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN0eC5zY2FsZSh0ZXh0SFNjYWxlLCAxKTtcbiAgICB9XG4gICAgbGV0IHBhdHRlcm5UcmFuc2Zvcm07XG4gICAgaWYgKGN1cnJlbnQucGF0dGVybkZpbGwpIHtcbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjb25zdCBwYXR0ZXJuID0gY3VycmVudC5maWxsQ29sb3IuZ2V0UGF0dGVybihjdHgsIHRoaXMsICgwLCBfZGlzcGxheV91dGlscy5nZXRDdXJyZW50VHJhbnNmb3JtSW52ZXJzZSkoY3R4KSwgX3BhdHRlcm5faGVscGVyLlBhdGhUeXBlLkZJTEwpO1xuICAgICAgcGF0dGVyblRyYW5zZm9ybSA9ICgwLCBfZGlzcGxheV91dGlscy5nZXRDdXJyZW50VHJhbnNmb3JtKShjdHgpO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBwYXR0ZXJuO1xuICAgIH1cbiAgICBsZXQgbGluZVdpZHRoID0gY3VycmVudC5saW5lV2lkdGg7XG4gICAgY29uc3Qgc2NhbGUgPSBjdXJyZW50LnRleHRNYXRyaXhTY2FsZTtcbiAgICBpZiAoc2NhbGUgPT09IDAgfHwgbGluZVdpZHRoID09PSAwKSB7XG4gICAgICBjb25zdCBmaWxsU3Ryb2tlTW9kZSA9IGN1cnJlbnQudGV4dFJlbmRlcmluZ01vZGUgJiBfdXRpbC5UZXh0UmVuZGVyaW5nTW9kZS5GSUxMX1NUUk9LRV9NQVNLO1xuICAgICAgaWYgKGZpbGxTdHJva2VNb2RlID09PSBfdXRpbC5UZXh0UmVuZGVyaW5nTW9kZS5TVFJPS0UgfHwgZmlsbFN0cm9rZU1vZGUgPT09IF91dGlsLlRleHRSZW5kZXJpbmdNb2RlLkZJTExfU1RST0tFKSB7XG4gICAgICAgIGxpbmVXaWR0aCA9IHRoaXMuZ2V0U2luZ2xlUGl4ZWxXaWR0aCgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsaW5lV2lkdGggLz0gc2NhbGU7XG4gICAgfVxuICAgIGlmIChmb250U2l6ZVNjYWxlICE9PSAxLjApIHtcbiAgICAgIGN0eC5zY2FsZShmb250U2l6ZVNjYWxlLCBmb250U2l6ZVNjYWxlKTtcbiAgICAgIGxpbmVXaWR0aCAvPSBmb250U2l6ZVNjYWxlO1xuICAgIH1cbiAgICBjdHgubGluZVdpZHRoID0gbGluZVdpZHRoO1xuICAgIGlmIChmb250LmlzSW52YWxpZFBERmpzRm9udCkge1xuICAgICAgY29uc3QgY2hhcnMgPSBbXTtcbiAgICAgIGxldCB3aWR0aCA9IDA7XG4gICAgICBmb3IgKGNvbnN0IGdseXBoIG9mIGdseXBocykge1xuICAgICAgICBjaGFycy5wdXNoKGdseXBoLnVuaWNvZGUpO1xuICAgICAgICB3aWR0aCArPSBnbHlwaC53aWR0aDtcbiAgICAgIH1cbiAgICAgIGN0eC5maWxsVGV4dChjaGFycy5qb2luKFwiXCIpLCAwLCAwKTtcbiAgICAgIGN1cnJlbnQueCArPSB3aWR0aCAqIHdpZHRoQWR2YW5jZVNjYWxlICogdGV4dEhTY2FsZTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICB0aGlzLmNvbXBvc2UoKTtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGxldCB4ID0gMCxcbiAgICAgIGk7XG4gICAgZm9yIChpID0gMDsgaSA8IGdseXBoc0xlbmd0aDsgKytpKSB7XG4gICAgICBjb25zdCBnbHlwaCA9IGdseXBoc1tpXTtcbiAgICAgIGlmICh0eXBlb2YgZ2x5cGggPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgeCArPSBzcGFjaW5nRGlyICogZ2x5cGggKiBmb250U2l6ZSAvIDEwMDA7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgbGV0IHJlc3RvcmVOZWVkZWQgPSBmYWxzZTtcbiAgICAgIGNvbnN0IHNwYWNpbmcgPSAoZ2x5cGguaXNTcGFjZSA/IHdvcmRTcGFjaW5nIDogMCkgKyBjaGFyU3BhY2luZztcbiAgICAgIGNvbnN0IGNoYXJhY3RlciA9IGdseXBoLmZvbnRDaGFyO1xuICAgICAgY29uc3QgYWNjZW50ID0gZ2x5cGguYWNjZW50O1xuICAgICAgbGV0IHNjYWxlZFgsIHNjYWxlZFk7XG4gICAgICBsZXQgd2lkdGggPSBnbHlwaC53aWR0aDtcbiAgICAgIGlmICh2ZXJ0aWNhbCkge1xuICAgICAgICBjb25zdCB2bWV0cmljID0gZ2x5cGgudm1ldHJpYyB8fCBkZWZhdWx0Vk1ldHJpY3M7XG4gICAgICAgIGNvbnN0IHZ4ID0gLShnbHlwaC52bWV0cmljID8gdm1ldHJpY1sxXSA6IHdpZHRoICogMC41KSAqIHdpZHRoQWR2YW5jZVNjYWxlO1xuICAgICAgICBjb25zdCB2eSA9IHZtZXRyaWNbMl0gKiB3aWR0aEFkdmFuY2VTY2FsZTtcbiAgICAgICAgd2lkdGggPSB2bWV0cmljID8gLXZtZXRyaWNbMF0gOiB3aWR0aDtcbiAgICAgICAgc2NhbGVkWCA9IHZ4IC8gZm9udFNpemVTY2FsZTtcbiAgICAgICAgc2NhbGVkWSA9ICh4ICsgdnkpIC8gZm9udFNpemVTY2FsZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNjYWxlZFggPSB4IC8gZm9udFNpemVTY2FsZTtcbiAgICAgICAgc2NhbGVkWSA9IDA7XG4gICAgICB9XG4gICAgICBpZiAoZm9udC5yZW1lYXN1cmUgJiYgd2lkdGggPiAwKSB7XG4gICAgICAgIGNvbnN0IG1lYXN1cmVkV2lkdGggPSBjdHgubWVhc3VyZVRleHQoY2hhcmFjdGVyKS53aWR0aCAqIDEwMDAgLyBmb250U2l6ZSAqIGZvbnRTaXplU2NhbGU7XG4gICAgICAgIGlmICh3aWR0aCA8IG1lYXN1cmVkV2lkdGggJiYgdGhpcy5pc0ZvbnRTdWJwaXhlbEFBRW5hYmxlZCkge1xuICAgICAgICAgIGNvbnN0IGNoYXJhY3RlclNjYWxlWCA9IHdpZHRoIC8gbWVhc3VyZWRXaWR0aDtcbiAgICAgICAgICByZXN0b3JlTmVlZGVkID0gdHJ1ZTtcbiAgICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICAgIGN0eC5zY2FsZShjaGFyYWN0ZXJTY2FsZVgsIDEpO1xuICAgICAgICAgIHNjYWxlZFggLz0gY2hhcmFjdGVyU2NhbGVYO1xuICAgICAgICB9IGVsc2UgaWYgKHdpZHRoICE9PSBtZWFzdXJlZFdpZHRoKSB7XG4gICAgICAgICAgc2NhbGVkWCArPSAod2lkdGggLSBtZWFzdXJlZFdpZHRoKSAvIDIwMDAgKiBmb250U2l6ZSAvIGZvbnRTaXplU2NhbGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmNvbnRlbnRWaXNpYmxlICYmIChnbHlwaC5pc0luRm9udCB8fCBmb250Lm1pc3NpbmdGaWxlKSkge1xuICAgICAgICBpZiAoc2ltcGxlRmlsbFRleHQgJiYgIWFjY2VudCkge1xuICAgICAgICAgIGN0eC5maWxsVGV4dChjaGFyYWN0ZXIsIHNjYWxlZFgsIHNjYWxlZFkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucGFpbnRDaGFyKGNoYXJhY3Rlciwgc2NhbGVkWCwgc2NhbGVkWSwgcGF0dGVyblRyYW5zZm9ybSk7XG4gICAgICAgICAgaWYgKGFjY2VudCkge1xuICAgICAgICAgICAgY29uc3Qgc2NhbGVkQWNjZW50WCA9IHNjYWxlZFggKyBmb250U2l6ZSAqIGFjY2VudC5vZmZzZXQueCAvIGZvbnRTaXplU2NhbGU7XG4gICAgICAgICAgICBjb25zdCBzY2FsZWRBY2NlbnRZID0gc2NhbGVkWSAtIGZvbnRTaXplICogYWNjZW50Lm9mZnNldC55IC8gZm9udFNpemVTY2FsZTtcbiAgICAgICAgICAgIHRoaXMucGFpbnRDaGFyKGFjY2VudC5mb250Q2hhciwgc2NhbGVkQWNjZW50WCwgc2NhbGVkQWNjZW50WSwgcGF0dGVyblRyYW5zZm9ybSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBjaGFyV2lkdGggPSB2ZXJ0aWNhbCA/IHdpZHRoICogd2lkdGhBZHZhbmNlU2NhbGUgLSBzcGFjaW5nICogZm9udERpcmVjdGlvbiA6IHdpZHRoICogd2lkdGhBZHZhbmNlU2NhbGUgKyBzcGFjaW5nICogZm9udERpcmVjdGlvbjtcbiAgICAgIHggKz0gY2hhcldpZHRoO1xuICAgICAgaWYgKHJlc3RvcmVOZWVkZWQpIHtcbiAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHZlcnRpY2FsKSB7XG4gICAgICBjdXJyZW50LnkgLT0geDtcbiAgICB9IGVsc2Uge1xuICAgICAgY3VycmVudC54ICs9IHggKiB0ZXh0SFNjYWxlO1xuICAgIH1cbiAgICBjdHgucmVzdG9yZSgpO1xuICAgIHRoaXMuY29tcG9zZSgpO1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgc2hvd1R5cGUzVGV4dChnbHlwaHMpIHtcbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICBjb25zdCBjdXJyZW50ID0gdGhpcy5jdXJyZW50O1xuICAgIGNvbnN0IGZvbnQgPSBjdXJyZW50LmZvbnQ7XG4gICAgY29uc3QgZm9udFNpemUgPSBjdXJyZW50LmZvbnRTaXplO1xuICAgIGNvbnN0IGZvbnREaXJlY3Rpb24gPSBjdXJyZW50LmZvbnREaXJlY3Rpb247XG4gICAgY29uc3Qgc3BhY2luZ0RpciA9IGZvbnQudmVydGljYWwgPyAxIDogLTE7XG4gICAgY29uc3QgY2hhclNwYWNpbmcgPSBjdXJyZW50LmNoYXJTcGFjaW5nO1xuICAgIGNvbnN0IHdvcmRTcGFjaW5nID0gY3VycmVudC53b3JkU3BhY2luZztcbiAgICBjb25zdCB0ZXh0SFNjYWxlID0gY3VycmVudC50ZXh0SFNjYWxlICogZm9udERpcmVjdGlvbjtcbiAgICBjb25zdCBmb250TWF0cml4ID0gY3VycmVudC5mb250TWF0cml4IHx8IF91dGlsLkZPTlRfSURFTlRJVFlfTUFUUklYO1xuICAgIGNvbnN0IGdseXBoc0xlbmd0aCA9IGdseXBocy5sZW5ndGg7XG4gICAgY29uc3QgaXNUZXh0SW52aXNpYmxlID0gY3VycmVudC50ZXh0UmVuZGVyaW5nTW9kZSA9PT0gX3V0aWwuVGV4dFJlbmRlcmluZ01vZGUuSU5WSVNJQkxFO1xuICAgIGxldCBpLCBnbHlwaCwgd2lkdGgsIHNwYWNpbmdMZW5ndGg7XG4gICAgaWYgKGlzVGV4dEludmlzaWJsZSB8fCBmb250U2l6ZSA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9jYWNoZWRTY2FsZUZvclN0cm9raW5nWzBdID0gLTE7XG4gICAgdGhpcy5fY2FjaGVkR2V0U2luZ2xlUGl4ZWxXaWR0aCA9IG51bGw7XG4gICAgY3R4LnNhdmUoKTtcbiAgICBjdHgudHJhbnNmb3JtKC4uLmN1cnJlbnQudGV4dE1hdHJpeCk7XG4gICAgY3R4LnRyYW5zbGF0ZShjdXJyZW50LngsIGN1cnJlbnQueSk7XG4gICAgY3R4LnNjYWxlKHRleHRIU2NhbGUsIGZvbnREaXJlY3Rpb24pO1xuICAgIGZvciAoaSA9IDA7IGkgPCBnbHlwaHNMZW5ndGg7ICsraSkge1xuICAgICAgZ2x5cGggPSBnbHlwaHNbaV07XG4gICAgICBpZiAodHlwZW9mIGdseXBoID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHNwYWNpbmdMZW5ndGggPSBzcGFjaW5nRGlyICogZ2x5cGggKiBmb250U2l6ZSAvIDEwMDA7XG4gICAgICAgIHRoaXMuY3R4LnRyYW5zbGF0ZShzcGFjaW5nTGVuZ3RoLCAwKTtcbiAgICAgICAgY3VycmVudC54ICs9IHNwYWNpbmdMZW5ndGggKiB0ZXh0SFNjYWxlO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNwYWNpbmcgPSAoZ2x5cGguaXNTcGFjZSA/IHdvcmRTcGFjaW5nIDogMCkgKyBjaGFyU3BhY2luZztcbiAgICAgIGNvbnN0IG9wZXJhdG9yTGlzdCA9IGZvbnQuY2hhclByb2NPcGVyYXRvckxpc3RbZ2x5cGgub3BlcmF0b3JMaXN0SWRdO1xuICAgICAgaWYgKCFvcGVyYXRvckxpc3QpIHtcbiAgICAgICAgKDAsIF91dGlsLndhcm4pKGBUeXBlMyBjaGFyYWN0ZXIgXCIke2dseXBoLm9wZXJhdG9yTGlzdElkfVwiIGlzIG5vdCBhdmFpbGFibGUuYCk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuY29udGVudFZpc2libGUpIHtcbiAgICAgICAgdGhpcy5wcm9jZXNzaW5nVHlwZTMgPSBnbHlwaDtcbiAgICAgICAgdGhpcy5zYXZlKCk7XG4gICAgICAgIGN0eC5zY2FsZShmb250U2l6ZSwgZm9udFNpemUpO1xuICAgICAgICBjdHgudHJhbnNmb3JtKC4uLmZvbnRNYXRyaXgpO1xuICAgICAgICB0aGlzLmV4ZWN1dGVPcGVyYXRvckxpc3Qob3BlcmF0b3JMaXN0KTtcbiAgICAgICAgdGhpcy5yZXN0b3JlKCk7XG4gICAgICB9XG4gICAgICBjb25zdCB0cmFuc2Zvcm1lZCA9IF91dGlsLlV0aWwuYXBwbHlUcmFuc2Zvcm0oW2dseXBoLndpZHRoLCAwXSwgZm9udE1hdHJpeCk7XG4gICAgICB3aWR0aCA9IHRyYW5zZm9ybWVkWzBdICogZm9udFNpemUgKyBzcGFjaW5nO1xuICAgICAgY3R4LnRyYW5zbGF0ZSh3aWR0aCwgMCk7XG4gICAgICBjdXJyZW50LnggKz0gd2lkdGggKiB0ZXh0SFNjYWxlO1xuICAgIH1cbiAgICBjdHgucmVzdG9yZSgpO1xuICAgIHRoaXMucHJvY2Vzc2luZ1R5cGUzID0gbnVsbDtcbiAgfVxuICBzZXRDaGFyV2lkdGgoeFdpZHRoLCB5V2lkdGgpIHt9XG4gIHNldENoYXJXaWR0aEFuZEJvdW5kcyh4V2lkdGgsIHlXaWR0aCwgbGx4LCBsbHksIHVyeCwgdXJ5KSB7XG4gICAgdGhpcy5jdHgucmVjdChsbHgsIGxseSwgdXJ4IC0gbGx4LCB1cnkgLSBsbHkpO1xuICAgIHRoaXMuY3R4LmNsaXAoKTtcbiAgICB0aGlzLmVuZFBhdGgoKTtcbiAgfVxuICBnZXRDb2xvck5fUGF0dGVybihJUikge1xuICAgIGxldCBwYXR0ZXJuO1xuICAgIGlmIChJUlswXSA9PT0gXCJUaWxpbmdQYXR0ZXJuXCIpIHtcbiAgICAgIGNvbnN0IGNvbG9yID0gSVJbMV07XG4gICAgICBjb25zdCBiYXNlVHJhbnNmb3JtID0gdGhpcy5iYXNlVHJhbnNmb3JtIHx8ICgwLCBfZGlzcGxheV91dGlscy5nZXRDdXJyZW50VHJhbnNmb3JtKSh0aGlzLmN0eCk7XG4gICAgICBjb25zdCBjYW52YXNHcmFwaGljc0ZhY3RvcnkgPSB7XG4gICAgICAgIGNyZWF0ZUNhbnZhc0dyYXBoaWNzOiBjdHggPT4ge1xuICAgICAgICAgIHJldHVybiBuZXcgQ2FudmFzR3JhcGhpY3MoY3R4LCB0aGlzLmNvbW1vbk9ianMsIHRoaXMub2JqcywgdGhpcy5jYW52YXNGYWN0b3J5LCB0aGlzLmZpbHRlckZhY3RvcnksIHtcbiAgICAgICAgICAgIG9wdGlvbmFsQ29udGVudENvbmZpZzogdGhpcy5vcHRpb25hbENvbnRlbnRDb25maWcsXG4gICAgICAgICAgICBtYXJrZWRDb250ZW50U3RhY2s6IHRoaXMubWFya2VkQ29udGVudFN0YWNrXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBwYXR0ZXJuID0gbmV3IF9wYXR0ZXJuX2hlbHBlci5UaWxpbmdQYXR0ZXJuKElSLCBjb2xvciwgdGhpcy5jdHgsIGNhbnZhc0dyYXBoaWNzRmFjdG9yeSwgYmFzZVRyYW5zZm9ybSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhdHRlcm4gPSB0aGlzLl9nZXRQYXR0ZXJuKElSWzFdLCBJUlsyXSk7XG4gICAgfVxuICAgIHJldHVybiBwYXR0ZXJuO1xuICB9XG4gIHNldFN0cm9rZUNvbG9yTigpIHtcbiAgICB0aGlzLmN1cnJlbnQuc3Ryb2tlQ29sb3IgPSB0aGlzLmdldENvbG9yTl9QYXR0ZXJuKGFyZ3VtZW50cyk7XG4gIH1cbiAgc2V0RmlsbENvbG9yTigpIHtcbiAgICB0aGlzLmN1cnJlbnQuZmlsbENvbG9yID0gdGhpcy5nZXRDb2xvck5fUGF0dGVybihhcmd1bWVudHMpO1xuICAgIHRoaXMuY3VycmVudC5wYXR0ZXJuRmlsbCA9IHRydWU7XG4gIH1cbiAgc2V0U3Ryb2tlUkdCQ29sb3IociwgZywgYikge1xuICAgIGNvbnN0IGNvbG9yID0gX3V0aWwuVXRpbC5tYWtlSGV4Q29sb3IociwgZywgYik7XG4gICAgdGhpcy5jdHguc3Ryb2tlU3R5bGUgPSBjb2xvcjtcbiAgICB0aGlzLmN1cnJlbnQuc3Ryb2tlQ29sb3IgPSBjb2xvcjtcbiAgfVxuICBzZXRGaWxsUkdCQ29sb3IociwgZywgYikge1xuICAgIGNvbnN0IGNvbG9yID0gX3V0aWwuVXRpbC5tYWtlSGV4Q29sb3IociwgZywgYik7XG4gICAgdGhpcy5jdHguZmlsbFN0eWxlID0gY29sb3I7XG4gICAgdGhpcy5jdXJyZW50LmZpbGxDb2xvciA9IGNvbG9yO1xuICAgIHRoaXMuY3VycmVudC5wYXR0ZXJuRmlsbCA9IGZhbHNlO1xuICB9XG4gIF9nZXRQYXR0ZXJuKG9iaklkLCBtYXRyaXggPSBudWxsKSB7XG4gICAgbGV0IHBhdHRlcm47XG4gICAgaWYgKHRoaXMuY2FjaGVkUGF0dGVybnMuaGFzKG9iaklkKSkge1xuICAgICAgcGF0dGVybiA9IHRoaXMuY2FjaGVkUGF0dGVybnMuZ2V0KG9iaklkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGF0dGVybiA9ICgwLCBfcGF0dGVybl9oZWxwZXIuZ2V0U2hhZGluZ1BhdHRlcm4pKHRoaXMuZ2V0T2JqZWN0KG9iaklkKSk7XG4gICAgICB0aGlzLmNhY2hlZFBhdHRlcm5zLnNldChvYmpJZCwgcGF0dGVybik7XG4gICAgfVxuICAgIGlmIChtYXRyaXgpIHtcbiAgICAgIHBhdHRlcm4ubWF0cml4ID0gbWF0cml4O1xuICAgIH1cbiAgICByZXR1cm4gcGF0dGVybjtcbiAgfVxuICBzaGFkaW5nRmlsbChvYmpJZCkge1xuICAgIGlmICghdGhpcy5jb250ZW50VmlzaWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICB0aGlzLnNhdmUoKTtcbiAgICBjb25zdCBwYXR0ZXJuID0gdGhpcy5fZ2V0UGF0dGVybihvYmpJZCk7XG4gICAgY3R4LmZpbGxTdHlsZSA9IHBhdHRlcm4uZ2V0UGF0dGVybihjdHgsIHRoaXMsICgwLCBfZGlzcGxheV91dGlscy5nZXRDdXJyZW50VHJhbnNmb3JtSW52ZXJzZSkoY3R4KSwgX3BhdHRlcm5faGVscGVyLlBhdGhUeXBlLlNIQURJTkcpO1xuICAgIGNvbnN0IGludiA9ICgwLCBfZGlzcGxheV91dGlscy5nZXRDdXJyZW50VHJhbnNmb3JtSW52ZXJzZSkoY3R4KTtcbiAgICBpZiAoaW52KSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHdpZHRoLFxuICAgICAgICBoZWlnaHRcbiAgICAgIH0gPSBjdHguY2FudmFzO1xuICAgICAgY29uc3QgW3gwLCB5MCwgeDEsIHkxXSA9IF91dGlsLlV0aWwuZ2V0QXhpYWxBbGlnbmVkQm91bmRpbmdCb3goWzAsIDAsIHdpZHRoLCBoZWlnaHRdLCBpbnYpO1xuICAgICAgdGhpcy5jdHguZmlsbFJlY3QoeDAsIHkwLCB4MSAtIHgwLCB5MSAtIHkwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jdHguZmlsbFJlY3QoLTFlMTAsIC0xZTEwLCAyZTEwLCAyZTEwKTtcbiAgICB9XG4gICAgdGhpcy5jb21wb3NlKHRoaXMuY3VycmVudC5nZXRDbGlwcGVkUGF0aEJvdW5kaW5nQm94KCkpO1xuICAgIHRoaXMucmVzdG9yZSgpO1xuICB9XG4gIGJlZ2luSW5saW5lSW1hZ2UoKSB7XG4gICAgKDAsIF91dGlsLnVucmVhY2hhYmxlKShcIlNob3VsZCBub3QgY2FsbCBiZWdpbklubGluZUltYWdlXCIpO1xuICB9XG4gIGJlZ2luSW1hZ2VEYXRhKCkge1xuICAgICgwLCBfdXRpbC51bnJlYWNoYWJsZSkoXCJTaG91bGQgbm90IGNhbGwgYmVnaW5JbWFnZURhdGFcIik7XG4gIH1cbiAgcGFpbnRGb3JtWE9iamVjdEJlZ2luKG1hdHJpeCwgYmJveCkge1xuICAgIGlmICghdGhpcy5jb250ZW50VmlzaWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnNhdmUoKTtcbiAgICB0aGlzLmJhc2VUcmFuc2Zvcm1TdGFjay5wdXNoKHRoaXMuYmFzZVRyYW5zZm9ybSk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkobWF0cml4KSAmJiBtYXRyaXgubGVuZ3RoID09PSA2KSB7XG4gICAgICB0aGlzLnRyYW5zZm9ybSguLi5tYXRyaXgpO1xuICAgIH1cbiAgICB0aGlzLmJhc2VUcmFuc2Zvcm0gPSAoMCwgX2Rpc3BsYXlfdXRpbHMuZ2V0Q3VycmVudFRyYW5zZm9ybSkodGhpcy5jdHgpO1xuICAgIGlmIChiYm94KSB7XG4gICAgICBjb25zdCB3aWR0aCA9IGJib3hbMl0gLSBiYm94WzBdO1xuICAgICAgY29uc3QgaGVpZ2h0ID0gYmJveFszXSAtIGJib3hbMV07XG4gICAgICB0aGlzLmN0eC5yZWN0KGJib3hbMF0sIGJib3hbMV0sIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgdGhpcy5jdXJyZW50LnVwZGF0ZVJlY3RNaW5NYXgoKDAsIF9kaXNwbGF5X3V0aWxzLmdldEN1cnJlbnRUcmFuc2Zvcm0pKHRoaXMuY3R4KSwgYmJveCk7XG4gICAgICB0aGlzLmNsaXAoKTtcbiAgICAgIHRoaXMuZW5kUGF0aCgpO1xuICAgIH1cbiAgfVxuICBwYWludEZvcm1YT2JqZWN0RW5kKCkge1xuICAgIGlmICghdGhpcy5jb250ZW50VmlzaWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnJlc3RvcmUoKTtcbiAgICB0aGlzLmJhc2VUcmFuc2Zvcm0gPSB0aGlzLmJhc2VUcmFuc2Zvcm1TdGFjay5wb3AoKTtcbiAgfVxuICBiZWdpbkdyb3VwKGdyb3VwKSB7XG4gICAgaWYgKCF0aGlzLmNvbnRlbnRWaXNpYmxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuc2F2ZSgpO1xuICAgIGlmICh0aGlzLmluU01hc2tNb2RlKSB7XG4gICAgICB0aGlzLmVuZFNNYXNrTW9kZSgpO1xuICAgICAgdGhpcy5jdXJyZW50LmFjdGl2ZVNNYXNrID0gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgY3VycmVudEN0eCA9IHRoaXMuY3R4O1xuICAgIGlmICghZ3JvdXAuaXNvbGF0ZWQpIHtcbiAgICAgICgwLCBfdXRpbC5pbmZvKShcIlRPRE86IFN1cHBvcnQgbm9uLWlzb2xhdGVkIGdyb3Vwcy5cIik7XG4gICAgfVxuICAgIGlmIChncm91cC5rbm9ja291dCkge1xuICAgICAgKDAsIF91dGlsLndhcm4pKFwiS25vY2tvdXQgZ3JvdXBzIG5vdCBzdXBwb3J0ZWQuXCIpO1xuICAgIH1cbiAgICBjb25zdCBjdXJyZW50VHJhbnNmb3JtID0gKDAsIF9kaXNwbGF5X3V0aWxzLmdldEN1cnJlbnRUcmFuc2Zvcm0pKGN1cnJlbnRDdHgpO1xuICAgIGlmIChncm91cC5tYXRyaXgpIHtcbiAgICAgIGN1cnJlbnRDdHgudHJhbnNmb3JtKC4uLmdyb3VwLm1hdHJpeCk7XG4gICAgfVxuICAgIGlmICghZ3JvdXAuYmJveCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQm91bmRpbmcgYm94IGlzIHJlcXVpcmVkLlwiKTtcbiAgICB9XG4gICAgbGV0IGJvdW5kcyA9IF91dGlsLlV0aWwuZ2V0QXhpYWxBbGlnbmVkQm91bmRpbmdCb3goZ3JvdXAuYmJveCwgKDAsIF9kaXNwbGF5X3V0aWxzLmdldEN1cnJlbnRUcmFuc2Zvcm0pKGN1cnJlbnRDdHgpKTtcbiAgICBjb25zdCBjYW52YXNCb3VuZHMgPSBbMCwgMCwgY3VycmVudEN0eC5jYW52YXMud2lkdGgsIGN1cnJlbnRDdHguY2FudmFzLmhlaWdodF07XG4gICAgYm91bmRzID0gX3V0aWwuVXRpbC5pbnRlcnNlY3QoYm91bmRzLCBjYW52YXNCb3VuZHMpIHx8IFswLCAwLCAwLCAwXTtcbiAgICBjb25zdCBvZmZzZXRYID0gTWF0aC5mbG9vcihib3VuZHNbMF0pO1xuICAgIGNvbnN0IG9mZnNldFkgPSBNYXRoLmZsb29yKGJvdW5kc1sxXSk7XG4gICAgbGV0IGRyYXduV2lkdGggPSBNYXRoLm1heChNYXRoLmNlaWwoYm91bmRzWzJdKSAtIG9mZnNldFgsIDEpO1xuICAgIGxldCBkcmF3bkhlaWdodCA9IE1hdGgubWF4KE1hdGguY2VpbChib3VuZHNbM10pIC0gb2Zmc2V0WSwgMSk7XG4gICAgbGV0IHNjYWxlWCA9IDEsXG4gICAgICBzY2FsZVkgPSAxO1xuICAgIGlmIChkcmF3bldpZHRoID4gTUFYX0dST1VQX1NJWkUpIHtcbiAgICAgIHNjYWxlWCA9IGRyYXduV2lkdGggLyBNQVhfR1JPVVBfU0laRTtcbiAgICAgIGRyYXduV2lkdGggPSBNQVhfR1JPVVBfU0laRTtcbiAgICB9XG4gICAgaWYgKGRyYXduSGVpZ2h0ID4gTUFYX0dST1VQX1NJWkUpIHtcbiAgICAgIHNjYWxlWSA9IGRyYXduSGVpZ2h0IC8gTUFYX0dST1VQX1NJWkU7XG4gICAgICBkcmF3bkhlaWdodCA9IE1BWF9HUk9VUF9TSVpFO1xuICAgIH1cbiAgICB0aGlzLmN1cnJlbnQuc3RhcnROZXdQYXRoQW5kQ2xpcEJveChbMCwgMCwgZHJhd25XaWR0aCwgZHJhd25IZWlnaHRdKTtcbiAgICBsZXQgY2FjaGVJZCA9IFwiZ3JvdXBBdFwiICsgdGhpcy5ncm91cExldmVsO1xuICAgIGlmIChncm91cC5zbWFzaykge1xuICAgICAgY2FjaGVJZCArPSBcIl9zbWFza19cIiArIHRoaXMuc21hc2tDb3VudGVyKysgJSAyO1xuICAgIH1cbiAgICBjb25zdCBzY3JhdGNoQ2FudmFzID0gdGhpcy5jYWNoZWRDYW52YXNlcy5nZXRDYW52YXMoY2FjaGVJZCwgZHJhd25XaWR0aCwgZHJhd25IZWlnaHQpO1xuICAgIGNvbnN0IGdyb3VwQ3R4ID0gc2NyYXRjaENhbnZhcy5jb250ZXh0O1xuICAgIGdyb3VwQ3R4LnNjYWxlKDEgLyBzY2FsZVgsIDEgLyBzY2FsZVkpO1xuICAgIGdyb3VwQ3R4LnRyYW5zbGF0ZSgtb2Zmc2V0WCwgLW9mZnNldFkpO1xuICAgIGdyb3VwQ3R4LnRyYW5zZm9ybSguLi5jdXJyZW50VHJhbnNmb3JtKTtcbiAgICBpZiAoZ3JvdXAuc21hc2spIHtcbiAgICAgIHRoaXMuc21hc2tTdGFjay5wdXNoKHtcbiAgICAgICAgY2FudmFzOiBzY3JhdGNoQ2FudmFzLmNhbnZhcyxcbiAgICAgICAgY29udGV4dDogZ3JvdXBDdHgsXG4gICAgICAgIG9mZnNldFgsXG4gICAgICAgIG9mZnNldFksXG4gICAgICAgIHNjYWxlWCxcbiAgICAgICAgc2NhbGVZLFxuICAgICAgICBzdWJ0eXBlOiBncm91cC5zbWFzay5zdWJ0eXBlLFxuICAgICAgICBiYWNrZHJvcDogZ3JvdXAuc21hc2suYmFja2Ryb3AsXG4gICAgICAgIHRyYW5zZmVyTWFwOiBncm91cC5zbWFzay50cmFuc2Zlck1hcCB8fCBudWxsLFxuICAgICAgICBzdGFydFRyYW5zZm9ybUludmVyc2U6IG51bGxcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdXJyZW50Q3R4LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcbiAgICAgIGN1cnJlbnRDdHgudHJhbnNsYXRlKG9mZnNldFgsIG9mZnNldFkpO1xuICAgICAgY3VycmVudEN0eC5zY2FsZShzY2FsZVgsIHNjYWxlWSk7XG4gICAgICBjdXJyZW50Q3R4LnNhdmUoKTtcbiAgICB9XG4gICAgY29weUN0eFN0YXRlKGN1cnJlbnRDdHgsIGdyb3VwQ3R4KTtcbiAgICB0aGlzLmN0eCA9IGdyb3VwQ3R4O1xuICAgIHRoaXMuc2V0R1N0YXRlKFtbXCJCTVwiLCBcInNvdXJjZS1vdmVyXCJdLCBbXCJjYVwiLCAxXSwgW1wiQ0FcIiwgMV1dKTtcbiAgICB0aGlzLmdyb3VwU3RhY2sucHVzaChjdXJyZW50Q3R4KTtcbiAgICB0aGlzLmdyb3VwTGV2ZWwrKztcbiAgfVxuICBlbmRHcm91cChncm91cCkge1xuICAgIGlmICghdGhpcy5jb250ZW50VmlzaWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmdyb3VwTGV2ZWwtLTtcbiAgICBjb25zdCBncm91cEN0eCA9IHRoaXMuY3R4O1xuICAgIGNvbnN0IGN0eCA9IHRoaXMuZ3JvdXBTdGFjay5wb3AoKTtcbiAgICB0aGlzLmN0eCA9IGN0eDtcbiAgICB0aGlzLmN0eC5pbWFnZVNtb290aGluZ0VuYWJsZWQgPSBmYWxzZTtcbiAgICBpZiAoZ3JvdXAuc21hc2spIHtcbiAgICAgIHRoaXMudGVtcFNNYXNrID0gdGhpcy5zbWFza1N0YWNrLnBvcCgpO1xuICAgICAgdGhpcy5yZXN0b3JlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY3R4LnJlc3RvcmUoKTtcbiAgICAgIGNvbnN0IGN1cnJlbnRNdHggPSAoMCwgX2Rpc3BsYXlfdXRpbHMuZ2V0Q3VycmVudFRyYW5zZm9ybSkodGhpcy5jdHgpO1xuICAgICAgdGhpcy5yZXN0b3JlKCk7XG4gICAgICB0aGlzLmN0eC5zYXZlKCk7XG4gICAgICB0aGlzLmN0eC5zZXRUcmFuc2Zvcm0oLi4uY3VycmVudE10eCk7XG4gICAgICBjb25zdCBkaXJ0eUJveCA9IF91dGlsLlV0aWwuZ2V0QXhpYWxBbGlnbmVkQm91bmRpbmdCb3goWzAsIDAsIGdyb3VwQ3R4LmNhbnZhcy53aWR0aCwgZ3JvdXBDdHguY2FudmFzLmhlaWdodF0sIGN1cnJlbnRNdHgpO1xuICAgICAgdGhpcy5jdHguZHJhd0ltYWdlKGdyb3VwQ3R4LmNhbnZhcywgMCwgMCk7XG4gICAgICB0aGlzLmN0eC5yZXN0b3JlKCk7XG4gICAgICB0aGlzLmNvbXBvc2UoZGlydHlCb3gpO1xuICAgIH1cbiAgfVxuICBiZWdpbkFubm90YXRpb24oaWQsIHJlY3QsIHRyYW5zZm9ybSwgbWF0cml4LCBoYXNPd25DYW52YXMpIHtcbiAgICB0aGlzLiNyZXN0b3JlSW5pdGlhbFN0YXRlKCk7XG4gICAgcmVzZXRDdHhUb0RlZmF1bHQodGhpcy5jdHgpO1xuICAgIHRoaXMuY3R4LnNhdmUoKTtcbiAgICB0aGlzLnNhdmUoKTtcbiAgICBpZiAodGhpcy5iYXNlVHJhbnNmb3JtKSB7XG4gICAgICB0aGlzLmN0eC5zZXRUcmFuc2Zvcm0oLi4udGhpcy5iYXNlVHJhbnNmb3JtKTtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocmVjdCkgJiYgcmVjdC5sZW5ndGggPT09IDQpIHtcbiAgICAgIGNvbnN0IHdpZHRoID0gcmVjdFsyXSAtIHJlY3RbMF07XG4gICAgICBjb25zdCBoZWlnaHQgPSByZWN0WzNdIC0gcmVjdFsxXTtcbiAgICAgIGlmIChoYXNPd25DYW52YXMgJiYgdGhpcy5hbm5vdGF0aW9uQ2FudmFzTWFwKSB7XG4gICAgICAgIHRyYW5zZm9ybSA9IHRyYW5zZm9ybS5zbGljZSgpO1xuICAgICAgICB0cmFuc2Zvcm1bNF0gLT0gcmVjdFswXTtcbiAgICAgICAgdHJhbnNmb3JtWzVdIC09IHJlY3RbMV07XG4gICAgICAgIHJlY3QgPSByZWN0LnNsaWNlKCk7XG4gICAgICAgIHJlY3RbMF0gPSByZWN0WzFdID0gMDtcbiAgICAgICAgcmVjdFsyXSA9IHdpZHRoO1xuICAgICAgICByZWN0WzNdID0gaGVpZ2h0O1xuICAgICAgICBjb25zdCBbc2NhbGVYLCBzY2FsZVldID0gX3V0aWwuVXRpbC5zaW5ndWxhclZhbHVlRGVjb21wb3NlMmRTY2FsZSgoMCwgX2Rpc3BsYXlfdXRpbHMuZ2V0Q3VycmVudFRyYW5zZm9ybSkodGhpcy5jdHgpKTtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHZpZXdwb3J0U2NhbGVcbiAgICAgICAgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGNhbnZhc1dpZHRoID0gTWF0aC5jZWlsKHdpZHRoICogdGhpcy5vdXRwdXRTY2FsZVggKiB2aWV3cG9ydFNjYWxlKTtcbiAgICAgICAgY29uc3QgY2FudmFzSGVpZ2h0ID0gTWF0aC5jZWlsKGhlaWdodCAqIHRoaXMub3V0cHV0U2NhbGVZICogdmlld3BvcnRTY2FsZSk7XG4gICAgICAgIHRoaXMuYW5ub3RhdGlvbkNhbnZhcyA9IHRoaXMuY2FudmFzRmFjdG9yeS5jcmVhdGUoY2FudmFzV2lkdGgsIGNhbnZhc0hlaWdodCk7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBjYW52YXMsXG4gICAgICAgICAgY29udGV4dFxuICAgICAgICB9ID0gdGhpcy5hbm5vdGF0aW9uQ2FudmFzO1xuICAgICAgICB0aGlzLmFubm90YXRpb25DYW52YXNNYXAuc2V0KGlkLCBjYW52YXMpO1xuICAgICAgICB0aGlzLmFubm90YXRpb25DYW52YXMuc2F2ZWRDdHggPSB0aGlzLmN0eDtcbiAgICAgICAgdGhpcy5jdHggPSBjb250ZXh0O1xuICAgICAgICB0aGlzLmN0eC5zYXZlKCk7XG4gICAgICAgIHRoaXMuY3R4LnNldFRyYW5zZm9ybShzY2FsZVgsIDAsIDAsIC1zY2FsZVksIDAsIGhlaWdodCAqIHNjYWxlWSk7XG4gICAgICAgIHJlc2V0Q3R4VG9EZWZhdWx0KHRoaXMuY3R4KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc2V0Q3R4VG9EZWZhdWx0KHRoaXMuY3R4KTtcbiAgICAgICAgdGhpcy5jdHgucmVjdChyZWN0WzBdLCByZWN0WzFdLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgdGhpcy5jdHguY2xpcCgpO1xuICAgICAgICB0aGlzLmVuZFBhdGgoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5jdXJyZW50ID0gbmV3IENhbnZhc0V4dHJhU3RhdGUodGhpcy5jdHguY2FudmFzLndpZHRoLCB0aGlzLmN0eC5jYW52YXMuaGVpZ2h0KTtcbiAgICB0aGlzLnRyYW5zZm9ybSguLi50cmFuc2Zvcm0pO1xuICAgIHRoaXMudHJhbnNmb3JtKC4uLm1hdHJpeCk7XG4gIH1cbiAgZW5kQW5ub3RhdGlvbigpIHtcbiAgICBpZiAodGhpcy5hbm5vdGF0aW9uQ2FudmFzKSB7XG4gICAgICB0aGlzLmN0eC5yZXN0b3JlKCk7XG4gICAgICB0aGlzLiNkcmF3RmlsdGVyKCk7XG4gICAgICB0aGlzLmN0eCA9IHRoaXMuYW5ub3RhdGlvbkNhbnZhcy5zYXZlZEN0eDtcbiAgICAgIGRlbGV0ZSB0aGlzLmFubm90YXRpb25DYW52YXMuc2F2ZWRDdHg7XG4gICAgICBkZWxldGUgdGhpcy5hbm5vdGF0aW9uQ2FudmFzO1xuICAgIH1cbiAgfVxuICBwYWludEltYWdlTWFza1hPYmplY3QoaW1nKSB7XG4gICAgaWYgKCF0aGlzLmNvbnRlbnRWaXNpYmxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGNvdW50ID0gaW1nLmNvdW50O1xuICAgIGltZyA9IHRoaXMuZ2V0T2JqZWN0KGltZy5kYXRhLCBpbWcpO1xuICAgIGltZy5jb3VudCA9IGNvdW50O1xuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgIGNvbnN0IGdseXBoID0gdGhpcy5wcm9jZXNzaW5nVHlwZTM7XG4gICAgaWYgKGdseXBoKSB7XG4gICAgICBpZiAoZ2x5cGguY29tcGlsZWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBnbHlwaC5jb21waWxlZCA9IGNvbXBpbGVUeXBlM0dseXBoKGltZyk7XG4gICAgICB9XG4gICAgICBpZiAoZ2x5cGguY29tcGlsZWQpIHtcbiAgICAgICAgZ2x5cGguY29tcGlsZWQoY3R4KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBtYXNrID0gdGhpcy5fY3JlYXRlTWFza0NhbnZhcyhpbWcpO1xuICAgIGNvbnN0IG1hc2tDYW52YXMgPSBtYXNrLmNhbnZhcztcbiAgICBjdHguc2F2ZSgpO1xuICAgIGN0eC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG4gICAgY3R4LmRyYXdJbWFnZShtYXNrQ2FudmFzLCBtYXNrLm9mZnNldFgsIG1hc2sub2Zmc2V0WSk7XG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgICB0aGlzLmNvbXBvc2UoKTtcbiAgfVxuICBwYWludEltYWdlTWFza1hPYmplY3RSZXBlYXQoaW1nLCBzY2FsZVgsIHNrZXdYID0gMCwgc2tld1kgPSAwLCBzY2FsZVksIHBvc2l0aW9ucykge1xuICAgIGlmICghdGhpcy5jb250ZW50VmlzaWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpbWcgPSB0aGlzLmdldE9iamVjdChpbWcuZGF0YSwgaW1nKTtcbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICBjdHguc2F2ZSgpO1xuICAgIGNvbnN0IGN1cnJlbnRUcmFuc2Zvcm0gPSAoMCwgX2Rpc3BsYXlfdXRpbHMuZ2V0Q3VycmVudFRyYW5zZm9ybSkoY3R4KTtcbiAgICBjdHgudHJhbnNmb3JtKHNjYWxlWCwgc2tld1gsIHNrZXdZLCBzY2FsZVksIDAsIDApO1xuICAgIGNvbnN0IG1hc2sgPSB0aGlzLl9jcmVhdGVNYXNrQ2FudmFzKGltZyk7XG4gICAgY3R4LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCBtYXNrLm9mZnNldFggLSBjdXJyZW50VHJhbnNmb3JtWzRdLCBtYXNrLm9mZnNldFkgLSBjdXJyZW50VHJhbnNmb3JtWzVdKTtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBwb3NpdGlvbnMubGVuZ3RoOyBpIDwgaWk7IGkgKz0gMikge1xuICAgICAgY29uc3QgdHJhbnMgPSBfdXRpbC5VdGlsLnRyYW5zZm9ybShjdXJyZW50VHJhbnNmb3JtLCBbc2NhbGVYLCBza2V3WCwgc2tld1ksIHNjYWxlWSwgcG9zaXRpb25zW2ldLCBwb3NpdGlvbnNbaSArIDFdXSk7XG4gICAgICBjb25zdCBbeCwgeV0gPSBfdXRpbC5VdGlsLmFwcGx5VHJhbnNmb3JtKFswLCAwXSwgdHJhbnMpO1xuICAgICAgY3R4LmRyYXdJbWFnZShtYXNrLmNhbnZhcywgeCwgeSk7XG4gICAgfVxuICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgdGhpcy5jb21wb3NlKCk7XG4gIH1cbiAgcGFpbnRJbWFnZU1hc2tYT2JqZWN0R3JvdXAoaW1hZ2VzKSB7XG4gICAgaWYgKCF0aGlzLmNvbnRlbnRWaXNpYmxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgIGNvbnN0IGZpbGxDb2xvciA9IHRoaXMuY3VycmVudC5maWxsQ29sb3I7XG4gICAgY29uc3QgaXNQYXR0ZXJuRmlsbCA9IHRoaXMuY3VycmVudC5wYXR0ZXJuRmlsbDtcbiAgICBmb3IgKGNvbnN0IGltYWdlIG9mIGltYWdlcykge1xuICAgICAgY29uc3Qge1xuICAgICAgICBkYXRhLFxuICAgICAgICB3aWR0aCxcbiAgICAgICAgaGVpZ2h0LFxuICAgICAgICB0cmFuc2Zvcm1cbiAgICAgIH0gPSBpbWFnZTtcbiAgICAgIGNvbnN0IG1hc2tDYW52YXMgPSB0aGlzLmNhY2hlZENhbnZhc2VzLmdldENhbnZhcyhcIm1hc2tDYW52YXNcIiwgd2lkdGgsIGhlaWdodCk7XG4gICAgICBjb25zdCBtYXNrQ3R4ID0gbWFza0NhbnZhcy5jb250ZXh0O1xuICAgICAgbWFza0N0eC5zYXZlKCk7XG4gICAgICBjb25zdCBpbWcgPSB0aGlzLmdldE9iamVjdChkYXRhLCBpbWFnZSk7XG4gICAgICBwdXRCaW5hcnlJbWFnZU1hc2sobWFza0N0eCwgaW1nKTtcbiAgICAgIG1hc2tDdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gXCJzb3VyY2UtaW5cIjtcbiAgICAgIG1hc2tDdHguZmlsbFN0eWxlID0gaXNQYXR0ZXJuRmlsbCA/IGZpbGxDb2xvci5nZXRQYXR0ZXJuKG1hc2tDdHgsIHRoaXMsICgwLCBfZGlzcGxheV91dGlscy5nZXRDdXJyZW50VHJhbnNmb3JtSW52ZXJzZSkoY3R4KSwgX3BhdHRlcm5faGVscGVyLlBhdGhUeXBlLkZJTEwpIDogZmlsbENvbG9yO1xuICAgICAgbWFza0N0eC5maWxsUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIG1hc2tDdHgucmVzdG9yZSgpO1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGN0eC50cmFuc2Zvcm0oLi4udHJhbnNmb3JtKTtcbiAgICAgIGN0eC5zY2FsZSgxLCAtMSk7XG4gICAgICBkcmF3SW1hZ2VBdEludGVnZXJDb29yZHMoY3R4LCBtYXNrQ2FudmFzLmNhbnZhcywgMCwgMCwgd2lkdGgsIGhlaWdodCwgMCwgLTEsIDEsIDEpO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9XG4gICAgdGhpcy5jb21wb3NlKCk7XG4gIH1cbiAgcGFpbnRJbWFnZVhPYmplY3Qob2JqSWQpIHtcbiAgICBpZiAoIXRoaXMuY29udGVudFZpc2libGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaW1nRGF0YSA9IHRoaXMuZ2V0T2JqZWN0KG9iaklkKTtcbiAgICBpZiAoIWltZ0RhdGEpIHtcbiAgICAgICgwLCBfdXRpbC53YXJuKShcIkRlcGVuZGVudCBpbWFnZSBpc24ndCByZWFkeSB5ZXRcIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMucGFpbnRJbmxpbmVJbWFnZVhPYmplY3QoaW1nRGF0YSk7XG4gIH1cbiAgcGFpbnRJbWFnZVhPYmplY3RSZXBlYXQob2JqSWQsIHNjYWxlWCwgc2NhbGVZLCBwb3NpdGlvbnMpIHtcbiAgICBpZiAoIXRoaXMuY29udGVudFZpc2libGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaW1nRGF0YSA9IHRoaXMuZ2V0T2JqZWN0KG9iaklkKTtcbiAgICBpZiAoIWltZ0RhdGEpIHtcbiAgICAgICgwLCBfdXRpbC53YXJuKShcIkRlcGVuZGVudCBpbWFnZSBpc24ndCByZWFkeSB5ZXRcIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHdpZHRoID0gaW1nRGF0YS53aWR0aDtcbiAgICBjb25zdCBoZWlnaHQgPSBpbWdEYXRhLmhlaWdodDtcbiAgICBjb25zdCBtYXAgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBwb3NpdGlvbnMubGVuZ3RoOyBpIDwgaWk7IGkgKz0gMikge1xuICAgICAgbWFwLnB1c2goe1xuICAgICAgICB0cmFuc2Zvcm06IFtzY2FsZVgsIDAsIDAsIHNjYWxlWSwgcG9zaXRpb25zW2ldLCBwb3NpdGlvbnNbaSArIDFdXSxcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogMCxcbiAgICAgICAgdzogd2lkdGgsXG4gICAgICAgIGg6IGhlaWdodFxuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMucGFpbnRJbmxpbmVJbWFnZVhPYmplY3RHcm91cChpbWdEYXRhLCBtYXApO1xuICB9XG4gIGFwcGx5VHJhbnNmZXJNYXBzVG9DYW52YXMoY3R4KSB7XG4gICAgaWYgKHRoaXMuY3VycmVudC50cmFuc2Zlck1hcHMgIT09IFwibm9uZVwiKSB7XG4gICAgICBjdHguZmlsdGVyID0gdGhpcy5jdXJyZW50LnRyYW5zZmVyTWFwcztcbiAgICAgIGN0eC5kcmF3SW1hZ2UoY3R4LmNhbnZhcywgMCwgMCk7XG4gICAgICBjdHguZmlsdGVyID0gXCJub25lXCI7XG4gICAgfVxuICAgIHJldHVybiBjdHguY2FudmFzO1xuICB9XG4gIGFwcGx5VHJhbnNmZXJNYXBzVG9CaXRtYXAoaW1nRGF0YSkge1xuICAgIGlmICh0aGlzLmN1cnJlbnQudHJhbnNmZXJNYXBzID09PSBcIm5vbmVcIikge1xuICAgICAgcmV0dXJuIGltZ0RhdGEuYml0bWFwO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBiaXRtYXAsXG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodFxuICAgIH0gPSBpbWdEYXRhO1xuICAgIGNvbnN0IHRtcENhbnZhcyA9IHRoaXMuY2FjaGVkQ2FudmFzZXMuZ2V0Q2FudmFzKFwiaW5saW5lSW1hZ2VcIiwgd2lkdGgsIGhlaWdodCk7XG4gICAgY29uc3QgdG1wQ3R4ID0gdG1wQ2FudmFzLmNvbnRleHQ7XG4gICAgdG1wQ3R4LmZpbHRlciA9IHRoaXMuY3VycmVudC50cmFuc2Zlck1hcHM7XG4gICAgdG1wQ3R4LmRyYXdJbWFnZShiaXRtYXAsIDAsIDApO1xuICAgIHRtcEN0eC5maWx0ZXIgPSBcIm5vbmVcIjtcbiAgICByZXR1cm4gdG1wQ2FudmFzLmNhbnZhcztcbiAgfVxuICBwYWludElubGluZUltYWdlWE9iamVjdChpbWdEYXRhKSB7XG4gICAgaWYgKCF0aGlzLmNvbnRlbnRWaXNpYmxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHdpZHRoID0gaW1nRGF0YS53aWR0aDtcbiAgICBjb25zdCBoZWlnaHQgPSBpbWdEYXRhLmhlaWdodDtcbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICB0aGlzLnNhdmUoKTtcbiAgICBpZiAoIV91dGlsLmlzTm9kZUpTKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGZpbHRlclxuICAgICAgfSA9IGN0eDtcbiAgICAgIGlmIChmaWx0ZXIgIT09IFwibm9uZVwiICYmIGZpbHRlciAhPT0gXCJcIikge1xuICAgICAgICBjdHguZmlsdGVyID0gXCJub25lXCI7XG4gICAgICB9XG4gICAgfVxuICAgIGN0eC5zY2FsZSgxIC8gd2lkdGgsIC0xIC8gaGVpZ2h0KTtcbiAgICBsZXQgaW1nVG9QYWludDtcbiAgICBpZiAoaW1nRGF0YS5iaXRtYXApIHtcbiAgICAgIGltZ1RvUGFpbnQgPSB0aGlzLmFwcGx5VHJhbnNmZXJNYXBzVG9CaXRtYXAoaW1nRGF0YSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgSFRNTEVsZW1lbnQgPT09IFwiZnVuY3Rpb25cIiAmJiBpbWdEYXRhIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgfHwgIWltZ0RhdGEuZGF0YSkge1xuICAgICAgaW1nVG9QYWludCA9IGltZ0RhdGE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHRtcENhbnZhcyA9IHRoaXMuY2FjaGVkQ2FudmFzZXMuZ2V0Q2FudmFzKFwiaW5saW5lSW1hZ2VcIiwgd2lkdGgsIGhlaWdodCk7XG4gICAgICBjb25zdCB0bXBDdHggPSB0bXBDYW52YXMuY29udGV4dDtcbiAgICAgIHB1dEJpbmFyeUltYWdlRGF0YSh0bXBDdHgsIGltZ0RhdGEpO1xuICAgICAgaW1nVG9QYWludCA9IHRoaXMuYXBwbHlUcmFuc2Zlck1hcHNUb0NhbnZhcyh0bXBDdHgpO1xuICAgIH1cbiAgICBjb25zdCBzY2FsZWQgPSB0aGlzLl9zY2FsZUltYWdlKGltZ1RvUGFpbnQsICgwLCBfZGlzcGxheV91dGlscy5nZXRDdXJyZW50VHJhbnNmb3JtSW52ZXJzZSkoY3R4KSk7XG4gICAgY3R4LmltYWdlU21vb3RoaW5nRW5hYmxlZCA9IGdldEltYWdlU21vb3RoaW5nRW5hYmxlZCgoMCwgX2Rpc3BsYXlfdXRpbHMuZ2V0Q3VycmVudFRyYW5zZm9ybSkoY3R4KSwgaW1nRGF0YS5pbnRlcnBvbGF0ZSk7XG4gICAgZHJhd0ltYWdlQXRJbnRlZ2VyQ29vcmRzKGN0eCwgc2NhbGVkLmltZywgMCwgMCwgc2NhbGVkLnBhaW50V2lkdGgsIHNjYWxlZC5wYWludEhlaWdodCwgMCwgLWhlaWdodCwgd2lkdGgsIGhlaWdodCk7XG4gICAgdGhpcy5jb21wb3NlKCk7XG4gICAgdGhpcy5yZXN0b3JlKCk7XG4gIH1cbiAgcGFpbnRJbmxpbmVJbWFnZVhPYmplY3RHcm91cChpbWdEYXRhLCBtYXApIHtcbiAgICBpZiAoIXRoaXMuY29udGVudFZpc2libGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgbGV0IGltZ1RvUGFpbnQ7XG4gICAgaWYgKGltZ0RhdGEuYml0bWFwKSB7XG4gICAgICBpbWdUb1BhaW50ID0gaW1nRGF0YS5iaXRtYXA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHcgPSBpbWdEYXRhLndpZHRoO1xuICAgICAgY29uc3QgaCA9IGltZ0RhdGEuaGVpZ2h0O1xuICAgICAgY29uc3QgdG1wQ2FudmFzID0gdGhpcy5jYWNoZWRDYW52YXNlcy5nZXRDYW52YXMoXCJpbmxpbmVJbWFnZVwiLCB3LCBoKTtcbiAgICAgIGNvbnN0IHRtcEN0eCA9IHRtcENhbnZhcy5jb250ZXh0O1xuICAgICAgcHV0QmluYXJ5SW1hZ2VEYXRhKHRtcEN0eCwgaW1nRGF0YSk7XG4gICAgICBpbWdUb1BhaW50ID0gdGhpcy5hcHBseVRyYW5zZmVyTWFwc1RvQ2FudmFzKHRtcEN0eCk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgZW50cnkgb2YgbWFwKSB7XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY3R4LnRyYW5zZm9ybSguLi5lbnRyeS50cmFuc2Zvcm0pO1xuICAgICAgY3R4LnNjYWxlKDEsIC0xKTtcbiAgICAgIGRyYXdJbWFnZUF0SW50ZWdlckNvb3JkcyhjdHgsIGltZ1RvUGFpbnQsIGVudHJ5LngsIGVudHJ5LnksIGVudHJ5LncsIGVudHJ5LmgsIDAsIC0xLCAxLCAxKTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfVxuICAgIHRoaXMuY29tcG9zZSgpO1xuICB9XG4gIHBhaW50U29saWRDb2xvckltYWdlTWFzaygpIHtcbiAgICBpZiAoIXRoaXMuY29udGVudFZpc2libGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5jdHguZmlsbFJlY3QoMCwgMCwgMSwgMSk7XG4gICAgdGhpcy5jb21wb3NlKCk7XG4gIH1cbiAgbWFya1BvaW50KHRhZykge31cbiAgbWFya1BvaW50UHJvcHModGFnLCBwcm9wZXJ0aWVzKSB7fVxuICBiZWdpbk1hcmtlZENvbnRlbnQodGFnKSB7XG4gICAgdGhpcy5tYXJrZWRDb250ZW50U3RhY2sucHVzaCh7XG4gICAgICB2aXNpYmxlOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgYmVnaW5NYXJrZWRDb250ZW50UHJvcHModGFnLCBwcm9wZXJ0aWVzKSB7XG4gICAgaWYgKHRhZyA9PT0gXCJPQ1wiKSB7XG4gICAgICB0aGlzLm1hcmtlZENvbnRlbnRTdGFjay5wdXNoKHtcbiAgICAgICAgdmlzaWJsZTogdGhpcy5vcHRpb25hbENvbnRlbnRDb25maWcuaXNWaXNpYmxlKHByb3BlcnRpZXMpXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5tYXJrZWRDb250ZW50U3RhY2sucHVzaCh7XG4gICAgICAgIHZpc2libGU6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLmNvbnRlbnRWaXNpYmxlID0gdGhpcy5pc0NvbnRlbnRWaXNpYmxlKCk7XG4gIH1cbiAgZW5kTWFya2VkQ29udGVudCgpIHtcbiAgICB0aGlzLm1hcmtlZENvbnRlbnRTdGFjay5wb3AoKTtcbiAgICB0aGlzLmNvbnRlbnRWaXNpYmxlID0gdGhpcy5pc0NvbnRlbnRWaXNpYmxlKCk7XG4gIH1cbiAgYmVnaW5Db21wYXQoKSB7fVxuICBlbmRDb21wYXQoKSB7fVxuICBjb25zdW1lUGF0aChjbGlwQm94KSB7XG4gICAgY29uc3QgaXNFbXB0eSA9IHRoaXMuY3VycmVudC5pc0VtcHR5Q2xpcCgpO1xuICAgIGlmICh0aGlzLnBlbmRpbmdDbGlwKSB7XG4gICAgICB0aGlzLmN1cnJlbnQudXBkYXRlQ2xpcEZyb21QYXRoKCk7XG4gICAgfVxuICAgIGlmICghdGhpcy5wZW5kaW5nQ2xpcCkge1xuICAgICAgdGhpcy5jb21wb3NlKGNsaXBCb3gpO1xuICAgIH1cbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICBpZiAodGhpcy5wZW5kaW5nQ2xpcCkge1xuICAgICAgaWYgKCFpc0VtcHR5KSB7XG4gICAgICAgIGlmICh0aGlzLnBlbmRpbmdDbGlwID09PSBFT19DTElQKSB7XG4gICAgICAgICAgY3R4LmNsaXAoXCJldmVub2RkXCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN0eC5jbGlwKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMucGVuZGluZ0NsaXAgPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLmN1cnJlbnQuc3RhcnROZXdQYXRoQW5kQ2xpcEJveCh0aGlzLmN1cnJlbnQuY2xpcEJveCk7XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICB9XG4gIGdldFNpbmdsZVBpeGVsV2lkdGgoKSB7XG4gICAgaWYgKCF0aGlzLl9jYWNoZWRHZXRTaW5nbGVQaXhlbFdpZHRoKSB7XG4gICAgICBjb25zdCBtID0gKDAsIF9kaXNwbGF5X3V0aWxzLmdldEN1cnJlbnRUcmFuc2Zvcm0pKHRoaXMuY3R4KTtcbiAgICAgIGlmIChtWzFdID09PSAwICYmIG1bMl0gPT09IDApIHtcbiAgICAgICAgdGhpcy5fY2FjaGVkR2V0U2luZ2xlUGl4ZWxXaWR0aCA9IDEgLyBNYXRoLm1pbihNYXRoLmFicyhtWzBdKSwgTWF0aC5hYnMobVszXSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgYWJzRGV0ID0gTWF0aC5hYnMobVswXSAqIG1bM10gLSBtWzJdICogbVsxXSk7XG4gICAgICAgIGNvbnN0IG5vcm1YID0gTWF0aC5oeXBvdChtWzBdLCBtWzJdKTtcbiAgICAgICAgY29uc3Qgbm9ybVkgPSBNYXRoLmh5cG90KG1bMV0sIG1bM10pO1xuICAgICAgICB0aGlzLl9jYWNoZWRHZXRTaW5nbGVQaXhlbFdpZHRoID0gTWF0aC5tYXgobm9ybVgsIG5vcm1ZKSAvIGFic0RldDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2NhY2hlZEdldFNpbmdsZVBpeGVsV2lkdGg7XG4gIH1cbiAgZ2V0U2NhbGVGb3JTdHJva2luZygpIHtcbiAgICBpZiAodGhpcy5fY2FjaGVkU2NhbGVGb3JTdHJva2luZ1swXSA9PT0gLTEpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbGluZVdpZHRoXG4gICAgICB9ID0gdGhpcy5jdXJyZW50O1xuICAgICAgY29uc3Qge1xuICAgICAgICBhLFxuICAgICAgICBiLFxuICAgICAgICBjLFxuICAgICAgICBkXG4gICAgICB9ID0gdGhpcy5jdHguZ2V0VHJhbnNmb3JtKCk7XG4gICAgICBsZXQgc2NhbGVYLCBzY2FsZVk7XG4gICAgICBpZiAoYiA9PT0gMCAmJiBjID09PSAwKSB7XG4gICAgICAgIGNvbnN0IG5vcm1YID0gTWF0aC5hYnMoYSk7XG4gICAgICAgIGNvbnN0IG5vcm1ZID0gTWF0aC5hYnMoZCk7XG4gICAgICAgIGlmIChub3JtWCA9PT0gbm9ybVkpIHtcbiAgICAgICAgICBpZiAobGluZVdpZHRoID09PSAwKSB7XG4gICAgICAgICAgICBzY2FsZVggPSBzY2FsZVkgPSAxIC8gbm9ybVg7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHNjYWxlZExpbmVXaWR0aCA9IG5vcm1YICogbGluZVdpZHRoO1xuICAgICAgICAgICAgc2NhbGVYID0gc2NhbGVZID0gc2NhbGVkTGluZVdpZHRoIDwgMSA/IDEgLyBzY2FsZWRMaW5lV2lkdGggOiAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChsaW5lV2lkdGggPT09IDApIHtcbiAgICAgICAgICBzY2FsZVggPSAxIC8gbm9ybVg7XG4gICAgICAgICAgc2NhbGVZID0gMSAvIG5vcm1ZO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IHNjYWxlZFhMaW5lV2lkdGggPSBub3JtWCAqIGxpbmVXaWR0aDtcbiAgICAgICAgICBjb25zdCBzY2FsZWRZTGluZVdpZHRoID0gbm9ybVkgKiBsaW5lV2lkdGg7XG4gICAgICAgICAgc2NhbGVYID0gc2NhbGVkWExpbmVXaWR0aCA8IDEgPyAxIC8gc2NhbGVkWExpbmVXaWR0aCA6IDE7XG4gICAgICAgICAgc2NhbGVZID0gc2NhbGVkWUxpbmVXaWR0aCA8IDEgPyAxIC8gc2NhbGVkWUxpbmVXaWR0aCA6IDE7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGFic0RldCA9IE1hdGguYWJzKGEgKiBkIC0gYiAqIGMpO1xuICAgICAgICBjb25zdCBub3JtWCA9IE1hdGguaHlwb3QoYSwgYik7XG4gICAgICAgIGNvbnN0IG5vcm1ZID0gTWF0aC5oeXBvdChjLCBkKTtcbiAgICAgICAgaWYgKGxpbmVXaWR0aCA9PT0gMCkge1xuICAgICAgICAgIHNjYWxlWCA9IG5vcm1ZIC8gYWJzRGV0O1xuICAgICAgICAgIHNjYWxlWSA9IG5vcm1YIC8gYWJzRGV0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IGJhc2VBcmVhID0gbGluZVdpZHRoICogYWJzRGV0O1xuICAgICAgICAgIHNjYWxlWCA9IG5vcm1ZID4gYmFzZUFyZWEgPyBub3JtWSAvIGJhc2VBcmVhIDogMTtcbiAgICAgICAgICBzY2FsZVkgPSBub3JtWCA+IGJhc2VBcmVhID8gbm9ybVggLyBiYXNlQXJlYSA6IDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuX2NhY2hlZFNjYWxlRm9yU3Ryb2tpbmdbMF0gPSBzY2FsZVg7XG4gICAgICB0aGlzLl9jYWNoZWRTY2FsZUZvclN0cm9raW5nWzFdID0gc2NhbGVZO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fY2FjaGVkU2NhbGVGb3JTdHJva2luZztcbiAgfVxuICByZXNjYWxlQW5kU3Ryb2tlKHNhdmVSZXN0b3JlKSB7XG4gICAgY29uc3Qge1xuICAgICAgY3R4XG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3Qge1xuICAgICAgbGluZVdpZHRoXG4gICAgfSA9IHRoaXMuY3VycmVudDtcbiAgICBjb25zdCBbc2NhbGVYLCBzY2FsZVldID0gdGhpcy5nZXRTY2FsZUZvclN0cm9raW5nKCk7XG4gICAgY3R4LmxpbmVXaWR0aCA9IGxpbmVXaWR0aCB8fCAxO1xuICAgIGlmIChzY2FsZVggPT09IDEgJiYgc2NhbGVZID09PSAxKSB7XG4gICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGRhc2hlcyA9IGN0eC5nZXRMaW5lRGFzaCgpO1xuICAgIGlmIChzYXZlUmVzdG9yZSkge1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICB9XG4gICAgY3R4LnNjYWxlKHNjYWxlWCwgc2NhbGVZKTtcbiAgICBpZiAoZGFzaGVzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IHNjYWxlID0gTWF0aC5tYXgoc2NhbGVYLCBzY2FsZVkpO1xuICAgICAgY3R4LnNldExpbmVEYXNoKGRhc2hlcy5tYXAoeCA9PiB4IC8gc2NhbGUpKTtcbiAgICAgIGN0eC5saW5lRGFzaE9mZnNldCAvPSBzY2FsZTtcbiAgICB9XG4gICAgY3R4LnN0cm9rZSgpO1xuICAgIGlmIChzYXZlUmVzdG9yZSkge1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9XG4gIH1cbiAgaXNDb250ZW50VmlzaWJsZSgpIHtcbiAgICBmb3IgKGxldCBpID0gdGhpcy5tYXJrZWRDb250ZW50U3RhY2subGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGlmICghdGhpcy5tYXJrZWRDb250ZW50U3RhY2tbaV0udmlzaWJsZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5leHBvcnRzLkNhbnZhc0dyYXBoaWNzID0gQ2FudmFzR3JhcGhpY3M7XG5mb3IgKGNvbnN0IG9wIGluIF91dGlsLk9QUykge1xuICBpZiAoQ2FudmFzR3JhcGhpY3MucHJvdG90eXBlW29wXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgQ2FudmFzR3JhcGhpY3MucHJvdG90eXBlW191dGlsLk9QU1tvcF1dID0gQ2FudmFzR3JhcGhpY3MucHJvdG90eXBlW29wXTtcbiAgfVxufVxuXG4vKioqLyB9KSxcbi8qIDEyICovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSA9PiB7XG5cblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5leHBvcnRzLlRpbGluZ1BhdHRlcm4gPSBleHBvcnRzLlBhdGhUeXBlID0gdm9pZCAwO1xuZXhwb3J0cy5nZXRTaGFkaW5nUGF0dGVybiA9IGdldFNoYWRpbmdQYXR0ZXJuO1xudmFyIF91dGlsID0gX193X3BkZmpzX3JlcXVpcmVfXygxKTtcbnZhciBfZGlzcGxheV91dGlscyA9IF9fd19wZGZqc19yZXF1aXJlX18oNik7XG5jb25zdCBQYXRoVHlwZSA9IHtcbiAgRklMTDogXCJGaWxsXCIsXG4gIFNUUk9LRTogXCJTdHJva2VcIixcbiAgU0hBRElORzogXCJTaGFkaW5nXCJcbn07XG5leHBvcnRzLlBhdGhUeXBlID0gUGF0aFR5cGU7XG5mdW5jdGlvbiBhcHBseUJvdW5kaW5nQm94KGN0eCwgYmJveCkge1xuICBpZiAoIWJib3gpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3Qgd2lkdGggPSBiYm94WzJdIC0gYmJveFswXTtcbiAgY29uc3QgaGVpZ2h0ID0gYmJveFszXSAtIGJib3hbMV07XG4gIGNvbnN0IHJlZ2lvbiA9IG5ldyBQYXRoMkQoKTtcbiAgcmVnaW9uLnJlY3QoYmJveFswXSwgYmJveFsxXSwgd2lkdGgsIGhlaWdodCk7XG4gIGN0eC5jbGlwKHJlZ2lvbik7XG59XG5jbGFzcyBCYXNlU2hhZGluZ1BhdHRlcm4ge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBpZiAodGhpcy5jb25zdHJ1Y3RvciA9PT0gQmFzZVNoYWRpbmdQYXR0ZXJuKSB7XG4gICAgICAoMCwgX3V0aWwudW5yZWFjaGFibGUpKFwiQ2Fubm90IGluaXRpYWxpemUgQmFzZVNoYWRpbmdQYXR0ZXJuLlwiKTtcbiAgICB9XG4gIH1cbiAgZ2V0UGF0dGVybigpIHtcbiAgICAoMCwgX3V0aWwudW5yZWFjaGFibGUpKFwiQWJzdHJhY3QgbWV0aG9kIGBnZXRQYXR0ZXJuYCBjYWxsZWQuXCIpO1xuICB9XG59XG5jbGFzcyBSYWRpYWxBeGlhbFNoYWRpbmdQYXR0ZXJuIGV4dGVuZHMgQmFzZVNoYWRpbmdQYXR0ZXJuIHtcbiAgY29uc3RydWN0b3IoSVIpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuX3R5cGUgPSBJUlsxXTtcbiAgICB0aGlzLl9iYm94ID0gSVJbMl07XG4gICAgdGhpcy5fY29sb3JTdG9wcyA9IElSWzNdO1xuICAgIHRoaXMuX3AwID0gSVJbNF07XG4gICAgdGhpcy5fcDEgPSBJUls1XTtcbiAgICB0aGlzLl9yMCA9IElSWzZdO1xuICAgIHRoaXMuX3IxID0gSVJbN107XG4gICAgdGhpcy5tYXRyaXggPSBudWxsO1xuICB9XG4gIF9jcmVhdGVHcmFkaWVudChjdHgpIHtcbiAgICBsZXQgZ3JhZDtcbiAgICBpZiAodGhpcy5fdHlwZSA9PT0gXCJheGlhbFwiKSB7XG4gICAgICBncmFkID0gY3R4LmNyZWF0ZUxpbmVhckdyYWRpZW50KHRoaXMuX3AwWzBdLCB0aGlzLl9wMFsxXSwgdGhpcy5fcDFbMF0sIHRoaXMuX3AxWzFdKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX3R5cGUgPT09IFwicmFkaWFsXCIpIHtcbiAgICAgIGdyYWQgPSBjdHguY3JlYXRlUmFkaWFsR3JhZGllbnQodGhpcy5fcDBbMF0sIHRoaXMuX3AwWzFdLCB0aGlzLl9yMCwgdGhpcy5fcDFbMF0sIHRoaXMuX3AxWzFdLCB0aGlzLl9yMSk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgY29sb3JTdG9wIG9mIHRoaXMuX2NvbG9yU3RvcHMpIHtcbiAgICAgIGdyYWQuYWRkQ29sb3JTdG9wKGNvbG9yU3RvcFswXSwgY29sb3JTdG9wWzFdKTtcbiAgICB9XG4gICAgcmV0dXJuIGdyYWQ7XG4gIH1cbiAgZ2V0UGF0dGVybihjdHgsIG93bmVyLCBpbnZlcnNlLCBwYXRoVHlwZSkge1xuICAgIGxldCBwYXR0ZXJuO1xuICAgIGlmIChwYXRoVHlwZSA9PT0gUGF0aFR5cGUuU1RST0tFIHx8IHBhdGhUeXBlID09PSBQYXRoVHlwZS5GSUxMKSB7XG4gICAgICBjb25zdCBvd25lckJCb3ggPSBvd25lci5jdXJyZW50LmdldENsaXBwZWRQYXRoQm91bmRpbmdCb3gocGF0aFR5cGUsICgwLCBfZGlzcGxheV91dGlscy5nZXRDdXJyZW50VHJhbnNmb3JtKShjdHgpKSB8fCBbMCwgMCwgMCwgMF07XG4gICAgICBjb25zdCB3aWR0aCA9IE1hdGguY2VpbChvd25lckJCb3hbMl0gLSBvd25lckJCb3hbMF0pIHx8IDE7XG4gICAgICBjb25zdCBoZWlnaHQgPSBNYXRoLmNlaWwob3duZXJCQm94WzNdIC0gb3duZXJCQm94WzFdKSB8fCAxO1xuICAgICAgY29uc3QgdG1wQ2FudmFzID0gb3duZXIuY2FjaGVkQ2FudmFzZXMuZ2V0Q2FudmFzKFwicGF0dGVyblwiLCB3aWR0aCwgaGVpZ2h0LCB0cnVlKTtcbiAgICAgIGNvbnN0IHRtcEN0eCA9IHRtcENhbnZhcy5jb250ZXh0O1xuICAgICAgdG1wQ3R4LmNsZWFyUmVjdCgwLCAwLCB0bXBDdHguY2FudmFzLndpZHRoLCB0bXBDdHguY2FudmFzLmhlaWdodCk7XG4gICAgICB0bXBDdHguYmVnaW5QYXRoKCk7XG4gICAgICB0bXBDdHgucmVjdCgwLCAwLCB0bXBDdHguY2FudmFzLndpZHRoLCB0bXBDdHguY2FudmFzLmhlaWdodCk7XG4gICAgICB0bXBDdHgudHJhbnNsYXRlKC1vd25lckJCb3hbMF0sIC1vd25lckJCb3hbMV0pO1xuICAgICAgaW52ZXJzZSA9IF91dGlsLlV0aWwudHJhbnNmb3JtKGludmVyc2UsIFsxLCAwLCAwLCAxLCBvd25lckJCb3hbMF0sIG93bmVyQkJveFsxXV0pO1xuICAgICAgdG1wQ3R4LnRyYW5zZm9ybSguLi5vd25lci5iYXNlVHJhbnNmb3JtKTtcbiAgICAgIGlmICh0aGlzLm1hdHJpeCkge1xuICAgICAgICB0bXBDdHgudHJhbnNmb3JtKC4uLnRoaXMubWF0cml4KTtcbiAgICAgIH1cbiAgICAgIGFwcGx5Qm91bmRpbmdCb3godG1wQ3R4LCB0aGlzLl9iYm94KTtcbiAgICAgIHRtcEN0eC5maWxsU3R5bGUgPSB0aGlzLl9jcmVhdGVHcmFkaWVudCh0bXBDdHgpO1xuICAgICAgdG1wQ3R4LmZpbGwoKTtcbiAgICAgIHBhdHRlcm4gPSBjdHguY3JlYXRlUGF0dGVybih0bXBDYW52YXMuY2FudmFzLCBcIm5vLXJlcGVhdFwiKTtcbiAgICAgIGNvbnN0IGRvbU1hdHJpeCA9IG5ldyBET01NYXRyaXgoaW52ZXJzZSk7XG4gICAgICBwYXR0ZXJuLnNldFRyYW5zZm9ybShkb21NYXRyaXgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhcHBseUJvdW5kaW5nQm94KGN0eCwgdGhpcy5fYmJveCk7XG4gICAgICBwYXR0ZXJuID0gdGhpcy5fY3JlYXRlR3JhZGllbnQoY3R4KTtcbiAgICB9XG4gICAgcmV0dXJuIHBhdHRlcm47XG4gIH1cbn1cbmZ1bmN0aW9uIGRyYXdUcmlhbmdsZShkYXRhLCBjb250ZXh0LCBwMSwgcDIsIHAzLCBjMSwgYzIsIGMzKSB7XG4gIGNvbnN0IGNvb3JkcyA9IGNvbnRleHQuY29vcmRzLFxuICAgIGNvbG9ycyA9IGNvbnRleHQuY29sb3JzO1xuICBjb25zdCBieXRlcyA9IGRhdGEuZGF0YSxcbiAgICByb3dTaXplID0gZGF0YS53aWR0aCAqIDQ7XG4gIGxldCB0bXA7XG4gIGlmIChjb29yZHNbcDEgKyAxXSA+IGNvb3Jkc1twMiArIDFdKSB7XG4gICAgdG1wID0gcDE7XG4gICAgcDEgPSBwMjtcbiAgICBwMiA9IHRtcDtcbiAgICB0bXAgPSBjMTtcbiAgICBjMSA9IGMyO1xuICAgIGMyID0gdG1wO1xuICB9XG4gIGlmIChjb29yZHNbcDIgKyAxXSA+IGNvb3Jkc1twMyArIDFdKSB7XG4gICAgdG1wID0gcDI7XG4gICAgcDIgPSBwMztcbiAgICBwMyA9IHRtcDtcbiAgICB0bXAgPSBjMjtcbiAgICBjMiA9IGMzO1xuICAgIGMzID0gdG1wO1xuICB9XG4gIGlmIChjb29yZHNbcDEgKyAxXSA+IGNvb3Jkc1twMiArIDFdKSB7XG4gICAgdG1wID0gcDE7XG4gICAgcDEgPSBwMjtcbiAgICBwMiA9IHRtcDtcbiAgICB0bXAgPSBjMTtcbiAgICBjMSA9IGMyO1xuICAgIGMyID0gdG1wO1xuICB9XG4gIGNvbnN0IHgxID0gKGNvb3Jkc1twMV0gKyBjb250ZXh0Lm9mZnNldFgpICogY29udGV4dC5zY2FsZVg7XG4gIGNvbnN0IHkxID0gKGNvb3Jkc1twMSArIDFdICsgY29udGV4dC5vZmZzZXRZKSAqIGNvbnRleHQuc2NhbGVZO1xuICBjb25zdCB4MiA9IChjb29yZHNbcDJdICsgY29udGV4dC5vZmZzZXRYKSAqIGNvbnRleHQuc2NhbGVYO1xuICBjb25zdCB5MiA9IChjb29yZHNbcDIgKyAxXSArIGNvbnRleHQub2Zmc2V0WSkgKiBjb250ZXh0LnNjYWxlWTtcbiAgY29uc3QgeDMgPSAoY29vcmRzW3AzXSArIGNvbnRleHQub2Zmc2V0WCkgKiBjb250ZXh0LnNjYWxlWDtcbiAgY29uc3QgeTMgPSAoY29vcmRzW3AzICsgMV0gKyBjb250ZXh0Lm9mZnNldFkpICogY29udGV4dC5zY2FsZVk7XG4gIGlmICh5MSA+PSB5Mykge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBjMXIgPSBjb2xvcnNbYzFdLFxuICAgIGMxZyA9IGNvbG9yc1tjMSArIDFdLFxuICAgIGMxYiA9IGNvbG9yc1tjMSArIDJdO1xuICBjb25zdCBjMnIgPSBjb2xvcnNbYzJdLFxuICAgIGMyZyA9IGNvbG9yc1tjMiArIDFdLFxuICAgIGMyYiA9IGNvbG9yc1tjMiArIDJdO1xuICBjb25zdCBjM3IgPSBjb2xvcnNbYzNdLFxuICAgIGMzZyA9IGNvbG9yc1tjMyArIDFdLFxuICAgIGMzYiA9IGNvbG9yc1tjMyArIDJdO1xuICBjb25zdCBtaW5ZID0gTWF0aC5yb3VuZCh5MSksXG4gICAgbWF4WSA9IE1hdGgucm91bmQoeTMpO1xuICBsZXQgeGEsIGNhciwgY2FnLCBjYWI7XG4gIGxldCB4YiwgY2JyLCBjYmcsIGNiYjtcbiAgZm9yIChsZXQgeSA9IG1pblk7IHkgPD0gbWF4WTsgeSsrKSB7XG4gICAgaWYgKHkgPCB5Mikge1xuICAgICAgY29uc3QgayA9IHkgPCB5MSA/IDAgOiAoeTEgLSB5KSAvICh5MSAtIHkyKTtcbiAgICAgIHhhID0geDEgLSAoeDEgLSB4MikgKiBrO1xuICAgICAgY2FyID0gYzFyIC0gKGMxciAtIGMycikgKiBrO1xuICAgICAgY2FnID0gYzFnIC0gKGMxZyAtIGMyZykgKiBrO1xuICAgICAgY2FiID0gYzFiIC0gKGMxYiAtIGMyYikgKiBrO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgaztcbiAgICAgIGlmICh5ID4geTMpIHtcbiAgICAgICAgayA9IDE7XG4gICAgICB9IGVsc2UgaWYgKHkyID09PSB5Mykge1xuICAgICAgICBrID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGsgPSAoeTIgLSB5KSAvICh5MiAtIHkzKTtcbiAgICAgIH1cbiAgICAgIHhhID0geDIgLSAoeDIgLSB4MykgKiBrO1xuICAgICAgY2FyID0gYzJyIC0gKGMyciAtIGMzcikgKiBrO1xuICAgICAgY2FnID0gYzJnIC0gKGMyZyAtIGMzZykgKiBrO1xuICAgICAgY2FiID0gYzJiIC0gKGMyYiAtIGMzYikgKiBrO1xuICAgIH1cbiAgICBsZXQgaztcbiAgICBpZiAoeSA8IHkxKSB7XG4gICAgICBrID0gMDtcbiAgICB9IGVsc2UgaWYgKHkgPiB5Mykge1xuICAgICAgayA9IDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGsgPSAoeTEgLSB5KSAvICh5MSAtIHkzKTtcbiAgICB9XG4gICAgeGIgPSB4MSAtICh4MSAtIHgzKSAqIGs7XG4gICAgY2JyID0gYzFyIC0gKGMxciAtIGMzcikgKiBrO1xuICAgIGNiZyA9IGMxZyAtIChjMWcgLSBjM2cpICogaztcbiAgICBjYmIgPSBjMWIgLSAoYzFiIC0gYzNiKSAqIGs7XG4gICAgY29uc3QgeDFfID0gTWF0aC5yb3VuZChNYXRoLm1pbih4YSwgeGIpKTtcbiAgICBjb25zdCB4Ml8gPSBNYXRoLnJvdW5kKE1hdGgubWF4KHhhLCB4YikpO1xuICAgIGxldCBqID0gcm93U2l6ZSAqIHkgKyB4MV8gKiA0O1xuICAgIGZvciAobGV0IHggPSB4MV87IHggPD0geDJfOyB4KyspIHtcbiAgICAgIGsgPSAoeGEgLSB4KSAvICh4YSAtIHhiKTtcbiAgICAgIGlmIChrIDwgMCkge1xuICAgICAgICBrID0gMDtcbiAgICAgIH0gZWxzZSBpZiAoayA+IDEpIHtcbiAgICAgICAgayA9IDE7XG4gICAgICB9XG4gICAgICBieXRlc1tqKytdID0gY2FyIC0gKGNhciAtIGNicikgKiBrIHwgMDtcbiAgICAgIGJ5dGVzW2orK10gPSBjYWcgLSAoY2FnIC0gY2JnKSAqIGsgfCAwO1xuICAgICAgYnl0ZXNbaisrXSA9IGNhYiAtIChjYWIgLSBjYmIpICogayB8IDA7XG4gICAgICBieXRlc1tqKytdID0gMjU1O1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZHJhd0ZpZ3VyZShkYXRhLCBmaWd1cmUsIGNvbnRleHQpIHtcbiAgY29uc3QgcHMgPSBmaWd1cmUuY29vcmRzO1xuICBjb25zdCBjcyA9IGZpZ3VyZS5jb2xvcnM7XG4gIGxldCBpLCBpaTtcbiAgc3dpdGNoIChmaWd1cmUudHlwZSkge1xuICAgIGNhc2UgXCJsYXR0aWNlXCI6XG4gICAgICBjb25zdCB2ZXJ0aWNlc1BlclJvdyA9IGZpZ3VyZS52ZXJ0aWNlc1BlclJvdztcbiAgICAgIGNvbnN0IHJvd3MgPSBNYXRoLmZsb29yKHBzLmxlbmd0aCAvIHZlcnRpY2VzUGVyUm93KSAtIDE7XG4gICAgICBjb25zdCBjb2xzID0gdmVydGljZXNQZXJSb3cgLSAxO1xuICAgICAgZm9yIChpID0gMDsgaSA8IHJvd3M7IGkrKykge1xuICAgICAgICBsZXQgcSA9IGkgKiB2ZXJ0aWNlc1BlclJvdztcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBjb2xzOyBqKyssIHErKykge1xuICAgICAgICAgIGRyYXdUcmlhbmdsZShkYXRhLCBjb250ZXh0LCBwc1txXSwgcHNbcSArIDFdLCBwc1txICsgdmVydGljZXNQZXJSb3ddLCBjc1txXSwgY3NbcSArIDFdLCBjc1txICsgdmVydGljZXNQZXJSb3ddKTtcbiAgICAgICAgICBkcmF3VHJpYW5nbGUoZGF0YSwgY29udGV4dCwgcHNbcSArIHZlcnRpY2VzUGVyUm93ICsgMV0sIHBzW3EgKyAxXSwgcHNbcSArIHZlcnRpY2VzUGVyUm93XSwgY3NbcSArIHZlcnRpY2VzUGVyUm93ICsgMV0sIGNzW3EgKyAxXSwgY3NbcSArIHZlcnRpY2VzUGVyUm93XSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJ0cmlhbmdsZXNcIjpcbiAgICAgIGZvciAoaSA9IDAsIGlpID0gcHMubGVuZ3RoOyBpIDwgaWk7IGkgKz0gMykge1xuICAgICAgICBkcmF3VHJpYW5nbGUoZGF0YSwgY29udGV4dCwgcHNbaV0sIHBzW2kgKyAxXSwgcHNbaSArIDJdLCBjc1tpXSwgY3NbaSArIDFdLCBjc1tpICsgMl0pO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImlsbGVnYWwgZmlndXJlXCIpO1xuICB9XG59XG5jbGFzcyBNZXNoU2hhZGluZ1BhdHRlcm4gZXh0ZW5kcyBCYXNlU2hhZGluZ1BhdHRlcm4ge1xuICBjb25zdHJ1Y3RvcihJUikge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5fY29vcmRzID0gSVJbMl07XG4gICAgdGhpcy5fY29sb3JzID0gSVJbM107XG4gICAgdGhpcy5fZmlndXJlcyA9IElSWzRdO1xuICAgIHRoaXMuX2JvdW5kcyA9IElSWzVdO1xuICAgIHRoaXMuX2Jib3ggPSBJUls3XTtcbiAgICB0aGlzLl9iYWNrZ3JvdW5kID0gSVJbOF07XG4gICAgdGhpcy5tYXRyaXggPSBudWxsO1xuICB9XG4gIF9jcmVhdGVNZXNoQ2FudmFzKGNvbWJpbmVkU2NhbGUsIGJhY2tncm91bmRDb2xvciwgY2FjaGVkQ2FudmFzZXMpIHtcbiAgICBjb25zdCBFWFBFQ1RFRF9TQ0FMRSA9IDEuMTtcbiAgICBjb25zdCBNQVhfUEFUVEVSTl9TSVpFID0gMzAwMDtcbiAgICBjb25zdCBCT1JERVJfU0laRSA9IDI7XG4gICAgY29uc3Qgb2Zmc2V0WCA9IE1hdGguZmxvb3IodGhpcy5fYm91bmRzWzBdKTtcbiAgICBjb25zdCBvZmZzZXRZID0gTWF0aC5mbG9vcih0aGlzLl9ib3VuZHNbMV0pO1xuICAgIGNvbnN0IGJvdW5kc1dpZHRoID0gTWF0aC5jZWlsKHRoaXMuX2JvdW5kc1syXSkgLSBvZmZzZXRYO1xuICAgIGNvbnN0IGJvdW5kc0hlaWdodCA9IE1hdGguY2VpbCh0aGlzLl9ib3VuZHNbM10pIC0gb2Zmc2V0WTtcbiAgICBjb25zdCB3aWR0aCA9IE1hdGgubWluKE1hdGguY2VpbChNYXRoLmFicyhib3VuZHNXaWR0aCAqIGNvbWJpbmVkU2NhbGVbMF0gKiBFWFBFQ1RFRF9TQ0FMRSkpLCBNQVhfUEFUVEVSTl9TSVpFKTtcbiAgICBjb25zdCBoZWlnaHQgPSBNYXRoLm1pbihNYXRoLmNlaWwoTWF0aC5hYnMoYm91bmRzSGVpZ2h0ICogY29tYmluZWRTY2FsZVsxXSAqIEVYUEVDVEVEX1NDQUxFKSksIE1BWF9QQVRURVJOX1NJWkUpO1xuICAgIGNvbnN0IHNjYWxlWCA9IGJvdW5kc1dpZHRoIC8gd2lkdGg7XG4gICAgY29uc3Qgc2NhbGVZID0gYm91bmRzSGVpZ2h0IC8gaGVpZ2h0O1xuICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICBjb29yZHM6IHRoaXMuX2Nvb3JkcyxcbiAgICAgIGNvbG9yczogdGhpcy5fY29sb3JzLFxuICAgICAgb2Zmc2V0WDogLW9mZnNldFgsXG4gICAgICBvZmZzZXRZOiAtb2Zmc2V0WSxcbiAgICAgIHNjYWxlWDogMSAvIHNjYWxlWCxcbiAgICAgIHNjYWxlWTogMSAvIHNjYWxlWVxuICAgIH07XG4gICAgY29uc3QgcGFkZGVkV2lkdGggPSB3aWR0aCArIEJPUkRFUl9TSVpFICogMjtcbiAgICBjb25zdCBwYWRkZWRIZWlnaHQgPSBoZWlnaHQgKyBCT1JERVJfU0laRSAqIDI7XG4gICAgY29uc3QgdG1wQ2FudmFzID0gY2FjaGVkQ2FudmFzZXMuZ2V0Q2FudmFzKFwibWVzaFwiLCBwYWRkZWRXaWR0aCwgcGFkZGVkSGVpZ2h0LCBmYWxzZSk7XG4gICAgY29uc3QgdG1wQ3R4ID0gdG1wQ2FudmFzLmNvbnRleHQ7XG4gICAgY29uc3QgZGF0YSA9IHRtcEN0eC5jcmVhdGVJbWFnZURhdGEod2lkdGgsIGhlaWdodCk7XG4gICAgaWYgKGJhY2tncm91bmRDb2xvcikge1xuICAgICAgY29uc3QgYnl0ZXMgPSBkYXRhLmRhdGE7XG4gICAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBieXRlcy5sZW5ndGg7IGkgPCBpaTsgaSArPSA0KSB7XG4gICAgICAgIGJ5dGVzW2ldID0gYmFja2dyb3VuZENvbG9yWzBdO1xuICAgICAgICBieXRlc1tpICsgMV0gPSBiYWNrZ3JvdW5kQ29sb3JbMV07XG4gICAgICAgIGJ5dGVzW2kgKyAyXSA9IGJhY2tncm91bmRDb2xvclsyXTtcbiAgICAgICAgYnl0ZXNbaSArIDNdID0gMjU1O1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IGZpZ3VyZSBvZiB0aGlzLl9maWd1cmVzKSB7XG4gICAgICBkcmF3RmlndXJlKGRhdGEsIGZpZ3VyZSwgY29udGV4dCk7XG4gICAgfVxuICAgIHRtcEN0eC5wdXRJbWFnZURhdGEoZGF0YSwgQk9SREVSX1NJWkUsIEJPUkRFUl9TSVpFKTtcbiAgICBjb25zdCBjYW52YXMgPSB0bXBDYW52YXMuY2FudmFzO1xuICAgIHJldHVybiB7XG4gICAgICBjYW52YXMsXG4gICAgICBvZmZzZXRYOiBvZmZzZXRYIC0gQk9SREVSX1NJWkUgKiBzY2FsZVgsXG4gICAgICBvZmZzZXRZOiBvZmZzZXRZIC0gQk9SREVSX1NJWkUgKiBzY2FsZVksXG4gICAgICBzY2FsZVgsXG4gICAgICBzY2FsZVlcbiAgICB9O1xuICB9XG4gIGdldFBhdHRlcm4oY3R4LCBvd25lciwgaW52ZXJzZSwgcGF0aFR5cGUpIHtcbiAgICBhcHBseUJvdW5kaW5nQm94KGN0eCwgdGhpcy5fYmJveCk7XG4gICAgbGV0IHNjYWxlO1xuICAgIGlmIChwYXRoVHlwZSA9PT0gUGF0aFR5cGUuU0hBRElORykge1xuICAgICAgc2NhbGUgPSBfdXRpbC5VdGlsLnNpbmd1bGFyVmFsdWVEZWNvbXBvc2UyZFNjYWxlKCgwLCBfZGlzcGxheV91dGlscy5nZXRDdXJyZW50VHJhbnNmb3JtKShjdHgpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2NhbGUgPSBfdXRpbC5VdGlsLnNpbmd1bGFyVmFsdWVEZWNvbXBvc2UyZFNjYWxlKG93bmVyLmJhc2VUcmFuc2Zvcm0pO1xuICAgICAgaWYgKHRoaXMubWF0cml4KSB7XG4gICAgICAgIGNvbnN0IG1hdHJpeFNjYWxlID0gX3V0aWwuVXRpbC5zaW5ndWxhclZhbHVlRGVjb21wb3NlMmRTY2FsZSh0aGlzLm1hdHJpeCk7XG4gICAgICAgIHNjYWxlID0gW3NjYWxlWzBdICogbWF0cml4U2NhbGVbMF0sIHNjYWxlWzFdICogbWF0cml4U2NhbGVbMV1dO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB0ZW1wb3JhcnlQYXR0ZXJuQ2FudmFzID0gdGhpcy5fY3JlYXRlTWVzaENhbnZhcyhzY2FsZSwgcGF0aFR5cGUgPT09IFBhdGhUeXBlLlNIQURJTkcgPyBudWxsIDogdGhpcy5fYmFja2dyb3VuZCwgb3duZXIuY2FjaGVkQ2FudmFzZXMpO1xuICAgIGlmIChwYXRoVHlwZSAhPT0gUGF0aFR5cGUuU0hBRElORykge1xuICAgICAgY3R4LnNldFRyYW5zZm9ybSguLi5vd25lci5iYXNlVHJhbnNmb3JtKTtcbiAgICAgIGlmICh0aGlzLm1hdHJpeCkge1xuICAgICAgICBjdHgudHJhbnNmb3JtKC4uLnRoaXMubWF0cml4KTtcbiAgICAgIH1cbiAgICB9XG4gICAgY3R4LnRyYW5zbGF0ZSh0ZW1wb3JhcnlQYXR0ZXJuQ2FudmFzLm9mZnNldFgsIHRlbXBvcmFyeVBhdHRlcm5DYW52YXMub2Zmc2V0WSk7XG4gICAgY3R4LnNjYWxlKHRlbXBvcmFyeVBhdHRlcm5DYW52YXMuc2NhbGVYLCB0ZW1wb3JhcnlQYXR0ZXJuQ2FudmFzLnNjYWxlWSk7XG4gICAgcmV0dXJuIGN0eC5jcmVhdGVQYXR0ZXJuKHRlbXBvcmFyeVBhdHRlcm5DYW52YXMuY2FudmFzLCBcIm5vLXJlcGVhdFwiKTtcbiAgfVxufVxuY2xhc3MgRHVtbXlTaGFkaW5nUGF0dGVybiBleHRlbmRzIEJhc2VTaGFkaW5nUGF0dGVybiB7XG4gIGdldFBhdHRlcm4oKSB7XG4gICAgcmV0dXJuIFwiaG90cGlua1wiO1xuICB9XG59XG5mdW5jdGlvbiBnZXRTaGFkaW5nUGF0dGVybihJUikge1xuICBzd2l0Y2ggKElSWzBdKSB7XG4gICAgY2FzZSBcIlJhZGlhbEF4aWFsXCI6XG4gICAgICByZXR1cm4gbmV3IFJhZGlhbEF4aWFsU2hhZGluZ1BhdHRlcm4oSVIpO1xuICAgIGNhc2UgXCJNZXNoXCI6XG4gICAgICByZXR1cm4gbmV3IE1lc2hTaGFkaW5nUGF0dGVybihJUik7XG4gICAgY2FzZSBcIkR1bW15XCI6XG4gICAgICByZXR1cm4gbmV3IER1bW15U2hhZGluZ1BhdHRlcm4oKTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gSVIgdHlwZTogJHtJUlswXX1gKTtcbn1cbmNvbnN0IFBhaW50VHlwZSA9IHtcbiAgQ09MT1JFRDogMSxcbiAgVU5DT0xPUkVEOiAyXG59O1xuY2xhc3MgVGlsaW5nUGF0dGVybiB7XG4gIHN0YXRpYyBNQVhfUEFUVEVSTl9TSVpFID0gMzAwMDtcbiAgY29uc3RydWN0b3IoSVIsIGNvbG9yLCBjdHgsIGNhbnZhc0dyYXBoaWNzRmFjdG9yeSwgYmFzZVRyYW5zZm9ybSkge1xuICAgIHRoaXMub3BlcmF0b3JMaXN0ID0gSVJbMl07XG4gICAgdGhpcy5tYXRyaXggPSBJUlszXSB8fCBbMSwgMCwgMCwgMSwgMCwgMF07XG4gICAgdGhpcy5iYm94ID0gSVJbNF07XG4gICAgdGhpcy54c3RlcCA9IElSWzVdO1xuICAgIHRoaXMueXN0ZXAgPSBJUls2XTtcbiAgICB0aGlzLnBhaW50VHlwZSA9IElSWzddO1xuICAgIHRoaXMudGlsaW5nVHlwZSA9IElSWzhdO1xuICAgIHRoaXMuY29sb3IgPSBjb2xvcjtcbiAgICB0aGlzLmN0eCA9IGN0eDtcbiAgICB0aGlzLmNhbnZhc0dyYXBoaWNzRmFjdG9yeSA9IGNhbnZhc0dyYXBoaWNzRmFjdG9yeTtcbiAgICB0aGlzLmJhc2VUcmFuc2Zvcm0gPSBiYXNlVHJhbnNmb3JtO1xuICB9XG4gIGNyZWF0ZVBhdHRlcm5DYW52YXMob3duZXIpIHtcbiAgICBjb25zdCBvcGVyYXRvckxpc3QgPSB0aGlzLm9wZXJhdG9yTGlzdDtcbiAgICBjb25zdCBiYm94ID0gdGhpcy5iYm94O1xuICAgIGNvbnN0IHhzdGVwID0gdGhpcy54c3RlcDtcbiAgICBjb25zdCB5c3RlcCA9IHRoaXMueXN0ZXA7XG4gICAgY29uc3QgcGFpbnRUeXBlID0gdGhpcy5wYWludFR5cGU7XG4gICAgY29uc3QgdGlsaW5nVHlwZSA9IHRoaXMudGlsaW5nVHlwZTtcbiAgICBjb25zdCBjb2xvciA9IHRoaXMuY29sb3I7XG4gICAgY29uc3QgY2FudmFzR3JhcGhpY3NGYWN0b3J5ID0gdGhpcy5jYW52YXNHcmFwaGljc0ZhY3Rvcnk7XG4gICAgKDAsIF91dGlsLmluZm8pKFwiVGlsaW5nVHlwZTogXCIgKyB0aWxpbmdUeXBlKTtcbiAgICBjb25zdCB4MCA9IGJib3hbMF0sXG4gICAgICB5MCA9IGJib3hbMV0sXG4gICAgICB4MSA9IGJib3hbMl0sXG4gICAgICB5MSA9IGJib3hbM107XG4gICAgY29uc3QgbWF0cml4U2NhbGUgPSBfdXRpbC5VdGlsLnNpbmd1bGFyVmFsdWVEZWNvbXBvc2UyZFNjYWxlKHRoaXMubWF0cml4KTtcbiAgICBjb25zdCBjdXJNYXRyaXhTY2FsZSA9IF91dGlsLlV0aWwuc2luZ3VsYXJWYWx1ZURlY29tcG9zZTJkU2NhbGUodGhpcy5iYXNlVHJhbnNmb3JtKTtcbiAgICBjb25zdCBjb21iaW5lZFNjYWxlID0gW21hdHJpeFNjYWxlWzBdICogY3VyTWF0cml4U2NhbGVbMF0sIG1hdHJpeFNjYWxlWzFdICogY3VyTWF0cml4U2NhbGVbMV1dO1xuICAgIGNvbnN0IGRpbXggPSB0aGlzLmdldFNpemVBbmRTY2FsZSh4c3RlcCwgdGhpcy5jdHguY2FudmFzLndpZHRoLCBjb21iaW5lZFNjYWxlWzBdKTtcbiAgICBjb25zdCBkaW15ID0gdGhpcy5nZXRTaXplQW5kU2NhbGUoeXN0ZXAsIHRoaXMuY3R4LmNhbnZhcy5oZWlnaHQsIGNvbWJpbmVkU2NhbGVbMV0pO1xuICAgIGNvbnN0IHRtcENhbnZhcyA9IG93bmVyLmNhY2hlZENhbnZhc2VzLmdldENhbnZhcyhcInBhdHRlcm5cIiwgZGlteC5zaXplLCBkaW15LnNpemUsIHRydWUpO1xuICAgIGNvbnN0IHRtcEN0eCA9IHRtcENhbnZhcy5jb250ZXh0O1xuICAgIGNvbnN0IGdyYXBoaWNzID0gY2FudmFzR3JhcGhpY3NGYWN0b3J5LmNyZWF0ZUNhbnZhc0dyYXBoaWNzKHRtcEN0eCk7XG4gICAgZ3JhcGhpY3MuZ3JvdXBMZXZlbCA9IG93bmVyLmdyb3VwTGV2ZWw7XG4gICAgdGhpcy5zZXRGaWxsQW5kU3Ryb2tlU3R5bGVUb0NvbnRleHQoZ3JhcGhpY3MsIHBhaW50VHlwZSwgY29sb3IpO1xuICAgIGxldCBhZGp1c3RlZFgwID0geDA7XG4gICAgbGV0IGFkanVzdGVkWTAgPSB5MDtcbiAgICBsZXQgYWRqdXN0ZWRYMSA9IHgxO1xuICAgIGxldCBhZGp1c3RlZFkxID0geTE7XG4gICAgaWYgKHgwIDwgMCkge1xuICAgICAgYWRqdXN0ZWRYMCA9IDA7XG4gICAgICBhZGp1c3RlZFgxICs9IE1hdGguYWJzKHgwKTtcbiAgICB9XG4gICAgaWYgKHkwIDwgMCkge1xuICAgICAgYWRqdXN0ZWRZMCA9IDA7XG4gICAgICBhZGp1c3RlZFkxICs9IE1hdGguYWJzKHkwKTtcbiAgICB9XG4gICAgdG1wQ3R4LnRyYW5zbGF0ZSgtKGRpbXguc2NhbGUgKiBhZGp1c3RlZFgwKSwgLShkaW15LnNjYWxlICogYWRqdXN0ZWRZMCkpO1xuICAgIGdyYXBoaWNzLnRyYW5zZm9ybShkaW14LnNjYWxlLCAwLCAwLCBkaW15LnNjYWxlLCAwLCAwKTtcbiAgICB0bXBDdHguc2F2ZSgpO1xuICAgIHRoaXMuY2xpcEJib3goZ3JhcGhpY3MsIGFkanVzdGVkWDAsIGFkanVzdGVkWTAsIGFkanVzdGVkWDEsIGFkanVzdGVkWTEpO1xuICAgIGdyYXBoaWNzLmJhc2VUcmFuc2Zvcm0gPSAoMCwgX2Rpc3BsYXlfdXRpbHMuZ2V0Q3VycmVudFRyYW5zZm9ybSkoZ3JhcGhpY3MuY3R4KTtcbiAgICBncmFwaGljcy5leGVjdXRlT3BlcmF0b3JMaXN0KG9wZXJhdG9yTGlzdCk7XG4gICAgZ3JhcGhpY3MuZW5kRHJhd2luZygpO1xuICAgIHJldHVybiB7XG4gICAgICBjYW52YXM6IHRtcENhbnZhcy5jYW52YXMsXG4gICAgICBzY2FsZVg6IGRpbXguc2NhbGUsXG4gICAgICBzY2FsZVk6IGRpbXkuc2NhbGUsXG4gICAgICBvZmZzZXRYOiBhZGp1c3RlZFgwLFxuICAgICAgb2Zmc2V0WTogYWRqdXN0ZWRZMFxuICAgIH07XG4gIH1cbiAgZ2V0U2l6ZUFuZFNjYWxlKHN0ZXAsIHJlYWxPdXRwdXRTaXplLCBzY2FsZSkge1xuICAgIHN0ZXAgPSBNYXRoLmFicyhzdGVwKTtcbiAgICBjb25zdCBtYXhTaXplID0gTWF0aC5tYXgoVGlsaW5nUGF0dGVybi5NQVhfUEFUVEVSTl9TSVpFLCByZWFsT3V0cHV0U2l6ZSk7XG4gICAgbGV0IHNpemUgPSBNYXRoLmNlaWwoc3RlcCAqIHNjYWxlKTtcbiAgICBpZiAoc2l6ZSA+PSBtYXhTaXplKSB7XG4gICAgICBzaXplID0gbWF4U2l6ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2NhbGUgPSBzaXplIC8gc3RlcDtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHNjYWxlLFxuICAgICAgc2l6ZVxuICAgIH07XG4gIH1cbiAgY2xpcEJib3goZ3JhcGhpY3MsIHgwLCB5MCwgeDEsIHkxKSB7XG4gICAgY29uc3QgYmJveFdpZHRoID0geDEgLSB4MDtcbiAgICBjb25zdCBiYm94SGVpZ2h0ID0geTEgLSB5MDtcbiAgICBncmFwaGljcy5jdHgucmVjdCh4MCwgeTAsIGJib3hXaWR0aCwgYmJveEhlaWdodCk7XG4gICAgZ3JhcGhpY3MuY3VycmVudC51cGRhdGVSZWN0TWluTWF4KCgwLCBfZGlzcGxheV91dGlscy5nZXRDdXJyZW50VHJhbnNmb3JtKShncmFwaGljcy5jdHgpLCBbeDAsIHkwLCB4MSwgeTFdKTtcbiAgICBncmFwaGljcy5jbGlwKCk7XG4gICAgZ3JhcGhpY3MuZW5kUGF0aCgpO1xuICB9XG4gIHNldEZpbGxBbmRTdHJva2VTdHlsZVRvQ29udGV4dChncmFwaGljcywgcGFpbnRUeXBlLCBjb2xvcikge1xuICAgIGNvbnN0IGNvbnRleHQgPSBncmFwaGljcy5jdHgsXG4gICAgICBjdXJyZW50ID0gZ3JhcGhpY3MuY3VycmVudDtcbiAgICBzd2l0Y2ggKHBhaW50VHlwZSkge1xuICAgICAgY2FzZSBQYWludFR5cGUuQ09MT1JFRDpcbiAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gY3R4LmZpbGxTdHlsZTtcbiAgICAgICAgY29udGV4dC5zdHJva2VTdHlsZSA9IGN0eC5zdHJva2VTdHlsZTtcbiAgICAgICAgY3VycmVudC5maWxsQ29sb3IgPSBjdHguZmlsbFN0eWxlO1xuICAgICAgICBjdXJyZW50LnN0cm9rZUNvbG9yID0gY3R4LnN0cm9rZVN0eWxlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgUGFpbnRUeXBlLlVOQ09MT1JFRDpcbiAgICAgICAgY29uc3QgY3NzQ29sb3IgPSBfdXRpbC5VdGlsLm1ha2VIZXhDb2xvcihjb2xvclswXSwgY29sb3JbMV0sIGNvbG9yWzJdKTtcbiAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSBjc3NDb2xvcjtcbiAgICAgICAgY29udGV4dC5zdHJva2VTdHlsZSA9IGNzc0NvbG9yO1xuICAgICAgICBjdXJyZW50LmZpbGxDb2xvciA9IGNzc0NvbG9yO1xuICAgICAgICBjdXJyZW50LnN0cm9rZUNvbG9yID0gY3NzQ29sb3I7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IF91dGlsLkZvcm1hdEVycm9yKGBVbnN1cHBvcnRlZCBwYWludCB0eXBlOiAke3BhaW50VHlwZX1gKTtcbiAgICB9XG4gIH1cbiAgZ2V0UGF0dGVybihjdHgsIG93bmVyLCBpbnZlcnNlLCBwYXRoVHlwZSkge1xuICAgIGxldCBtYXRyaXggPSBpbnZlcnNlO1xuICAgIGlmIChwYXRoVHlwZSAhPT0gUGF0aFR5cGUuU0hBRElORykge1xuICAgICAgbWF0cml4ID0gX3V0aWwuVXRpbC50cmFuc2Zvcm0obWF0cml4LCBvd25lci5iYXNlVHJhbnNmb3JtKTtcbiAgICAgIGlmICh0aGlzLm1hdHJpeCkge1xuICAgICAgICBtYXRyaXggPSBfdXRpbC5VdGlsLnRyYW5zZm9ybShtYXRyaXgsIHRoaXMubWF0cml4KTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgdGVtcG9yYXJ5UGF0dGVybkNhbnZhcyA9IHRoaXMuY3JlYXRlUGF0dGVybkNhbnZhcyhvd25lcik7XG4gICAgbGV0IGRvbU1hdHJpeCA9IG5ldyBET01NYXRyaXgobWF0cml4KTtcbiAgICBkb21NYXRyaXggPSBkb21NYXRyaXgudHJhbnNsYXRlKHRlbXBvcmFyeVBhdHRlcm5DYW52YXMub2Zmc2V0WCwgdGVtcG9yYXJ5UGF0dGVybkNhbnZhcy5vZmZzZXRZKTtcbiAgICBkb21NYXRyaXggPSBkb21NYXRyaXguc2NhbGUoMSAvIHRlbXBvcmFyeVBhdHRlcm5DYW52YXMuc2NhbGVYLCAxIC8gdGVtcG9yYXJ5UGF0dGVybkNhbnZhcy5zY2FsZVkpO1xuICAgIGNvbnN0IHBhdHRlcm4gPSBjdHguY3JlYXRlUGF0dGVybih0ZW1wb3JhcnlQYXR0ZXJuQ2FudmFzLmNhbnZhcywgXCJyZXBlYXRcIik7XG4gICAgcGF0dGVybi5zZXRUcmFuc2Zvcm0oZG9tTWF0cml4KTtcbiAgICByZXR1cm4gcGF0dGVybjtcbiAgfVxufVxuZXhwb3J0cy5UaWxpbmdQYXR0ZXJuID0gVGlsaW5nUGF0dGVybjtcblxuLyoqKi8gfSksXG4vKiAxMyAqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykgPT4ge1xuXG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xuZXhwb3J0cy5jb252ZXJ0QmxhY2tBbmRXaGl0ZVRvUkdCQSA9IGNvbnZlcnRCbGFja0FuZFdoaXRlVG9SR0JBO1xuZXhwb3J0cy5jb252ZXJ0VG9SR0JBID0gY29udmVydFRvUkdCQTtcbmV4cG9ydHMuZ3JheVRvUkdCQSA9IGdyYXlUb1JHQkE7XG52YXIgX3V0aWwgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEpO1xuZnVuY3Rpb24gY29udmVydFRvUkdCQShwYXJhbXMpIHtcbiAgc3dpdGNoIChwYXJhbXMua2luZCkge1xuICAgIGNhc2UgX3V0aWwuSW1hZ2VLaW5kLkdSQVlTQ0FMRV8xQlBQOlxuICAgICAgcmV0dXJuIGNvbnZlcnRCbGFja0FuZFdoaXRlVG9SR0JBKHBhcmFtcyk7XG4gICAgY2FzZSBfdXRpbC5JbWFnZUtpbmQuUkdCXzI0QlBQOlxuICAgICAgcmV0dXJuIGNvbnZlcnRSR0JUb1JHQkEocGFyYW1zKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRCbGFja0FuZFdoaXRlVG9SR0JBKHtcbiAgc3JjLFxuICBzcmNQb3MgPSAwLFxuICBkZXN0LFxuICB3aWR0aCxcbiAgaGVpZ2h0LFxuICBub25CbGFja0NvbG9yID0gMHhmZmZmZmZmZixcbiAgaW52ZXJzZURlY29kZSA9IGZhbHNlXG59KSB7XG4gIGNvbnN0IGJsYWNrID0gX3V0aWwuRmVhdHVyZVRlc3QuaXNMaXR0bGVFbmRpYW4gPyAweGZmMDAwMDAwIDogMHgwMDAwMDBmZjtcbiAgY29uc3QgW3plcm9NYXBwaW5nLCBvbmVNYXBwaW5nXSA9IGludmVyc2VEZWNvZGUgPyBbbm9uQmxhY2tDb2xvciwgYmxhY2tdIDogW2JsYWNrLCBub25CbGFja0NvbG9yXTtcbiAgY29uc3Qgd2lkdGhJblNvdXJjZSA9IHdpZHRoID4+IDM7XG4gIGNvbnN0IHdpZHRoUmVtYWluZGVyID0gd2lkdGggJiA3O1xuICBjb25zdCBzcmNMZW5ndGggPSBzcmMubGVuZ3RoO1xuICBkZXN0ID0gbmV3IFVpbnQzMkFycmF5KGRlc3QuYnVmZmVyKTtcbiAgbGV0IGRlc3RQb3MgPSAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGhlaWdodDsgaSsrKSB7XG4gICAgZm9yIChjb25zdCBtYXggPSBzcmNQb3MgKyB3aWR0aEluU291cmNlOyBzcmNQb3MgPCBtYXg7IHNyY1BvcysrKSB7XG4gICAgICBjb25zdCBlbGVtID0gc3JjUG9zIDwgc3JjTGVuZ3RoID8gc3JjW3NyY1Bvc10gOiAyNTU7XG4gICAgICBkZXN0W2Rlc3RQb3MrK10gPSBlbGVtICYgMGIxMDAwMDAwMCA/IG9uZU1hcHBpbmcgOiB6ZXJvTWFwcGluZztcbiAgICAgIGRlc3RbZGVzdFBvcysrXSA9IGVsZW0gJiAwYjEwMDAwMDAgPyBvbmVNYXBwaW5nIDogemVyb01hcHBpbmc7XG4gICAgICBkZXN0W2Rlc3RQb3MrK10gPSBlbGVtICYgMGIxMDAwMDAgPyBvbmVNYXBwaW5nIDogemVyb01hcHBpbmc7XG4gICAgICBkZXN0W2Rlc3RQb3MrK10gPSBlbGVtICYgMGIxMDAwMCA/IG9uZU1hcHBpbmcgOiB6ZXJvTWFwcGluZztcbiAgICAgIGRlc3RbZGVzdFBvcysrXSA9IGVsZW0gJiAwYjEwMDAgPyBvbmVNYXBwaW5nIDogemVyb01hcHBpbmc7XG4gICAgICBkZXN0W2Rlc3RQb3MrK10gPSBlbGVtICYgMGIxMDAgPyBvbmVNYXBwaW5nIDogemVyb01hcHBpbmc7XG4gICAgICBkZXN0W2Rlc3RQb3MrK10gPSBlbGVtICYgMGIxMCA/IG9uZU1hcHBpbmcgOiB6ZXJvTWFwcGluZztcbiAgICAgIGRlc3RbZGVzdFBvcysrXSA9IGVsZW0gJiAwYjEgPyBvbmVNYXBwaW5nIDogemVyb01hcHBpbmc7XG4gICAgfVxuICAgIGlmICh3aWR0aFJlbWFpbmRlciA9PT0gMCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IGVsZW0gPSBzcmNQb3MgPCBzcmNMZW5ndGggPyBzcmNbc3JjUG9zKytdIDogMjU1O1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgd2lkdGhSZW1haW5kZXI7IGorKykge1xuICAgICAgZGVzdFtkZXN0UG9zKytdID0gZWxlbSAmIDEgPDwgNyAtIGogPyBvbmVNYXBwaW5nIDogemVyb01hcHBpbmc7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgc3JjUG9zLFxuICAgIGRlc3RQb3NcbiAgfTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRSR0JUb1JHQkEoe1xuICBzcmMsXG4gIHNyY1BvcyA9IDAsXG4gIGRlc3QsXG4gIGRlc3RQb3MgPSAwLFxuICB3aWR0aCxcbiAgaGVpZ2h0XG59KSB7XG4gIGxldCBpID0gMDtcbiAgY29uc3QgbGVuMzIgPSBzcmMubGVuZ3RoID4+IDI7XG4gIGNvbnN0IHNyYzMyID0gbmV3IFVpbnQzMkFycmF5KHNyYy5idWZmZXIsIHNyY1BvcywgbGVuMzIpO1xuICBpZiAoX3V0aWwuRmVhdHVyZVRlc3QuaXNMaXR0bGVFbmRpYW4pIHtcbiAgICBmb3IgKDsgaSA8IGxlbjMyIC0gMjsgaSArPSAzLCBkZXN0UG9zICs9IDQpIHtcbiAgICAgIGNvbnN0IHMxID0gc3JjMzJbaV07XG4gICAgICBjb25zdCBzMiA9IHNyYzMyW2kgKyAxXTtcbiAgICAgIGNvbnN0IHMzID0gc3JjMzJbaSArIDJdO1xuICAgICAgZGVzdFtkZXN0UG9zXSA9IHMxIHwgMHhmZjAwMDAwMDtcbiAgICAgIGRlc3RbZGVzdFBvcyArIDFdID0gczEgPj4+IDI0IHwgczIgPDwgOCB8IDB4ZmYwMDAwMDA7XG4gICAgICBkZXN0W2Rlc3RQb3MgKyAyXSA9IHMyID4+PiAxNiB8IHMzIDw8IDE2IHwgMHhmZjAwMDAwMDtcbiAgICAgIGRlc3RbZGVzdFBvcyArIDNdID0gczMgPj4+IDggfCAweGZmMDAwMDAwO1xuICAgIH1cbiAgICBmb3IgKGxldCBqID0gaSAqIDQsIGpqID0gc3JjLmxlbmd0aDsgaiA8IGpqOyBqICs9IDMpIHtcbiAgICAgIGRlc3RbZGVzdFBvcysrXSA9IHNyY1tqXSB8IHNyY1tqICsgMV0gPDwgOCB8IHNyY1tqICsgMl0gPDwgMTYgfCAweGZmMDAwMDAwO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmb3IgKDsgaSA8IGxlbjMyIC0gMjsgaSArPSAzLCBkZXN0UG9zICs9IDQpIHtcbiAgICAgIGNvbnN0IHMxID0gc3JjMzJbaV07XG4gICAgICBjb25zdCBzMiA9IHNyYzMyW2kgKyAxXTtcbiAgICAgIGNvbnN0IHMzID0gc3JjMzJbaSArIDJdO1xuICAgICAgZGVzdFtkZXN0UG9zXSA9IHMxIHwgMHhmZjtcbiAgICAgIGRlc3RbZGVzdFBvcyArIDFdID0gczEgPDwgMjQgfCBzMiA+Pj4gOCB8IDB4ZmY7XG4gICAgICBkZXN0W2Rlc3RQb3MgKyAyXSA9IHMyIDw8IDE2IHwgczMgPj4+IDE2IHwgMHhmZjtcbiAgICAgIGRlc3RbZGVzdFBvcyArIDNdID0gczMgPDwgOCB8IDB4ZmY7XG4gICAgfVxuICAgIGZvciAobGV0IGogPSBpICogNCwgamogPSBzcmMubGVuZ3RoOyBqIDwgamo7IGogKz0gMykge1xuICAgICAgZGVzdFtkZXN0UG9zKytdID0gc3JjW2pdIDw8IDI0IHwgc3JjW2ogKyAxXSA8PCAxNiB8IHNyY1tqICsgMl0gPDwgOCB8IDB4ZmY7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgc3JjUG9zLFxuICAgIGRlc3RQb3NcbiAgfTtcbn1cbmZ1bmN0aW9uIGdyYXlUb1JHQkEoc3JjLCBkZXN0KSB7XG4gIGlmIChfdXRpbC5GZWF0dXJlVGVzdC5pc0xpdHRsZUVuZGlhbikge1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IHNyYy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICBkZXN0W2ldID0gc3JjW2ldICogMHgxMDEwMSB8IDB4ZmYwMDAwMDA7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IHNyYy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICBkZXN0W2ldID0gc3JjW2ldICogMHgxMDEwMTAwIHwgMHgwMDAwMDBmZjtcbiAgICB9XG4gIH1cbn1cblxuLyoqKi8gfSksXG4vKiAxNCAqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cykgPT4ge1xuXG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xuZXhwb3J0cy5HbG9iYWxXb3JrZXJPcHRpb25zID0gdm9pZCAwO1xuY29uc3QgR2xvYmFsV29ya2VyT3B0aW9ucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5leHBvcnRzLkdsb2JhbFdvcmtlck9wdGlvbnMgPSBHbG9iYWxXb3JrZXJPcHRpb25zO1xuR2xvYmFsV29ya2VyT3B0aW9ucy53b3JrZXJQb3J0ID0gbnVsbDtcbkdsb2JhbFdvcmtlck9wdGlvbnMud29ya2VyU3JjID0gXCJcIjtcblxuLyoqKi8gfSksXG4vKiAxNSAqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykgPT4ge1xuXG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xuZXhwb3J0cy5NZXNzYWdlSGFuZGxlciA9IHZvaWQgMDtcbnZhciBfdXRpbCA9IF9fd19wZGZqc19yZXF1aXJlX18oMSk7XG5jb25zdCBDYWxsYmFja0tpbmQgPSB7XG4gIFVOS05PV046IDAsXG4gIERBVEE6IDEsXG4gIEVSUk9SOiAyXG59O1xuY29uc3QgU3RyZWFtS2luZCA9IHtcbiAgVU5LTk9XTjogMCxcbiAgQ0FOQ0VMOiAxLFxuICBDQU5DRUxfQ09NUExFVEU6IDIsXG4gIENMT1NFOiAzLFxuICBFTlFVRVVFOiA0LFxuICBFUlJPUjogNSxcbiAgUFVMTDogNixcbiAgUFVMTF9DT01QTEVURTogNyxcbiAgU1RBUlRfQ09NUExFVEU6IDhcbn07XG5mdW5jdGlvbiB3cmFwUmVhc29uKHJlYXNvbikge1xuICBpZiAoIShyZWFzb24gaW5zdGFuY2VvZiBFcnJvciB8fCB0eXBlb2YgcmVhc29uID09PSBcIm9iamVjdFwiICYmIHJlYXNvbiAhPT0gbnVsbCkpIHtcbiAgICAoMCwgX3V0aWwudW5yZWFjaGFibGUpKCd3cmFwUmVhc29uOiBFeHBlY3RlZCBcInJlYXNvblwiIHRvIGJlIGEgKHBvc3NpYmx5IGNsb25lZCkgRXJyb3IuJyk7XG4gIH1cbiAgc3dpdGNoIChyZWFzb24ubmFtZSkge1xuICAgIGNhc2UgXCJBYm9ydEV4Y2VwdGlvblwiOlxuICAgICAgcmV0dXJuIG5ldyBfdXRpbC5BYm9ydEV4Y2VwdGlvbihyZWFzb24ubWVzc2FnZSk7XG4gICAgY2FzZSBcIk1pc3NpbmdQREZFeGNlcHRpb25cIjpcbiAgICAgIHJldHVybiBuZXcgX3V0aWwuTWlzc2luZ1BERkV4Y2VwdGlvbihyZWFzb24ubWVzc2FnZSk7XG4gICAgY2FzZSBcIlBhc3N3b3JkRXhjZXB0aW9uXCI6XG4gICAgICByZXR1cm4gbmV3IF91dGlsLlBhc3N3b3JkRXhjZXB0aW9uKHJlYXNvbi5tZXNzYWdlLCByZWFzb24uY29kZSk7XG4gICAgY2FzZSBcIlVuZXhwZWN0ZWRSZXNwb25zZUV4Y2VwdGlvblwiOlxuICAgICAgcmV0dXJuIG5ldyBfdXRpbC5VbmV4cGVjdGVkUmVzcG9uc2VFeGNlcHRpb24ocmVhc29uLm1lc3NhZ2UsIHJlYXNvbi5zdGF0dXMpO1xuICAgIGNhc2UgXCJVbmtub3duRXJyb3JFeGNlcHRpb25cIjpcbiAgICAgIHJldHVybiBuZXcgX3V0aWwuVW5rbm93bkVycm9yRXhjZXB0aW9uKHJlYXNvbi5tZXNzYWdlLCByZWFzb24uZGV0YWlscyk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBuZXcgX3V0aWwuVW5rbm93bkVycm9yRXhjZXB0aW9uKHJlYXNvbi5tZXNzYWdlLCByZWFzb24udG9TdHJpbmcoKSk7XG4gIH1cbn1cbmNsYXNzIE1lc3NhZ2VIYW5kbGVyIHtcbiAgY29uc3RydWN0b3Ioc291cmNlTmFtZSwgdGFyZ2V0TmFtZSwgY29tT2JqKSB7XG4gICAgdGhpcy5zb3VyY2VOYW1lID0gc291cmNlTmFtZTtcbiAgICB0aGlzLnRhcmdldE5hbWUgPSB0YXJnZXROYW1lO1xuICAgIHRoaXMuY29tT2JqID0gY29tT2JqO1xuICAgIHRoaXMuY2FsbGJhY2tJZCA9IDE7XG4gICAgdGhpcy5zdHJlYW1JZCA9IDE7XG4gICAgdGhpcy5zdHJlYW1TaW5rcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5zdHJlYW1Db250cm9sbGVycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5jYWxsYmFja0NhcGFiaWxpdGllcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5hY3Rpb25IYW5kbGVyID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLl9vbkNvbU9iak9uTWVzc2FnZSA9IGV2ZW50ID0+IHtcbiAgICAgIGNvbnN0IGRhdGEgPSBldmVudC5kYXRhO1xuICAgICAgaWYgKGRhdGEudGFyZ2V0TmFtZSAhPT0gdGhpcy5zb3VyY2VOYW1lKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChkYXRhLnN0cmVhbSkge1xuICAgICAgICB0aGlzLiNwcm9jZXNzU3RyZWFtTWVzc2FnZShkYXRhKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGRhdGEuY2FsbGJhY2spIHtcbiAgICAgICAgY29uc3QgY2FsbGJhY2tJZCA9IGRhdGEuY2FsbGJhY2tJZDtcbiAgICAgICAgY29uc3QgY2FwYWJpbGl0eSA9IHRoaXMuY2FsbGJhY2tDYXBhYmlsaXRpZXNbY2FsbGJhY2tJZF07XG4gICAgICAgIGlmICghY2FwYWJpbGl0eSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IHJlc29sdmUgY2FsbGJhY2sgJHtjYWxsYmFja0lkfWApO1xuICAgICAgICB9XG4gICAgICAgIGRlbGV0ZSB0aGlzLmNhbGxiYWNrQ2FwYWJpbGl0aWVzW2NhbGxiYWNrSWRdO1xuICAgICAgICBpZiAoZGF0YS5jYWxsYmFjayA9PT0gQ2FsbGJhY2tLaW5kLkRBVEEpIHtcbiAgICAgICAgICBjYXBhYmlsaXR5LnJlc29sdmUoZGF0YS5kYXRhKTtcbiAgICAgICAgfSBlbHNlIGlmIChkYXRhLmNhbGxiYWNrID09PSBDYWxsYmFja0tpbmQuRVJST1IpIHtcbiAgICAgICAgICBjYXBhYmlsaXR5LnJlamVjdCh3cmFwUmVhc29uKGRhdGEucmVhc29uKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBjYWxsYmFjayBjYXNlXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGFjdGlvbiA9IHRoaXMuYWN0aW9uSGFuZGxlcltkYXRhLmFjdGlvbl07XG4gICAgICBpZiAoIWFjdGlvbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gYWN0aW9uIGZyb20gd29ya2VyOiAke2RhdGEuYWN0aW9ufWApO1xuICAgICAgfVxuICAgICAgaWYgKGRhdGEuY2FsbGJhY2tJZCkge1xuICAgICAgICBjb25zdCBjYlNvdXJjZU5hbWUgPSB0aGlzLnNvdXJjZU5hbWU7XG4gICAgICAgIGNvbnN0IGNiVGFyZ2V0TmFtZSA9IGRhdGEuc291cmNlTmFtZTtcbiAgICAgICAgbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICByZXNvbHZlKGFjdGlvbihkYXRhLmRhdGEpKTtcbiAgICAgICAgfSkudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgY29tT2JqLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgIHNvdXJjZU5hbWU6IGNiU291cmNlTmFtZSxcbiAgICAgICAgICAgIHRhcmdldE5hbWU6IGNiVGFyZ2V0TmFtZSxcbiAgICAgICAgICAgIGNhbGxiYWNrOiBDYWxsYmFja0tpbmQuREFUQSxcbiAgICAgICAgICAgIGNhbGxiYWNrSWQ6IGRhdGEuY2FsbGJhY2tJZCxcbiAgICAgICAgICAgIGRhdGE6IHJlc3VsdFxuICAgICAgICAgIH0pO1xuICAgICAgICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAgICAgY29tT2JqLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgIHNvdXJjZU5hbWU6IGNiU291cmNlTmFtZSxcbiAgICAgICAgICAgIHRhcmdldE5hbWU6IGNiVGFyZ2V0TmFtZSxcbiAgICAgICAgICAgIGNhbGxiYWNrOiBDYWxsYmFja0tpbmQuRVJST1IsXG4gICAgICAgICAgICBjYWxsYmFja0lkOiBkYXRhLmNhbGxiYWNrSWQsXG4gICAgICAgICAgICByZWFzb246IHdyYXBSZWFzb24ocmVhc29uKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGRhdGEuc3RyZWFtSWQpIHtcbiAgICAgICAgdGhpcy4jY3JlYXRlU3RyZWFtU2luayhkYXRhKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgYWN0aW9uKGRhdGEuZGF0YSk7XG4gICAgfTtcbiAgICBjb21PYmouYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgdGhpcy5fb25Db21PYmpPbk1lc3NhZ2UpO1xuICB9XG4gIG9uKGFjdGlvbk5hbWUsIGhhbmRsZXIpIHtcbiAgICBjb25zdCBhaCA9IHRoaXMuYWN0aW9uSGFuZGxlcjtcbiAgICBpZiAoYWhbYWN0aW9uTmFtZV0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlcmUgaXMgYWxyZWFkeSBhbiBhY3Rpb25OYW1lIGNhbGxlZCBcIiR7YWN0aW9uTmFtZX1cImApO1xuICAgIH1cbiAgICBhaFthY3Rpb25OYW1lXSA9IGhhbmRsZXI7XG4gIH1cbiAgc2VuZChhY3Rpb25OYW1lLCBkYXRhLCB0cmFuc2ZlcnMpIHtcbiAgICB0aGlzLmNvbU9iai5wb3N0TWVzc2FnZSh7XG4gICAgICBzb3VyY2VOYW1lOiB0aGlzLnNvdXJjZU5hbWUsXG4gICAgICB0YXJnZXROYW1lOiB0aGlzLnRhcmdldE5hbWUsXG4gICAgICBhY3Rpb246IGFjdGlvbk5hbWUsXG4gICAgICBkYXRhXG4gICAgfSwgdHJhbnNmZXJzKTtcbiAgfVxuICBzZW5kV2l0aFByb21pc2UoYWN0aW9uTmFtZSwgZGF0YSwgdHJhbnNmZXJzKSB7XG4gICAgY29uc3QgY2FsbGJhY2tJZCA9IHRoaXMuY2FsbGJhY2tJZCsrO1xuICAgIGNvbnN0IGNhcGFiaWxpdHkgPSBuZXcgX3V0aWwuUHJvbWlzZUNhcGFiaWxpdHkoKTtcbiAgICB0aGlzLmNhbGxiYWNrQ2FwYWJpbGl0aWVzW2NhbGxiYWNrSWRdID0gY2FwYWJpbGl0eTtcbiAgICB0cnkge1xuICAgICAgdGhpcy5jb21PYmoucG9zdE1lc3NhZ2Uoe1xuICAgICAgICBzb3VyY2VOYW1lOiB0aGlzLnNvdXJjZU5hbWUsXG4gICAgICAgIHRhcmdldE5hbWU6IHRoaXMudGFyZ2V0TmFtZSxcbiAgICAgICAgYWN0aW9uOiBhY3Rpb25OYW1lLFxuICAgICAgICBjYWxsYmFja0lkLFxuICAgICAgICBkYXRhXG4gICAgICB9LCB0cmFuc2ZlcnMpO1xuICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICBjYXBhYmlsaXR5LnJlamVjdChleCk7XG4gICAgfVxuICAgIHJldHVybiBjYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbiAgc2VuZFdpdGhTdHJlYW0oYWN0aW9uTmFtZSwgZGF0YSwgcXVldWVpbmdTdHJhdGVneSwgdHJhbnNmZXJzKSB7XG4gICAgY29uc3Qgc3RyZWFtSWQgPSB0aGlzLnN0cmVhbUlkKyssXG4gICAgICBzb3VyY2VOYW1lID0gdGhpcy5zb3VyY2VOYW1lLFxuICAgICAgdGFyZ2V0TmFtZSA9IHRoaXMudGFyZ2V0TmFtZSxcbiAgICAgIGNvbU9iaiA9IHRoaXMuY29tT2JqO1xuICAgIHJldHVybiBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgICAgc3RhcnQ6IGNvbnRyb2xsZXIgPT4ge1xuICAgICAgICBjb25zdCBzdGFydENhcGFiaWxpdHkgPSBuZXcgX3V0aWwuUHJvbWlzZUNhcGFiaWxpdHkoKTtcbiAgICAgICAgdGhpcy5zdHJlYW1Db250cm9sbGVyc1tzdHJlYW1JZF0gPSB7XG4gICAgICAgICAgY29udHJvbGxlcixcbiAgICAgICAgICBzdGFydENhbGw6IHN0YXJ0Q2FwYWJpbGl0eSxcbiAgICAgICAgICBwdWxsQ2FsbDogbnVsbCxcbiAgICAgICAgICBjYW5jZWxDYWxsOiBudWxsLFxuICAgICAgICAgIGlzQ2xvc2VkOiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgICBjb21PYmoucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgIHNvdXJjZU5hbWUsXG4gICAgICAgICAgdGFyZ2V0TmFtZSxcbiAgICAgICAgICBhY3Rpb246IGFjdGlvbk5hbWUsXG4gICAgICAgICAgc3RyZWFtSWQsXG4gICAgICAgICAgZGF0YSxcbiAgICAgICAgICBkZXNpcmVkU2l6ZTogY29udHJvbGxlci5kZXNpcmVkU2l6ZVxuICAgICAgICB9LCB0cmFuc2ZlcnMpO1xuICAgICAgICByZXR1cm4gc3RhcnRDYXBhYmlsaXR5LnByb21pc2U7XG4gICAgICB9LFxuICAgICAgcHVsbDogY29udHJvbGxlciA9PiB7XG4gICAgICAgIGNvbnN0IHB1bGxDYXBhYmlsaXR5ID0gbmV3IF91dGlsLlByb21pc2VDYXBhYmlsaXR5KCk7XG4gICAgICAgIHRoaXMuc3RyZWFtQ29udHJvbGxlcnNbc3RyZWFtSWRdLnB1bGxDYWxsID0gcHVsbENhcGFiaWxpdHk7XG4gICAgICAgIGNvbU9iai5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgc291cmNlTmFtZSxcbiAgICAgICAgICB0YXJnZXROYW1lLFxuICAgICAgICAgIHN0cmVhbTogU3RyZWFtS2luZC5QVUxMLFxuICAgICAgICAgIHN0cmVhbUlkLFxuICAgICAgICAgIGRlc2lyZWRTaXplOiBjb250cm9sbGVyLmRlc2lyZWRTaXplXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcHVsbENhcGFiaWxpdHkucHJvbWlzZTtcbiAgICAgIH0sXG4gICAgICBjYW5jZWw6IHJlYXNvbiA9PiB7XG4gICAgICAgICgwLCBfdXRpbC5hc3NlcnQpKHJlYXNvbiBpbnN0YW5jZW9mIEVycm9yLCBcImNhbmNlbCBtdXN0IGhhdmUgYSB2YWxpZCByZWFzb25cIik7XG4gICAgICAgIGNvbnN0IGNhbmNlbENhcGFiaWxpdHkgPSBuZXcgX3V0aWwuUHJvbWlzZUNhcGFiaWxpdHkoKTtcbiAgICAgICAgdGhpcy5zdHJlYW1Db250cm9sbGVyc1tzdHJlYW1JZF0uY2FuY2VsQ2FsbCA9IGNhbmNlbENhcGFiaWxpdHk7XG4gICAgICAgIHRoaXMuc3RyZWFtQ29udHJvbGxlcnNbc3RyZWFtSWRdLmlzQ2xvc2VkID0gdHJ1ZTtcbiAgICAgICAgY29tT2JqLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICBzb3VyY2VOYW1lLFxuICAgICAgICAgIHRhcmdldE5hbWUsXG4gICAgICAgICAgc3RyZWFtOiBTdHJlYW1LaW5kLkNBTkNFTCxcbiAgICAgICAgICBzdHJlYW1JZCxcbiAgICAgICAgICByZWFzb246IHdyYXBSZWFzb24ocmVhc29uKVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGNhbmNlbENhcGFiaWxpdHkucHJvbWlzZTtcbiAgICAgIH1cbiAgICB9LCBxdWV1ZWluZ1N0cmF0ZWd5KTtcbiAgfVxuICAjY3JlYXRlU3RyZWFtU2luayhkYXRhKSB7XG4gICAgY29uc3Qgc3RyZWFtSWQgPSBkYXRhLnN0cmVhbUlkLFxuICAgICAgc291cmNlTmFtZSA9IHRoaXMuc291cmNlTmFtZSxcbiAgICAgIHRhcmdldE5hbWUgPSBkYXRhLnNvdXJjZU5hbWUsXG4gICAgICBjb21PYmogPSB0aGlzLmNvbU9iajtcbiAgICBjb25zdCBzZWxmID0gdGhpcyxcbiAgICAgIGFjdGlvbiA9IHRoaXMuYWN0aW9uSGFuZGxlcltkYXRhLmFjdGlvbl07XG4gICAgY29uc3Qgc3RyZWFtU2luayA9IHtcbiAgICAgIGVucXVldWUoY2h1bmssIHNpemUgPSAxLCB0cmFuc2ZlcnMpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNDYW5jZWxsZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGFzdERlc2lyZWRTaXplID0gdGhpcy5kZXNpcmVkU2l6ZTtcbiAgICAgICAgdGhpcy5kZXNpcmVkU2l6ZSAtPSBzaXplO1xuICAgICAgICBpZiAobGFzdERlc2lyZWRTaXplID4gMCAmJiB0aGlzLmRlc2lyZWRTaXplIDw9IDApIHtcbiAgICAgICAgICB0aGlzLnNpbmtDYXBhYmlsaXR5ID0gbmV3IF91dGlsLlByb21pc2VDYXBhYmlsaXR5KCk7XG4gICAgICAgICAgdGhpcy5yZWFkeSA9IHRoaXMuc2lua0NhcGFiaWxpdHkucHJvbWlzZTtcbiAgICAgICAgfVxuICAgICAgICBjb21PYmoucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgIHNvdXJjZU5hbWUsXG4gICAgICAgICAgdGFyZ2V0TmFtZSxcbiAgICAgICAgICBzdHJlYW06IFN0cmVhbUtpbmQuRU5RVUVVRSxcbiAgICAgICAgICBzdHJlYW1JZCxcbiAgICAgICAgICBjaHVua1xuICAgICAgICB9LCB0cmFuc2ZlcnMpO1xuICAgICAgfSxcbiAgICAgIGNsb3NlKCkge1xuICAgICAgICBpZiAodGhpcy5pc0NhbmNlbGxlZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzQ2FuY2VsbGVkID0gdHJ1ZTtcbiAgICAgICAgY29tT2JqLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICBzb3VyY2VOYW1lLFxuICAgICAgICAgIHRhcmdldE5hbWUsXG4gICAgICAgICAgc3RyZWFtOiBTdHJlYW1LaW5kLkNMT1NFLFxuICAgICAgICAgIHN0cmVhbUlkXG4gICAgICAgIH0pO1xuICAgICAgICBkZWxldGUgc2VsZi5zdHJlYW1TaW5rc1tzdHJlYW1JZF07XG4gICAgICB9LFxuICAgICAgZXJyb3IocmVhc29uKSB7XG4gICAgICAgICgwLCBfdXRpbC5hc3NlcnQpKHJlYXNvbiBpbnN0YW5jZW9mIEVycm9yLCBcImVycm9yIG11c3QgaGF2ZSBhIHZhbGlkIHJlYXNvblwiKTtcbiAgICAgICAgaWYgKHRoaXMuaXNDYW5jZWxsZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pc0NhbmNlbGxlZCA9IHRydWU7XG4gICAgICAgIGNvbU9iai5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgc291cmNlTmFtZSxcbiAgICAgICAgICB0YXJnZXROYW1lLFxuICAgICAgICAgIHN0cmVhbTogU3RyZWFtS2luZC5FUlJPUixcbiAgICAgICAgICBzdHJlYW1JZCxcbiAgICAgICAgICByZWFzb246IHdyYXBSZWFzb24ocmVhc29uKVxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBzaW5rQ2FwYWJpbGl0eTogbmV3IF91dGlsLlByb21pc2VDYXBhYmlsaXR5KCksXG4gICAgICBvblB1bGw6IG51bGwsXG4gICAgICBvbkNhbmNlbDogbnVsbCxcbiAgICAgIGlzQ2FuY2VsbGVkOiBmYWxzZSxcbiAgICAgIGRlc2lyZWRTaXplOiBkYXRhLmRlc2lyZWRTaXplLFxuICAgICAgcmVhZHk6IG51bGxcbiAgICB9O1xuICAgIHN0cmVhbVNpbmsuc2lua0NhcGFiaWxpdHkucmVzb2x2ZSgpO1xuICAgIHN0cmVhbVNpbmsucmVhZHkgPSBzdHJlYW1TaW5rLnNpbmtDYXBhYmlsaXR5LnByb21pc2U7XG4gICAgdGhpcy5zdHJlYW1TaW5rc1tzdHJlYW1JZF0gPSBzdHJlYW1TaW5rO1xuICAgIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICByZXNvbHZlKGFjdGlvbihkYXRhLmRhdGEsIHN0cmVhbVNpbmspKTtcbiAgICB9KS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgIGNvbU9iai5wb3N0TWVzc2FnZSh7XG4gICAgICAgIHNvdXJjZU5hbWUsXG4gICAgICAgIHRhcmdldE5hbWUsXG4gICAgICAgIHN0cmVhbTogU3RyZWFtS2luZC5TVEFSVF9DT01QTEVURSxcbiAgICAgICAgc3RyZWFtSWQsXG4gICAgICAgIHN1Y2Nlc3M6IHRydWVcbiAgICAgIH0pO1xuICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgIGNvbU9iai5wb3N0TWVzc2FnZSh7XG4gICAgICAgIHNvdXJjZU5hbWUsXG4gICAgICAgIHRhcmdldE5hbWUsXG4gICAgICAgIHN0cmVhbTogU3RyZWFtS2luZC5TVEFSVF9DT01QTEVURSxcbiAgICAgICAgc3RyZWFtSWQsXG4gICAgICAgIHJlYXNvbjogd3JhcFJlYXNvbihyZWFzb24pXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICAjcHJvY2Vzc1N0cmVhbU1lc3NhZ2UoZGF0YSkge1xuICAgIGNvbnN0IHN0cmVhbUlkID0gZGF0YS5zdHJlYW1JZCxcbiAgICAgIHNvdXJjZU5hbWUgPSB0aGlzLnNvdXJjZU5hbWUsXG4gICAgICB0YXJnZXROYW1lID0gZGF0YS5zb3VyY2VOYW1lLFxuICAgICAgY29tT2JqID0gdGhpcy5jb21PYmo7XG4gICAgY29uc3Qgc3RyZWFtQ29udHJvbGxlciA9IHRoaXMuc3RyZWFtQ29udHJvbGxlcnNbc3RyZWFtSWRdLFxuICAgICAgc3RyZWFtU2luayA9IHRoaXMuc3RyZWFtU2lua3Nbc3RyZWFtSWRdO1xuICAgIHN3aXRjaCAoZGF0YS5zdHJlYW0pIHtcbiAgICAgIGNhc2UgU3RyZWFtS2luZC5TVEFSVF9DT01QTEVURTpcbiAgICAgICAgaWYgKGRhdGEuc3VjY2Vzcykge1xuICAgICAgICAgIHN0cmVhbUNvbnRyb2xsZXIuc3RhcnRDYWxsLnJlc29sdmUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdHJlYW1Db250cm9sbGVyLnN0YXJ0Q2FsbC5yZWplY3Qod3JhcFJlYXNvbihkYXRhLnJlYXNvbikpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBTdHJlYW1LaW5kLlBVTExfQ09NUExFVEU6XG4gICAgICAgIGlmIChkYXRhLnN1Y2Nlc3MpIHtcbiAgICAgICAgICBzdHJlYW1Db250cm9sbGVyLnB1bGxDYWxsLnJlc29sdmUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdHJlYW1Db250cm9sbGVyLnB1bGxDYWxsLnJlamVjdCh3cmFwUmVhc29uKGRhdGEucmVhc29uKSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFN0cmVhbUtpbmQuUFVMTDpcbiAgICAgICAgaWYgKCFzdHJlYW1TaW5rKSB7XG4gICAgICAgICAgY29tT2JqLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgIHNvdXJjZU5hbWUsXG4gICAgICAgICAgICB0YXJnZXROYW1lLFxuICAgICAgICAgICAgc3RyZWFtOiBTdHJlYW1LaW5kLlBVTExfQ09NUExFVEUsXG4gICAgICAgICAgICBzdHJlYW1JZCxcbiAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RyZWFtU2luay5kZXNpcmVkU2l6ZSA8PSAwICYmIGRhdGEuZGVzaXJlZFNpemUgPiAwKSB7XG4gICAgICAgICAgc3RyZWFtU2luay5zaW5rQ2FwYWJpbGl0eS5yZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgc3RyZWFtU2luay5kZXNpcmVkU2l6ZSA9IGRhdGEuZGVzaXJlZFNpemU7XG4gICAgICAgIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgcmVzb2x2ZShzdHJlYW1TaW5rLm9uUHVsbD8uKCkpO1xuICAgICAgICB9KS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBjb21PYmoucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgc291cmNlTmFtZSxcbiAgICAgICAgICAgIHRhcmdldE5hbWUsXG4gICAgICAgICAgICBzdHJlYW06IFN0cmVhbUtpbmQuUFVMTF9DT01QTEVURSxcbiAgICAgICAgICAgIHN0cmVhbUlkLFxuICAgICAgICAgICAgc3VjY2VzczogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAgICAgY29tT2JqLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgIHNvdXJjZU5hbWUsXG4gICAgICAgICAgICB0YXJnZXROYW1lLFxuICAgICAgICAgICAgc3RyZWFtOiBTdHJlYW1LaW5kLlBVTExfQ09NUExFVEUsXG4gICAgICAgICAgICBzdHJlYW1JZCxcbiAgICAgICAgICAgIHJlYXNvbjogd3JhcFJlYXNvbihyZWFzb24pXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgU3RyZWFtS2luZC5FTlFVRVVFOlxuICAgICAgICAoMCwgX3V0aWwuYXNzZXJ0KShzdHJlYW1Db250cm9sbGVyLCBcImVucXVldWUgc2hvdWxkIGhhdmUgc3RyZWFtIGNvbnRyb2xsZXJcIik7XG4gICAgICAgIGlmIChzdHJlYW1Db250cm9sbGVyLmlzQ2xvc2VkKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgc3RyZWFtQ29udHJvbGxlci5jb250cm9sbGVyLmVucXVldWUoZGF0YS5jaHVuayk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBTdHJlYW1LaW5kLkNMT1NFOlxuICAgICAgICAoMCwgX3V0aWwuYXNzZXJ0KShzdHJlYW1Db250cm9sbGVyLCBcImNsb3NlIHNob3VsZCBoYXZlIHN0cmVhbSBjb250cm9sbGVyXCIpO1xuICAgICAgICBpZiAoc3RyZWFtQ29udHJvbGxlci5pc0Nsb3NlZCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHN0cmVhbUNvbnRyb2xsZXIuaXNDbG9zZWQgPSB0cnVlO1xuICAgICAgICBzdHJlYW1Db250cm9sbGVyLmNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgICAgdGhpcy4jZGVsZXRlU3RyZWFtQ29udHJvbGxlcihzdHJlYW1Db250cm9sbGVyLCBzdHJlYW1JZCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBTdHJlYW1LaW5kLkVSUk9SOlxuICAgICAgICAoMCwgX3V0aWwuYXNzZXJ0KShzdHJlYW1Db250cm9sbGVyLCBcImVycm9yIHNob3VsZCBoYXZlIHN0cmVhbSBjb250cm9sbGVyXCIpO1xuICAgICAgICBzdHJlYW1Db250cm9sbGVyLmNvbnRyb2xsZXIuZXJyb3Iod3JhcFJlYXNvbihkYXRhLnJlYXNvbikpO1xuICAgICAgICB0aGlzLiNkZWxldGVTdHJlYW1Db250cm9sbGVyKHN0cmVhbUNvbnRyb2xsZXIsIHN0cmVhbUlkKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFN0cmVhbUtpbmQuQ0FOQ0VMX0NPTVBMRVRFOlxuICAgICAgICBpZiAoZGF0YS5zdWNjZXNzKSB7XG4gICAgICAgICAgc3RyZWFtQ29udHJvbGxlci5jYW5jZWxDYWxsLnJlc29sdmUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdHJlYW1Db250cm9sbGVyLmNhbmNlbENhbGwucmVqZWN0KHdyYXBSZWFzb24oZGF0YS5yZWFzb24pKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNkZWxldGVTdHJlYW1Db250cm9sbGVyKHN0cmVhbUNvbnRyb2xsZXIsIHN0cmVhbUlkKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFN0cmVhbUtpbmQuQ0FOQ0VMOlxuICAgICAgICBpZiAoIXN0cmVhbVNpbmspIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICAgIHJlc29sdmUoc3RyZWFtU2luay5vbkNhbmNlbD8uKHdyYXBSZWFzb24oZGF0YS5yZWFzb24pKSk7XG4gICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGNvbU9iai5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICBzb3VyY2VOYW1lLFxuICAgICAgICAgICAgdGFyZ2V0TmFtZSxcbiAgICAgICAgICAgIHN0cmVhbTogU3RyZWFtS2luZC5DQU5DRUxfQ09NUExFVEUsXG4gICAgICAgICAgICBzdHJlYW1JZCxcbiAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICAgIGNvbU9iai5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICBzb3VyY2VOYW1lLFxuICAgICAgICAgICAgdGFyZ2V0TmFtZSxcbiAgICAgICAgICAgIHN0cmVhbTogU3RyZWFtS2luZC5DQU5DRUxfQ09NUExFVEUsXG4gICAgICAgICAgICBzdHJlYW1JZCxcbiAgICAgICAgICAgIHJlYXNvbjogd3JhcFJlYXNvbihyZWFzb24pXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBzdHJlYW1TaW5rLnNpbmtDYXBhYmlsaXR5LnJlamVjdCh3cmFwUmVhc29uKGRhdGEucmVhc29uKSk7XG4gICAgICAgIHN0cmVhbVNpbmsuaXNDYW5jZWxsZWQgPSB0cnVlO1xuICAgICAgICBkZWxldGUgdGhpcy5zdHJlYW1TaW5rc1tzdHJlYW1JZF07XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBzdHJlYW0gY2FzZVwiKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgI2RlbGV0ZVN0cmVhbUNvbnRyb2xsZXIoc3RyZWFtQ29udHJvbGxlciwgc3RyZWFtSWQpIHtcbiAgICBhd2FpdCBQcm9taXNlLmFsbFNldHRsZWQoW3N0cmVhbUNvbnRyb2xsZXIuc3RhcnRDYWxsPy5wcm9taXNlLCBzdHJlYW1Db250cm9sbGVyLnB1bGxDYWxsPy5wcm9taXNlLCBzdHJlYW1Db250cm9sbGVyLmNhbmNlbENhbGw/LnByb21pc2VdKTtcbiAgICBkZWxldGUgdGhpcy5zdHJlYW1Db250cm9sbGVyc1tzdHJlYW1JZF07XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmNvbU9iai5yZW1vdmVFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCB0aGlzLl9vbkNvbU9iak9uTWVzc2FnZSk7XG4gIH1cbn1cbmV4cG9ydHMuTWVzc2FnZUhhbmRsZXIgPSBNZXNzYWdlSGFuZGxlcjtcblxuLyoqKi8gfSksXG4vKiAxNiAqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykgPT4ge1xuXG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xuZXhwb3J0cy5NZXRhZGF0YSA9IHZvaWQgMDtcbnZhciBfdXRpbCA9IF9fd19wZGZqc19yZXF1aXJlX18oMSk7XG5jbGFzcyBNZXRhZGF0YSB7XG4gICNtZXRhZGF0YU1hcDtcbiAgI2RhdGE7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBwYXJzZWREYXRhLFxuICAgIHJhd0RhdGFcbiAgfSkge1xuICAgIHRoaXMuI21ldGFkYXRhTWFwID0gcGFyc2VkRGF0YTtcbiAgICB0aGlzLiNkYXRhID0gcmF3RGF0YTtcbiAgfVxuICBnZXRSYXcoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2RhdGE7XG4gIH1cbiAgZ2V0KG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy4jbWV0YWRhdGFNYXAuZ2V0KG5hbWUpID8/IG51bGw7XG4gIH1cbiAgZ2V0QWxsKCkge1xuICAgIHJldHVybiAoMCwgX3V0aWwub2JqZWN0RnJvbU1hcCkodGhpcy4jbWV0YWRhdGFNYXApO1xuICB9XG4gIGhhcyhuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuI21ldGFkYXRhTWFwLmhhcyhuYW1lKTtcbiAgfVxufVxuZXhwb3J0cy5NZXRhZGF0YSA9IE1ldGFkYXRhO1xuXG4vKioqLyB9KSxcbi8qIDE3ICovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSA9PiB7XG5cblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5leHBvcnRzLk9wdGlvbmFsQ29udGVudENvbmZpZyA9IHZvaWQgMDtcbnZhciBfdXRpbCA9IF9fd19wZGZqc19yZXF1aXJlX18oMSk7XG52YXIgX211cm11cmhhc2ggPSBfX3dfcGRmanNfcmVxdWlyZV9fKDgpO1xuY29uc3QgSU5URVJOQUwgPSBTeW1ib2woXCJJTlRFUk5BTFwiKTtcbmNsYXNzIE9wdGlvbmFsQ29udGVudEdyb3VwIHtcbiAgI3Zpc2libGUgPSB0cnVlO1xuICBjb25zdHJ1Y3RvcihuYW1lLCBpbnRlbnQpIHtcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIHRoaXMuaW50ZW50ID0gaW50ZW50O1xuICB9XG4gIGdldCB2aXNpYmxlKCkge1xuICAgIHJldHVybiB0aGlzLiN2aXNpYmxlO1xuICB9XG4gIF9zZXRWaXNpYmxlKGludGVybmFsLCB2aXNpYmxlKSB7XG4gICAgaWYgKGludGVybmFsICE9PSBJTlRFUk5BTCkge1xuICAgICAgKDAsIF91dGlsLnVucmVhY2hhYmxlKShcIkludGVybmFsIG1ldGhvZCBgX3NldFZpc2libGVgIGNhbGxlZC5cIik7XG4gICAgfVxuICAgIHRoaXMuI3Zpc2libGUgPSB2aXNpYmxlO1xuICB9XG59XG5jbGFzcyBPcHRpb25hbENvbnRlbnRDb25maWcge1xuICAjY2FjaGVkR2V0SGFzaCA9IG51bGw7XG4gICNncm91cHMgPSBuZXcgTWFwKCk7XG4gICNpbml0aWFsSGFzaCA9IG51bGw7XG4gICNvcmRlciA9IG51bGw7XG4gIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICB0aGlzLm5hbWUgPSBudWxsO1xuICAgIHRoaXMuY3JlYXRvciA9IG51bGw7XG4gICAgaWYgKGRhdGEgPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5uYW1lID0gZGF0YS5uYW1lO1xuICAgIHRoaXMuY3JlYXRvciA9IGRhdGEuY3JlYXRvcjtcbiAgICB0aGlzLiNvcmRlciA9IGRhdGEub3JkZXI7XG4gICAgZm9yIChjb25zdCBncm91cCBvZiBkYXRhLmdyb3Vwcykge1xuICAgICAgdGhpcy4jZ3JvdXBzLnNldChncm91cC5pZCwgbmV3IE9wdGlvbmFsQ29udGVudEdyb3VwKGdyb3VwLm5hbWUsIGdyb3VwLmludGVudCkpO1xuICAgIH1cbiAgICBpZiAoZGF0YS5iYXNlU3RhdGUgPT09IFwiT0ZGXCIpIHtcbiAgICAgIGZvciAoY29uc3QgZ3JvdXAgb2YgdGhpcy4jZ3JvdXBzLnZhbHVlcygpKSB7XG4gICAgICAgIGdyb3VwLl9zZXRWaXNpYmxlKElOVEVSTkFMLCBmYWxzZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoY29uc3Qgb24gb2YgZGF0YS5vbikge1xuICAgICAgdGhpcy4jZ3JvdXBzLmdldChvbikuX3NldFZpc2libGUoSU5URVJOQUwsIHRydWUpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IG9mZiBvZiBkYXRhLm9mZikge1xuICAgICAgdGhpcy4jZ3JvdXBzLmdldChvZmYpLl9zZXRWaXNpYmxlKElOVEVSTkFMLCBmYWxzZSk7XG4gICAgfVxuICAgIHRoaXMuI2luaXRpYWxIYXNoID0gdGhpcy5nZXRIYXNoKCk7XG4gIH1cbiAgI2V2YWx1YXRlVmlzaWJpbGl0eUV4cHJlc3Npb24oYXJyYXkpIHtcbiAgICBjb25zdCBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gICAgaWYgKGxlbmd0aCA8IDIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjb25zdCBvcGVyYXRvciA9IGFycmF5WzBdO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGVsZW1lbnQgPSBhcnJheVtpXTtcbiAgICAgIGxldCBzdGF0ZTtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGVsZW1lbnQpKSB7XG4gICAgICAgIHN0YXRlID0gdGhpcy4jZXZhbHVhdGVWaXNpYmlsaXR5RXhwcmVzc2lvbihlbGVtZW50KTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy4jZ3JvdXBzLmhhcyhlbGVtZW50KSkge1xuICAgICAgICBzdGF0ZSA9IHRoaXMuI2dyb3Vwcy5nZXQoZWxlbWVudCkudmlzaWJsZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICgwLCBfdXRpbC53YXJuKShgT3B0aW9uYWwgY29udGVudCBncm91cCBub3QgZm91bmQ6ICR7ZWxlbWVudH1gKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKG9wZXJhdG9yKSB7XG4gICAgICAgIGNhc2UgXCJBbmRcIjpcbiAgICAgICAgICBpZiAoIXN0YXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiT3JcIjpcbiAgICAgICAgICBpZiAoc3RhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIk5vdFwiOlxuICAgICAgICAgIHJldHVybiAhc3RhdGU7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvcGVyYXRvciA9PT0gXCJBbmRcIjtcbiAgfVxuICBpc1Zpc2libGUoZ3JvdXApIHtcbiAgICBpZiAodGhpcy4jZ3JvdXBzLnNpemUgPT09IDApIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoIWdyb3VwKSB7XG4gICAgICAoMCwgX3V0aWwud2FybikoXCJPcHRpb25hbCBjb250ZW50IGdyb3VwIG5vdCBkZWZpbmVkLlwiKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoZ3JvdXAudHlwZSA9PT0gXCJPQ0dcIikge1xuICAgICAgaWYgKCF0aGlzLiNncm91cHMuaGFzKGdyb3VwLmlkKSkge1xuICAgICAgICAoMCwgX3V0aWwud2FybikoYE9wdGlvbmFsIGNvbnRlbnQgZ3JvdXAgbm90IGZvdW5kOiAke2dyb3VwLmlkfWApO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLiNncm91cHMuZ2V0KGdyb3VwLmlkKS52aXNpYmxlO1xuICAgIH0gZWxzZSBpZiAoZ3JvdXAudHlwZSA9PT0gXCJPQ01EXCIpIHtcbiAgICAgIGlmIChncm91cC5leHByZXNzaW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNldmFsdWF0ZVZpc2liaWxpdHlFeHByZXNzaW9uKGdyb3VwLmV4cHJlc3Npb24pO1xuICAgICAgfVxuICAgICAgaWYgKCFncm91cC5wb2xpY3kgfHwgZ3JvdXAucG9saWN5ID09PSBcIkFueU9uXCIpIHtcbiAgICAgICAgZm9yIChjb25zdCBpZCBvZiBncm91cC5pZHMpIHtcbiAgICAgICAgICBpZiAoIXRoaXMuI2dyb3Vwcy5oYXMoaWQpKSB7XG4gICAgICAgICAgICAoMCwgX3V0aWwud2FybikoYE9wdGlvbmFsIGNvbnRlbnQgZ3JvdXAgbm90IGZvdW5kOiAke2lkfWApO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0aGlzLiNncm91cHMuZ2V0KGlkKS52aXNpYmxlKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIGlmIChncm91cC5wb2xpY3kgPT09IFwiQWxsT25cIikge1xuICAgICAgICBmb3IgKGNvbnN0IGlkIG9mIGdyb3VwLmlkcykge1xuICAgICAgICAgIGlmICghdGhpcy4jZ3JvdXBzLmhhcyhpZCkpIHtcbiAgICAgICAgICAgICgwLCBfdXRpbC53YXJuKShgT3B0aW9uYWwgY29udGVudCBncm91cCBub3QgZm91bmQ6ICR7aWR9YCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCF0aGlzLiNncm91cHMuZ2V0KGlkKS52aXNpYmxlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChncm91cC5wb2xpY3kgPT09IFwiQW55T2ZmXCIpIHtcbiAgICAgICAgZm9yIChjb25zdCBpZCBvZiBncm91cC5pZHMpIHtcbiAgICAgICAgICBpZiAoIXRoaXMuI2dyb3Vwcy5oYXMoaWQpKSB7XG4gICAgICAgICAgICAoMCwgX3V0aWwud2FybikoYE9wdGlvbmFsIGNvbnRlbnQgZ3JvdXAgbm90IGZvdW5kOiAke2lkfWApO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghdGhpcy4jZ3JvdXBzLmdldChpZCkudmlzaWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAoZ3JvdXAucG9saWN5ID09PSBcIkFsbE9mZlwiKSB7XG4gICAgICAgIGZvciAoY29uc3QgaWQgb2YgZ3JvdXAuaWRzKSB7XG4gICAgICAgICAgaWYgKCF0aGlzLiNncm91cHMuaGFzKGlkKSkge1xuICAgICAgICAgICAgKDAsIF91dGlsLndhcm4pKGBPcHRpb25hbCBjb250ZW50IGdyb3VwIG5vdCBmb3VuZDogJHtpZH1gKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGhpcy4jZ3JvdXBzLmdldChpZCkudmlzaWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgICgwLCBfdXRpbC53YXJuKShgVW5rbm93biBvcHRpb25hbCBjb250ZW50IHBvbGljeSAke2dyb3VwLnBvbGljeX0uYCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgKDAsIF91dGlsLndhcm4pKGBVbmtub3duIGdyb3VwIHR5cGUgJHtncm91cC50eXBlfS5gKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBzZXRWaXNpYmlsaXR5KGlkLCB2aXNpYmxlID0gdHJ1ZSkge1xuICAgIGlmICghdGhpcy4jZ3JvdXBzLmhhcyhpZCkpIHtcbiAgICAgICgwLCBfdXRpbC53YXJuKShgT3B0aW9uYWwgY29udGVudCBncm91cCBub3QgZm91bmQ6ICR7aWR9YCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2dyb3Vwcy5nZXQoaWQpLl9zZXRWaXNpYmxlKElOVEVSTkFMLCAhIXZpc2libGUpO1xuICAgIHRoaXMuI2NhY2hlZEdldEhhc2ggPSBudWxsO1xuICB9XG4gIGdldCBoYXNJbml0aWFsVmlzaWJpbGl0eSgpIHtcbiAgICByZXR1cm4gdGhpcy4jaW5pdGlhbEhhc2ggPT09IG51bGwgfHwgdGhpcy5nZXRIYXNoKCkgPT09IHRoaXMuI2luaXRpYWxIYXNoO1xuICB9XG4gIGdldE9yZGVyKCkge1xuICAgIGlmICghdGhpcy4jZ3JvdXBzLnNpemUpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAodGhpcy4jb3JkZXIpIHtcbiAgICAgIHJldHVybiB0aGlzLiNvcmRlci5zbGljZSgpO1xuICAgIH1cbiAgICByZXR1cm4gWy4uLnRoaXMuI2dyb3Vwcy5rZXlzKCldO1xuICB9XG4gIGdldEdyb3VwcygpIHtcbiAgICByZXR1cm4gdGhpcy4jZ3JvdXBzLnNpemUgPiAwID8gKDAsIF91dGlsLm9iamVjdEZyb21NYXApKHRoaXMuI2dyb3VwcykgOiBudWxsO1xuICB9XG4gIGdldEdyb3VwKGlkKSB7XG4gICAgcmV0dXJuIHRoaXMuI2dyb3Vwcy5nZXQoaWQpIHx8IG51bGw7XG4gIH1cbiAgZ2V0SGFzaCgpIHtcbiAgICBpZiAodGhpcy4jY2FjaGVkR2V0SGFzaCAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHRoaXMuI2NhY2hlZEdldEhhc2g7XG4gICAgfVxuICAgIGNvbnN0IGhhc2ggPSBuZXcgX211cm11cmhhc2guTXVybXVySGFzaDNfNjQoKTtcbiAgICBmb3IgKGNvbnN0IFtpZCwgZ3JvdXBdIG9mIHRoaXMuI2dyb3Vwcykge1xuICAgICAgaGFzaC51cGRhdGUoYCR7aWR9OiR7Z3JvdXAudmlzaWJsZX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuI2NhY2hlZEdldEhhc2ggPSBoYXNoLmhleGRpZ2VzdCgpO1xuICB9XG59XG5leHBvcnRzLk9wdGlvbmFsQ29udGVudENvbmZpZyA9IE9wdGlvbmFsQ29udGVudENvbmZpZztcblxuLyoqKi8gfSksXG4vKiAxOCAqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykgPT4ge1xuXG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xuZXhwb3J0cy5QREZEYXRhVHJhbnNwb3J0U3RyZWFtID0gdm9pZCAwO1xudmFyIF91dGlsID0gX193X3BkZmpzX3JlcXVpcmVfXygxKTtcbnZhciBfZGlzcGxheV91dGlscyA9IF9fd19wZGZqc19yZXF1aXJlX18oNik7XG5jbGFzcyBQREZEYXRhVHJhbnNwb3J0U3RyZWFtIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIGxlbmd0aCxcbiAgICBpbml0aWFsRGF0YSxcbiAgICBwcm9ncmVzc2l2ZURvbmUgPSBmYWxzZSxcbiAgICBjb250ZW50RGlzcG9zaXRpb25GaWxlbmFtZSA9IG51bGwsXG4gICAgZGlzYWJsZVJhbmdlID0gZmFsc2UsXG4gICAgZGlzYWJsZVN0cmVhbSA9IGZhbHNlXG4gIH0sIHBkZkRhdGFSYW5nZVRyYW5zcG9ydCkge1xuICAgICgwLCBfdXRpbC5hc3NlcnQpKHBkZkRhdGFSYW5nZVRyYW5zcG9ydCwgJ1BERkRhdGFUcmFuc3BvcnRTdHJlYW0gLSBtaXNzaW5nIHJlcXVpcmVkIFwicGRmRGF0YVJhbmdlVHJhbnNwb3J0XCIgYXJndW1lbnQuJyk7XG4gICAgdGhpcy5fcXVldWVkQ2h1bmtzID0gW107XG4gICAgdGhpcy5fcHJvZ3Jlc3NpdmVEb25lID0gcHJvZ3Jlc3NpdmVEb25lO1xuICAgIHRoaXMuX2NvbnRlbnREaXNwb3NpdGlvbkZpbGVuYW1lID0gY29udGVudERpc3Bvc2l0aW9uRmlsZW5hbWU7XG4gICAgaWYgKGluaXRpYWxEYXRhPy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBidWZmZXIgPSBpbml0aWFsRGF0YSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgJiYgaW5pdGlhbERhdGEuYnl0ZUxlbmd0aCA9PT0gaW5pdGlhbERhdGEuYnVmZmVyLmJ5dGVMZW5ndGggPyBpbml0aWFsRGF0YS5idWZmZXIgOiBuZXcgVWludDhBcnJheShpbml0aWFsRGF0YSkuYnVmZmVyO1xuICAgICAgdGhpcy5fcXVldWVkQ2h1bmtzLnB1c2goYnVmZmVyKTtcbiAgICB9XG4gICAgdGhpcy5fcGRmRGF0YVJhbmdlVHJhbnNwb3J0ID0gcGRmRGF0YVJhbmdlVHJhbnNwb3J0O1xuICAgIHRoaXMuX2lzU3RyZWFtaW5nU3VwcG9ydGVkID0gIWRpc2FibGVTdHJlYW07XG4gICAgdGhpcy5faXNSYW5nZVN1cHBvcnRlZCA9ICFkaXNhYmxlUmFuZ2U7XG4gICAgdGhpcy5fY29udGVudExlbmd0aCA9IGxlbmd0aDtcbiAgICB0aGlzLl9mdWxsUmVxdWVzdFJlYWRlciA9IG51bGw7XG4gICAgdGhpcy5fcmFuZ2VSZWFkZXJzID0gW107XG4gICAgdGhpcy5fcGRmRGF0YVJhbmdlVHJhbnNwb3J0LmFkZFJhbmdlTGlzdGVuZXIoKGJlZ2luLCBjaHVuaykgPT4ge1xuICAgICAgdGhpcy5fb25SZWNlaXZlRGF0YSh7XG4gICAgICAgIGJlZ2luLFxuICAgICAgICBjaHVua1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgdGhpcy5fcGRmRGF0YVJhbmdlVHJhbnNwb3J0LmFkZFByb2dyZXNzTGlzdGVuZXIoKGxvYWRlZCwgdG90YWwpID0+IHtcbiAgICAgIHRoaXMuX29uUHJvZ3Jlc3Moe1xuICAgICAgICBsb2FkZWQsXG4gICAgICAgIHRvdGFsXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICB0aGlzLl9wZGZEYXRhUmFuZ2VUcmFuc3BvcnQuYWRkUHJvZ3Jlc3NpdmVSZWFkTGlzdGVuZXIoY2h1bmsgPT4ge1xuICAgICAgdGhpcy5fb25SZWNlaXZlRGF0YSh7XG4gICAgICAgIGNodW5rXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICB0aGlzLl9wZGZEYXRhUmFuZ2VUcmFuc3BvcnQuYWRkUHJvZ3Jlc3NpdmVEb25lTGlzdGVuZXIoKCkgPT4ge1xuICAgICAgdGhpcy5fb25Qcm9ncmVzc2l2ZURvbmUoKTtcbiAgICB9KTtcbiAgICB0aGlzLl9wZGZEYXRhUmFuZ2VUcmFuc3BvcnQudHJhbnNwb3J0UmVhZHkoKTtcbiAgfVxuICBfb25SZWNlaXZlRGF0YSh7XG4gICAgYmVnaW4sXG4gICAgY2h1bmtcbiAgfSkge1xuICAgIGNvbnN0IGJ1ZmZlciA9IGNodW5rIGluc3RhbmNlb2YgVWludDhBcnJheSAmJiBjaHVuay5ieXRlTGVuZ3RoID09PSBjaHVuay5idWZmZXIuYnl0ZUxlbmd0aCA/IGNodW5rLmJ1ZmZlciA6IG5ldyBVaW50OEFycmF5KGNodW5rKS5idWZmZXI7XG4gICAgaWYgKGJlZ2luID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmICh0aGlzLl9mdWxsUmVxdWVzdFJlYWRlcikge1xuICAgICAgICB0aGlzLl9mdWxsUmVxdWVzdFJlYWRlci5fZW5xdWV1ZShidWZmZXIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fcXVldWVkQ2h1bmtzLnB1c2goYnVmZmVyKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgZm91bmQgPSB0aGlzLl9yYW5nZVJlYWRlcnMuc29tZShmdW5jdGlvbiAocmFuZ2VSZWFkZXIpIHtcbiAgICAgICAgaWYgKHJhbmdlUmVhZGVyLl9iZWdpbiAhPT0gYmVnaW4pIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmFuZ2VSZWFkZXIuX2VucXVldWUoYnVmZmVyKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9KTtcbiAgICAgICgwLCBfdXRpbC5hc3NlcnQpKGZvdW5kLCBcIl9vblJlY2VpdmVEYXRhIC0gbm8gYFBERkRhdGFUcmFuc3BvcnRTdHJlYW1SYW5nZVJlYWRlcmAgaW5zdGFuY2UgZm91bmQuXCIpO1xuICAgIH1cbiAgfVxuICBnZXQgX3Byb2dyZXNzaXZlRGF0YUxlbmd0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXI/Ll9sb2FkZWQgPz8gMDtcbiAgfVxuICBfb25Qcm9ncmVzcyhldnQpIHtcbiAgICBpZiAoZXZ0LnRvdGFsID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuX3JhbmdlUmVhZGVyc1swXT8ub25Qcm9ncmVzcz8uKHtcbiAgICAgICAgbG9hZGVkOiBldnQubG9hZGVkXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXI/Lm9uUHJvZ3Jlc3M/Lih7XG4gICAgICAgIGxvYWRlZDogZXZ0LmxvYWRlZCxcbiAgICAgICAgdG90YWw6IGV2dC50b3RhbFxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIF9vblByb2dyZXNzaXZlRG9uZSgpIHtcbiAgICB0aGlzLl9mdWxsUmVxdWVzdFJlYWRlcj8ucHJvZ3Jlc3NpdmVEb25lKCk7XG4gICAgdGhpcy5fcHJvZ3Jlc3NpdmVEb25lID0gdHJ1ZTtcbiAgfVxuICBfcmVtb3ZlUmFuZ2VSZWFkZXIocmVhZGVyKSB7XG4gICAgY29uc3QgaSA9IHRoaXMuX3JhbmdlUmVhZGVycy5pbmRleE9mKHJlYWRlcik7XG4gICAgaWYgKGkgPj0gMCkge1xuICAgICAgdGhpcy5fcmFuZ2VSZWFkZXJzLnNwbGljZShpLCAxKTtcbiAgICB9XG4gIH1cbiAgZ2V0RnVsbFJlYWRlcigpIHtcbiAgICAoMCwgX3V0aWwuYXNzZXJ0KSghdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXIsIFwiUERGRGF0YVRyYW5zcG9ydFN0cmVhbS5nZXRGdWxsUmVhZGVyIGNhbiBvbmx5IGJlIGNhbGxlZCBvbmNlLlwiKTtcbiAgICBjb25zdCBxdWV1ZWRDaHVua3MgPSB0aGlzLl9xdWV1ZWRDaHVua3M7XG4gICAgdGhpcy5fcXVldWVkQ2h1bmtzID0gbnVsbDtcbiAgICByZXR1cm4gbmV3IFBERkRhdGFUcmFuc3BvcnRTdHJlYW1SZWFkZXIodGhpcywgcXVldWVkQ2h1bmtzLCB0aGlzLl9wcm9ncmVzc2l2ZURvbmUsIHRoaXMuX2NvbnRlbnREaXNwb3NpdGlvbkZpbGVuYW1lKTtcbiAgfVxuICBnZXRSYW5nZVJlYWRlcihiZWdpbiwgZW5kKSB7XG4gICAgaWYgKGVuZCA8PSB0aGlzLl9wcm9ncmVzc2l2ZURhdGFMZW5ndGgpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCByZWFkZXIgPSBuZXcgUERGRGF0YVRyYW5zcG9ydFN0cmVhbVJhbmdlUmVhZGVyKHRoaXMsIGJlZ2luLCBlbmQpO1xuICAgIHRoaXMuX3BkZkRhdGFSYW5nZVRyYW5zcG9ydC5yZXF1ZXN0RGF0YVJhbmdlKGJlZ2luLCBlbmQpO1xuICAgIHRoaXMuX3JhbmdlUmVhZGVycy5wdXNoKHJlYWRlcik7XG4gICAgcmV0dXJuIHJlYWRlcjtcbiAgfVxuICBjYW5jZWxBbGxSZXF1ZXN0cyhyZWFzb24pIHtcbiAgICB0aGlzLl9mdWxsUmVxdWVzdFJlYWRlcj8uY2FuY2VsKHJlYXNvbik7XG4gICAgZm9yIChjb25zdCByZWFkZXIgb2YgdGhpcy5fcmFuZ2VSZWFkZXJzLnNsaWNlKDApKSB7XG4gICAgICByZWFkZXIuY2FuY2VsKHJlYXNvbik7XG4gICAgfVxuICAgIHRoaXMuX3BkZkRhdGFSYW5nZVRyYW5zcG9ydC5hYm9ydCgpO1xuICB9XG59XG5leHBvcnRzLlBERkRhdGFUcmFuc3BvcnRTdHJlYW0gPSBQREZEYXRhVHJhbnNwb3J0U3RyZWFtO1xuY2xhc3MgUERGRGF0YVRyYW5zcG9ydFN0cmVhbVJlYWRlciB7XG4gIGNvbnN0cnVjdG9yKHN0cmVhbSwgcXVldWVkQ2h1bmtzLCBwcm9ncmVzc2l2ZURvbmUgPSBmYWxzZSwgY29udGVudERpc3Bvc2l0aW9uRmlsZW5hbWUgPSBudWxsKSB7XG4gICAgdGhpcy5fc3RyZWFtID0gc3RyZWFtO1xuICAgIHRoaXMuX2RvbmUgPSBwcm9ncmVzc2l2ZURvbmUgfHwgZmFsc2U7XG4gICAgdGhpcy5fZmlsZW5hbWUgPSAoMCwgX2Rpc3BsYXlfdXRpbHMuaXNQZGZGaWxlKShjb250ZW50RGlzcG9zaXRpb25GaWxlbmFtZSkgPyBjb250ZW50RGlzcG9zaXRpb25GaWxlbmFtZSA6IG51bGw7XG4gICAgdGhpcy5fcXVldWVkQ2h1bmtzID0gcXVldWVkQ2h1bmtzIHx8IFtdO1xuICAgIHRoaXMuX2xvYWRlZCA9IDA7XG4gICAgZm9yIChjb25zdCBjaHVuayBvZiB0aGlzLl9xdWV1ZWRDaHVua3MpIHtcbiAgICAgIHRoaXMuX2xvYWRlZCArPSBjaHVuay5ieXRlTGVuZ3RoO1xuICAgIH1cbiAgICB0aGlzLl9yZXF1ZXN0cyA9IFtdO1xuICAgIHRoaXMuX2hlYWRlcnNSZWFkeSA9IFByb21pc2UucmVzb2x2ZSgpO1xuICAgIHN0cmVhbS5fZnVsbFJlcXVlc3RSZWFkZXIgPSB0aGlzO1xuICAgIHRoaXMub25Qcm9ncmVzcyA9IG51bGw7XG4gIH1cbiAgX2VucXVldWUoY2h1bmspIHtcbiAgICBpZiAodGhpcy5fZG9uZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5fcmVxdWVzdHMubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgcmVxdWVzdENhcGFiaWxpdHkgPSB0aGlzLl9yZXF1ZXN0cy5zaGlmdCgpO1xuICAgICAgcmVxdWVzdENhcGFiaWxpdHkucmVzb2x2ZSh7XG4gICAgICAgIHZhbHVlOiBjaHVuayxcbiAgICAgICAgZG9uZTogZmFsc2VcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9xdWV1ZWRDaHVua3MucHVzaChjaHVuayk7XG4gICAgfVxuICAgIHRoaXMuX2xvYWRlZCArPSBjaHVuay5ieXRlTGVuZ3RoO1xuICB9XG4gIGdldCBoZWFkZXJzUmVhZHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2hlYWRlcnNSZWFkeTtcbiAgfVxuICBnZXQgZmlsZW5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZpbGVuYW1lO1xuICB9XG4gIGdldCBpc1JhbmdlU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiB0aGlzLl9zdHJlYW0uX2lzUmFuZ2VTdXBwb3J0ZWQ7XG4gIH1cbiAgZ2V0IGlzU3RyZWFtaW5nU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiB0aGlzLl9zdHJlYW0uX2lzU3RyZWFtaW5nU3VwcG9ydGVkO1xuICB9XG4gIGdldCBjb250ZW50TGVuZ3RoKCkge1xuICAgIHJldHVybiB0aGlzLl9zdHJlYW0uX2NvbnRlbnRMZW5ndGg7XG4gIH1cbiAgYXN5bmMgcmVhZCgpIHtcbiAgICBpZiAodGhpcy5fcXVldWVkQ2h1bmtzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IGNodW5rID0gdGhpcy5fcXVldWVkQ2h1bmtzLnNoaWZ0KCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogY2h1bmssXG4gICAgICAgIGRvbmU6IGZhbHNlXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAodGhpcy5fZG9uZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgcmVxdWVzdENhcGFiaWxpdHkgPSBuZXcgX3V0aWwuUHJvbWlzZUNhcGFiaWxpdHkoKTtcbiAgICB0aGlzLl9yZXF1ZXN0cy5wdXNoKHJlcXVlc3RDYXBhYmlsaXR5KTtcbiAgICByZXR1cm4gcmVxdWVzdENhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxuICBjYW5jZWwocmVhc29uKSB7XG4gICAgdGhpcy5fZG9uZSA9IHRydWU7XG4gICAgZm9yIChjb25zdCByZXF1ZXN0Q2FwYWJpbGl0eSBvZiB0aGlzLl9yZXF1ZXN0cykge1xuICAgICAgcmVxdWVzdENhcGFiaWxpdHkucmVzb2x2ZSh7XG4gICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgIGRvbmU6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLl9yZXF1ZXN0cy5sZW5ndGggPSAwO1xuICB9XG4gIHByb2dyZXNzaXZlRG9uZSgpIHtcbiAgICBpZiAodGhpcy5fZG9uZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9kb25lID0gdHJ1ZTtcbiAgfVxufVxuY2xhc3MgUERGRGF0YVRyYW5zcG9ydFN0cmVhbVJhbmdlUmVhZGVyIHtcbiAgY29uc3RydWN0b3Ioc3RyZWFtLCBiZWdpbiwgZW5kKSB7XG4gICAgdGhpcy5fc3RyZWFtID0gc3RyZWFtO1xuICAgIHRoaXMuX2JlZ2luID0gYmVnaW47XG4gICAgdGhpcy5fZW5kID0gZW5kO1xuICAgIHRoaXMuX3F1ZXVlZENodW5rID0gbnVsbDtcbiAgICB0aGlzLl9yZXF1ZXN0cyA9IFtdO1xuICAgIHRoaXMuX2RvbmUgPSBmYWxzZTtcbiAgICB0aGlzLm9uUHJvZ3Jlc3MgPSBudWxsO1xuICB9XG4gIF9lbnF1ZXVlKGNodW5rKSB7XG4gICAgaWYgKHRoaXMuX2RvbmUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3JlcXVlc3RzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy5fcXVldWVkQ2h1bmsgPSBjaHVuaztcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgcmVxdWVzdHNDYXBhYmlsaXR5ID0gdGhpcy5fcmVxdWVzdHMuc2hpZnQoKTtcbiAgICAgIHJlcXVlc3RzQ2FwYWJpbGl0eS5yZXNvbHZlKHtcbiAgICAgICAgdmFsdWU6IGNodW5rLFxuICAgICAgICBkb25lOiBmYWxzZVxuICAgICAgfSk7XG4gICAgICBmb3IgKGNvbnN0IHJlcXVlc3RDYXBhYmlsaXR5IG9mIHRoaXMuX3JlcXVlc3RzKSB7XG4gICAgICAgIHJlcXVlc3RDYXBhYmlsaXR5LnJlc29sdmUoe1xuICAgICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3JlcXVlc3RzLmxlbmd0aCA9IDA7XG4gICAgfVxuICAgIHRoaXMuX2RvbmUgPSB0cnVlO1xuICAgIHRoaXMuX3N0cmVhbS5fcmVtb3ZlUmFuZ2VSZWFkZXIodGhpcyk7XG4gIH1cbiAgZ2V0IGlzU3RyZWFtaW5nU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBhc3luYyByZWFkKCkge1xuICAgIGlmICh0aGlzLl9xdWV1ZWRDaHVuaykge1xuICAgICAgY29uc3QgY2h1bmsgPSB0aGlzLl9xdWV1ZWRDaHVuaztcbiAgICAgIHRoaXMuX3F1ZXVlZENodW5rID0gbnVsbDtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiBjaHVuayxcbiAgICAgICAgZG9uZTogZmFsc2VcbiAgICAgIH07XG4gICAgfVxuICAgIGlmICh0aGlzLl9kb25lKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICBkb25lOiB0cnVlXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCByZXF1ZXN0Q2FwYWJpbGl0eSA9IG5ldyBfdXRpbC5Qcm9taXNlQ2FwYWJpbGl0eSgpO1xuICAgIHRoaXMuX3JlcXVlc3RzLnB1c2gocmVxdWVzdENhcGFiaWxpdHkpO1xuICAgIHJldHVybiByZXF1ZXN0Q2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG4gIGNhbmNlbChyZWFzb24pIHtcbiAgICB0aGlzLl9kb25lID0gdHJ1ZTtcbiAgICBmb3IgKGNvbnN0IHJlcXVlc3RDYXBhYmlsaXR5IG9mIHRoaXMuX3JlcXVlc3RzKSB7XG4gICAgICByZXF1ZXN0Q2FwYWJpbGl0eS5yZXNvbHZlKHtcbiAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMuX3JlcXVlc3RzLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5fc3RyZWFtLl9yZW1vdmVSYW5nZVJlYWRlcih0aGlzKTtcbiAgfVxufVxuXG4vKioqLyB9KSxcbi8qIDE5ICovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSA9PiB7XG5cblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5leHBvcnRzLlBERkZldGNoU3RyZWFtID0gdm9pZCAwO1xudmFyIF91dGlsID0gX193X3BkZmpzX3JlcXVpcmVfXygxKTtcbnZhciBfbmV0d29ya191dGlscyA9IF9fd19wZGZqc19yZXF1aXJlX18oMjApO1xuO1xuZnVuY3Rpb24gY3JlYXRlRmV0Y2hPcHRpb25zKGhlYWRlcnMsIHdpdGhDcmVkZW50aWFscywgYWJvcnRDb250cm9sbGVyKSB7XG4gIHJldHVybiB7XG4gICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgIGhlYWRlcnMsXG4gICAgc2lnbmFsOiBhYm9ydENvbnRyb2xsZXIuc2lnbmFsLFxuICAgIG1vZGU6IFwiY29yc1wiLFxuICAgIGNyZWRlbnRpYWxzOiB3aXRoQ3JlZGVudGlhbHMgPyBcImluY2x1ZGVcIiA6IFwic2FtZS1vcmlnaW5cIixcbiAgICByZWRpcmVjdDogXCJmb2xsb3dcIlxuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlSGVhZGVycyhodHRwSGVhZGVycykge1xuICBjb25zdCBoZWFkZXJzID0gbmV3IEhlYWRlcnMoKTtcbiAgZm9yIChjb25zdCBwcm9wZXJ0eSBpbiBodHRwSGVhZGVycykge1xuICAgIGNvbnN0IHZhbHVlID0gaHR0cEhlYWRlcnNbcHJvcGVydHldO1xuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaGVhZGVycy5hcHBlbmQocHJvcGVydHksIHZhbHVlKTtcbiAgfVxuICByZXR1cm4gaGVhZGVycztcbn1cbmZ1bmN0aW9uIGdldEFycmF5QnVmZmVyKHZhbCkge1xuICBpZiAodmFsIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgIHJldHVybiB2YWwuYnVmZmVyO1xuICB9XG4gIGlmICh2YWwgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiB2YWw7XG4gIH1cbiAgKDAsIF91dGlsLndhcm4pKGBnZXRBcnJheUJ1ZmZlciAtIHVuZXhwZWN0ZWQgZGF0YSBmb3JtYXQ6ICR7dmFsfWApO1xuICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkodmFsKS5idWZmZXI7XG59XG5jbGFzcyBQREZGZXRjaFN0cmVhbSB7XG4gIGNvbnN0cnVjdG9yKHNvdXJjZSkge1xuICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgIHRoaXMuaXNIdHRwID0gL15odHRwcz86L2kudGVzdChzb3VyY2UudXJsKTtcbiAgICB0aGlzLmh0dHBIZWFkZXJzID0gdGhpcy5pc0h0dHAgJiYgc291cmNlLmh0dHBIZWFkZXJzIHx8IHt9O1xuICAgIHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyID0gbnVsbDtcbiAgICB0aGlzLl9yYW5nZVJlcXVlc3RSZWFkZXJzID0gW107XG4gIH1cbiAgZ2V0IF9wcm9ncmVzc2l2ZURhdGFMZW5ndGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyPy5fbG9hZGVkID8/IDA7XG4gIH1cbiAgZ2V0RnVsbFJlYWRlcigpIHtcbiAgICAoMCwgX3V0aWwuYXNzZXJ0KSghdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXIsIFwiUERGRmV0Y2hTdHJlYW0uZ2V0RnVsbFJlYWRlciBjYW4gb25seSBiZSBjYWxsZWQgb25jZS5cIik7XG4gICAgdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXIgPSBuZXcgUERGRmV0Y2hTdHJlYW1SZWFkZXIodGhpcyk7XG4gICAgcmV0dXJuIHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyO1xuICB9XG4gIGdldFJhbmdlUmVhZGVyKGJlZ2luLCBlbmQpIHtcbiAgICBpZiAoZW5kIDw9IHRoaXMuX3Byb2dyZXNzaXZlRGF0YUxlbmd0aCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHJlYWRlciA9IG5ldyBQREZGZXRjaFN0cmVhbVJhbmdlUmVhZGVyKHRoaXMsIGJlZ2luLCBlbmQpO1xuICAgIHRoaXMuX3JhbmdlUmVxdWVzdFJlYWRlcnMucHVzaChyZWFkZXIpO1xuICAgIHJldHVybiByZWFkZXI7XG4gIH1cbiAgY2FuY2VsQWxsUmVxdWVzdHMocmVhc29uKSB7XG4gICAgdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXI/LmNhbmNlbChyZWFzb24pO1xuICAgIGZvciAoY29uc3QgcmVhZGVyIG9mIHRoaXMuX3JhbmdlUmVxdWVzdFJlYWRlcnMuc2xpY2UoMCkpIHtcbiAgICAgIHJlYWRlci5jYW5jZWwocmVhc29uKTtcbiAgICB9XG4gIH1cbn1cbmV4cG9ydHMuUERGRmV0Y2hTdHJlYW0gPSBQREZGZXRjaFN0cmVhbTtcbmNsYXNzIFBERkZldGNoU3RyZWFtUmVhZGVyIHtcbiAgY29uc3RydWN0b3Ioc3RyZWFtKSB7XG4gICAgdGhpcy5fc3RyZWFtID0gc3RyZWFtO1xuICAgIHRoaXMuX3JlYWRlciA9IG51bGw7XG4gICAgdGhpcy5fbG9hZGVkID0gMDtcbiAgICB0aGlzLl9maWxlbmFtZSA9IG51bGw7XG4gICAgY29uc3Qgc291cmNlID0gc3RyZWFtLnNvdXJjZTtcbiAgICB0aGlzLl93aXRoQ3JlZGVudGlhbHMgPSBzb3VyY2Uud2l0aENyZWRlbnRpYWxzIHx8IGZhbHNlO1xuICAgIHRoaXMuX2NvbnRlbnRMZW5ndGggPSBzb3VyY2UubGVuZ3RoO1xuICAgIHRoaXMuX2hlYWRlcnNDYXBhYmlsaXR5ID0gbmV3IF91dGlsLlByb21pc2VDYXBhYmlsaXR5KCk7XG4gICAgdGhpcy5fZGlzYWJsZVJhbmdlID0gc291cmNlLmRpc2FibGVSYW5nZSB8fCBmYWxzZTtcbiAgICB0aGlzLl9yYW5nZUNodW5rU2l6ZSA9IHNvdXJjZS5yYW5nZUNodW5rU2l6ZTtcbiAgICBpZiAoIXRoaXMuX3JhbmdlQ2h1bmtTaXplICYmICF0aGlzLl9kaXNhYmxlUmFuZ2UpIHtcbiAgICAgIHRoaXMuX2Rpc2FibGVSYW5nZSA9IHRydWU7XG4gICAgfVxuICAgIHRoaXMuX2Fib3J0Q29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICB0aGlzLl9pc1N0cmVhbWluZ1N1cHBvcnRlZCA9ICFzb3VyY2UuZGlzYWJsZVN0cmVhbTtcbiAgICB0aGlzLl9pc1JhbmdlU3VwcG9ydGVkID0gIXNvdXJjZS5kaXNhYmxlUmFuZ2U7XG4gICAgdGhpcy5faGVhZGVycyA9IGNyZWF0ZUhlYWRlcnModGhpcy5fc3RyZWFtLmh0dHBIZWFkZXJzKTtcbiAgICBjb25zdCB1cmwgPSBzb3VyY2UudXJsO1xuICAgIGZldGNoKHVybCwgY3JlYXRlRmV0Y2hPcHRpb25zKHRoaXMuX2hlYWRlcnMsIHRoaXMuX3dpdGhDcmVkZW50aWFscywgdGhpcy5fYWJvcnRDb250cm9sbGVyKSkudGhlbihyZXNwb25zZSA9PiB7XG4gICAgICBpZiAoISgwLCBfbmV0d29ya191dGlscy52YWxpZGF0ZVJlc3BvbnNlU3RhdHVzKShyZXNwb25zZS5zdGF0dXMpKSB7XG4gICAgICAgIHRocm93ICgwLCBfbmV0d29ya191dGlscy5jcmVhdGVSZXNwb25zZVN0YXR1c0Vycm9yKShyZXNwb25zZS5zdGF0dXMsIHVybCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9yZWFkZXIgPSByZXNwb25zZS5ib2R5LmdldFJlYWRlcigpO1xuICAgICAgdGhpcy5faGVhZGVyc0NhcGFiaWxpdHkucmVzb2x2ZSgpO1xuICAgICAgY29uc3QgZ2V0UmVzcG9uc2VIZWFkZXIgPSBuYW1lID0+IHtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmhlYWRlcnMuZ2V0KG5hbWUpO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgYWxsb3dSYW5nZVJlcXVlc3RzLFxuICAgICAgICBzdWdnZXN0ZWRMZW5ndGhcbiAgICAgIH0gPSAoMCwgX25ldHdvcmtfdXRpbHMudmFsaWRhdGVSYW5nZVJlcXVlc3RDYXBhYmlsaXRpZXMpKHtcbiAgICAgICAgZ2V0UmVzcG9uc2VIZWFkZXIsXG4gICAgICAgIGlzSHR0cDogdGhpcy5fc3RyZWFtLmlzSHR0cCxcbiAgICAgICAgcmFuZ2VDaHVua1NpemU6IHRoaXMuX3JhbmdlQ2h1bmtTaXplLFxuICAgICAgICBkaXNhYmxlUmFuZ2U6IHRoaXMuX2Rpc2FibGVSYW5nZVxuICAgICAgfSk7XG4gICAgICB0aGlzLl9pc1JhbmdlU3VwcG9ydGVkID0gYWxsb3dSYW5nZVJlcXVlc3RzO1xuICAgICAgdGhpcy5fY29udGVudExlbmd0aCA9IHN1Z2dlc3RlZExlbmd0aCB8fCB0aGlzLl9jb250ZW50TGVuZ3RoO1xuICAgICAgdGhpcy5fZmlsZW5hbWUgPSAoMCwgX25ldHdvcmtfdXRpbHMuZXh0cmFjdEZpbGVuYW1lRnJvbUhlYWRlcikoZ2V0UmVzcG9uc2VIZWFkZXIpO1xuICAgICAgaWYgKCF0aGlzLl9pc1N0cmVhbWluZ1N1cHBvcnRlZCAmJiB0aGlzLl9pc1JhbmdlU3VwcG9ydGVkKSB7XG4gICAgICAgIHRoaXMuY2FuY2VsKG5ldyBfdXRpbC5BYm9ydEV4Y2VwdGlvbihcIlN0cmVhbWluZyBpcyBkaXNhYmxlZC5cIikpO1xuICAgICAgfVxuICAgIH0pLmNhdGNoKHRoaXMuX2hlYWRlcnNDYXBhYmlsaXR5LnJlamVjdCk7XG4gICAgdGhpcy5vblByb2dyZXNzID0gbnVsbDtcbiAgfVxuICBnZXQgaGVhZGVyc1JlYWR5KCkge1xuICAgIHJldHVybiB0aGlzLl9oZWFkZXJzQ2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG4gIGdldCBmaWxlbmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZmlsZW5hbWU7XG4gIH1cbiAgZ2V0IGNvbnRlbnRMZW5ndGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbnRlbnRMZW5ndGg7XG4gIH1cbiAgZ2V0IGlzUmFuZ2VTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lzUmFuZ2VTdXBwb3J0ZWQ7XG4gIH1cbiAgZ2V0IGlzU3RyZWFtaW5nU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiB0aGlzLl9pc1N0cmVhbWluZ1N1cHBvcnRlZDtcbiAgfVxuICBhc3luYyByZWFkKCkge1xuICAgIGF3YWl0IHRoaXMuX2hlYWRlcnNDYXBhYmlsaXR5LnByb21pc2U7XG4gICAgY29uc3Qge1xuICAgICAgdmFsdWUsXG4gICAgICBkb25lXG4gICAgfSA9IGF3YWl0IHRoaXMuX3JlYWRlci5yZWFkKCk7XG4gICAgaWYgKGRvbmUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlLFxuICAgICAgICBkb25lXG4gICAgICB9O1xuICAgIH1cbiAgICB0aGlzLl9sb2FkZWQgKz0gdmFsdWUuYnl0ZUxlbmd0aDtcbiAgICB0aGlzLm9uUHJvZ3Jlc3M/Lih7XG4gICAgICBsb2FkZWQ6IHRoaXMuX2xvYWRlZCxcbiAgICAgIHRvdGFsOiB0aGlzLl9jb250ZW50TGVuZ3RoXG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHZhbHVlOiBnZXRBcnJheUJ1ZmZlcih2YWx1ZSksXG4gICAgICBkb25lOiBmYWxzZVxuICAgIH07XG4gIH1cbiAgY2FuY2VsKHJlYXNvbikge1xuICAgIHRoaXMuX3JlYWRlcj8uY2FuY2VsKHJlYXNvbik7XG4gICAgdGhpcy5fYWJvcnRDb250cm9sbGVyLmFib3J0KCk7XG4gIH1cbn1cbmNsYXNzIFBERkZldGNoU3RyZWFtUmFuZ2VSZWFkZXIge1xuICBjb25zdHJ1Y3RvcihzdHJlYW0sIGJlZ2luLCBlbmQpIHtcbiAgICB0aGlzLl9zdHJlYW0gPSBzdHJlYW07XG4gICAgdGhpcy5fcmVhZGVyID0gbnVsbDtcbiAgICB0aGlzLl9sb2FkZWQgPSAwO1xuICAgIGNvbnN0IHNvdXJjZSA9IHN0cmVhbS5zb3VyY2U7XG4gICAgdGhpcy5fd2l0aENyZWRlbnRpYWxzID0gc291cmNlLndpdGhDcmVkZW50aWFscyB8fCBmYWxzZTtcbiAgICB0aGlzLl9yZWFkQ2FwYWJpbGl0eSA9IG5ldyBfdXRpbC5Qcm9taXNlQ2FwYWJpbGl0eSgpO1xuICAgIHRoaXMuX2lzU3RyZWFtaW5nU3VwcG9ydGVkID0gIXNvdXJjZS5kaXNhYmxlU3RyZWFtO1xuICAgIHRoaXMuX2Fib3J0Q29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICB0aGlzLl9oZWFkZXJzID0gY3JlYXRlSGVhZGVycyh0aGlzLl9zdHJlYW0uaHR0cEhlYWRlcnMpO1xuICAgIHRoaXMuX2hlYWRlcnMuYXBwZW5kKFwiUmFuZ2VcIiwgYGJ5dGVzPSR7YmVnaW59LSR7ZW5kIC0gMX1gKTtcbiAgICBjb25zdCB1cmwgPSBzb3VyY2UudXJsO1xuICAgIGZldGNoKHVybCwgY3JlYXRlRmV0Y2hPcHRpb25zKHRoaXMuX2hlYWRlcnMsIHRoaXMuX3dpdGhDcmVkZW50aWFscywgdGhpcy5fYWJvcnRDb250cm9sbGVyKSkudGhlbihyZXNwb25zZSA9PiB7XG4gICAgICBpZiAoISgwLCBfbmV0d29ya191dGlscy52YWxpZGF0ZVJlc3BvbnNlU3RhdHVzKShyZXNwb25zZS5zdGF0dXMpKSB7XG4gICAgICAgIHRocm93ICgwLCBfbmV0d29ya191dGlscy5jcmVhdGVSZXNwb25zZVN0YXR1c0Vycm9yKShyZXNwb25zZS5zdGF0dXMsIHVybCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9yZWFkQ2FwYWJpbGl0eS5yZXNvbHZlKCk7XG4gICAgICB0aGlzLl9yZWFkZXIgPSByZXNwb25zZS5ib2R5LmdldFJlYWRlcigpO1xuICAgIH0pLmNhdGNoKHRoaXMuX3JlYWRDYXBhYmlsaXR5LnJlamVjdCk7XG4gICAgdGhpcy5vblByb2dyZXNzID0gbnVsbDtcbiAgfVxuICBnZXQgaXNTdHJlYW1pbmdTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lzU3RyZWFtaW5nU3VwcG9ydGVkO1xuICB9XG4gIGFzeW5jIHJlYWQoKSB7XG4gICAgYXdhaXQgdGhpcy5fcmVhZENhcGFiaWxpdHkucHJvbWlzZTtcbiAgICBjb25zdCB7XG4gICAgICB2YWx1ZSxcbiAgICAgIGRvbmVcbiAgICB9ID0gYXdhaXQgdGhpcy5fcmVhZGVyLnJlYWQoKTtcbiAgICBpZiAoZG9uZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIGRvbmVcbiAgICAgIH07XG4gICAgfVxuICAgIHRoaXMuX2xvYWRlZCArPSB2YWx1ZS5ieXRlTGVuZ3RoO1xuICAgIHRoaXMub25Qcm9ncmVzcz8uKHtcbiAgICAgIGxvYWRlZDogdGhpcy5fbG9hZGVkXG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHZhbHVlOiBnZXRBcnJheUJ1ZmZlcih2YWx1ZSksXG4gICAgICBkb25lOiBmYWxzZVxuICAgIH07XG4gIH1cbiAgY2FuY2VsKHJlYXNvbikge1xuICAgIHRoaXMuX3JlYWRlcj8uY2FuY2VsKHJlYXNvbik7XG4gICAgdGhpcy5fYWJvcnRDb250cm9sbGVyLmFib3J0KCk7XG4gIH1cbn1cblxuLyoqKi8gfSksXG4vKiAyMCAqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykgPT4ge1xuXG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xuZXhwb3J0cy5jcmVhdGVSZXNwb25zZVN0YXR1c0Vycm9yID0gY3JlYXRlUmVzcG9uc2VTdGF0dXNFcnJvcjtcbmV4cG9ydHMuZXh0cmFjdEZpbGVuYW1lRnJvbUhlYWRlciA9IGV4dHJhY3RGaWxlbmFtZUZyb21IZWFkZXI7XG5leHBvcnRzLnZhbGlkYXRlUmFuZ2VSZXF1ZXN0Q2FwYWJpbGl0aWVzID0gdmFsaWRhdGVSYW5nZVJlcXVlc3RDYXBhYmlsaXRpZXM7XG5leHBvcnRzLnZhbGlkYXRlUmVzcG9uc2VTdGF0dXMgPSB2YWxpZGF0ZVJlc3BvbnNlU3RhdHVzO1xudmFyIF91dGlsID0gX193X3BkZmpzX3JlcXVpcmVfXygxKTtcbnZhciBfY29udGVudF9kaXNwb3NpdGlvbiA9IF9fd19wZGZqc19yZXF1aXJlX18oMjEpO1xudmFyIF9kaXNwbGF5X3V0aWxzID0gX193X3BkZmpzX3JlcXVpcmVfXyg2KTtcbmZ1bmN0aW9uIHZhbGlkYXRlUmFuZ2VSZXF1ZXN0Q2FwYWJpbGl0aWVzKHtcbiAgZ2V0UmVzcG9uc2VIZWFkZXIsXG4gIGlzSHR0cCxcbiAgcmFuZ2VDaHVua1NpemUsXG4gIGRpc2FibGVSYW5nZVxufSkge1xuICBjb25zdCByZXR1cm5WYWx1ZXMgPSB7XG4gICAgYWxsb3dSYW5nZVJlcXVlc3RzOiBmYWxzZSxcbiAgICBzdWdnZXN0ZWRMZW5ndGg6IHVuZGVmaW5lZFxuICB9O1xuICBjb25zdCBsZW5ndGggPSBwYXJzZUludChnZXRSZXNwb25zZUhlYWRlcihcIkNvbnRlbnQtTGVuZ3RoXCIpLCAxMCk7XG4gIGlmICghTnVtYmVyLmlzSW50ZWdlcihsZW5ndGgpKSB7XG4gICAgcmV0dXJuIHJldHVyblZhbHVlcztcbiAgfVxuICByZXR1cm5WYWx1ZXMuc3VnZ2VzdGVkTGVuZ3RoID0gbGVuZ3RoO1xuICBpZiAobGVuZ3RoIDw9IDIgKiByYW5nZUNodW5rU2l6ZSkge1xuICAgIHJldHVybiByZXR1cm5WYWx1ZXM7XG4gIH1cbiAgaWYgKGRpc2FibGVSYW5nZSB8fCAhaXNIdHRwKSB7XG4gICAgcmV0dXJuIHJldHVyblZhbHVlcztcbiAgfVxuICBpZiAoZ2V0UmVzcG9uc2VIZWFkZXIoXCJBY2NlcHQtUmFuZ2VzXCIpICE9PSBcImJ5dGVzXCIpIHtcbiAgICByZXR1cm4gcmV0dXJuVmFsdWVzO1xuICB9XG4gIGNvbnN0IGNvbnRlbnRFbmNvZGluZyA9IGdldFJlc3BvbnNlSGVhZGVyKFwiQ29udGVudC1FbmNvZGluZ1wiKSB8fCBcImlkZW50aXR5XCI7XG4gIGlmIChjb250ZW50RW5jb2RpbmcgIT09IFwiaWRlbnRpdHlcIikge1xuICAgIHJldHVybiByZXR1cm5WYWx1ZXM7XG4gIH1cbiAgcmV0dXJuVmFsdWVzLmFsbG93UmFuZ2VSZXF1ZXN0cyA9IHRydWU7XG4gIHJldHVybiByZXR1cm5WYWx1ZXM7XG59XG5mdW5jdGlvbiBleHRyYWN0RmlsZW5hbWVGcm9tSGVhZGVyKGdldFJlc3BvbnNlSGVhZGVyKSB7XG4gIGNvbnN0IGNvbnRlbnREaXNwb3NpdGlvbiA9IGdldFJlc3BvbnNlSGVhZGVyKFwiQ29udGVudC1EaXNwb3NpdGlvblwiKTtcbiAgaWYgKGNvbnRlbnREaXNwb3NpdGlvbikge1xuICAgIGxldCBmaWxlbmFtZSA9ICgwLCBfY29udGVudF9kaXNwb3NpdGlvbi5nZXRGaWxlbmFtZUZyb21Db250ZW50RGlzcG9zaXRpb25IZWFkZXIpKGNvbnRlbnREaXNwb3NpdGlvbik7XG4gICAgaWYgKGZpbGVuYW1lLmluY2x1ZGVzKFwiJVwiKSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZmlsZW5hbWUgPSBkZWNvZGVVUklDb21wb25lbnQoZmlsZW5hbWUpO1xuICAgICAgfSBjYXRjaCB7fVxuICAgIH1cbiAgICBpZiAoKDAsIF9kaXNwbGF5X3V0aWxzLmlzUGRmRmlsZSkoZmlsZW5hbWUpKSB7XG4gICAgICByZXR1cm4gZmlsZW5hbWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gY3JlYXRlUmVzcG9uc2VTdGF0dXNFcnJvcihzdGF0dXMsIHVybCkge1xuICBpZiAoc3RhdHVzID09PSA0MDQgfHwgc3RhdHVzID09PSAwICYmIHVybC5zdGFydHNXaXRoKFwiZmlsZTpcIikpIHtcbiAgICByZXR1cm4gbmV3IF91dGlsLk1pc3NpbmdQREZFeGNlcHRpb24oJ01pc3NpbmcgUERGIFwiJyArIHVybCArICdcIi4nKTtcbiAgfVxuICByZXR1cm4gbmV3IF91dGlsLlVuZXhwZWN0ZWRSZXNwb25zZUV4Y2VwdGlvbihgVW5leHBlY3RlZCBzZXJ2ZXIgcmVzcG9uc2UgKCR7c3RhdHVzfSkgd2hpbGUgcmV0cmlldmluZyBQREYgXCIke3VybH1cIi5gLCBzdGF0dXMpO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVSZXNwb25zZVN0YXR1cyhzdGF0dXMpIHtcbiAgcmV0dXJuIHN0YXR1cyA9PT0gMjAwIHx8IHN0YXR1cyA9PT0gMjA2O1xufVxuXG4vKioqLyB9KSxcbi8qIDIxICovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSA9PiB7XG5cblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5leHBvcnRzLmdldEZpbGVuYW1lRnJvbUNvbnRlbnREaXNwb3NpdGlvbkhlYWRlciA9IGdldEZpbGVuYW1lRnJvbUNvbnRlbnREaXNwb3NpdGlvbkhlYWRlcjtcbnZhciBfdXRpbCA9IF9fd19wZGZqc19yZXF1aXJlX18oMSk7XG5mdW5jdGlvbiBnZXRGaWxlbmFtZUZyb21Db250ZW50RGlzcG9zaXRpb25IZWFkZXIoY29udGVudERpc3Bvc2l0aW9uKSB7XG4gIGxldCBuZWVkc0VuY29kaW5nRml4dXAgPSB0cnVlO1xuICBsZXQgdG1wID0gdG9QYXJhbVJlZ0V4cChcImZpbGVuYW1lXFxcXCpcIiwgXCJpXCIpLmV4ZWMoY29udGVudERpc3Bvc2l0aW9uKTtcbiAgaWYgKHRtcCkge1xuICAgIHRtcCA9IHRtcFsxXTtcbiAgICBsZXQgZmlsZW5hbWUgPSByZmMyNjE2dW5xdW90ZSh0bXApO1xuICAgIGZpbGVuYW1lID0gdW5lc2NhcGUoZmlsZW5hbWUpO1xuICAgIGZpbGVuYW1lID0gcmZjNTk4N2RlY29kZShmaWxlbmFtZSk7XG4gICAgZmlsZW5hbWUgPSByZmMyMDQ3ZGVjb2RlKGZpbGVuYW1lKTtcbiAgICByZXR1cm4gZml4dXBFbmNvZGluZyhmaWxlbmFtZSk7XG4gIH1cbiAgdG1wID0gcmZjMjIzMWdldHBhcmFtKGNvbnRlbnREaXNwb3NpdGlvbik7XG4gIGlmICh0bXApIHtcbiAgICBjb25zdCBmaWxlbmFtZSA9IHJmYzIwNDdkZWNvZGUodG1wKTtcbiAgICByZXR1cm4gZml4dXBFbmNvZGluZyhmaWxlbmFtZSk7XG4gIH1cbiAgdG1wID0gdG9QYXJhbVJlZ0V4cChcImZpbGVuYW1lXCIsIFwiaVwiKS5leGVjKGNvbnRlbnREaXNwb3NpdGlvbik7XG4gIGlmICh0bXApIHtcbiAgICB0bXAgPSB0bXBbMV07XG4gICAgbGV0IGZpbGVuYW1lID0gcmZjMjYxNnVucXVvdGUodG1wKTtcbiAgICBmaWxlbmFtZSA9IHJmYzIwNDdkZWNvZGUoZmlsZW5hbWUpO1xuICAgIHJldHVybiBmaXh1cEVuY29kaW5nKGZpbGVuYW1lKTtcbiAgfVxuICBmdW5jdGlvbiB0b1BhcmFtUmVnRXhwKGF0dHJpYnV0ZVBhdHRlcm4sIGZsYWdzKSB7XG4gICAgcmV0dXJuIG5ldyBSZWdFeHAoXCIoPzpefDspXFxcXHMqXCIgKyBhdHRyaWJ1dGVQYXR0ZXJuICsgXCJcXFxccyo9XFxcXHMqXCIgKyBcIihcIiArICdbXlwiO1xcXFxzXVteO1xcXFxzXSonICsgXCJ8XCIgKyAnXCIoPzpbXlwiXFxcXFxcXFxdfFxcXFxcXFxcXCI/KStcIj8nICsgXCIpXCIsIGZsYWdzKTtcbiAgfVxuICBmdW5jdGlvbiB0ZXh0ZGVjb2RlKGVuY29kaW5nLCB2YWx1ZSkge1xuICAgIGlmIChlbmNvZGluZykge1xuICAgICAgaWYgKCEvXltcXHgwMC1cXHhGRl0rJC8udGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgZGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcihlbmNvZGluZywge1xuICAgICAgICAgIGZhdGFsOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBidWZmZXIgPSAoMCwgX3V0aWwuc3RyaW5nVG9CeXRlcykodmFsdWUpO1xuICAgICAgICB2YWx1ZSA9IGRlY29kZXIuZGVjb2RlKGJ1ZmZlcik7XG4gICAgICAgIG5lZWRzRW5jb2RpbmdGaXh1cCA9IGZhbHNlO1xuICAgICAgfSBjYXRjaCB7fVxuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgZnVuY3Rpb24gZml4dXBFbmNvZGluZyh2YWx1ZSkge1xuICAgIGlmIChuZWVkc0VuY29kaW5nRml4dXAgJiYgL1tcXHg4MC1cXHhmZl0vLnRlc3QodmFsdWUpKSB7XG4gICAgICB2YWx1ZSA9IHRleHRkZWNvZGUoXCJ1dGYtOFwiLCB2YWx1ZSk7XG4gICAgICBpZiAobmVlZHNFbmNvZGluZ0ZpeHVwKSB7XG4gICAgICAgIHZhbHVlID0gdGV4dGRlY29kZShcImlzby04ODU5LTFcIiwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgZnVuY3Rpb24gcmZjMjIzMWdldHBhcmFtKGNvbnRlbnREaXNwb3NpdGlvblN0cikge1xuICAgIGNvbnN0IG1hdGNoZXMgPSBbXTtcbiAgICBsZXQgbWF0Y2g7XG4gICAgY29uc3QgaXRlciA9IHRvUGFyYW1SZWdFeHAoXCJmaWxlbmFtZVxcXFwqKCg/ITBcXFxcZClcXFxcZCspKFxcXFwqPylcIiwgXCJpZ1wiKTtcbiAgICB3aGlsZSAoKG1hdGNoID0gaXRlci5leGVjKGNvbnRlbnREaXNwb3NpdGlvblN0cikpICE9PSBudWxsKSB7XG4gICAgICBsZXQgWywgbiwgcXVvdCwgcGFydF0gPSBtYXRjaDtcbiAgICAgIG4gPSBwYXJzZUludChuLCAxMCk7XG4gICAgICBpZiAobiBpbiBtYXRjaGVzKSB7XG4gICAgICAgIGlmIChuID09PSAwKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBtYXRjaGVzW25dID0gW3F1b3QsIHBhcnRdO1xuICAgIH1cbiAgICBjb25zdCBwYXJ0cyA9IFtdO1xuICAgIGZvciAobGV0IG4gPSAwOyBuIDwgbWF0Y2hlcy5sZW5ndGg7ICsrbikge1xuICAgICAgaWYgKCEobiBpbiBtYXRjaGVzKSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGxldCBbcXVvdCwgcGFydF0gPSBtYXRjaGVzW25dO1xuICAgICAgcGFydCA9IHJmYzI2MTZ1bnF1b3RlKHBhcnQpO1xuICAgICAgaWYgKHF1b3QpIHtcbiAgICAgICAgcGFydCA9IHVuZXNjYXBlKHBhcnQpO1xuICAgICAgICBpZiAobiA9PT0gMCkge1xuICAgICAgICAgIHBhcnQgPSByZmM1OTg3ZGVjb2RlKHBhcnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBwYXJ0cy5wdXNoKHBhcnQpO1xuICAgIH1cbiAgICByZXR1cm4gcGFydHMuam9pbihcIlwiKTtcbiAgfVxuICBmdW5jdGlvbiByZmMyNjE2dW5xdW90ZSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZS5zdGFydHNXaXRoKCdcIicpKSB7XG4gICAgICBjb25zdCBwYXJ0cyA9IHZhbHVlLnNsaWNlKDEpLnNwbGl0KCdcXFxcXCInKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29uc3QgcXVvdGluZGV4ID0gcGFydHNbaV0uaW5kZXhPZignXCInKTtcbiAgICAgICAgaWYgKHF1b3RpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICBwYXJ0c1tpXSA9IHBhcnRzW2ldLnNsaWNlKDAsIHF1b3RpbmRleCk7XG4gICAgICAgICAgcGFydHMubGVuZ3RoID0gaSArIDE7XG4gICAgICAgIH1cbiAgICAgICAgcGFydHNbaV0gPSBwYXJ0c1tpXS5yZXBsYWNlQWxsKC9cXFxcKC4pL2csIFwiJDFcIik7XG4gICAgICB9XG4gICAgICB2YWx1ZSA9IHBhcnRzLmpvaW4oJ1wiJyk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBmdW5jdGlvbiByZmM1OTg3ZGVjb2RlKGV4dHZhbHVlKSB7XG4gICAgY29uc3QgZW5jb2RpbmdlbmQgPSBleHR2YWx1ZS5pbmRleE9mKFwiJ1wiKTtcbiAgICBpZiAoZW5jb2RpbmdlbmQgPT09IC0xKSB7XG4gICAgICByZXR1cm4gZXh0dmFsdWU7XG4gICAgfVxuICAgIGNvbnN0IGVuY29kaW5nID0gZXh0dmFsdWUuc2xpY2UoMCwgZW5jb2RpbmdlbmQpO1xuICAgIGNvbnN0IGxhbmd2YWx1ZSA9IGV4dHZhbHVlLnNsaWNlKGVuY29kaW5nZW5kICsgMSk7XG4gICAgY29uc3QgdmFsdWUgPSBsYW5ndmFsdWUucmVwbGFjZSgvXlteJ10qJy8sIFwiXCIpO1xuICAgIHJldHVybiB0ZXh0ZGVjb2RlKGVuY29kaW5nLCB2YWx1ZSk7XG4gIH1cbiAgZnVuY3Rpb24gcmZjMjA0N2RlY29kZSh2YWx1ZSkge1xuICAgIGlmICghdmFsdWUuc3RhcnRzV2l0aChcIj0/XCIpIHx8IC9bXFx4MDAtXFx4MTlcXHg4MC1cXHhmZl0vLnRlc3QodmFsdWUpKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZS5yZXBsYWNlQWxsKC89XFw/KFtcXHctXSopXFw/KFtRcUJiXSlcXD8oKD86W14/XXxcXD8oPyE9KSkqKVxcPz0vZywgZnVuY3Rpb24gKG1hdGNoZXMsIGNoYXJzZXQsIGVuY29kaW5nLCB0ZXh0KSB7XG4gICAgICBpZiAoZW5jb2RpbmcgPT09IFwicVwiIHx8IGVuY29kaW5nID09PSBcIlFcIikge1xuICAgICAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlQWxsKFwiX1wiLCBcIiBcIik7XG4gICAgICAgIHRleHQgPSB0ZXh0LnJlcGxhY2VBbGwoLz0oWzAtOWEtZkEtRl17Mn0pL2csIGZ1bmN0aW9uIChtYXRjaCwgaGV4KSB7XG4gICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUocGFyc2VJbnQoaGV4LCAxNikpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRleHRkZWNvZGUoY2hhcnNldCwgdGV4dCk7XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICB0ZXh0ID0gYXRvYih0ZXh0KTtcbiAgICAgIH0gY2F0Y2gge31cbiAgICAgIHJldHVybiB0ZXh0ZGVjb2RlKGNoYXJzZXQsIHRleHQpO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBcIlwiO1xufVxuXG4vKioqLyB9KSxcbi8qIDIyICovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSA9PiB7XG5cblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5leHBvcnRzLlBERk5ldHdvcmtTdHJlYW0gPSB2b2lkIDA7XG52YXIgX3V0aWwgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEpO1xudmFyIF9uZXR3b3JrX3V0aWxzID0gX193X3BkZmpzX3JlcXVpcmVfXygyMCk7XG47XG5jb25zdCBPS19SRVNQT05TRSA9IDIwMDtcbmNvbnN0IFBBUlRJQUxfQ09OVEVOVF9SRVNQT05TRSA9IDIwNjtcbmZ1bmN0aW9uIGdldEFycmF5QnVmZmVyKHhocikge1xuICBjb25zdCBkYXRhID0geGhyLnJlc3BvbnNlO1xuICBpZiAodHlwZW9mIGRhdGEgIT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuICByZXR1cm4gKDAsIF91dGlsLnN0cmluZ1RvQnl0ZXMpKGRhdGEpLmJ1ZmZlcjtcbn1cbmNsYXNzIE5ldHdvcmtNYW5hZ2VyIHtcbiAgY29uc3RydWN0b3IodXJsLCBhcmdzID0ge30pIHtcbiAgICB0aGlzLnVybCA9IHVybDtcbiAgICB0aGlzLmlzSHR0cCA9IC9eaHR0cHM/Oi9pLnRlc3QodXJsKTtcbiAgICB0aGlzLmh0dHBIZWFkZXJzID0gdGhpcy5pc0h0dHAgJiYgYXJncy5odHRwSGVhZGVycyB8fCBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMud2l0aENyZWRlbnRpYWxzID0gYXJncy53aXRoQ3JlZGVudGlhbHMgfHwgZmFsc2U7XG4gICAgdGhpcy5jdXJyWGhySWQgPSAwO1xuICAgIHRoaXMucGVuZGluZ1JlcXVlc3RzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgfVxuICByZXF1ZXN0UmFuZ2UoYmVnaW4sIGVuZCwgbGlzdGVuZXJzKSB7XG4gICAgY29uc3QgYXJncyA9IHtcbiAgICAgIGJlZ2luLFxuICAgICAgZW5kXG4gICAgfTtcbiAgICBmb3IgKGNvbnN0IHByb3AgaW4gbGlzdGVuZXJzKSB7XG4gICAgICBhcmdzW3Byb3BdID0gbGlzdGVuZXJzW3Byb3BdO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KGFyZ3MpO1xuICB9XG4gIHJlcXVlc3RGdWxsKGxpc3RlbmVycykge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3QobGlzdGVuZXJzKTtcbiAgfVxuICByZXF1ZXN0KGFyZ3MpIHtcbiAgICBjb25zdCB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICBjb25zdCB4aHJJZCA9IHRoaXMuY3VyclhocklkKys7XG4gICAgY29uc3QgcGVuZGluZ1JlcXVlc3QgPSB0aGlzLnBlbmRpbmdSZXF1ZXN0c1t4aHJJZF0gPSB7XG4gICAgICB4aHJcbiAgICB9O1xuICAgIHhoci5vcGVuKFwiR0VUXCIsIHRoaXMudXJsKTtcbiAgICB4aHIud2l0aENyZWRlbnRpYWxzID0gdGhpcy53aXRoQ3JlZGVudGlhbHM7XG4gICAgZm9yIChjb25zdCBwcm9wZXJ0eSBpbiB0aGlzLmh0dHBIZWFkZXJzKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuaHR0cEhlYWRlcnNbcHJvcGVydHldO1xuICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihwcm9wZXJ0eSwgdmFsdWUpO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc0h0dHAgJiYgXCJiZWdpblwiIGluIGFyZ3MgJiYgXCJlbmRcIiBpbiBhcmdzKSB7XG4gICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihcIlJhbmdlXCIsIGBieXRlcz0ke2FyZ3MuYmVnaW59LSR7YXJncy5lbmQgLSAxfWApO1xuICAgICAgcGVuZGluZ1JlcXVlc3QuZXhwZWN0ZWRTdGF0dXMgPSBQQVJUSUFMX0NPTlRFTlRfUkVTUE9OU0U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBlbmRpbmdSZXF1ZXN0LmV4cGVjdGVkU3RhdHVzID0gT0tfUkVTUE9OU0U7XG4gICAgfVxuICAgIHhoci5yZXNwb25zZVR5cGUgPSBcImFycmF5YnVmZmVyXCI7XG4gICAgaWYgKGFyZ3Mub25FcnJvcikge1xuICAgICAgeGhyLm9uZXJyb3IgPSBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICAgIGFyZ3Mub25FcnJvcih4aHIuc3RhdHVzKTtcbiAgICAgIH07XG4gICAgfVxuICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSB0aGlzLm9uU3RhdGVDaGFuZ2UuYmluZCh0aGlzLCB4aHJJZCk7XG4gICAgeGhyLm9ucHJvZ3Jlc3MgPSB0aGlzLm9uUHJvZ3Jlc3MuYmluZCh0aGlzLCB4aHJJZCk7XG4gICAgcGVuZGluZ1JlcXVlc3Qub25IZWFkZXJzUmVjZWl2ZWQgPSBhcmdzLm9uSGVhZGVyc1JlY2VpdmVkO1xuICAgIHBlbmRpbmdSZXF1ZXN0Lm9uRG9uZSA9IGFyZ3Mub25Eb25lO1xuICAgIHBlbmRpbmdSZXF1ZXN0Lm9uRXJyb3IgPSBhcmdzLm9uRXJyb3I7XG4gICAgcGVuZGluZ1JlcXVlc3Qub25Qcm9ncmVzcyA9IGFyZ3Mub25Qcm9ncmVzcztcbiAgICB4aHIuc2VuZChudWxsKTtcbiAgICByZXR1cm4geGhySWQ7XG4gIH1cbiAgb25Qcm9ncmVzcyh4aHJJZCwgZXZ0KSB7XG4gICAgY29uc3QgcGVuZGluZ1JlcXVlc3QgPSB0aGlzLnBlbmRpbmdSZXF1ZXN0c1t4aHJJZF07XG4gICAgaWYgKCFwZW5kaW5nUmVxdWVzdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBwZW5kaW5nUmVxdWVzdC5vblByb2dyZXNzPy4oZXZ0KTtcbiAgfVxuICBvblN0YXRlQ2hhbmdlKHhocklkLCBldnQpIHtcbiAgICBjb25zdCBwZW5kaW5nUmVxdWVzdCA9IHRoaXMucGVuZGluZ1JlcXVlc3RzW3hocklkXTtcbiAgICBpZiAoIXBlbmRpbmdSZXF1ZXN0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHhociA9IHBlbmRpbmdSZXF1ZXN0LnhocjtcbiAgICBpZiAoeGhyLnJlYWR5U3RhdGUgPj0gMiAmJiBwZW5kaW5nUmVxdWVzdC5vbkhlYWRlcnNSZWNlaXZlZCkge1xuICAgICAgcGVuZGluZ1JlcXVlc3Qub25IZWFkZXJzUmVjZWl2ZWQoKTtcbiAgICAgIGRlbGV0ZSBwZW5kaW5nUmVxdWVzdC5vbkhlYWRlcnNSZWNlaXZlZDtcbiAgICB9XG4gICAgaWYgKHhoci5yZWFkeVN0YXRlICE9PSA0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghKHhocklkIGluIHRoaXMucGVuZGluZ1JlcXVlc3RzKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkZWxldGUgdGhpcy5wZW5kaW5nUmVxdWVzdHNbeGhySWRdO1xuICAgIGlmICh4aHIuc3RhdHVzID09PSAwICYmIHRoaXMuaXNIdHRwKSB7XG4gICAgICBwZW5kaW5nUmVxdWVzdC5vbkVycm9yPy4oeGhyLnN0YXR1cyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHhoclN0YXR1cyA9IHhoci5zdGF0dXMgfHwgT0tfUkVTUE9OU0U7XG4gICAgY29uc3Qgb2tfcmVzcG9uc2Vfb25fcmFuZ2VfcmVxdWVzdCA9IHhoclN0YXR1cyA9PT0gT0tfUkVTUE9OU0UgJiYgcGVuZGluZ1JlcXVlc3QuZXhwZWN0ZWRTdGF0dXMgPT09IFBBUlRJQUxfQ09OVEVOVF9SRVNQT05TRTtcbiAgICBpZiAoIW9rX3Jlc3BvbnNlX29uX3JhbmdlX3JlcXVlc3QgJiYgeGhyU3RhdHVzICE9PSBwZW5kaW5nUmVxdWVzdC5leHBlY3RlZFN0YXR1cykge1xuICAgICAgcGVuZGluZ1JlcXVlc3Qub25FcnJvcj8uKHhoci5zdGF0dXMpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjaHVuayA9IGdldEFycmF5QnVmZmVyKHhocik7XG4gICAgaWYgKHhoclN0YXR1cyA9PT0gUEFSVElBTF9DT05URU5UX1JFU1BPTlNFKSB7XG4gICAgICBjb25zdCByYW5nZUhlYWRlciA9IHhoci5nZXRSZXNwb25zZUhlYWRlcihcIkNvbnRlbnQtUmFuZ2VcIik7XG4gICAgICBjb25zdCBtYXRjaGVzID0gL2J5dGVzIChcXGQrKS0oXFxkKylcXC8oXFxkKykvLmV4ZWMocmFuZ2VIZWFkZXIpO1xuICAgICAgcGVuZGluZ1JlcXVlc3Qub25Eb25lKHtcbiAgICAgICAgYmVnaW46IHBhcnNlSW50KG1hdGNoZXNbMV0sIDEwKSxcbiAgICAgICAgY2h1bmtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoY2h1bmspIHtcbiAgICAgIHBlbmRpbmdSZXF1ZXN0Lm9uRG9uZSh7XG4gICAgICAgIGJlZ2luOiAwLFxuICAgICAgICBjaHVua1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBlbmRpbmdSZXF1ZXN0Lm9uRXJyb3I/Lih4aHIuc3RhdHVzKTtcbiAgICB9XG4gIH1cbiAgZ2V0UmVxdWVzdFhocih4aHJJZCkge1xuICAgIHJldHVybiB0aGlzLnBlbmRpbmdSZXF1ZXN0c1t4aHJJZF0ueGhyO1xuICB9XG4gIGlzUGVuZGluZ1JlcXVlc3QoeGhySWQpIHtcbiAgICByZXR1cm4geGhySWQgaW4gdGhpcy5wZW5kaW5nUmVxdWVzdHM7XG4gIH1cbiAgYWJvcnRSZXF1ZXN0KHhocklkKSB7XG4gICAgY29uc3QgeGhyID0gdGhpcy5wZW5kaW5nUmVxdWVzdHNbeGhySWRdLnhocjtcbiAgICBkZWxldGUgdGhpcy5wZW5kaW5nUmVxdWVzdHNbeGhySWRdO1xuICAgIHhoci5hYm9ydCgpO1xuICB9XG59XG5jbGFzcyBQREZOZXR3b3JrU3RyZWFtIHtcbiAgY29uc3RydWN0b3Ioc291cmNlKSB7XG4gICAgdGhpcy5fc291cmNlID0gc291cmNlO1xuICAgIHRoaXMuX21hbmFnZXIgPSBuZXcgTmV0d29ya01hbmFnZXIoc291cmNlLnVybCwge1xuICAgICAgaHR0cEhlYWRlcnM6IHNvdXJjZS5odHRwSGVhZGVycyxcbiAgICAgIHdpdGhDcmVkZW50aWFsczogc291cmNlLndpdGhDcmVkZW50aWFsc1xuICAgIH0pO1xuICAgIHRoaXMuX3JhbmdlQ2h1bmtTaXplID0gc291cmNlLnJhbmdlQ2h1bmtTaXplO1xuICAgIHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyID0gbnVsbDtcbiAgICB0aGlzLl9yYW5nZVJlcXVlc3RSZWFkZXJzID0gW107XG4gIH1cbiAgX29uUmFuZ2VSZXF1ZXN0UmVhZGVyQ2xvc2VkKHJlYWRlcikge1xuICAgIGNvbnN0IGkgPSB0aGlzLl9yYW5nZVJlcXVlc3RSZWFkZXJzLmluZGV4T2YocmVhZGVyKTtcbiAgICBpZiAoaSA+PSAwKSB7XG4gICAgICB0aGlzLl9yYW5nZVJlcXVlc3RSZWFkZXJzLnNwbGljZShpLCAxKTtcbiAgICB9XG4gIH1cbiAgZ2V0RnVsbFJlYWRlcigpIHtcbiAgICAoMCwgX3V0aWwuYXNzZXJ0KSghdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXIsIFwiUERGTmV0d29ya1N0cmVhbS5nZXRGdWxsUmVhZGVyIGNhbiBvbmx5IGJlIGNhbGxlZCBvbmNlLlwiKTtcbiAgICB0aGlzLl9mdWxsUmVxdWVzdFJlYWRlciA9IG5ldyBQREZOZXR3b3JrU3RyZWFtRnVsbFJlcXVlc3RSZWFkZXIodGhpcy5fbWFuYWdlciwgdGhpcy5fc291cmNlKTtcbiAgICByZXR1cm4gdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXI7XG4gIH1cbiAgZ2V0UmFuZ2VSZWFkZXIoYmVnaW4sIGVuZCkge1xuICAgIGNvbnN0IHJlYWRlciA9IG5ldyBQREZOZXR3b3JrU3RyZWFtUmFuZ2VSZXF1ZXN0UmVhZGVyKHRoaXMuX21hbmFnZXIsIGJlZ2luLCBlbmQpO1xuICAgIHJlYWRlci5vbkNsb3NlZCA9IHRoaXMuX29uUmFuZ2VSZXF1ZXN0UmVhZGVyQ2xvc2VkLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fcmFuZ2VSZXF1ZXN0UmVhZGVycy5wdXNoKHJlYWRlcik7XG4gICAgcmV0dXJuIHJlYWRlcjtcbiAgfVxuICBjYW5jZWxBbGxSZXF1ZXN0cyhyZWFzb24pIHtcbiAgICB0aGlzLl9mdWxsUmVxdWVzdFJlYWRlcj8uY2FuY2VsKHJlYXNvbik7XG4gICAgZm9yIChjb25zdCByZWFkZXIgb2YgdGhpcy5fcmFuZ2VSZXF1ZXN0UmVhZGVycy5zbGljZSgwKSkge1xuICAgICAgcmVhZGVyLmNhbmNlbChyZWFzb24pO1xuICAgIH1cbiAgfVxufVxuZXhwb3J0cy5QREZOZXR3b3JrU3RyZWFtID0gUERGTmV0d29ya1N0cmVhbTtcbmNsYXNzIFBERk5ldHdvcmtTdHJlYW1GdWxsUmVxdWVzdFJlYWRlciB7XG4gIGNvbnN0cnVjdG9yKG1hbmFnZXIsIHNvdXJjZSkge1xuICAgIHRoaXMuX21hbmFnZXIgPSBtYW5hZ2VyO1xuICAgIGNvbnN0IGFyZ3MgPSB7XG4gICAgICBvbkhlYWRlcnNSZWNlaXZlZDogdGhpcy5fb25IZWFkZXJzUmVjZWl2ZWQuYmluZCh0aGlzKSxcbiAgICAgIG9uRG9uZTogdGhpcy5fb25Eb25lLmJpbmQodGhpcyksXG4gICAgICBvbkVycm9yOiB0aGlzLl9vbkVycm9yLmJpbmQodGhpcyksXG4gICAgICBvblByb2dyZXNzOiB0aGlzLl9vblByb2dyZXNzLmJpbmQodGhpcylcbiAgICB9O1xuICAgIHRoaXMuX3VybCA9IHNvdXJjZS51cmw7XG4gICAgdGhpcy5fZnVsbFJlcXVlc3RJZCA9IG1hbmFnZXIucmVxdWVzdEZ1bGwoYXJncyk7XG4gICAgdGhpcy5faGVhZGVyc1JlY2VpdmVkQ2FwYWJpbGl0eSA9IG5ldyBfdXRpbC5Qcm9taXNlQ2FwYWJpbGl0eSgpO1xuICAgIHRoaXMuX2Rpc2FibGVSYW5nZSA9IHNvdXJjZS5kaXNhYmxlUmFuZ2UgfHwgZmFsc2U7XG4gICAgdGhpcy5fY29udGVudExlbmd0aCA9IHNvdXJjZS5sZW5ndGg7XG4gICAgdGhpcy5fcmFuZ2VDaHVua1NpemUgPSBzb3VyY2UucmFuZ2VDaHVua1NpemU7XG4gICAgaWYgKCF0aGlzLl9yYW5nZUNodW5rU2l6ZSAmJiAhdGhpcy5fZGlzYWJsZVJhbmdlKSB7XG4gICAgICB0aGlzLl9kaXNhYmxlUmFuZ2UgPSB0cnVlO1xuICAgIH1cbiAgICB0aGlzLl9pc1N0cmVhbWluZ1N1cHBvcnRlZCA9IGZhbHNlO1xuICAgIHRoaXMuX2lzUmFuZ2VTdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9jYWNoZWRDaHVua3MgPSBbXTtcbiAgICB0aGlzLl9yZXF1ZXN0cyA9IFtdO1xuICAgIHRoaXMuX2RvbmUgPSBmYWxzZTtcbiAgICB0aGlzLl9zdG9yZWRFcnJvciA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9maWxlbmFtZSA9IG51bGw7XG4gICAgdGhpcy5vblByb2dyZXNzID0gbnVsbDtcbiAgfVxuICBfb25IZWFkZXJzUmVjZWl2ZWQoKSB7XG4gICAgY29uc3QgZnVsbFJlcXVlc3RYaHJJZCA9IHRoaXMuX2Z1bGxSZXF1ZXN0SWQ7XG4gICAgY29uc3QgZnVsbFJlcXVlc3RYaHIgPSB0aGlzLl9tYW5hZ2VyLmdldFJlcXVlc3RYaHIoZnVsbFJlcXVlc3RYaHJJZCk7XG4gICAgY29uc3QgZ2V0UmVzcG9uc2VIZWFkZXIgPSBuYW1lID0+IHtcbiAgICAgIHJldHVybiBmdWxsUmVxdWVzdFhoci5nZXRSZXNwb25zZUhlYWRlcihuYW1lKTtcbiAgICB9O1xuICAgIGNvbnN0IHtcbiAgICAgIGFsbG93UmFuZ2VSZXF1ZXN0cyxcbiAgICAgIHN1Z2dlc3RlZExlbmd0aFxuICAgIH0gPSAoMCwgX25ldHdvcmtfdXRpbHMudmFsaWRhdGVSYW5nZVJlcXVlc3RDYXBhYmlsaXRpZXMpKHtcbiAgICAgIGdldFJlc3BvbnNlSGVhZGVyLFxuICAgICAgaXNIdHRwOiB0aGlzLl9tYW5hZ2VyLmlzSHR0cCxcbiAgICAgIHJhbmdlQ2h1bmtTaXplOiB0aGlzLl9yYW5nZUNodW5rU2l6ZSxcbiAgICAgIGRpc2FibGVSYW5nZTogdGhpcy5fZGlzYWJsZVJhbmdlXG4gICAgfSk7XG4gICAgaWYgKGFsbG93UmFuZ2VSZXF1ZXN0cykge1xuICAgICAgdGhpcy5faXNSYW5nZVN1cHBvcnRlZCA9IHRydWU7XG4gICAgfVxuICAgIHRoaXMuX2NvbnRlbnRMZW5ndGggPSBzdWdnZXN0ZWRMZW5ndGggfHwgdGhpcy5fY29udGVudExlbmd0aDtcbiAgICB0aGlzLl9maWxlbmFtZSA9ICgwLCBfbmV0d29ya191dGlscy5leHRyYWN0RmlsZW5hbWVGcm9tSGVhZGVyKShnZXRSZXNwb25zZUhlYWRlcik7XG4gICAgaWYgKHRoaXMuX2lzUmFuZ2VTdXBwb3J0ZWQpIHtcbiAgICAgIHRoaXMuX21hbmFnZXIuYWJvcnRSZXF1ZXN0KGZ1bGxSZXF1ZXN0WGhySWQpO1xuICAgIH1cbiAgICB0aGlzLl9oZWFkZXJzUmVjZWl2ZWRDYXBhYmlsaXR5LnJlc29sdmUoKTtcbiAgfVxuICBfb25Eb25lKGRhdGEpIHtcbiAgICBpZiAoZGF0YSkge1xuICAgICAgaWYgKHRoaXMuX3JlcXVlc3RzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3QgcmVxdWVzdENhcGFiaWxpdHkgPSB0aGlzLl9yZXF1ZXN0cy5zaGlmdCgpO1xuICAgICAgICByZXF1ZXN0Q2FwYWJpbGl0eS5yZXNvbHZlKHtcbiAgICAgICAgICB2YWx1ZTogZGF0YS5jaHVuayxcbiAgICAgICAgICBkb25lOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2NhY2hlZENodW5rcy5wdXNoKGRhdGEuY2h1bmspO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9kb25lID0gdHJ1ZTtcbiAgICBpZiAodGhpcy5fY2FjaGVkQ2h1bmtzLmxlbmd0aCA+IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yIChjb25zdCByZXF1ZXN0Q2FwYWJpbGl0eSBvZiB0aGlzLl9yZXF1ZXN0cykge1xuICAgICAgcmVxdWVzdENhcGFiaWxpdHkucmVzb2x2ZSh7XG4gICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgIGRvbmU6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLl9yZXF1ZXN0cy5sZW5ndGggPSAwO1xuICB9XG4gIF9vbkVycm9yKHN0YXR1cykge1xuICAgIHRoaXMuX3N0b3JlZEVycm9yID0gKDAsIF9uZXR3b3JrX3V0aWxzLmNyZWF0ZVJlc3BvbnNlU3RhdHVzRXJyb3IpKHN0YXR1cywgdGhpcy5fdXJsKTtcbiAgICB0aGlzLl9oZWFkZXJzUmVjZWl2ZWRDYXBhYmlsaXR5LnJlamVjdCh0aGlzLl9zdG9yZWRFcnJvcik7XG4gICAgZm9yIChjb25zdCByZXF1ZXN0Q2FwYWJpbGl0eSBvZiB0aGlzLl9yZXF1ZXN0cykge1xuICAgICAgcmVxdWVzdENhcGFiaWxpdHkucmVqZWN0KHRoaXMuX3N0b3JlZEVycm9yKTtcbiAgICB9XG4gICAgdGhpcy5fcmVxdWVzdHMubGVuZ3RoID0gMDtcbiAgICB0aGlzLl9jYWNoZWRDaHVua3MubGVuZ3RoID0gMDtcbiAgfVxuICBfb25Qcm9ncmVzcyhldnQpIHtcbiAgICB0aGlzLm9uUHJvZ3Jlc3M/Lih7XG4gICAgICBsb2FkZWQ6IGV2dC5sb2FkZWQsXG4gICAgICB0b3RhbDogZXZ0Lmxlbmd0aENvbXB1dGFibGUgPyBldnQudG90YWwgOiB0aGlzLl9jb250ZW50TGVuZ3RoXG4gICAgfSk7XG4gIH1cbiAgZ2V0IGZpbGVuYW1lKCkge1xuICAgIHJldHVybiB0aGlzLl9maWxlbmFtZTtcbiAgfVxuICBnZXQgaXNSYW5nZVN1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5faXNSYW5nZVN1cHBvcnRlZDtcbiAgfVxuICBnZXQgaXNTdHJlYW1pbmdTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lzU3RyZWFtaW5nU3VwcG9ydGVkO1xuICB9XG4gIGdldCBjb250ZW50TGVuZ3RoKCkge1xuICAgIHJldHVybiB0aGlzLl9jb250ZW50TGVuZ3RoO1xuICB9XG4gIGdldCBoZWFkZXJzUmVhZHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2hlYWRlcnNSZWNlaXZlZENhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxuICBhc3luYyByZWFkKCkge1xuICAgIGlmICh0aGlzLl9zdG9yZWRFcnJvcikge1xuICAgICAgdGhyb3cgdGhpcy5fc3RvcmVkRXJyb3I7XG4gICAgfVxuICAgIGlmICh0aGlzLl9jYWNoZWRDaHVua3MubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgY2h1bmsgPSB0aGlzLl9jYWNoZWRDaHVua3Muc2hpZnQoKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiBjaHVuayxcbiAgICAgICAgZG9uZTogZmFsc2VcbiAgICAgIH07XG4gICAgfVxuICAgIGlmICh0aGlzLl9kb25lKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICBkb25lOiB0cnVlXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCByZXF1ZXN0Q2FwYWJpbGl0eSA9IG5ldyBfdXRpbC5Qcm9taXNlQ2FwYWJpbGl0eSgpO1xuICAgIHRoaXMuX3JlcXVlc3RzLnB1c2gocmVxdWVzdENhcGFiaWxpdHkpO1xuICAgIHJldHVybiByZXF1ZXN0Q2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG4gIGNhbmNlbChyZWFzb24pIHtcbiAgICB0aGlzLl9kb25lID0gdHJ1ZTtcbiAgICB0aGlzLl9oZWFkZXJzUmVjZWl2ZWRDYXBhYmlsaXR5LnJlamVjdChyZWFzb24pO1xuICAgIGZvciAoY29uc3QgcmVxdWVzdENhcGFiaWxpdHkgb2YgdGhpcy5fcmVxdWVzdHMpIHtcbiAgICAgIHJlcXVlc3RDYXBhYmlsaXR5LnJlc29sdmUoe1xuICAgICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICBkb25lOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5fcmVxdWVzdHMubGVuZ3RoID0gMDtcbiAgICBpZiAodGhpcy5fbWFuYWdlci5pc1BlbmRpbmdSZXF1ZXN0KHRoaXMuX2Z1bGxSZXF1ZXN0SWQpKSB7XG4gICAgICB0aGlzLl9tYW5hZ2VyLmFib3J0UmVxdWVzdCh0aGlzLl9mdWxsUmVxdWVzdElkKTtcbiAgICB9XG4gICAgdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXIgPSBudWxsO1xuICB9XG59XG5jbGFzcyBQREZOZXR3b3JrU3RyZWFtUmFuZ2VSZXF1ZXN0UmVhZGVyIHtcbiAgY29uc3RydWN0b3IobWFuYWdlciwgYmVnaW4sIGVuZCkge1xuICAgIHRoaXMuX21hbmFnZXIgPSBtYW5hZ2VyO1xuICAgIGNvbnN0IGFyZ3MgPSB7XG4gICAgICBvbkRvbmU6IHRoaXMuX29uRG9uZS5iaW5kKHRoaXMpLFxuICAgICAgb25FcnJvcjogdGhpcy5fb25FcnJvci5iaW5kKHRoaXMpLFxuICAgICAgb25Qcm9ncmVzczogdGhpcy5fb25Qcm9ncmVzcy5iaW5kKHRoaXMpXG4gICAgfTtcbiAgICB0aGlzLl91cmwgPSBtYW5hZ2VyLnVybDtcbiAgICB0aGlzLl9yZXF1ZXN0SWQgPSBtYW5hZ2VyLnJlcXVlc3RSYW5nZShiZWdpbiwgZW5kLCBhcmdzKTtcbiAgICB0aGlzLl9yZXF1ZXN0cyA9IFtdO1xuICAgIHRoaXMuX3F1ZXVlZENodW5rID0gbnVsbDtcbiAgICB0aGlzLl9kb25lID0gZmFsc2U7XG4gICAgdGhpcy5fc3RvcmVkRXJyb3IgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5vblByb2dyZXNzID0gbnVsbDtcbiAgICB0aGlzLm9uQ2xvc2VkID0gbnVsbDtcbiAgfVxuICBfY2xvc2UoKSB7XG4gICAgdGhpcy5vbkNsb3NlZD8uKHRoaXMpO1xuICB9XG4gIF9vbkRvbmUoZGF0YSkge1xuICAgIGNvbnN0IGNodW5rID0gZGF0YS5jaHVuaztcbiAgICBpZiAodGhpcy5fcmVxdWVzdHMubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgcmVxdWVzdENhcGFiaWxpdHkgPSB0aGlzLl9yZXF1ZXN0cy5zaGlmdCgpO1xuICAgICAgcmVxdWVzdENhcGFiaWxpdHkucmVzb2x2ZSh7XG4gICAgICAgIHZhbHVlOiBjaHVuayxcbiAgICAgICAgZG9uZTogZmFsc2VcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9xdWV1ZWRDaHVuayA9IGNodW5rO1xuICAgIH1cbiAgICB0aGlzLl9kb25lID0gdHJ1ZTtcbiAgICBmb3IgKGNvbnN0IHJlcXVlc3RDYXBhYmlsaXR5IG9mIHRoaXMuX3JlcXVlc3RzKSB7XG4gICAgICByZXF1ZXN0Q2FwYWJpbGl0eS5yZXNvbHZlKHtcbiAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMuX3JlcXVlc3RzLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5fY2xvc2UoKTtcbiAgfVxuICBfb25FcnJvcihzdGF0dXMpIHtcbiAgICB0aGlzLl9zdG9yZWRFcnJvciA9ICgwLCBfbmV0d29ya191dGlscy5jcmVhdGVSZXNwb25zZVN0YXR1c0Vycm9yKShzdGF0dXMsIHRoaXMuX3VybCk7XG4gICAgZm9yIChjb25zdCByZXF1ZXN0Q2FwYWJpbGl0eSBvZiB0aGlzLl9yZXF1ZXN0cykge1xuICAgICAgcmVxdWVzdENhcGFiaWxpdHkucmVqZWN0KHRoaXMuX3N0b3JlZEVycm9yKTtcbiAgICB9XG4gICAgdGhpcy5fcmVxdWVzdHMubGVuZ3RoID0gMDtcbiAgICB0aGlzLl9xdWV1ZWRDaHVuayA9IG51bGw7XG4gIH1cbiAgX29uUHJvZ3Jlc3MoZXZ0KSB7XG4gICAgaWYgKCF0aGlzLmlzU3RyZWFtaW5nU3VwcG9ydGVkKSB7XG4gICAgICB0aGlzLm9uUHJvZ3Jlc3M/Lih7XG4gICAgICAgIGxvYWRlZDogZXZ0LmxvYWRlZFxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGdldCBpc1N0cmVhbWluZ1N1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgYXN5bmMgcmVhZCgpIHtcbiAgICBpZiAodGhpcy5fc3RvcmVkRXJyb3IpIHtcbiAgICAgIHRocm93IHRoaXMuX3N0b3JlZEVycm9yO1xuICAgIH1cbiAgICBpZiAodGhpcy5fcXVldWVkQ2h1bmsgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IGNodW5rID0gdGhpcy5fcXVldWVkQ2h1bms7XG4gICAgICB0aGlzLl9xdWV1ZWRDaHVuayA9IG51bGw7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogY2h1bmssXG4gICAgICAgIGRvbmU6IGZhbHNlXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAodGhpcy5fZG9uZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgcmVxdWVzdENhcGFiaWxpdHkgPSBuZXcgX3V0aWwuUHJvbWlzZUNhcGFiaWxpdHkoKTtcbiAgICB0aGlzLl9yZXF1ZXN0cy5wdXNoKHJlcXVlc3RDYXBhYmlsaXR5KTtcbiAgICByZXR1cm4gcmVxdWVzdENhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxuICBjYW5jZWwocmVhc29uKSB7XG4gICAgdGhpcy5fZG9uZSA9IHRydWU7XG4gICAgZm9yIChjb25zdCByZXF1ZXN0Q2FwYWJpbGl0eSBvZiB0aGlzLl9yZXF1ZXN0cykge1xuICAgICAgcmVxdWVzdENhcGFiaWxpdHkucmVzb2x2ZSh7XG4gICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgIGRvbmU6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLl9yZXF1ZXN0cy5sZW5ndGggPSAwO1xuICAgIGlmICh0aGlzLl9tYW5hZ2VyLmlzUGVuZGluZ1JlcXVlc3QodGhpcy5fcmVxdWVzdElkKSkge1xuICAgICAgdGhpcy5fbWFuYWdlci5hYm9ydFJlcXVlc3QodGhpcy5fcmVxdWVzdElkKTtcbiAgICB9XG4gICAgdGhpcy5fY2xvc2UoKTtcbiAgfVxufVxuXG4vKioqLyB9KSxcbi8qIDIzICovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSA9PiB7XG5cblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5leHBvcnRzLlBERk5vZGVTdHJlYW0gPSB2b2lkIDA7XG52YXIgX3V0aWwgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEpO1xudmFyIF9uZXR3b3JrX3V0aWxzID0gX193X3BkZmpzX3JlcXVpcmVfXygyMCk7XG47XG5jb25zdCBmaWxlVXJpUmVnZXggPSAvXmZpbGU6XFwvXFwvXFwvW2EtekEtWl06XFwvLztcbmZ1bmN0aW9uIHBhcnNlVXJsKHNvdXJjZVVybCkge1xuICBjb25zdCB1cmwgPSByZXF1aXJlKFwidXJsXCIpO1xuICBjb25zdCBwYXJzZWRVcmwgPSB1cmwucGFyc2Uoc291cmNlVXJsKTtcbiAgaWYgKHBhcnNlZFVybC5wcm90b2NvbCA9PT0gXCJmaWxlOlwiIHx8IHBhcnNlZFVybC5ob3N0KSB7XG4gICAgcmV0dXJuIHBhcnNlZFVybDtcbiAgfVxuICBpZiAoL15bYS16XTpbL1xcXFxdL2kudGVzdChzb3VyY2VVcmwpKSB7XG4gICAgcmV0dXJuIHVybC5wYXJzZShgZmlsZTovLy8ke3NvdXJjZVVybH1gKTtcbiAgfVxuICBpZiAoIXBhcnNlZFVybC5ob3N0KSB7XG4gICAgcGFyc2VkVXJsLnByb3RvY29sID0gXCJmaWxlOlwiO1xuICB9XG4gIHJldHVybiBwYXJzZWRVcmw7XG59XG5jbGFzcyBQREZOb2RlU3RyZWFtIHtcbiAgY29uc3RydWN0b3Ioc291cmNlKSB7XG4gICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgdGhpcy51cmwgPSBwYXJzZVVybChzb3VyY2UudXJsKTtcbiAgICB0aGlzLmlzSHR0cCA9IHRoaXMudXJsLnByb3RvY29sID09PSBcImh0dHA6XCIgfHwgdGhpcy51cmwucHJvdG9jb2wgPT09IFwiaHR0cHM6XCI7XG4gICAgdGhpcy5pc0ZzVXJsID0gdGhpcy51cmwucHJvdG9jb2wgPT09IFwiZmlsZTpcIjtcbiAgICB0aGlzLmh0dHBIZWFkZXJzID0gdGhpcy5pc0h0dHAgJiYgc291cmNlLmh0dHBIZWFkZXJzIHx8IHt9O1xuICAgIHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyID0gbnVsbDtcbiAgICB0aGlzLl9yYW5nZVJlcXVlc3RSZWFkZXJzID0gW107XG4gIH1cbiAgZ2V0IF9wcm9ncmVzc2l2ZURhdGFMZW5ndGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyPy5fbG9hZGVkID8/IDA7XG4gIH1cbiAgZ2V0RnVsbFJlYWRlcigpIHtcbiAgICAoMCwgX3V0aWwuYXNzZXJ0KSghdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXIsIFwiUERGTm9kZVN0cmVhbS5nZXRGdWxsUmVhZGVyIGNhbiBvbmx5IGJlIGNhbGxlZCBvbmNlLlwiKTtcbiAgICB0aGlzLl9mdWxsUmVxdWVzdFJlYWRlciA9IHRoaXMuaXNGc1VybCA/IG5ldyBQREZOb2RlU3RyZWFtRnNGdWxsUmVhZGVyKHRoaXMpIDogbmV3IFBERk5vZGVTdHJlYW1GdWxsUmVhZGVyKHRoaXMpO1xuICAgIHJldHVybiB0aGlzLl9mdWxsUmVxdWVzdFJlYWRlcjtcbiAgfVxuICBnZXRSYW5nZVJlYWRlcihzdGFydCwgZW5kKSB7XG4gICAgaWYgKGVuZCA8PSB0aGlzLl9wcm9ncmVzc2l2ZURhdGFMZW5ndGgpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCByYW5nZVJlYWRlciA9IHRoaXMuaXNGc1VybCA/IG5ldyBQREZOb2RlU3RyZWFtRnNSYW5nZVJlYWRlcih0aGlzLCBzdGFydCwgZW5kKSA6IG5ldyBQREZOb2RlU3RyZWFtUmFuZ2VSZWFkZXIodGhpcywgc3RhcnQsIGVuZCk7XG4gICAgdGhpcy5fcmFuZ2VSZXF1ZXN0UmVhZGVycy5wdXNoKHJhbmdlUmVhZGVyKTtcbiAgICByZXR1cm4gcmFuZ2VSZWFkZXI7XG4gIH1cbiAgY2FuY2VsQWxsUmVxdWVzdHMocmVhc29uKSB7XG4gICAgdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXI/LmNhbmNlbChyZWFzb24pO1xuICAgIGZvciAoY29uc3QgcmVhZGVyIG9mIHRoaXMuX3JhbmdlUmVxdWVzdFJlYWRlcnMuc2xpY2UoMCkpIHtcbiAgICAgIHJlYWRlci5jYW5jZWwocmVhc29uKTtcbiAgICB9XG4gIH1cbn1cbmV4cG9ydHMuUERGTm9kZVN0cmVhbSA9IFBERk5vZGVTdHJlYW07XG5jbGFzcyBCYXNlRnVsbFJlYWRlciB7XG4gIGNvbnN0cnVjdG9yKHN0cmVhbSkge1xuICAgIHRoaXMuX3VybCA9IHN0cmVhbS51cmw7XG4gICAgdGhpcy5fZG9uZSA9IGZhbHNlO1xuICAgIHRoaXMuX3N0b3JlZEVycm9yID0gbnVsbDtcbiAgICB0aGlzLm9uUHJvZ3Jlc3MgPSBudWxsO1xuICAgIGNvbnN0IHNvdXJjZSA9IHN0cmVhbS5zb3VyY2U7XG4gICAgdGhpcy5fY29udGVudExlbmd0aCA9IHNvdXJjZS5sZW5ndGg7XG4gICAgdGhpcy5fbG9hZGVkID0gMDtcbiAgICB0aGlzLl9maWxlbmFtZSA9IG51bGw7XG4gICAgdGhpcy5fZGlzYWJsZVJhbmdlID0gc291cmNlLmRpc2FibGVSYW5nZSB8fCBmYWxzZTtcbiAgICB0aGlzLl9yYW5nZUNodW5rU2l6ZSA9IHNvdXJjZS5yYW5nZUNodW5rU2l6ZTtcbiAgICBpZiAoIXRoaXMuX3JhbmdlQ2h1bmtTaXplICYmICF0aGlzLl9kaXNhYmxlUmFuZ2UpIHtcbiAgICAgIHRoaXMuX2Rpc2FibGVSYW5nZSA9IHRydWU7XG4gICAgfVxuICAgIHRoaXMuX2lzU3RyZWFtaW5nU3VwcG9ydGVkID0gIXNvdXJjZS5kaXNhYmxlU3RyZWFtO1xuICAgIHRoaXMuX2lzUmFuZ2VTdXBwb3J0ZWQgPSAhc291cmNlLmRpc2FibGVSYW5nZTtcbiAgICB0aGlzLl9yZWFkYWJsZVN0cmVhbSA9IG51bGw7XG4gICAgdGhpcy5fcmVhZENhcGFiaWxpdHkgPSBuZXcgX3V0aWwuUHJvbWlzZUNhcGFiaWxpdHkoKTtcbiAgICB0aGlzLl9oZWFkZXJzQ2FwYWJpbGl0eSA9IG5ldyBfdXRpbC5Qcm9taXNlQ2FwYWJpbGl0eSgpO1xuICB9XG4gIGdldCBoZWFkZXJzUmVhZHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2hlYWRlcnNDYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbiAgZ2V0IGZpbGVuYW1lKCkge1xuICAgIHJldHVybiB0aGlzLl9maWxlbmFtZTtcbiAgfVxuICBnZXQgY29udGVudExlbmd0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5fY29udGVudExlbmd0aDtcbiAgfVxuICBnZXQgaXNSYW5nZVN1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5faXNSYW5nZVN1cHBvcnRlZDtcbiAgfVxuICBnZXQgaXNTdHJlYW1pbmdTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lzU3RyZWFtaW5nU3VwcG9ydGVkO1xuICB9XG4gIGFzeW5jIHJlYWQoKSB7XG4gICAgYXdhaXQgdGhpcy5fcmVhZENhcGFiaWxpdHkucHJvbWlzZTtcbiAgICBpZiAodGhpcy5fZG9uZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3N0b3JlZEVycm9yKSB7XG4gICAgICB0aHJvdyB0aGlzLl9zdG9yZWRFcnJvcjtcbiAgICB9XG4gICAgY29uc3QgY2h1bmsgPSB0aGlzLl9yZWFkYWJsZVN0cmVhbS5yZWFkKCk7XG4gICAgaWYgKGNodW5rID09PSBudWxsKSB7XG4gICAgICB0aGlzLl9yZWFkQ2FwYWJpbGl0eSA9IG5ldyBfdXRpbC5Qcm9taXNlQ2FwYWJpbGl0eSgpO1xuICAgICAgcmV0dXJuIHRoaXMucmVhZCgpO1xuICAgIH1cbiAgICB0aGlzLl9sb2FkZWQgKz0gY2h1bmsubGVuZ3RoO1xuICAgIHRoaXMub25Qcm9ncmVzcz8uKHtcbiAgICAgIGxvYWRlZDogdGhpcy5fbG9hZGVkLFxuICAgICAgdG90YWw6IHRoaXMuX2NvbnRlbnRMZW5ndGhcbiAgICB9KTtcbiAgICBjb25zdCBidWZmZXIgPSBuZXcgVWludDhBcnJheShjaHVuaykuYnVmZmVyO1xuICAgIHJldHVybiB7XG4gICAgICB2YWx1ZTogYnVmZmVyLFxuICAgICAgZG9uZTogZmFsc2VcbiAgICB9O1xuICB9XG4gIGNhbmNlbChyZWFzb24pIHtcbiAgICBpZiAoIXRoaXMuX3JlYWRhYmxlU3RyZWFtKSB7XG4gICAgICB0aGlzLl9lcnJvcihyZWFzb24pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9yZWFkYWJsZVN0cmVhbS5kZXN0cm95KHJlYXNvbik7XG4gIH1cbiAgX2Vycm9yKHJlYXNvbikge1xuICAgIHRoaXMuX3N0b3JlZEVycm9yID0gcmVhc29uO1xuICAgIHRoaXMuX3JlYWRDYXBhYmlsaXR5LnJlc29sdmUoKTtcbiAgfVxuICBfc2V0UmVhZGFibGVTdHJlYW0ocmVhZGFibGVTdHJlYW0pIHtcbiAgICB0aGlzLl9yZWFkYWJsZVN0cmVhbSA9IHJlYWRhYmxlU3RyZWFtO1xuICAgIHJlYWRhYmxlU3RyZWFtLm9uKFwicmVhZGFibGVcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5fcmVhZENhcGFiaWxpdHkucmVzb2x2ZSgpO1xuICAgIH0pO1xuICAgIHJlYWRhYmxlU3RyZWFtLm9uKFwiZW5kXCIsICgpID0+IHtcbiAgICAgIHJlYWRhYmxlU3RyZWFtLmRlc3Ryb3koKTtcbiAgICAgIHRoaXMuX2RvbmUgPSB0cnVlO1xuICAgICAgdGhpcy5fcmVhZENhcGFiaWxpdHkucmVzb2x2ZSgpO1xuICAgIH0pO1xuICAgIHJlYWRhYmxlU3RyZWFtLm9uKFwiZXJyb3JcIiwgcmVhc29uID0+IHtcbiAgICAgIHRoaXMuX2Vycm9yKHJlYXNvbik7XG4gICAgfSk7XG4gICAgaWYgKCF0aGlzLl9pc1N0cmVhbWluZ1N1cHBvcnRlZCAmJiB0aGlzLl9pc1JhbmdlU3VwcG9ydGVkKSB7XG4gICAgICB0aGlzLl9lcnJvcihuZXcgX3V0aWwuQWJvcnRFeGNlcHRpb24oXCJzdHJlYW1pbmcgaXMgZGlzYWJsZWRcIikpO1xuICAgIH1cbiAgICBpZiAodGhpcy5fc3RvcmVkRXJyb3IpIHtcbiAgICAgIHRoaXMuX3JlYWRhYmxlU3RyZWFtLmRlc3Ryb3kodGhpcy5fc3RvcmVkRXJyb3IpO1xuICAgIH1cbiAgfVxufVxuY2xhc3MgQmFzZVJhbmdlUmVhZGVyIHtcbiAgY29uc3RydWN0b3Ioc3RyZWFtKSB7XG4gICAgdGhpcy5fdXJsID0gc3RyZWFtLnVybDtcbiAgICB0aGlzLl9kb25lID0gZmFsc2U7XG4gICAgdGhpcy5fc3RvcmVkRXJyb3IgPSBudWxsO1xuICAgIHRoaXMub25Qcm9ncmVzcyA9IG51bGw7XG4gICAgdGhpcy5fbG9hZGVkID0gMDtcbiAgICB0aGlzLl9yZWFkYWJsZVN0cmVhbSA9IG51bGw7XG4gICAgdGhpcy5fcmVhZENhcGFiaWxpdHkgPSBuZXcgX3V0aWwuUHJvbWlzZUNhcGFiaWxpdHkoKTtcbiAgICBjb25zdCBzb3VyY2UgPSBzdHJlYW0uc291cmNlO1xuICAgIHRoaXMuX2lzU3RyZWFtaW5nU3VwcG9ydGVkID0gIXNvdXJjZS5kaXNhYmxlU3RyZWFtO1xuICB9XG4gIGdldCBpc1N0cmVhbWluZ1N1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5faXNTdHJlYW1pbmdTdXBwb3J0ZWQ7XG4gIH1cbiAgYXN5bmMgcmVhZCgpIHtcbiAgICBhd2FpdCB0aGlzLl9yZWFkQ2FwYWJpbGl0eS5wcm9taXNlO1xuICAgIGlmICh0aGlzLl9kb25lKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICBkb25lOiB0cnVlXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAodGhpcy5fc3RvcmVkRXJyb3IpIHtcbiAgICAgIHRocm93IHRoaXMuX3N0b3JlZEVycm9yO1xuICAgIH1cbiAgICBjb25zdCBjaHVuayA9IHRoaXMuX3JlYWRhYmxlU3RyZWFtLnJlYWQoKTtcbiAgICBpZiAoY2h1bmsgPT09IG51bGwpIHtcbiAgICAgIHRoaXMuX3JlYWRDYXBhYmlsaXR5ID0gbmV3IF91dGlsLlByb21pc2VDYXBhYmlsaXR5KCk7XG4gICAgICByZXR1cm4gdGhpcy5yZWFkKCk7XG4gICAgfVxuICAgIHRoaXMuX2xvYWRlZCArPSBjaHVuay5sZW5ndGg7XG4gICAgdGhpcy5vblByb2dyZXNzPy4oe1xuICAgICAgbG9hZGVkOiB0aGlzLl9sb2FkZWRcbiAgICB9KTtcbiAgICBjb25zdCBidWZmZXIgPSBuZXcgVWludDhBcnJheShjaHVuaykuYnVmZmVyO1xuICAgIHJldHVybiB7XG4gICAgICB2YWx1ZTogYnVmZmVyLFxuICAgICAgZG9uZTogZmFsc2VcbiAgICB9O1xuICB9XG4gIGNhbmNlbChyZWFzb24pIHtcbiAgICBpZiAoIXRoaXMuX3JlYWRhYmxlU3RyZWFtKSB7XG4gICAgICB0aGlzLl9lcnJvcihyZWFzb24pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9yZWFkYWJsZVN0cmVhbS5kZXN0cm95KHJlYXNvbik7XG4gIH1cbiAgX2Vycm9yKHJlYXNvbikge1xuICAgIHRoaXMuX3N0b3JlZEVycm9yID0gcmVhc29uO1xuICAgIHRoaXMuX3JlYWRDYXBhYmlsaXR5LnJlc29sdmUoKTtcbiAgfVxuICBfc2V0UmVhZGFibGVTdHJlYW0ocmVhZGFibGVTdHJlYW0pIHtcbiAgICB0aGlzLl9yZWFkYWJsZVN0cmVhbSA9IHJlYWRhYmxlU3RyZWFtO1xuICAgIHJlYWRhYmxlU3RyZWFtLm9uKFwicmVhZGFibGVcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5fcmVhZENhcGFiaWxpdHkucmVzb2x2ZSgpO1xuICAgIH0pO1xuICAgIHJlYWRhYmxlU3RyZWFtLm9uKFwiZW5kXCIsICgpID0+IHtcbiAgICAgIHJlYWRhYmxlU3RyZWFtLmRlc3Ryb3koKTtcbiAgICAgIHRoaXMuX2RvbmUgPSB0cnVlO1xuICAgICAgdGhpcy5fcmVhZENhcGFiaWxpdHkucmVzb2x2ZSgpO1xuICAgIH0pO1xuICAgIHJlYWRhYmxlU3RyZWFtLm9uKFwiZXJyb3JcIiwgcmVhc29uID0+IHtcbiAgICAgIHRoaXMuX2Vycm9yKHJlYXNvbik7XG4gICAgfSk7XG4gICAgaWYgKHRoaXMuX3N0b3JlZEVycm9yKSB7XG4gICAgICB0aGlzLl9yZWFkYWJsZVN0cmVhbS5kZXN0cm95KHRoaXMuX3N0b3JlZEVycm9yKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZVJlcXVlc3RPcHRpb25zKHBhcnNlZFVybCwgaGVhZGVycykge1xuICByZXR1cm4ge1xuICAgIHByb3RvY29sOiBwYXJzZWRVcmwucHJvdG9jb2wsXG4gICAgYXV0aDogcGFyc2VkVXJsLmF1dGgsXG4gICAgaG9zdDogcGFyc2VkVXJsLmhvc3RuYW1lLFxuICAgIHBvcnQ6IHBhcnNlZFVybC5wb3J0LFxuICAgIHBhdGg6IHBhcnNlZFVybC5wYXRoLFxuICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICBoZWFkZXJzXG4gIH07XG59XG5jbGFzcyBQREZOb2RlU3RyZWFtRnVsbFJlYWRlciBleHRlbmRzIEJhc2VGdWxsUmVhZGVyIHtcbiAgY29uc3RydWN0b3Ioc3RyZWFtKSB7XG4gICAgc3VwZXIoc3RyZWFtKTtcbiAgICBjb25zdCBoYW5kbGVSZXNwb25zZSA9IHJlc3BvbnNlID0+IHtcbiAgICAgIGlmIChyZXNwb25zZS5zdGF0dXNDb2RlID09PSA0MDQpIHtcbiAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgX3V0aWwuTWlzc2luZ1BERkV4Y2VwdGlvbihgTWlzc2luZyBQREYgXCIke3RoaXMuX3VybH1cIi5gKTtcbiAgICAgICAgdGhpcy5fc3RvcmVkRXJyb3IgPSBlcnJvcjtcbiAgICAgICAgdGhpcy5faGVhZGVyc0NhcGFiaWxpdHkucmVqZWN0KGVycm9yKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5faGVhZGVyc0NhcGFiaWxpdHkucmVzb2x2ZSgpO1xuICAgICAgdGhpcy5fc2V0UmVhZGFibGVTdHJlYW0ocmVzcG9uc2UpO1xuICAgICAgY29uc3QgZ2V0UmVzcG9uc2VIZWFkZXIgPSBuYW1lID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RyZWFtLmhlYWRlcnNbbmFtZS50b0xvd2VyQ2FzZSgpXTtcbiAgICAgIH07XG4gICAgICBjb25zdCB7XG4gICAgICAgIGFsbG93UmFuZ2VSZXF1ZXN0cyxcbiAgICAgICAgc3VnZ2VzdGVkTGVuZ3RoXG4gICAgICB9ID0gKDAsIF9uZXR3b3JrX3V0aWxzLnZhbGlkYXRlUmFuZ2VSZXF1ZXN0Q2FwYWJpbGl0aWVzKSh7XG4gICAgICAgIGdldFJlc3BvbnNlSGVhZGVyLFxuICAgICAgICBpc0h0dHA6IHN0cmVhbS5pc0h0dHAsXG4gICAgICAgIHJhbmdlQ2h1bmtTaXplOiB0aGlzLl9yYW5nZUNodW5rU2l6ZSxcbiAgICAgICAgZGlzYWJsZVJhbmdlOiB0aGlzLl9kaXNhYmxlUmFuZ2VcbiAgICAgIH0pO1xuICAgICAgdGhpcy5faXNSYW5nZVN1cHBvcnRlZCA9IGFsbG93UmFuZ2VSZXF1ZXN0cztcbiAgICAgIHRoaXMuX2NvbnRlbnRMZW5ndGggPSBzdWdnZXN0ZWRMZW5ndGggfHwgdGhpcy5fY29udGVudExlbmd0aDtcbiAgICAgIHRoaXMuX2ZpbGVuYW1lID0gKDAsIF9uZXR3b3JrX3V0aWxzLmV4dHJhY3RGaWxlbmFtZUZyb21IZWFkZXIpKGdldFJlc3BvbnNlSGVhZGVyKTtcbiAgICB9O1xuICAgIHRoaXMuX3JlcXVlc3QgPSBudWxsO1xuICAgIGlmICh0aGlzLl91cmwucHJvdG9jb2wgPT09IFwiaHR0cDpcIikge1xuICAgICAgY29uc3QgaHR0cCA9IHJlcXVpcmUoXCJodHRwXCIpO1xuICAgICAgdGhpcy5fcmVxdWVzdCA9IGh0dHAucmVxdWVzdChjcmVhdGVSZXF1ZXN0T3B0aW9ucyh0aGlzLl91cmwsIHN0cmVhbS5odHRwSGVhZGVycyksIGhhbmRsZVJlc3BvbnNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgaHR0cHMgPSByZXF1aXJlKFwiaHR0cHNcIik7XG4gICAgICB0aGlzLl9yZXF1ZXN0ID0gaHR0cHMucmVxdWVzdChjcmVhdGVSZXF1ZXN0T3B0aW9ucyh0aGlzLl91cmwsIHN0cmVhbS5odHRwSGVhZGVycyksIGhhbmRsZVJlc3BvbnNlKTtcbiAgICB9XG4gICAgdGhpcy5fcmVxdWVzdC5vbihcImVycm9yXCIsIHJlYXNvbiA9PiB7XG4gICAgICB0aGlzLl9zdG9yZWRFcnJvciA9IHJlYXNvbjtcbiAgICAgIHRoaXMuX2hlYWRlcnNDYXBhYmlsaXR5LnJlamVjdChyZWFzb24pO1xuICAgIH0pO1xuICAgIHRoaXMuX3JlcXVlc3QuZW5kKCk7XG4gIH1cbn1cbmNsYXNzIFBERk5vZGVTdHJlYW1SYW5nZVJlYWRlciBleHRlbmRzIEJhc2VSYW5nZVJlYWRlciB7XG4gIGNvbnN0cnVjdG9yKHN0cmVhbSwgc3RhcnQsIGVuZCkge1xuICAgIHN1cGVyKHN0cmVhbSk7XG4gICAgdGhpcy5faHR0cEhlYWRlcnMgPSB7fTtcbiAgICBmb3IgKGNvbnN0IHByb3BlcnR5IGluIHN0cmVhbS5odHRwSGVhZGVycykge1xuICAgICAgY29uc3QgdmFsdWUgPSBzdHJlYW0uaHR0cEhlYWRlcnNbcHJvcGVydHldO1xuICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB0aGlzLl9odHRwSGVhZGVyc1twcm9wZXJ0eV0gPSB2YWx1ZTtcbiAgICB9XG4gICAgdGhpcy5faHR0cEhlYWRlcnMuUmFuZ2UgPSBgYnl0ZXM9JHtzdGFydH0tJHtlbmQgLSAxfWA7XG4gICAgY29uc3QgaGFuZGxlUmVzcG9uc2UgPSByZXNwb25zZSA9PiB7XG4gICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzQ29kZSA9PT0gNDA0KSB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gbmV3IF91dGlsLk1pc3NpbmdQREZFeGNlcHRpb24oYE1pc3NpbmcgUERGIFwiJHt0aGlzLl91cmx9XCIuYCk7XG4gICAgICAgIHRoaXMuX3N0b3JlZEVycm9yID0gZXJyb3I7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3NldFJlYWRhYmxlU3RyZWFtKHJlc3BvbnNlKTtcbiAgICB9O1xuICAgIHRoaXMuX3JlcXVlc3QgPSBudWxsO1xuICAgIGlmICh0aGlzLl91cmwucHJvdG9jb2wgPT09IFwiaHR0cDpcIikge1xuICAgICAgY29uc3QgaHR0cCA9IHJlcXVpcmUoXCJodHRwXCIpO1xuICAgICAgdGhpcy5fcmVxdWVzdCA9IGh0dHAucmVxdWVzdChjcmVhdGVSZXF1ZXN0T3B0aW9ucyh0aGlzLl91cmwsIHRoaXMuX2h0dHBIZWFkZXJzKSwgaGFuZGxlUmVzcG9uc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBodHRwcyA9IHJlcXVpcmUoXCJodHRwc1wiKTtcbiAgICAgIHRoaXMuX3JlcXVlc3QgPSBodHRwcy5yZXF1ZXN0KGNyZWF0ZVJlcXVlc3RPcHRpb25zKHRoaXMuX3VybCwgdGhpcy5faHR0cEhlYWRlcnMpLCBoYW5kbGVSZXNwb25zZSk7XG4gICAgfVxuICAgIHRoaXMuX3JlcXVlc3Qub24oXCJlcnJvclwiLCByZWFzb24gPT4ge1xuICAgICAgdGhpcy5fc3RvcmVkRXJyb3IgPSByZWFzb247XG4gICAgfSk7XG4gICAgdGhpcy5fcmVxdWVzdC5lbmQoKTtcbiAgfVxufVxuY2xhc3MgUERGTm9kZVN0cmVhbUZzRnVsbFJlYWRlciBleHRlbmRzIEJhc2VGdWxsUmVhZGVyIHtcbiAgY29uc3RydWN0b3Ioc3RyZWFtKSB7XG4gICAgc3VwZXIoc3RyZWFtKTtcbiAgICBsZXQgcGF0aCA9IGRlY29kZVVSSUNvbXBvbmVudCh0aGlzLl91cmwucGF0aCk7XG4gICAgaWYgKGZpbGVVcmlSZWdleC50ZXN0KHRoaXMuX3VybC5ocmVmKSkge1xuICAgICAgcGF0aCA9IHBhdGgucmVwbGFjZSgvXlxcLy8sIFwiXCIpO1xuICAgIH1cbiAgICBjb25zdCBmcyA9IHJlcXVpcmUoXCJmc1wiKTtcbiAgICBmcy5sc3RhdChwYXRoLCAoZXJyb3IsIHN0YXQpID0+IHtcbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICBpZiAoZXJyb3IuY29kZSA9PT0gXCJFTk9FTlRcIikge1xuICAgICAgICAgIGVycm9yID0gbmV3IF91dGlsLk1pc3NpbmdQREZFeGNlcHRpb24oYE1pc3NpbmcgUERGIFwiJHtwYXRofVwiLmApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3N0b3JlZEVycm9yID0gZXJyb3I7XG4gICAgICAgIHRoaXMuX2hlYWRlcnNDYXBhYmlsaXR5LnJlamVjdChlcnJvcik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2NvbnRlbnRMZW5ndGggPSBzdGF0LnNpemU7XG4gICAgICB0aGlzLl9zZXRSZWFkYWJsZVN0cmVhbShmcy5jcmVhdGVSZWFkU3RyZWFtKHBhdGgpKTtcbiAgICAgIHRoaXMuX2hlYWRlcnNDYXBhYmlsaXR5LnJlc29sdmUoKTtcbiAgICB9KTtcbiAgfVxufVxuY2xhc3MgUERGTm9kZVN0cmVhbUZzUmFuZ2VSZWFkZXIgZXh0ZW5kcyBCYXNlUmFuZ2VSZWFkZXIge1xuICBjb25zdHJ1Y3RvcihzdHJlYW0sIHN0YXJ0LCBlbmQpIHtcbiAgICBzdXBlcihzdHJlYW0pO1xuICAgIGxldCBwYXRoID0gZGVjb2RlVVJJQ29tcG9uZW50KHRoaXMuX3VybC5wYXRoKTtcbiAgICBpZiAoZmlsZVVyaVJlZ2V4LnRlc3QodGhpcy5fdXJsLmhyZWYpKSB7XG4gICAgICBwYXRoID0gcGF0aC5yZXBsYWNlKC9eXFwvLywgXCJcIik7XG4gICAgfVxuICAgIGNvbnN0IGZzID0gcmVxdWlyZShcImZzXCIpO1xuICAgIHRoaXMuX3NldFJlYWRhYmxlU3RyZWFtKGZzLmNyZWF0ZVJlYWRTdHJlYW0ocGF0aCwge1xuICAgICAgc3RhcnQsXG4gICAgICBlbmQ6IGVuZCAtIDFcbiAgICB9KSk7XG4gIH1cbn1cblxuLyoqKi8gfSksXG4vKiAyNCAqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykgPT4ge1xuXG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xuZXhwb3J0cy5TVkdHcmFwaGljcyA9IHZvaWQgMDtcbnZhciBfZGlzcGxheV91dGlscyA9IF9fd19wZGZqc19yZXF1aXJlX18oNik7XG52YXIgX3V0aWwgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEpO1xuO1xuY29uc3QgU1ZHX0RFRkFVTFRTID0ge1xuICBmb250U3R5bGU6IFwibm9ybWFsXCIsXG4gIGZvbnRXZWlnaHQ6IFwibm9ybWFsXCIsXG4gIGZpbGxDb2xvcjogXCIjMDAwMDAwXCJcbn07XG5jb25zdCBYTUxfTlMgPSBcImh0dHA6Ly93d3cudzMub3JnL1hNTC8xOTk4L25hbWVzcGFjZVwiO1xuY29uc3QgWExJTktfTlMgPSBcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIjtcbmNvbnN0IExJTkVfQ0FQX1NUWUxFUyA9IFtcImJ1dHRcIiwgXCJyb3VuZFwiLCBcInNxdWFyZVwiXTtcbmNvbnN0IExJTkVfSk9JTl9TVFlMRVMgPSBbXCJtaXRlclwiLCBcInJvdW5kXCIsIFwiYmV2ZWxcIl07XG5jb25zdCBjcmVhdGVPYmplY3RVUkwgPSBmdW5jdGlvbiAoZGF0YSwgY29udGVudFR5cGUgPSBcIlwiLCBmb3JjZURhdGFTY2hlbWEgPSBmYWxzZSkge1xuICBpZiAoVVJMLmNyZWF0ZU9iamVjdFVSTCAmJiB0eXBlb2YgQmxvYiAhPT0gXCJ1bmRlZmluZWRcIiAmJiAhZm9yY2VEYXRhU2NoZW1hKSB7XG4gICAgcmV0dXJuIFVSTC5jcmVhdGVPYmplY3RVUkwobmV3IEJsb2IoW2RhdGFdLCB7XG4gICAgICB0eXBlOiBjb250ZW50VHlwZVxuICAgIH0pKTtcbiAgfVxuICBjb25zdCBkaWdpdHMgPSBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky89XCI7XG4gIGxldCBidWZmZXIgPSBgZGF0YToke2NvbnRlbnRUeXBlfTtiYXNlNjQsYDtcbiAgZm9yIChsZXQgaSA9IDAsIGlpID0gZGF0YS5sZW5ndGg7IGkgPCBpaTsgaSArPSAzKSB7XG4gICAgY29uc3QgYjEgPSBkYXRhW2ldICYgMHhmZjtcbiAgICBjb25zdCBiMiA9IGRhdGFbaSArIDFdICYgMHhmZjtcbiAgICBjb25zdCBiMyA9IGRhdGFbaSArIDJdICYgMHhmZjtcbiAgICBjb25zdCBkMSA9IGIxID4+IDIsXG4gICAgICBkMiA9IChiMSAmIDMpIDw8IDQgfCBiMiA+PiA0O1xuICAgIGNvbnN0IGQzID0gaSArIDEgPCBpaSA/IChiMiAmIDB4ZikgPDwgMiB8IGIzID4+IDYgOiA2NDtcbiAgICBjb25zdCBkNCA9IGkgKyAyIDwgaWkgPyBiMyAmIDB4M2YgOiA2NDtcbiAgICBidWZmZXIgKz0gZGlnaXRzW2QxXSArIGRpZ2l0c1tkMl0gKyBkaWdpdHNbZDNdICsgZGlnaXRzW2Q0XTtcbiAgfVxuICByZXR1cm4gYnVmZmVyO1xufTtcbmNvbnN0IGNvbnZlcnRJbWdEYXRhVG9QbmcgPSBmdW5jdGlvbiAoKSB7XG4gIGNvbnN0IFBOR19IRUFERVIgPSBuZXcgVWludDhBcnJheShbMHg4OSwgMHg1MCwgMHg0ZSwgMHg0NywgMHgwZCwgMHgwYSwgMHgxYSwgMHgwYV0pO1xuICBjb25zdCBDSFVOS19XUkFQUEVSX1NJWkUgPSAxMjtcbiAgY29uc3QgY3JjVGFibGUgPSBuZXcgSW50MzJBcnJheSgyNTYpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IDI1NjsgaSsrKSB7XG4gICAgbGV0IGMgPSBpO1xuICAgIGZvciAobGV0IGggPSAwOyBoIDwgODsgaCsrKSB7XG4gICAgICBjID0gYyAmIDEgPyAweGVkYjg4MzIwIF4gYyA+PiAxICYgMHg3ZmZmZmZmZiA6IGMgPj4gMSAmIDB4N2ZmZmZmZmY7XG4gICAgfVxuICAgIGNyY1RhYmxlW2ldID0gYztcbiAgfVxuICBmdW5jdGlvbiBjcmMzMihkYXRhLCBzdGFydCwgZW5kKSB7XG4gICAgbGV0IGNyYyA9IC0xO1xuICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICBjb25zdCBhID0gKGNyYyBeIGRhdGFbaV0pICYgMHhmZjtcbiAgICAgIGNvbnN0IGIgPSBjcmNUYWJsZVthXTtcbiAgICAgIGNyYyA9IGNyYyA+Pj4gOCBeIGI7XG4gICAgfVxuICAgIHJldHVybiBjcmMgXiAtMTtcbiAgfVxuICBmdW5jdGlvbiB3cml0ZVBuZ0NodW5rKHR5cGUsIGJvZHksIGRhdGEsIG9mZnNldCkge1xuICAgIGxldCBwID0gb2Zmc2V0O1xuICAgIGNvbnN0IGxlbiA9IGJvZHkubGVuZ3RoO1xuICAgIGRhdGFbcF0gPSBsZW4gPj4gMjQgJiAweGZmO1xuICAgIGRhdGFbcCArIDFdID0gbGVuID4+IDE2ICYgMHhmZjtcbiAgICBkYXRhW3AgKyAyXSA9IGxlbiA+PiA4ICYgMHhmZjtcbiAgICBkYXRhW3AgKyAzXSA9IGxlbiAmIDB4ZmY7XG4gICAgcCArPSA0O1xuICAgIGRhdGFbcF0gPSB0eXBlLmNoYXJDb2RlQXQoMCkgJiAweGZmO1xuICAgIGRhdGFbcCArIDFdID0gdHlwZS5jaGFyQ29kZUF0KDEpICYgMHhmZjtcbiAgICBkYXRhW3AgKyAyXSA9IHR5cGUuY2hhckNvZGVBdCgyKSAmIDB4ZmY7XG4gICAgZGF0YVtwICsgM10gPSB0eXBlLmNoYXJDb2RlQXQoMykgJiAweGZmO1xuICAgIHAgKz0gNDtcbiAgICBkYXRhLnNldChib2R5LCBwKTtcbiAgICBwICs9IGJvZHkubGVuZ3RoO1xuICAgIGNvbnN0IGNyYyA9IGNyYzMyKGRhdGEsIG9mZnNldCArIDQsIHApO1xuICAgIGRhdGFbcF0gPSBjcmMgPj4gMjQgJiAweGZmO1xuICAgIGRhdGFbcCArIDFdID0gY3JjID4+IDE2ICYgMHhmZjtcbiAgICBkYXRhW3AgKyAyXSA9IGNyYyA+PiA4ICYgMHhmZjtcbiAgICBkYXRhW3AgKyAzXSA9IGNyYyAmIDB4ZmY7XG4gIH1cbiAgZnVuY3Rpb24gYWRsZXIzMihkYXRhLCBzdGFydCwgZW5kKSB7XG4gICAgbGV0IGEgPSAxO1xuICAgIGxldCBiID0gMDtcbiAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgICAgYSA9IChhICsgKGRhdGFbaV0gJiAweGZmKSkgJSA2NTUyMTtcbiAgICAgIGIgPSAoYiArIGEpICUgNjU1MjE7XG4gICAgfVxuICAgIHJldHVybiBiIDw8IDE2IHwgYTtcbiAgfVxuICBmdW5jdGlvbiBkZWZsYXRlU3luYyhsaXRlcmFscykge1xuICAgIGlmICghX3V0aWwuaXNOb2RlSlMpIHtcbiAgICAgIHJldHVybiBkZWZsYXRlU3luY1VuY29tcHJlc3NlZChsaXRlcmFscyk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBjb25zdCBpbnB1dCA9IHBhcnNlSW50KHByb2Nlc3MudmVyc2lvbnMubm9kZSkgPj0gOCA/IGxpdGVyYWxzIDogQnVmZmVyLmZyb20obGl0ZXJhbHMpO1xuICAgICAgY29uc3Qgb3V0cHV0ID0gcmVxdWlyZShcInpsaWJcIikuZGVmbGF0ZVN5bmMoaW5wdXQsIHtcbiAgICAgICAgbGV2ZWw6IDlcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG91dHB1dCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgPyBvdXRwdXQgOiBuZXcgVWludDhBcnJheShvdXRwdXQpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICgwLCBfdXRpbC53YXJuKShcIk5vdCBjb21wcmVzc2luZyBQTkcgYmVjYXVzZSB6bGliLmRlZmxhdGVTeW5jIGlzIHVuYXZhaWxhYmxlOiBcIiArIGUpO1xuICAgIH1cbiAgICByZXR1cm4gZGVmbGF0ZVN5bmNVbmNvbXByZXNzZWQobGl0ZXJhbHMpO1xuICB9XG4gIGZ1bmN0aW9uIGRlZmxhdGVTeW5jVW5jb21wcmVzc2VkKGxpdGVyYWxzKSB7XG4gICAgbGV0IGxlbiA9IGxpdGVyYWxzLmxlbmd0aDtcbiAgICBjb25zdCBtYXhCbG9ja0xlbmd0aCA9IDB4ZmZmZjtcbiAgICBjb25zdCBkZWZsYXRlQmxvY2tzID0gTWF0aC5jZWlsKGxlbiAvIG1heEJsb2NrTGVuZ3RoKTtcbiAgICBjb25zdCBpZGF0ID0gbmV3IFVpbnQ4QXJyYXkoMiArIGxlbiArIGRlZmxhdGVCbG9ja3MgKiA1ICsgNCk7XG4gICAgbGV0IHBpID0gMDtcbiAgICBpZGF0W3BpKytdID0gMHg3ODtcbiAgICBpZGF0W3BpKytdID0gMHg5YztcbiAgICBsZXQgcG9zID0gMDtcbiAgICB3aGlsZSAobGVuID4gbWF4QmxvY2tMZW5ndGgpIHtcbiAgICAgIGlkYXRbcGkrK10gPSAweDAwO1xuICAgICAgaWRhdFtwaSsrXSA9IDB4ZmY7XG4gICAgICBpZGF0W3BpKytdID0gMHhmZjtcbiAgICAgIGlkYXRbcGkrK10gPSAweDAwO1xuICAgICAgaWRhdFtwaSsrXSA9IDB4MDA7XG4gICAgICBpZGF0LnNldChsaXRlcmFscy5zdWJhcnJheShwb3MsIHBvcyArIG1heEJsb2NrTGVuZ3RoKSwgcGkpO1xuICAgICAgcGkgKz0gbWF4QmxvY2tMZW5ndGg7XG4gICAgICBwb3MgKz0gbWF4QmxvY2tMZW5ndGg7XG4gICAgICBsZW4gLT0gbWF4QmxvY2tMZW5ndGg7XG4gICAgfVxuICAgIGlkYXRbcGkrK10gPSAweDAxO1xuICAgIGlkYXRbcGkrK10gPSBsZW4gJiAweGZmO1xuICAgIGlkYXRbcGkrK10gPSBsZW4gPj4gOCAmIDB4ZmY7XG4gICAgaWRhdFtwaSsrXSA9IH5sZW4gJiAweGZmZmYgJiAweGZmO1xuICAgIGlkYXRbcGkrK10gPSAofmxlbiAmIDB4ZmZmZikgPj4gOCAmIDB4ZmY7XG4gICAgaWRhdC5zZXQobGl0ZXJhbHMuc3ViYXJyYXkocG9zKSwgcGkpO1xuICAgIHBpICs9IGxpdGVyYWxzLmxlbmd0aCAtIHBvcztcbiAgICBjb25zdCBhZGxlciA9IGFkbGVyMzIobGl0ZXJhbHMsIDAsIGxpdGVyYWxzLmxlbmd0aCk7XG4gICAgaWRhdFtwaSsrXSA9IGFkbGVyID4+IDI0ICYgMHhmZjtcbiAgICBpZGF0W3BpKytdID0gYWRsZXIgPj4gMTYgJiAweGZmO1xuICAgIGlkYXRbcGkrK10gPSBhZGxlciA+PiA4ICYgMHhmZjtcbiAgICBpZGF0W3BpKytdID0gYWRsZXIgJiAweGZmO1xuICAgIHJldHVybiBpZGF0O1xuICB9XG4gIGZ1bmN0aW9uIGVuY29kZShpbWdEYXRhLCBraW5kLCBmb3JjZURhdGFTY2hlbWEsIGlzTWFzaykge1xuICAgIGNvbnN0IHdpZHRoID0gaW1nRGF0YS53aWR0aDtcbiAgICBjb25zdCBoZWlnaHQgPSBpbWdEYXRhLmhlaWdodDtcbiAgICBsZXQgYml0RGVwdGgsIGNvbG9yVHlwZSwgbGluZVNpemU7XG4gICAgY29uc3QgYnl0ZXMgPSBpbWdEYXRhLmRhdGE7XG4gICAgc3dpdGNoIChraW5kKSB7XG4gICAgICBjYXNlIF91dGlsLkltYWdlS2luZC5HUkFZU0NBTEVfMUJQUDpcbiAgICAgICAgY29sb3JUeXBlID0gMDtcbiAgICAgICAgYml0RGVwdGggPSAxO1xuICAgICAgICBsaW5lU2l6ZSA9IHdpZHRoICsgNyA+PiAzO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgX3V0aWwuSW1hZ2VLaW5kLlJHQl8yNEJQUDpcbiAgICAgICAgY29sb3JUeXBlID0gMjtcbiAgICAgICAgYml0RGVwdGggPSA4O1xuICAgICAgICBsaW5lU2l6ZSA9IHdpZHRoICogMztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIF91dGlsLkltYWdlS2luZC5SR0JBXzMyQlBQOlxuICAgICAgICBjb2xvclR5cGUgPSA2O1xuICAgICAgICBiaXREZXB0aCA9IDg7XG4gICAgICAgIGxpbmVTaXplID0gd2lkdGggKiA0O1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgZm9ybWF0XCIpO1xuICAgIH1cbiAgICBjb25zdCBsaXRlcmFscyA9IG5ldyBVaW50OEFycmF5KCgxICsgbGluZVNpemUpICogaGVpZ2h0KTtcbiAgICBsZXQgb2Zmc2V0TGl0ZXJhbHMgPSAwLFxuICAgICAgb2Zmc2V0Qnl0ZXMgPSAwO1xuICAgIGZvciAobGV0IHkgPSAwOyB5IDwgaGVpZ2h0OyArK3kpIHtcbiAgICAgIGxpdGVyYWxzW29mZnNldExpdGVyYWxzKytdID0gMDtcbiAgICAgIGxpdGVyYWxzLnNldChieXRlcy5zdWJhcnJheShvZmZzZXRCeXRlcywgb2Zmc2V0Qnl0ZXMgKyBsaW5lU2l6ZSksIG9mZnNldExpdGVyYWxzKTtcbiAgICAgIG9mZnNldEJ5dGVzICs9IGxpbmVTaXplO1xuICAgICAgb2Zmc2V0TGl0ZXJhbHMgKz0gbGluZVNpemU7XG4gICAgfVxuICAgIGlmIChraW5kID09PSBfdXRpbC5JbWFnZUtpbmQuR1JBWVNDQUxFXzFCUFAgJiYgaXNNYXNrKSB7XG4gICAgICBvZmZzZXRMaXRlcmFscyA9IDA7XG4gICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IGhlaWdodDsgeSsrKSB7XG4gICAgICAgIG9mZnNldExpdGVyYWxzKys7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZVNpemU7IGkrKykge1xuICAgICAgICAgIGxpdGVyYWxzW29mZnNldExpdGVyYWxzKytdIF49IDB4ZmY7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgaWhkciA9IG5ldyBVaW50OEFycmF5KFt3aWR0aCA+PiAyNCAmIDB4ZmYsIHdpZHRoID4+IDE2ICYgMHhmZiwgd2lkdGggPj4gOCAmIDB4ZmYsIHdpZHRoICYgMHhmZiwgaGVpZ2h0ID4+IDI0ICYgMHhmZiwgaGVpZ2h0ID4+IDE2ICYgMHhmZiwgaGVpZ2h0ID4+IDggJiAweGZmLCBoZWlnaHQgJiAweGZmLCBiaXREZXB0aCwgY29sb3JUeXBlLCAweDAwLCAweDAwLCAweDAwXSk7XG4gICAgY29uc3QgaWRhdCA9IGRlZmxhdGVTeW5jKGxpdGVyYWxzKTtcbiAgICBjb25zdCBwbmdMZW5ndGggPSBQTkdfSEVBREVSLmxlbmd0aCArIENIVU5LX1dSQVBQRVJfU0laRSAqIDMgKyBpaGRyLmxlbmd0aCArIGlkYXQubGVuZ3RoO1xuICAgIGNvbnN0IGRhdGEgPSBuZXcgVWludDhBcnJheShwbmdMZW5ndGgpO1xuICAgIGxldCBvZmZzZXQgPSAwO1xuICAgIGRhdGEuc2V0KFBOR19IRUFERVIsIG9mZnNldCk7XG4gICAgb2Zmc2V0ICs9IFBOR19IRUFERVIubGVuZ3RoO1xuICAgIHdyaXRlUG5nQ2h1bmsoXCJJSERSXCIsIGloZHIsIGRhdGEsIG9mZnNldCk7XG4gICAgb2Zmc2V0ICs9IENIVU5LX1dSQVBQRVJfU0laRSArIGloZHIubGVuZ3RoO1xuICAgIHdyaXRlUG5nQ2h1bmsoXCJJREFUQVwiLCBpZGF0LCBkYXRhLCBvZmZzZXQpO1xuICAgIG9mZnNldCArPSBDSFVOS19XUkFQUEVSX1NJWkUgKyBpZGF0Lmxlbmd0aDtcbiAgICB3cml0ZVBuZ0NodW5rKFwiSUVORFwiLCBuZXcgVWludDhBcnJheSgwKSwgZGF0YSwgb2Zmc2V0KTtcbiAgICByZXR1cm4gY3JlYXRlT2JqZWN0VVJMKGRhdGEsIFwiaW1hZ2UvcG5nXCIsIGZvcmNlRGF0YVNjaGVtYSk7XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uIGNvbnZlcnRJbWdEYXRhVG9QbmcoaW1nRGF0YSwgZm9yY2VEYXRhU2NoZW1hLCBpc01hc2spIHtcbiAgICBjb25zdCBraW5kID0gaW1nRGF0YS5raW5kID09PSB1bmRlZmluZWQgPyBfdXRpbC5JbWFnZUtpbmQuR1JBWVNDQUxFXzFCUFAgOiBpbWdEYXRhLmtpbmQ7XG4gICAgcmV0dXJuIGVuY29kZShpbWdEYXRhLCBraW5kLCBmb3JjZURhdGFTY2hlbWEsIGlzTWFzayk7XG4gIH07XG59KCk7XG5jbGFzcyBTVkdFeHRyYVN0YXRlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5mb250U2l6ZVNjYWxlID0gMTtcbiAgICB0aGlzLmZvbnRXZWlnaHQgPSBTVkdfREVGQVVMVFMuZm9udFdlaWdodDtcbiAgICB0aGlzLmZvbnRTaXplID0gMDtcbiAgICB0aGlzLnRleHRNYXRyaXggPSBfdXRpbC5JREVOVElUWV9NQVRSSVg7XG4gICAgdGhpcy5mb250TWF0cml4ID0gX3V0aWwuRk9OVF9JREVOVElUWV9NQVRSSVg7XG4gICAgdGhpcy5sZWFkaW5nID0gMDtcbiAgICB0aGlzLnRleHRSZW5kZXJpbmdNb2RlID0gX3V0aWwuVGV4dFJlbmRlcmluZ01vZGUuRklMTDtcbiAgICB0aGlzLnRleHRNYXRyaXhTY2FsZSA9IDE7XG4gICAgdGhpcy54ID0gMDtcbiAgICB0aGlzLnkgPSAwO1xuICAgIHRoaXMubGluZVggPSAwO1xuICAgIHRoaXMubGluZVkgPSAwO1xuICAgIHRoaXMuY2hhclNwYWNpbmcgPSAwO1xuICAgIHRoaXMud29yZFNwYWNpbmcgPSAwO1xuICAgIHRoaXMudGV4dEhTY2FsZSA9IDE7XG4gICAgdGhpcy50ZXh0UmlzZSA9IDA7XG4gICAgdGhpcy5maWxsQ29sb3IgPSBTVkdfREVGQVVMVFMuZmlsbENvbG9yO1xuICAgIHRoaXMuc3Ryb2tlQ29sb3IgPSBcIiMwMDAwMDBcIjtcbiAgICB0aGlzLmZpbGxBbHBoYSA9IDE7XG4gICAgdGhpcy5zdHJva2VBbHBoYSA9IDE7XG4gICAgdGhpcy5saW5lV2lkdGggPSAxO1xuICAgIHRoaXMubGluZUpvaW4gPSBcIlwiO1xuICAgIHRoaXMubGluZUNhcCA9IFwiXCI7XG4gICAgdGhpcy5taXRlckxpbWl0ID0gMDtcbiAgICB0aGlzLmRhc2hBcnJheSA9IFtdO1xuICAgIHRoaXMuZGFzaFBoYXNlID0gMDtcbiAgICB0aGlzLmRlcGVuZGVuY2llcyA9IFtdO1xuICAgIHRoaXMuYWN0aXZlQ2xpcFVybCA9IG51bGw7XG4gICAgdGhpcy5jbGlwR3JvdXAgPSBudWxsO1xuICAgIHRoaXMubWFza0lkID0gXCJcIjtcbiAgfVxuICBjbG9uZSgpIHtcbiAgICByZXR1cm4gT2JqZWN0LmNyZWF0ZSh0aGlzKTtcbiAgfVxuICBzZXRDdXJyZW50UG9pbnQoeCwgeSkge1xuICAgIHRoaXMueCA9IHg7XG4gICAgdGhpcy55ID0geTtcbiAgfVxufVxuZnVuY3Rpb24gb3BMaXN0VG9UcmVlKG9wTGlzdCkge1xuICBsZXQgb3BUcmVlID0gW107XG4gIGNvbnN0IHRtcCA9IFtdO1xuICBmb3IgKGNvbnN0IG9wTGlzdEVsZW1lbnQgb2Ygb3BMaXN0KSB7XG4gICAgaWYgKG9wTGlzdEVsZW1lbnQuZm4gPT09IFwic2F2ZVwiKSB7XG4gICAgICBvcFRyZWUucHVzaCh7XG4gICAgICAgIGZuSWQ6IDkyLFxuICAgICAgICBmbjogXCJncm91cFwiLFxuICAgICAgICBpdGVtczogW11cbiAgICAgIH0pO1xuICAgICAgdG1wLnB1c2gob3BUcmVlKTtcbiAgICAgIG9wVHJlZSA9IG9wVHJlZS5hdCgtMSkuaXRlbXM7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKG9wTGlzdEVsZW1lbnQuZm4gPT09IFwicmVzdG9yZVwiKSB7XG4gICAgICBvcFRyZWUgPSB0bXAucG9wKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9wVHJlZS5wdXNoKG9wTGlzdEVsZW1lbnQpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gb3BUcmVlO1xufVxuZnVuY3Rpb24gcGYodmFsdWUpIHtcbiAgaWYgKE51bWJlci5pc0ludGVnZXIodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gIH1cbiAgY29uc3QgcyA9IHZhbHVlLnRvRml4ZWQoMTApO1xuICBsZXQgaSA9IHMubGVuZ3RoIC0gMTtcbiAgaWYgKHNbaV0gIT09IFwiMFwiKSB7XG4gICAgcmV0dXJuIHM7XG4gIH1cbiAgZG8ge1xuICAgIGktLTtcbiAgfSB3aGlsZSAoc1tpXSA9PT0gXCIwXCIpO1xuICByZXR1cm4gcy5zdWJzdHJpbmcoMCwgc1tpXSA9PT0gXCIuXCIgPyBpIDogaSArIDEpO1xufVxuZnVuY3Rpb24gcG0obSkge1xuICBpZiAobVs0XSA9PT0gMCAmJiBtWzVdID09PSAwKSB7XG4gICAgaWYgKG1bMV0gPT09IDAgJiYgbVsyXSA9PT0gMCkge1xuICAgICAgaWYgKG1bMF0gPT09IDEgJiYgbVszXSA9PT0gMSkge1xuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBgc2NhbGUoJHtwZihtWzBdKX0gJHtwZihtWzNdKX0pYDtcbiAgICB9XG4gICAgaWYgKG1bMF0gPT09IG1bM10gJiYgbVsxXSA9PT0gLW1bMl0pIHtcbiAgICAgIGNvbnN0IGEgPSBNYXRoLmFjb3MobVswXSkgKiAxODAgLyBNYXRoLlBJO1xuICAgICAgcmV0dXJuIGByb3RhdGUoJHtwZihhKX0pYDtcbiAgICB9XG4gIH0gZWxzZSBpZiAobVswXSA9PT0gMSAmJiBtWzFdID09PSAwICYmIG1bMl0gPT09IDAgJiYgbVszXSA9PT0gMSkge1xuICAgIHJldHVybiBgdHJhbnNsYXRlKCR7cGYobVs0XSl9ICR7cGYobVs1XSl9KWA7XG4gIH1cbiAgcmV0dXJuIGBtYXRyaXgoJHtwZihtWzBdKX0gJHtwZihtWzFdKX0gJHtwZihtWzJdKX0gJHtwZihtWzNdKX0gJHtwZihtWzRdKX0gYCArIGAke3BmKG1bNV0pfSlgO1xufVxubGV0IGNsaXBDb3VudCA9IDA7XG5sZXQgbWFza0NvdW50ID0gMDtcbmxldCBzaGFkaW5nQ291bnQgPSAwO1xuY2xhc3MgU1ZHR3JhcGhpY3Mge1xuICBjb25zdHJ1Y3Rvcihjb21tb25PYmpzLCBvYmpzLCBmb3JjZURhdGFTY2hlbWEgPSBmYWxzZSkge1xuICAgICgwLCBfZGlzcGxheV91dGlscy5kZXByZWNhdGVkKShcIlRoZSBTVkcgYmFjay1lbmQgaXMgbm8gbG9uZ2VyIG1haW50YWluZWQgYW5kICptYXkqIGJlIHJlbW92ZWQgaW4gdGhlIGZ1dHVyZS5cIik7XG4gICAgdGhpcy5zdmdGYWN0b3J5ID0gbmV3IF9kaXNwbGF5X3V0aWxzLkRPTVNWR0ZhY3RvcnkoKTtcbiAgICB0aGlzLmN1cnJlbnQgPSBuZXcgU1ZHRXh0cmFTdGF0ZSgpO1xuICAgIHRoaXMudHJhbnNmb3JtTWF0cml4ID0gX3V0aWwuSURFTlRJVFlfTUFUUklYO1xuICAgIHRoaXMudHJhbnNmb3JtU3RhY2sgPSBbXTtcbiAgICB0aGlzLmV4dHJhU3RhY2sgPSBbXTtcbiAgICB0aGlzLmNvbW1vbk9ianMgPSBjb21tb25PYmpzO1xuICAgIHRoaXMub2JqcyA9IG9ianM7XG4gICAgdGhpcy5wZW5kaW5nQ2xpcCA9IG51bGw7XG4gICAgdGhpcy5wZW5kaW5nRU9GaWxsID0gZmFsc2U7XG4gICAgdGhpcy5lbWJlZEZvbnRzID0gZmFsc2U7XG4gICAgdGhpcy5lbWJlZGRlZEZvbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLmNzc1N0eWxlID0gbnVsbDtcbiAgICB0aGlzLmZvcmNlRGF0YVNjaGVtYSA9ICEhZm9yY2VEYXRhU2NoZW1hO1xuICAgIHRoaXMuX29wZXJhdG9ySWRNYXBwaW5nID0gW107XG4gICAgZm9yIChjb25zdCBvcCBpbiBfdXRpbC5PUFMpIHtcbiAgICAgIHRoaXMuX29wZXJhdG9ySWRNYXBwaW5nW191dGlsLk9QU1tvcF1dID0gb3A7XG4gICAgfVxuICB9XG4gIGdldE9iamVjdChkYXRhLCBmYWxsYmFjayA9IG51bGwpIHtcbiAgICBpZiAodHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybiBkYXRhLnN0YXJ0c1dpdGgoXCJnX1wiKSA/IHRoaXMuY29tbW9uT2Jqcy5nZXQoZGF0YSkgOiB0aGlzLm9ianMuZ2V0KGRhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsbGJhY2s7XG4gIH1cbiAgc2F2ZSgpIHtcbiAgICB0aGlzLnRyYW5zZm9ybVN0YWNrLnB1c2godGhpcy50cmFuc2Zvcm1NYXRyaXgpO1xuICAgIGNvbnN0IG9sZCA9IHRoaXMuY3VycmVudDtcbiAgICB0aGlzLmV4dHJhU3RhY2sucHVzaChvbGQpO1xuICAgIHRoaXMuY3VycmVudCA9IG9sZC5jbG9uZSgpO1xuICB9XG4gIHJlc3RvcmUoKSB7XG4gICAgdGhpcy50cmFuc2Zvcm1NYXRyaXggPSB0aGlzLnRyYW5zZm9ybVN0YWNrLnBvcCgpO1xuICAgIHRoaXMuY3VycmVudCA9IHRoaXMuZXh0cmFTdGFjay5wb3AoKTtcbiAgICB0aGlzLnBlbmRpbmdDbGlwID0gbnVsbDtcbiAgICB0aGlzLnRncnAgPSBudWxsO1xuICB9XG4gIGdyb3VwKGl0ZW1zKSB7XG4gICAgdGhpcy5zYXZlKCk7XG4gICAgdGhpcy5leGVjdXRlT3BUcmVlKGl0ZW1zKTtcbiAgICB0aGlzLnJlc3RvcmUoKTtcbiAgfVxuICBsb2FkRGVwZW5kZW5jaWVzKG9wZXJhdG9yTGlzdCkge1xuICAgIGNvbnN0IGZuQXJyYXkgPSBvcGVyYXRvckxpc3QuZm5BcnJheTtcbiAgICBjb25zdCBhcmdzQXJyYXkgPSBvcGVyYXRvckxpc3QuYXJnc0FycmF5O1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IGZuQXJyYXkubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgaWYgKGZuQXJyYXlbaV0gIT09IF91dGlsLk9QUy5kZXBlbmRlbmN5KSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBvYmogb2YgYXJnc0FycmF5W2ldKSB7XG4gICAgICAgIGNvbnN0IG9ianNQb29sID0gb2JqLnN0YXJ0c1dpdGgoXCJnX1wiKSA/IHRoaXMuY29tbW9uT2JqcyA6IHRoaXMub2JqcztcbiAgICAgICAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICAgIG9ianNQb29sLmdldChvYmosIHJlc29sdmUpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jdXJyZW50LmRlcGVuZGVuY2llcy5wdXNoKHByb21pc2UpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5hbGwodGhpcy5jdXJyZW50LmRlcGVuZGVuY2llcyk7XG4gIH1cbiAgdHJhbnNmb3JtKGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgICBjb25zdCB0cmFuc2Zvcm1NYXRyaXggPSBbYSwgYiwgYywgZCwgZSwgZl07XG4gICAgdGhpcy50cmFuc2Zvcm1NYXRyaXggPSBfdXRpbC5VdGlsLnRyYW5zZm9ybSh0aGlzLnRyYW5zZm9ybU1hdHJpeCwgdHJhbnNmb3JtTWF0cml4KTtcbiAgICB0aGlzLnRncnAgPSBudWxsO1xuICB9XG4gIGdldFNWRyhvcGVyYXRvckxpc3QsIHZpZXdwb3J0KSB7XG4gICAgdGhpcy52aWV3cG9ydCA9IHZpZXdwb3J0O1xuICAgIGNvbnN0IHN2Z0VsZW1lbnQgPSB0aGlzLl9pbml0aWFsaXplKHZpZXdwb3J0KTtcbiAgICByZXR1cm4gdGhpcy5sb2FkRGVwZW5kZW5jaWVzKG9wZXJhdG9yTGlzdCkudGhlbigoKSA9PiB7XG4gICAgICB0aGlzLnRyYW5zZm9ybU1hdHJpeCA9IF91dGlsLklERU5USVRZX01BVFJJWDtcbiAgICAgIHRoaXMuZXhlY3V0ZU9wVHJlZSh0aGlzLmNvbnZlcnRPcExpc3Qob3BlcmF0b3JMaXN0KSk7XG4gICAgICByZXR1cm4gc3ZnRWxlbWVudDtcbiAgICB9KTtcbiAgfVxuICBjb252ZXJ0T3BMaXN0KG9wZXJhdG9yTGlzdCkge1xuICAgIGNvbnN0IG9wZXJhdG9ySWRNYXBwaW5nID0gdGhpcy5fb3BlcmF0b3JJZE1hcHBpbmc7XG4gICAgY29uc3QgYXJnc0FycmF5ID0gb3BlcmF0b3JMaXN0LmFyZ3NBcnJheTtcbiAgICBjb25zdCBmbkFycmF5ID0gb3BlcmF0b3JMaXN0LmZuQXJyYXk7XG4gICAgY29uc3Qgb3BMaXN0ID0gW107XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gZm5BcnJheS5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICBjb25zdCBmbklkID0gZm5BcnJheVtpXTtcbiAgICAgIG9wTGlzdC5wdXNoKHtcbiAgICAgICAgZm5JZCxcbiAgICAgICAgZm46IG9wZXJhdG9ySWRNYXBwaW5nW2ZuSWRdLFxuICAgICAgICBhcmdzOiBhcmdzQXJyYXlbaV1cbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gb3BMaXN0VG9UcmVlKG9wTGlzdCk7XG4gIH1cbiAgZXhlY3V0ZU9wVHJlZShvcFRyZWUpIHtcbiAgICBmb3IgKGNvbnN0IG9wVHJlZUVsZW1lbnQgb2Ygb3BUcmVlKSB7XG4gICAgICBjb25zdCBmbiA9IG9wVHJlZUVsZW1lbnQuZm47XG4gICAgICBjb25zdCBmbklkID0gb3BUcmVlRWxlbWVudC5mbklkO1xuICAgICAgY29uc3QgYXJncyA9IG9wVHJlZUVsZW1lbnQuYXJncztcbiAgICAgIHN3aXRjaCAoZm5JZCB8IDApIHtcbiAgICAgICAgY2FzZSBfdXRpbC5PUFMuYmVnaW5UZXh0OlxuICAgICAgICAgIHRoaXMuYmVnaW5UZXh0KCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgX3V0aWwuT1BTLmRlcGVuZGVuY3k6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgX3V0aWwuT1BTLnNldExlYWRpbmc6XG4gICAgICAgICAgdGhpcy5zZXRMZWFkaW5nKGFyZ3MpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIF91dGlsLk9QUy5zZXRMZWFkaW5nTW92ZVRleHQ6XG4gICAgICAgICAgdGhpcy5zZXRMZWFkaW5nTW92ZVRleHQoYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgX3V0aWwuT1BTLnNldEZvbnQ6XG4gICAgICAgICAgdGhpcy5zZXRGb250KGFyZ3MpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIF91dGlsLk9QUy5zaG93VGV4dDpcbiAgICAgICAgICB0aGlzLnNob3dUZXh0KGFyZ3NbMF0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIF91dGlsLk9QUy5zaG93U3BhY2VkVGV4dDpcbiAgICAgICAgICB0aGlzLnNob3dUZXh0KGFyZ3NbMF0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIF91dGlsLk9QUy5lbmRUZXh0OlxuICAgICAgICAgIHRoaXMuZW5kVGV4dCgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIF91dGlsLk9QUy5tb3ZlVGV4dDpcbiAgICAgICAgICB0aGlzLm1vdmVUZXh0KGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIF91dGlsLk9QUy5zZXRDaGFyU3BhY2luZzpcbiAgICAgICAgICB0aGlzLnNldENoYXJTcGFjaW5nKGFyZ3NbMF0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIF91dGlsLk9QUy5zZXRXb3JkU3BhY2luZzpcbiAgICAgICAgICB0aGlzLnNldFdvcmRTcGFjaW5nKGFyZ3NbMF0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIF91dGlsLk9QUy5zZXRIU2NhbGU6XG4gICAgICAgICAgdGhpcy5zZXRIU2NhbGUoYXJnc1swXSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgX3V0aWwuT1BTLnNldFRleHRNYXRyaXg6XG4gICAgICAgICAgdGhpcy5zZXRUZXh0TWF0cml4KGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10sIGFyZ3NbNF0sIGFyZ3NbNV0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIF91dGlsLk9QUy5zZXRUZXh0UmlzZTpcbiAgICAgICAgICB0aGlzLnNldFRleHRSaXNlKGFyZ3NbMF0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIF91dGlsLk9QUy5zZXRUZXh0UmVuZGVyaW5nTW9kZTpcbiAgICAgICAgICB0aGlzLnNldFRleHRSZW5kZXJpbmdNb2RlKGFyZ3NbMF0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIF91dGlsLk9QUy5zZXRMaW5lV2lkdGg6XG4gICAgICAgICAgdGhpcy5zZXRMaW5lV2lkdGgoYXJnc1swXSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgX3V0aWwuT1BTLnNldExpbmVKb2luOlxuICAgICAgICAgIHRoaXMuc2V0TGluZUpvaW4oYXJnc1swXSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgX3V0aWwuT1BTLnNldExpbmVDYXA6XG4gICAgICAgICAgdGhpcy5zZXRMaW5lQ2FwKGFyZ3NbMF0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIF91dGlsLk9QUy5zZXRNaXRlckxpbWl0OlxuICAgICAgICAgIHRoaXMuc2V0TWl0ZXJMaW1pdChhcmdzWzBdKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBfdXRpbC5PUFMuc2V0RmlsbFJHQkNvbG9yOlxuICAgICAgICAgIHRoaXMuc2V0RmlsbFJHQkNvbG9yKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIF91dGlsLk9QUy5zZXRTdHJva2VSR0JDb2xvcjpcbiAgICAgICAgICB0aGlzLnNldFN0cm9rZVJHQkNvbG9yKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIF91dGlsLk9QUy5zZXRTdHJva2VDb2xvck46XG4gICAgICAgICAgdGhpcy5zZXRTdHJva2VDb2xvck4oYXJncyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgX3V0aWwuT1BTLnNldEZpbGxDb2xvck46XG4gICAgICAgICAgdGhpcy5zZXRGaWxsQ29sb3JOKGFyZ3MpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIF91dGlsLk9QUy5zaGFkaW5nRmlsbDpcbiAgICAgICAgICB0aGlzLnNoYWRpbmdGaWxsKGFyZ3NbMF0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIF91dGlsLk9QUy5zZXREYXNoOlxuICAgICAgICAgIHRoaXMuc2V0RGFzaChhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBfdXRpbC5PUFMuc2V0UmVuZGVyaW5nSW50ZW50OlxuICAgICAgICAgIHRoaXMuc2V0UmVuZGVyaW5nSW50ZW50KGFyZ3NbMF0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIF91dGlsLk9QUy5zZXRGbGF0bmVzczpcbiAgICAgICAgICB0aGlzLnNldEZsYXRuZXNzKGFyZ3NbMF0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIF91dGlsLk9QUy5zZXRHU3RhdGU6XG4gICAgICAgICAgdGhpcy5zZXRHU3RhdGUoYXJnc1swXSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgX3V0aWwuT1BTLmZpbGw6XG4gICAgICAgICAgdGhpcy5maWxsKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgX3V0aWwuT1BTLmVvRmlsbDpcbiAgICAgICAgICB0aGlzLmVvRmlsbCgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIF91dGlsLk9QUy5zdHJva2U6XG4gICAgICAgICAgdGhpcy5zdHJva2UoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBfdXRpbC5PUFMuZmlsbFN0cm9rZTpcbiAgICAgICAgICB0aGlzLmZpbGxTdHJva2UoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBfdXRpbC5PUFMuZW9GaWxsU3Ryb2tlOlxuICAgICAgICAgIHRoaXMuZW9GaWxsU3Ryb2tlKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgX3V0aWwuT1BTLmNsaXA6XG4gICAgICAgICAgdGhpcy5jbGlwKFwibm9uemVyb1wiKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBfdXRpbC5PUFMuZW9DbGlwOlxuICAgICAgICAgIHRoaXMuY2xpcChcImV2ZW5vZGRcIik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgX3V0aWwuT1BTLnBhaW50U29saWRDb2xvckltYWdlTWFzazpcbiAgICAgICAgICB0aGlzLnBhaW50U29saWRDb2xvckltYWdlTWFzaygpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIF91dGlsLk9QUy5wYWludEltYWdlWE9iamVjdDpcbiAgICAgICAgICB0aGlzLnBhaW50SW1hZ2VYT2JqZWN0KGFyZ3NbMF0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIF91dGlsLk9QUy5wYWludElubGluZUltYWdlWE9iamVjdDpcbiAgICAgICAgICB0aGlzLnBhaW50SW5saW5lSW1hZ2VYT2JqZWN0KGFyZ3NbMF0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIF91dGlsLk9QUy5wYWludEltYWdlTWFza1hPYmplY3Q6XG4gICAgICAgICAgdGhpcy5wYWludEltYWdlTWFza1hPYmplY3QoYXJnc1swXSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgX3V0aWwuT1BTLnBhaW50Rm9ybVhPYmplY3RCZWdpbjpcbiAgICAgICAgICB0aGlzLnBhaW50Rm9ybVhPYmplY3RCZWdpbihhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBfdXRpbC5PUFMucGFpbnRGb3JtWE9iamVjdEVuZDpcbiAgICAgICAgICB0aGlzLnBhaW50Rm9ybVhPYmplY3RFbmQoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBfdXRpbC5PUFMuY2xvc2VQYXRoOlxuICAgICAgICAgIHRoaXMuY2xvc2VQYXRoKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgX3V0aWwuT1BTLmNsb3NlU3Ryb2tlOlxuICAgICAgICAgIHRoaXMuY2xvc2VTdHJva2UoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBfdXRpbC5PUFMuY2xvc2VGaWxsU3Ryb2tlOlxuICAgICAgICAgIHRoaXMuY2xvc2VGaWxsU3Ryb2tlKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgX3V0aWwuT1BTLmNsb3NlRU9GaWxsU3Ryb2tlOlxuICAgICAgICAgIHRoaXMuY2xvc2VFT0ZpbGxTdHJva2UoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBfdXRpbC5PUFMubmV4dExpbmU6XG4gICAgICAgICAgdGhpcy5uZXh0TGluZSgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIF91dGlsLk9QUy50cmFuc2Zvcm06XG4gICAgICAgICAgdGhpcy50cmFuc2Zvcm0oYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSwgYXJnc1s0XSwgYXJnc1s1XSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgX3V0aWwuT1BTLmNvbnN0cnVjdFBhdGg6XG4gICAgICAgICAgdGhpcy5jb25zdHJ1Y3RQYXRoKGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIF91dGlsLk9QUy5lbmRQYXRoOlxuICAgICAgICAgIHRoaXMuZW5kUGF0aCgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDkyOlxuICAgICAgICAgIHRoaXMuZ3JvdXAob3BUcmVlRWxlbWVudC5pdGVtcyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgKDAsIF91dGlsLndhcm4pKGBVbmltcGxlbWVudGVkIG9wZXJhdG9yICR7Zm59YCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHNldFdvcmRTcGFjaW5nKHdvcmRTcGFjaW5nKSB7XG4gICAgdGhpcy5jdXJyZW50LndvcmRTcGFjaW5nID0gd29yZFNwYWNpbmc7XG4gIH1cbiAgc2V0Q2hhclNwYWNpbmcoY2hhclNwYWNpbmcpIHtcbiAgICB0aGlzLmN1cnJlbnQuY2hhclNwYWNpbmcgPSBjaGFyU3BhY2luZztcbiAgfVxuICBuZXh0TGluZSgpIHtcbiAgICB0aGlzLm1vdmVUZXh0KDAsIHRoaXMuY3VycmVudC5sZWFkaW5nKTtcbiAgfVxuICBzZXRUZXh0TWF0cml4KGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgICBjb25zdCBjdXJyZW50ID0gdGhpcy5jdXJyZW50O1xuICAgIGN1cnJlbnQudGV4dE1hdHJpeCA9IGN1cnJlbnQubGluZU1hdHJpeCA9IFthLCBiLCBjLCBkLCBlLCBmXTtcbiAgICBjdXJyZW50LnRleHRNYXRyaXhTY2FsZSA9IE1hdGguaHlwb3QoYSwgYik7XG4gICAgY3VycmVudC54ID0gY3VycmVudC5saW5lWCA9IDA7XG4gICAgY3VycmVudC55ID0gY3VycmVudC5saW5lWSA9IDA7XG4gICAgY3VycmVudC54Y29vcmRzID0gW107XG4gICAgY3VycmVudC55Y29vcmRzID0gW107XG4gICAgY3VycmVudC50c3BhbiA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwic3ZnOnRzcGFuXCIpO1xuICAgIGN1cnJlbnQudHNwYW4uc2V0QXR0cmlidXRlTlMobnVsbCwgXCJmb250LWZhbWlseVwiLCBjdXJyZW50LmZvbnRGYW1pbHkpO1xuICAgIGN1cnJlbnQudHNwYW4uc2V0QXR0cmlidXRlTlMobnVsbCwgXCJmb250LXNpemVcIiwgYCR7cGYoY3VycmVudC5mb250U2l6ZSl9cHhgKTtcbiAgICBjdXJyZW50LnRzcGFuLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwieVwiLCBwZigtY3VycmVudC55KSk7XG4gICAgY3VycmVudC50eHRFbGVtZW50ID0gdGhpcy5zdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJzdmc6dGV4dFwiKTtcbiAgICBjdXJyZW50LnR4dEVsZW1lbnQuYXBwZW5kKGN1cnJlbnQudHNwYW4pO1xuICB9XG4gIGJlZ2luVGV4dCgpIHtcbiAgICBjb25zdCBjdXJyZW50ID0gdGhpcy5jdXJyZW50O1xuICAgIGN1cnJlbnQueCA9IGN1cnJlbnQubGluZVggPSAwO1xuICAgIGN1cnJlbnQueSA9IGN1cnJlbnQubGluZVkgPSAwO1xuICAgIGN1cnJlbnQudGV4dE1hdHJpeCA9IF91dGlsLklERU5USVRZX01BVFJJWDtcbiAgICBjdXJyZW50LmxpbmVNYXRyaXggPSBfdXRpbC5JREVOVElUWV9NQVRSSVg7XG4gICAgY3VycmVudC50ZXh0TWF0cml4U2NhbGUgPSAxO1xuICAgIGN1cnJlbnQudHNwYW4gPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcInN2Zzp0c3BhblwiKTtcbiAgICBjdXJyZW50LnR4dEVsZW1lbnQgPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcInN2Zzp0ZXh0XCIpO1xuICAgIGN1cnJlbnQudHh0Z3JwID0gdGhpcy5zdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJzdmc6Z1wiKTtcbiAgICBjdXJyZW50Lnhjb29yZHMgPSBbXTtcbiAgICBjdXJyZW50Lnljb29yZHMgPSBbXTtcbiAgfVxuICBtb3ZlVGV4dCh4LCB5KSB7XG4gICAgY29uc3QgY3VycmVudCA9IHRoaXMuY3VycmVudDtcbiAgICBjdXJyZW50LnggPSBjdXJyZW50LmxpbmVYICs9IHg7XG4gICAgY3VycmVudC55ID0gY3VycmVudC5saW5lWSArPSB5O1xuICAgIGN1cnJlbnQueGNvb3JkcyA9IFtdO1xuICAgIGN1cnJlbnQueWNvb3JkcyA9IFtdO1xuICAgIGN1cnJlbnQudHNwYW4gPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcInN2Zzp0c3BhblwiKTtcbiAgICBjdXJyZW50LnRzcGFuLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiZm9udC1mYW1pbHlcIiwgY3VycmVudC5mb250RmFtaWx5KTtcbiAgICBjdXJyZW50LnRzcGFuLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiZm9udC1zaXplXCIsIGAke3BmKGN1cnJlbnQuZm9udFNpemUpfXB4YCk7XG4gICAgY3VycmVudC50c3Bhbi5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInlcIiwgcGYoLWN1cnJlbnQueSkpO1xuICB9XG4gIHNob3dUZXh0KGdseXBocykge1xuICAgIGNvbnN0IGN1cnJlbnQgPSB0aGlzLmN1cnJlbnQ7XG4gICAgY29uc3QgZm9udCA9IGN1cnJlbnQuZm9udDtcbiAgICBjb25zdCBmb250U2l6ZSA9IGN1cnJlbnQuZm9udFNpemU7XG4gICAgaWYgKGZvbnRTaXplID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGZvbnRTaXplU2NhbGUgPSBjdXJyZW50LmZvbnRTaXplU2NhbGU7XG4gICAgY29uc3QgY2hhclNwYWNpbmcgPSBjdXJyZW50LmNoYXJTcGFjaW5nO1xuICAgIGNvbnN0IHdvcmRTcGFjaW5nID0gY3VycmVudC53b3JkU3BhY2luZztcbiAgICBjb25zdCBmb250RGlyZWN0aW9uID0gY3VycmVudC5mb250RGlyZWN0aW9uO1xuICAgIGNvbnN0IHRleHRIU2NhbGUgPSBjdXJyZW50LnRleHRIU2NhbGUgKiBmb250RGlyZWN0aW9uO1xuICAgIGNvbnN0IHZlcnRpY2FsID0gZm9udC52ZXJ0aWNhbDtcbiAgICBjb25zdCBzcGFjaW5nRGlyID0gdmVydGljYWwgPyAxIDogLTE7XG4gICAgY29uc3QgZGVmYXVsdFZNZXRyaWNzID0gZm9udC5kZWZhdWx0Vk1ldHJpY3M7XG4gICAgY29uc3Qgd2lkdGhBZHZhbmNlU2NhbGUgPSBmb250U2l6ZSAqIGN1cnJlbnQuZm9udE1hdHJpeFswXTtcbiAgICBsZXQgeCA9IDA7XG4gICAgZm9yIChjb25zdCBnbHlwaCBvZiBnbHlwaHMpIHtcbiAgICAgIGlmIChnbHlwaCA9PT0gbnVsbCkge1xuICAgICAgICB4ICs9IGZvbnREaXJlY3Rpb24gKiB3b3JkU3BhY2luZztcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBnbHlwaCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICB4ICs9IHNwYWNpbmdEaXIgKiBnbHlwaCAqIGZvbnRTaXplIC8gMTAwMDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBzcGFjaW5nID0gKGdseXBoLmlzU3BhY2UgPyB3b3JkU3BhY2luZyA6IDApICsgY2hhclNwYWNpbmc7XG4gICAgICBjb25zdCBjaGFyYWN0ZXIgPSBnbHlwaC5mb250Q2hhcjtcbiAgICAgIGxldCBzY2FsZWRYLCBzY2FsZWRZO1xuICAgICAgbGV0IHdpZHRoID0gZ2x5cGgud2lkdGg7XG4gICAgICBpZiAodmVydGljYWwpIHtcbiAgICAgICAgbGV0IHZ4O1xuICAgICAgICBjb25zdCB2bWV0cmljID0gZ2x5cGgudm1ldHJpYyB8fCBkZWZhdWx0Vk1ldHJpY3M7XG4gICAgICAgIHZ4ID0gZ2x5cGgudm1ldHJpYyA/IHZtZXRyaWNbMV0gOiB3aWR0aCAqIDAuNTtcbiAgICAgICAgdnggPSAtdnggKiB3aWR0aEFkdmFuY2VTY2FsZTtcbiAgICAgICAgY29uc3QgdnkgPSB2bWV0cmljWzJdICogd2lkdGhBZHZhbmNlU2NhbGU7XG4gICAgICAgIHdpZHRoID0gdm1ldHJpYyA/IC12bWV0cmljWzBdIDogd2lkdGg7XG4gICAgICAgIHNjYWxlZFggPSB2eCAvIGZvbnRTaXplU2NhbGU7XG4gICAgICAgIHNjYWxlZFkgPSAoeCArIHZ5KSAvIGZvbnRTaXplU2NhbGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzY2FsZWRYID0geCAvIGZvbnRTaXplU2NhbGU7XG4gICAgICAgIHNjYWxlZFkgPSAwO1xuICAgICAgfVxuICAgICAgaWYgKGdseXBoLmlzSW5Gb250IHx8IGZvbnQubWlzc2luZ0ZpbGUpIHtcbiAgICAgICAgY3VycmVudC54Y29vcmRzLnB1c2goY3VycmVudC54ICsgc2NhbGVkWCk7XG4gICAgICAgIGlmICh2ZXJ0aWNhbCkge1xuICAgICAgICAgIGN1cnJlbnQueWNvb3Jkcy5wdXNoKC1jdXJyZW50LnkgKyBzY2FsZWRZKTtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50LnRzcGFuLnRleHRDb250ZW50ICs9IGNoYXJhY3RlcjtcbiAgICAgIH0gZWxzZSB7fVxuICAgICAgY29uc3QgY2hhcldpZHRoID0gdmVydGljYWwgPyB3aWR0aCAqIHdpZHRoQWR2YW5jZVNjYWxlIC0gc3BhY2luZyAqIGZvbnREaXJlY3Rpb24gOiB3aWR0aCAqIHdpZHRoQWR2YW5jZVNjYWxlICsgc3BhY2luZyAqIGZvbnREaXJlY3Rpb247XG4gICAgICB4ICs9IGNoYXJXaWR0aDtcbiAgICB9XG4gICAgY3VycmVudC50c3Bhbi5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInhcIiwgY3VycmVudC54Y29vcmRzLm1hcChwZikuam9pbihcIiBcIikpO1xuICAgIGlmICh2ZXJ0aWNhbCkge1xuICAgICAgY3VycmVudC50c3Bhbi5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInlcIiwgY3VycmVudC55Y29vcmRzLm1hcChwZikuam9pbihcIiBcIikpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdXJyZW50LnRzcGFuLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwieVwiLCBwZigtY3VycmVudC55KSk7XG4gICAgfVxuICAgIGlmICh2ZXJ0aWNhbCkge1xuICAgICAgY3VycmVudC55IC09IHg7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN1cnJlbnQueCArPSB4ICogdGV4dEhTY2FsZTtcbiAgICB9XG4gICAgY3VycmVudC50c3Bhbi5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImZvbnQtZmFtaWx5XCIsIGN1cnJlbnQuZm9udEZhbWlseSk7XG4gICAgY3VycmVudC50c3Bhbi5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImZvbnQtc2l6ZVwiLCBgJHtwZihjdXJyZW50LmZvbnRTaXplKX1weGApO1xuICAgIGlmIChjdXJyZW50LmZvbnRTdHlsZSAhPT0gU1ZHX0RFRkFVTFRTLmZvbnRTdHlsZSkge1xuICAgICAgY3VycmVudC50c3Bhbi5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImZvbnQtc3R5bGVcIiwgY3VycmVudC5mb250U3R5bGUpO1xuICAgIH1cbiAgICBpZiAoY3VycmVudC5mb250V2VpZ2h0ICE9PSBTVkdfREVGQVVMVFMuZm9udFdlaWdodCkge1xuICAgICAgY3VycmVudC50c3Bhbi5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImZvbnQtd2VpZ2h0XCIsIGN1cnJlbnQuZm9udFdlaWdodCk7XG4gICAgfVxuICAgIGNvbnN0IGZpbGxTdHJva2VNb2RlID0gY3VycmVudC50ZXh0UmVuZGVyaW5nTW9kZSAmIF91dGlsLlRleHRSZW5kZXJpbmdNb2RlLkZJTExfU1RST0tFX01BU0s7XG4gICAgaWYgKGZpbGxTdHJva2VNb2RlID09PSBfdXRpbC5UZXh0UmVuZGVyaW5nTW9kZS5GSUxMIHx8IGZpbGxTdHJva2VNb2RlID09PSBfdXRpbC5UZXh0UmVuZGVyaW5nTW9kZS5GSUxMX1NUUk9LRSkge1xuICAgICAgaWYgKGN1cnJlbnQuZmlsbENvbG9yICE9PSBTVkdfREVGQVVMVFMuZmlsbENvbG9yKSB7XG4gICAgICAgIGN1cnJlbnQudHNwYW4uc2V0QXR0cmlidXRlTlMobnVsbCwgXCJmaWxsXCIsIGN1cnJlbnQuZmlsbENvbG9yKTtcbiAgICAgIH1cbiAgICAgIGlmIChjdXJyZW50LmZpbGxBbHBoYSA8IDEpIHtcbiAgICAgICAgY3VycmVudC50c3Bhbi5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImZpbGwtb3BhY2l0eVwiLCBjdXJyZW50LmZpbGxBbHBoYSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjdXJyZW50LnRleHRSZW5kZXJpbmdNb2RlID09PSBfdXRpbC5UZXh0UmVuZGVyaW5nTW9kZS5BRERfVE9fUEFUSCkge1xuICAgICAgY3VycmVudC50c3Bhbi5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImZpbGxcIiwgXCJ0cmFuc3BhcmVudFwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3VycmVudC50c3Bhbi5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImZpbGxcIiwgXCJub25lXCIpO1xuICAgIH1cbiAgICBpZiAoZmlsbFN0cm9rZU1vZGUgPT09IF91dGlsLlRleHRSZW5kZXJpbmdNb2RlLlNUUk9LRSB8fCBmaWxsU3Ryb2tlTW9kZSA9PT0gX3V0aWwuVGV4dFJlbmRlcmluZ01vZGUuRklMTF9TVFJPS0UpIHtcbiAgICAgIGNvbnN0IGxpbmVXaWR0aFNjYWxlID0gMSAvIChjdXJyZW50LnRleHRNYXRyaXhTY2FsZSB8fCAxKTtcbiAgICAgIHRoaXMuX3NldFN0cm9rZUF0dHJpYnV0ZXMoY3VycmVudC50c3BhbiwgbGluZVdpZHRoU2NhbGUpO1xuICAgIH1cbiAgICBsZXQgdGV4dE1hdHJpeCA9IGN1cnJlbnQudGV4dE1hdHJpeDtcbiAgICBpZiAoY3VycmVudC50ZXh0UmlzZSAhPT0gMCkge1xuICAgICAgdGV4dE1hdHJpeCA9IHRleHRNYXRyaXguc2xpY2UoKTtcbiAgICAgIHRleHRNYXRyaXhbNV0gKz0gY3VycmVudC50ZXh0UmlzZTtcbiAgICB9XG4gICAgY3VycmVudC50eHRFbGVtZW50LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwidHJhbnNmb3JtXCIsIGAke3BtKHRleHRNYXRyaXgpfSBzY2FsZSgke3BmKHRleHRIU2NhbGUpfSwgLTEpYCk7XG4gICAgY3VycmVudC50eHRFbGVtZW50LnNldEF0dHJpYnV0ZU5TKFhNTF9OUywgXCJ4bWw6c3BhY2VcIiwgXCJwcmVzZXJ2ZVwiKTtcbiAgICBjdXJyZW50LnR4dEVsZW1lbnQuYXBwZW5kKGN1cnJlbnQudHNwYW4pO1xuICAgIGN1cnJlbnQudHh0Z3JwLmFwcGVuZChjdXJyZW50LnR4dEVsZW1lbnQpO1xuICAgIHRoaXMuX2Vuc3VyZVRyYW5zZm9ybUdyb3VwKCkuYXBwZW5kKGN1cnJlbnQudHh0RWxlbWVudCk7XG4gIH1cbiAgc2V0TGVhZGluZ01vdmVUZXh0KHgsIHkpIHtcbiAgICB0aGlzLnNldExlYWRpbmcoLXkpO1xuICAgIHRoaXMubW92ZVRleHQoeCwgeSk7XG4gIH1cbiAgYWRkRm9udFN0eWxlKGZvbnRPYmopIHtcbiAgICBpZiAoIWZvbnRPYmouZGF0YSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYWRkRm9udFN0eWxlOiBObyBmb250IGRhdGEgYXZhaWxhYmxlLCBcIiArICdlbnN1cmUgdGhhdCB0aGUgXCJmb250RXh0cmFQcm9wZXJ0aWVzXCIgQVBJIHBhcmFtZXRlciBpcyBzZXQuJyk7XG4gICAgfVxuICAgIGlmICghdGhpcy5jc3NTdHlsZSkge1xuICAgICAgdGhpcy5jc3NTdHlsZSA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwic3ZnOnN0eWxlXCIpO1xuICAgICAgdGhpcy5jc3NTdHlsZS5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInR5cGVcIiwgXCJ0ZXh0L2Nzc1wiKTtcbiAgICAgIHRoaXMuZGVmcy5hcHBlbmQodGhpcy5jc3NTdHlsZSk7XG4gICAgfVxuICAgIGNvbnN0IHVybCA9IGNyZWF0ZU9iamVjdFVSTChmb250T2JqLmRhdGEsIGZvbnRPYmoubWltZXR5cGUsIHRoaXMuZm9yY2VEYXRhU2NoZW1hKTtcbiAgICB0aGlzLmNzc1N0eWxlLnRleHRDb250ZW50ICs9IGBAZm9udC1mYWNlIHsgZm9udC1mYW1pbHk6IFwiJHtmb250T2JqLmxvYWRlZE5hbWV9XCI7YCArIGAgc3JjOiB1cmwoJHt1cmx9KTsgfVxcbmA7XG4gIH1cbiAgc2V0Rm9udChkZXRhaWxzKSB7XG4gICAgY29uc3QgY3VycmVudCA9IHRoaXMuY3VycmVudDtcbiAgICBjb25zdCBmb250T2JqID0gdGhpcy5jb21tb25PYmpzLmdldChkZXRhaWxzWzBdKTtcbiAgICBsZXQgc2l6ZSA9IGRldGFpbHNbMV07XG4gICAgY3VycmVudC5mb250ID0gZm9udE9iajtcbiAgICBpZiAodGhpcy5lbWJlZEZvbnRzICYmICFmb250T2JqLm1pc3NpbmdGaWxlICYmICF0aGlzLmVtYmVkZGVkRm9udHNbZm9udE9iai5sb2FkZWROYW1lXSkge1xuICAgICAgdGhpcy5hZGRGb250U3R5bGUoZm9udE9iaik7XG4gICAgICB0aGlzLmVtYmVkZGVkRm9udHNbZm9udE9iai5sb2FkZWROYW1lXSA9IGZvbnRPYmo7XG4gICAgfVxuICAgIGN1cnJlbnQuZm9udE1hdHJpeCA9IGZvbnRPYmouZm9udE1hdHJpeCB8fCBfdXRpbC5GT05UX0lERU5USVRZX01BVFJJWDtcbiAgICBsZXQgYm9sZCA9IFwibm9ybWFsXCI7XG4gICAgaWYgKGZvbnRPYmouYmxhY2spIHtcbiAgICAgIGJvbGQgPSBcIjkwMFwiO1xuICAgIH0gZWxzZSBpZiAoZm9udE9iai5ib2xkKSB7XG4gICAgICBib2xkID0gXCJib2xkXCI7XG4gICAgfVxuICAgIGNvbnN0IGl0YWxpYyA9IGZvbnRPYmouaXRhbGljID8gXCJpdGFsaWNcIiA6IFwibm9ybWFsXCI7XG4gICAgaWYgKHNpemUgPCAwKSB7XG4gICAgICBzaXplID0gLXNpemU7XG4gICAgICBjdXJyZW50LmZvbnREaXJlY3Rpb24gPSAtMTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3VycmVudC5mb250RGlyZWN0aW9uID0gMTtcbiAgICB9XG4gICAgY3VycmVudC5mb250U2l6ZSA9IHNpemU7XG4gICAgY3VycmVudC5mb250RmFtaWx5ID0gZm9udE9iai5sb2FkZWROYW1lO1xuICAgIGN1cnJlbnQuZm9udFdlaWdodCA9IGJvbGQ7XG4gICAgY3VycmVudC5mb250U3R5bGUgPSBpdGFsaWM7XG4gICAgY3VycmVudC50c3BhbiA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwic3ZnOnRzcGFuXCIpO1xuICAgIGN1cnJlbnQudHNwYW4uc2V0QXR0cmlidXRlTlMobnVsbCwgXCJ5XCIsIHBmKC1jdXJyZW50LnkpKTtcbiAgICBjdXJyZW50Lnhjb29yZHMgPSBbXTtcbiAgICBjdXJyZW50Lnljb29yZHMgPSBbXTtcbiAgfVxuICBlbmRUZXh0KCkge1xuICAgIGNvbnN0IGN1cnJlbnQgPSB0aGlzLmN1cnJlbnQ7XG4gICAgaWYgKGN1cnJlbnQudGV4dFJlbmRlcmluZ01vZGUgJiBfdXRpbC5UZXh0UmVuZGVyaW5nTW9kZS5BRERfVE9fUEFUSF9GTEFHICYmIGN1cnJlbnQudHh0RWxlbWVudD8uaGFzQ2hpbGROb2RlcygpKSB7XG4gICAgICBjdXJyZW50LmVsZW1lbnQgPSBjdXJyZW50LnR4dEVsZW1lbnQ7XG4gICAgICB0aGlzLmNsaXAoXCJub256ZXJvXCIpO1xuICAgICAgdGhpcy5lbmRQYXRoKCk7XG4gICAgfVxuICB9XG4gIHNldExpbmVXaWR0aCh3aWR0aCkge1xuICAgIGlmICh3aWR0aCA+IDApIHtcbiAgICAgIHRoaXMuY3VycmVudC5saW5lV2lkdGggPSB3aWR0aDtcbiAgICB9XG4gIH1cbiAgc2V0TGluZUNhcChzdHlsZSkge1xuICAgIHRoaXMuY3VycmVudC5saW5lQ2FwID0gTElORV9DQVBfU1RZTEVTW3N0eWxlXTtcbiAgfVxuICBzZXRMaW5lSm9pbihzdHlsZSkge1xuICAgIHRoaXMuY3VycmVudC5saW5lSm9pbiA9IExJTkVfSk9JTl9TVFlMRVNbc3R5bGVdO1xuICB9XG4gIHNldE1pdGVyTGltaXQobGltaXQpIHtcbiAgICB0aGlzLmN1cnJlbnQubWl0ZXJMaW1pdCA9IGxpbWl0O1xuICB9XG4gIHNldFN0cm9rZUFscGhhKHN0cm9rZUFscGhhKSB7XG4gICAgdGhpcy5jdXJyZW50LnN0cm9rZUFscGhhID0gc3Ryb2tlQWxwaGE7XG4gIH1cbiAgc2V0U3Ryb2tlUkdCQ29sb3IociwgZywgYikge1xuICAgIHRoaXMuY3VycmVudC5zdHJva2VDb2xvciA9IF91dGlsLlV0aWwubWFrZUhleENvbG9yKHIsIGcsIGIpO1xuICB9XG4gIHNldEZpbGxBbHBoYShmaWxsQWxwaGEpIHtcbiAgICB0aGlzLmN1cnJlbnQuZmlsbEFscGhhID0gZmlsbEFscGhhO1xuICB9XG4gIHNldEZpbGxSR0JDb2xvcihyLCBnLCBiKSB7XG4gICAgdGhpcy5jdXJyZW50LmZpbGxDb2xvciA9IF91dGlsLlV0aWwubWFrZUhleENvbG9yKHIsIGcsIGIpO1xuICAgIHRoaXMuY3VycmVudC50c3BhbiA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwic3ZnOnRzcGFuXCIpO1xuICAgIHRoaXMuY3VycmVudC54Y29vcmRzID0gW107XG4gICAgdGhpcy5jdXJyZW50Lnljb29yZHMgPSBbXTtcbiAgfVxuICBzZXRTdHJva2VDb2xvck4oYXJncykge1xuICAgIHRoaXMuY3VycmVudC5zdHJva2VDb2xvciA9IHRoaXMuX21ha2VDb2xvck5fUGF0dGVybihhcmdzKTtcbiAgfVxuICBzZXRGaWxsQ29sb3JOKGFyZ3MpIHtcbiAgICB0aGlzLmN1cnJlbnQuZmlsbENvbG9yID0gdGhpcy5fbWFrZUNvbG9yTl9QYXR0ZXJuKGFyZ3MpO1xuICB9XG4gIHNoYWRpbmdGaWxsKGFyZ3MpIHtcbiAgICBjb25zdCB7XG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodFxuICAgIH0gPSB0aGlzLnZpZXdwb3J0O1xuICAgIGNvbnN0IGludiA9IF91dGlsLlV0aWwuaW52ZXJzZVRyYW5zZm9ybSh0aGlzLnRyYW5zZm9ybU1hdHJpeCk7XG4gICAgY29uc3QgW3gwLCB5MCwgeDEsIHkxXSA9IF91dGlsLlV0aWwuZ2V0QXhpYWxBbGlnbmVkQm91bmRpbmdCb3goWzAsIDAsIHdpZHRoLCBoZWlnaHRdLCBpbnYpO1xuICAgIGNvbnN0IHJlY3QgPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcInN2ZzpyZWN0XCIpO1xuICAgIHJlY3Quc2V0QXR0cmlidXRlTlMobnVsbCwgXCJ4XCIsIHgwKTtcbiAgICByZWN0LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwieVwiLCB5MCk7XG4gICAgcmVjdC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcIndpZHRoXCIsIHgxIC0geDApO1xuICAgIHJlY3Quc2V0QXR0cmlidXRlTlMobnVsbCwgXCJoZWlnaHRcIiwgeTEgLSB5MCk7XG4gICAgcmVjdC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImZpbGxcIiwgdGhpcy5fbWFrZVNoYWRpbmdQYXR0ZXJuKGFyZ3MpKTtcbiAgICBpZiAodGhpcy5jdXJyZW50LmZpbGxBbHBoYSA8IDEpIHtcbiAgICAgIHJlY3Quc2V0QXR0cmlidXRlTlMobnVsbCwgXCJmaWxsLW9wYWNpdHlcIiwgdGhpcy5jdXJyZW50LmZpbGxBbHBoYSk7XG4gICAgfVxuICAgIHRoaXMuX2Vuc3VyZVRyYW5zZm9ybUdyb3VwKCkuYXBwZW5kKHJlY3QpO1xuICB9XG4gIF9tYWtlQ29sb3JOX1BhdHRlcm4oYXJncykge1xuICAgIGlmIChhcmdzWzBdID09PSBcIlRpbGluZ1BhdHRlcm5cIikge1xuICAgICAgcmV0dXJuIHRoaXMuX21ha2VUaWxpbmdQYXR0ZXJuKGFyZ3MpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fbWFrZVNoYWRpbmdQYXR0ZXJuKGFyZ3MpO1xuICB9XG4gIF9tYWtlVGlsaW5nUGF0dGVybihhcmdzKSB7XG4gICAgY29uc3QgY29sb3IgPSBhcmdzWzFdO1xuICAgIGNvbnN0IG9wZXJhdG9yTGlzdCA9IGFyZ3NbMl07XG4gICAgY29uc3QgbWF0cml4ID0gYXJnc1szXSB8fCBfdXRpbC5JREVOVElUWV9NQVRSSVg7XG4gICAgY29uc3QgW3gwLCB5MCwgeDEsIHkxXSA9IGFyZ3NbNF07XG4gICAgY29uc3QgeHN0ZXAgPSBhcmdzWzVdO1xuICAgIGNvbnN0IHlzdGVwID0gYXJnc1s2XTtcbiAgICBjb25zdCBwYWludFR5cGUgPSBhcmdzWzddO1xuICAgIGNvbnN0IHRpbGluZ0lkID0gYHNoYWRpbmcke3NoYWRpbmdDb3VudCsrfWA7XG4gICAgY29uc3QgW3R4MCwgdHkwLCB0eDEsIHR5MV0gPSBfdXRpbC5VdGlsLm5vcm1hbGl6ZVJlY3QoWy4uLl91dGlsLlV0aWwuYXBwbHlUcmFuc2Zvcm0oW3gwLCB5MF0sIG1hdHJpeCksIC4uLl91dGlsLlV0aWwuYXBwbHlUcmFuc2Zvcm0oW3gxLCB5MV0sIG1hdHJpeCldKTtcbiAgICBjb25zdCBbeHNjYWxlLCB5c2NhbGVdID0gX3V0aWwuVXRpbC5zaW5ndWxhclZhbHVlRGVjb21wb3NlMmRTY2FsZShtYXRyaXgpO1xuICAgIGNvbnN0IHR4c3RlcCA9IHhzdGVwICogeHNjYWxlO1xuICAgIGNvbnN0IHR5c3RlcCA9IHlzdGVwICogeXNjYWxlO1xuICAgIGNvbnN0IHRpbGluZyA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwic3ZnOnBhdHRlcm5cIik7XG4gICAgdGlsaW5nLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiaWRcIiwgdGlsaW5nSWQpO1xuICAgIHRpbGluZy5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInBhdHRlcm5Vbml0c1wiLCBcInVzZXJTcGFjZU9uVXNlXCIpO1xuICAgIHRpbGluZy5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcIndpZHRoXCIsIHR4c3RlcCk7XG4gICAgdGlsaW5nLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiaGVpZ2h0XCIsIHR5c3RlcCk7XG4gICAgdGlsaW5nLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwieFwiLCBgJHt0eDB9YCk7XG4gICAgdGlsaW5nLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwieVwiLCBgJHt0eTB9YCk7XG4gICAgY29uc3Qgc3ZnID0gdGhpcy5zdmc7XG4gICAgY29uc3QgdHJhbnNmb3JtTWF0cml4ID0gdGhpcy50cmFuc2Zvcm1NYXRyaXg7XG4gICAgY29uc3QgZmlsbENvbG9yID0gdGhpcy5jdXJyZW50LmZpbGxDb2xvcjtcbiAgICBjb25zdCBzdHJva2VDb2xvciA9IHRoaXMuY3VycmVudC5zdHJva2VDb2xvcjtcbiAgICBjb25zdCBiYm94ID0gdGhpcy5zdmdGYWN0b3J5LmNyZWF0ZSh0eDEgLSB0eDAsIHR5MSAtIHR5MCk7XG4gICAgdGhpcy5zdmcgPSBiYm94O1xuICAgIHRoaXMudHJhbnNmb3JtTWF0cml4ID0gbWF0cml4O1xuICAgIGlmIChwYWludFR5cGUgPT09IDIpIHtcbiAgICAgIGNvbnN0IGNzc0NvbG9yID0gX3V0aWwuVXRpbC5tYWtlSGV4Q29sb3IoLi4uY29sb3IpO1xuICAgICAgdGhpcy5jdXJyZW50LmZpbGxDb2xvciA9IGNzc0NvbG9yO1xuICAgICAgdGhpcy5jdXJyZW50LnN0cm9rZUNvbG9yID0gY3NzQ29sb3I7XG4gICAgfVxuICAgIHRoaXMuZXhlY3V0ZU9wVHJlZSh0aGlzLmNvbnZlcnRPcExpc3Qob3BlcmF0b3JMaXN0KSk7XG4gICAgdGhpcy5zdmcgPSBzdmc7XG4gICAgdGhpcy50cmFuc2Zvcm1NYXRyaXggPSB0cmFuc2Zvcm1NYXRyaXg7XG4gICAgdGhpcy5jdXJyZW50LmZpbGxDb2xvciA9IGZpbGxDb2xvcjtcbiAgICB0aGlzLmN1cnJlbnQuc3Ryb2tlQ29sb3IgPSBzdHJva2VDb2xvcjtcbiAgICB0aWxpbmcuYXBwZW5kKGJib3guY2hpbGROb2Rlc1swXSk7XG4gICAgdGhpcy5kZWZzLmFwcGVuZCh0aWxpbmcpO1xuICAgIHJldHVybiBgdXJsKCMke3RpbGluZ0lkfSlgO1xuICB9XG4gIF9tYWtlU2hhZGluZ1BhdHRlcm4oYXJncykge1xuICAgIGlmICh0eXBlb2YgYXJncyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgYXJncyA9IHRoaXMub2Jqcy5nZXQoYXJncyk7XG4gICAgfVxuICAgIHN3aXRjaCAoYXJnc1swXSkge1xuICAgICAgY2FzZSBcIlJhZGlhbEF4aWFsXCI6XG4gICAgICAgIGNvbnN0IHNoYWRpbmdJZCA9IGBzaGFkaW5nJHtzaGFkaW5nQ291bnQrK31gO1xuICAgICAgICBjb25zdCBjb2xvclN0b3BzID0gYXJnc1szXTtcbiAgICAgICAgbGV0IGdyYWRpZW50O1xuICAgICAgICBzd2l0Y2ggKGFyZ3NbMV0pIHtcbiAgICAgICAgICBjYXNlIFwiYXhpYWxcIjpcbiAgICAgICAgICAgIGNvbnN0IHBvaW50MCA9IGFyZ3NbNF07XG4gICAgICAgICAgICBjb25zdCBwb2ludDEgPSBhcmdzWzVdO1xuICAgICAgICAgICAgZ3JhZGllbnQgPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcInN2ZzpsaW5lYXJHcmFkaWVudFwiKTtcbiAgICAgICAgICAgIGdyYWRpZW50LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiaWRcIiwgc2hhZGluZ0lkKTtcbiAgICAgICAgICAgIGdyYWRpZW50LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiZ3JhZGllbnRVbml0c1wiLCBcInVzZXJTcGFjZU9uVXNlXCIpO1xuICAgICAgICAgICAgZ3JhZGllbnQuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJ4MVwiLCBwb2ludDBbMF0pO1xuICAgICAgICAgICAgZ3JhZGllbnQuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJ5MVwiLCBwb2ludDBbMV0pO1xuICAgICAgICAgICAgZ3JhZGllbnQuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJ4MlwiLCBwb2ludDFbMF0pO1xuICAgICAgICAgICAgZ3JhZGllbnQuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJ5MlwiLCBwb2ludDFbMV0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcInJhZGlhbFwiOlxuICAgICAgICAgICAgY29uc3QgZm9jYWxQb2ludCA9IGFyZ3NbNF07XG4gICAgICAgICAgICBjb25zdCBjaXJjbGVQb2ludCA9IGFyZ3NbNV07XG4gICAgICAgICAgICBjb25zdCBmb2NhbFJhZGl1cyA9IGFyZ3NbNl07XG4gICAgICAgICAgICBjb25zdCBjaXJjbGVSYWRpdXMgPSBhcmdzWzddO1xuICAgICAgICAgICAgZ3JhZGllbnQgPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcInN2ZzpyYWRpYWxHcmFkaWVudFwiKTtcbiAgICAgICAgICAgIGdyYWRpZW50LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiaWRcIiwgc2hhZGluZ0lkKTtcbiAgICAgICAgICAgIGdyYWRpZW50LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiZ3JhZGllbnRVbml0c1wiLCBcInVzZXJTcGFjZU9uVXNlXCIpO1xuICAgICAgICAgICAgZ3JhZGllbnQuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJjeFwiLCBjaXJjbGVQb2ludFswXSk7XG4gICAgICAgICAgICBncmFkaWVudC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImN5XCIsIGNpcmNsZVBvaW50WzFdKTtcbiAgICAgICAgICAgIGdyYWRpZW50LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiclwiLCBjaXJjbGVSYWRpdXMpO1xuICAgICAgICAgICAgZ3JhZGllbnQuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJmeFwiLCBmb2NhbFBvaW50WzBdKTtcbiAgICAgICAgICAgIGdyYWRpZW50LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiZnlcIiwgZm9jYWxQb2ludFsxXSk7XG4gICAgICAgICAgICBncmFkaWVudC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImZyXCIsIGZvY2FsUmFkaXVzKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gUmFkaWFsQXhpYWwgdHlwZTogJHthcmdzWzFdfWApO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgY29sb3JTdG9wIG9mIGNvbG9yU3RvcHMpIHtcbiAgICAgICAgICBjb25zdCBzdG9wID0gdGhpcy5zdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJzdmc6c3RvcFwiKTtcbiAgICAgICAgICBzdG9wLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwib2Zmc2V0XCIsIGNvbG9yU3RvcFswXSk7XG4gICAgICAgICAgc3RvcC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInN0b3AtY29sb3JcIiwgY29sb3JTdG9wWzFdKTtcbiAgICAgICAgICBncmFkaWVudC5hcHBlbmQoc3RvcCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kZWZzLmFwcGVuZChncmFkaWVudCk7XG4gICAgICAgIHJldHVybiBgdXJsKCMke3NoYWRpbmdJZH0pYDtcbiAgICAgIGNhc2UgXCJNZXNoXCI6XG4gICAgICAgICgwLCBfdXRpbC53YXJuKShcIlVuaW1wbGVtZW50ZWQgcGF0dGVybiBNZXNoXCIpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIGNhc2UgXCJEdW1teVwiOlxuICAgICAgICByZXR1cm4gXCJob3RwaW5rXCI7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gSVIgdHlwZTogJHthcmdzWzBdfWApO1xuICAgIH1cbiAgfVxuICBzZXREYXNoKGRhc2hBcnJheSwgZGFzaFBoYXNlKSB7XG4gICAgdGhpcy5jdXJyZW50LmRhc2hBcnJheSA9IGRhc2hBcnJheTtcbiAgICB0aGlzLmN1cnJlbnQuZGFzaFBoYXNlID0gZGFzaFBoYXNlO1xuICB9XG4gIGNvbnN0cnVjdFBhdGgob3BzLCBhcmdzKSB7XG4gICAgY29uc3QgY3VycmVudCA9IHRoaXMuY3VycmVudDtcbiAgICBsZXQgeCA9IGN1cnJlbnQueCxcbiAgICAgIHkgPSBjdXJyZW50Lnk7XG4gICAgbGV0IGQgPSBbXTtcbiAgICBsZXQgaiA9IDA7XG4gICAgZm9yIChjb25zdCBvcCBvZiBvcHMpIHtcbiAgICAgIHN3aXRjaCAob3AgfCAwKSB7XG4gICAgICAgIGNhc2UgX3V0aWwuT1BTLnJlY3RhbmdsZTpcbiAgICAgICAgICB4ID0gYXJnc1tqKytdO1xuICAgICAgICAgIHkgPSBhcmdzW2orK107XG4gICAgICAgICAgY29uc3Qgd2lkdGggPSBhcmdzW2orK107XG4gICAgICAgICAgY29uc3QgaGVpZ2h0ID0gYXJnc1tqKytdO1xuICAgICAgICAgIGNvbnN0IHh3ID0geCArIHdpZHRoO1xuICAgICAgICAgIGNvbnN0IHloID0geSArIGhlaWdodDtcbiAgICAgICAgICBkLnB1c2goXCJNXCIsIHBmKHgpLCBwZih5KSwgXCJMXCIsIHBmKHh3KSwgcGYoeSksIFwiTFwiLCBwZih4dyksIHBmKHloKSwgXCJMXCIsIHBmKHgpLCBwZih5aCksIFwiWlwiKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBfdXRpbC5PUFMubW92ZVRvOlxuICAgICAgICAgIHggPSBhcmdzW2orK107XG4gICAgICAgICAgeSA9IGFyZ3NbaisrXTtcbiAgICAgICAgICBkLnB1c2goXCJNXCIsIHBmKHgpLCBwZih5KSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgX3V0aWwuT1BTLmxpbmVUbzpcbiAgICAgICAgICB4ID0gYXJnc1tqKytdO1xuICAgICAgICAgIHkgPSBhcmdzW2orK107XG4gICAgICAgICAgZC5wdXNoKFwiTFwiLCBwZih4KSwgcGYoeSkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIF91dGlsLk9QUy5jdXJ2ZVRvOlxuICAgICAgICAgIHggPSBhcmdzW2ogKyA0XTtcbiAgICAgICAgICB5ID0gYXJnc1tqICsgNV07XG4gICAgICAgICAgZC5wdXNoKFwiQ1wiLCBwZihhcmdzW2pdKSwgcGYoYXJnc1tqICsgMV0pLCBwZihhcmdzW2ogKyAyXSksIHBmKGFyZ3NbaiArIDNdKSwgcGYoeCksIHBmKHkpKTtcbiAgICAgICAgICBqICs9IDY7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgX3V0aWwuT1BTLmN1cnZlVG8yOlxuICAgICAgICAgIGQucHVzaChcIkNcIiwgcGYoeCksIHBmKHkpLCBwZihhcmdzW2pdKSwgcGYoYXJnc1tqICsgMV0pLCBwZihhcmdzW2ogKyAyXSksIHBmKGFyZ3NbaiArIDNdKSk7XG4gICAgICAgICAgeCA9IGFyZ3NbaiArIDJdO1xuICAgICAgICAgIHkgPSBhcmdzW2ogKyAzXTtcbiAgICAgICAgICBqICs9IDQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgX3V0aWwuT1BTLmN1cnZlVG8zOlxuICAgICAgICAgIHggPSBhcmdzW2ogKyAyXTtcbiAgICAgICAgICB5ID0gYXJnc1tqICsgM107XG4gICAgICAgICAgZC5wdXNoKFwiQ1wiLCBwZihhcmdzW2pdKSwgcGYoYXJnc1tqICsgMV0pLCBwZih4KSwgcGYoeSksIHBmKHgpLCBwZih5KSk7XG4gICAgICAgICAgaiArPSA0O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIF91dGlsLk9QUy5jbG9zZVBhdGg6XG4gICAgICAgICAgZC5wdXNoKFwiWlwiKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgZCA9IGQuam9pbihcIiBcIik7XG4gICAgaWYgKGN1cnJlbnQucGF0aCAmJiBvcHMubGVuZ3RoID4gMCAmJiBvcHNbMF0gIT09IF91dGlsLk9QUy5yZWN0YW5nbGUgJiYgb3BzWzBdICE9PSBfdXRpbC5PUFMubW92ZVRvKSB7XG4gICAgICBkID0gY3VycmVudC5wYXRoLmdldEF0dHJpYnV0ZU5TKG51bGwsIFwiZFwiKSArIGQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN1cnJlbnQucGF0aCA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwic3ZnOnBhdGhcIik7XG4gICAgICB0aGlzLl9lbnN1cmVUcmFuc2Zvcm1Hcm91cCgpLmFwcGVuZChjdXJyZW50LnBhdGgpO1xuICAgIH1cbiAgICBjdXJyZW50LnBhdGguc2V0QXR0cmlidXRlTlMobnVsbCwgXCJkXCIsIGQpO1xuICAgIGN1cnJlbnQucGF0aC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImZpbGxcIiwgXCJub25lXCIpO1xuICAgIGN1cnJlbnQuZWxlbWVudCA9IGN1cnJlbnQucGF0aDtcbiAgICBjdXJyZW50LnNldEN1cnJlbnRQb2ludCh4LCB5KTtcbiAgfVxuICBlbmRQYXRoKCkge1xuICAgIGNvbnN0IGN1cnJlbnQgPSB0aGlzLmN1cnJlbnQ7XG4gICAgY3VycmVudC5wYXRoID0gbnVsbDtcbiAgICBpZiAoIXRoaXMucGVuZGluZ0NsaXApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFjdXJyZW50LmVsZW1lbnQpIHtcbiAgICAgIHRoaXMucGVuZGluZ0NsaXAgPSBudWxsO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjbGlwSWQgPSBgY2xpcHBhdGgke2NsaXBDb3VudCsrfWA7XG4gICAgY29uc3QgY2xpcFBhdGggPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcInN2ZzpjbGlwUGF0aFwiKTtcbiAgICBjbGlwUGF0aC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImlkXCIsIGNsaXBJZCk7XG4gICAgY2xpcFBhdGguc2V0QXR0cmlidXRlTlMobnVsbCwgXCJ0cmFuc2Zvcm1cIiwgcG0odGhpcy50cmFuc2Zvcm1NYXRyaXgpKTtcbiAgICBjb25zdCBjbGlwRWxlbWVudCA9IGN1cnJlbnQuZWxlbWVudC5jbG9uZU5vZGUodHJ1ZSk7XG4gICAgaWYgKHRoaXMucGVuZGluZ0NsaXAgPT09IFwiZXZlbm9kZFwiKSB7XG4gICAgICBjbGlwRWxlbWVudC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImNsaXAtcnVsZVwiLCBcImV2ZW5vZGRcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNsaXBFbGVtZW50LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiY2xpcC1ydWxlXCIsIFwibm9uemVyb1wiKTtcbiAgICB9XG4gICAgdGhpcy5wZW5kaW5nQ2xpcCA9IG51bGw7XG4gICAgY2xpcFBhdGguYXBwZW5kKGNsaXBFbGVtZW50KTtcbiAgICB0aGlzLmRlZnMuYXBwZW5kKGNsaXBQYXRoKTtcbiAgICBpZiAoY3VycmVudC5hY3RpdmVDbGlwVXJsKSB7XG4gICAgICBjdXJyZW50LmNsaXBHcm91cCA9IG51bGw7XG4gICAgICBmb3IgKGNvbnN0IHByZXYgb2YgdGhpcy5leHRyYVN0YWNrKSB7XG4gICAgICAgIHByZXYuY2xpcEdyb3VwID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIGNsaXBQYXRoLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiY2xpcC1wYXRoXCIsIGN1cnJlbnQuYWN0aXZlQ2xpcFVybCk7XG4gICAgfVxuICAgIGN1cnJlbnQuYWN0aXZlQ2xpcFVybCA9IGB1cmwoIyR7Y2xpcElkfSlgO1xuICAgIHRoaXMudGdycCA9IG51bGw7XG4gIH1cbiAgY2xpcCh0eXBlKSB7XG4gICAgdGhpcy5wZW5kaW5nQ2xpcCA9IHR5cGU7XG4gIH1cbiAgY2xvc2VQYXRoKCkge1xuICAgIGNvbnN0IGN1cnJlbnQgPSB0aGlzLmN1cnJlbnQ7XG4gICAgaWYgKGN1cnJlbnQucGF0aCkge1xuICAgICAgY29uc3QgZCA9IGAke2N1cnJlbnQucGF0aC5nZXRBdHRyaWJ1dGVOUyhudWxsLCBcImRcIil9WmA7XG4gICAgICBjdXJyZW50LnBhdGguc2V0QXR0cmlidXRlTlMobnVsbCwgXCJkXCIsIGQpO1xuICAgIH1cbiAgfVxuICBzZXRMZWFkaW5nKGxlYWRpbmcpIHtcbiAgICB0aGlzLmN1cnJlbnQubGVhZGluZyA9IC1sZWFkaW5nO1xuICB9XG4gIHNldFRleHRSaXNlKHRleHRSaXNlKSB7XG4gICAgdGhpcy5jdXJyZW50LnRleHRSaXNlID0gdGV4dFJpc2U7XG4gIH1cbiAgc2V0VGV4dFJlbmRlcmluZ01vZGUodGV4dFJlbmRlcmluZ01vZGUpIHtcbiAgICB0aGlzLmN1cnJlbnQudGV4dFJlbmRlcmluZ01vZGUgPSB0ZXh0UmVuZGVyaW5nTW9kZTtcbiAgfVxuICBzZXRIU2NhbGUoc2NhbGUpIHtcbiAgICB0aGlzLmN1cnJlbnQudGV4dEhTY2FsZSA9IHNjYWxlIC8gMTAwO1xuICB9XG4gIHNldFJlbmRlcmluZ0ludGVudChpbnRlbnQpIHt9XG4gIHNldEZsYXRuZXNzKGZsYXRuZXNzKSB7fVxuICBzZXRHU3RhdGUoc3RhdGVzKSB7XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2Ygc3RhdGVzKSB7XG4gICAgICBzd2l0Y2ggKGtleSkge1xuICAgICAgICBjYXNlIFwiTFdcIjpcbiAgICAgICAgICB0aGlzLnNldExpbmVXaWR0aCh2YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJMQ1wiOlxuICAgICAgICAgIHRoaXMuc2V0TGluZUNhcCh2YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJMSlwiOlxuICAgICAgICAgIHRoaXMuc2V0TGluZUpvaW4odmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiTUxcIjpcbiAgICAgICAgICB0aGlzLnNldE1pdGVyTGltaXQodmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiRFwiOlxuICAgICAgICAgIHRoaXMuc2V0RGFzaCh2YWx1ZVswXSwgdmFsdWVbMV0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiUklcIjpcbiAgICAgICAgICB0aGlzLnNldFJlbmRlcmluZ0ludGVudCh2YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJGTFwiOlxuICAgICAgICAgIHRoaXMuc2V0RmxhdG5lc3ModmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiRm9udFwiOlxuICAgICAgICAgIHRoaXMuc2V0Rm9udCh2YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJDQVwiOlxuICAgICAgICAgIHRoaXMuc2V0U3Ryb2tlQWxwaGEodmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiY2FcIjpcbiAgICAgICAgICB0aGlzLnNldEZpbGxBbHBoYSh2YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgKDAsIF91dGlsLndhcm4pKGBVbmltcGxlbWVudGVkIGdyYXBoaWMgc3RhdGUgb3BlcmF0b3IgJHtrZXl9YCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZpbGwoKSB7XG4gICAgY29uc3QgY3VycmVudCA9IHRoaXMuY3VycmVudDtcbiAgICBpZiAoY3VycmVudC5lbGVtZW50KSB7XG4gICAgICBjdXJyZW50LmVsZW1lbnQuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJmaWxsXCIsIGN1cnJlbnQuZmlsbENvbG9yKTtcbiAgICAgIGN1cnJlbnQuZWxlbWVudC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImZpbGwtb3BhY2l0eVwiLCBjdXJyZW50LmZpbGxBbHBoYSk7XG4gICAgICB0aGlzLmVuZFBhdGgoKTtcbiAgICB9XG4gIH1cbiAgc3Ryb2tlKCkge1xuICAgIGNvbnN0IGN1cnJlbnQgPSB0aGlzLmN1cnJlbnQ7XG4gICAgaWYgKGN1cnJlbnQuZWxlbWVudCkge1xuICAgICAgdGhpcy5fc2V0U3Ryb2tlQXR0cmlidXRlcyhjdXJyZW50LmVsZW1lbnQpO1xuICAgICAgY3VycmVudC5lbGVtZW50LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiZmlsbFwiLCBcIm5vbmVcIik7XG4gICAgICB0aGlzLmVuZFBhdGgoKTtcbiAgICB9XG4gIH1cbiAgX3NldFN0cm9rZUF0dHJpYnV0ZXMoZWxlbWVudCwgbGluZVdpZHRoU2NhbGUgPSAxKSB7XG4gICAgY29uc3QgY3VycmVudCA9IHRoaXMuY3VycmVudDtcbiAgICBsZXQgZGFzaEFycmF5ID0gY3VycmVudC5kYXNoQXJyYXk7XG4gICAgaWYgKGxpbmVXaWR0aFNjYWxlICE9PSAxICYmIGRhc2hBcnJheS5sZW5ndGggPiAwKSB7XG4gICAgICBkYXNoQXJyYXkgPSBkYXNoQXJyYXkubWFwKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gbGluZVdpZHRoU2NhbGUgKiB2YWx1ZTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwic3Ryb2tlXCIsIGN1cnJlbnQuc3Ryb2tlQ29sb3IpO1xuICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJzdHJva2Utb3BhY2l0eVwiLCBjdXJyZW50LnN0cm9rZUFscGhhKTtcbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwic3Ryb2tlLW1pdGVybGltaXRcIiwgcGYoY3VycmVudC5taXRlckxpbWl0KSk7XG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInN0cm9rZS1saW5lY2FwXCIsIGN1cnJlbnQubGluZUNhcCk7XG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInN0cm9rZS1saW5lam9pblwiLCBjdXJyZW50LmxpbmVKb2luKTtcbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwic3Ryb2tlLXdpZHRoXCIsIHBmKGxpbmVXaWR0aFNjYWxlICogY3VycmVudC5saW5lV2lkdGgpICsgXCJweFwiKTtcbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwic3Ryb2tlLWRhc2hhcnJheVwiLCBkYXNoQXJyYXkubWFwKHBmKS5qb2luKFwiIFwiKSk7XG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInN0cm9rZS1kYXNob2Zmc2V0XCIsIHBmKGxpbmVXaWR0aFNjYWxlICogY3VycmVudC5kYXNoUGhhc2UpICsgXCJweFwiKTtcbiAgfVxuICBlb0ZpbGwoKSB7XG4gICAgdGhpcy5jdXJyZW50LmVsZW1lbnQ/LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiZmlsbC1ydWxlXCIsIFwiZXZlbm9kZFwiKTtcbiAgICB0aGlzLmZpbGwoKTtcbiAgfVxuICBmaWxsU3Ryb2tlKCkge1xuICAgIHRoaXMuc3Ryb2tlKCk7XG4gICAgdGhpcy5maWxsKCk7XG4gIH1cbiAgZW9GaWxsU3Ryb2tlKCkge1xuICAgIHRoaXMuY3VycmVudC5lbGVtZW50Py5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImZpbGwtcnVsZVwiLCBcImV2ZW5vZGRcIik7XG4gICAgdGhpcy5maWxsU3Ryb2tlKCk7XG4gIH1cbiAgY2xvc2VTdHJva2UoKSB7XG4gICAgdGhpcy5jbG9zZVBhdGgoKTtcbiAgICB0aGlzLnN0cm9rZSgpO1xuICB9XG4gIGNsb3NlRmlsbFN0cm9rZSgpIHtcbiAgICB0aGlzLmNsb3NlUGF0aCgpO1xuICAgIHRoaXMuZmlsbFN0cm9rZSgpO1xuICB9XG4gIGNsb3NlRU9GaWxsU3Ryb2tlKCkge1xuICAgIHRoaXMuY2xvc2VQYXRoKCk7XG4gICAgdGhpcy5lb0ZpbGxTdHJva2UoKTtcbiAgfVxuICBwYWludFNvbGlkQ29sb3JJbWFnZU1hc2soKSB7XG4gICAgY29uc3QgcmVjdCA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwic3ZnOnJlY3RcIik7XG4gICAgcmVjdC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInhcIiwgXCIwXCIpO1xuICAgIHJlY3Quc2V0QXR0cmlidXRlTlMobnVsbCwgXCJ5XCIsIFwiMFwiKTtcbiAgICByZWN0LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwid2lkdGhcIiwgXCIxcHhcIik7XG4gICAgcmVjdC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImhlaWdodFwiLCBcIjFweFwiKTtcbiAgICByZWN0LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiZmlsbFwiLCB0aGlzLmN1cnJlbnQuZmlsbENvbG9yKTtcbiAgICB0aGlzLl9lbnN1cmVUcmFuc2Zvcm1Hcm91cCgpLmFwcGVuZChyZWN0KTtcbiAgfVxuICBwYWludEltYWdlWE9iamVjdChvYmpJZCkge1xuICAgIGNvbnN0IGltZ0RhdGEgPSB0aGlzLmdldE9iamVjdChvYmpJZCk7XG4gICAgaWYgKCFpbWdEYXRhKSB7XG4gICAgICAoMCwgX3V0aWwud2FybikoYERlcGVuZGVudCBpbWFnZSB3aXRoIG9iamVjdCBJRCAke29iaklkfSBpcyBub3QgcmVhZHkgeWV0YCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMucGFpbnRJbmxpbmVJbWFnZVhPYmplY3QoaW1nRGF0YSk7XG4gIH1cbiAgcGFpbnRJbmxpbmVJbWFnZVhPYmplY3QoaW1nRGF0YSwgbWFzaykge1xuICAgIGNvbnN0IHdpZHRoID0gaW1nRGF0YS53aWR0aDtcbiAgICBjb25zdCBoZWlnaHQgPSBpbWdEYXRhLmhlaWdodDtcbiAgICBjb25zdCBpbWdTcmMgPSBjb252ZXJ0SW1nRGF0YVRvUG5nKGltZ0RhdGEsIHRoaXMuZm9yY2VEYXRhU2NoZW1hLCAhIW1hc2spO1xuICAgIGNvbnN0IGNsaXByZWN0ID0gdGhpcy5zdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJzdmc6cmVjdFwiKTtcbiAgICBjbGlwcmVjdC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInhcIiwgXCIwXCIpO1xuICAgIGNsaXByZWN0LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwieVwiLCBcIjBcIik7XG4gICAgY2xpcHJlY3Quc2V0QXR0cmlidXRlTlMobnVsbCwgXCJ3aWR0aFwiLCBwZih3aWR0aCkpO1xuICAgIGNsaXByZWN0LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiaGVpZ2h0XCIsIHBmKGhlaWdodCkpO1xuICAgIHRoaXMuY3VycmVudC5lbGVtZW50ID0gY2xpcHJlY3Q7XG4gICAgdGhpcy5jbGlwKFwibm9uemVyb1wiKTtcbiAgICBjb25zdCBpbWdFbCA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwic3ZnOmltYWdlXCIpO1xuICAgIGltZ0VsLnNldEF0dHJpYnV0ZU5TKFhMSU5LX05TLCBcInhsaW5rOmhyZWZcIiwgaW1nU3JjKTtcbiAgICBpbWdFbC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInhcIiwgXCIwXCIpO1xuICAgIGltZ0VsLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwieVwiLCBwZigtaGVpZ2h0KSk7XG4gICAgaW1nRWwuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJ3aWR0aFwiLCBwZih3aWR0aCkgKyBcInB4XCIpO1xuICAgIGltZ0VsLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiaGVpZ2h0XCIsIHBmKGhlaWdodCkgKyBcInB4XCIpO1xuICAgIGltZ0VsLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwidHJhbnNmb3JtXCIsIGBzY2FsZSgke3BmKDEgLyB3aWR0aCl9ICR7cGYoLTEgLyBoZWlnaHQpfSlgKTtcbiAgICBpZiAobWFzaykge1xuICAgICAgbWFzay5hcHBlbmQoaW1nRWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9lbnN1cmVUcmFuc2Zvcm1Hcm91cCgpLmFwcGVuZChpbWdFbCk7XG4gICAgfVxuICB9XG4gIHBhaW50SW1hZ2VNYXNrWE9iamVjdChpbWcpIHtcbiAgICBjb25zdCBpbWdEYXRhID0gdGhpcy5nZXRPYmplY3QoaW1nLmRhdGEsIGltZyk7XG4gICAgaWYgKGltZ0RhdGEuYml0bWFwKSB7XG4gICAgICAoMCwgX3V0aWwud2FybikoXCJwYWludEltYWdlTWFza1hPYmplY3Q6IEltYWdlQml0bWFwIHN1cHBvcnQgaXMgbm90IGltcGxlbWVudGVkLCBcIiArIFwiZW5zdXJlIHRoYXQgdGhlIGBpc09mZnNjcmVlbkNhbnZhc1N1cHBvcnRlZGAgQVBJIHBhcmFtZXRlciBpcyBkaXNhYmxlZC5cIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGN1cnJlbnQgPSB0aGlzLmN1cnJlbnQ7XG4gICAgY29uc3Qgd2lkdGggPSBpbWdEYXRhLndpZHRoO1xuICAgIGNvbnN0IGhlaWdodCA9IGltZ0RhdGEuaGVpZ2h0O1xuICAgIGNvbnN0IGZpbGxDb2xvciA9IGN1cnJlbnQuZmlsbENvbG9yO1xuICAgIGN1cnJlbnQubWFza0lkID0gYG1hc2ske21hc2tDb3VudCsrfWA7XG4gICAgY29uc3QgbWFzayA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwic3ZnOm1hc2tcIik7XG4gICAgbWFzay5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImlkXCIsIGN1cnJlbnQubWFza0lkKTtcbiAgICBjb25zdCByZWN0ID0gdGhpcy5zdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJzdmc6cmVjdFwiKTtcbiAgICByZWN0LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwieFwiLCBcIjBcIik7XG4gICAgcmVjdC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInlcIiwgXCIwXCIpO1xuICAgIHJlY3Quc2V0QXR0cmlidXRlTlMobnVsbCwgXCJ3aWR0aFwiLCBwZih3aWR0aCkpO1xuICAgIHJlY3Quc2V0QXR0cmlidXRlTlMobnVsbCwgXCJoZWlnaHRcIiwgcGYoaGVpZ2h0KSk7XG4gICAgcmVjdC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImZpbGxcIiwgZmlsbENvbG9yKTtcbiAgICByZWN0LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwibWFza1wiLCBgdXJsKCMke2N1cnJlbnQubWFza0lkfSlgKTtcbiAgICB0aGlzLmRlZnMuYXBwZW5kKG1hc2spO1xuICAgIHRoaXMuX2Vuc3VyZVRyYW5zZm9ybUdyb3VwKCkuYXBwZW5kKHJlY3QpO1xuICAgIHRoaXMucGFpbnRJbmxpbmVJbWFnZVhPYmplY3QoaW1nRGF0YSwgbWFzayk7XG4gIH1cbiAgcGFpbnRGb3JtWE9iamVjdEJlZ2luKG1hdHJpeCwgYmJveCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KG1hdHJpeCkgJiYgbWF0cml4Lmxlbmd0aCA9PT0gNikge1xuICAgICAgdGhpcy50cmFuc2Zvcm0obWF0cml4WzBdLCBtYXRyaXhbMV0sIG1hdHJpeFsyXSwgbWF0cml4WzNdLCBtYXRyaXhbNF0sIG1hdHJpeFs1XSk7XG4gICAgfVxuICAgIGlmIChiYm94KSB7XG4gICAgICBjb25zdCB3aWR0aCA9IGJib3hbMl0gLSBiYm94WzBdO1xuICAgICAgY29uc3QgaGVpZ2h0ID0gYmJveFszXSAtIGJib3hbMV07XG4gICAgICBjb25zdCBjbGlwcmVjdCA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwic3ZnOnJlY3RcIik7XG4gICAgICBjbGlwcmVjdC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInhcIiwgYmJveFswXSk7XG4gICAgICBjbGlwcmVjdC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInlcIiwgYmJveFsxXSk7XG4gICAgICBjbGlwcmVjdC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcIndpZHRoXCIsIHBmKHdpZHRoKSk7XG4gICAgICBjbGlwcmVjdC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImhlaWdodFwiLCBwZihoZWlnaHQpKTtcbiAgICAgIHRoaXMuY3VycmVudC5lbGVtZW50ID0gY2xpcHJlY3Q7XG4gICAgICB0aGlzLmNsaXAoXCJub256ZXJvXCIpO1xuICAgICAgdGhpcy5lbmRQYXRoKCk7XG4gICAgfVxuICB9XG4gIHBhaW50Rm9ybVhPYmplY3RFbmQoKSB7fVxuICBfaW5pdGlhbGl6ZSh2aWV3cG9ydCkge1xuICAgIGNvbnN0IHN2ZyA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGUodmlld3BvcnQud2lkdGgsIHZpZXdwb3J0LmhlaWdodCk7XG4gICAgY29uc3QgZGVmaW5pdGlvbnMgPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcInN2ZzpkZWZzXCIpO1xuICAgIHN2Zy5hcHBlbmQoZGVmaW5pdGlvbnMpO1xuICAgIHRoaXMuZGVmcyA9IGRlZmluaXRpb25zO1xuICAgIGNvbnN0IHJvb3RHcm91cCA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwic3ZnOmdcIik7XG4gICAgcm9vdEdyb3VwLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwidHJhbnNmb3JtXCIsIHBtKHZpZXdwb3J0LnRyYW5zZm9ybSkpO1xuICAgIHN2Zy5hcHBlbmQocm9vdEdyb3VwKTtcbiAgICB0aGlzLnN2ZyA9IHJvb3RHcm91cDtcbiAgICByZXR1cm4gc3ZnO1xuICB9XG4gIF9lbnN1cmVDbGlwR3JvdXAoKSB7XG4gICAgaWYgKCF0aGlzLmN1cnJlbnQuY2xpcEdyb3VwKSB7XG4gICAgICBjb25zdCBjbGlwR3JvdXAgPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcInN2ZzpnXCIpO1xuICAgICAgY2xpcEdyb3VwLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiY2xpcC1wYXRoXCIsIHRoaXMuY3VycmVudC5hY3RpdmVDbGlwVXJsKTtcbiAgICAgIHRoaXMuc3ZnLmFwcGVuZChjbGlwR3JvdXApO1xuICAgICAgdGhpcy5jdXJyZW50LmNsaXBHcm91cCA9IGNsaXBHcm91cDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY3VycmVudC5jbGlwR3JvdXA7XG4gIH1cbiAgX2Vuc3VyZVRyYW5zZm9ybUdyb3VwKCkge1xuICAgIGlmICghdGhpcy50Z3JwKSB7XG4gICAgICB0aGlzLnRncnAgPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcInN2ZzpnXCIpO1xuICAgICAgdGhpcy50Z3JwLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwidHJhbnNmb3JtXCIsIHBtKHRoaXMudHJhbnNmb3JtTWF0cml4KSk7XG4gICAgICBpZiAodGhpcy5jdXJyZW50LmFjdGl2ZUNsaXBVcmwpIHtcbiAgICAgICAgdGhpcy5fZW5zdXJlQ2xpcEdyb3VwKCkuYXBwZW5kKHRoaXMudGdycCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnN2Zy5hcHBlbmQodGhpcy50Z3JwKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudGdycDtcbiAgfVxufVxuZXhwb3J0cy5TVkdHcmFwaGljcyA9IFNWR0dyYXBoaWNzO1xuXG4vKioqLyB9KSxcbi8qIDI1ICovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzKSA9PiB7XG5cblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5leHBvcnRzLlhmYVRleHQgPSB2b2lkIDA7XG5jbGFzcyBYZmFUZXh0IHtcbiAgc3RhdGljIHRleHRDb250ZW50KHhmYSkge1xuICAgIGNvbnN0IGl0ZW1zID0gW107XG4gICAgY29uc3Qgb3V0cHV0ID0ge1xuICAgICAgaXRlbXMsXG4gICAgICBzdHlsZXM6IE9iamVjdC5jcmVhdGUobnVsbClcbiAgICB9O1xuICAgIGZ1bmN0aW9uIHdhbGsobm9kZSkge1xuICAgICAgaWYgKCFub2RlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGxldCBzdHIgPSBudWxsO1xuICAgICAgY29uc3QgbmFtZSA9IG5vZGUubmFtZTtcbiAgICAgIGlmIChuYW1lID09PSBcIiN0ZXh0XCIpIHtcbiAgICAgICAgc3RyID0gbm9kZS52YWx1ZTtcbiAgICAgIH0gZWxzZSBpZiAoIVhmYVRleHQuc2hvdWxkQnVpbGRUZXh0KG5hbWUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSBpZiAobm9kZT8uYXR0cmlidXRlcz8udGV4dENvbnRlbnQpIHtcbiAgICAgICAgc3RyID0gbm9kZS5hdHRyaWJ1dGVzLnRleHRDb250ZW50O1xuICAgICAgfSBlbHNlIGlmIChub2RlLnZhbHVlKSB7XG4gICAgICAgIHN0ciA9IG5vZGUudmFsdWU7XG4gICAgICB9XG4gICAgICBpZiAoc3RyICE9PSBudWxsKSB7XG4gICAgICAgIGl0ZW1zLnB1c2goe1xuICAgICAgICAgIHN0clxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmICghbm9kZS5jaGlsZHJlbikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIG5vZGUuY2hpbGRyZW4pIHtcbiAgICAgICAgd2FsayhjaGlsZCk7XG4gICAgICB9XG4gICAgfVxuICAgIHdhbGsoeGZhKTtcbiAgICByZXR1cm4gb3V0cHV0O1xuICB9XG4gIHN0YXRpYyBzaG91bGRCdWlsZFRleHQobmFtZSkge1xuICAgIHJldHVybiAhKG5hbWUgPT09IFwidGV4dGFyZWFcIiB8fCBuYW1lID09PSBcImlucHV0XCIgfHwgbmFtZSA9PT0gXCJvcHRpb25cIiB8fCBuYW1lID09PSBcInNlbGVjdFwiKTtcbiAgfVxufVxuZXhwb3J0cy5YZmFUZXh0ID0gWGZhVGV4dDtcblxuLyoqKi8gfSksXG4vKiAyNiAqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykgPT4ge1xuXG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xuZXhwb3J0cy5UZXh0TGF5ZXJSZW5kZXJUYXNrID0gdm9pZCAwO1xuZXhwb3J0cy5yZW5kZXJUZXh0TGF5ZXIgPSByZW5kZXJUZXh0TGF5ZXI7XG5leHBvcnRzLnVwZGF0ZVRleHRMYXllciA9IHVwZGF0ZVRleHRMYXllcjtcbnZhciBfdXRpbCA9IF9fd19wZGZqc19yZXF1aXJlX18oMSk7XG52YXIgX2Rpc3BsYXlfdXRpbHMgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDYpO1xuY29uc3QgTUFYX1RFWFRfRElWU19UT19SRU5ERVIgPSAxMDAwMDA7XG5jb25zdCBERUZBVUxUX0ZPTlRfU0laRSA9IDMwO1xuY29uc3QgREVGQVVMVF9GT05UX0FTQ0VOVCA9IDAuODtcbmNvbnN0IGFzY2VudENhY2hlID0gbmV3IE1hcCgpO1xuZnVuY3Rpb24gZ2V0Q3R4KHNpemUsIGlzT2Zmc2NyZWVuQ2FudmFzU3VwcG9ydGVkKSB7XG4gIGxldCBjdHg7XG4gIGlmIChpc09mZnNjcmVlbkNhbnZhc1N1cHBvcnRlZCAmJiBfdXRpbC5GZWF0dXJlVGVzdC5pc09mZnNjcmVlbkNhbnZhc1N1cHBvcnRlZCkge1xuICAgIGN0eCA9IG5ldyBPZmZzY3JlZW5DYW52YXMoc2l6ZSwgc2l6ZSkuZ2V0Q29udGV4dChcIjJkXCIsIHtcbiAgICAgIGFscGhhOiBmYWxzZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gICAgY2FudmFzLndpZHRoID0gY2FudmFzLmhlaWdodCA9IHNpemU7XG4gICAgY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiLCB7XG4gICAgICBhbHBoYTogZmFsc2VcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gY3R4O1xufVxuZnVuY3Rpb24gZ2V0QXNjZW50KGZvbnRGYW1pbHksIGlzT2Zmc2NyZWVuQ2FudmFzU3VwcG9ydGVkKSB7XG4gIGNvbnN0IGNhY2hlZEFzY2VudCA9IGFzY2VudENhY2hlLmdldChmb250RmFtaWx5KTtcbiAgaWYgKGNhY2hlZEFzY2VudCkge1xuICAgIHJldHVybiBjYWNoZWRBc2NlbnQ7XG4gIH1cbiAgY29uc3QgY3R4ID0gZ2V0Q3R4KERFRkFVTFRfRk9OVF9TSVpFLCBpc09mZnNjcmVlbkNhbnZhc1N1cHBvcnRlZCk7XG4gIGN0eC5mb250ID0gYCR7REVGQVVMVF9GT05UX1NJWkV9cHggJHtmb250RmFtaWx5fWA7XG4gIGNvbnN0IG1ldHJpY3MgPSBjdHgubWVhc3VyZVRleHQoXCJcIik7XG4gIGxldCBhc2NlbnQgPSBtZXRyaWNzLmZvbnRCb3VuZGluZ0JveEFzY2VudDtcbiAgbGV0IGRlc2NlbnQgPSBNYXRoLmFicyhtZXRyaWNzLmZvbnRCb3VuZGluZ0JveERlc2NlbnQpO1xuICBpZiAoYXNjZW50KSB7XG4gICAgY29uc3QgcmF0aW8gPSBhc2NlbnQgLyAoYXNjZW50ICsgZGVzY2VudCk7XG4gICAgYXNjZW50Q2FjaGUuc2V0KGZvbnRGYW1pbHksIHJhdGlvKTtcbiAgICBjdHguY2FudmFzLndpZHRoID0gY3R4LmNhbnZhcy5oZWlnaHQgPSAwO1xuICAgIHJldHVybiByYXRpbztcbiAgfVxuICBjdHguc3Ryb2tlU3R5bGUgPSBcInJlZFwiO1xuICBjdHguY2xlYXJSZWN0KDAsIDAsIERFRkFVTFRfRk9OVF9TSVpFLCBERUZBVUxUX0ZPTlRfU0laRSk7XG4gIGN0eC5zdHJva2VUZXh0KFwiZ1wiLCAwLCAwKTtcbiAgbGV0IHBpeGVscyA9IGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgREVGQVVMVF9GT05UX1NJWkUsIERFRkFVTFRfRk9OVF9TSVpFKS5kYXRhO1xuICBkZXNjZW50ID0gMDtcbiAgZm9yIChsZXQgaSA9IHBpeGVscy5sZW5ndGggLSAxIC0gMzsgaSA+PSAwOyBpIC09IDQpIHtcbiAgICBpZiAocGl4ZWxzW2ldID4gMCkge1xuICAgICAgZGVzY2VudCA9IE1hdGguY2VpbChpIC8gNCAvIERFRkFVTFRfRk9OVF9TSVpFKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBjdHguY2xlYXJSZWN0KDAsIDAsIERFRkFVTFRfRk9OVF9TSVpFLCBERUZBVUxUX0ZPTlRfU0laRSk7XG4gIGN0eC5zdHJva2VUZXh0KFwiQVwiLCAwLCBERUZBVUxUX0ZPTlRfU0laRSk7XG4gIHBpeGVscyA9IGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgREVGQVVMVF9GT05UX1NJWkUsIERFRkFVTFRfRk9OVF9TSVpFKS5kYXRhO1xuICBhc2NlbnQgPSAwO1xuICBmb3IgKGxldCBpID0gMCwgaWkgPSBwaXhlbHMubGVuZ3RoOyBpIDwgaWk7IGkgKz0gNCkge1xuICAgIGlmIChwaXhlbHNbaV0gPiAwKSB7XG4gICAgICBhc2NlbnQgPSBERUZBVUxUX0ZPTlRfU0laRSAtIE1hdGguZmxvb3IoaSAvIDQgLyBERUZBVUxUX0ZPTlRfU0laRSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgY3R4LmNhbnZhcy53aWR0aCA9IGN0eC5jYW52YXMuaGVpZ2h0ID0gMDtcbiAgaWYgKGFzY2VudCkge1xuICAgIGNvbnN0IHJhdGlvID0gYXNjZW50IC8gKGFzY2VudCArIGRlc2NlbnQpO1xuICAgIGFzY2VudENhY2hlLnNldChmb250RmFtaWx5LCByYXRpbyk7XG4gICAgcmV0dXJuIHJhdGlvO1xuICB9XG4gIGFzY2VudENhY2hlLnNldChmb250RmFtaWx5LCBERUZBVUxUX0ZPTlRfQVNDRU5UKTtcbiAgcmV0dXJuIERFRkFVTFRfRk9OVF9BU0NFTlQ7XG59XG5mdW5jdGlvbiBhcHBlbmRUZXh0KHRhc2ssIGdlb20sIHN0eWxlcykge1xuICBjb25zdCB0ZXh0RGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gIGNvbnN0IHRleHREaXZQcm9wZXJ0aWVzID0ge1xuICAgIGFuZ2xlOiAwLFxuICAgIGNhbnZhc1dpZHRoOiAwLFxuICAgIGhhc1RleHQ6IGdlb20uc3RyICE9PSBcIlwiLFxuICAgIGhhc0VPTDogZ2VvbS5oYXNFT0wsXG4gICAgZm9udFNpemU6IDBcbiAgfTtcbiAgdGFzay5fdGV4dERpdnMucHVzaCh0ZXh0RGl2KTtcbiAgY29uc3QgdHggPSBfdXRpbC5VdGlsLnRyYW5zZm9ybSh0YXNrLl90cmFuc2Zvcm0sIGdlb20udHJhbnNmb3JtKTtcbiAgbGV0IGFuZ2xlID0gTWF0aC5hdGFuMih0eFsxXSwgdHhbMF0pO1xuICBjb25zdCBzdHlsZSA9IHN0eWxlc1tnZW9tLmZvbnROYW1lXTtcbiAgaWYgKHN0eWxlLnZlcnRpY2FsKSB7XG4gICAgYW5nbGUgKz0gTWF0aC5QSSAvIDI7XG4gIH1cbiAgY29uc3QgZm9udEhlaWdodCA9IE1hdGguaHlwb3QodHhbMl0sIHR4WzNdKTtcbiAgY29uc3QgZm9udEFzY2VudCA9IGZvbnRIZWlnaHQgKiBnZXRBc2NlbnQoc3R5bGUuZm9udEZhbWlseSwgdGFzay5faXNPZmZzY3JlZW5DYW52YXNTdXBwb3J0ZWQpO1xuICBsZXQgbGVmdCwgdG9wO1xuICBpZiAoYW5nbGUgPT09IDApIHtcbiAgICBsZWZ0ID0gdHhbNF07XG4gICAgdG9wID0gdHhbNV0gLSBmb250QXNjZW50O1xuICB9IGVsc2Uge1xuICAgIGxlZnQgPSB0eFs0XSArIGZvbnRBc2NlbnQgKiBNYXRoLnNpbihhbmdsZSk7XG4gICAgdG9wID0gdHhbNV0gLSBmb250QXNjZW50ICogTWF0aC5jb3MoYW5nbGUpO1xuICB9XG4gIGNvbnN0IHNjYWxlRmFjdG9yU3RyID0gXCJjYWxjKHZhcigtLXNjYWxlLWZhY3RvcikqXCI7XG4gIGNvbnN0IGRpdlN0eWxlID0gdGV4dERpdi5zdHlsZTtcbiAgaWYgKHRhc2suX2NvbnRhaW5lciA9PT0gdGFzay5fcm9vdENvbnRhaW5lcikge1xuICAgIGRpdlN0eWxlLmxlZnQgPSBgJHsoMTAwICogbGVmdCAvIHRhc2suX3BhZ2VXaWR0aCkudG9GaXhlZCgyKX0lYDtcbiAgICBkaXZTdHlsZS50b3AgPSBgJHsoMTAwICogdG9wIC8gdGFzay5fcGFnZUhlaWdodCkudG9GaXhlZCgyKX0lYDtcbiAgfSBlbHNlIHtcbiAgICBkaXZTdHlsZS5sZWZ0ID0gYCR7c2NhbGVGYWN0b3JTdHJ9JHtsZWZ0LnRvRml4ZWQoMil9cHgpYDtcbiAgICBkaXZTdHlsZS50b3AgPSBgJHtzY2FsZUZhY3RvclN0cn0ke3RvcC50b0ZpeGVkKDIpfXB4KWA7XG4gIH1cbiAgZGl2U3R5bGUuZm9udFNpemUgPSBgJHtzY2FsZUZhY3RvclN0cn0ke2ZvbnRIZWlnaHQudG9GaXhlZCgyKX1weClgO1xuICBkaXZTdHlsZS5mb250RmFtaWx5ID0gc3R5bGUuZm9udEZhbWlseTtcbiAgdGV4dERpdlByb3BlcnRpZXMuZm9udFNpemUgPSBmb250SGVpZ2h0O1xuICB0ZXh0RGl2LnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJwcmVzZW50YXRpb25cIik7XG4gIHRleHREaXYudGV4dENvbnRlbnQgPSBnZW9tLnN0cjtcbiAgdGV4dERpdi5kaXIgPSBnZW9tLmRpcjtcbiAgaWYgKHRhc2suX2ZvbnRJbnNwZWN0b3JFbmFibGVkKSB7XG4gICAgdGV4dERpdi5kYXRhc2V0LmZvbnROYW1lID0gZ2VvbS5mb250TmFtZTtcbiAgfVxuICBpZiAoYW5nbGUgIT09IDApIHtcbiAgICB0ZXh0RGl2UHJvcGVydGllcy5hbmdsZSA9IGFuZ2xlICogKDE4MCAvIE1hdGguUEkpO1xuICB9XG4gIGxldCBzaG91bGRTY2FsZVRleHQgPSBmYWxzZTtcbiAgaWYgKGdlb20uc3RyLmxlbmd0aCA+IDEpIHtcbiAgICBzaG91bGRTY2FsZVRleHQgPSB0cnVlO1xuICB9IGVsc2UgaWYgKGdlb20uc3RyICE9PSBcIiBcIiAmJiBnZW9tLnRyYW5zZm9ybVswXSAhPT0gZ2VvbS50cmFuc2Zvcm1bM10pIHtcbiAgICBjb25zdCBhYnNTY2FsZVggPSBNYXRoLmFicyhnZW9tLnRyYW5zZm9ybVswXSksXG4gICAgICBhYnNTY2FsZVkgPSBNYXRoLmFicyhnZW9tLnRyYW5zZm9ybVszXSk7XG4gICAgaWYgKGFic1NjYWxlWCAhPT0gYWJzU2NhbGVZICYmIE1hdGgubWF4KGFic1NjYWxlWCwgYWJzU2NhbGVZKSAvIE1hdGgubWluKGFic1NjYWxlWCwgYWJzU2NhbGVZKSA+IDEuNSkge1xuICAgICAgc2hvdWxkU2NhbGVUZXh0ID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgaWYgKHNob3VsZFNjYWxlVGV4dCkge1xuICAgIHRleHREaXZQcm9wZXJ0aWVzLmNhbnZhc1dpZHRoID0gc3R5bGUudmVydGljYWwgPyBnZW9tLmhlaWdodCA6IGdlb20ud2lkdGg7XG4gIH1cbiAgdGFzay5fdGV4dERpdlByb3BlcnRpZXMuc2V0KHRleHREaXYsIHRleHREaXZQcm9wZXJ0aWVzKTtcbiAgaWYgKHRhc2suX2lzUmVhZGFibGVTdHJlYW0pIHtcbiAgICB0YXNrLl9sYXlvdXRUZXh0KHRleHREaXYpO1xuICB9XG59XG5mdW5jdGlvbiBsYXlvdXQocGFyYW1zKSB7XG4gIGNvbnN0IHtcbiAgICBkaXYsXG4gICAgc2NhbGUsXG4gICAgcHJvcGVydGllcyxcbiAgICBjdHgsXG4gICAgcHJldkZvbnRTaXplLFxuICAgIHByZXZGb250RmFtaWx5XG4gIH0gPSBwYXJhbXM7XG4gIGNvbnN0IHtcbiAgICBzdHlsZVxuICB9ID0gZGl2O1xuICBsZXQgdHJhbnNmb3JtID0gXCJcIjtcbiAgaWYgKHByb3BlcnRpZXMuY2FudmFzV2lkdGggIT09IDAgJiYgcHJvcGVydGllcy5oYXNUZXh0KSB7XG4gICAgY29uc3Qge1xuICAgICAgZm9udEZhbWlseVxuICAgIH0gPSBzdHlsZTtcbiAgICBjb25zdCB7XG4gICAgICBjYW52YXNXaWR0aCxcbiAgICAgIGZvbnRTaXplXG4gICAgfSA9IHByb3BlcnRpZXM7XG4gICAgaWYgKHByZXZGb250U2l6ZSAhPT0gZm9udFNpemUgfHwgcHJldkZvbnRGYW1pbHkgIT09IGZvbnRGYW1pbHkpIHtcbiAgICAgIGN0eC5mb250ID0gYCR7Zm9udFNpemUgKiBzY2FsZX1weCAke2ZvbnRGYW1pbHl9YDtcbiAgICAgIHBhcmFtcy5wcmV2Rm9udFNpemUgPSBmb250U2l6ZTtcbiAgICAgIHBhcmFtcy5wcmV2Rm9udEZhbWlseSA9IGZvbnRGYW1pbHk7XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIHdpZHRoXG4gICAgfSA9IGN0eC5tZWFzdXJlVGV4dChkaXYudGV4dENvbnRlbnQpO1xuICAgIGlmICh3aWR0aCA+IDApIHtcbiAgICAgIHRyYW5zZm9ybSA9IGBzY2FsZVgoJHtjYW52YXNXaWR0aCAqIHNjYWxlIC8gd2lkdGh9KWA7XG4gICAgfVxuICB9XG4gIGlmIChwcm9wZXJ0aWVzLmFuZ2xlICE9PSAwKSB7XG4gICAgdHJhbnNmb3JtID0gYHJvdGF0ZSgke3Byb3BlcnRpZXMuYW5nbGV9ZGVnKSAke3RyYW5zZm9ybX1gO1xuICB9XG4gIGlmICh0cmFuc2Zvcm0ubGVuZ3RoID4gMCkge1xuICAgIHN0eWxlLnRyYW5zZm9ybSA9IHRyYW5zZm9ybTtcbiAgfVxufVxuZnVuY3Rpb24gcmVuZGVyKHRhc2spIHtcbiAgaWYgKHRhc2suX2NhbmNlbGVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHRleHREaXZzID0gdGFzay5fdGV4dERpdnM7XG4gIGNvbnN0IGNhcGFiaWxpdHkgPSB0YXNrLl9jYXBhYmlsaXR5O1xuICBjb25zdCB0ZXh0RGl2c0xlbmd0aCA9IHRleHREaXZzLmxlbmd0aDtcbiAgaWYgKHRleHREaXZzTGVuZ3RoID4gTUFYX1RFWFRfRElWU19UT19SRU5ERVIpIHtcbiAgICBjYXBhYmlsaXR5LnJlc29sdmUoKTtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKCF0YXNrLl9pc1JlYWRhYmxlU3RyZWFtKSB7XG4gICAgZm9yIChjb25zdCB0ZXh0RGl2IG9mIHRleHREaXZzKSB7XG4gICAgICB0YXNrLl9sYXlvdXRUZXh0KHRleHREaXYpO1xuICAgIH1cbiAgfVxuICBjYXBhYmlsaXR5LnJlc29sdmUoKTtcbn1cbmNsYXNzIFRleHRMYXllclJlbmRlclRhc2sge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgdGV4dENvbnRlbnRTb3VyY2UsXG4gICAgY29udGFpbmVyLFxuICAgIHZpZXdwb3J0LFxuICAgIHRleHREaXZzLFxuICAgIHRleHREaXZQcm9wZXJ0aWVzLFxuICAgIHRleHRDb250ZW50SXRlbXNTdHIsXG4gICAgaXNPZmZzY3JlZW5DYW52YXNTdXBwb3J0ZWRcbiAgfSkge1xuICAgIHRoaXMuX3RleHRDb250ZW50U291cmNlID0gdGV4dENvbnRlbnRTb3VyY2U7XG4gICAgdGhpcy5faXNSZWFkYWJsZVN0cmVhbSA9IHRleHRDb250ZW50U291cmNlIGluc3RhbmNlb2YgUmVhZGFibGVTdHJlYW07XG4gICAgdGhpcy5fY29udGFpbmVyID0gdGhpcy5fcm9vdENvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICB0aGlzLl90ZXh0RGl2cyA9IHRleHREaXZzIHx8IFtdO1xuICAgIHRoaXMuX3RleHRDb250ZW50SXRlbXNTdHIgPSB0ZXh0Q29udGVudEl0ZW1zU3RyIHx8IFtdO1xuICAgIHRoaXMuX2lzT2Zmc2NyZWVuQ2FudmFzU3VwcG9ydGVkID0gaXNPZmZzY3JlZW5DYW52YXNTdXBwb3J0ZWQ7XG4gICAgdGhpcy5fZm9udEluc3BlY3RvckVuYWJsZWQgPSAhIWdsb2JhbFRoaXMuRm9udEluc3BlY3Rvcj8uZW5hYmxlZDtcbiAgICB0aGlzLl9yZWFkZXIgPSBudWxsO1xuICAgIHRoaXMuX3RleHREaXZQcm9wZXJ0aWVzID0gdGV4dERpdlByb3BlcnRpZXMgfHwgbmV3IFdlYWtNYXAoKTtcbiAgICB0aGlzLl9jYW5jZWxlZCA9IGZhbHNlO1xuICAgIHRoaXMuX2NhcGFiaWxpdHkgPSBuZXcgX3V0aWwuUHJvbWlzZUNhcGFiaWxpdHkoKTtcbiAgICB0aGlzLl9sYXlvdXRUZXh0UGFyYW1zID0ge1xuICAgICAgcHJldkZvbnRTaXplOiBudWxsLFxuICAgICAgcHJldkZvbnRGYW1pbHk6IG51bGwsXG4gICAgICBkaXY6IG51bGwsXG4gICAgICBzY2FsZTogdmlld3BvcnQuc2NhbGUgKiAoZ2xvYmFsVGhpcy5kZXZpY2VQaXhlbFJhdGlvIHx8IDEpLFxuICAgICAgcHJvcGVydGllczogbnVsbCxcbiAgICAgIGN0eDogZ2V0Q3R4KDAsIGlzT2Zmc2NyZWVuQ2FudmFzU3VwcG9ydGVkKVxuICAgIH07XG4gICAgY29uc3Qge1xuICAgICAgcGFnZVdpZHRoLFxuICAgICAgcGFnZUhlaWdodCxcbiAgICAgIHBhZ2VYLFxuICAgICAgcGFnZVlcbiAgICB9ID0gdmlld3BvcnQucmF3RGltcztcbiAgICB0aGlzLl90cmFuc2Zvcm0gPSBbMSwgMCwgMCwgLTEsIC1wYWdlWCwgcGFnZVkgKyBwYWdlSGVpZ2h0XTtcbiAgICB0aGlzLl9wYWdlV2lkdGggPSBwYWdlV2lkdGg7XG4gICAgdGhpcy5fcGFnZUhlaWdodCA9IHBhZ2VIZWlnaHQ7XG4gICAgKDAsIF9kaXNwbGF5X3V0aWxzLnNldExheWVyRGltZW5zaW9ucykoY29udGFpbmVyLCB2aWV3cG9ydCk7XG4gICAgdGhpcy5fY2FwYWJpbGl0eS5wcm9taXNlLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgdGhpcy5fbGF5b3V0VGV4dFBhcmFtcyA9IG51bGw7XG4gICAgfSkuY2F0Y2goKCkgPT4ge30pO1xuICB9XG4gIGdldCBwcm9taXNlKCkge1xuICAgIHJldHVybiB0aGlzLl9jYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbiAgY2FuY2VsKCkge1xuICAgIHRoaXMuX2NhbmNlbGVkID0gdHJ1ZTtcbiAgICBpZiAodGhpcy5fcmVhZGVyKSB7XG4gICAgICB0aGlzLl9yZWFkZXIuY2FuY2VsKG5ldyBfdXRpbC5BYm9ydEV4Y2VwdGlvbihcIlRleHRMYXllciB0YXNrIGNhbmNlbGxlZC5cIikpLmNhdGNoKCgpID0+IHt9KTtcbiAgICAgIHRoaXMuX3JlYWRlciA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMuX2NhcGFiaWxpdHkucmVqZWN0KG5ldyBfdXRpbC5BYm9ydEV4Y2VwdGlvbihcIlRleHRMYXllciB0YXNrIGNhbmNlbGxlZC5cIikpO1xuICB9XG4gIF9wcm9jZXNzSXRlbXMoaXRlbXMsIHN0eWxlQ2FjaGUpIHtcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgaXRlbXMpIHtcbiAgICAgIGlmIChpdGVtLnN0ciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChpdGVtLnR5cGUgPT09IFwiYmVnaW5NYXJrZWRDb250ZW50UHJvcHNcIiB8fCBpdGVtLnR5cGUgPT09IFwiYmVnaW5NYXJrZWRDb250ZW50XCIpIHtcbiAgICAgICAgICBjb25zdCBwYXJlbnQgPSB0aGlzLl9jb250YWluZXI7XG4gICAgICAgICAgdGhpcy5fY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICAgICAgdGhpcy5fY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJtYXJrZWRDb250ZW50XCIpO1xuICAgICAgICAgIGlmIChpdGVtLmlkICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9jb250YWluZXIuc2V0QXR0cmlidXRlKFwiaWRcIiwgYCR7aXRlbS5pZH1gKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcGFyZW50LmFwcGVuZCh0aGlzLl9jb250YWluZXIpO1xuICAgICAgICB9IGVsc2UgaWYgKGl0ZW0udHlwZSA9PT0gXCJlbmRNYXJrZWRDb250ZW50XCIpIHtcbiAgICAgICAgICB0aGlzLl9jb250YWluZXIgPSB0aGlzLl9jb250YWluZXIucGFyZW50Tm9kZTtcbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3RleHRDb250ZW50SXRlbXNTdHIucHVzaChpdGVtLnN0cik7XG4gICAgICBhcHBlbmRUZXh0KHRoaXMsIGl0ZW0sIHN0eWxlQ2FjaGUpO1xuICAgIH1cbiAgfVxuICBfbGF5b3V0VGV4dCh0ZXh0RGl2KSB7XG4gICAgY29uc3QgdGV4dERpdlByb3BlcnRpZXMgPSB0aGlzLl9sYXlvdXRUZXh0UGFyYW1zLnByb3BlcnRpZXMgPSB0aGlzLl90ZXh0RGl2UHJvcGVydGllcy5nZXQodGV4dERpdik7XG4gICAgdGhpcy5fbGF5b3V0VGV4dFBhcmFtcy5kaXYgPSB0ZXh0RGl2O1xuICAgIGxheW91dCh0aGlzLl9sYXlvdXRUZXh0UGFyYW1zKTtcbiAgICBpZiAodGV4dERpdlByb3BlcnRpZXMuaGFzVGV4dCkge1xuICAgICAgdGhpcy5fY29udGFpbmVyLmFwcGVuZCh0ZXh0RGl2KTtcbiAgICB9XG4gICAgaWYgKHRleHREaXZQcm9wZXJ0aWVzLmhhc0VPTCkge1xuICAgICAgY29uc3QgYnIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnJcIik7XG4gICAgICBici5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwicHJlc2VudGF0aW9uXCIpO1xuICAgICAgdGhpcy5fY29udGFpbmVyLmFwcGVuZChicik7XG4gICAgfVxuICB9XG4gIF9yZW5kZXIoKSB7XG4gICAgY29uc3QgY2FwYWJpbGl0eSA9IG5ldyBfdXRpbC5Qcm9taXNlQ2FwYWJpbGl0eSgpO1xuICAgIGxldCBzdHlsZUNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBpZiAodGhpcy5faXNSZWFkYWJsZVN0cmVhbSkge1xuICAgICAgY29uc3QgcHVtcCA9ICgpID0+IHtcbiAgICAgICAgdGhpcy5fcmVhZGVyLnJlYWQoKS50aGVuKCh7XG4gICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgZG9uZVxuICAgICAgICB9KSA9PiB7XG4gICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgIGNhcGFiaWxpdHkucmVzb2x2ZSgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBPYmplY3QuYXNzaWduKHN0eWxlQ2FjaGUsIHZhbHVlLnN0eWxlcyk7XG4gICAgICAgICAgdGhpcy5fcHJvY2Vzc0l0ZW1zKHZhbHVlLml0ZW1zLCBzdHlsZUNhY2hlKTtcbiAgICAgICAgICBwdW1wKCk7XG4gICAgICAgIH0sIGNhcGFiaWxpdHkucmVqZWN0KTtcbiAgICAgIH07XG4gICAgICB0aGlzLl9yZWFkZXIgPSB0aGlzLl90ZXh0Q29udGVudFNvdXJjZS5nZXRSZWFkZXIoKTtcbiAgICAgIHB1bXAoKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX3RleHRDb250ZW50U291cmNlKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGl0ZW1zLFxuICAgICAgICBzdHlsZXNcbiAgICAgIH0gPSB0aGlzLl90ZXh0Q29udGVudFNvdXJjZTtcbiAgICAgIHRoaXMuX3Byb2Nlc3NJdGVtcyhpdGVtcywgc3R5bGVzKTtcbiAgICAgIGNhcGFiaWxpdHkucmVzb2x2ZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIFwidGV4dENvbnRlbnRTb3VyY2VcIiBwYXJhbWV0ZXIgc3BlY2lmaWVkLicpO1xuICAgIH1cbiAgICBjYXBhYmlsaXR5LnByb21pc2UudGhlbigoKSA9PiB7XG4gICAgICBzdHlsZUNhY2hlID0gbnVsbDtcbiAgICAgIHJlbmRlcih0aGlzKTtcbiAgICB9LCB0aGlzLl9jYXBhYmlsaXR5LnJlamVjdCk7XG4gIH1cbn1cbmV4cG9ydHMuVGV4dExheWVyUmVuZGVyVGFzayA9IFRleHRMYXllclJlbmRlclRhc2s7XG5mdW5jdGlvbiByZW5kZXJUZXh0TGF5ZXIocGFyYW1zKSB7XG4gIGlmICghcGFyYW1zLnRleHRDb250ZW50U291cmNlICYmIChwYXJhbXMudGV4dENvbnRlbnQgfHwgcGFyYW1zLnRleHRDb250ZW50U3RyZWFtKSkge1xuICAgICgwLCBfZGlzcGxheV91dGlscy5kZXByZWNhdGVkKShcIlRoZSBUZXh0TGF5ZXJSZW5kZXIgYHRleHRDb250ZW50YC9gdGV4dENvbnRlbnRTdHJlYW1gIHBhcmFtZXRlcnMgXCIgKyBcIndpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgZnV0dXJlLCBwbGVhc2UgdXNlIGB0ZXh0Q29udGVudFNvdXJjZWAgaW5zdGVhZC5cIik7XG4gICAgcGFyYW1zLnRleHRDb250ZW50U291cmNlID0gcGFyYW1zLnRleHRDb250ZW50IHx8IHBhcmFtcy50ZXh0Q29udGVudFN0cmVhbTtcbiAgfVxuICBjb25zdCB7XG4gICAgY29udGFpbmVyLFxuICAgIHZpZXdwb3J0XG4gIH0gPSBwYXJhbXM7XG4gIGNvbnN0IHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShjb250YWluZXIpO1xuICBjb25zdCB2aXNpYmlsaXR5ID0gc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShcInZpc2liaWxpdHlcIik7XG4gIGNvbnN0IHNjYWxlRmFjdG9yID0gcGFyc2VGbG9hdChzdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKFwiLS1zY2FsZS1mYWN0b3JcIikpO1xuICBpZiAodmlzaWJpbGl0eSA9PT0gXCJ2aXNpYmxlXCIgJiYgKCFzY2FsZUZhY3RvciB8fCBNYXRoLmFicyhzY2FsZUZhY3RvciAtIHZpZXdwb3J0LnNjYWxlKSA+IDFlLTUpKSB7XG4gICAgY29uc29sZS5lcnJvcihcIlRoZSBgLS1zY2FsZS1mYWN0b3JgIENTUy12YXJpYWJsZSBtdXN0IGJlIHNldCwgXCIgKyBcInRvIHRoZSBzYW1lIHZhbHVlIGFzIGB2aWV3cG9ydC5zY2FsZWAsIFwiICsgXCJlaXRoZXIgb24gdGhlIGBjb250YWluZXJgLWVsZW1lbnQgaXRzZWxmIG9yIGhpZ2hlciB1cCBpbiB0aGUgRE9NLlwiKTtcbiAgfVxuICBjb25zdCB0YXNrID0gbmV3IFRleHRMYXllclJlbmRlclRhc2socGFyYW1zKTtcbiAgdGFzay5fcmVuZGVyKCk7XG4gIHJldHVybiB0YXNrO1xufVxuZnVuY3Rpb24gdXBkYXRlVGV4dExheWVyKHtcbiAgY29udGFpbmVyLFxuICB2aWV3cG9ydCxcbiAgdGV4dERpdnMsXG4gIHRleHREaXZQcm9wZXJ0aWVzLFxuICBpc09mZnNjcmVlbkNhbnZhc1N1cHBvcnRlZCxcbiAgbXVzdFJvdGF0ZSA9IHRydWUsXG4gIG11c3RSZXNjYWxlID0gdHJ1ZVxufSkge1xuICBpZiAobXVzdFJvdGF0ZSkge1xuICAgICgwLCBfZGlzcGxheV91dGlscy5zZXRMYXllckRpbWVuc2lvbnMpKGNvbnRhaW5lciwge1xuICAgICAgcm90YXRpb246IHZpZXdwb3J0LnJvdGF0aW9uXG4gICAgfSk7XG4gIH1cbiAgaWYgKG11c3RSZXNjYWxlKSB7XG4gICAgY29uc3QgY3R4ID0gZ2V0Q3R4KDAsIGlzT2Zmc2NyZWVuQ2FudmFzU3VwcG9ydGVkKTtcbiAgICBjb25zdCBzY2FsZSA9IHZpZXdwb3J0LnNjYWxlICogKGdsb2JhbFRoaXMuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxKTtcbiAgICBjb25zdCBwYXJhbXMgPSB7XG4gICAgICBwcmV2Rm9udFNpemU6IG51bGwsXG4gICAgICBwcmV2Rm9udEZhbWlseTogbnVsbCxcbiAgICAgIGRpdjogbnVsbCxcbiAgICAgIHNjYWxlLFxuICAgICAgcHJvcGVydGllczogbnVsbCxcbiAgICAgIGN0eFxuICAgIH07XG4gICAgZm9yIChjb25zdCBkaXYgb2YgdGV4dERpdnMpIHtcbiAgICAgIHBhcmFtcy5wcm9wZXJ0aWVzID0gdGV4dERpdlByb3BlcnRpZXMuZ2V0KGRpdik7XG4gICAgICBwYXJhbXMuZGl2ID0gZGl2O1xuICAgICAgbGF5b3V0KHBhcmFtcyk7XG4gICAgfVxuICB9XG59XG5cbi8qKiovIH0pLFxuLyogMjcgKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pID0+IHtcblxuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcbmV4cG9ydHMuQW5ub3RhdGlvbkVkaXRvckxheWVyID0gdm9pZCAwO1xudmFyIF91dGlsID0gX193X3BkZmpzX3JlcXVpcmVfXygxKTtcbnZhciBfZWRpdG9yID0gX193X3BkZmpzX3JlcXVpcmVfXyg0KTtcbnZhciBfZnJlZXRleHQgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDI4KTtcbnZhciBfaW5rID0gX193X3BkZmpzX3JlcXVpcmVfXygzMyk7XG52YXIgX2Rpc3BsYXlfdXRpbHMgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDYpO1xudmFyIF9zdGFtcCA9IF9fd19wZGZqc19yZXF1aXJlX18oMzQpO1xuY2xhc3MgQW5ub3RhdGlvbkVkaXRvckxheWVyIHtcbiAgI2FjY2Vzc2liaWxpdHlNYW5hZ2VyO1xuICAjYWxsb3dDbGljayA9IGZhbHNlO1xuICAjYW5ub3RhdGlvbkxheWVyID0gbnVsbDtcbiAgI2JvdW5kUG9pbnRlcnVwID0gdGhpcy5wb2ludGVydXAuYmluZCh0aGlzKTtcbiAgI2JvdW5kUG9pbnRlcmRvd24gPSB0aGlzLnBvaW50ZXJkb3duLmJpbmQodGhpcyk7XG4gICNlZGl0b3JzID0gbmV3IE1hcCgpO1xuICAjaGFkUG9pbnRlckRvd24gPSBmYWxzZTtcbiAgI2lzQ2xlYW5pbmdVcCA9IGZhbHNlO1xuICAjaXNEaXNhYmxpbmcgPSBmYWxzZTtcbiAgI3VpTWFuYWdlcjtcbiAgc3RhdGljIF9pbml0aWFsaXplZCA9IGZhbHNlO1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgdWlNYW5hZ2VyLFxuICAgIHBhZ2VJbmRleCxcbiAgICBkaXYsXG4gICAgYWNjZXNzaWJpbGl0eU1hbmFnZXIsXG4gICAgYW5ub3RhdGlvbkxheWVyLFxuICAgIHZpZXdwb3J0LFxuICAgIGwxMG5cbiAgfSkge1xuICAgIGNvbnN0IGVkaXRvclR5cGVzID0gW19mcmVldGV4dC5GcmVlVGV4dEVkaXRvciwgX2luay5JbmtFZGl0b3IsIF9zdGFtcC5TdGFtcEVkaXRvcl07XG4gICAgaWYgKCFBbm5vdGF0aW9uRWRpdG9yTGF5ZXIuX2luaXRpYWxpemVkKSB7XG4gICAgICBBbm5vdGF0aW9uRWRpdG9yTGF5ZXIuX2luaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgIGZvciAoY29uc3QgZWRpdG9yVHlwZSBvZiBlZGl0b3JUeXBlcykge1xuICAgICAgICBlZGl0b3JUeXBlLmluaXRpYWxpemUobDEwbik7XG4gICAgICB9XG4gICAgfVxuICAgIHVpTWFuYWdlci5yZWdpc3RlckVkaXRvclR5cGVzKGVkaXRvclR5cGVzKTtcbiAgICB0aGlzLiN1aU1hbmFnZXIgPSB1aU1hbmFnZXI7XG4gICAgdGhpcy5wYWdlSW5kZXggPSBwYWdlSW5kZXg7XG4gICAgdGhpcy5kaXYgPSBkaXY7XG4gICAgdGhpcy4jYWNjZXNzaWJpbGl0eU1hbmFnZXIgPSBhY2Nlc3NpYmlsaXR5TWFuYWdlcjtcbiAgICB0aGlzLiNhbm5vdGF0aW9uTGF5ZXIgPSBhbm5vdGF0aW9uTGF5ZXI7XG4gICAgdGhpcy52aWV3cG9ydCA9IHZpZXdwb3J0O1xuICAgIHRoaXMuI3VpTWFuYWdlci5hZGRMYXllcih0aGlzKTtcbiAgfVxuICBnZXQgaXNFbXB0eSgpIHtcbiAgICByZXR1cm4gdGhpcy4jZWRpdG9ycy5zaXplID09PSAwO1xuICB9XG4gIHVwZGF0ZVRvb2xiYXIobW9kZSkge1xuICAgIHRoaXMuI3VpTWFuYWdlci51cGRhdGVUb29sYmFyKG1vZGUpO1xuICB9XG4gIHVwZGF0ZU1vZGUobW9kZSA9IHRoaXMuI3VpTWFuYWdlci5nZXRNb2RlKCkpIHtcbiAgICB0aGlzLiNjbGVhbnVwKCk7XG4gICAgaWYgKG1vZGUgPT09IF91dGlsLkFubm90YXRpb25FZGl0b3JUeXBlLklOSykge1xuICAgICAgdGhpcy5hZGRJbmtFZGl0b3JJZk5lZWRlZChmYWxzZSk7XG4gICAgICB0aGlzLmRpc2FibGVDbGljaygpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmVuYWJsZUNsaWNrKCk7XG4gICAgfVxuICAgIGlmIChtb2RlICE9PSBfdXRpbC5Bbm5vdGF0aW9uRWRpdG9yVHlwZS5OT05FKSB7XG4gICAgICB0aGlzLmRpdi5jbGFzc0xpc3QudG9nZ2xlKFwiZnJlZVRleHRFZGl0aW5nXCIsIG1vZGUgPT09IF91dGlsLkFubm90YXRpb25FZGl0b3JUeXBlLkZSRUVURVhUKTtcbiAgICAgIHRoaXMuZGl2LmNsYXNzTGlzdC50b2dnbGUoXCJpbmtFZGl0aW5nXCIsIG1vZGUgPT09IF91dGlsLkFubm90YXRpb25FZGl0b3JUeXBlLklOSyk7XG4gICAgICB0aGlzLmRpdi5jbGFzc0xpc3QudG9nZ2xlKFwic3RhbXBFZGl0aW5nXCIsIG1vZGUgPT09IF91dGlsLkFubm90YXRpb25FZGl0b3JUeXBlLlNUQU1QKTtcbiAgICAgIHRoaXMuZGl2LmhpZGRlbiA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICBhZGRJbmtFZGl0b3JJZk5lZWRlZChpc0NvbW1pdHRpbmcpIHtcbiAgICBpZiAoIWlzQ29tbWl0dGluZyAmJiB0aGlzLiN1aU1hbmFnZXIuZ2V0TW9kZSgpICE9PSBfdXRpbC5Bbm5vdGF0aW9uRWRpdG9yVHlwZS5JTkspIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFpc0NvbW1pdHRpbmcpIHtcbiAgICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIHRoaXMuI2VkaXRvcnMudmFsdWVzKCkpIHtcbiAgICAgICAgaWYgKGVkaXRvci5pc0VtcHR5KCkpIHtcbiAgICAgICAgICBlZGl0b3Iuc2V0SW5CYWNrZ3JvdW5kKCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGVkaXRvciA9IHRoaXMuI2NyZWF0ZUFuZEFkZE5ld0VkaXRvcih7XG4gICAgICBvZmZzZXRYOiAwLFxuICAgICAgb2Zmc2V0WTogMFxuICAgIH0sIGZhbHNlKTtcbiAgICBlZGl0b3Iuc2V0SW5CYWNrZ3JvdW5kKCk7XG4gIH1cbiAgc2V0RWRpdGluZ1N0YXRlKGlzRWRpdGluZykge1xuICAgIHRoaXMuI3VpTWFuYWdlci5zZXRFZGl0aW5nU3RhdGUoaXNFZGl0aW5nKTtcbiAgfVxuICBhZGRDb21tYW5kcyhwYXJhbXMpIHtcbiAgICB0aGlzLiN1aU1hbmFnZXIuYWRkQ29tbWFuZHMocGFyYW1zKTtcbiAgfVxuICBlbmFibGUoKSB7XG4gICAgdGhpcy5kaXYuc3R5bGUucG9pbnRlckV2ZW50cyA9IFwiYXV0b1wiO1xuICAgIGNvbnN0IGFubm90YXRpb25FbGVtZW50SWRzID0gbmV3IFNldCgpO1xuICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIHRoaXMuI2VkaXRvcnMudmFsdWVzKCkpIHtcbiAgICAgIGVkaXRvci5lbmFibGVFZGl0aW5nKCk7XG4gICAgICBpZiAoZWRpdG9yLmFubm90YXRpb25FbGVtZW50SWQpIHtcbiAgICAgICAgYW5ub3RhdGlvbkVsZW1lbnRJZHMuYWRkKGVkaXRvci5hbm5vdGF0aW9uRWxlbWVudElkKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCF0aGlzLiNhbm5vdGF0aW9uTGF5ZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZWRpdGFibGVzID0gdGhpcy4jYW5ub3RhdGlvbkxheWVyLmdldEVkaXRhYmxlQW5ub3RhdGlvbnMoKTtcbiAgICBmb3IgKGNvbnN0IGVkaXRhYmxlIG9mIGVkaXRhYmxlcykge1xuICAgICAgZWRpdGFibGUuaGlkZSgpO1xuICAgICAgaWYgKHRoaXMuI3VpTWFuYWdlci5pc0RlbGV0ZWRBbm5vdGF0aW9uRWxlbWVudChlZGl0YWJsZS5kYXRhLmlkKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChhbm5vdGF0aW9uRWxlbWVudElkcy5oYXMoZWRpdGFibGUuZGF0YS5pZCkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBlZGl0b3IgPSB0aGlzLmRlc2VyaWFsaXplKGVkaXRhYmxlKTtcbiAgICAgIGlmICghZWRpdG9yKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdGhpcy5hZGRPclJlYnVpbGQoZWRpdG9yKTtcbiAgICAgIGVkaXRvci5lbmFibGVFZGl0aW5nKCk7XG4gICAgfVxuICB9XG4gIGRpc2FibGUoKSB7XG4gICAgdGhpcy4jaXNEaXNhYmxpbmcgPSB0cnVlO1xuICAgIHRoaXMuZGl2LnN0eWxlLnBvaW50ZXJFdmVudHMgPSBcIm5vbmVcIjtcbiAgICBjb25zdCBoaWRkZW5Bbm5vdGF0aW9uSWRzID0gbmV3IFNldCgpO1xuICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIHRoaXMuI2VkaXRvcnMudmFsdWVzKCkpIHtcbiAgICAgIGVkaXRvci5kaXNhYmxlRWRpdGluZygpO1xuICAgICAgaWYgKCFlZGl0b3IuYW5ub3RhdGlvbkVsZW1lbnRJZCB8fCBlZGl0b3Iuc2VyaWFsaXplKCkgIT09IG51bGwpIHtcbiAgICAgICAgaGlkZGVuQW5ub3RhdGlvbklkcy5hZGQoZWRpdG9yLmFubm90YXRpb25FbGVtZW50SWQpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZ2V0RWRpdGFibGVBbm5vdGF0aW9uKGVkaXRvci5hbm5vdGF0aW9uRWxlbWVudElkKT8uc2hvdygpO1xuICAgICAgZWRpdG9yLnJlbW92ZSgpO1xuICAgIH1cbiAgICBpZiAodGhpcy4jYW5ub3RhdGlvbkxheWVyKSB7XG4gICAgICBjb25zdCBlZGl0YWJsZXMgPSB0aGlzLiNhbm5vdGF0aW9uTGF5ZXIuZ2V0RWRpdGFibGVBbm5vdGF0aW9ucygpO1xuICAgICAgZm9yIChjb25zdCBlZGl0YWJsZSBvZiBlZGl0YWJsZXMpIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGlkXG4gICAgICAgIH0gPSBlZGl0YWJsZS5kYXRhO1xuICAgICAgICBpZiAoaGlkZGVuQW5ub3RhdGlvbklkcy5oYXMoaWQpIHx8IHRoaXMuI3VpTWFuYWdlci5pc0RlbGV0ZWRBbm5vdGF0aW9uRWxlbWVudChpZCkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBlZGl0YWJsZS5zaG93KCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuI2NsZWFudXAoKTtcbiAgICBpZiAodGhpcy5pc0VtcHR5KSB7XG4gICAgICB0aGlzLmRpdi5oaWRkZW4gPSB0cnVlO1xuICAgIH1cbiAgICB0aGlzLiNpc0Rpc2FibGluZyA9IGZhbHNlO1xuICB9XG4gIGdldEVkaXRhYmxlQW5ub3RhdGlvbihpZCkge1xuICAgIHJldHVybiB0aGlzLiNhbm5vdGF0aW9uTGF5ZXI/LmdldEVkaXRhYmxlQW5ub3RhdGlvbihpZCkgfHwgbnVsbDtcbiAgfVxuICBzZXRBY3RpdmVFZGl0b3IoZWRpdG9yKSB7XG4gICAgY29uc3QgY3VycmVudEFjdGl2ZSA9IHRoaXMuI3VpTWFuYWdlci5nZXRBY3RpdmUoKTtcbiAgICBpZiAoY3VycmVudEFjdGl2ZSA9PT0gZWRpdG9yKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI3VpTWFuYWdlci5zZXRBY3RpdmVFZGl0b3IoZWRpdG9yKTtcbiAgfVxuICBlbmFibGVDbGljaygpIHtcbiAgICB0aGlzLmRpdi5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcmRvd25cIiwgdGhpcy4jYm91bmRQb2ludGVyZG93bik7XG4gICAgdGhpcy5kaXYuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJ1cFwiLCB0aGlzLiNib3VuZFBvaW50ZXJ1cCk7XG4gIH1cbiAgZGlzYWJsZUNsaWNrKCkge1xuICAgIHRoaXMuZGl2LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJwb2ludGVyZG93blwiLCB0aGlzLiNib3VuZFBvaW50ZXJkb3duKTtcbiAgICB0aGlzLmRpdi5yZW1vdmVFdmVudExpc3RlbmVyKFwicG9pbnRlcnVwXCIsIHRoaXMuI2JvdW5kUG9pbnRlcnVwKTtcbiAgfVxuICBhdHRhY2goZWRpdG9yKSB7XG4gICAgdGhpcy4jZWRpdG9ycy5zZXQoZWRpdG9yLmlkLCBlZGl0b3IpO1xuICAgIGNvbnN0IHtcbiAgICAgIGFubm90YXRpb25FbGVtZW50SWRcbiAgICB9ID0gZWRpdG9yO1xuICAgIGlmIChhbm5vdGF0aW9uRWxlbWVudElkICYmIHRoaXMuI3VpTWFuYWdlci5pc0RlbGV0ZWRBbm5vdGF0aW9uRWxlbWVudChhbm5vdGF0aW9uRWxlbWVudElkKSkge1xuICAgICAgdGhpcy4jdWlNYW5hZ2VyLnJlbW92ZURlbGV0ZWRBbm5vdGF0aW9uRWxlbWVudChlZGl0b3IpO1xuICAgIH1cbiAgfVxuICBkZXRhY2goZWRpdG9yKSB7XG4gICAgdGhpcy4jZWRpdG9ycy5kZWxldGUoZWRpdG9yLmlkKTtcbiAgICB0aGlzLiNhY2Nlc3NpYmlsaXR5TWFuYWdlcj8ucmVtb3ZlUG9pbnRlckluVGV4dExheWVyKGVkaXRvci5jb250ZW50RGl2KTtcbiAgICBpZiAoIXRoaXMuI2lzRGlzYWJsaW5nICYmIGVkaXRvci5hbm5vdGF0aW9uRWxlbWVudElkKSB7XG4gICAgICB0aGlzLiN1aU1hbmFnZXIuYWRkRGVsZXRlZEFubm90YXRpb25FbGVtZW50KGVkaXRvcik7XG4gICAgfVxuICB9XG4gIHJlbW92ZShlZGl0b3IpIHtcbiAgICB0aGlzLmRldGFjaChlZGl0b3IpO1xuICAgIHRoaXMuI3VpTWFuYWdlci5yZW1vdmVFZGl0b3IoZWRpdG9yKTtcbiAgICBpZiAoZWRpdG9yLmRpdi5jb250YWlucyhkb2N1bWVudC5hY3RpdmVFbGVtZW50KSkge1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRoaXMuI3VpTWFuYWdlci5mb2N1c01haW5Db250YWluZXIoKTtcbiAgICAgIH0sIDApO1xuICAgIH1cbiAgICBlZGl0b3IuZGl2LnJlbW92ZSgpO1xuICAgIGVkaXRvci5pc0F0dGFjaGVkVG9ET00gPSBmYWxzZTtcbiAgICBpZiAoIXRoaXMuI2lzQ2xlYW5pbmdVcCkge1xuICAgICAgdGhpcy5hZGRJbmtFZGl0b3JJZk5lZWRlZChmYWxzZSk7XG4gICAgfVxuICB9XG4gIGNoYW5nZVBhcmVudChlZGl0b3IpIHtcbiAgICBpZiAoZWRpdG9yLnBhcmVudCA9PT0gdGhpcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZWRpdG9yLmFubm90YXRpb25FbGVtZW50SWQpIHtcbiAgICAgIHRoaXMuI3VpTWFuYWdlci5hZGREZWxldGVkQW5ub3RhdGlvbkVsZW1lbnQoZWRpdG9yLmFubm90YXRpb25FbGVtZW50SWQpO1xuICAgICAgX2VkaXRvci5Bbm5vdGF0aW9uRWRpdG9yLmRlbGV0ZUFubm90YXRpb25FbGVtZW50KGVkaXRvcik7XG4gICAgICBlZGl0b3IuYW5ub3RhdGlvbkVsZW1lbnRJZCA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMuYXR0YWNoKGVkaXRvcik7XG4gICAgZWRpdG9yLnBhcmVudD8uZGV0YWNoKGVkaXRvcik7XG4gICAgZWRpdG9yLnNldFBhcmVudCh0aGlzKTtcbiAgICBpZiAoZWRpdG9yLmRpdiAmJiBlZGl0b3IuaXNBdHRhY2hlZFRvRE9NKSB7XG4gICAgICBlZGl0b3IuZGl2LnJlbW92ZSgpO1xuICAgICAgdGhpcy5kaXYuYXBwZW5kKGVkaXRvci5kaXYpO1xuICAgIH1cbiAgfVxuICBhZGQoZWRpdG9yKSB7XG4gICAgdGhpcy5jaGFuZ2VQYXJlbnQoZWRpdG9yKTtcbiAgICB0aGlzLiN1aU1hbmFnZXIuYWRkRWRpdG9yKGVkaXRvcik7XG4gICAgdGhpcy5hdHRhY2goZWRpdG9yKTtcbiAgICBpZiAoIWVkaXRvci5pc0F0dGFjaGVkVG9ET00pIHtcbiAgICAgIGNvbnN0IGRpdiA9IGVkaXRvci5yZW5kZXIoKTtcbiAgICAgIHRoaXMuZGl2LmFwcGVuZChkaXYpO1xuICAgICAgZWRpdG9yLmlzQXR0YWNoZWRUb0RPTSA9IHRydWU7XG4gICAgfVxuICAgIGVkaXRvci5maXhBbmRTZXRQb3NpdGlvbigpO1xuICAgIGVkaXRvci5vbmNlQWRkZWQoKTtcbiAgICB0aGlzLiN1aU1hbmFnZXIuYWRkVG9Bbm5vdGF0aW9uU3RvcmFnZShlZGl0b3IpO1xuICB9XG4gIG1vdmVFZGl0b3JJbkRPTShlZGl0b3IpIHtcbiAgICBpZiAoIWVkaXRvci5pc0F0dGFjaGVkVG9ET00pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgYWN0aXZlRWxlbWVudFxuICAgIH0gPSBkb2N1bWVudDtcbiAgICBpZiAoZWRpdG9yLmRpdi5jb250YWlucyhhY3RpdmVFbGVtZW50KSkge1xuICAgICAgZWRpdG9yLl9mb2N1c0V2ZW50c0FsbG93ZWQgPSBmYWxzZTtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBpZiAoIWVkaXRvci5kaXYuY29udGFpbnMoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkpIHtcbiAgICAgICAgICBlZGl0b3IuZGl2LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c2luXCIsICgpID0+IHtcbiAgICAgICAgICAgIGVkaXRvci5fZm9jdXNFdmVudHNBbGxvd2VkID0gdHJ1ZTtcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICBvbmNlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYWN0aXZlRWxlbWVudC5mb2N1cygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVkaXRvci5fZm9jdXNFdmVudHNBbGxvd2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSwgMCk7XG4gICAgfVxuICAgIGVkaXRvci5fc3RydWN0VHJlZVBhcmVudElkID0gdGhpcy4jYWNjZXNzaWJpbGl0eU1hbmFnZXI/Lm1vdmVFbGVtZW50SW5ET00odGhpcy5kaXYsIGVkaXRvci5kaXYsIGVkaXRvci5jb250ZW50RGl2LCB0cnVlKTtcbiAgfVxuICBhZGRPclJlYnVpbGQoZWRpdG9yKSB7XG4gICAgaWYgKGVkaXRvci5uZWVkc1RvQmVSZWJ1aWx0KCkpIHtcbiAgICAgIGVkaXRvci5yZWJ1aWxkKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWRkKGVkaXRvcik7XG4gICAgfVxuICB9XG4gIGFkZFVuZG9hYmxlRWRpdG9yKGVkaXRvcikge1xuICAgIGNvbnN0IGNtZCA9ICgpID0+IGVkaXRvci5fdWlNYW5hZ2VyLnJlYnVpbGQoZWRpdG9yKTtcbiAgICBjb25zdCB1bmRvID0gKCkgPT4ge1xuICAgICAgZWRpdG9yLnJlbW92ZSgpO1xuICAgIH07XG4gICAgdGhpcy5hZGRDb21tYW5kcyh7XG4gICAgICBjbWQsXG4gICAgICB1bmRvLFxuICAgICAgbXVzdEV4ZWM6IGZhbHNlXG4gICAgfSk7XG4gIH1cbiAgZ2V0TmV4dElkKCkge1xuICAgIHJldHVybiB0aGlzLiN1aU1hbmFnZXIuZ2V0SWQoKTtcbiAgfVxuICAjY3JlYXRlTmV3RWRpdG9yKHBhcmFtcykge1xuICAgIHN3aXRjaCAodGhpcy4jdWlNYW5hZ2VyLmdldE1vZGUoKSkge1xuICAgICAgY2FzZSBfdXRpbC5Bbm5vdGF0aW9uRWRpdG9yVHlwZS5GUkVFVEVYVDpcbiAgICAgICAgcmV0dXJuIG5ldyBfZnJlZXRleHQuRnJlZVRleHRFZGl0b3IocGFyYW1zKTtcbiAgICAgIGNhc2UgX3V0aWwuQW5ub3RhdGlvbkVkaXRvclR5cGUuSU5LOlxuICAgICAgICByZXR1cm4gbmV3IF9pbmsuSW5rRWRpdG9yKHBhcmFtcyk7XG4gICAgICBjYXNlIF91dGlsLkFubm90YXRpb25FZGl0b3JUeXBlLlNUQU1QOlxuICAgICAgICByZXR1cm4gbmV3IF9zdGFtcC5TdGFtcEVkaXRvcihwYXJhbXMpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBwYXN0ZUVkaXRvcihtb2RlLCBwYXJhbXMpIHtcbiAgICB0aGlzLiN1aU1hbmFnZXIudXBkYXRlVG9vbGJhcihtb2RlKTtcbiAgICB0aGlzLiN1aU1hbmFnZXIudXBkYXRlTW9kZShtb2RlKTtcbiAgICBjb25zdCB7XG4gICAgICBvZmZzZXRYLFxuICAgICAgb2Zmc2V0WVxuICAgIH0gPSB0aGlzLiNnZXRDZW50ZXJQb2ludCgpO1xuICAgIGNvbnN0IGlkID0gdGhpcy5nZXROZXh0SWQoKTtcbiAgICBjb25zdCBlZGl0b3IgPSB0aGlzLiNjcmVhdGVOZXdFZGl0b3Ioe1xuICAgICAgcGFyZW50OiB0aGlzLFxuICAgICAgaWQsXG4gICAgICB4OiBvZmZzZXRYLFxuICAgICAgeTogb2Zmc2V0WSxcbiAgICAgIHVpTWFuYWdlcjogdGhpcy4jdWlNYW5hZ2VyLFxuICAgICAgaXNDZW50ZXJlZDogdHJ1ZSxcbiAgICAgIC4uLnBhcmFtc1xuICAgIH0pO1xuICAgIGlmIChlZGl0b3IpIHtcbiAgICAgIHRoaXMuYWRkKGVkaXRvcik7XG4gICAgfVxuICB9XG4gIGRlc2VyaWFsaXplKGRhdGEpIHtcbiAgICBzd2l0Y2ggKGRhdGEuYW5ub3RhdGlvblR5cGUgPz8gZGF0YS5hbm5vdGF0aW9uRWRpdG9yVHlwZSkge1xuICAgICAgY2FzZSBfdXRpbC5Bbm5vdGF0aW9uRWRpdG9yVHlwZS5GUkVFVEVYVDpcbiAgICAgICAgcmV0dXJuIF9mcmVldGV4dC5GcmVlVGV4dEVkaXRvci5kZXNlcmlhbGl6ZShkYXRhLCB0aGlzLCB0aGlzLiN1aU1hbmFnZXIpO1xuICAgICAgY2FzZSBfdXRpbC5Bbm5vdGF0aW9uRWRpdG9yVHlwZS5JTks6XG4gICAgICAgIHJldHVybiBfaW5rLklua0VkaXRvci5kZXNlcmlhbGl6ZShkYXRhLCB0aGlzLCB0aGlzLiN1aU1hbmFnZXIpO1xuICAgICAgY2FzZSBfdXRpbC5Bbm5vdGF0aW9uRWRpdG9yVHlwZS5TVEFNUDpcbiAgICAgICAgcmV0dXJuIF9zdGFtcC5TdGFtcEVkaXRvci5kZXNlcmlhbGl6ZShkYXRhLCB0aGlzLCB0aGlzLiN1aU1hbmFnZXIpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICAjY3JlYXRlQW5kQWRkTmV3RWRpdG9yKGV2ZW50LCBpc0NlbnRlcmVkKSB7XG4gICAgY29uc3QgaWQgPSB0aGlzLmdldE5leHRJZCgpO1xuICAgIGNvbnN0IGVkaXRvciA9IHRoaXMuI2NyZWF0ZU5ld0VkaXRvcih7XG4gICAgICBwYXJlbnQ6IHRoaXMsXG4gICAgICBpZCxcbiAgICAgIHg6IGV2ZW50Lm9mZnNldFgsXG4gICAgICB5OiBldmVudC5vZmZzZXRZLFxuICAgICAgdWlNYW5hZ2VyOiB0aGlzLiN1aU1hbmFnZXIsXG4gICAgICBpc0NlbnRlcmVkXG4gICAgfSk7XG4gICAgaWYgKGVkaXRvcikge1xuICAgICAgdGhpcy5hZGQoZWRpdG9yKTtcbiAgICB9XG4gICAgcmV0dXJuIGVkaXRvcjtcbiAgfVxuICAjZ2V0Q2VudGVyUG9pbnQoKSB7XG4gICAgY29uc3Qge1xuICAgICAgeCxcbiAgICAgIHksXG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodFxuICAgIH0gPSB0aGlzLmRpdi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBjb25zdCB0bFggPSBNYXRoLm1heCgwLCB4KTtcbiAgICBjb25zdCB0bFkgPSBNYXRoLm1heCgwLCB5KTtcbiAgICBjb25zdCBiclggPSBNYXRoLm1pbih3aW5kb3cuaW5uZXJXaWR0aCwgeCArIHdpZHRoKTtcbiAgICBjb25zdCBiclkgPSBNYXRoLm1pbih3aW5kb3cuaW5uZXJIZWlnaHQsIHkgKyBoZWlnaHQpO1xuICAgIGNvbnN0IGNlbnRlclggPSAodGxYICsgYnJYKSAvIDIgLSB4O1xuICAgIGNvbnN0IGNlbnRlclkgPSAodGxZICsgYnJZKSAvIDIgLSB5O1xuICAgIGNvbnN0IFtvZmZzZXRYLCBvZmZzZXRZXSA9IHRoaXMudmlld3BvcnQucm90YXRpb24gJSAxODAgPT09IDAgPyBbY2VudGVyWCwgY2VudGVyWV0gOiBbY2VudGVyWSwgY2VudGVyWF07XG4gICAgcmV0dXJuIHtcbiAgICAgIG9mZnNldFgsXG4gICAgICBvZmZzZXRZXG4gICAgfTtcbiAgfVxuICBhZGROZXdFZGl0b3IoKSB7XG4gICAgdGhpcy4jY3JlYXRlQW5kQWRkTmV3RWRpdG9yKHRoaXMuI2dldENlbnRlclBvaW50KCksIHRydWUpO1xuICB9XG4gIHNldFNlbGVjdGVkKGVkaXRvcikge1xuICAgIHRoaXMuI3VpTWFuYWdlci5zZXRTZWxlY3RlZChlZGl0b3IpO1xuICB9XG4gIHRvZ2dsZVNlbGVjdGVkKGVkaXRvcikge1xuICAgIHRoaXMuI3VpTWFuYWdlci50b2dnbGVTZWxlY3RlZChlZGl0b3IpO1xuICB9XG4gIGlzU2VsZWN0ZWQoZWRpdG9yKSB7XG4gICAgcmV0dXJuIHRoaXMuI3VpTWFuYWdlci5pc1NlbGVjdGVkKGVkaXRvcik7XG4gIH1cbiAgdW5zZWxlY3QoZWRpdG9yKSB7XG4gICAgdGhpcy4jdWlNYW5hZ2VyLnVuc2VsZWN0KGVkaXRvcik7XG4gIH1cbiAgcG9pbnRlcnVwKGV2ZW50KSB7XG4gICAgY29uc3Qge1xuICAgICAgaXNNYWNcbiAgICB9ID0gX3V0aWwuRmVhdHVyZVRlc3QucGxhdGZvcm07XG4gICAgaWYgKGV2ZW50LmJ1dHRvbiAhPT0gMCB8fCBldmVudC5jdHJsS2V5ICYmIGlzTWFjKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChldmVudC50YXJnZXQgIT09IHRoaXMuZGl2KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghdGhpcy4jaGFkUG9pbnRlckRvd24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jaGFkUG9pbnRlckRvd24gPSBmYWxzZTtcbiAgICBpZiAoIXRoaXMuI2FsbG93Q2xpY2spIHtcbiAgICAgIHRoaXMuI2FsbG93Q2xpY2sgPSB0cnVlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy4jdWlNYW5hZ2VyLmdldE1vZGUoKSA9PT0gX3V0aWwuQW5ub3RhdGlvbkVkaXRvclR5cGUuU1RBTVApIHtcbiAgICAgIHRoaXMuI3VpTWFuYWdlci51bnNlbGVjdEFsbCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNjcmVhdGVBbmRBZGROZXdFZGl0b3IoZXZlbnQsIGZhbHNlKTtcbiAgfVxuICBwb2ludGVyZG93bihldmVudCkge1xuICAgIGlmICh0aGlzLiNoYWRQb2ludGVyRG93bikge1xuICAgICAgdGhpcy4jaGFkUG9pbnRlckRvd24gPSBmYWxzZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgaXNNYWNcbiAgICB9ID0gX3V0aWwuRmVhdHVyZVRlc3QucGxhdGZvcm07XG4gICAgaWYgKGV2ZW50LmJ1dHRvbiAhPT0gMCB8fCBldmVudC5jdHJsS2V5ICYmIGlzTWFjKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChldmVudC50YXJnZXQgIT09IHRoaXMuZGl2KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2hhZFBvaW50ZXJEb3duID0gdHJ1ZTtcbiAgICBjb25zdCBlZGl0b3IgPSB0aGlzLiN1aU1hbmFnZXIuZ2V0QWN0aXZlKCk7XG4gICAgdGhpcy4jYWxsb3dDbGljayA9ICFlZGl0b3IgfHwgZWRpdG9yLmlzRW1wdHkoKTtcbiAgfVxuICBmaW5kTmV3UGFyZW50KGVkaXRvciwgeCwgeSkge1xuICAgIGNvbnN0IGxheWVyID0gdGhpcy4jdWlNYW5hZ2VyLmZpbmRQYXJlbnQoeCwgeSk7XG4gICAgaWYgKGxheWVyID09PSBudWxsIHx8IGxheWVyID09PSB0aGlzKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGxheWVyLmNoYW5nZVBhcmVudChlZGl0b3IpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgaWYgKHRoaXMuI3VpTWFuYWdlci5nZXRBY3RpdmUoKT8ucGFyZW50ID09PSB0aGlzKSB7XG4gICAgICB0aGlzLiN1aU1hbmFnZXIuY29tbWl0T3JSZW1vdmUoKTtcbiAgICAgIHRoaXMuI3VpTWFuYWdlci5zZXRBY3RpdmVFZGl0b3IobnVsbCk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIHRoaXMuI2VkaXRvcnMudmFsdWVzKCkpIHtcbiAgICAgIHRoaXMuI2FjY2Vzc2liaWxpdHlNYW5hZ2VyPy5yZW1vdmVQb2ludGVySW5UZXh0TGF5ZXIoZWRpdG9yLmNvbnRlbnREaXYpO1xuICAgICAgZWRpdG9yLnNldFBhcmVudChudWxsKTtcbiAgICAgIGVkaXRvci5pc0F0dGFjaGVkVG9ET00gPSBmYWxzZTtcbiAgICAgIGVkaXRvci5kaXYucmVtb3ZlKCk7XG4gICAgfVxuICAgIHRoaXMuZGl2ID0gbnVsbDtcbiAgICB0aGlzLiNlZGl0b3JzLmNsZWFyKCk7XG4gICAgdGhpcy4jdWlNYW5hZ2VyLnJlbW92ZUxheWVyKHRoaXMpO1xuICB9XG4gICNjbGVhbnVwKCkge1xuICAgIHRoaXMuI2lzQ2xlYW5pbmdVcCA9IHRydWU7XG4gICAgZm9yIChjb25zdCBlZGl0b3Igb2YgdGhpcy4jZWRpdG9ycy52YWx1ZXMoKSkge1xuICAgICAgaWYgKGVkaXRvci5pc0VtcHR5KCkpIHtcbiAgICAgICAgZWRpdG9yLnJlbW92ZSgpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLiNpc0NsZWFuaW5nVXAgPSBmYWxzZTtcbiAgfVxuICByZW5kZXIoe1xuICAgIHZpZXdwb3J0XG4gIH0pIHtcbiAgICB0aGlzLnZpZXdwb3J0ID0gdmlld3BvcnQ7XG4gICAgKDAsIF9kaXNwbGF5X3V0aWxzLnNldExheWVyRGltZW5zaW9ucykodGhpcy5kaXYsIHZpZXdwb3J0KTtcbiAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiB0aGlzLiN1aU1hbmFnZXIuZ2V0RWRpdG9ycyh0aGlzLnBhZ2VJbmRleCkpIHtcbiAgICAgIHRoaXMuYWRkKGVkaXRvcik7XG4gICAgfVxuICAgIHRoaXMudXBkYXRlTW9kZSgpO1xuICB9XG4gIHVwZGF0ZSh7XG4gICAgdmlld3BvcnRcbiAgfSkge1xuICAgIHRoaXMuI3VpTWFuYWdlci5jb21taXRPclJlbW92ZSgpO1xuICAgIHRoaXMudmlld3BvcnQgPSB2aWV3cG9ydDtcbiAgICAoMCwgX2Rpc3BsYXlfdXRpbHMuc2V0TGF5ZXJEaW1lbnNpb25zKSh0aGlzLmRpdiwge1xuICAgICAgcm90YXRpb246IHZpZXdwb3J0LnJvdGF0aW9uXG4gICAgfSk7XG4gICAgdGhpcy51cGRhdGVNb2RlKCk7XG4gIH1cbiAgZ2V0IHBhZ2VEaW1lbnNpb25zKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHBhZ2VXaWR0aCxcbiAgICAgIHBhZ2VIZWlnaHRcbiAgICB9ID0gdGhpcy52aWV3cG9ydC5yYXdEaW1zO1xuICAgIHJldHVybiBbcGFnZVdpZHRoLCBwYWdlSGVpZ2h0XTtcbiAgfVxufVxuZXhwb3J0cy5Bbm5vdGF0aW9uRWRpdG9yTGF5ZXIgPSBBbm5vdGF0aW9uRWRpdG9yTGF5ZXI7XG5cbi8qKiovIH0pLFxuLyogMjggKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pID0+IHtcblxuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcbmV4cG9ydHMuRnJlZVRleHRFZGl0b3IgPSB2b2lkIDA7XG52YXIgX3V0aWwgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEpO1xudmFyIF90b29scyA9IF9fd19wZGZqc19yZXF1aXJlX18oNSk7XG52YXIgX2VkaXRvciA9IF9fd19wZGZqc19yZXF1aXJlX18oNCk7XG52YXIgX2Fubm90YXRpb25fbGF5ZXIgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDI5KTtcbmNsYXNzIEZyZWVUZXh0RWRpdG9yIGV4dGVuZHMgX2VkaXRvci5Bbm5vdGF0aW9uRWRpdG9yIHtcbiAgI2JvdW5kRWRpdG9yRGl2Qmx1ciA9IHRoaXMuZWRpdG9yRGl2Qmx1ci5iaW5kKHRoaXMpO1xuICAjYm91bmRFZGl0b3JEaXZGb2N1cyA9IHRoaXMuZWRpdG9yRGl2Rm9jdXMuYmluZCh0aGlzKTtcbiAgI2JvdW5kRWRpdG9yRGl2SW5wdXQgPSB0aGlzLmVkaXRvckRpdklucHV0LmJpbmQodGhpcyk7XG4gICNib3VuZEVkaXRvckRpdktleWRvd24gPSB0aGlzLmVkaXRvckRpdktleWRvd24uYmluZCh0aGlzKTtcbiAgI2NvbG9yO1xuICAjY29udGVudCA9IFwiXCI7XG4gICNlZGl0b3JEaXZJZCA9IGAke3RoaXMuaWR9LWVkaXRvcmA7XG4gICNmb250U2l6ZTtcbiAgI2luaXRpYWxEYXRhID0gbnVsbDtcbiAgc3RhdGljIF9mcmVlVGV4dERlZmF1bHRDb250ZW50ID0gXCJcIjtcbiAgc3RhdGljIF9pbnRlcm5hbFBhZGRpbmcgPSAwO1xuICBzdGF0aWMgX2RlZmF1bHRDb2xvciA9IG51bGw7XG4gIHN0YXRpYyBfZGVmYXVsdEZvbnRTaXplID0gMTA7XG4gIHN0YXRpYyBnZXQgX2tleWJvYXJkTWFuYWdlcigpIHtcbiAgICBjb25zdCBwcm90byA9IEZyZWVUZXh0RWRpdG9yLnByb3RvdHlwZTtcbiAgICBjb25zdCBhcnJvd0NoZWNrZXIgPSBzZWxmID0+IHNlbGYuaXNFbXB0eSgpO1xuICAgIGNvbnN0IHNtYWxsID0gX3Rvb2xzLkFubm90YXRpb25FZGl0b3JVSU1hbmFnZXIuVFJBTlNMQVRFX1NNQUxMO1xuICAgIGNvbnN0IGJpZyA9IF90b29scy5Bbm5vdGF0aW9uRWRpdG9yVUlNYW5hZ2VyLlRSQU5TTEFURV9CSUc7XG4gICAgcmV0dXJuICgwLCBfdXRpbC5zaGFkb3cpKHRoaXMsIFwiX2tleWJvYXJkTWFuYWdlclwiLCBuZXcgX3Rvb2xzLktleWJvYXJkTWFuYWdlcihbW1tcImN0cmwrc1wiLCBcIm1hYyttZXRhK3NcIiwgXCJjdHJsK3BcIiwgXCJtYWMrbWV0YStwXCJdLCBwcm90by5jb21taXRPclJlbW92ZSwge1xuICAgICAgYnViYmxlczogdHJ1ZVxuICAgIH1dLCBbW1wiY3RybCtFbnRlclwiLCBcIm1hYyttZXRhK0VudGVyXCIsIFwiRXNjYXBlXCIsIFwibWFjK0VzY2FwZVwiXSwgcHJvdG8uY29tbWl0T3JSZW1vdmVdLCBbW1wiQXJyb3dMZWZ0XCIsIFwibWFjK0Fycm93TGVmdFwiXSwgcHJvdG8uX3RyYW5zbGF0ZUVtcHR5LCB7XG4gICAgICBhcmdzOiBbLXNtYWxsLCAwXSxcbiAgICAgIGNoZWNrZXI6IGFycm93Q2hlY2tlclxuICAgIH1dLCBbW1wiY3RybCtBcnJvd0xlZnRcIiwgXCJtYWMrc2hpZnQrQXJyb3dMZWZ0XCJdLCBwcm90by5fdHJhbnNsYXRlRW1wdHksIHtcbiAgICAgIGFyZ3M6IFstYmlnLCAwXSxcbiAgICAgIGNoZWNrZXI6IGFycm93Q2hlY2tlclxuICAgIH1dLCBbW1wiQXJyb3dSaWdodFwiLCBcIm1hYytBcnJvd1JpZ2h0XCJdLCBwcm90by5fdHJhbnNsYXRlRW1wdHksIHtcbiAgICAgIGFyZ3M6IFtzbWFsbCwgMF0sXG4gICAgICBjaGVja2VyOiBhcnJvd0NoZWNrZXJcbiAgICB9XSwgW1tcImN0cmwrQXJyb3dSaWdodFwiLCBcIm1hYytzaGlmdCtBcnJvd1JpZ2h0XCJdLCBwcm90by5fdHJhbnNsYXRlRW1wdHksIHtcbiAgICAgIGFyZ3M6IFtiaWcsIDBdLFxuICAgICAgY2hlY2tlcjogYXJyb3dDaGVja2VyXG4gICAgfV0sIFtbXCJBcnJvd1VwXCIsIFwibWFjK0Fycm93VXBcIl0sIHByb3RvLl90cmFuc2xhdGVFbXB0eSwge1xuICAgICAgYXJnczogWzAsIC1zbWFsbF0sXG4gICAgICBjaGVja2VyOiBhcnJvd0NoZWNrZXJcbiAgICB9XSwgW1tcImN0cmwrQXJyb3dVcFwiLCBcIm1hYytzaGlmdCtBcnJvd1VwXCJdLCBwcm90by5fdHJhbnNsYXRlRW1wdHksIHtcbiAgICAgIGFyZ3M6IFswLCAtYmlnXSxcbiAgICAgIGNoZWNrZXI6IGFycm93Q2hlY2tlclxuICAgIH1dLCBbW1wiQXJyb3dEb3duXCIsIFwibWFjK0Fycm93RG93blwiXSwgcHJvdG8uX3RyYW5zbGF0ZUVtcHR5LCB7XG4gICAgICBhcmdzOiBbMCwgc21hbGxdLFxuICAgICAgY2hlY2tlcjogYXJyb3dDaGVja2VyXG4gICAgfV0sIFtbXCJjdHJsK0Fycm93RG93blwiLCBcIm1hYytzaGlmdCtBcnJvd0Rvd25cIl0sIHByb3RvLl90cmFuc2xhdGVFbXB0eSwge1xuICAgICAgYXJnczogWzAsIGJpZ10sXG4gICAgICBjaGVja2VyOiBhcnJvd0NoZWNrZXJcbiAgICB9XV0pKTtcbiAgfVxuICBzdGF0aWMgX3R5cGUgPSBcImZyZWV0ZXh0XCI7XG4gIGNvbnN0cnVjdG9yKHBhcmFtcykge1xuICAgIHN1cGVyKHtcbiAgICAgIC4uLnBhcmFtcyxcbiAgICAgIG5hbWU6IFwiZnJlZVRleHRFZGl0b3JcIlxuICAgIH0pO1xuICAgIHRoaXMuI2NvbG9yID0gcGFyYW1zLmNvbG9yIHx8IEZyZWVUZXh0RWRpdG9yLl9kZWZhdWx0Q29sb3IgfHwgX2VkaXRvci5Bbm5vdGF0aW9uRWRpdG9yLl9kZWZhdWx0TGluZUNvbG9yO1xuICAgIHRoaXMuI2ZvbnRTaXplID0gcGFyYW1zLmZvbnRTaXplIHx8IEZyZWVUZXh0RWRpdG9yLl9kZWZhdWx0Rm9udFNpemU7XG4gIH1cbiAgc3RhdGljIGluaXRpYWxpemUobDEwbikge1xuICAgIF9lZGl0b3IuQW5ub3RhdGlvbkVkaXRvci5pbml0aWFsaXplKGwxMG4sIHtcbiAgICAgIHN0cmluZ3M6IFtcImZyZWVfdGV4dDJfZGVmYXVsdF9jb250ZW50XCIsIFwiZWRpdG9yX2ZyZWVfdGV4dDJfYXJpYV9sYWJlbFwiXVxuICAgIH0pO1xuICAgIGNvbnN0IHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpO1xuICAgIHRoaXMuX2ludGVybmFsUGFkZGluZyA9IHBhcnNlRmxvYXQoc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShcIi0tZnJlZXRleHQtcGFkZGluZ1wiKSk7XG4gIH1cbiAgc3RhdGljIHVwZGF0ZURlZmF1bHRQYXJhbXModHlwZSwgdmFsdWUpIHtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgX3V0aWwuQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuRlJFRVRFWFRfU0laRTpcbiAgICAgICAgRnJlZVRleHRFZGl0b3IuX2RlZmF1bHRGb250U2l6ZSA9IHZhbHVlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgX3V0aWwuQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuRlJFRVRFWFRfQ09MT1I6XG4gICAgICAgIEZyZWVUZXh0RWRpdG9yLl9kZWZhdWx0Q29sb3IgPSB2YWx1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHVwZGF0ZVBhcmFtcyh0eXBlLCB2YWx1ZSkge1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSBfdXRpbC5Bbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5GUkVFVEVYVF9TSVpFOlxuICAgICAgICB0aGlzLiN1cGRhdGVGb250U2l6ZSh2YWx1ZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBfdXRpbC5Bbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5GUkVFVEVYVF9DT0xPUjpcbiAgICAgICAgdGhpcy4jdXBkYXRlQ29sb3IodmFsdWUpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgc3RhdGljIGdldCBkZWZhdWx0UHJvcGVydGllc1RvVXBkYXRlKCkge1xuICAgIHJldHVybiBbW191dGlsLkFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLkZSRUVURVhUX1NJWkUsIEZyZWVUZXh0RWRpdG9yLl9kZWZhdWx0Rm9udFNpemVdLCBbX3V0aWwuQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuRlJFRVRFWFRfQ09MT1IsIEZyZWVUZXh0RWRpdG9yLl9kZWZhdWx0Q29sb3IgfHwgX2VkaXRvci5Bbm5vdGF0aW9uRWRpdG9yLl9kZWZhdWx0TGluZUNvbG9yXV07XG4gIH1cbiAgZ2V0IHByb3BlcnRpZXNUb1VwZGF0ZSgpIHtcbiAgICByZXR1cm4gW1tfdXRpbC5Bbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5GUkVFVEVYVF9TSVpFLCB0aGlzLiNmb250U2l6ZV0sIFtfdXRpbC5Bbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5GUkVFVEVYVF9DT0xPUiwgdGhpcy4jY29sb3JdXTtcbiAgfVxuICAjdXBkYXRlRm9udFNpemUoZm9udFNpemUpIHtcbiAgICBjb25zdCBzZXRGb250c2l6ZSA9IHNpemUgPT4ge1xuICAgICAgdGhpcy5lZGl0b3JEaXYuc3R5bGUuZm9udFNpemUgPSBgY2FsYygke3NpemV9cHggKiB2YXIoLS1zY2FsZS1mYWN0b3IpKWA7XG4gICAgICB0aGlzLnRyYW5zbGF0ZSgwLCAtKHNpemUgLSB0aGlzLiNmb250U2l6ZSkgKiB0aGlzLnBhcmVudFNjYWxlKTtcbiAgICAgIHRoaXMuI2ZvbnRTaXplID0gc2l6ZTtcbiAgICAgIHRoaXMuI3NldEVkaXRvckRpbWVuc2lvbnMoKTtcbiAgICB9O1xuICAgIGNvbnN0IHNhdmVkRm9udHNpemUgPSB0aGlzLiNmb250U2l6ZTtcbiAgICB0aGlzLmFkZENvbW1hbmRzKHtcbiAgICAgIGNtZDogKCkgPT4ge1xuICAgICAgICBzZXRGb250c2l6ZShmb250U2l6ZSk7XG4gICAgICB9LFxuICAgICAgdW5kbzogKCkgPT4ge1xuICAgICAgICBzZXRGb250c2l6ZShzYXZlZEZvbnRzaXplKTtcbiAgICAgIH0sXG4gICAgICBtdXN0RXhlYzogdHJ1ZSxcbiAgICAgIHR5cGU6IF91dGlsLkFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLkZSRUVURVhUX1NJWkUsXG4gICAgICBvdmVyd3JpdGVJZlNhbWVUeXBlOiB0cnVlLFxuICAgICAga2VlcFVuZG86IHRydWVcbiAgICB9KTtcbiAgfVxuICAjdXBkYXRlQ29sb3IoY29sb3IpIHtcbiAgICBjb25zdCBzYXZlZENvbG9yID0gdGhpcy4jY29sb3I7XG4gICAgdGhpcy5hZGRDb21tYW5kcyh7XG4gICAgICBjbWQ6ICgpID0+IHtcbiAgICAgICAgdGhpcy4jY29sb3IgPSB0aGlzLmVkaXRvckRpdi5zdHlsZS5jb2xvciA9IGNvbG9yO1xuICAgICAgfSxcbiAgICAgIHVuZG86ICgpID0+IHtcbiAgICAgICAgdGhpcy4jY29sb3IgPSB0aGlzLmVkaXRvckRpdi5zdHlsZS5jb2xvciA9IHNhdmVkQ29sb3I7XG4gICAgICB9LFxuICAgICAgbXVzdEV4ZWM6IHRydWUsXG4gICAgICB0eXBlOiBfdXRpbC5Bbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5GUkVFVEVYVF9DT0xPUixcbiAgICAgIG92ZXJ3cml0ZUlmU2FtZVR5cGU6IHRydWUsXG4gICAgICBrZWVwVW5kbzogdHJ1ZVxuICAgIH0pO1xuICB9XG4gIF90cmFuc2xhdGVFbXB0eSh4LCB5KSB7XG4gICAgdGhpcy5fdWlNYW5hZ2VyLnRyYW5zbGF0ZVNlbGVjdGVkRWRpdG9ycyh4LCB5LCB0cnVlKTtcbiAgfVxuICBnZXRJbml0aWFsVHJhbnNsYXRpb24oKSB7XG4gICAgY29uc3Qgc2NhbGUgPSB0aGlzLnBhcmVudFNjYWxlO1xuICAgIHJldHVybiBbLUZyZWVUZXh0RWRpdG9yLl9pbnRlcm5hbFBhZGRpbmcgKiBzY2FsZSwgLShGcmVlVGV4dEVkaXRvci5faW50ZXJuYWxQYWRkaW5nICsgdGhpcy4jZm9udFNpemUpICogc2NhbGVdO1xuICB9XG4gIHJlYnVpbGQoKSB7XG4gICAgaWYgKCF0aGlzLnBhcmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzdXBlci5yZWJ1aWxkKCk7XG4gICAgaWYgKHRoaXMuZGl2ID09PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghdGhpcy5pc0F0dGFjaGVkVG9ET00pIHtcbiAgICAgIHRoaXMucGFyZW50LmFkZCh0aGlzKTtcbiAgICB9XG4gIH1cbiAgZW5hYmxlRWRpdE1vZGUoKSB7XG4gICAgaWYgKHRoaXMuaXNJbkVkaXRNb2RlKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5wYXJlbnQuc2V0RWRpdGluZ1N0YXRlKGZhbHNlKTtcbiAgICB0aGlzLnBhcmVudC51cGRhdGVUb29sYmFyKF91dGlsLkFubm90YXRpb25FZGl0b3JUeXBlLkZSRUVURVhUKTtcbiAgICBzdXBlci5lbmFibGVFZGl0TW9kZSgpO1xuICAgIHRoaXMub3ZlcmxheURpdi5jbGFzc0xpc3QucmVtb3ZlKFwiZW5hYmxlZFwiKTtcbiAgICB0aGlzLmVkaXRvckRpdi5jb250ZW50RWRpdGFibGUgPSB0cnVlO1xuICAgIHRoaXMuX2lzRHJhZ2dhYmxlID0gZmFsc2U7XG4gICAgdGhpcy5kaXYucmVtb3ZlQXR0cmlidXRlKFwiYXJpYS1hY3RpdmVkZXNjZW5kYW50XCIpO1xuICAgIHRoaXMuZWRpdG9yRGl2LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHRoaXMuI2JvdW5kRWRpdG9yRGl2S2V5ZG93bik7XG4gICAgdGhpcy5lZGl0b3JEaXYuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3VzXCIsIHRoaXMuI2JvdW5kRWRpdG9yRGl2Rm9jdXMpO1xuICAgIHRoaXMuZWRpdG9yRGl2LmFkZEV2ZW50TGlzdGVuZXIoXCJibHVyXCIsIHRoaXMuI2JvdW5kRWRpdG9yRGl2Qmx1cik7XG4gICAgdGhpcy5lZGl0b3JEaXYuYWRkRXZlbnRMaXN0ZW5lcihcImlucHV0XCIsIHRoaXMuI2JvdW5kRWRpdG9yRGl2SW5wdXQpO1xuICB9XG4gIGRpc2FibGVFZGl0TW9kZSgpIHtcbiAgICBpZiAoIXRoaXMuaXNJbkVkaXRNb2RlKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5wYXJlbnQuc2V0RWRpdGluZ1N0YXRlKHRydWUpO1xuICAgIHN1cGVyLmRpc2FibGVFZGl0TW9kZSgpO1xuICAgIHRoaXMub3ZlcmxheURpdi5jbGFzc0xpc3QuYWRkKFwiZW5hYmxlZFwiKTtcbiAgICB0aGlzLmVkaXRvckRpdi5jb250ZW50RWRpdGFibGUgPSBmYWxzZTtcbiAgICB0aGlzLmRpdi5zZXRBdHRyaWJ1dGUoXCJhcmlhLWFjdGl2ZWRlc2NlbmRhbnRcIiwgdGhpcy4jZWRpdG9yRGl2SWQpO1xuICAgIHRoaXMuX2lzRHJhZ2dhYmxlID0gdHJ1ZTtcbiAgICB0aGlzLmVkaXRvckRpdi5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCB0aGlzLiNib3VuZEVkaXRvckRpdktleWRvd24pO1xuICAgIHRoaXMuZWRpdG9yRGl2LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJmb2N1c1wiLCB0aGlzLiNib3VuZEVkaXRvckRpdkZvY3VzKTtcbiAgICB0aGlzLmVkaXRvckRpdi5yZW1vdmVFdmVudExpc3RlbmVyKFwiYmx1clwiLCB0aGlzLiNib3VuZEVkaXRvckRpdkJsdXIpO1xuICAgIHRoaXMuZWRpdG9yRGl2LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJpbnB1dFwiLCB0aGlzLiNib3VuZEVkaXRvckRpdklucHV0KTtcbiAgICB0aGlzLmRpdi5mb2N1cyh7XG4gICAgICBwcmV2ZW50U2Nyb2xsOiB0cnVlXG4gICAgfSk7XG4gICAgdGhpcy5pc0VkaXRpbmcgPSBmYWxzZTtcbiAgICB0aGlzLnBhcmVudC5kaXYuY2xhc3NMaXN0LmFkZChcImZyZWVUZXh0RWRpdGluZ1wiKTtcbiAgfVxuICBmb2N1c2luKGV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLl9mb2N1c0V2ZW50c0FsbG93ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3VwZXIuZm9jdXNpbihldmVudCk7XG4gICAgaWYgKGV2ZW50LnRhcmdldCAhPT0gdGhpcy5lZGl0b3JEaXYpIHtcbiAgICAgIHRoaXMuZWRpdG9yRGl2LmZvY3VzKCk7XG4gICAgfVxuICB9XG4gIG9uY2VBZGRlZCgpIHtcbiAgICBpZiAodGhpcy53aWR0aCkge1xuICAgICAgdGhpcy4jY2hlYXRJbml0aWFsUmVjdCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmVuYWJsZUVkaXRNb2RlKCk7XG4gICAgdGhpcy5lZGl0b3JEaXYuZm9jdXMoKTtcbiAgICBpZiAodGhpcy5faW5pdGlhbE9wdGlvbnM/LmlzQ2VudGVyZWQpIHtcbiAgICAgIHRoaXMuY2VudGVyKCk7XG4gICAgfVxuICAgIHRoaXMuX2luaXRpYWxPcHRpb25zID0gbnVsbDtcbiAgfVxuICBpc0VtcHR5KCkge1xuICAgIHJldHVybiAhdGhpcy5lZGl0b3JEaXYgfHwgdGhpcy5lZGl0b3JEaXYuaW5uZXJUZXh0LnRyaW0oKSA9PT0gXCJcIjtcbiAgfVxuICByZW1vdmUoKSB7XG4gICAgdGhpcy5pc0VkaXRpbmcgPSBmYWxzZTtcbiAgICBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgIHRoaXMucGFyZW50LnNldEVkaXRpbmdTdGF0ZSh0cnVlKTtcbiAgICAgIHRoaXMucGFyZW50LmRpdi5jbGFzc0xpc3QuYWRkKFwiZnJlZVRleHRFZGl0aW5nXCIpO1xuICAgIH1cbiAgICBzdXBlci5yZW1vdmUoKTtcbiAgfVxuICAjZXh0cmFjdFRleHQoKSB7XG4gICAgY29uc3QgZGl2cyA9IHRoaXMuZWRpdG9yRGl2LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiZGl2XCIpO1xuICAgIGlmIChkaXZzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoaXMuZWRpdG9yRGl2LmlubmVyVGV4dDtcbiAgICB9XG4gICAgY29uc3QgYnVmZmVyID0gW107XG4gICAgZm9yIChjb25zdCBkaXYgb2YgZGl2cykge1xuICAgICAgYnVmZmVyLnB1c2goZGl2LmlubmVyVGV4dC5yZXBsYWNlKC9cXHJcXG4/fFxcbi8sIFwiXCIpKTtcbiAgICB9XG4gICAgcmV0dXJuIGJ1ZmZlci5qb2luKFwiXFxuXCIpO1xuICB9XG4gICNzZXRFZGl0b3JEaW1lbnNpb25zKCkge1xuICAgIGNvbnN0IFtwYXJlbnRXaWR0aCwgcGFyZW50SGVpZ2h0XSA9IHRoaXMucGFyZW50RGltZW5zaW9ucztcbiAgICBsZXQgcmVjdDtcbiAgICBpZiAodGhpcy5pc0F0dGFjaGVkVG9ET00pIHtcbiAgICAgIHJlY3QgPSB0aGlzLmRpdi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qge1xuICAgICAgICBjdXJyZW50TGF5ZXIsXG4gICAgICAgIGRpdlxuICAgICAgfSA9IHRoaXM7XG4gICAgICBjb25zdCBzYXZlZERpc3BsYXkgPSBkaXYuc3R5bGUuZGlzcGxheTtcbiAgICAgIGRpdi5zdHlsZS5kaXNwbGF5ID0gXCJoaWRkZW5cIjtcbiAgICAgIGN1cnJlbnRMYXllci5kaXYuYXBwZW5kKHRoaXMuZGl2KTtcbiAgICAgIHJlY3QgPSBkaXYuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBkaXYucmVtb3ZlKCk7XG4gICAgICBkaXYuc3R5bGUuZGlzcGxheSA9IHNhdmVkRGlzcGxheTtcbiAgICB9XG4gICAgaWYgKHRoaXMucm90YXRpb24gJSAxODAgPT09IHRoaXMucGFyZW50Um90YXRpb24gJSAxODApIHtcbiAgICAgIHRoaXMud2lkdGggPSByZWN0LndpZHRoIC8gcGFyZW50V2lkdGg7XG4gICAgICB0aGlzLmhlaWdodCA9IHJlY3QuaGVpZ2h0IC8gcGFyZW50SGVpZ2h0O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLndpZHRoID0gcmVjdC5oZWlnaHQgLyBwYXJlbnRXaWR0aDtcbiAgICAgIHRoaXMuaGVpZ2h0ID0gcmVjdC53aWR0aCAvIHBhcmVudEhlaWdodDtcbiAgICB9XG4gICAgdGhpcy5maXhBbmRTZXRQb3NpdGlvbigpO1xuICB9XG4gIGNvbW1pdCgpIHtcbiAgICBpZiAoIXRoaXMuaXNJbkVkaXRNb2RlKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3VwZXIuY29tbWl0KCk7XG4gICAgdGhpcy5kaXNhYmxlRWRpdE1vZGUoKTtcbiAgICBjb25zdCBzYXZlZFRleHQgPSB0aGlzLiNjb250ZW50O1xuICAgIGNvbnN0IG5ld1RleHQgPSB0aGlzLiNjb250ZW50ID0gdGhpcy4jZXh0cmFjdFRleHQoKS50cmltRW5kKCk7XG4gICAgaWYgKHNhdmVkVGV4dCA9PT0gbmV3VGV4dCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzZXRUZXh0ID0gdGV4dCA9PiB7XG4gICAgICB0aGlzLiNjb250ZW50ID0gdGV4dDtcbiAgICAgIGlmICghdGV4dCkge1xuICAgICAgICB0aGlzLnJlbW92ZSgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLiNzZXRDb250ZW50KCk7XG4gICAgICB0aGlzLl91aU1hbmFnZXIucmVidWlsZCh0aGlzKTtcbiAgICAgIHRoaXMuI3NldEVkaXRvckRpbWVuc2lvbnMoKTtcbiAgICB9O1xuICAgIHRoaXMuYWRkQ29tbWFuZHMoe1xuICAgICAgY21kOiAoKSA9PiB7XG4gICAgICAgIHNldFRleHQobmV3VGV4dCk7XG4gICAgICB9LFxuICAgICAgdW5kbzogKCkgPT4ge1xuICAgICAgICBzZXRUZXh0KHNhdmVkVGV4dCk7XG4gICAgICB9LFxuICAgICAgbXVzdEV4ZWM6IGZhbHNlXG4gICAgfSk7XG4gICAgdGhpcy4jc2V0RWRpdG9yRGltZW5zaW9ucygpO1xuICB9XG4gIHNob3VsZEdldEtleWJvYXJkRXZlbnRzKCkge1xuICAgIHJldHVybiB0aGlzLmlzSW5FZGl0TW9kZSgpO1xuICB9XG4gIGVudGVySW5FZGl0TW9kZSgpIHtcbiAgICB0aGlzLmVuYWJsZUVkaXRNb2RlKCk7XG4gICAgdGhpcy5lZGl0b3JEaXYuZm9jdXMoKTtcbiAgfVxuICBkYmxjbGljayhldmVudCkge1xuICAgIHRoaXMuZW50ZXJJbkVkaXRNb2RlKCk7XG4gIH1cbiAga2V5ZG93bihldmVudCkge1xuICAgIGlmIChldmVudC50YXJnZXQgPT09IHRoaXMuZGl2ICYmIGV2ZW50LmtleSA9PT0gXCJFbnRlclwiKSB7XG4gICAgICB0aGlzLmVudGVySW5FZGl0TW9kZSgpO1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gIH1cbiAgZWRpdG9yRGl2S2V5ZG93bihldmVudCkge1xuICAgIEZyZWVUZXh0RWRpdG9yLl9rZXlib2FyZE1hbmFnZXIuZXhlYyh0aGlzLCBldmVudCk7XG4gIH1cbiAgZWRpdG9yRGl2Rm9jdXMoZXZlbnQpIHtcbiAgICB0aGlzLmlzRWRpdGluZyA9IHRydWU7XG4gIH1cbiAgZWRpdG9yRGl2Qmx1cihldmVudCkge1xuICAgIHRoaXMuaXNFZGl0aW5nID0gZmFsc2U7XG4gIH1cbiAgZWRpdG9yRGl2SW5wdXQoZXZlbnQpIHtcbiAgICB0aGlzLnBhcmVudC5kaXYuY2xhc3NMaXN0LnRvZ2dsZShcImZyZWVUZXh0RWRpdGluZ1wiLCB0aGlzLmlzRW1wdHkoKSk7XG4gIH1cbiAgZGlzYWJsZUVkaXRpbmcoKSB7XG4gICAgdGhpcy5lZGl0b3JEaXYuc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcImNvbW1lbnRcIik7XG4gICAgdGhpcy5lZGl0b3JEaXYucmVtb3ZlQXR0cmlidXRlKFwiYXJpYS1tdWx0aWxpbmVcIik7XG4gIH1cbiAgZW5hYmxlRWRpdGluZygpIHtcbiAgICB0aGlzLmVkaXRvckRpdi5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwidGV4dGJveFwiKTtcbiAgICB0aGlzLmVkaXRvckRpdi5zZXRBdHRyaWJ1dGUoXCJhcmlhLW11bHRpbGluZVwiLCB0cnVlKTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgaWYgKHRoaXMuZGl2KSB7XG4gICAgICByZXR1cm4gdGhpcy5kaXY7XG4gICAgfVxuICAgIGxldCBiYXNlWCwgYmFzZVk7XG4gICAgaWYgKHRoaXMud2lkdGgpIHtcbiAgICAgIGJhc2VYID0gdGhpcy54O1xuICAgICAgYmFzZVkgPSB0aGlzLnk7XG4gICAgfVxuICAgIHN1cGVyLnJlbmRlcigpO1xuICAgIHRoaXMuZWRpdG9yRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICB0aGlzLmVkaXRvckRpdi5jbGFzc05hbWUgPSBcImludGVybmFsXCI7XG4gICAgdGhpcy5lZGl0b3JEaXYuc2V0QXR0cmlidXRlKFwiaWRcIiwgdGhpcy4jZWRpdG9yRGl2SWQpO1xuICAgIHRoaXMuZW5hYmxlRWRpdGluZygpO1xuICAgIF9lZGl0b3IuQW5ub3RhdGlvbkVkaXRvci5fbDEwblByb21pc2UuZ2V0KFwiZWRpdG9yX2ZyZWVfdGV4dDJfYXJpYV9sYWJlbFwiKS50aGVuKG1zZyA9PiB0aGlzLmVkaXRvckRpdj8uc2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiLCBtc2cpKTtcbiAgICBfZWRpdG9yLkFubm90YXRpb25FZGl0b3IuX2wxMG5Qcm9taXNlLmdldChcImZyZWVfdGV4dDJfZGVmYXVsdF9jb250ZW50XCIpLnRoZW4obXNnID0+IHRoaXMuZWRpdG9yRGl2Py5zZXRBdHRyaWJ1dGUoXCJkZWZhdWx0LWNvbnRlbnRcIiwgbXNnKSk7XG4gICAgdGhpcy5lZGl0b3JEaXYuY29udGVudEVkaXRhYmxlID0gdHJ1ZTtcbiAgICBjb25zdCB7XG4gICAgICBzdHlsZVxuICAgIH0gPSB0aGlzLmVkaXRvckRpdjtcbiAgICBzdHlsZS5mb250U2l6ZSA9IGBjYWxjKCR7dGhpcy4jZm9udFNpemV9cHggKiB2YXIoLS1zY2FsZS1mYWN0b3IpKWA7XG4gICAgc3R5bGUuY29sb3IgPSB0aGlzLiNjb2xvcjtcbiAgICB0aGlzLmRpdi5hcHBlbmQodGhpcy5lZGl0b3JEaXYpO1xuICAgIHRoaXMub3ZlcmxheURpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgdGhpcy5vdmVybGF5RGl2LmNsYXNzTGlzdC5hZGQoXCJvdmVybGF5XCIsIFwiZW5hYmxlZFwiKTtcbiAgICB0aGlzLmRpdi5hcHBlbmQodGhpcy5vdmVybGF5RGl2KTtcbiAgICAoMCwgX3Rvb2xzLmJpbmRFdmVudHMpKHRoaXMsIHRoaXMuZGl2LCBbXCJkYmxjbGlja1wiLCBcImtleWRvd25cIl0pO1xuICAgIGlmICh0aGlzLndpZHRoKSB7XG4gICAgICBjb25zdCBbcGFyZW50V2lkdGgsIHBhcmVudEhlaWdodF0gPSB0aGlzLnBhcmVudERpbWVuc2lvbnM7XG4gICAgICBpZiAodGhpcy5hbm5vdGF0aW9uRWxlbWVudElkKSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBwb3NpdGlvblxuICAgICAgICB9ID0gdGhpcy4jaW5pdGlhbERhdGE7XG4gICAgICAgIGxldCBbdHgsIHR5XSA9IHRoaXMuZ2V0SW5pdGlhbFRyYW5zbGF0aW9uKCk7XG4gICAgICAgIFt0eCwgdHldID0gdGhpcy5wYWdlVHJhbnNsYXRpb25Ub1NjcmVlbih0eCwgdHkpO1xuICAgICAgICBjb25zdCBbcGFnZVdpZHRoLCBwYWdlSGVpZ2h0XSA9IHRoaXMucGFnZURpbWVuc2lvbnM7XG4gICAgICAgIGNvbnN0IFtwYWdlWCwgcGFnZVldID0gdGhpcy5wYWdlVHJhbnNsYXRpb247XG4gICAgICAgIGxldCBwb3NYLCBwb3NZO1xuICAgICAgICBzd2l0Y2ggKHRoaXMucm90YXRpb24pIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBwb3NYID0gYmFzZVggKyAocG9zaXRpb25bMF0gLSBwYWdlWCkgLyBwYWdlV2lkdGg7XG4gICAgICAgICAgICBwb3NZID0gYmFzZVkgKyB0aGlzLmhlaWdodCAtIChwb3NpdGlvblsxXSAtIHBhZ2VZKSAvIHBhZ2VIZWlnaHQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDkwOlxuICAgICAgICAgICAgcG9zWCA9IGJhc2VYICsgKHBvc2l0aW9uWzBdIC0gcGFnZVgpIC8gcGFnZVdpZHRoO1xuICAgICAgICAgICAgcG9zWSA9IGJhc2VZIC0gKHBvc2l0aW9uWzFdIC0gcGFnZVkpIC8gcGFnZUhlaWdodDtcbiAgICAgICAgICAgIFt0eCwgdHldID0gW3R5LCAtdHhdO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAxODA6XG4gICAgICAgICAgICBwb3NYID0gYmFzZVggLSB0aGlzLndpZHRoICsgKHBvc2l0aW9uWzBdIC0gcGFnZVgpIC8gcGFnZVdpZHRoO1xuICAgICAgICAgICAgcG9zWSA9IGJhc2VZIC0gKHBvc2l0aW9uWzFdIC0gcGFnZVkpIC8gcGFnZUhlaWdodDtcbiAgICAgICAgICAgIFt0eCwgdHldID0gWy10eCwgLXR5XTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMjcwOlxuICAgICAgICAgICAgcG9zWCA9IGJhc2VYICsgKHBvc2l0aW9uWzBdIC0gcGFnZVggLSB0aGlzLmhlaWdodCAqIHBhZ2VIZWlnaHQpIC8gcGFnZVdpZHRoO1xuICAgICAgICAgICAgcG9zWSA9IGJhc2VZICsgKHBvc2l0aW9uWzFdIC0gcGFnZVkgLSB0aGlzLndpZHRoICogcGFnZVdpZHRoKSAvIHBhZ2VIZWlnaHQ7XG4gICAgICAgICAgICBbdHgsIHR5XSA9IFstdHksIHR4XTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0QXQocG9zWCAqIHBhcmVudFdpZHRoLCBwb3NZICogcGFyZW50SGVpZ2h0LCB0eCwgdHkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zZXRBdChiYXNlWCAqIHBhcmVudFdpZHRoLCBiYXNlWSAqIHBhcmVudEhlaWdodCwgdGhpcy53aWR0aCAqIHBhcmVudFdpZHRoLCB0aGlzLmhlaWdodCAqIHBhcmVudEhlaWdodCk7XG4gICAgICB9XG4gICAgICB0aGlzLiNzZXRDb250ZW50KCk7XG4gICAgICB0aGlzLl9pc0RyYWdnYWJsZSA9IHRydWU7XG4gICAgICB0aGlzLmVkaXRvckRpdi5jb250ZW50RWRpdGFibGUgPSBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5faXNEcmFnZ2FibGUgPSBmYWxzZTtcbiAgICAgIHRoaXMuZWRpdG9yRGl2LmNvbnRlbnRFZGl0YWJsZSA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmRpdjtcbiAgfVxuICAjc2V0Q29udGVudCgpIHtcbiAgICB0aGlzLmVkaXRvckRpdi5yZXBsYWNlQ2hpbGRyZW4oKTtcbiAgICBpZiAoIXRoaXMuI2NvbnRlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yIChjb25zdCBsaW5lIG9mIHRoaXMuI2NvbnRlbnQuc3BsaXQoXCJcXG5cIikpIHtcbiAgICAgIGNvbnN0IGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICBkaXYuYXBwZW5kKGxpbmUgPyBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShsaW5lKSA6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJiclwiKSk7XG4gICAgICB0aGlzLmVkaXRvckRpdi5hcHBlbmQoZGl2KTtcbiAgICB9XG4gIH1cbiAgZ2V0IGNvbnRlbnREaXYoKSB7XG4gICAgcmV0dXJuIHRoaXMuZWRpdG9yRGl2O1xuICB9XG4gIHN0YXRpYyBkZXNlcmlhbGl6ZShkYXRhLCBwYXJlbnQsIHVpTWFuYWdlcikge1xuICAgIGxldCBpbml0aWFsRGF0YSA9IG51bGw7XG4gICAgaWYgKGRhdGEgaW5zdGFuY2VvZiBfYW5ub3RhdGlvbl9sYXllci5GcmVlVGV4dEFubm90YXRpb25FbGVtZW50KSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICBkZWZhdWx0QXBwZWFyYW5jZURhdGE6IHtcbiAgICAgICAgICAgIGZvbnRTaXplLFxuICAgICAgICAgICAgZm9udENvbG9yXG4gICAgICAgICAgfSxcbiAgICAgICAgICByZWN0LFxuICAgICAgICAgIHJvdGF0aW9uLFxuICAgICAgICAgIGlkXG4gICAgICAgIH0sXG4gICAgICAgIHRleHRDb250ZW50LFxuICAgICAgICB0ZXh0UG9zaXRpb24sXG4gICAgICAgIHBhcmVudDoge1xuICAgICAgICAgIHBhZ2U6IHtcbiAgICAgICAgICAgIHBhZ2VOdW1iZXJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gPSBkYXRhO1xuICAgICAgaWYgKCF0ZXh0Q29udGVudCB8fCB0ZXh0Q29udGVudC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBpbml0aWFsRGF0YSA9IGRhdGEgPSB7XG4gICAgICAgIGFubm90YXRpb25UeXBlOiBfdXRpbC5Bbm5vdGF0aW9uRWRpdG9yVHlwZS5GUkVFVEVYVCxcbiAgICAgICAgY29sb3I6IEFycmF5LmZyb20oZm9udENvbG9yKSxcbiAgICAgICAgZm9udFNpemUsXG4gICAgICAgIHZhbHVlOiB0ZXh0Q29udGVudC5qb2luKFwiXFxuXCIpLFxuICAgICAgICBwb3NpdGlvbjogdGV4dFBvc2l0aW9uLFxuICAgICAgICBwYWdlSW5kZXg6IHBhZ2VOdW1iZXIgLSAxLFxuICAgICAgICByZWN0LFxuICAgICAgICByb3RhdGlvbixcbiAgICAgICAgaWQsXG4gICAgICAgIGRlbGV0ZWQ6IGZhbHNlXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBlZGl0b3IgPSBzdXBlci5kZXNlcmlhbGl6ZShkYXRhLCBwYXJlbnQsIHVpTWFuYWdlcik7XG4gICAgZWRpdG9yLiNmb250U2l6ZSA9IGRhdGEuZm9udFNpemU7XG4gICAgZWRpdG9yLiNjb2xvciA9IF91dGlsLlV0aWwubWFrZUhleENvbG9yKC4uLmRhdGEuY29sb3IpO1xuICAgIGVkaXRvci4jY29udGVudCA9IGRhdGEudmFsdWU7XG4gICAgZWRpdG9yLmFubm90YXRpb25FbGVtZW50SWQgPSBkYXRhLmlkIHx8IG51bGw7XG4gICAgZWRpdG9yLiNpbml0aWFsRGF0YSA9IGluaXRpYWxEYXRhO1xuICAgIHJldHVybiBlZGl0b3I7XG4gIH1cbiAgc2VyaWFsaXplKGlzRm9yQ29weWluZyA9IGZhbHNlKSB7XG4gICAgaWYgKHRoaXMuaXNFbXB0eSgpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKHRoaXMuZGVsZXRlZCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcGFnZUluZGV4OiB0aGlzLnBhZ2VJbmRleCxcbiAgICAgICAgaWQ6IHRoaXMuYW5ub3RhdGlvbkVsZW1lbnRJZCxcbiAgICAgICAgZGVsZXRlZDogdHJ1ZVxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgcGFkZGluZyA9IEZyZWVUZXh0RWRpdG9yLl9pbnRlcm5hbFBhZGRpbmcgKiB0aGlzLnBhcmVudFNjYWxlO1xuICAgIGNvbnN0IHJlY3QgPSB0aGlzLmdldFJlY3QocGFkZGluZywgcGFkZGluZyk7XG4gICAgY29uc3QgY29sb3IgPSBfZWRpdG9yLkFubm90YXRpb25FZGl0b3IuX2NvbG9yTWFuYWdlci5jb252ZXJ0KHRoaXMuaXNBdHRhY2hlZFRvRE9NID8gZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLmVkaXRvckRpdikuY29sb3IgOiB0aGlzLiNjb2xvcik7XG4gICAgY29uc3Qgc2VyaWFsaXplZCA9IHtcbiAgICAgIGFubm90YXRpb25UeXBlOiBfdXRpbC5Bbm5vdGF0aW9uRWRpdG9yVHlwZS5GUkVFVEVYVCxcbiAgICAgIGNvbG9yLFxuICAgICAgZm9udFNpemU6IHRoaXMuI2ZvbnRTaXplLFxuICAgICAgdmFsdWU6IHRoaXMuI2NvbnRlbnQsXG4gICAgICBwYWdlSW5kZXg6IHRoaXMucGFnZUluZGV4LFxuICAgICAgcmVjdCxcbiAgICAgIHJvdGF0aW9uOiB0aGlzLnJvdGF0aW9uLFxuICAgICAgc3RydWN0VHJlZVBhcmVudElkOiB0aGlzLl9zdHJ1Y3RUcmVlUGFyZW50SWRcbiAgICB9O1xuICAgIGlmIChpc0ZvckNvcHlpbmcpIHtcbiAgICAgIHJldHVybiBzZXJpYWxpemVkO1xuICAgIH1cbiAgICBpZiAodGhpcy5hbm5vdGF0aW9uRWxlbWVudElkICYmICF0aGlzLiNoYXNFbGVtZW50Q2hhbmdlZChzZXJpYWxpemVkKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHNlcmlhbGl6ZWQuaWQgPSB0aGlzLmFubm90YXRpb25FbGVtZW50SWQ7XG4gICAgcmV0dXJuIHNlcmlhbGl6ZWQ7XG4gIH1cbiAgI2hhc0VsZW1lbnRDaGFuZ2VkKHNlcmlhbGl6ZWQpIHtcbiAgICBjb25zdCB7XG4gICAgICB2YWx1ZSxcbiAgICAgIGZvbnRTaXplLFxuICAgICAgY29sb3IsXG4gICAgICByZWN0LFxuICAgICAgcGFnZUluZGV4XG4gICAgfSA9IHRoaXMuI2luaXRpYWxEYXRhO1xuICAgIHJldHVybiBzZXJpYWxpemVkLnZhbHVlICE9PSB2YWx1ZSB8fCBzZXJpYWxpemVkLmZvbnRTaXplICE9PSBmb250U2l6ZSB8fCBzZXJpYWxpemVkLnJlY3Quc29tZSgoeCwgaSkgPT4gTWF0aC5hYnMoeCAtIHJlY3RbaV0pID49IDEpIHx8IHNlcmlhbGl6ZWQuY29sb3Iuc29tZSgoYywgaSkgPT4gYyAhPT0gY29sb3JbaV0pIHx8IHNlcmlhbGl6ZWQucGFnZUluZGV4ICE9PSBwYWdlSW5kZXg7XG4gIH1cbiAgI2NoZWF0SW5pdGlhbFJlY3QoZGVsYXllZCA9IGZhbHNlKSB7XG4gICAgaWYgKCF0aGlzLmFubm90YXRpb25FbGVtZW50SWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jc2V0RWRpdG9yRGltZW5zaW9ucygpO1xuICAgIGlmICghZGVsYXllZCAmJiAodGhpcy53aWR0aCA9PT0gMCB8fCB0aGlzLmhlaWdodCA9PT0gMCkpIHtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy4jY2hlYXRJbml0aWFsUmVjdCh0cnVlKSwgMCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHBhZGRpbmcgPSBGcmVlVGV4dEVkaXRvci5faW50ZXJuYWxQYWRkaW5nICogdGhpcy5wYXJlbnRTY2FsZTtcbiAgICB0aGlzLiNpbml0aWFsRGF0YS5yZWN0ID0gdGhpcy5nZXRSZWN0KHBhZGRpbmcsIHBhZGRpbmcpO1xuICB9XG59XG5leHBvcnRzLkZyZWVUZXh0RWRpdG9yID0gRnJlZVRleHRFZGl0b3I7XG5cbi8qKiovIH0pLFxuLyogMjkgKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pID0+IHtcblxuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcbmV4cG9ydHMuU3RhbXBBbm5vdGF0aW9uRWxlbWVudCA9IGV4cG9ydHMuSW5rQW5ub3RhdGlvbkVsZW1lbnQgPSBleHBvcnRzLkZyZWVUZXh0QW5ub3RhdGlvbkVsZW1lbnQgPSBleHBvcnRzLkFubm90YXRpb25MYXllciA9IHZvaWQgMDtcbnZhciBfdXRpbCA9IF9fd19wZGZqc19yZXF1aXJlX18oMSk7XG52YXIgX2Rpc3BsYXlfdXRpbHMgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDYpO1xudmFyIF9hbm5vdGF0aW9uX3N0b3JhZ2UgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDMpO1xudmFyIF9zY3JpcHRpbmdfdXRpbHMgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDMwKTtcbnZhciBfZGlzcGxheUwxMG5fdXRpbHMgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDMxKTtcbnZhciBfeGZhX2xheWVyID0gX193X3BkZmpzX3JlcXVpcmVfXygzMik7XG5jb25zdCBERUZBVUxUX1RBQl9JTkRFWCA9IDEwMDA7XG5jb25zdCBERUZBVUxUX0ZPTlRfU0laRSA9IDk7XG5jb25zdCBHZXRFbGVtZW50c0J5TmFtZVNldCA9IG5ldyBXZWFrU2V0KCk7XG5mdW5jdGlvbiBnZXRSZWN0RGltcyhyZWN0KSB7XG4gIHJldHVybiB7XG4gICAgd2lkdGg6IHJlY3RbMl0gLSByZWN0WzBdLFxuICAgIGhlaWdodDogcmVjdFszXSAtIHJlY3RbMV1cbiAgfTtcbn1cbmNsYXNzIEFubm90YXRpb25FbGVtZW50RmFjdG9yeSB7XG4gIHN0YXRpYyBjcmVhdGUocGFyYW1ldGVycykge1xuICAgIGNvbnN0IHN1YnR5cGUgPSBwYXJhbWV0ZXJzLmRhdGEuYW5ub3RhdGlvblR5cGU7XG4gICAgc3dpdGNoIChzdWJ0eXBlKSB7XG4gICAgICBjYXNlIF91dGlsLkFubm90YXRpb25UeXBlLkxJTks6XG4gICAgICAgIHJldHVybiBuZXcgTGlua0Fubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuICAgICAgY2FzZSBfdXRpbC5Bbm5vdGF0aW9uVHlwZS5URVhUOlxuICAgICAgICByZXR1cm4gbmV3IFRleHRBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICAgIGNhc2UgX3V0aWwuQW5ub3RhdGlvblR5cGUuV0lER0VUOlxuICAgICAgICBjb25zdCBmaWVsZFR5cGUgPSBwYXJhbWV0ZXJzLmRhdGEuZmllbGRUeXBlO1xuICAgICAgICBzd2l0Y2ggKGZpZWxkVHlwZSkge1xuICAgICAgICAgIGNhc2UgXCJUeFwiOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBUZXh0V2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG4gICAgICAgICAgY2FzZSBcIkJ0blwiOlxuICAgICAgICAgICAgaWYgKHBhcmFtZXRlcnMuZGF0YS5yYWRpb0J1dHRvbikge1xuICAgICAgICAgICAgICByZXR1cm4gbmV3IFJhZGlvQnV0dG9uV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHBhcmFtZXRlcnMuZGF0YS5jaGVja0JveCkge1xuICAgICAgICAgICAgICByZXR1cm4gbmV3IENoZWNrYm94V2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IFB1c2hCdXR0b25XaWRnZXRBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICAgICAgICBjYXNlIFwiQ2hcIjpcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ2hvaWNlV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG4gICAgICAgICAgY2FzZSBcIlNpZ1wiOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBTaWduYXR1cmVXaWRnZXRBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFdpZGdldEFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuICAgICAgY2FzZSBfdXRpbC5Bbm5vdGF0aW9uVHlwZS5QT1BVUDpcbiAgICAgICAgcmV0dXJuIG5ldyBQb3B1cEFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuICAgICAgY2FzZSBfdXRpbC5Bbm5vdGF0aW9uVHlwZS5GUkVFVEVYVDpcbiAgICAgICAgcmV0dXJuIG5ldyBGcmVlVGV4dEFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuICAgICAgY2FzZSBfdXRpbC5Bbm5vdGF0aW9uVHlwZS5MSU5FOlxuICAgICAgICByZXR1cm4gbmV3IExpbmVBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICAgIGNhc2UgX3V0aWwuQW5ub3RhdGlvblR5cGUuU1FVQVJFOlxuICAgICAgICByZXR1cm4gbmV3IFNxdWFyZUFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuICAgICAgY2FzZSBfdXRpbC5Bbm5vdGF0aW9uVHlwZS5DSVJDTEU6XG4gICAgICAgIHJldHVybiBuZXcgQ2lyY2xlQW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG4gICAgICBjYXNlIF91dGlsLkFubm90YXRpb25UeXBlLlBPTFlMSU5FOlxuICAgICAgICByZXR1cm4gbmV3IFBvbHlsaW5lQW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG4gICAgICBjYXNlIF91dGlsLkFubm90YXRpb25UeXBlLkNBUkVUOlxuICAgICAgICByZXR1cm4gbmV3IENhcmV0QW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG4gICAgICBjYXNlIF91dGlsLkFubm90YXRpb25UeXBlLklOSzpcbiAgICAgICAgcmV0dXJuIG5ldyBJbmtBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICAgIGNhc2UgX3V0aWwuQW5ub3RhdGlvblR5cGUuUE9MWUdPTjpcbiAgICAgICAgcmV0dXJuIG5ldyBQb2x5Z29uQW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG4gICAgICBjYXNlIF91dGlsLkFubm90YXRpb25UeXBlLkhJR0hMSUdIVDpcbiAgICAgICAgcmV0dXJuIG5ldyBIaWdobGlnaHRBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICAgIGNhc2UgX3V0aWwuQW5ub3RhdGlvblR5cGUuVU5ERVJMSU5FOlxuICAgICAgICByZXR1cm4gbmV3IFVuZGVybGluZUFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuICAgICAgY2FzZSBfdXRpbC5Bbm5vdGF0aW9uVHlwZS5TUVVJR0dMWTpcbiAgICAgICAgcmV0dXJuIG5ldyBTcXVpZ2dseUFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuICAgICAgY2FzZSBfdXRpbC5Bbm5vdGF0aW9uVHlwZS5TVFJJS0VPVVQ6XG4gICAgICAgIHJldHVybiBuZXcgU3RyaWtlT3V0QW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG4gICAgICBjYXNlIF91dGlsLkFubm90YXRpb25UeXBlLlNUQU1QOlxuICAgICAgICByZXR1cm4gbmV3IFN0YW1wQW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG4gICAgICBjYXNlIF91dGlsLkFubm90YXRpb25UeXBlLkZJTEVBVFRBQ0hNRU5UOlxuICAgICAgICByZXR1cm4gbmV3IEZpbGVBdHRhY2htZW50QW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gbmV3IEFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuICAgIH1cbiAgfVxufVxuY2xhc3MgQW5ub3RhdGlvbkVsZW1lbnQge1xuICAjaGFzQm9yZGVyID0gZmFsc2U7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMsIHtcbiAgICBpc1JlbmRlcmFibGUgPSBmYWxzZSxcbiAgICBpZ25vcmVCb3JkZXIgPSBmYWxzZSxcbiAgICBjcmVhdGVRdWFkcmlsYXRlcmFscyA9IGZhbHNlXG4gIH0gPSB7fSkge1xuICAgIHRoaXMuaXNSZW5kZXJhYmxlID0gaXNSZW5kZXJhYmxlO1xuICAgIHRoaXMuZGF0YSA9IHBhcmFtZXRlcnMuZGF0YTtcbiAgICB0aGlzLmxheWVyID0gcGFyYW1ldGVycy5sYXllcjtcbiAgICB0aGlzLmxpbmtTZXJ2aWNlID0gcGFyYW1ldGVycy5saW5rU2VydmljZTtcbiAgICB0aGlzLmRvd25sb2FkTWFuYWdlciA9IHBhcmFtZXRlcnMuZG93bmxvYWRNYW5hZ2VyO1xuICAgIHRoaXMuaW1hZ2VSZXNvdXJjZXNQYXRoID0gcGFyYW1ldGVycy5pbWFnZVJlc291cmNlc1BhdGg7XG4gICAgdGhpcy5yZW5kZXJGb3JtcyA9IHBhcmFtZXRlcnMucmVuZGVyRm9ybXM7XG4gICAgdGhpcy5zdmdGYWN0b3J5ID0gcGFyYW1ldGVycy5zdmdGYWN0b3J5O1xuICAgIHRoaXMuYW5ub3RhdGlvblN0b3JhZ2UgPSBwYXJhbWV0ZXJzLmFubm90YXRpb25TdG9yYWdlO1xuICAgIHRoaXMuZW5hYmxlU2NyaXB0aW5nID0gcGFyYW1ldGVycy5lbmFibGVTY3JpcHRpbmc7XG4gICAgdGhpcy5oYXNKU0FjdGlvbnMgPSBwYXJhbWV0ZXJzLmhhc0pTQWN0aW9ucztcbiAgICB0aGlzLl9maWVsZE9iamVjdHMgPSBwYXJhbWV0ZXJzLmZpZWxkT2JqZWN0cztcbiAgICB0aGlzLnBhcmVudCA9IHBhcmFtZXRlcnMucGFyZW50O1xuICAgIGlmIChpc1JlbmRlcmFibGUpIHtcbiAgICAgIHRoaXMuY29udGFpbmVyID0gdGhpcy5fY3JlYXRlQ29udGFpbmVyKGlnbm9yZUJvcmRlcik7XG4gICAgfVxuICAgIGlmIChjcmVhdGVRdWFkcmlsYXRlcmFscykge1xuICAgICAgdGhpcy5fY3JlYXRlUXVhZHJpbGF0ZXJhbHMoKTtcbiAgICB9XG4gIH1cbiAgc3RhdGljIF9oYXNQb3B1cERhdGEoe1xuICAgIHRpdGxlT2JqLFxuICAgIGNvbnRlbnRzT2JqLFxuICAgIHJpY2hUZXh0XG4gIH0pIHtcbiAgICByZXR1cm4gISEodGl0bGVPYmo/LnN0ciB8fCBjb250ZW50c09iaj8uc3RyIHx8IHJpY2hUZXh0Py5zdHIpO1xuICB9XG4gIGdldCBoYXNQb3B1cERhdGEoKSB7XG4gICAgcmV0dXJuIEFubm90YXRpb25FbGVtZW50Ll9oYXNQb3B1cERhdGEodGhpcy5kYXRhKTtcbiAgfVxuICBfY3JlYXRlQ29udGFpbmVyKGlnbm9yZUJvcmRlcikge1xuICAgIGNvbnN0IHtcbiAgICAgIGRhdGEsXG4gICAgICBwYXJlbnQ6IHtcbiAgICAgICAgcGFnZSxcbiAgICAgICAgdmlld3BvcnRcbiAgICAgIH1cbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic2VjdGlvblwiKTtcbiAgICBjb250YWluZXIuc2V0QXR0cmlidXRlKFwiZGF0YS1hbm5vdGF0aW9uLWlkXCIsIGRhdGEuaWQpO1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBXaWRnZXRBbm5vdGF0aW9uRWxlbWVudCkpIHtcbiAgICAgIGNvbnRhaW5lci50YWJJbmRleCA9IERFRkFVTFRfVEFCX0lOREVYO1xuICAgIH1cbiAgICBjb250YWluZXIuc3R5bGUuekluZGV4ID0gdGhpcy5wYXJlbnQuekluZGV4Kys7XG4gICAgaWYgKHRoaXMuZGF0YS5wb3B1cFJlZikge1xuICAgICAgY29udGFpbmVyLnNldEF0dHJpYnV0ZShcImFyaWEtaGFzcG9wdXBcIiwgXCJkaWFsb2dcIik7XG4gICAgfVxuICAgIGlmIChkYXRhLm5vUm90YXRlKSB7XG4gICAgICBjb250YWluZXIuY2xhc3NMaXN0LmFkZChcIm5vcm90YXRlXCIpO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBwYWdlV2lkdGgsXG4gICAgICBwYWdlSGVpZ2h0LFxuICAgICAgcGFnZVgsXG4gICAgICBwYWdlWVxuICAgIH0gPSB2aWV3cG9ydC5yYXdEaW1zO1xuICAgIGlmICghZGF0YS5yZWN0IHx8IHRoaXMgaW5zdGFuY2VvZiBQb3B1cEFubm90YXRpb25FbGVtZW50KSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHJvdGF0aW9uXG4gICAgICB9ID0gZGF0YTtcbiAgICAgIGlmICghZGF0YS5oYXNPd25DYW52YXMgJiYgcm90YXRpb24gIT09IDApIHtcbiAgICAgICAgdGhpcy5zZXRSb3RhdGlvbihyb3RhdGlvbiwgY29udGFpbmVyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb250YWluZXI7XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0XG4gICAgfSA9IGdldFJlY3REaW1zKGRhdGEucmVjdCk7XG4gICAgY29uc3QgcmVjdCA9IF91dGlsLlV0aWwubm9ybWFsaXplUmVjdChbZGF0YS5yZWN0WzBdLCBwYWdlLnZpZXdbM10gLSBkYXRhLnJlY3RbMV0gKyBwYWdlLnZpZXdbMV0sIGRhdGEucmVjdFsyXSwgcGFnZS52aWV3WzNdIC0gZGF0YS5yZWN0WzNdICsgcGFnZS52aWV3WzFdXSk7XG4gICAgaWYgKCFpZ25vcmVCb3JkZXIgJiYgZGF0YS5ib3JkZXJTdHlsZS53aWR0aCA+IDApIHtcbiAgICAgIGNvbnRhaW5lci5zdHlsZS5ib3JkZXJXaWR0aCA9IGAke2RhdGEuYm9yZGVyU3R5bGUud2lkdGh9cHhgO1xuICAgICAgY29uc3QgaG9yaXpvbnRhbFJhZGl1cyA9IGRhdGEuYm9yZGVyU3R5bGUuaG9yaXpvbnRhbENvcm5lclJhZGl1cztcbiAgICAgIGNvbnN0IHZlcnRpY2FsUmFkaXVzID0gZGF0YS5ib3JkZXJTdHlsZS52ZXJ0aWNhbENvcm5lclJhZGl1cztcbiAgICAgIGlmIChob3Jpem9udGFsUmFkaXVzID4gMCB8fCB2ZXJ0aWNhbFJhZGl1cyA+IDApIHtcbiAgICAgICAgY29uc3QgcmFkaXVzID0gYGNhbGMoJHtob3Jpem9udGFsUmFkaXVzfXB4ICogdmFyKC0tc2NhbGUtZmFjdG9yKSkgLyBjYWxjKCR7dmVydGljYWxSYWRpdXN9cHggKiB2YXIoLS1zY2FsZS1mYWN0b3IpKWA7XG4gICAgICAgIGNvbnRhaW5lci5zdHlsZS5ib3JkZXJSYWRpdXMgPSByYWRpdXM7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMgaW5zdGFuY2VvZiBSYWRpb0J1dHRvbldpZGdldEFubm90YXRpb25FbGVtZW50KSB7XG4gICAgICAgIGNvbnN0IHJhZGl1cyA9IGBjYWxjKCR7d2lkdGh9cHggKiB2YXIoLS1zY2FsZS1mYWN0b3IpKSAvIGNhbGMoJHtoZWlnaHR9cHggKiB2YXIoLS1zY2FsZS1mYWN0b3IpKWA7XG4gICAgICAgIGNvbnRhaW5lci5zdHlsZS5ib3JkZXJSYWRpdXMgPSByYWRpdXM7XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKGRhdGEuYm9yZGVyU3R5bGUuc3R5bGUpIHtcbiAgICAgICAgY2FzZSBfdXRpbC5Bbm5vdGF0aW9uQm9yZGVyU3R5bGVUeXBlLlNPTElEOlxuICAgICAgICAgIGNvbnRhaW5lci5zdHlsZS5ib3JkZXJTdHlsZSA9IFwic29saWRcIjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBfdXRpbC5Bbm5vdGF0aW9uQm9yZGVyU3R5bGVUeXBlLkRBU0hFRDpcbiAgICAgICAgICBjb250YWluZXIuc3R5bGUuYm9yZGVyU3R5bGUgPSBcImRhc2hlZFwiO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIF91dGlsLkFubm90YXRpb25Cb3JkZXJTdHlsZVR5cGUuQkVWRUxFRDpcbiAgICAgICAgICAoMCwgX3V0aWwud2FybikoXCJVbmltcGxlbWVudGVkIGJvcmRlciBzdHlsZTogYmV2ZWxlZFwiKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBfdXRpbC5Bbm5vdGF0aW9uQm9yZGVyU3R5bGVUeXBlLklOU0VUOlxuICAgICAgICAgICgwLCBfdXRpbC53YXJuKShcIlVuaW1wbGVtZW50ZWQgYm9yZGVyIHN0eWxlOiBpbnNldFwiKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBfdXRpbC5Bbm5vdGF0aW9uQm9yZGVyU3R5bGVUeXBlLlVOREVSTElORTpcbiAgICAgICAgICBjb250YWluZXIuc3R5bGUuYm9yZGVyQm90dG9tU3R5bGUgPSBcInNvbGlkXCI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjb25zdCBib3JkZXJDb2xvciA9IGRhdGEuYm9yZGVyQ29sb3IgfHwgbnVsbDtcbiAgICAgIGlmIChib3JkZXJDb2xvcikge1xuICAgICAgICB0aGlzLiNoYXNCb3JkZXIgPSB0cnVlO1xuICAgICAgICBjb250YWluZXIuc3R5bGUuYm9yZGVyQ29sb3IgPSBfdXRpbC5VdGlsLm1ha2VIZXhDb2xvcihib3JkZXJDb2xvclswXSB8IDAsIGJvcmRlckNvbG9yWzFdIHwgMCwgYm9yZGVyQ29sb3JbMl0gfCAwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRhaW5lci5zdHlsZS5ib3JkZXJXaWR0aCA9IDA7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnRhaW5lci5zdHlsZS5sZWZ0ID0gYCR7MTAwICogKHJlY3RbMF0gLSBwYWdlWCkgLyBwYWdlV2lkdGh9JWA7XG4gICAgY29udGFpbmVyLnN0eWxlLnRvcCA9IGAkezEwMCAqIChyZWN0WzFdIC0gcGFnZVkpIC8gcGFnZUhlaWdodH0lYDtcbiAgICBjb25zdCB7XG4gICAgICByb3RhdGlvblxuICAgIH0gPSBkYXRhO1xuICAgIGlmIChkYXRhLmhhc093bkNhbnZhcyB8fCByb3RhdGlvbiA9PT0gMCkge1xuICAgICAgY29udGFpbmVyLnN0eWxlLndpZHRoID0gYCR7MTAwICogd2lkdGggLyBwYWdlV2lkdGh9JWA7XG4gICAgICBjb250YWluZXIuc3R5bGUuaGVpZ2h0ID0gYCR7MTAwICogaGVpZ2h0IC8gcGFnZUhlaWdodH0lYDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZXRSb3RhdGlvbihyb3RhdGlvbiwgY29udGFpbmVyKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbnRhaW5lcjtcbiAgfVxuICBzZXRSb3RhdGlvbihhbmdsZSwgY29udGFpbmVyID0gdGhpcy5jb250YWluZXIpIHtcbiAgICBpZiAoIXRoaXMuZGF0YS5yZWN0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIHBhZ2VXaWR0aCxcbiAgICAgIHBhZ2VIZWlnaHRcbiAgICB9ID0gdGhpcy5wYXJlbnQudmlld3BvcnQucmF3RGltcztcbiAgICBjb25zdCB7XG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodFxuICAgIH0gPSBnZXRSZWN0RGltcyh0aGlzLmRhdGEucmVjdCk7XG4gICAgbGV0IGVsZW1lbnRXaWR0aCwgZWxlbWVudEhlaWdodDtcbiAgICBpZiAoYW5nbGUgJSAxODAgPT09IDApIHtcbiAgICAgIGVsZW1lbnRXaWR0aCA9IDEwMCAqIHdpZHRoIC8gcGFnZVdpZHRoO1xuICAgICAgZWxlbWVudEhlaWdodCA9IDEwMCAqIGhlaWdodCAvIHBhZ2VIZWlnaHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZW1lbnRXaWR0aCA9IDEwMCAqIGhlaWdodCAvIHBhZ2VXaWR0aDtcbiAgICAgIGVsZW1lbnRIZWlnaHQgPSAxMDAgKiB3aWR0aCAvIHBhZ2VIZWlnaHQ7XG4gICAgfVxuICAgIGNvbnRhaW5lci5zdHlsZS53aWR0aCA9IGAke2VsZW1lbnRXaWR0aH0lYDtcbiAgICBjb250YWluZXIuc3R5bGUuaGVpZ2h0ID0gYCR7ZWxlbWVudEhlaWdodH0lYDtcbiAgICBjb250YWluZXIuc2V0QXR0cmlidXRlKFwiZGF0YS1tYWluLXJvdGF0aW9uXCIsICgzNjAgLSBhbmdsZSkgJSAzNjApO1xuICB9XG4gIGdldCBfY29tbW9uQWN0aW9ucygpIHtcbiAgICBjb25zdCBzZXRDb2xvciA9IChqc05hbWUsIHN0eWxlTmFtZSwgZXZlbnQpID0+IHtcbiAgICAgIGNvbnN0IGNvbG9yID0gZXZlbnQuZGV0YWlsW2pzTmFtZV07XG4gICAgICBjb25zdCBjb2xvclR5cGUgPSBjb2xvclswXTtcbiAgICAgIGNvbnN0IGNvbG9yQXJyYXkgPSBjb2xvci5zbGljZSgxKTtcbiAgICAgIGV2ZW50LnRhcmdldC5zdHlsZVtzdHlsZU5hbWVdID0gX3NjcmlwdGluZ191dGlscy5Db2xvckNvbnZlcnRlcnNbYCR7Y29sb3JUeXBlfV9IVE1MYF0oY29sb3JBcnJheSk7XG4gICAgICB0aGlzLmFubm90YXRpb25TdG9yYWdlLnNldFZhbHVlKHRoaXMuZGF0YS5pZCwge1xuICAgICAgICBbc3R5bGVOYW1lXTogX3NjcmlwdGluZ191dGlscy5Db2xvckNvbnZlcnRlcnNbYCR7Y29sb3JUeXBlfV9yZ2JgXShjb2xvckFycmF5KVxuICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gKDAsIF91dGlsLnNoYWRvdykodGhpcywgXCJfY29tbW9uQWN0aW9uc1wiLCB7XG4gICAgICBkaXNwbGF5OiBldmVudCA9PiB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBkaXNwbGF5XG4gICAgICAgIH0gPSBldmVudC5kZXRhaWw7XG4gICAgICAgIGNvbnN0IGhpZGRlbiA9IGRpc3BsYXkgJSAyID09PSAxO1xuICAgICAgICB0aGlzLmNvbnRhaW5lci5zdHlsZS52aXNpYmlsaXR5ID0gaGlkZGVuID8gXCJoaWRkZW5cIiA6IFwidmlzaWJsZVwiO1xuICAgICAgICB0aGlzLmFubm90YXRpb25TdG9yYWdlLnNldFZhbHVlKHRoaXMuZGF0YS5pZCwge1xuICAgICAgICAgIG5vVmlldzogaGlkZGVuLFxuICAgICAgICAgIG5vUHJpbnQ6IGRpc3BsYXkgPT09IDEgfHwgZGlzcGxheSA9PT0gMlxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBwcmludDogZXZlbnQgPT4ge1xuICAgICAgICB0aGlzLmFubm90YXRpb25TdG9yYWdlLnNldFZhbHVlKHRoaXMuZGF0YS5pZCwge1xuICAgICAgICAgIG5vUHJpbnQ6ICFldmVudC5kZXRhaWwucHJpbnRcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgaGlkZGVuOiBldmVudCA9PiB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBoaWRkZW5cbiAgICAgICAgfSA9IGV2ZW50LmRldGFpbDtcbiAgICAgICAgdGhpcy5jb250YWluZXIuc3R5bGUudmlzaWJpbGl0eSA9IGhpZGRlbiA/IFwiaGlkZGVuXCIgOiBcInZpc2libGVcIjtcbiAgICAgICAgdGhpcy5hbm5vdGF0aW9uU3RvcmFnZS5zZXRWYWx1ZSh0aGlzLmRhdGEuaWQsIHtcbiAgICAgICAgICBub1ByaW50OiBoaWRkZW4sXG4gICAgICAgICAgbm9WaWV3OiBoaWRkZW5cbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgZm9jdXM6IGV2ZW50ID0+IHtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiBldmVudC50YXJnZXQuZm9jdXMoe1xuICAgICAgICAgIHByZXZlbnRTY3JvbGw6IGZhbHNlXG4gICAgICAgIH0pLCAwKTtcbiAgICAgIH0sXG4gICAgICB1c2VyTmFtZTogZXZlbnQgPT4ge1xuICAgICAgICBldmVudC50YXJnZXQudGl0bGUgPSBldmVudC5kZXRhaWwudXNlck5hbWU7XG4gICAgICB9LFxuICAgICAgcmVhZG9ubHk6IGV2ZW50ID0+IHtcbiAgICAgICAgZXZlbnQudGFyZ2V0LmRpc2FibGVkID0gZXZlbnQuZGV0YWlsLnJlYWRvbmx5O1xuICAgICAgfSxcbiAgICAgIHJlcXVpcmVkOiBldmVudCA9PiB7XG4gICAgICAgIHRoaXMuX3NldFJlcXVpcmVkKGV2ZW50LnRhcmdldCwgZXZlbnQuZGV0YWlsLnJlcXVpcmVkKTtcbiAgICAgIH0sXG4gICAgICBiZ0NvbG9yOiBldmVudCA9PiB7XG4gICAgICAgIHNldENvbG9yKFwiYmdDb2xvclwiLCBcImJhY2tncm91bmRDb2xvclwiLCBldmVudCk7XG4gICAgICB9LFxuICAgICAgZmlsbENvbG9yOiBldmVudCA9PiB7XG4gICAgICAgIHNldENvbG9yKFwiZmlsbENvbG9yXCIsIFwiYmFja2dyb3VuZENvbG9yXCIsIGV2ZW50KTtcbiAgICAgIH0sXG4gICAgICBmZ0NvbG9yOiBldmVudCA9PiB7XG4gICAgICAgIHNldENvbG9yKFwiZmdDb2xvclwiLCBcImNvbG9yXCIsIGV2ZW50KTtcbiAgICAgIH0sXG4gICAgICB0ZXh0Q29sb3I6IGV2ZW50ID0+IHtcbiAgICAgICAgc2V0Q29sb3IoXCJ0ZXh0Q29sb3JcIiwgXCJjb2xvclwiLCBldmVudCk7XG4gICAgICB9LFxuICAgICAgYm9yZGVyQ29sb3I6IGV2ZW50ID0+IHtcbiAgICAgICAgc2V0Q29sb3IoXCJib3JkZXJDb2xvclwiLCBcImJvcmRlckNvbG9yXCIsIGV2ZW50KTtcbiAgICAgIH0sXG4gICAgICBzdHJva2VDb2xvcjogZXZlbnQgPT4ge1xuICAgICAgICBzZXRDb2xvcihcInN0cm9rZUNvbG9yXCIsIFwiYm9yZGVyQ29sb3JcIiwgZXZlbnQpO1xuICAgICAgfSxcbiAgICAgIHJvdGF0aW9uOiBldmVudCA9PiB7XG4gICAgICAgIGNvbnN0IGFuZ2xlID0gZXZlbnQuZGV0YWlsLnJvdGF0aW9uO1xuICAgICAgICB0aGlzLnNldFJvdGF0aW9uKGFuZ2xlKTtcbiAgICAgICAgdGhpcy5hbm5vdGF0aW9uU3RvcmFnZS5zZXRWYWx1ZSh0aGlzLmRhdGEuaWQsIHtcbiAgICAgICAgICByb3RhdGlvbjogYW5nbGVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgX2Rpc3BhdGNoRXZlbnRGcm9tU2FuZGJveChhY3Rpb25zLCBqc0V2ZW50KSB7XG4gICAgY29uc3QgY29tbW9uQWN0aW9ucyA9IHRoaXMuX2NvbW1vbkFjdGlvbnM7XG4gICAgZm9yIChjb25zdCBuYW1lIG9mIE9iamVjdC5rZXlzKGpzRXZlbnQuZGV0YWlsKSkge1xuICAgICAgY29uc3QgYWN0aW9uID0gYWN0aW9uc1tuYW1lXSB8fCBjb21tb25BY3Rpb25zW25hbWVdO1xuICAgICAgYWN0aW9uPy4oanNFdmVudCk7XG4gICAgfVxuICB9XG4gIF9zZXREZWZhdWx0UHJvcGVydGllc0Zyb21KUyhlbGVtZW50KSB7XG4gICAgaWYgKCF0aGlzLmVuYWJsZVNjcmlwdGluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzdG9yZWREYXRhID0gdGhpcy5hbm5vdGF0aW9uU3RvcmFnZS5nZXRSYXdWYWx1ZSh0aGlzLmRhdGEuaWQpO1xuICAgIGlmICghc3RvcmVkRGF0YSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjb21tb25BY3Rpb25zID0gdGhpcy5fY29tbW9uQWN0aW9ucztcbiAgICBmb3IgKGNvbnN0IFthY3Rpb25OYW1lLCBkZXRhaWxdIG9mIE9iamVjdC5lbnRyaWVzKHN0b3JlZERhdGEpKSB7XG4gICAgICBjb25zdCBhY3Rpb24gPSBjb21tb25BY3Rpb25zW2FjdGlvbk5hbWVdO1xuICAgICAgaWYgKGFjdGlvbikge1xuICAgICAgICBjb25zdCBldmVudFByb3h5ID0ge1xuICAgICAgICAgIGRldGFpbDoge1xuICAgICAgICAgICAgW2FjdGlvbk5hbWVdOiBkZXRhaWxcbiAgICAgICAgICB9LFxuICAgICAgICAgIHRhcmdldDogZWxlbWVudFxuICAgICAgICB9O1xuICAgICAgICBhY3Rpb24oZXZlbnRQcm94eSk7XG4gICAgICAgIGRlbGV0ZSBzdG9yZWREYXRhW2FjdGlvbk5hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBfY3JlYXRlUXVhZHJpbGF0ZXJhbHMoKSB7XG4gICAgaWYgKCF0aGlzLmNvbnRhaW5lcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBxdWFkUG9pbnRzXG4gICAgfSA9IHRoaXMuZGF0YTtcbiAgICBpZiAoIXF1YWRQb2ludHMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgW3JlY3RCbFgsIHJlY3RCbFksIHJlY3RUclgsIHJlY3RUclldID0gdGhpcy5kYXRhLnJlY3Q7XG4gICAgaWYgKHF1YWRQb2ludHMubGVuZ3RoID09PSAxKSB7XG4gICAgICBjb25zdCBbLCB7XG4gICAgICAgIHg6IHRyWCxcbiAgICAgICAgeTogdHJZXG4gICAgICB9LCB7XG4gICAgICAgIHg6IGJsWCxcbiAgICAgICAgeTogYmxZXG4gICAgICB9XSA9IHF1YWRQb2ludHNbMF07XG4gICAgICBpZiAocmVjdFRyWCA9PT0gdHJYICYmIHJlY3RUclkgPT09IHRyWSAmJiByZWN0QmxYID09PSBibFggJiYgcmVjdEJsWSA9PT0gYmxZKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgc3R5bGVcbiAgICB9ID0gdGhpcy5jb250YWluZXI7XG4gICAgbGV0IHN2Z0J1ZmZlcjtcbiAgICBpZiAodGhpcy4jaGFzQm9yZGVyKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGJvcmRlckNvbG9yLFxuICAgICAgICBib3JkZXJXaWR0aFxuICAgICAgfSA9IHN0eWxlO1xuICAgICAgc3R5bGUuYm9yZGVyV2lkdGggPSAwO1xuICAgICAgc3ZnQnVmZmVyID0gW1widXJsKCdkYXRhOmltYWdlL3N2Zyt4bWw7dXRmOCxcIiwgYDxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiYCwgYCBwcmVzZXJ2ZUFzcGVjdFJhdGlvPVwibm9uZVwiIHZpZXdCb3g9XCIwIDAgMSAxXCI+YCwgYDxnIGZpbGw9XCJ0cmFuc3BhcmVudFwiIHN0cm9rZT1cIiR7Ym9yZGVyQ29sb3J9XCIgc3Ryb2tlLXdpZHRoPVwiJHtib3JkZXJXaWR0aH1cIj5gXTtcbiAgICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJoYXNCb3JkZXJcIik7XG4gICAgfVxuICAgIGNvbnN0IHdpZHRoID0gcmVjdFRyWCAtIHJlY3RCbFg7XG4gICAgY29uc3QgaGVpZ2h0ID0gcmVjdFRyWSAtIHJlY3RCbFk7XG4gICAgY29uc3Qge1xuICAgICAgc3ZnRmFjdG9yeVxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IHN2ZyA9IHN2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcInN2Z1wiKTtcbiAgICBzdmcuY2xhc3NMaXN0LmFkZChcInF1YWRyaWxhdGVyYWxzQ29udGFpbmVyXCIpO1xuICAgIHN2Zy5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLCAwKTtcbiAgICBzdmcuc2V0QXR0cmlidXRlKFwiaGVpZ2h0XCIsIDApO1xuICAgIGNvbnN0IGRlZnMgPSBzdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJkZWZzXCIpO1xuICAgIHN2Zy5hcHBlbmQoZGVmcyk7XG4gICAgY29uc3QgY2xpcFBhdGggPSBzdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJjbGlwUGF0aFwiKTtcbiAgICBjb25zdCBpZCA9IGBjbGlwcGF0aF8ke3RoaXMuZGF0YS5pZH1gO1xuICAgIGNsaXBQYXRoLnNldEF0dHJpYnV0ZShcImlkXCIsIGlkKTtcbiAgICBjbGlwUGF0aC5zZXRBdHRyaWJ1dGUoXCJjbGlwUGF0aFVuaXRzXCIsIFwib2JqZWN0Qm91bmRpbmdCb3hcIik7XG4gICAgZGVmcy5hcHBlbmQoY2xpcFBhdGgpO1xuICAgIGZvciAoY29uc3QgWywge1xuICAgICAgeDogdHJYLFxuICAgICAgeTogdHJZXG4gICAgfSwge1xuICAgICAgeDogYmxYLFxuICAgICAgeTogYmxZXG4gICAgfV0gb2YgcXVhZFBvaW50cykge1xuICAgICAgY29uc3QgcmVjdCA9IHN2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcInJlY3RcIik7XG4gICAgICBjb25zdCB4ID0gKGJsWCAtIHJlY3RCbFgpIC8gd2lkdGg7XG4gICAgICBjb25zdCB5ID0gKHJlY3RUclkgLSB0clkpIC8gaGVpZ2h0O1xuICAgICAgY29uc3QgcmVjdFdpZHRoID0gKHRyWCAtIGJsWCkgLyB3aWR0aDtcbiAgICAgIGNvbnN0IHJlY3RIZWlnaHQgPSAodHJZIC0gYmxZKSAvIGhlaWdodDtcbiAgICAgIHJlY3Quc2V0QXR0cmlidXRlKFwieFwiLCB4KTtcbiAgICAgIHJlY3Quc2V0QXR0cmlidXRlKFwieVwiLCB5KTtcbiAgICAgIHJlY3Quc2V0QXR0cmlidXRlKFwid2lkdGhcIiwgcmVjdFdpZHRoKTtcbiAgICAgIHJlY3Quc2V0QXR0cmlidXRlKFwiaGVpZ2h0XCIsIHJlY3RIZWlnaHQpO1xuICAgICAgY2xpcFBhdGguYXBwZW5kKHJlY3QpO1xuICAgICAgc3ZnQnVmZmVyPy5wdXNoKGA8cmVjdCB2ZWN0b3ItZWZmZWN0PVwibm9uLXNjYWxpbmctc3Ryb2tlXCIgeD1cIiR7eH1cIiB5PVwiJHt5fVwiIHdpZHRoPVwiJHtyZWN0V2lkdGh9XCIgaGVpZ2h0PVwiJHtyZWN0SGVpZ2h0fVwiLz5gKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuI2hhc0JvcmRlcikge1xuICAgICAgc3ZnQnVmZmVyLnB1c2goYDwvZz48L3N2Zz4nKWApO1xuICAgICAgc3R5bGUuYmFja2dyb3VuZEltYWdlID0gc3ZnQnVmZmVyLmpvaW4oXCJcIik7XG4gICAgfVxuICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZChzdmcpO1xuICAgIHRoaXMuY29udGFpbmVyLnN0eWxlLmNsaXBQYXRoID0gYHVybCgjJHtpZH0pYDtcbiAgfVxuICBfY3JlYXRlUG9wdXAoKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29udGFpbmVyLFxuICAgICAgZGF0YVxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoXCJhcmlhLWhhc3BvcHVwXCIsIFwiZGlhbG9nXCIpO1xuICAgIGNvbnN0IHBvcHVwID0gbmV3IFBvcHVwQW5ub3RhdGlvbkVsZW1lbnQoe1xuICAgICAgZGF0YToge1xuICAgICAgICBjb2xvcjogZGF0YS5jb2xvcixcbiAgICAgICAgdGl0bGVPYmo6IGRhdGEudGl0bGVPYmosXG4gICAgICAgIG1vZGlmaWNhdGlvbkRhdGU6IGRhdGEubW9kaWZpY2F0aW9uRGF0ZSxcbiAgICAgICAgY29udGVudHNPYmo6IGRhdGEuY29udGVudHNPYmosXG4gICAgICAgIHJpY2hUZXh0OiBkYXRhLnJpY2hUZXh0LFxuICAgICAgICBwYXJlbnRSZWN0OiBkYXRhLnJlY3QsXG4gICAgICAgIGJvcmRlclN0eWxlOiAwLFxuICAgICAgICBpZDogYHBvcHVwXyR7ZGF0YS5pZH1gLFxuICAgICAgICByb3RhdGlvbjogZGF0YS5yb3RhdGlvblxuICAgICAgfSxcbiAgICAgIHBhcmVudDogdGhpcy5wYXJlbnQsXG4gICAgICBlbGVtZW50czogW3RoaXNdXG4gICAgfSk7XG4gICAgdGhpcy5wYXJlbnQuZGl2LmFwcGVuZChwb3B1cC5yZW5kZXIoKSk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgICgwLCBfdXRpbC51bnJlYWNoYWJsZSkoXCJBYnN0cmFjdCBtZXRob2QgYEFubm90YXRpb25FbGVtZW50LnJlbmRlcmAgY2FsbGVkXCIpO1xuICB9XG4gIF9nZXRFbGVtZW50c0J5TmFtZShuYW1lLCBza2lwSWQgPSBudWxsKSB7XG4gICAgY29uc3QgZmllbGRzID0gW107XG4gICAgaWYgKHRoaXMuX2ZpZWxkT2JqZWN0cykge1xuICAgICAgY29uc3QgZmllbGRPYmogPSB0aGlzLl9maWVsZE9iamVjdHNbbmFtZV07XG4gICAgICBpZiAoZmllbGRPYmopIHtcbiAgICAgICAgZm9yIChjb25zdCB7XG4gICAgICAgICAgcGFnZSxcbiAgICAgICAgICBpZCxcbiAgICAgICAgICBleHBvcnRWYWx1ZXNcbiAgICAgICAgfSBvZiBmaWVsZE9iaikge1xuICAgICAgICAgIGlmIChwYWdlID09PSAtMSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpZCA9PT0gc2tpcElkKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgZXhwb3J0VmFsdWUgPSB0eXBlb2YgZXhwb3J0VmFsdWVzID09PSBcInN0cmluZ1wiID8gZXhwb3J0VmFsdWVzIDogbnVsbDtcbiAgICAgICAgICBjb25zdCBkb21FbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihgW2RhdGEtZWxlbWVudC1pZD1cIiR7aWR9XCJdYCk7XG4gICAgICAgICAgaWYgKGRvbUVsZW1lbnQgJiYgIUdldEVsZW1lbnRzQnlOYW1lU2V0Lmhhcyhkb21FbGVtZW50KSkge1xuICAgICAgICAgICAgKDAsIF91dGlsLndhcm4pKGBfZ2V0RWxlbWVudHNCeU5hbWUgLSBlbGVtZW50IG5vdCBhbGxvd2VkOiAke2lkfWApO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZpZWxkcy5wdXNoKHtcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgZXhwb3J0VmFsdWUsXG4gICAgICAgICAgICBkb21FbGVtZW50XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmaWVsZHM7XG4gICAgfVxuICAgIGZvciAoY29uc3QgZG9tRWxlbWVudCBvZiBkb2N1bWVudC5nZXRFbGVtZW50c0J5TmFtZShuYW1lKSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBleHBvcnRWYWx1ZVxuICAgICAgfSA9IGRvbUVsZW1lbnQ7XG4gICAgICBjb25zdCBpZCA9IGRvbUVsZW1lbnQuZ2V0QXR0cmlidXRlKFwiZGF0YS1lbGVtZW50LWlkXCIpO1xuICAgICAgaWYgKGlkID09PSBza2lwSWQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoIUdldEVsZW1lbnRzQnlOYW1lU2V0Lmhhcyhkb21FbGVtZW50KSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGZpZWxkcy5wdXNoKHtcbiAgICAgICAgaWQsXG4gICAgICAgIGV4cG9ydFZhbHVlLFxuICAgICAgICBkb21FbGVtZW50XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGZpZWxkcztcbiAgfVxuICBzaG93KCkge1xuICAgIGlmICh0aGlzLmNvbnRhaW5lcikge1xuICAgICAgdGhpcy5jb250YWluZXIuaGlkZGVuID0gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMucG9wdXA/Lm1heWJlU2hvdygpO1xuICB9XG4gIGhpZGUoKSB7XG4gICAgaWYgKHRoaXMuY29udGFpbmVyKSB7XG4gICAgICB0aGlzLmNvbnRhaW5lci5oaWRkZW4gPSB0cnVlO1xuICAgIH1cbiAgICB0aGlzLnBvcHVwPy5mb3JjZUhpZGUoKTtcbiAgfVxuICBnZXRFbGVtZW50c1RvVHJpZ2dlclBvcHVwKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgfVxuICBhZGRIaWdobGlnaHRBcmVhKCkge1xuICAgIGNvbnN0IHRyaWdnZXJzID0gdGhpcy5nZXRFbGVtZW50c1RvVHJpZ2dlclBvcHVwKCk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodHJpZ2dlcnMpKSB7XG4gICAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgdHJpZ2dlcnMpIHtcbiAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKFwiaGlnaGxpZ2h0QXJlYVwiKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdHJpZ2dlcnMuY2xhc3NMaXN0LmFkZChcImhpZ2hsaWdodEFyZWFcIik7XG4gICAgfVxuICB9XG4gIF9lZGl0T25Eb3VibGVDbGljaygpIHtcbiAgICBjb25zdCB7XG4gICAgICBhbm5vdGF0aW9uRWRpdG9yVHlwZTogbW9kZSxcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgaWQ6IGVkaXRJZFxuICAgICAgfVxuICAgIH0gPSB0aGlzO1xuICAgIHRoaXMuY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoXCJkYmxjbGlja1wiLCAoKSA9PiB7XG4gICAgICB0aGlzLmxpbmtTZXJ2aWNlLmV2ZW50QnVzPy5kaXNwYXRjaChcInN3aXRjaGFubm90YXRpb25lZGl0b3Jtb2RlXCIsIHtcbiAgICAgICAgc291cmNlOiB0aGlzLFxuICAgICAgICBtb2RlLFxuICAgICAgICBlZGl0SWRcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG59XG5jbGFzcyBMaW5rQW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBBbm5vdGF0aW9uRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMsIG9wdGlvbnMgPSBudWxsKSB7XG4gICAgc3VwZXIocGFyYW1ldGVycywge1xuICAgICAgaXNSZW5kZXJhYmxlOiB0cnVlLFxuICAgICAgaWdub3JlQm9yZGVyOiAhIW9wdGlvbnM/Lmlnbm9yZUJvcmRlcixcbiAgICAgIGNyZWF0ZVF1YWRyaWxhdGVyYWxzOiB0cnVlXG4gICAgfSk7XG4gICAgdGhpcy5pc1Rvb2x0aXBPbmx5ID0gcGFyYW1ldGVycy5kYXRhLmlzVG9vbHRpcE9ubHk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGRhdGEsXG4gICAgICBsaW5rU2VydmljZVxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYVwiKTtcbiAgICBsaW5rLnNldEF0dHJpYnV0ZShcImRhdGEtZWxlbWVudC1pZFwiLCBkYXRhLmlkKTtcbiAgICBsZXQgaXNCb3VuZCA9IGZhbHNlO1xuICAgIGlmIChkYXRhLnVybCkge1xuICAgICAgbGlua1NlcnZpY2UuYWRkTGlua0F0dHJpYnV0ZXMobGluaywgZGF0YS51cmwsIGRhdGEubmV3V2luZG93KTtcbiAgICAgIGlzQm91bmQgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAoZGF0YS5hY3Rpb24pIHtcbiAgICAgIHRoaXMuX2JpbmROYW1lZEFjdGlvbihsaW5rLCBkYXRhLmFjdGlvbik7XG4gICAgICBpc0JvdW5kID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKGRhdGEuYXR0YWNobWVudCkge1xuICAgICAgdGhpcy5fYmluZEF0dGFjaG1lbnQobGluaywgZGF0YS5hdHRhY2htZW50KTtcbiAgICAgIGlzQm91bmQgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAoZGF0YS5zZXRPQ0dTdGF0ZSkge1xuICAgICAgdGhpcy4jYmluZFNldE9DR1N0YXRlKGxpbmssIGRhdGEuc2V0T0NHU3RhdGUpO1xuICAgICAgaXNCb3VuZCA9IHRydWU7XG4gICAgfSBlbHNlIGlmIChkYXRhLmRlc3QpIHtcbiAgICAgIHRoaXMuX2JpbmRMaW5rKGxpbmssIGRhdGEuZGVzdCk7XG4gICAgICBpc0JvdW5kID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGRhdGEuYWN0aW9ucyAmJiAoZGF0YS5hY3Rpb25zLkFjdGlvbiB8fCBkYXRhLmFjdGlvbnNbXCJNb3VzZSBVcFwiXSB8fCBkYXRhLmFjdGlvbnNbXCJNb3VzZSBEb3duXCJdKSAmJiB0aGlzLmVuYWJsZVNjcmlwdGluZyAmJiB0aGlzLmhhc0pTQWN0aW9ucykge1xuICAgICAgICB0aGlzLl9iaW5kSlNBY3Rpb24obGluaywgZGF0YSk7XG4gICAgICAgIGlzQm91bmQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGRhdGEucmVzZXRGb3JtKSB7XG4gICAgICAgIHRoaXMuX2JpbmRSZXNldEZvcm1BY3Rpb24obGluaywgZGF0YS5yZXNldEZvcm0pO1xuICAgICAgICBpc0JvdW5kID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5pc1Rvb2x0aXBPbmx5ICYmICFpc0JvdW5kKSB7XG4gICAgICAgIHRoaXMuX2JpbmRMaW5rKGxpbmssIFwiXCIpO1xuICAgICAgICBpc0JvdW5kID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChcImxpbmtBbm5vdGF0aW9uXCIpO1xuICAgIGlmIChpc0JvdW5kKSB7XG4gICAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmQobGluayk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgfVxuICAjc2V0SW50ZXJuYWxMaW5rKCkge1xuICAgIHRoaXMuY29udGFpbmVyLnNldEF0dHJpYnV0ZShcImRhdGEtaW50ZXJuYWwtbGlua1wiLCBcIlwiKTtcbiAgfVxuICBfYmluZExpbmsobGluaywgZGVzdGluYXRpb24pIHtcbiAgICBsaW5rLmhyZWYgPSB0aGlzLmxpbmtTZXJ2aWNlLmdldERlc3RpbmF0aW9uSGFzaChkZXN0aW5hdGlvbik7XG4gICAgbGluay5vbmNsaWNrID0gKCkgPT4ge1xuICAgICAgaWYgKGRlc3RpbmF0aW9uKSB7XG4gICAgICAgIHRoaXMubGlua1NlcnZpY2UuZ29Ub0Rlc3RpbmF0aW9uKGRlc3RpbmF0aW9uKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIGlmIChkZXN0aW5hdGlvbiB8fCBkZXN0aW5hdGlvbiA9PT0gXCJcIikge1xuICAgICAgdGhpcy4jc2V0SW50ZXJuYWxMaW5rKCk7XG4gICAgfVxuICB9XG4gIF9iaW5kTmFtZWRBY3Rpb24obGluaywgYWN0aW9uKSB7XG4gICAgbGluay5ocmVmID0gdGhpcy5saW5rU2VydmljZS5nZXRBbmNob3JVcmwoXCJcIik7XG4gICAgbGluay5vbmNsaWNrID0gKCkgPT4ge1xuICAgICAgdGhpcy5saW5rU2VydmljZS5leGVjdXRlTmFtZWRBY3Rpb24oYWN0aW9uKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIHRoaXMuI3NldEludGVybmFsTGluaygpO1xuICB9XG4gIF9iaW5kQXR0YWNobWVudChsaW5rLCBhdHRhY2htZW50KSB7XG4gICAgbGluay5ocmVmID0gdGhpcy5saW5rU2VydmljZS5nZXRBbmNob3JVcmwoXCJcIik7XG4gICAgbGluay5vbmNsaWNrID0gKCkgPT4ge1xuICAgICAgdGhpcy5kb3dubG9hZE1hbmFnZXI/Lm9wZW5PckRvd25sb2FkRGF0YSh0aGlzLmNvbnRhaW5lciwgYXR0YWNobWVudC5jb250ZW50LCBhdHRhY2htZW50LmZpbGVuYW1lKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIHRoaXMuI3NldEludGVybmFsTGluaygpO1xuICB9XG4gICNiaW5kU2V0T0NHU3RhdGUobGluaywgYWN0aW9uKSB7XG4gICAgbGluay5ocmVmID0gdGhpcy5saW5rU2VydmljZS5nZXRBbmNob3JVcmwoXCJcIik7XG4gICAgbGluay5vbmNsaWNrID0gKCkgPT4ge1xuICAgICAgdGhpcy5saW5rU2VydmljZS5leGVjdXRlU2V0T0NHU3RhdGUoYWN0aW9uKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIHRoaXMuI3NldEludGVybmFsTGluaygpO1xuICB9XG4gIF9iaW5kSlNBY3Rpb24obGluaywgZGF0YSkge1xuICAgIGxpbmsuaHJlZiA9IHRoaXMubGlua1NlcnZpY2UuZ2V0QW5jaG9yVXJsKFwiXCIpO1xuICAgIGNvbnN0IG1hcCA9IG5ldyBNYXAoW1tcIkFjdGlvblwiLCBcIm9uY2xpY2tcIl0sIFtcIk1vdXNlIFVwXCIsIFwib25tb3VzZXVwXCJdLCBbXCJNb3VzZSBEb3duXCIsIFwib25tb3VzZWRvd25cIl1dKTtcbiAgICBmb3IgKGNvbnN0IG5hbWUgb2YgT2JqZWN0LmtleXMoZGF0YS5hY3Rpb25zKSkge1xuICAgICAgY29uc3QganNOYW1lID0gbWFwLmdldChuYW1lKTtcbiAgICAgIGlmICghanNOYW1lKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgbGlua1tqc05hbWVdID0gKCkgPT4ge1xuICAgICAgICB0aGlzLmxpbmtTZXJ2aWNlLmV2ZW50QnVzPy5kaXNwYXRjaChcImRpc3BhdGNoZXZlbnRpbnNhbmRib3hcIiwge1xuICAgICAgICAgIHNvdXJjZTogdGhpcyxcbiAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgIGlkOiBkYXRhLmlkLFxuICAgICAgICAgICAgbmFtZVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH07XG4gICAgfVxuICAgIGlmICghbGluay5vbmNsaWNrKSB7XG4gICAgICBsaW5rLm9uY2xpY2sgPSAoKSA9PiBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy4jc2V0SW50ZXJuYWxMaW5rKCk7XG4gIH1cbiAgX2JpbmRSZXNldEZvcm1BY3Rpb24obGluaywgcmVzZXRGb3JtKSB7XG4gICAgY29uc3Qgb3RoZXJDbGlja0FjdGlvbiA9IGxpbmsub25jbGljaztcbiAgICBpZiAoIW90aGVyQ2xpY2tBY3Rpb24pIHtcbiAgICAgIGxpbmsuaHJlZiA9IHRoaXMubGlua1NlcnZpY2UuZ2V0QW5jaG9yVXJsKFwiXCIpO1xuICAgIH1cbiAgICB0aGlzLiNzZXRJbnRlcm5hbExpbmsoKTtcbiAgICBpZiAoIXRoaXMuX2ZpZWxkT2JqZWN0cykge1xuICAgICAgKDAsIF91dGlsLndhcm4pKGBfYmluZFJlc2V0Rm9ybUFjdGlvbiAtIFwicmVzZXRGb3JtXCIgYWN0aW9uIG5vdCBzdXBwb3J0ZWQsIGAgKyBcImVuc3VyZSB0aGF0IHRoZSBgZmllbGRPYmplY3RzYCBwYXJhbWV0ZXIgaXMgcHJvdmlkZWQuXCIpO1xuICAgICAgaWYgKCFvdGhlckNsaWNrQWN0aW9uKSB7XG4gICAgICAgIGxpbmsub25jbGljayA9ICgpID0+IGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsaW5rLm9uY2xpY2sgPSAoKSA9PiB7XG4gICAgICBvdGhlckNsaWNrQWN0aW9uPy4oKTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZmllbGRzOiByZXNldEZvcm1GaWVsZHMsXG4gICAgICAgIHJlZnM6IHJlc2V0Rm9ybVJlZnMsXG4gICAgICAgIGluY2x1ZGVcbiAgICAgIH0gPSByZXNldEZvcm07XG4gICAgICBjb25zdCBhbGxGaWVsZHMgPSBbXTtcbiAgICAgIGlmIChyZXNldEZvcm1GaWVsZHMubGVuZ3RoICE9PSAwIHx8IHJlc2V0Rm9ybVJlZnMubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgIGNvbnN0IGZpZWxkSWRzID0gbmV3IFNldChyZXNldEZvcm1SZWZzKTtcbiAgICAgICAgZm9yIChjb25zdCBmaWVsZE5hbWUgb2YgcmVzZXRGb3JtRmllbGRzKSB7XG4gICAgICAgICAgY29uc3QgZmllbGRzID0gdGhpcy5fZmllbGRPYmplY3RzW2ZpZWxkTmFtZV0gfHwgW107XG4gICAgICAgICAgZm9yIChjb25zdCB7XG4gICAgICAgICAgICBpZFxuICAgICAgICAgIH0gb2YgZmllbGRzKSB7XG4gICAgICAgICAgICBmaWVsZElkcy5hZGQoaWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGZpZWxkcyBvZiBPYmplY3QudmFsdWVzKHRoaXMuX2ZpZWxkT2JqZWN0cykpIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IGZpZWxkIG9mIGZpZWxkcykge1xuICAgICAgICAgICAgaWYgKGZpZWxkSWRzLmhhcyhmaWVsZC5pZCkgPT09IGluY2x1ZGUpIHtcbiAgICAgICAgICAgICAgYWxsRmllbGRzLnB1c2goZmllbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChjb25zdCBmaWVsZHMgb2YgT2JqZWN0LnZhbHVlcyh0aGlzLl9maWVsZE9iamVjdHMpKSB7XG4gICAgICAgICAgYWxsRmllbGRzLnB1c2goLi4uZmllbGRzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3Qgc3RvcmFnZSA9IHRoaXMuYW5ub3RhdGlvblN0b3JhZ2U7XG4gICAgICBjb25zdCBhbGxJZHMgPSBbXTtcbiAgICAgIGZvciAoY29uc3QgZmllbGQgb2YgYWxsRmllbGRzKSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBpZFxuICAgICAgICB9ID0gZmllbGQ7XG4gICAgICAgIGFsbElkcy5wdXNoKGlkKTtcbiAgICAgICAgc3dpdGNoIChmaWVsZC50eXBlKSB7XG4gICAgICAgICAgY2FzZSBcInRleHRcIjpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBmaWVsZC5kZWZhdWx0VmFsdWUgfHwgXCJcIjtcbiAgICAgICAgICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwge1xuICAgICAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFwiY2hlY2tib3hcIjpcbiAgICAgICAgICBjYXNlIFwicmFkaW9idXR0b25cIjpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBmaWVsZC5kZWZhdWx0VmFsdWUgPT09IGZpZWxkLmV4cG9ydFZhbHVlcztcbiAgICAgICAgICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwge1xuICAgICAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFwiY29tYm9ib3hcIjpcbiAgICAgICAgICBjYXNlIFwibGlzdGJveFwiOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGZpZWxkLmRlZmF1bHRWYWx1ZSB8fCBcIlwiO1xuICAgICAgICAgICAgICBzdG9yYWdlLnNldFZhbHVlKGlkLCB7XG4gICAgICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkb21FbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihgW2RhdGEtZWxlbWVudC1pZD1cIiR7aWR9XCJdYCk7XG4gICAgICAgIGlmICghZG9tRWxlbWVudCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IGVsc2UgaWYgKCFHZXRFbGVtZW50c0J5TmFtZVNldC5oYXMoZG9tRWxlbWVudCkpIHtcbiAgICAgICAgICAoMCwgX3V0aWwud2FybikoYF9iaW5kUmVzZXRGb3JtQWN0aW9uIC0gZWxlbWVudCBub3QgYWxsb3dlZDogJHtpZH1gKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBkb21FbGVtZW50LmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KFwicmVzZXRmb3JtXCIpKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmVuYWJsZVNjcmlwdGluZykge1xuICAgICAgICB0aGlzLmxpbmtTZXJ2aWNlLmV2ZW50QnVzPy5kaXNwYXRjaChcImRpc3BhdGNoZXZlbnRpbnNhbmRib3hcIiwge1xuICAgICAgICAgIHNvdXJjZTogdGhpcyxcbiAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgIGlkOiBcImFwcFwiLFxuICAgICAgICAgICAgaWRzOiBhbGxJZHMsXG4gICAgICAgICAgICBuYW1lOiBcIlJlc2V0Rm9ybVwiXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICB9XG59XG5jbGFzcyBUZXh0QW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBBbm5vdGF0aW9uRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcbiAgICBzdXBlcihwYXJhbWV0ZXJzLCB7XG4gICAgICBpc1JlbmRlcmFibGU6IHRydWVcbiAgICB9KTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChcInRleHRBbm5vdGF0aW9uXCIpO1xuICAgIGNvbnN0IGltYWdlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImltZ1wiKTtcbiAgICBpbWFnZS5zcmMgPSB0aGlzLmltYWdlUmVzb3VyY2VzUGF0aCArIFwiYW5ub3RhdGlvbi1cIiArIHRoaXMuZGF0YS5uYW1lLnRvTG93ZXJDYXNlKCkgKyBcIi5zdmdcIjtcbiAgICBpbWFnZS5hbHQgPSBcIlt7e3R5cGV9fSBBbm5vdGF0aW9uXVwiO1xuICAgIGltYWdlLmRhdGFzZXQubDEwbklkID0gXCJ0ZXh0X2Fubm90YXRpb25fdHlwZVwiO1xuICAgIGltYWdlLmRhdGFzZXQubDEwbkFyZ3MgPSBKU09OLnN0cmluZ2lmeSh7XG4gICAgICB0eXBlOiB0aGlzLmRhdGEubmFtZVxuICAgIH0pO1xuICAgIGlmICghdGhpcy5kYXRhLnBvcHVwUmVmICYmIHRoaXMuaGFzUG9wdXBEYXRhKSB7XG4gICAgICB0aGlzLl9jcmVhdGVQb3B1cCgpO1xuICAgIH1cbiAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmQoaW1hZ2UpO1xuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgfVxufVxuY2xhc3MgV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBBbm5vdGF0aW9uRWxlbWVudCB7XG4gIHJlbmRlcigpIHtcbiAgICBpZiAodGhpcy5kYXRhLmFsdGVybmF0aXZlVGV4dCkge1xuICAgICAgdGhpcy5jb250YWluZXIudGl0bGUgPSB0aGlzLmRhdGEuYWx0ZXJuYXRpdmVUZXh0O1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gIH1cbiAgc2hvd0VsZW1lbnRBbmRIaWRlQ2FudmFzKGVsZW1lbnQpIHtcbiAgICBpZiAodGhpcy5kYXRhLmhhc093bkNhbnZhcykge1xuICAgICAgaWYgKGVsZW1lbnQucHJldmlvdXNTaWJsaW5nPy5ub2RlTmFtZSA9PT0gXCJDQU5WQVNcIikge1xuICAgICAgICBlbGVtZW50LnByZXZpb3VzU2libGluZy5oaWRkZW4gPSB0cnVlO1xuICAgICAgfVxuICAgICAgZWxlbWVudC5oaWRkZW4gPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgX2dldEtleU1vZGlmaWVyKGV2ZW50KSB7XG4gICAgY29uc3Qge1xuICAgICAgaXNXaW4sXG4gICAgICBpc01hY1xuICAgIH0gPSBfdXRpbC5GZWF0dXJlVGVzdC5wbGF0Zm9ybTtcbiAgICByZXR1cm4gaXNXaW4gJiYgZXZlbnQuY3RybEtleSB8fCBpc01hYyAmJiBldmVudC5tZXRhS2V5O1xuICB9XG4gIF9zZXRFdmVudExpc3RlbmVyKGVsZW1lbnQsIGVsZW1lbnREYXRhLCBiYXNlTmFtZSwgZXZlbnROYW1lLCB2YWx1ZUdldHRlcikge1xuICAgIGlmIChiYXNlTmFtZS5pbmNsdWRlcyhcIm1vdXNlXCIpKSB7XG4gICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoYmFzZU5hbWUsIGV2ZW50ID0+IHtcbiAgICAgICAgdGhpcy5saW5rU2VydmljZS5ldmVudEJ1cz8uZGlzcGF0Y2goXCJkaXNwYXRjaGV2ZW50aW5zYW5kYm94XCIsIHtcbiAgICAgICAgICBzb3VyY2U6IHRoaXMsXG4gICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICBpZDogdGhpcy5kYXRhLmlkLFxuICAgICAgICAgICAgbmFtZTogZXZlbnROYW1lLFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlR2V0dGVyKGV2ZW50KSxcbiAgICAgICAgICAgIHNoaWZ0OiBldmVudC5zaGlmdEtleSxcbiAgICAgICAgICAgIG1vZGlmaWVyOiB0aGlzLl9nZXRLZXlNb2RpZmllcihldmVudClcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihiYXNlTmFtZSwgZXZlbnQgPT4ge1xuICAgICAgICBpZiAoYmFzZU5hbWUgPT09IFwiYmx1clwiKSB7XG4gICAgICAgICAgaWYgKCFlbGVtZW50RGF0YS5mb2N1c2VkIHx8ICFldmVudC5yZWxhdGVkVGFyZ2V0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsZW1lbnREYXRhLmZvY3VzZWQgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIGlmIChiYXNlTmFtZSA9PT0gXCJmb2N1c1wiKSB7XG4gICAgICAgICAgaWYgKGVsZW1lbnREYXRhLmZvY3VzZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxlbWVudERhdGEuZm9jdXNlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF2YWx1ZUdldHRlcikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxpbmtTZXJ2aWNlLmV2ZW50QnVzPy5kaXNwYXRjaChcImRpc3BhdGNoZXZlbnRpbnNhbmRib3hcIiwge1xuICAgICAgICAgIHNvdXJjZTogdGhpcyxcbiAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgIGlkOiB0aGlzLmRhdGEuaWQsXG4gICAgICAgICAgICBuYW1lOiBldmVudE5hbWUsXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWVHZXR0ZXIoZXZlbnQpXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBfc2V0RXZlbnRMaXN0ZW5lcnMoZWxlbWVudCwgZWxlbWVudERhdGEsIG5hbWVzLCBnZXR0ZXIpIHtcbiAgICBmb3IgKGNvbnN0IFtiYXNlTmFtZSwgZXZlbnROYW1lXSBvZiBuYW1lcykge1xuICAgICAgaWYgKGV2ZW50TmFtZSA9PT0gXCJBY3Rpb25cIiB8fCB0aGlzLmRhdGEuYWN0aW9ucz8uW2V2ZW50TmFtZV0pIHtcbiAgICAgICAgaWYgKGV2ZW50TmFtZSA9PT0gXCJGb2N1c1wiIHx8IGV2ZW50TmFtZSA9PT0gXCJCbHVyXCIpIHtcbiAgICAgICAgICBlbGVtZW50RGF0YSB8fD0ge1xuICAgICAgICAgICAgZm9jdXNlZDogZmFsc2VcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3NldEV2ZW50TGlzdGVuZXIoZWxlbWVudCwgZWxlbWVudERhdGEsIGJhc2VOYW1lLCBldmVudE5hbWUsIGdldHRlcik7XG4gICAgICAgIGlmIChldmVudE5hbWUgPT09IFwiRm9jdXNcIiAmJiAhdGhpcy5kYXRhLmFjdGlvbnM/LkJsdXIpIHtcbiAgICAgICAgICB0aGlzLl9zZXRFdmVudExpc3RlbmVyKGVsZW1lbnQsIGVsZW1lbnREYXRhLCBcImJsdXJcIiwgXCJCbHVyXCIsIG51bGwpO1xuICAgICAgICB9IGVsc2UgaWYgKGV2ZW50TmFtZSA9PT0gXCJCbHVyXCIgJiYgIXRoaXMuZGF0YS5hY3Rpb25zPy5Gb2N1cykge1xuICAgICAgICAgIHRoaXMuX3NldEV2ZW50TGlzdGVuZXIoZWxlbWVudCwgZWxlbWVudERhdGEsIFwiZm9jdXNcIiwgXCJGb2N1c1wiLCBudWxsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBfc2V0QmFja2dyb3VuZENvbG9yKGVsZW1lbnQpIHtcbiAgICBjb25zdCBjb2xvciA9IHRoaXMuZGF0YS5iYWNrZ3JvdW5kQ29sb3IgfHwgbnVsbDtcbiAgICBlbGVtZW50LnN0eWxlLmJhY2tncm91bmRDb2xvciA9IGNvbG9yID09PSBudWxsID8gXCJ0cmFuc3BhcmVudFwiIDogX3V0aWwuVXRpbC5tYWtlSGV4Q29sb3IoY29sb3JbMF0sIGNvbG9yWzFdLCBjb2xvclsyXSk7XG4gIH1cbiAgX3NldFRleHRTdHlsZShlbGVtZW50KSB7XG4gICAgY29uc3QgVEVYVF9BTElHTk1FTlQgPSBbXCJsZWZ0XCIsIFwiY2VudGVyXCIsIFwicmlnaHRcIl07XG4gICAgY29uc3Qge1xuICAgICAgZm9udENvbG9yXG4gICAgfSA9IHRoaXMuZGF0YS5kZWZhdWx0QXBwZWFyYW5jZURhdGE7XG4gICAgY29uc3QgZm9udFNpemUgPSB0aGlzLmRhdGEuZGVmYXVsdEFwcGVhcmFuY2VEYXRhLmZvbnRTaXplIHx8IERFRkFVTFRfRk9OVF9TSVpFO1xuICAgIGNvbnN0IHN0eWxlID0gZWxlbWVudC5zdHlsZTtcbiAgICBsZXQgY29tcHV0ZWRGb250U2l6ZTtcbiAgICBjb25zdCBCT1JERVJfU0laRSA9IDI7XG4gICAgY29uc3Qgcm91bmRUb09uZURlY2ltYWwgPSB4ID0+IE1hdGgucm91bmQoMTAgKiB4KSAvIDEwO1xuICAgIGlmICh0aGlzLmRhdGEubXVsdGlMaW5lKSB7XG4gICAgICBjb25zdCBoZWlnaHQgPSBNYXRoLmFicyh0aGlzLmRhdGEucmVjdFszXSAtIHRoaXMuZGF0YS5yZWN0WzFdIC0gQk9SREVSX1NJWkUpO1xuICAgICAgY29uc3QgbnVtYmVyT2ZMaW5lcyA9IE1hdGgucm91bmQoaGVpZ2h0IC8gKF91dGlsLkxJTkVfRkFDVE9SICogZm9udFNpemUpKSB8fCAxO1xuICAgICAgY29uc3QgbGluZUhlaWdodCA9IGhlaWdodCAvIG51bWJlck9mTGluZXM7XG4gICAgICBjb21wdXRlZEZvbnRTaXplID0gTWF0aC5taW4oZm9udFNpemUsIHJvdW5kVG9PbmVEZWNpbWFsKGxpbmVIZWlnaHQgLyBfdXRpbC5MSU5FX0ZBQ1RPUikpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBoZWlnaHQgPSBNYXRoLmFicyh0aGlzLmRhdGEucmVjdFszXSAtIHRoaXMuZGF0YS5yZWN0WzFdIC0gQk9SREVSX1NJWkUpO1xuICAgICAgY29tcHV0ZWRGb250U2l6ZSA9IE1hdGgubWluKGZvbnRTaXplLCByb3VuZFRvT25lRGVjaW1hbChoZWlnaHQgLyBfdXRpbC5MSU5FX0ZBQ1RPUikpO1xuICAgIH1cbiAgICBzdHlsZS5mb250U2l6ZSA9IGBjYWxjKCR7Y29tcHV0ZWRGb250U2l6ZX1weCAqIHZhcigtLXNjYWxlLWZhY3RvcikpYDtcbiAgICBzdHlsZS5jb2xvciA9IF91dGlsLlV0aWwubWFrZUhleENvbG9yKGZvbnRDb2xvclswXSwgZm9udENvbG9yWzFdLCBmb250Q29sb3JbMl0pO1xuICAgIGlmICh0aGlzLmRhdGEudGV4dEFsaWdubWVudCAhPT0gbnVsbCkge1xuICAgICAgc3R5bGUudGV4dEFsaWduID0gVEVYVF9BTElHTk1FTlRbdGhpcy5kYXRhLnRleHRBbGlnbm1lbnRdO1xuICAgIH1cbiAgfVxuICBfc2V0UmVxdWlyZWQoZWxlbWVudCwgaXNSZXF1aXJlZCkge1xuICAgIGlmIChpc1JlcXVpcmVkKSB7XG4gICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShcInJlcXVpcmVkXCIsIHRydWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShcInJlcXVpcmVkXCIpO1xuICAgIH1cbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShcImFyaWEtcmVxdWlyZWRcIiwgaXNSZXF1aXJlZCk7XG4gIH1cbn1cbmNsYXNzIFRleHRXaWRnZXRBbm5vdGF0aW9uRWxlbWVudCBleHRlbmRzIFdpZGdldEFubm90YXRpb25FbGVtZW50IHtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVycykge1xuICAgIGNvbnN0IGlzUmVuZGVyYWJsZSA9IHBhcmFtZXRlcnMucmVuZGVyRm9ybXMgfHwgIXBhcmFtZXRlcnMuZGF0YS5oYXNBcHBlYXJhbmNlICYmICEhcGFyYW1ldGVycy5kYXRhLmZpZWxkVmFsdWU7XG4gICAgc3VwZXIocGFyYW1ldGVycywge1xuICAgICAgaXNSZW5kZXJhYmxlXG4gICAgfSk7XG4gIH1cbiAgc2V0UHJvcGVydHlPblNpYmxpbmdzKGJhc2UsIGtleSwgdmFsdWUsIGtleUluU3RvcmFnZSkge1xuICAgIGNvbnN0IHN0b3JhZ2UgPSB0aGlzLmFubm90YXRpb25TdG9yYWdlO1xuICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiB0aGlzLl9nZXRFbGVtZW50c0J5TmFtZShiYXNlLm5hbWUsIGJhc2UuaWQpKSB7XG4gICAgICBpZiAoZWxlbWVudC5kb21FbGVtZW50KSB7XG4gICAgICAgIGVsZW1lbnQuZG9tRWxlbWVudFtrZXldID0gdmFsdWU7XG4gICAgICB9XG4gICAgICBzdG9yYWdlLnNldFZhbHVlKGVsZW1lbnQuaWQsIHtcbiAgICAgICAgW2tleUluU3RvcmFnZV06IHZhbHVlXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHN0b3JhZ2UgPSB0aGlzLmFubm90YXRpb25TdG9yYWdlO1xuICAgIGNvbnN0IGlkID0gdGhpcy5kYXRhLmlkO1xuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJ0ZXh0V2lkZ2V0QW5ub3RhdGlvblwiKTtcbiAgICBsZXQgZWxlbWVudCA9IG51bGw7XG4gICAgaWYgKHRoaXMucmVuZGVyRm9ybXMpIHtcbiAgICAgIGNvbnN0IHN0b3JlZERhdGEgPSBzdG9yYWdlLmdldFZhbHVlKGlkLCB7XG4gICAgICAgIHZhbHVlOiB0aGlzLmRhdGEuZmllbGRWYWx1ZVxuICAgICAgfSk7XG4gICAgICBsZXQgdGV4dENvbnRlbnQgPSBzdG9yZWREYXRhLnZhbHVlIHx8IFwiXCI7XG4gICAgICBjb25zdCBtYXhMZW4gPSBzdG9yYWdlLmdldFZhbHVlKGlkLCB7XG4gICAgICAgIGNoYXJMaW1pdDogdGhpcy5kYXRhLm1heExlblxuICAgICAgfSkuY2hhckxpbWl0O1xuICAgICAgaWYgKG1heExlbiAmJiB0ZXh0Q29udGVudC5sZW5ndGggPiBtYXhMZW4pIHtcbiAgICAgICAgdGV4dENvbnRlbnQgPSB0ZXh0Q29udGVudC5zbGljZSgwLCBtYXhMZW4pO1xuICAgICAgfVxuICAgICAgbGV0IGZpZWxkRm9ybWF0dGVkVmFsdWVzID0gc3RvcmVkRGF0YS5mb3JtYXR0ZWRWYWx1ZSB8fCB0aGlzLmRhdGEudGV4dENvbnRlbnQ/LmpvaW4oXCJcXG5cIikgfHwgbnVsbDtcbiAgICAgIGlmIChmaWVsZEZvcm1hdHRlZFZhbHVlcyAmJiB0aGlzLmRhdGEuY29tYikge1xuICAgICAgICBmaWVsZEZvcm1hdHRlZFZhbHVlcyA9IGZpZWxkRm9ybWF0dGVkVmFsdWVzLnJlcGxhY2VBbGwoL1xccysvZywgXCJcIik7XG4gICAgICB9XG4gICAgICBjb25zdCBlbGVtZW50RGF0YSA9IHtcbiAgICAgICAgdXNlclZhbHVlOiB0ZXh0Q29udGVudCxcbiAgICAgICAgZm9ybWF0dGVkVmFsdWU6IGZpZWxkRm9ybWF0dGVkVmFsdWVzLFxuICAgICAgICBsYXN0Q29tbWl0dGVkVmFsdWU6IG51bGwsXG4gICAgICAgIGNvbW1pdEtleTogMSxcbiAgICAgICAgZm9jdXNlZDogZmFsc2VcbiAgICAgIH07XG4gICAgICBpZiAodGhpcy5kYXRhLm11bHRpTGluZSkge1xuICAgICAgICBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRleHRhcmVhXCIpO1xuICAgICAgICBlbGVtZW50LnRleHRDb250ZW50ID0gZmllbGRGb3JtYXR0ZWRWYWx1ZXMgPz8gdGV4dENvbnRlbnQ7XG4gICAgICAgIGlmICh0aGlzLmRhdGEuZG9Ob3RTY3JvbGwpIHtcbiAgICAgICAgICBlbGVtZW50LnN0eWxlLm92ZXJmbG93WSA9IFwiaGlkZGVuXCI7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7XG4gICAgICAgIGVsZW1lbnQudHlwZSA9IFwidGV4dFwiO1xuICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShcInZhbHVlXCIsIGZpZWxkRm9ybWF0dGVkVmFsdWVzID8/IHRleHRDb250ZW50KTtcbiAgICAgICAgaWYgKHRoaXMuZGF0YS5kb05vdFNjcm9sbCkge1xuICAgICAgICAgIGVsZW1lbnQuc3R5bGUub3ZlcmZsb3dYID0gXCJoaWRkZW5cIjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHRoaXMuZGF0YS5oYXNPd25DYW52YXMpIHtcbiAgICAgICAgZWxlbWVudC5oaWRkZW4gPSB0cnVlO1xuICAgICAgfVxuICAgICAgR2V0RWxlbWVudHNCeU5hbWVTZXQuYWRkKGVsZW1lbnQpO1xuICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJkYXRhLWVsZW1lbnQtaWRcIiwgaWQpO1xuICAgICAgZWxlbWVudC5kaXNhYmxlZCA9IHRoaXMuZGF0YS5yZWFkT25seTtcbiAgICAgIGVsZW1lbnQubmFtZSA9IHRoaXMuZGF0YS5maWVsZE5hbWU7XG4gICAgICBlbGVtZW50LnRhYkluZGV4ID0gREVGQVVMVF9UQUJfSU5ERVg7XG4gICAgICB0aGlzLl9zZXRSZXF1aXJlZChlbGVtZW50LCB0aGlzLmRhdGEucmVxdWlyZWQpO1xuICAgICAgaWYgKG1heExlbikge1xuICAgICAgICBlbGVtZW50Lm1heExlbmd0aCA9IG1heExlbjtcbiAgICAgIH1cbiAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImlucHV0XCIsIGV2ZW50ID0+IHtcbiAgICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwge1xuICAgICAgICAgIHZhbHVlOiBldmVudC50YXJnZXQudmFsdWVcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc2V0UHJvcGVydHlPblNpYmxpbmdzKGVsZW1lbnQsIFwidmFsdWVcIiwgZXZlbnQudGFyZ2V0LnZhbHVlLCBcInZhbHVlXCIpO1xuICAgICAgICBlbGVtZW50RGF0YS5mb3JtYXR0ZWRWYWx1ZSA9IG51bGw7XG4gICAgICB9KTtcbiAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2V0Zm9ybVwiLCBldmVudCA9PiB7XG4gICAgICAgIGNvbnN0IGRlZmF1bHRWYWx1ZSA9IHRoaXMuZGF0YS5kZWZhdWx0RmllbGRWYWx1ZSA/PyBcIlwiO1xuICAgICAgICBlbGVtZW50LnZhbHVlID0gZWxlbWVudERhdGEudXNlclZhbHVlID0gZGVmYXVsdFZhbHVlO1xuICAgICAgICBlbGVtZW50RGF0YS5mb3JtYXR0ZWRWYWx1ZSA9IG51bGw7XG4gICAgICB9KTtcbiAgICAgIGxldCBibHVyTGlzdGVuZXIgPSBldmVudCA9PiB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBmb3JtYXR0ZWRWYWx1ZVxuICAgICAgICB9ID0gZWxlbWVudERhdGE7XG4gICAgICAgIGlmIChmb3JtYXR0ZWRWYWx1ZSAhPT0gbnVsbCAmJiBmb3JtYXR0ZWRWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgZXZlbnQudGFyZ2V0LnZhbHVlID0gZm9ybWF0dGVkVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZXZlbnQudGFyZ2V0LnNjcm9sbExlZnQgPSAwO1xuICAgICAgfTtcbiAgICAgIGlmICh0aGlzLmVuYWJsZVNjcmlwdGluZyAmJiB0aGlzLmhhc0pTQWN0aW9ucykge1xuICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c1wiLCBldmVudCA9PiB7XG4gICAgICAgICAgaWYgKGVsZW1lbnREYXRhLmZvY3VzZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgdGFyZ2V0XG4gICAgICAgICAgfSA9IGV2ZW50O1xuICAgICAgICAgIGlmIChlbGVtZW50RGF0YS51c2VyVmFsdWUpIHtcbiAgICAgICAgICAgIHRhcmdldC52YWx1ZSA9IGVsZW1lbnREYXRhLnVzZXJWYWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxlbWVudERhdGEubGFzdENvbW1pdHRlZFZhbHVlID0gdGFyZ2V0LnZhbHVlO1xuICAgICAgICAgIGVsZW1lbnREYXRhLmNvbW1pdEtleSA9IDE7XG4gICAgICAgICAgZWxlbWVudERhdGEuZm9jdXNlZCA9IHRydWU7XG4gICAgICAgIH0pO1xuICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ1cGRhdGVmcm9tc2FuZGJveFwiLCBqc0V2ZW50ID0+IHtcbiAgICAgICAgICB0aGlzLnNob3dFbGVtZW50QW5kSGlkZUNhbnZhcyhqc0V2ZW50LnRhcmdldCk7XG4gICAgICAgICAgY29uc3QgYWN0aW9ucyA9IHtcbiAgICAgICAgICAgIHZhbHVlKGV2ZW50KSB7XG4gICAgICAgICAgICAgIGVsZW1lbnREYXRhLnVzZXJWYWx1ZSA9IGV2ZW50LmRldGFpbC52YWx1ZSA/PyBcIlwiO1xuICAgICAgICAgICAgICBzdG9yYWdlLnNldFZhbHVlKGlkLCB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IGVsZW1lbnREYXRhLnVzZXJWYWx1ZS50b1N0cmluZygpXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBldmVudC50YXJnZXQudmFsdWUgPSBlbGVtZW50RGF0YS51c2VyVmFsdWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZm9ybWF0dGVkVmFsdWUoZXZlbnQpIHtcbiAgICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICAgIGZvcm1hdHRlZFZhbHVlXG4gICAgICAgICAgICAgIH0gPSBldmVudC5kZXRhaWw7XG4gICAgICAgICAgICAgIGVsZW1lbnREYXRhLmZvcm1hdHRlZFZhbHVlID0gZm9ybWF0dGVkVmFsdWU7XG4gICAgICAgICAgICAgIGlmIChmb3JtYXR0ZWRWYWx1ZSAhPT0gbnVsbCAmJiBmb3JtYXR0ZWRWYWx1ZSAhPT0gdW5kZWZpbmVkICYmIGV2ZW50LnRhcmdldCAhPT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIGV2ZW50LnRhcmdldC52YWx1ZSA9IGZvcm1hdHRlZFZhbHVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgICAgICAgICBmb3JtYXR0ZWRWYWx1ZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZWxSYW5nZShldmVudCkge1xuICAgICAgICAgICAgICBldmVudC50YXJnZXQuc2V0U2VsZWN0aW9uUmFuZ2UoLi4uZXZlbnQuZGV0YWlsLnNlbFJhbmdlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjaGFyTGltaXQ6IGV2ZW50ID0+IHtcbiAgICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICAgIGNoYXJMaW1pdFxuICAgICAgICAgICAgICB9ID0gZXZlbnQuZGV0YWlsO1xuICAgICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0XG4gICAgICAgICAgICAgIH0gPSBldmVudDtcbiAgICAgICAgICAgICAgaWYgKGNoYXJMaW1pdCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRhcmdldC5yZW1vdmVBdHRyaWJ1dGUoXCJtYXhMZW5ndGhcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRhcmdldC5zZXRBdHRyaWJ1dGUoXCJtYXhMZW5ndGhcIiwgY2hhckxpbWl0KTtcbiAgICAgICAgICAgICAgbGV0IHZhbHVlID0gZWxlbWVudERhdGEudXNlclZhbHVlO1xuICAgICAgICAgICAgICBpZiAoIXZhbHVlIHx8IHZhbHVlLmxlbmd0aCA8PSBjaGFyTGltaXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5zbGljZSgwLCBjaGFyTGltaXQpO1xuICAgICAgICAgICAgICB0YXJnZXQudmFsdWUgPSBlbGVtZW50RGF0YS51c2VyVmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwge1xuICAgICAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB0aGlzLmxpbmtTZXJ2aWNlLmV2ZW50QnVzPy5kaXNwYXRjaChcImRpc3BhdGNoZXZlbnRpbnNhbmRib3hcIiwge1xuICAgICAgICAgICAgICAgIHNvdXJjZTogdGhpcyxcbiAgICAgICAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgICAgbmFtZTogXCJLZXlzdHJva2VcIixcbiAgICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgICAgd2lsbENvbW1pdDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgIGNvbW1pdEtleTogMSxcbiAgICAgICAgICAgICAgICAgIHNlbFN0YXJ0OiB0YXJnZXQuc2VsZWN0aW9uU3RhcnQsXG4gICAgICAgICAgICAgICAgICBzZWxFbmQ6IHRhcmdldC5zZWxlY3Rpb25FbmRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgICAgdGhpcy5fZGlzcGF0Y2hFdmVudEZyb21TYW5kYm94KGFjdGlvbnMsIGpzRXZlbnQpO1xuICAgICAgICB9KTtcbiAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBldmVudCA9PiB7XG4gICAgICAgICAgZWxlbWVudERhdGEuY29tbWl0S2V5ID0gMTtcbiAgICAgICAgICBsZXQgY29tbWl0S2V5ID0gLTE7XG4gICAgICAgICAgaWYgKGV2ZW50LmtleSA9PT0gXCJFc2NhcGVcIikge1xuICAgICAgICAgICAgY29tbWl0S2V5ID0gMDtcbiAgICAgICAgICB9IGVsc2UgaWYgKGV2ZW50LmtleSA9PT0gXCJFbnRlclwiICYmICF0aGlzLmRhdGEubXVsdGlMaW5lKSB7XG4gICAgICAgICAgICBjb21taXRLZXkgPSAyO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZXZlbnQua2V5ID09PSBcIlRhYlwiKSB7XG4gICAgICAgICAgICBlbGVtZW50RGF0YS5jb21taXRLZXkgPSAzO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY29tbWl0S2V5ID09PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgIH0gPSBldmVudC50YXJnZXQ7XG4gICAgICAgICAgaWYgKGVsZW1lbnREYXRhLmxhc3RDb21taXR0ZWRWYWx1ZSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxlbWVudERhdGEubGFzdENvbW1pdHRlZFZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgZWxlbWVudERhdGEudXNlclZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgdGhpcy5saW5rU2VydmljZS5ldmVudEJ1cz8uZGlzcGF0Y2goXCJkaXNwYXRjaGV2ZW50aW5zYW5kYm94XCIsIHtcbiAgICAgICAgICAgIHNvdXJjZTogdGhpcyxcbiAgICAgICAgICAgIGRldGFpbDoge1xuICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgbmFtZTogXCJLZXlzdHJva2VcIixcbiAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgIHdpbGxDb21taXQ6IHRydWUsXG4gICAgICAgICAgICAgIGNvbW1pdEtleSxcbiAgICAgICAgICAgICAgc2VsU3RhcnQ6IGV2ZW50LnRhcmdldC5zZWxlY3Rpb25TdGFydCxcbiAgICAgICAgICAgICAgc2VsRW5kOiBldmVudC50YXJnZXQuc2VsZWN0aW9uRW5kXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBfYmx1ckxpc3RlbmVyID0gYmx1ckxpc3RlbmVyO1xuICAgICAgICBibHVyTGlzdGVuZXIgPSBudWxsO1xuICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJibHVyXCIsIGV2ZW50ID0+IHtcbiAgICAgICAgICBpZiAoIWVsZW1lbnREYXRhLmZvY3VzZWQgfHwgIWV2ZW50LnJlbGF0ZWRUYXJnZXQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxlbWVudERhdGEuZm9jdXNlZCA9IGZhbHNlO1xuICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgfSA9IGV2ZW50LnRhcmdldDtcbiAgICAgICAgICBlbGVtZW50RGF0YS51c2VyVmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICBpZiAoZWxlbWVudERhdGEubGFzdENvbW1pdHRlZFZhbHVlICE9PSB2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5saW5rU2VydmljZS5ldmVudEJ1cz8uZGlzcGF0Y2goXCJkaXNwYXRjaGV2ZW50aW5zYW5kYm94XCIsIHtcbiAgICAgICAgICAgICAgc291cmNlOiB0aGlzLFxuICAgICAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICBuYW1lOiBcIktleXN0cm9rZVwiLFxuICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgIHdpbGxDb21taXQ6IHRydWUsXG4gICAgICAgICAgICAgICAgY29tbWl0S2V5OiBlbGVtZW50RGF0YS5jb21taXRLZXksXG4gICAgICAgICAgICAgICAgc2VsU3RhcnQ6IGV2ZW50LnRhcmdldC5zZWxlY3Rpb25TdGFydCxcbiAgICAgICAgICAgICAgICBzZWxFbmQ6IGV2ZW50LnRhcmdldC5zZWxlY3Rpb25FbmRcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIF9ibHVyTGlzdGVuZXIoZXZlbnQpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHRoaXMuZGF0YS5hY3Rpb25zPy5LZXlzdHJva2UpIHtcbiAgICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJiZWZvcmVpbnB1dFwiLCBldmVudCA9PiB7XG4gICAgICAgICAgICBlbGVtZW50RGF0YS5sYXN0Q29tbWl0dGVkVmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgICB0YXJnZXRcbiAgICAgICAgICAgIH0gPSBldmVudDtcbiAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgIHNlbGVjdGlvblN0YXJ0LFxuICAgICAgICAgICAgICBzZWxlY3Rpb25FbmRcbiAgICAgICAgICAgIH0gPSB0YXJnZXQ7XG4gICAgICAgICAgICBsZXQgc2VsU3RhcnQgPSBzZWxlY3Rpb25TdGFydCxcbiAgICAgICAgICAgICAgc2VsRW5kID0gc2VsZWN0aW9uRW5kO1xuICAgICAgICAgICAgc3dpdGNoIChldmVudC5pbnB1dFR5cGUpIHtcbiAgICAgICAgICAgICAgY2FzZSBcImRlbGV0ZVdvcmRCYWNrd2FyZFwiOlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IG1hdGNoID0gdmFsdWUuc3Vic3RyaW5nKDAsIHNlbGVjdGlvblN0YXJ0KS5tYXRjaCgvXFx3KlteXFx3XSokLyk7XG4gICAgICAgICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsU3RhcnQgLT0gbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjYXNlIFwiZGVsZXRlV29yZEZvcndhcmRcIjpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBtYXRjaCA9IHZhbHVlLnN1YnN0cmluZyhzZWxlY3Rpb25TdGFydCkubWF0Y2goL15bXlxcd10qXFx3Ki8pO1xuICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbEVuZCArPSBtYXRjaFswXS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNhc2UgXCJkZWxldGVDb250ZW50QmFja3dhcmRcIjpcbiAgICAgICAgICAgICAgICBpZiAoc2VsZWN0aW9uU3RhcnQgPT09IHNlbGVjdGlvbkVuZCkge1xuICAgICAgICAgICAgICAgICAgc2VsU3RhcnQgLT0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgXCJkZWxldGVDb250ZW50Rm9yd2FyZFwiOlxuICAgICAgICAgICAgICAgIGlmIChzZWxlY3Rpb25TdGFydCA9PT0gc2VsZWN0aW9uRW5kKSB7XG4gICAgICAgICAgICAgICAgICBzZWxFbmQgKz0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgdGhpcy5saW5rU2VydmljZS5ldmVudEJ1cz8uZGlzcGF0Y2goXCJkaXNwYXRjaGV2ZW50aW5zYW5kYm94XCIsIHtcbiAgICAgICAgICAgICAgc291cmNlOiB0aGlzLFxuICAgICAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICBuYW1lOiBcIktleXN0cm9rZVwiLFxuICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgIGNoYW5nZTogZGF0YSB8fCBcIlwiLFxuICAgICAgICAgICAgICAgIHdpbGxDb21taXQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHNlbFN0YXJ0LFxuICAgICAgICAgICAgICAgIHNlbEVuZFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zZXRFdmVudExpc3RlbmVycyhlbGVtZW50LCBlbGVtZW50RGF0YSwgW1tcImZvY3VzXCIsIFwiRm9jdXNcIl0sIFtcImJsdXJcIiwgXCJCbHVyXCJdLCBbXCJtb3VzZWRvd25cIiwgXCJNb3VzZSBEb3duXCJdLCBbXCJtb3VzZWVudGVyXCIsIFwiTW91c2UgRW50ZXJcIl0sIFtcIm1vdXNlbGVhdmVcIiwgXCJNb3VzZSBFeGl0XCJdLCBbXCJtb3VzZXVwXCIsIFwiTW91c2UgVXBcIl1dLCBldmVudCA9PiBldmVudC50YXJnZXQudmFsdWUpO1xuICAgICAgfVxuICAgICAgaWYgKGJsdXJMaXN0ZW5lcikge1xuICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJibHVyXCIsIGJsdXJMaXN0ZW5lcik7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5kYXRhLmNvbWIpIHtcbiAgICAgICAgY29uc3QgZmllbGRXaWR0aCA9IHRoaXMuZGF0YS5yZWN0WzJdIC0gdGhpcy5kYXRhLnJlY3RbMF07XG4gICAgICAgIGNvbnN0IGNvbWJXaWR0aCA9IGZpZWxkV2lkdGggLyBtYXhMZW47XG4gICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZChcImNvbWJcIik7XG4gICAgICAgIGVsZW1lbnQuc3R5bGUubGV0dGVyU3BhY2luZyA9IGBjYWxjKCR7Y29tYldpZHRofXB4ICogdmFyKC0tc2NhbGUtZmFjdG9yKSAtIDFjaClgO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIGVsZW1lbnQudGV4dENvbnRlbnQgPSB0aGlzLmRhdGEuZmllbGRWYWx1ZTtcbiAgICAgIGVsZW1lbnQuc3R5bGUudmVydGljYWxBbGlnbiA9IFwibWlkZGxlXCI7XG4gICAgICBlbGVtZW50LnN0eWxlLmRpc3BsYXkgPSBcInRhYmxlLWNlbGxcIjtcbiAgICB9XG4gICAgdGhpcy5fc2V0VGV4dFN0eWxlKGVsZW1lbnQpO1xuICAgIHRoaXMuX3NldEJhY2tncm91bmRDb2xvcihlbGVtZW50KTtcbiAgICB0aGlzLl9zZXREZWZhdWx0UHJvcGVydGllc0Zyb21KUyhlbGVtZW50KTtcbiAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmQoZWxlbWVudCk7XG4gICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICB9XG59XG5jbGFzcyBTaWduYXR1cmVXaWRnZXRBbm5vdGF0aW9uRWxlbWVudCBleHRlbmRzIFdpZGdldEFubm90YXRpb25FbGVtZW50IHtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVycykge1xuICAgIHN1cGVyKHBhcmFtZXRlcnMsIHtcbiAgICAgIGlzUmVuZGVyYWJsZTogISFwYXJhbWV0ZXJzLmRhdGEuaGFzT3duQ2FudmFzXG4gICAgfSk7XG4gIH1cbn1cbmNsYXNzIENoZWNrYm94V2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBXaWRnZXRBbm5vdGF0aW9uRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcbiAgICBzdXBlcihwYXJhbWV0ZXJzLCB7XG4gICAgICBpc1JlbmRlcmFibGU6IHBhcmFtZXRlcnMucmVuZGVyRm9ybXNcbiAgICB9KTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgY29uc3Qgc3RvcmFnZSA9IHRoaXMuYW5ub3RhdGlvblN0b3JhZ2U7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICBjb25zdCBpZCA9IGRhdGEuaWQ7XG4gICAgbGV0IHZhbHVlID0gc3RvcmFnZS5nZXRWYWx1ZShpZCwge1xuICAgICAgdmFsdWU6IGRhdGEuZXhwb3J0VmFsdWUgPT09IGRhdGEuZmllbGRWYWx1ZVxuICAgIH0pLnZhbHVlO1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHZhbHVlID0gdmFsdWUgIT09IFwiT2ZmXCI7XG4gICAgICBzdG9yYWdlLnNldFZhbHVlKGlkLCB7XG4gICAgICAgIHZhbHVlXG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChcImJ1dHRvbldpZGdldEFubm90YXRpb25cIiwgXCJjaGVja0JveFwiKTtcbiAgICBjb25zdCBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO1xuICAgIEdldEVsZW1lbnRzQnlOYW1lU2V0LmFkZChlbGVtZW50KTtcbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShcImRhdGEtZWxlbWVudC1pZFwiLCBpZCk7XG4gICAgZWxlbWVudC5kaXNhYmxlZCA9IGRhdGEucmVhZE9ubHk7XG4gICAgdGhpcy5fc2V0UmVxdWlyZWQoZWxlbWVudCwgdGhpcy5kYXRhLnJlcXVpcmVkKTtcbiAgICBlbGVtZW50LnR5cGUgPSBcImNoZWNrYm94XCI7XG4gICAgZWxlbWVudC5uYW1lID0gZGF0YS5maWVsZE5hbWU7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShcImNoZWNrZWRcIiwgdHJ1ZSk7XG4gICAgfVxuICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKFwiZXhwb3J0VmFsdWVcIiwgZGF0YS5leHBvcnRWYWx1ZSk7XG4gICAgZWxlbWVudC50YWJJbmRleCA9IERFRkFVTFRfVEFCX0lOREVYO1xuICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCBldmVudCA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIG5hbWUsXG4gICAgICAgIGNoZWNrZWRcbiAgICAgIH0gPSBldmVudC50YXJnZXQ7XG4gICAgICBmb3IgKGNvbnN0IGNoZWNrYm94IG9mIHRoaXMuX2dldEVsZW1lbnRzQnlOYW1lKG5hbWUsIGlkKSkge1xuICAgICAgICBjb25zdCBjdXJDaGVja2VkID0gY2hlY2tlZCAmJiBjaGVja2JveC5leHBvcnRWYWx1ZSA9PT0gZGF0YS5leHBvcnRWYWx1ZTtcbiAgICAgICAgaWYgKGNoZWNrYm94LmRvbUVsZW1lbnQpIHtcbiAgICAgICAgICBjaGVja2JveC5kb21FbGVtZW50LmNoZWNrZWQgPSBjdXJDaGVja2VkO1xuICAgICAgICB9XG4gICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoY2hlY2tib3guaWQsIHtcbiAgICAgICAgICB2YWx1ZTogY3VyQ2hlY2tlZFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgdmFsdWU6IGNoZWNrZWRcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2V0Zm9ybVwiLCBldmVudCA9PiB7XG4gICAgICBjb25zdCBkZWZhdWx0VmFsdWUgPSBkYXRhLmRlZmF1bHRGaWVsZFZhbHVlIHx8IFwiT2ZmXCI7XG4gICAgICBldmVudC50YXJnZXQuY2hlY2tlZCA9IGRlZmF1bHRWYWx1ZSA9PT0gZGF0YS5leHBvcnRWYWx1ZTtcbiAgICB9KTtcbiAgICBpZiAodGhpcy5lbmFibGVTY3JpcHRpbmcgJiYgdGhpcy5oYXNKU0FjdGlvbnMpIHtcbiAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInVwZGF0ZWZyb21zYW5kYm94XCIsIGpzRXZlbnQgPT4ge1xuICAgICAgICBjb25zdCBhY3Rpb25zID0ge1xuICAgICAgICAgIHZhbHVlKGV2ZW50KSB7XG4gICAgICAgICAgICBldmVudC50YXJnZXQuY2hlY2tlZCA9IGV2ZW50LmRldGFpbC52YWx1ZSAhPT0gXCJPZmZcIjtcbiAgICAgICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IGV2ZW50LnRhcmdldC5jaGVja2VkXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX2Rpc3BhdGNoRXZlbnRGcm9tU2FuZGJveChhY3Rpb25zLCBqc0V2ZW50KTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5fc2V0RXZlbnRMaXN0ZW5lcnMoZWxlbWVudCwgbnVsbCwgW1tcImNoYW5nZVwiLCBcIlZhbGlkYXRlXCJdLCBbXCJjaGFuZ2VcIiwgXCJBY3Rpb25cIl0sIFtcImZvY3VzXCIsIFwiRm9jdXNcIl0sIFtcImJsdXJcIiwgXCJCbHVyXCJdLCBbXCJtb3VzZWRvd25cIiwgXCJNb3VzZSBEb3duXCJdLCBbXCJtb3VzZWVudGVyXCIsIFwiTW91c2UgRW50ZXJcIl0sIFtcIm1vdXNlbGVhdmVcIiwgXCJNb3VzZSBFeGl0XCJdLCBbXCJtb3VzZXVwXCIsIFwiTW91c2UgVXBcIl1dLCBldmVudCA9PiBldmVudC50YXJnZXQuY2hlY2tlZCk7XG4gICAgfVxuICAgIHRoaXMuX3NldEJhY2tncm91bmRDb2xvcihlbGVtZW50KTtcbiAgICB0aGlzLl9zZXREZWZhdWx0UHJvcGVydGllc0Zyb21KUyhlbGVtZW50KTtcbiAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmQoZWxlbWVudCk7XG4gICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICB9XG59XG5jbGFzcyBSYWRpb0J1dHRvbldpZGdldEFubm90YXRpb25FbGVtZW50IGV4dGVuZHMgV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgc3VwZXIocGFyYW1ldGVycywge1xuICAgICAgaXNSZW5kZXJhYmxlOiBwYXJhbWV0ZXJzLnJlbmRlckZvcm1zXG4gICAgfSk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJidXR0b25XaWRnZXRBbm5vdGF0aW9uXCIsIFwicmFkaW9CdXR0b25cIik7XG4gICAgY29uc3Qgc3RvcmFnZSA9IHRoaXMuYW5ub3RhdGlvblN0b3JhZ2U7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICBjb25zdCBpZCA9IGRhdGEuaWQ7XG4gICAgbGV0IHZhbHVlID0gc3RvcmFnZS5nZXRWYWx1ZShpZCwge1xuICAgICAgdmFsdWU6IGRhdGEuZmllbGRWYWx1ZSA9PT0gZGF0YS5idXR0b25WYWx1ZVxuICAgIH0pLnZhbHVlO1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHZhbHVlID0gdmFsdWUgIT09IGRhdGEuYnV0dG9uVmFsdWU7XG4gICAgICBzdG9yYWdlLnNldFZhbHVlKGlkLCB7XG4gICAgICAgIHZhbHVlXG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtcbiAgICBHZXRFbGVtZW50c0J5TmFtZVNldC5hZGQoZWxlbWVudCk7XG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJkYXRhLWVsZW1lbnQtaWRcIiwgaWQpO1xuICAgIGVsZW1lbnQuZGlzYWJsZWQgPSBkYXRhLnJlYWRPbmx5O1xuICAgIHRoaXMuX3NldFJlcXVpcmVkKGVsZW1lbnQsIHRoaXMuZGF0YS5yZXF1aXJlZCk7XG4gICAgZWxlbWVudC50eXBlID0gXCJyYWRpb1wiO1xuICAgIGVsZW1lbnQubmFtZSA9IGRhdGEuZmllbGROYW1lO1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJjaGVja2VkXCIsIHRydWUpO1xuICAgIH1cbiAgICBlbGVtZW50LnRhYkluZGV4ID0gREVGQVVMVF9UQUJfSU5ERVg7XG4gICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIGV2ZW50ID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbmFtZSxcbiAgICAgICAgY2hlY2tlZFxuICAgICAgfSA9IGV2ZW50LnRhcmdldDtcbiAgICAgIGZvciAoY29uc3QgcmFkaW8gb2YgdGhpcy5fZ2V0RWxlbWVudHNCeU5hbWUobmFtZSwgaWQpKSB7XG4gICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUocmFkaW8uaWQsIHtcbiAgICAgICAgICB2YWx1ZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBzdG9yYWdlLnNldFZhbHVlKGlkLCB7XG4gICAgICAgIHZhbHVlOiBjaGVja2VkXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNldGZvcm1cIiwgZXZlbnQgPT4ge1xuICAgICAgY29uc3QgZGVmYXVsdFZhbHVlID0gZGF0YS5kZWZhdWx0RmllbGRWYWx1ZTtcbiAgICAgIGV2ZW50LnRhcmdldC5jaGVja2VkID0gZGVmYXVsdFZhbHVlICE9PSBudWxsICYmIGRlZmF1bHRWYWx1ZSAhPT0gdW5kZWZpbmVkICYmIGRlZmF1bHRWYWx1ZSA9PT0gZGF0YS5idXR0b25WYWx1ZTtcbiAgICB9KTtcbiAgICBpZiAodGhpcy5lbmFibGVTY3JpcHRpbmcgJiYgdGhpcy5oYXNKU0FjdGlvbnMpIHtcbiAgICAgIGNvbnN0IHBkZkJ1dHRvblZhbHVlID0gZGF0YS5idXR0b25WYWx1ZTtcbiAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInVwZGF0ZWZyb21zYW5kYm94XCIsIGpzRXZlbnQgPT4ge1xuICAgICAgICBjb25zdCBhY3Rpb25zID0ge1xuICAgICAgICAgIHZhbHVlOiBldmVudCA9PiB7XG4gICAgICAgICAgICBjb25zdCBjaGVja2VkID0gcGRmQnV0dG9uVmFsdWUgPT09IGV2ZW50LmRldGFpbC52YWx1ZTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcmFkaW8gb2YgdGhpcy5fZ2V0RWxlbWVudHNCeU5hbWUoZXZlbnQudGFyZ2V0Lm5hbWUpKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGN1ckNoZWNrZWQgPSBjaGVja2VkICYmIHJhZGlvLmlkID09PSBpZDtcbiAgICAgICAgICAgICAgaWYgKHJhZGlvLmRvbUVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICByYWRpby5kb21FbGVtZW50LmNoZWNrZWQgPSBjdXJDaGVja2VkO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUocmFkaW8uaWQsIHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogY3VyQ2hlY2tlZFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX2Rpc3BhdGNoRXZlbnRGcm9tU2FuZGJveChhY3Rpb25zLCBqc0V2ZW50KTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5fc2V0RXZlbnRMaXN0ZW5lcnMoZWxlbWVudCwgbnVsbCwgW1tcImNoYW5nZVwiLCBcIlZhbGlkYXRlXCJdLCBbXCJjaGFuZ2VcIiwgXCJBY3Rpb25cIl0sIFtcImZvY3VzXCIsIFwiRm9jdXNcIl0sIFtcImJsdXJcIiwgXCJCbHVyXCJdLCBbXCJtb3VzZWRvd25cIiwgXCJNb3VzZSBEb3duXCJdLCBbXCJtb3VzZWVudGVyXCIsIFwiTW91c2UgRW50ZXJcIl0sIFtcIm1vdXNlbGVhdmVcIiwgXCJNb3VzZSBFeGl0XCJdLCBbXCJtb3VzZXVwXCIsIFwiTW91c2UgVXBcIl1dLCBldmVudCA9PiBldmVudC50YXJnZXQuY2hlY2tlZCk7XG4gICAgfVxuICAgIHRoaXMuX3NldEJhY2tncm91bmRDb2xvcihlbGVtZW50KTtcbiAgICB0aGlzLl9zZXREZWZhdWx0UHJvcGVydGllc0Zyb21KUyhlbGVtZW50KTtcbiAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmQoZWxlbWVudCk7XG4gICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICB9XG59XG5jbGFzcyBQdXNoQnV0dG9uV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBMaW5rQW5ub3RhdGlvbkVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgc3VwZXIocGFyYW1ldGVycywge1xuICAgICAgaWdub3JlQm9yZGVyOiBwYXJhbWV0ZXJzLmRhdGEuaGFzQXBwZWFyYW5jZVxuICAgIH0pO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCBjb250YWluZXIgPSBzdXBlci5yZW5kZXIoKTtcbiAgICBjb250YWluZXIuY2xhc3NMaXN0LmFkZChcImJ1dHRvbldpZGdldEFubm90YXRpb25cIiwgXCJwdXNoQnV0dG9uXCIpO1xuICAgIGlmICh0aGlzLmRhdGEuYWx0ZXJuYXRpdmVUZXh0KSB7XG4gICAgICBjb250YWluZXIudGl0bGUgPSB0aGlzLmRhdGEuYWx0ZXJuYXRpdmVUZXh0O1xuICAgIH1cbiAgICBjb25zdCBsaW5rRWxlbWVudCA9IGNvbnRhaW5lci5sYXN0Q2hpbGQ7XG4gICAgaWYgKHRoaXMuZW5hYmxlU2NyaXB0aW5nICYmIHRoaXMuaGFzSlNBY3Rpb25zICYmIGxpbmtFbGVtZW50KSB7XG4gICAgICB0aGlzLl9zZXREZWZhdWx0UHJvcGVydGllc0Zyb21KUyhsaW5rRWxlbWVudCk7XG4gICAgICBsaW5rRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwidXBkYXRlZnJvbXNhbmRib3hcIiwganNFdmVudCA9PiB7XG4gICAgICAgIHRoaXMuX2Rpc3BhdGNoRXZlbnRGcm9tU2FuZGJveCh7fSwganNFdmVudCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbnRhaW5lcjtcbiAgfVxufVxuY2xhc3MgQ2hvaWNlV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBXaWRnZXRBbm5vdGF0aW9uRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcbiAgICBzdXBlcihwYXJhbWV0ZXJzLCB7XG4gICAgICBpc1JlbmRlcmFibGU6IHBhcmFtZXRlcnMucmVuZGVyRm9ybXNcbiAgICB9KTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChcImNob2ljZVdpZGdldEFubm90YXRpb25cIik7XG4gICAgY29uc3Qgc3RvcmFnZSA9IHRoaXMuYW5ub3RhdGlvblN0b3JhZ2U7XG4gICAgY29uc3QgaWQgPSB0aGlzLmRhdGEuaWQ7XG4gICAgY29uc3Qgc3RvcmVkRGF0YSA9IHN0b3JhZ2UuZ2V0VmFsdWUoaWQsIHtcbiAgICAgIHZhbHVlOiB0aGlzLmRhdGEuZmllbGRWYWx1ZVxuICAgIH0pO1xuICAgIGNvbnN0IHNlbGVjdEVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic2VsZWN0XCIpO1xuICAgIEdldEVsZW1lbnRzQnlOYW1lU2V0LmFkZChzZWxlY3RFbGVtZW50KTtcbiAgICBzZWxlY3RFbGVtZW50LnNldEF0dHJpYnV0ZShcImRhdGEtZWxlbWVudC1pZFwiLCBpZCk7XG4gICAgc2VsZWN0RWxlbWVudC5kaXNhYmxlZCA9IHRoaXMuZGF0YS5yZWFkT25seTtcbiAgICB0aGlzLl9zZXRSZXF1aXJlZChzZWxlY3RFbGVtZW50LCB0aGlzLmRhdGEucmVxdWlyZWQpO1xuICAgIHNlbGVjdEVsZW1lbnQubmFtZSA9IHRoaXMuZGF0YS5maWVsZE5hbWU7XG4gICAgc2VsZWN0RWxlbWVudC50YWJJbmRleCA9IERFRkFVTFRfVEFCX0lOREVYO1xuICAgIGxldCBhZGRBbkVtcHR5RW50cnkgPSB0aGlzLmRhdGEuY29tYm8gJiYgdGhpcy5kYXRhLm9wdGlvbnMubGVuZ3RoID4gMDtcbiAgICBpZiAoIXRoaXMuZGF0YS5jb21ibykge1xuICAgICAgc2VsZWN0RWxlbWVudC5zaXplID0gdGhpcy5kYXRhLm9wdGlvbnMubGVuZ3RoO1xuICAgICAgaWYgKHRoaXMuZGF0YS5tdWx0aVNlbGVjdCkge1xuICAgICAgICBzZWxlY3RFbGVtZW50Lm11bHRpcGxlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgc2VsZWN0RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwicmVzZXRmb3JtXCIsIGV2ZW50ID0+IHtcbiAgICAgIGNvbnN0IGRlZmF1bHRWYWx1ZSA9IHRoaXMuZGF0YS5kZWZhdWx0RmllbGRWYWx1ZTtcbiAgICAgIGZvciAoY29uc3Qgb3B0aW9uIG9mIHNlbGVjdEVsZW1lbnQub3B0aW9ucykge1xuICAgICAgICBvcHRpb24uc2VsZWN0ZWQgPSBvcHRpb24udmFsdWUgPT09IGRlZmF1bHRWYWx1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBmb3IgKGNvbnN0IG9wdGlvbiBvZiB0aGlzLmRhdGEub3B0aW9ucykge1xuICAgICAgY29uc3Qgb3B0aW9uRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJvcHRpb25cIik7XG4gICAgICBvcHRpb25FbGVtZW50LnRleHRDb250ZW50ID0gb3B0aW9uLmRpc3BsYXlWYWx1ZTtcbiAgICAgIG9wdGlvbkVsZW1lbnQudmFsdWUgPSBvcHRpb24uZXhwb3J0VmFsdWU7XG4gICAgICBpZiAoc3RvcmVkRGF0YS52YWx1ZS5pbmNsdWRlcyhvcHRpb24uZXhwb3J0VmFsdWUpKSB7XG4gICAgICAgIG9wdGlvbkVsZW1lbnQuc2V0QXR0cmlidXRlKFwic2VsZWN0ZWRcIiwgdHJ1ZSk7XG4gICAgICAgIGFkZEFuRW1wdHlFbnRyeSA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgc2VsZWN0RWxlbWVudC5hcHBlbmQob3B0aW9uRWxlbWVudCk7XG4gICAgfVxuICAgIGxldCByZW1vdmVFbXB0eUVudHJ5ID0gbnVsbDtcbiAgICBpZiAoYWRkQW5FbXB0eUVudHJ5KSB7XG4gICAgICBjb25zdCBub25lT3B0aW9uRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJvcHRpb25cIik7XG4gICAgICBub25lT3B0aW9uRWxlbWVudC52YWx1ZSA9IFwiIFwiO1xuICAgICAgbm9uZU9wdGlvbkVsZW1lbnQuc2V0QXR0cmlidXRlKFwiaGlkZGVuXCIsIHRydWUpO1xuICAgICAgbm9uZU9wdGlvbkVsZW1lbnQuc2V0QXR0cmlidXRlKFwic2VsZWN0ZWRcIiwgdHJ1ZSk7XG4gICAgICBzZWxlY3RFbGVtZW50LnByZXBlbmQobm9uZU9wdGlvbkVsZW1lbnQpO1xuICAgICAgcmVtb3ZlRW1wdHlFbnRyeSA9ICgpID0+IHtcbiAgICAgICAgbm9uZU9wdGlvbkVsZW1lbnQucmVtb3ZlKCk7XG4gICAgICAgIHNlbGVjdEVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImlucHV0XCIsIHJlbW92ZUVtcHR5RW50cnkpO1xuICAgICAgICByZW1vdmVFbXB0eUVudHJ5ID0gbnVsbDtcbiAgICAgIH07XG4gICAgICBzZWxlY3RFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJpbnB1dFwiLCByZW1vdmVFbXB0eUVudHJ5KTtcbiAgICB9XG4gICAgY29uc3QgZ2V0VmFsdWUgPSBpc0V4cG9ydCA9PiB7XG4gICAgICBjb25zdCBuYW1lID0gaXNFeHBvcnQgPyBcInZhbHVlXCIgOiBcInRleHRDb250ZW50XCI7XG4gICAgICBjb25zdCB7XG4gICAgICAgIG9wdGlvbnMsXG4gICAgICAgIG11bHRpcGxlXG4gICAgICB9ID0gc2VsZWN0RWxlbWVudDtcbiAgICAgIGlmICghbXVsdGlwbGUpIHtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnMuc2VsZWN0ZWRJbmRleCA9PT0gLTEgPyBudWxsIDogb3B0aW9uc1tvcHRpb25zLnNlbGVjdGVkSW5kZXhdW25hbWVdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5maWx0ZXIuY2FsbChvcHRpb25zLCBvcHRpb24gPT4gb3B0aW9uLnNlbGVjdGVkKS5tYXAob3B0aW9uID0+IG9wdGlvbltuYW1lXSk7XG4gICAgfTtcbiAgICBsZXQgc2VsZWN0ZWRWYWx1ZXMgPSBnZXRWYWx1ZShmYWxzZSk7XG4gICAgY29uc3QgZ2V0SXRlbXMgPSBldmVudCA9PiB7XG4gICAgICBjb25zdCBvcHRpb25zID0gZXZlbnQudGFyZ2V0Lm9wdGlvbnM7XG4gICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLm1hcC5jYWxsKG9wdGlvbnMsIG9wdGlvbiA9PiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZGlzcGxheVZhbHVlOiBvcHRpb24udGV4dENvbnRlbnQsXG4gICAgICAgICAgZXhwb3J0VmFsdWU6IG9wdGlvbi52YWx1ZVxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBpZiAodGhpcy5lbmFibGVTY3JpcHRpbmcgJiYgdGhpcy5oYXNKU0FjdGlvbnMpIHtcbiAgICAgIHNlbGVjdEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInVwZGF0ZWZyb21zYW5kYm94XCIsIGpzRXZlbnQgPT4ge1xuICAgICAgICBjb25zdCBhY3Rpb25zID0ge1xuICAgICAgICAgIHZhbHVlKGV2ZW50KSB7XG4gICAgICAgICAgICByZW1vdmVFbXB0eUVudHJ5Py4oKTtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gZXZlbnQuZGV0YWlsLnZhbHVlO1xuICAgICAgICAgICAgY29uc3QgdmFsdWVzID0gbmV3IFNldChBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlIDogW3ZhbHVlXSk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IG9wdGlvbiBvZiBzZWxlY3RFbGVtZW50Lm9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgb3B0aW9uLnNlbGVjdGVkID0gdmFsdWVzLmhhcyhvcHRpb24udmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwge1xuICAgICAgICAgICAgICB2YWx1ZTogZ2V0VmFsdWUodHJ1ZSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2VsZWN0ZWRWYWx1ZXMgPSBnZXRWYWx1ZShmYWxzZSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBtdWx0aXBsZVNlbGVjdGlvbihldmVudCkge1xuICAgICAgICAgICAgc2VsZWN0RWxlbWVudC5tdWx0aXBsZSA9IHRydWU7XG4gICAgICAgICAgfSxcbiAgICAgICAgICByZW1vdmUoZXZlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IG9wdGlvbnMgPSBzZWxlY3RFbGVtZW50Lm9wdGlvbnM7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IGV2ZW50LmRldGFpbC5yZW1vdmU7XG4gICAgICAgICAgICBvcHRpb25zW2luZGV4XS5zZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgICAgICAgc2VsZWN0RWxlbWVudC5yZW1vdmUoaW5kZXgpO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICBjb25zdCBpID0gQXJyYXkucHJvdG90eXBlLmZpbmRJbmRleC5jYWxsKG9wdGlvbnMsIG9wdGlvbiA9PiBvcHRpb24uc2VsZWN0ZWQpO1xuICAgICAgICAgICAgICBpZiAoaSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zWzBdLnNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwge1xuICAgICAgICAgICAgICB2YWx1ZTogZ2V0VmFsdWUodHJ1ZSksXG4gICAgICAgICAgICAgIGl0ZW1zOiBnZXRJdGVtcyhldmVudClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2VsZWN0ZWRWYWx1ZXMgPSBnZXRWYWx1ZShmYWxzZSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBjbGVhcihldmVudCkge1xuICAgICAgICAgICAgd2hpbGUgKHNlbGVjdEVsZW1lbnQubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICAgIHNlbGVjdEVsZW1lbnQucmVtb3ZlKDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwge1xuICAgICAgICAgICAgICB2YWx1ZTogbnVsbCxcbiAgICAgICAgICAgICAgaXRlbXM6IFtdXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNlbGVjdGVkVmFsdWVzID0gZ2V0VmFsdWUoZmFsc2UpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgaW5zZXJ0KGV2ZW50KSB7XG4gICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgIGluZGV4LFxuICAgICAgICAgICAgICBkaXNwbGF5VmFsdWUsXG4gICAgICAgICAgICAgIGV4cG9ydFZhbHVlXG4gICAgICAgICAgICB9ID0gZXZlbnQuZGV0YWlsLmluc2VydDtcbiAgICAgICAgICAgIGNvbnN0IHNlbGVjdENoaWxkID0gc2VsZWN0RWxlbWVudC5jaGlsZHJlbltpbmRleF07XG4gICAgICAgICAgICBjb25zdCBvcHRpb25FbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIm9wdGlvblwiKTtcbiAgICAgICAgICAgIG9wdGlvbkVsZW1lbnQudGV4dENvbnRlbnQgPSBkaXNwbGF5VmFsdWU7XG4gICAgICAgICAgICBvcHRpb25FbGVtZW50LnZhbHVlID0gZXhwb3J0VmFsdWU7XG4gICAgICAgICAgICBpZiAoc2VsZWN0Q2hpbGQpIHtcbiAgICAgICAgICAgICAgc2VsZWN0Q2hpbGQuYmVmb3JlKG9wdGlvbkVsZW1lbnQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc2VsZWN0RWxlbWVudC5hcHBlbmQob3B0aW9uRWxlbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdG9yYWdlLnNldFZhbHVlKGlkLCB7XG4gICAgICAgICAgICAgIHZhbHVlOiBnZXRWYWx1ZSh0cnVlKSxcbiAgICAgICAgICAgICAgaXRlbXM6IGdldEl0ZW1zKGV2ZW50KVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzZWxlY3RlZFZhbHVlcyA9IGdldFZhbHVlKGZhbHNlKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGl0ZW1zKGV2ZW50KSB7XG4gICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgIGl0ZW1zXG4gICAgICAgICAgICB9ID0gZXZlbnQuZGV0YWlsO1xuICAgICAgICAgICAgd2hpbGUgKHNlbGVjdEVsZW1lbnQubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICAgIHNlbGVjdEVsZW1lbnQucmVtb3ZlKDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIGl0ZW1zKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgICBkaXNwbGF5VmFsdWUsXG4gICAgICAgICAgICAgICAgZXhwb3J0VmFsdWVcbiAgICAgICAgICAgICAgfSA9IGl0ZW07XG4gICAgICAgICAgICAgIGNvbnN0IG9wdGlvbkVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwib3B0aW9uXCIpO1xuICAgICAgICAgICAgICBvcHRpb25FbGVtZW50LnRleHRDb250ZW50ID0gZGlzcGxheVZhbHVlO1xuICAgICAgICAgICAgICBvcHRpb25FbGVtZW50LnZhbHVlID0gZXhwb3J0VmFsdWU7XG4gICAgICAgICAgICAgIHNlbGVjdEVsZW1lbnQuYXBwZW5kKG9wdGlvbkVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNlbGVjdEVsZW1lbnQub3B0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIHNlbGVjdEVsZW1lbnQub3B0aW9uc1swXS5zZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdG9yYWdlLnNldFZhbHVlKGlkLCB7XG4gICAgICAgICAgICAgIHZhbHVlOiBnZXRWYWx1ZSh0cnVlKSxcbiAgICAgICAgICAgICAgaXRlbXM6IGdldEl0ZW1zKGV2ZW50KVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzZWxlY3RlZFZhbHVlcyA9IGdldFZhbHVlKGZhbHNlKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGluZGljZXMoZXZlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IGluZGljZXMgPSBuZXcgU2V0KGV2ZW50LmRldGFpbC5pbmRpY2VzKTtcbiAgICAgICAgICAgIGZvciAoY29uc3Qgb3B0aW9uIG9mIGV2ZW50LnRhcmdldC5vcHRpb25zKSB7XG4gICAgICAgICAgICAgIG9wdGlvbi5zZWxlY3RlZCA9IGluZGljZXMuaGFzKG9wdGlvbi5pbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdG9yYWdlLnNldFZhbHVlKGlkLCB7XG4gICAgICAgICAgICAgIHZhbHVlOiBnZXRWYWx1ZSh0cnVlKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzZWxlY3RlZFZhbHVlcyA9IGdldFZhbHVlKGZhbHNlKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGVkaXRhYmxlKGV2ZW50KSB7XG4gICAgICAgICAgICBldmVudC50YXJnZXQuZGlzYWJsZWQgPSAhZXZlbnQuZGV0YWlsLmVkaXRhYmxlO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fZGlzcGF0Y2hFdmVudEZyb21TYW5kYm94KGFjdGlvbnMsIGpzRXZlbnQpO1xuICAgICAgfSk7XG4gICAgICBzZWxlY3RFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJpbnB1dFwiLCBldmVudCA9PiB7XG4gICAgICAgIGNvbnN0IGV4cG9ydFZhbHVlID0gZ2V0VmFsdWUodHJ1ZSk7XG4gICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgICB2YWx1ZTogZXhwb3J0VmFsdWVcbiAgICAgICAgfSk7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHRoaXMubGlua1NlcnZpY2UuZXZlbnRCdXM/LmRpc3BhdGNoKFwiZGlzcGF0Y2hldmVudGluc2FuZGJveFwiLCB7XG4gICAgICAgICAgc291cmNlOiB0aGlzLFxuICAgICAgICAgIGRldGFpbDoge1xuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICBuYW1lOiBcIktleXN0cm9rZVwiLFxuICAgICAgICAgICAgdmFsdWU6IHNlbGVjdGVkVmFsdWVzLFxuICAgICAgICAgICAgY2hhbmdlRXg6IGV4cG9ydFZhbHVlLFxuICAgICAgICAgICAgd2lsbENvbW1pdDogZmFsc2UsXG4gICAgICAgICAgICBjb21taXRLZXk6IDEsXG4gICAgICAgICAgICBrZXlEb3duOiBmYWxzZVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuX3NldEV2ZW50TGlzdGVuZXJzKHNlbGVjdEVsZW1lbnQsIG51bGwsIFtbXCJmb2N1c1wiLCBcIkZvY3VzXCJdLCBbXCJibHVyXCIsIFwiQmx1clwiXSwgW1wibW91c2Vkb3duXCIsIFwiTW91c2UgRG93blwiXSwgW1wibW91c2VlbnRlclwiLCBcIk1vdXNlIEVudGVyXCJdLCBbXCJtb3VzZWxlYXZlXCIsIFwiTW91c2UgRXhpdFwiXSwgW1wibW91c2V1cFwiLCBcIk1vdXNlIFVwXCJdLCBbXCJpbnB1dFwiLCBcIkFjdGlvblwiXSwgW1wiaW5wdXRcIiwgXCJWYWxpZGF0ZVwiXV0sIGV2ZW50ID0+IGV2ZW50LnRhcmdldC52YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlbGVjdEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImlucHV0XCIsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBzdG9yYWdlLnNldFZhbHVlKGlkLCB7XG4gICAgICAgICAgdmFsdWU6IGdldFZhbHVlKHRydWUpXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICh0aGlzLmRhdGEuY29tYm8pIHtcbiAgICAgIHRoaXMuX3NldFRleHRTdHlsZShzZWxlY3RFbGVtZW50KTtcbiAgICB9IGVsc2Uge31cbiAgICB0aGlzLl9zZXRCYWNrZ3JvdW5kQ29sb3Ioc2VsZWN0RWxlbWVudCk7XG4gICAgdGhpcy5fc2V0RGVmYXVsdFByb3BlcnRpZXNGcm9tSlMoc2VsZWN0RWxlbWVudCk7XG4gICAgdGhpcy5jb250YWluZXIuYXBwZW5kKHNlbGVjdEVsZW1lbnQpO1xuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgfVxufVxuY2xhc3MgUG9wdXBBbm5vdGF0aW9uRWxlbWVudCBleHRlbmRzIEFubm90YXRpb25FbGVtZW50IHtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVycykge1xuICAgIGNvbnN0IHtcbiAgICAgIGRhdGEsXG4gICAgICBlbGVtZW50c1xuICAgIH0gPSBwYXJhbWV0ZXJzO1xuICAgIHN1cGVyKHBhcmFtZXRlcnMsIHtcbiAgICAgIGlzUmVuZGVyYWJsZTogQW5ub3RhdGlvbkVsZW1lbnQuX2hhc1BvcHVwRGF0YShkYXRhKVxuICAgIH0pO1xuICAgIHRoaXMuZWxlbWVudHMgPSBlbGVtZW50cztcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChcInBvcHVwQW5ub3RhdGlvblwiKTtcbiAgICBjb25zdCBwb3B1cCA9IG5ldyBQb3B1cEVsZW1lbnQoe1xuICAgICAgY29udGFpbmVyOiB0aGlzLmNvbnRhaW5lcixcbiAgICAgIGNvbG9yOiB0aGlzLmRhdGEuY29sb3IsXG4gICAgICB0aXRsZU9iajogdGhpcy5kYXRhLnRpdGxlT2JqLFxuICAgICAgbW9kaWZpY2F0aW9uRGF0ZTogdGhpcy5kYXRhLm1vZGlmaWNhdGlvbkRhdGUsXG4gICAgICBjb250ZW50c09iajogdGhpcy5kYXRhLmNvbnRlbnRzT2JqLFxuICAgICAgcmljaFRleHQ6IHRoaXMuZGF0YS5yaWNoVGV4dCxcbiAgICAgIHJlY3Q6IHRoaXMuZGF0YS5yZWN0LFxuICAgICAgcGFyZW50UmVjdDogdGhpcy5kYXRhLnBhcmVudFJlY3QgfHwgbnVsbCxcbiAgICAgIHBhcmVudDogdGhpcy5wYXJlbnQsXG4gICAgICBlbGVtZW50czogdGhpcy5lbGVtZW50cyxcbiAgICAgIG9wZW46IHRoaXMuZGF0YS5vcGVuXG4gICAgfSk7XG4gICAgY29uc3QgZWxlbWVudElkcyA9IFtdO1xuICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiB0aGlzLmVsZW1lbnRzKSB7XG4gICAgICBlbGVtZW50LnBvcHVwID0gcG9wdXA7XG4gICAgICBlbGVtZW50SWRzLnB1c2goZWxlbWVudC5kYXRhLmlkKTtcbiAgICAgIGVsZW1lbnQuYWRkSGlnaGxpZ2h0QXJlYSgpO1xuICAgIH1cbiAgICB0aGlzLmNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoXCJhcmlhLWNvbnRyb2xzXCIsIGVsZW1lbnRJZHMubWFwKGlkID0+IGAke191dGlsLkFubm90YXRpb25QcmVmaXh9JHtpZH1gKS5qb2luKFwiLFwiKSk7XG4gICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICB9XG59XG5jbGFzcyBQb3B1cEVsZW1lbnQge1xuICAjZGF0ZVRpbWVQcm9taXNlID0gbnVsbDtcbiAgI2JvdW5kS2V5RG93biA9IHRoaXMuI2tleURvd24uYmluZCh0aGlzKTtcbiAgI2JvdW5kSGlkZSA9IHRoaXMuI2hpZGUuYmluZCh0aGlzKTtcbiAgI2JvdW5kU2hvdyA9IHRoaXMuI3Nob3cuYmluZCh0aGlzKTtcbiAgI2JvdW5kVG9nZ2xlID0gdGhpcy4jdG9nZ2xlLmJpbmQodGhpcyk7XG4gICNjb2xvciA9IG51bGw7XG4gICNjb250YWluZXIgPSBudWxsO1xuICAjY29udGVudHNPYmogPSBudWxsO1xuICAjZWxlbWVudHMgPSBudWxsO1xuICAjcGFyZW50ID0gbnVsbDtcbiAgI3BhcmVudFJlY3QgPSBudWxsO1xuICAjcGlubmVkID0gZmFsc2U7XG4gICNwb3B1cCA9IG51bGw7XG4gICNyZWN0ID0gbnVsbDtcbiAgI3JpY2hUZXh0ID0gbnVsbDtcbiAgI3RpdGxlT2JqID0gbnVsbDtcbiAgI3dhc1Zpc2libGUgPSBmYWxzZTtcbiAgY29uc3RydWN0b3Ioe1xuICAgIGNvbnRhaW5lcixcbiAgICBjb2xvcixcbiAgICBlbGVtZW50cyxcbiAgICB0aXRsZU9iaixcbiAgICBtb2RpZmljYXRpb25EYXRlLFxuICAgIGNvbnRlbnRzT2JqLFxuICAgIHJpY2hUZXh0LFxuICAgIHBhcmVudCxcbiAgICByZWN0LFxuICAgIHBhcmVudFJlY3QsXG4gICAgb3BlblxuICB9KSB7XG4gICAgdGhpcy4jY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgIHRoaXMuI3RpdGxlT2JqID0gdGl0bGVPYmo7XG4gICAgdGhpcy4jY29udGVudHNPYmogPSBjb250ZW50c09iajtcbiAgICB0aGlzLiNyaWNoVGV4dCA9IHJpY2hUZXh0O1xuICAgIHRoaXMuI3BhcmVudCA9IHBhcmVudDtcbiAgICB0aGlzLiNjb2xvciA9IGNvbG9yO1xuICAgIHRoaXMuI3JlY3QgPSByZWN0O1xuICAgIHRoaXMuI3BhcmVudFJlY3QgPSBwYXJlbnRSZWN0O1xuICAgIHRoaXMuI2VsZW1lbnRzID0gZWxlbWVudHM7XG4gICAgY29uc3QgZGF0ZU9iamVjdCA9IF9kaXNwbGF5X3V0aWxzLlBERkRhdGVTdHJpbmcudG9EYXRlT2JqZWN0KG1vZGlmaWNhdGlvbkRhdGUpO1xuICAgIGlmIChkYXRlT2JqZWN0KSB7XG4gICAgICB0aGlzLiNkYXRlVGltZVByb21pc2UgPSBwYXJlbnQubDEwbi5nZXQoXCJhbm5vdGF0aW9uX2RhdGVfc3RyaW5nXCIsIHtcbiAgICAgICAgZGF0ZTogZGF0ZU9iamVjdC50b0xvY2FsZURhdGVTdHJpbmcoKSxcbiAgICAgICAgdGltZTogZGF0ZU9iamVjdC50b0xvY2FsZVRpbWVTdHJpbmcoKVxuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMudHJpZ2dlciA9IGVsZW1lbnRzLmZsYXRNYXAoZSA9PiBlLmdldEVsZW1lbnRzVG9UcmlnZ2VyUG9wdXAoKSk7XG4gICAgZm9yIChjb25zdCBlbGVtZW50IG9mIHRoaXMudHJpZ2dlcikge1xuICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy4jYm91bmRUb2dnbGUpO1xuICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwibW91c2VlbnRlclwiLCB0aGlzLiNib3VuZFNob3cpO1xuICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwibW91c2VsZWF2ZVwiLCB0aGlzLiNib3VuZEhpZGUpO1xuICAgICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKFwicG9wdXBUcmlnZ2VyQXJlYVwiKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBlbGVtZW50IG9mIGVsZW1lbnRzKSB7XG4gICAgICBlbGVtZW50LmNvbnRhaW5lcj8uYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgdGhpcy4jYm91bmRLZXlEb3duKTtcbiAgICB9XG4gICAgdGhpcy4jY29udGFpbmVyLmhpZGRlbiA9IHRydWU7XG4gICAgaWYgKG9wZW4pIHtcbiAgICAgIHRoaXMuI3RvZ2dsZSgpO1xuICAgIH1cbiAgfVxuICByZW5kZXIoKSB7XG4gICAgaWYgKHRoaXMuI3BvcHVwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIHBhZ2U6IHtcbiAgICAgICAgdmlld1xuICAgICAgfSxcbiAgICAgIHZpZXdwb3J0OiB7XG4gICAgICAgIHJhd0RpbXM6IHtcbiAgICAgICAgICBwYWdlV2lkdGgsXG4gICAgICAgICAgcGFnZUhlaWdodCxcbiAgICAgICAgICBwYWdlWCxcbiAgICAgICAgICBwYWdlWVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSA9IHRoaXMuI3BhcmVudDtcbiAgICBjb25zdCBwb3B1cCA9IHRoaXMuI3BvcHVwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICBwb3B1cC5jbGFzc05hbWUgPSBcInBvcHVwXCI7XG4gICAgaWYgKHRoaXMuI2NvbG9yKSB7XG4gICAgICBjb25zdCBiYXNlQ29sb3IgPSBwb3B1cC5zdHlsZS5vdXRsaW5lQ29sb3IgPSBfdXRpbC5VdGlsLm1ha2VIZXhDb2xvciguLi50aGlzLiNjb2xvcik7XG4gICAgICBpZiAoQ1NTLnN1cHBvcnRzKFwiYmFja2dyb3VuZC1jb2xvclwiLCBcImNvbG9yLW1peChpbiBzcmdiLCByZWQgMzAlLCB3aGl0ZSlcIikpIHtcbiAgICAgICAgcG9wdXAuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gYGNvbG9yLW1peChpbiBzcmdiLCAke2Jhc2VDb2xvcn0gMzAlLCB3aGl0ZSlgO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgQkFDS0dST1VORF9FTkxJR0hUID0gMC43O1xuICAgICAgICBwb3B1cC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBfdXRpbC5VdGlsLm1ha2VIZXhDb2xvciguLi50aGlzLiNjb2xvci5tYXAoYyA9PiBNYXRoLmZsb29yKEJBQ0tHUk9VTkRfRU5MSUdIVCAqICgyNTUgLSBjKSArIGMpKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGhlYWRlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgIGhlYWRlci5jbGFzc05hbWUgPSBcImhlYWRlclwiO1xuICAgIGNvbnN0IHRpdGxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImgxXCIpO1xuICAgIGhlYWRlci5hcHBlbmQodGl0bGUpO1xuICAgICh7XG4gICAgICBkaXI6IHRpdGxlLmRpcixcbiAgICAgIHN0cjogdGl0bGUudGV4dENvbnRlbnRcbiAgICB9ID0gdGhpcy4jdGl0bGVPYmopO1xuICAgIHBvcHVwLmFwcGVuZChoZWFkZXIpO1xuICAgIGlmICh0aGlzLiNkYXRlVGltZVByb21pc2UpIHtcbiAgICAgIGNvbnN0IG1vZGlmaWNhdGlvbkRhdGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICAgIG1vZGlmaWNhdGlvbkRhdGUuY2xhc3NMaXN0LmFkZChcInBvcHVwRGF0ZVwiKTtcbiAgICAgIHRoaXMuI2RhdGVUaW1lUHJvbWlzZS50aGVuKGxvY2FsaXplZCA9PiB7XG4gICAgICAgIG1vZGlmaWNhdGlvbkRhdGUudGV4dENvbnRlbnQgPSBsb2NhbGl6ZWQ7XG4gICAgICB9KTtcbiAgICAgIGhlYWRlci5hcHBlbmQobW9kaWZpY2F0aW9uRGF0ZSk7XG4gICAgfVxuICAgIGNvbnN0IGNvbnRlbnRzT2JqID0gdGhpcy4jY29udGVudHNPYmo7XG4gICAgY29uc3QgcmljaFRleHQgPSB0aGlzLiNyaWNoVGV4dDtcbiAgICBpZiAocmljaFRleHQ/LnN0ciAmJiAoIWNvbnRlbnRzT2JqPy5zdHIgfHwgY29udGVudHNPYmouc3RyID09PSByaWNoVGV4dC5zdHIpKSB7XG4gICAgICBfeGZhX2xheWVyLlhmYUxheWVyLnJlbmRlcih7XG4gICAgICAgIHhmYUh0bWw6IHJpY2hUZXh0Lmh0bWwsXG4gICAgICAgIGludGVudDogXCJyaWNoVGV4dFwiLFxuICAgICAgICBkaXY6IHBvcHVwXG4gICAgICB9KTtcbiAgICAgIHBvcHVwLmxhc3RDaGlsZC5jbGFzc0xpc3QuYWRkKFwicmljaFRleHRcIiwgXCJwb3B1cENvbnRlbnRcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGNvbnRlbnRzID0gdGhpcy5fZm9ybWF0Q29udGVudHMoY29udGVudHNPYmopO1xuICAgICAgcG9wdXAuYXBwZW5kKGNvbnRlbnRzKTtcbiAgICB9XG4gICAgbGV0IHVzZVBhcmVudFJlY3QgPSAhIXRoaXMuI3BhcmVudFJlY3Q7XG4gICAgbGV0IHJlY3QgPSB1c2VQYXJlbnRSZWN0ID8gdGhpcy4jcGFyZW50UmVjdCA6IHRoaXMuI3JlY3Q7XG4gICAgZm9yIChjb25zdCBlbGVtZW50IG9mIHRoaXMuI2VsZW1lbnRzKSB7XG4gICAgICBpZiAoIXJlY3QgfHwgX3V0aWwuVXRpbC5pbnRlcnNlY3QoZWxlbWVudC5kYXRhLnJlY3QsIHJlY3QpICE9PSBudWxsKSB7XG4gICAgICAgIHJlY3QgPSBlbGVtZW50LmRhdGEucmVjdDtcbiAgICAgICAgdXNlUGFyZW50UmVjdCA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBub3JtYWxpemVkUmVjdCA9IF91dGlsLlV0aWwubm9ybWFsaXplUmVjdChbcmVjdFswXSwgdmlld1szXSAtIHJlY3RbMV0gKyB2aWV3WzFdLCByZWN0WzJdLCB2aWV3WzNdIC0gcmVjdFszXSArIHZpZXdbMV1dKTtcbiAgICBjb25zdCBIT1JJWk9OVEFMX1NQQUNFX0FGVEVSX0FOTk9UQVRJT04gPSA1O1xuICAgIGNvbnN0IHBhcmVudFdpZHRoID0gdXNlUGFyZW50UmVjdCA/IHJlY3RbMl0gLSByZWN0WzBdICsgSE9SSVpPTlRBTF9TUEFDRV9BRlRFUl9BTk5PVEFUSU9OIDogMDtcbiAgICBjb25zdCBwb3B1cExlZnQgPSBub3JtYWxpemVkUmVjdFswXSArIHBhcmVudFdpZHRoO1xuICAgIGNvbnN0IHBvcHVwVG9wID0gbm9ybWFsaXplZFJlY3RbMV07XG4gICAgY29uc3Qge1xuICAgICAgc3R5bGVcbiAgICB9ID0gdGhpcy4jY29udGFpbmVyO1xuICAgIHN0eWxlLmxlZnQgPSBgJHsxMDAgKiAocG9wdXBMZWZ0IC0gcGFnZVgpIC8gcGFnZVdpZHRofSVgO1xuICAgIHN0eWxlLnRvcCA9IGAkezEwMCAqIChwb3B1cFRvcCAtIHBhZ2VZKSAvIHBhZ2VIZWlnaHR9JWA7XG4gICAgdGhpcy4jY29udGFpbmVyLmFwcGVuZChwb3B1cCk7XG4gIH1cbiAgX2Zvcm1hdENvbnRlbnRzKHtcbiAgICBzdHIsXG4gICAgZGlyXG4gIH0pIHtcbiAgICBjb25zdCBwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInBcIik7XG4gICAgcC5jbGFzc0xpc3QuYWRkKFwicG9wdXBDb250ZW50XCIpO1xuICAgIHAuZGlyID0gZGlyO1xuICAgIGNvbnN0IGxpbmVzID0gc3RyLnNwbGl0KC8oPzpcXHJcXG4/fFxcbikvKTtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBsaW5lcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICBjb25zdCBsaW5lID0gbGluZXNbaV07XG4gICAgICBwLmFwcGVuZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShsaW5lKSk7XG4gICAgICBpZiAoaSA8IGlpIC0gMSkge1xuICAgICAgICBwLmFwcGVuZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnJcIikpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcDtcbiAgfVxuICAja2V5RG93bihldmVudCkge1xuICAgIGlmIChldmVudC5hbHRLZXkgfHwgZXZlbnQuc2hpZnRLZXkgfHwgZXZlbnQuY3RybEtleSB8fCBldmVudC5tZXRhS2V5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChldmVudC5rZXkgPT09IFwiRW50ZXJcIiB8fCBldmVudC5rZXkgPT09IFwiRXNjYXBlXCIgJiYgdGhpcy4jcGlubmVkKSB7XG4gICAgICB0aGlzLiN0b2dnbGUoKTtcbiAgICB9XG4gIH1cbiAgI3RvZ2dsZSgpIHtcbiAgICB0aGlzLiNwaW5uZWQgPSAhdGhpcy4jcGlubmVkO1xuICAgIGlmICh0aGlzLiNwaW5uZWQpIHtcbiAgICAgIHRoaXMuI3Nob3coKTtcbiAgICAgIHRoaXMuI2NvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy4jYm91bmRUb2dnbGUpO1xuICAgICAgdGhpcy4jY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHRoaXMuI2JvdW5kS2V5RG93bik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuI2hpZGUoKTtcbiAgICAgIHRoaXMuI2NvbnRhaW5lci5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy4jYm91bmRUb2dnbGUpO1xuICAgICAgdGhpcy4jY29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHRoaXMuI2JvdW5kS2V5RG93bik7XG4gICAgfVxuICB9XG4gICNzaG93KCkge1xuICAgIGlmICghdGhpcy4jcG9wdXApIHtcbiAgICAgIHRoaXMucmVuZGVyKCk7XG4gICAgfVxuICAgIGlmICghdGhpcy5pc1Zpc2libGUpIHtcbiAgICAgIHRoaXMuI2NvbnRhaW5lci5oaWRkZW4gPSBmYWxzZTtcbiAgICAgIHRoaXMuI2NvbnRhaW5lci5zdHlsZS56SW5kZXggPSBwYXJzZUludCh0aGlzLiNjb250YWluZXIuc3R5bGUuekluZGV4KSArIDEwMDA7XG4gICAgfSBlbHNlIGlmICh0aGlzLiNwaW5uZWQpIHtcbiAgICAgIHRoaXMuI2NvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwiZm9jdXNlZFwiKTtcbiAgICB9XG4gIH1cbiAgI2hpZGUoKSB7XG4gICAgdGhpcy4jY29udGFpbmVyLmNsYXNzTGlzdC5yZW1vdmUoXCJmb2N1c2VkXCIpO1xuICAgIGlmICh0aGlzLiNwaW5uZWQgfHwgIXRoaXMuaXNWaXNpYmxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2NvbnRhaW5lci5oaWRkZW4gPSB0cnVlO1xuICAgIHRoaXMuI2NvbnRhaW5lci5zdHlsZS56SW5kZXggPSBwYXJzZUludCh0aGlzLiNjb250YWluZXIuc3R5bGUuekluZGV4KSAtIDEwMDA7XG4gIH1cbiAgZm9yY2VIaWRlKCkge1xuICAgIHRoaXMuI3dhc1Zpc2libGUgPSB0aGlzLmlzVmlzaWJsZTtcbiAgICBpZiAoIXRoaXMuI3dhc1Zpc2libGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jY29udGFpbmVyLmhpZGRlbiA9IHRydWU7XG4gIH1cbiAgbWF5YmVTaG93KCkge1xuICAgIGlmICghdGhpcy4jd2FzVmlzaWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiN3YXNWaXNpYmxlID0gZmFsc2U7XG4gICAgdGhpcy4jY29udGFpbmVyLmhpZGRlbiA9IGZhbHNlO1xuICB9XG4gIGdldCBpc1Zpc2libGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2NvbnRhaW5lci5oaWRkZW4gPT09IGZhbHNlO1xuICB9XG59XG5jbGFzcyBGcmVlVGV4dEFubm90YXRpb25FbGVtZW50IGV4dGVuZHMgQW5ub3RhdGlvbkVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgc3VwZXIocGFyYW1ldGVycywge1xuICAgICAgaXNSZW5kZXJhYmxlOiB0cnVlLFxuICAgICAgaWdub3JlQm9yZGVyOiB0cnVlXG4gICAgfSk7XG4gICAgdGhpcy50ZXh0Q29udGVudCA9IHBhcmFtZXRlcnMuZGF0YS50ZXh0Q29udGVudDtcbiAgICB0aGlzLnRleHRQb3NpdGlvbiA9IHBhcmFtZXRlcnMuZGF0YS50ZXh0UG9zaXRpb247XG4gICAgdGhpcy5hbm5vdGF0aW9uRWRpdG9yVHlwZSA9IF91dGlsLkFubm90YXRpb25FZGl0b3JUeXBlLkZSRUVURVhUO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwiZnJlZVRleHRBbm5vdGF0aW9uXCIpO1xuICAgIGlmICh0aGlzLnRleHRDb250ZW50KSB7XG4gICAgICBjb25zdCBjb250ZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIGNvbnRlbnQuY2xhc3NMaXN0LmFkZChcImFubm90YXRpb25UZXh0Q29udGVudFwiKTtcbiAgICAgIGNvbnRlbnQuc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcImNvbW1lbnRcIik7XG4gICAgICBmb3IgKGNvbnN0IGxpbmUgb2YgdGhpcy50ZXh0Q29udGVudCkge1xuICAgICAgICBjb25zdCBsaW5lU3BhbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgICBsaW5lU3Bhbi50ZXh0Q29udGVudCA9IGxpbmU7XG4gICAgICAgIGNvbnRlbnQuYXBwZW5kKGxpbmVTcGFuKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZChjb250ZW50KTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmRhdGEucG9wdXBSZWYgJiYgdGhpcy5oYXNQb3B1cERhdGEpIHtcbiAgICAgIHRoaXMuX2NyZWF0ZVBvcHVwKCk7XG4gICAgfVxuICAgIHRoaXMuX2VkaXRPbkRvdWJsZUNsaWNrKCk7XG4gICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICB9XG59XG5leHBvcnRzLkZyZWVUZXh0QW5ub3RhdGlvbkVsZW1lbnQgPSBGcmVlVGV4dEFubm90YXRpb25FbGVtZW50O1xuY2xhc3MgTGluZUFubm90YXRpb25FbGVtZW50IGV4dGVuZHMgQW5ub3RhdGlvbkVsZW1lbnQge1xuICAjbGluZSA9IG51bGw7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcbiAgICBzdXBlcihwYXJhbWV0ZXJzLCB7XG4gICAgICBpc1JlbmRlcmFibGU6IHRydWUsXG4gICAgICBpZ25vcmVCb3JkZXI6IHRydWVcbiAgICB9KTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChcImxpbmVBbm5vdGF0aW9uXCIpO1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgY29uc3Qge1xuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHRcbiAgICB9ID0gZ2V0UmVjdERpbXMoZGF0YS5yZWN0KTtcbiAgICBjb25zdCBzdmcgPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlKHdpZHRoLCBoZWlnaHQsIHRydWUpO1xuICAgIGNvbnN0IGxpbmUgPSB0aGlzLiNsaW5lID0gdGhpcy5zdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJzdmc6bGluZVwiKTtcbiAgICBsaW5lLnNldEF0dHJpYnV0ZShcIngxXCIsIGRhdGEucmVjdFsyXSAtIGRhdGEubGluZUNvb3JkaW5hdGVzWzBdKTtcbiAgICBsaW5lLnNldEF0dHJpYnV0ZShcInkxXCIsIGRhdGEucmVjdFszXSAtIGRhdGEubGluZUNvb3JkaW5hdGVzWzFdKTtcbiAgICBsaW5lLnNldEF0dHJpYnV0ZShcIngyXCIsIGRhdGEucmVjdFsyXSAtIGRhdGEubGluZUNvb3JkaW5hdGVzWzJdKTtcbiAgICBsaW5lLnNldEF0dHJpYnV0ZShcInkyXCIsIGRhdGEucmVjdFszXSAtIGRhdGEubGluZUNvb3JkaW5hdGVzWzNdKTtcbiAgICBsaW5lLnNldEF0dHJpYnV0ZShcInN0cm9rZS13aWR0aFwiLCBkYXRhLmJvcmRlclN0eWxlLndpZHRoIHx8IDEpO1xuICAgIGxpbmUuc2V0QXR0cmlidXRlKFwic3Ryb2tlXCIsIFwidHJhbnNwYXJlbnRcIik7XG4gICAgbGluZS5zZXRBdHRyaWJ1dGUoXCJmaWxsXCIsIFwidHJhbnNwYXJlbnRcIik7XG4gICAgc3ZnLmFwcGVuZChsaW5lKTtcbiAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmQoc3ZnKTtcbiAgICBpZiAoIWRhdGEucG9wdXBSZWYgJiYgdGhpcy5oYXNQb3B1cERhdGEpIHtcbiAgICAgIHRoaXMuX2NyZWF0ZVBvcHVwKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgfVxuICBnZXRFbGVtZW50c1RvVHJpZ2dlclBvcHVwKCkge1xuICAgIHJldHVybiB0aGlzLiNsaW5lO1xuICB9XG4gIGFkZEhpZ2hsaWdodEFyZWEoKSB7XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChcImhpZ2hsaWdodEFyZWFcIik7XG4gIH1cbn1cbmNsYXNzIFNxdWFyZUFubm90YXRpb25FbGVtZW50IGV4dGVuZHMgQW5ub3RhdGlvbkVsZW1lbnQge1xuICAjc3F1YXJlID0gbnVsbDtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVycykge1xuICAgIHN1cGVyKHBhcmFtZXRlcnMsIHtcbiAgICAgIGlzUmVuZGVyYWJsZTogdHJ1ZSxcbiAgICAgIGlnbm9yZUJvcmRlcjogdHJ1ZVxuICAgIH0pO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwic3F1YXJlQW5ub3RhdGlvblwiKTtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5kYXRhO1xuICAgIGNvbnN0IHtcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0XG4gICAgfSA9IGdldFJlY3REaW1zKGRhdGEucmVjdCk7XG4gICAgY29uc3Qgc3ZnID0gdGhpcy5zdmdGYWN0b3J5LmNyZWF0ZSh3aWR0aCwgaGVpZ2h0LCB0cnVlKTtcbiAgICBjb25zdCBib3JkZXJXaWR0aCA9IGRhdGEuYm9yZGVyU3R5bGUud2lkdGg7XG4gICAgY29uc3Qgc3F1YXJlID0gdGhpcy4jc3F1YXJlID0gdGhpcy5zdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJzdmc6cmVjdFwiKTtcbiAgICBzcXVhcmUuc2V0QXR0cmlidXRlKFwieFwiLCBib3JkZXJXaWR0aCAvIDIpO1xuICAgIHNxdWFyZS5zZXRBdHRyaWJ1dGUoXCJ5XCIsIGJvcmRlcldpZHRoIC8gMik7XG4gICAgc3F1YXJlLnNldEF0dHJpYnV0ZShcIndpZHRoXCIsIHdpZHRoIC0gYm9yZGVyV2lkdGgpO1xuICAgIHNxdWFyZS5zZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIiwgaGVpZ2h0IC0gYm9yZGVyV2lkdGgpO1xuICAgIHNxdWFyZS5zZXRBdHRyaWJ1dGUoXCJzdHJva2Utd2lkdGhcIiwgYm9yZGVyV2lkdGggfHwgMSk7XG4gICAgc3F1YXJlLnNldEF0dHJpYnV0ZShcInN0cm9rZVwiLCBcInRyYW5zcGFyZW50XCIpO1xuICAgIHNxdWFyZS5zZXRBdHRyaWJ1dGUoXCJmaWxsXCIsIFwidHJhbnNwYXJlbnRcIik7XG4gICAgc3ZnLmFwcGVuZChzcXVhcmUpO1xuICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZChzdmcpO1xuICAgIGlmICghZGF0YS5wb3B1cFJlZiAmJiB0aGlzLmhhc1BvcHVwRGF0YSkge1xuICAgICAgdGhpcy5fY3JlYXRlUG9wdXAoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICB9XG4gIGdldEVsZW1lbnRzVG9UcmlnZ2VyUG9wdXAoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3NxdWFyZTtcbiAgfVxuICBhZGRIaWdobGlnaHRBcmVhKCkge1xuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJoaWdobGlnaHRBcmVhXCIpO1xuICB9XG59XG5jbGFzcyBDaXJjbGVBbm5vdGF0aW9uRWxlbWVudCBleHRlbmRzIEFubm90YXRpb25FbGVtZW50IHtcbiAgI2NpcmNsZSA9IG51bGw7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcbiAgICBzdXBlcihwYXJhbWV0ZXJzLCB7XG4gICAgICBpc1JlbmRlcmFibGU6IHRydWUsXG4gICAgICBpZ25vcmVCb3JkZXI6IHRydWVcbiAgICB9KTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChcImNpcmNsZUFubm90YXRpb25cIik7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICBjb25zdCB7XG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodFxuICAgIH0gPSBnZXRSZWN0RGltcyhkYXRhLnJlY3QpO1xuICAgIGNvbnN0IHN2ZyA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGUod2lkdGgsIGhlaWdodCwgdHJ1ZSk7XG4gICAgY29uc3QgYm9yZGVyV2lkdGggPSBkYXRhLmJvcmRlclN0eWxlLndpZHRoO1xuICAgIGNvbnN0IGNpcmNsZSA9IHRoaXMuI2NpcmNsZSA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwic3ZnOmVsbGlwc2VcIik7XG4gICAgY2lyY2xlLnNldEF0dHJpYnV0ZShcImN4XCIsIHdpZHRoIC8gMik7XG4gICAgY2lyY2xlLnNldEF0dHJpYnV0ZShcImN5XCIsIGhlaWdodCAvIDIpO1xuICAgIGNpcmNsZS5zZXRBdHRyaWJ1dGUoXCJyeFwiLCB3aWR0aCAvIDIgLSBib3JkZXJXaWR0aCAvIDIpO1xuICAgIGNpcmNsZS5zZXRBdHRyaWJ1dGUoXCJyeVwiLCBoZWlnaHQgLyAyIC0gYm9yZGVyV2lkdGggLyAyKTtcbiAgICBjaXJjbGUuc2V0QXR0cmlidXRlKFwic3Ryb2tlLXdpZHRoXCIsIGJvcmRlcldpZHRoIHx8IDEpO1xuICAgIGNpcmNsZS5zZXRBdHRyaWJ1dGUoXCJzdHJva2VcIiwgXCJ0cmFuc3BhcmVudFwiKTtcbiAgICBjaXJjbGUuc2V0QXR0cmlidXRlKFwiZmlsbFwiLCBcInRyYW5zcGFyZW50XCIpO1xuICAgIHN2Zy5hcHBlbmQoY2lyY2xlKTtcbiAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmQoc3ZnKTtcbiAgICBpZiAoIWRhdGEucG9wdXBSZWYgJiYgdGhpcy5oYXNQb3B1cERhdGEpIHtcbiAgICAgIHRoaXMuX2NyZWF0ZVBvcHVwKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgfVxuICBnZXRFbGVtZW50c1RvVHJpZ2dlclBvcHVwKCkge1xuICAgIHJldHVybiB0aGlzLiNjaXJjbGU7XG4gIH1cbiAgYWRkSGlnaGxpZ2h0QXJlYSgpIHtcbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwiaGlnaGxpZ2h0QXJlYVwiKTtcbiAgfVxufVxuY2xhc3MgUG9seWxpbmVBbm5vdGF0aW9uRWxlbWVudCBleHRlbmRzIEFubm90YXRpb25FbGVtZW50IHtcbiAgI3BvbHlsaW5lID0gbnVsbDtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVycykge1xuICAgIHN1cGVyKHBhcmFtZXRlcnMsIHtcbiAgICAgIGlzUmVuZGVyYWJsZTogdHJ1ZSxcbiAgICAgIGlnbm9yZUJvcmRlcjogdHJ1ZVxuICAgIH0pO1xuICAgIHRoaXMuY29udGFpbmVyQ2xhc3NOYW1lID0gXCJwb2x5bGluZUFubm90YXRpb25cIjtcbiAgICB0aGlzLnN2Z0VsZW1lbnROYW1lID0gXCJzdmc6cG9seWxpbmVcIjtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZCh0aGlzLmNvbnRhaW5lckNsYXNzTmFtZSk7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICBjb25zdCB7XG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodFxuICAgIH0gPSBnZXRSZWN0RGltcyhkYXRhLnJlY3QpO1xuICAgIGNvbnN0IHN2ZyA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGUod2lkdGgsIGhlaWdodCwgdHJ1ZSk7XG4gICAgbGV0IHBvaW50cyA9IFtdO1xuICAgIGZvciAoY29uc3QgY29vcmRpbmF0ZSBvZiBkYXRhLnZlcnRpY2VzKSB7XG4gICAgICBjb25zdCB4ID0gY29vcmRpbmF0ZS54IC0gZGF0YS5yZWN0WzBdO1xuICAgICAgY29uc3QgeSA9IGRhdGEucmVjdFszXSAtIGNvb3JkaW5hdGUueTtcbiAgICAgIHBvaW50cy5wdXNoKHggKyBcIixcIiArIHkpO1xuICAgIH1cbiAgICBwb2ludHMgPSBwb2ludHMuam9pbihcIiBcIik7XG4gICAgY29uc3QgcG9seWxpbmUgPSB0aGlzLiNwb2x5bGluZSA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KHRoaXMuc3ZnRWxlbWVudE5hbWUpO1xuICAgIHBvbHlsaW5lLnNldEF0dHJpYnV0ZShcInBvaW50c1wiLCBwb2ludHMpO1xuICAgIHBvbHlsaW5lLnNldEF0dHJpYnV0ZShcInN0cm9rZS13aWR0aFwiLCBkYXRhLmJvcmRlclN0eWxlLndpZHRoIHx8IDEpO1xuICAgIHBvbHlsaW5lLnNldEF0dHJpYnV0ZShcInN0cm9rZVwiLCBcInRyYW5zcGFyZW50XCIpO1xuICAgIHBvbHlsaW5lLnNldEF0dHJpYnV0ZShcImZpbGxcIiwgXCJ0cmFuc3BhcmVudFwiKTtcbiAgICBzdmcuYXBwZW5kKHBvbHlsaW5lKTtcbiAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmQoc3ZnKTtcbiAgICBpZiAoIWRhdGEucG9wdXBSZWYgJiYgdGhpcy5oYXNQb3B1cERhdGEpIHtcbiAgICAgIHRoaXMuX2NyZWF0ZVBvcHVwKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgfVxuICBnZXRFbGVtZW50c1RvVHJpZ2dlclBvcHVwKCkge1xuICAgIHJldHVybiB0aGlzLiNwb2x5bGluZTtcbiAgfVxuICBhZGRIaWdobGlnaHRBcmVhKCkge1xuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJoaWdobGlnaHRBcmVhXCIpO1xuICB9XG59XG5jbGFzcyBQb2x5Z29uQW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBQb2x5bGluZUFubm90YXRpb25FbGVtZW50IHtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVycykge1xuICAgIHN1cGVyKHBhcmFtZXRlcnMpO1xuICAgIHRoaXMuY29udGFpbmVyQ2xhc3NOYW1lID0gXCJwb2x5Z29uQW5ub3RhdGlvblwiO1xuICAgIHRoaXMuc3ZnRWxlbWVudE5hbWUgPSBcInN2Zzpwb2x5Z29uXCI7XG4gIH1cbn1cbmNsYXNzIENhcmV0QW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBBbm5vdGF0aW9uRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcbiAgICBzdXBlcihwYXJhbWV0ZXJzLCB7XG4gICAgICBpc1JlbmRlcmFibGU6IHRydWUsXG4gICAgICBpZ25vcmVCb3JkZXI6IHRydWVcbiAgICB9KTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChcImNhcmV0QW5ub3RhdGlvblwiKTtcbiAgICBpZiAoIXRoaXMuZGF0YS5wb3B1cFJlZiAmJiB0aGlzLmhhc1BvcHVwRGF0YSkge1xuICAgICAgdGhpcy5fY3JlYXRlUG9wdXAoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICB9XG59XG5jbGFzcyBJbmtBbm5vdGF0aW9uRWxlbWVudCBleHRlbmRzIEFubm90YXRpb25FbGVtZW50IHtcbiAgI3BvbHlsaW5lcyA9IFtdO1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgc3VwZXIocGFyYW1ldGVycywge1xuICAgICAgaXNSZW5kZXJhYmxlOiB0cnVlLFxuICAgICAgaWdub3JlQm9yZGVyOiB0cnVlXG4gICAgfSk7XG4gICAgdGhpcy5jb250YWluZXJDbGFzc05hbWUgPSBcImlua0Fubm90YXRpb25cIjtcbiAgICB0aGlzLnN2Z0VsZW1lbnROYW1lID0gXCJzdmc6cG9seWxpbmVcIjtcbiAgICB0aGlzLmFubm90YXRpb25FZGl0b3JUeXBlID0gX3V0aWwuQW5ub3RhdGlvbkVkaXRvclR5cGUuSU5LO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKHRoaXMuY29udGFpbmVyQ2xhc3NOYW1lKTtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5kYXRhO1xuICAgIGNvbnN0IHtcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0XG4gICAgfSA9IGdldFJlY3REaW1zKGRhdGEucmVjdCk7XG4gICAgY29uc3Qgc3ZnID0gdGhpcy5zdmdGYWN0b3J5LmNyZWF0ZSh3aWR0aCwgaGVpZ2h0LCB0cnVlKTtcbiAgICBmb3IgKGNvbnN0IGlua0xpc3Qgb2YgZGF0YS5pbmtMaXN0cykge1xuICAgICAgbGV0IHBvaW50cyA9IFtdO1xuICAgICAgZm9yIChjb25zdCBjb29yZGluYXRlIG9mIGlua0xpc3QpIHtcbiAgICAgICAgY29uc3QgeCA9IGNvb3JkaW5hdGUueCAtIGRhdGEucmVjdFswXTtcbiAgICAgICAgY29uc3QgeSA9IGRhdGEucmVjdFszXSAtIGNvb3JkaW5hdGUueTtcbiAgICAgICAgcG9pbnRzLnB1c2goYCR7eH0sJHt5fWApO1xuICAgICAgfVxuICAgICAgcG9pbnRzID0gcG9pbnRzLmpvaW4oXCIgXCIpO1xuICAgICAgY29uc3QgcG9seWxpbmUgPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudCh0aGlzLnN2Z0VsZW1lbnROYW1lKTtcbiAgICAgIHRoaXMuI3BvbHlsaW5lcy5wdXNoKHBvbHlsaW5lKTtcbiAgICAgIHBvbHlsaW5lLnNldEF0dHJpYnV0ZShcInBvaW50c1wiLCBwb2ludHMpO1xuICAgICAgcG9seWxpbmUuc2V0QXR0cmlidXRlKFwic3Ryb2tlLXdpZHRoXCIsIGRhdGEuYm9yZGVyU3R5bGUud2lkdGggfHwgMSk7XG4gICAgICBwb2x5bGluZS5zZXRBdHRyaWJ1dGUoXCJzdHJva2VcIiwgXCJ0cmFuc3BhcmVudFwiKTtcbiAgICAgIHBvbHlsaW5lLnNldEF0dHJpYnV0ZShcImZpbGxcIiwgXCJ0cmFuc3BhcmVudFwiKTtcbiAgICAgIGlmICghZGF0YS5wb3B1cFJlZiAmJiB0aGlzLmhhc1BvcHVwRGF0YSkge1xuICAgICAgICB0aGlzLl9jcmVhdGVQb3B1cCgpO1xuICAgICAgfVxuICAgICAgc3ZnLmFwcGVuZChwb2x5bGluZSk7XG4gICAgfVxuICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZChzdmcpO1xuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgfVxuICBnZXRFbGVtZW50c1RvVHJpZ2dlclBvcHVwKCkge1xuICAgIHJldHVybiB0aGlzLiNwb2x5bGluZXM7XG4gIH1cbiAgYWRkSGlnaGxpZ2h0QXJlYSgpIHtcbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwiaGlnaGxpZ2h0QXJlYVwiKTtcbiAgfVxufVxuZXhwb3J0cy5JbmtBbm5vdGF0aW9uRWxlbWVudCA9IElua0Fubm90YXRpb25FbGVtZW50O1xuY2xhc3MgSGlnaGxpZ2h0QW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBBbm5vdGF0aW9uRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcbiAgICBzdXBlcihwYXJhbWV0ZXJzLCB7XG4gICAgICBpc1JlbmRlcmFibGU6IHRydWUsXG4gICAgICBpZ25vcmVCb3JkZXI6IHRydWUsXG4gICAgICBjcmVhdGVRdWFkcmlsYXRlcmFsczogdHJ1ZVxuICAgIH0pO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICBpZiAoIXRoaXMuZGF0YS5wb3B1cFJlZiAmJiB0aGlzLmhhc1BvcHVwRGF0YSkge1xuICAgICAgdGhpcy5fY3JlYXRlUG9wdXAoKTtcbiAgICB9XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChcImhpZ2hsaWdodEFubm90YXRpb25cIik7XG4gICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICB9XG59XG5jbGFzcyBVbmRlcmxpbmVBbm5vdGF0aW9uRWxlbWVudCBleHRlbmRzIEFubm90YXRpb25FbGVtZW50IHtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVycykge1xuICAgIHN1cGVyKHBhcmFtZXRlcnMsIHtcbiAgICAgIGlzUmVuZGVyYWJsZTogdHJ1ZSxcbiAgICAgIGlnbm9yZUJvcmRlcjogdHJ1ZSxcbiAgICAgIGNyZWF0ZVF1YWRyaWxhdGVyYWxzOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIGlmICghdGhpcy5kYXRhLnBvcHVwUmVmICYmIHRoaXMuaGFzUG9wdXBEYXRhKSB7XG4gICAgICB0aGlzLl9jcmVhdGVQb3B1cCgpO1xuICAgIH1cbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwidW5kZXJsaW5lQW5ub3RhdGlvblwiKTtcbiAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gIH1cbn1cbmNsYXNzIFNxdWlnZ2x5QW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBBbm5vdGF0aW9uRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcbiAgICBzdXBlcihwYXJhbWV0ZXJzLCB7XG4gICAgICBpc1JlbmRlcmFibGU6IHRydWUsXG4gICAgICBpZ25vcmVCb3JkZXI6IHRydWUsXG4gICAgICBjcmVhdGVRdWFkcmlsYXRlcmFsczogdHJ1ZVxuICAgIH0pO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICBpZiAoIXRoaXMuZGF0YS5wb3B1cFJlZiAmJiB0aGlzLmhhc1BvcHVwRGF0YSkge1xuICAgICAgdGhpcy5fY3JlYXRlUG9wdXAoKTtcbiAgICB9XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChcInNxdWlnZ2x5QW5ub3RhdGlvblwiKTtcbiAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gIH1cbn1cbmNsYXNzIFN0cmlrZU91dEFubm90YXRpb25FbGVtZW50IGV4dGVuZHMgQW5ub3RhdGlvbkVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgc3VwZXIocGFyYW1ldGVycywge1xuICAgICAgaXNSZW5kZXJhYmxlOiB0cnVlLFxuICAgICAgaWdub3JlQm9yZGVyOiB0cnVlLFxuICAgICAgY3JlYXRlUXVhZHJpbGF0ZXJhbHM6IHRydWVcbiAgICB9KTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgaWYgKCF0aGlzLmRhdGEucG9wdXBSZWYgJiYgdGhpcy5oYXNQb3B1cERhdGEpIHtcbiAgICAgIHRoaXMuX2NyZWF0ZVBvcHVwKCk7XG4gICAgfVxuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJzdHJpa2VvdXRBbm5vdGF0aW9uXCIpO1xuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgfVxufVxuY2xhc3MgU3RhbXBBbm5vdGF0aW9uRWxlbWVudCBleHRlbmRzIEFubm90YXRpb25FbGVtZW50IHtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVycykge1xuICAgIHN1cGVyKHBhcmFtZXRlcnMsIHtcbiAgICAgIGlzUmVuZGVyYWJsZTogdHJ1ZSxcbiAgICAgIGlnbm9yZUJvcmRlcjogdHJ1ZVxuICAgIH0pO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwic3RhbXBBbm5vdGF0aW9uXCIpO1xuICAgIGlmICghdGhpcy5kYXRhLnBvcHVwUmVmICYmIHRoaXMuaGFzUG9wdXBEYXRhKSB7XG4gICAgICB0aGlzLl9jcmVhdGVQb3B1cCgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gIH1cbn1cbmV4cG9ydHMuU3RhbXBBbm5vdGF0aW9uRWxlbWVudCA9IFN0YW1wQW5ub3RhdGlvbkVsZW1lbnQ7XG5jbGFzcyBGaWxlQXR0YWNobWVudEFubm90YXRpb25FbGVtZW50IGV4dGVuZHMgQW5ub3RhdGlvbkVsZW1lbnQge1xuICAjdHJpZ2dlciA9IG51bGw7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcbiAgICBzdXBlcihwYXJhbWV0ZXJzLCB7XG4gICAgICBpc1JlbmRlcmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBjb25zdCB7XG4gICAgICBmaWxlbmFtZSxcbiAgICAgIGNvbnRlbnRcbiAgICB9ID0gdGhpcy5kYXRhLmZpbGU7XG4gICAgdGhpcy5maWxlbmFtZSA9ICgwLCBfZGlzcGxheV91dGlscy5nZXRGaWxlbmFtZUZyb21VcmwpKGZpbGVuYW1lLCB0cnVlKTtcbiAgICB0aGlzLmNvbnRlbnQgPSBjb250ZW50O1xuICAgIHRoaXMubGlua1NlcnZpY2UuZXZlbnRCdXM/LmRpc3BhdGNoKFwiZmlsZWF0dGFjaG1lbnRhbm5vdGF0aW9uXCIsIHtcbiAgICAgIHNvdXJjZTogdGhpcyxcbiAgICAgIGZpbGVuYW1lLFxuICAgICAgY29udGVudFxuICAgIH0pO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwiZmlsZUF0dGFjaG1lbnRBbm5vdGF0aW9uXCIpO1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbnRhaW5lcixcbiAgICAgIGRhdGFcbiAgICB9ID0gdGhpcztcbiAgICBsZXQgdHJpZ2dlcjtcbiAgICBpZiAoZGF0YS5oYXNBcHBlYXJhbmNlIHx8IGRhdGEuZmlsbEFscGhhID09PSAwKSB7XG4gICAgICB0cmlnZ2VyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHJpZ2dlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbWdcIik7XG4gICAgICB0cmlnZ2VyLnNyYyA9IGAke3RoaXMuaW1hZ2VSZXNvdXJjZXNQYXRofWFubm90YXRpb24tJHsvcGFwZXJjbGlwL2kudGVzdChkYXRhLm5hbWUpID8gXCJwYXBlcmNsaXBcIiA6IFwicHVzaHBpblwifS5zdmdgO1xuICAgICAgaWYgKGRhdGEuZmlsbEFscGhhICYmIGRhdGEuZmlsbEFscGhhIDwgMSkge1xuICAgICAgICB0cmlnZ2VyLnN0eWxlID0gYGZpbHRlcjogb3BhY2l0eSgke01hdGgucm91bmQoZGF0YS5maWxsQWxwaGEgKiAxMDApfSUpO2A7XG4gICAgICB9XG4gICAgfVxuICAgIHRyaWdnZXIuYWRkRXZlbnRMaXN0ZW5lcihcImRibGNsaWNrXCIsIHRoaXMuI2Rvd25sb2FkLmJpbmQodGhpcykpO1xuICAgIHRoaXMuI3RyaWdnZXIgPSB0cmlnZ2VyO1xuICAgIGNvbnN0IHtcbiAgICAgIGlzTWFjXG4gICAgfSA9IF91dGlsLkZlYXR1cmVUZXN0LnBsYXRmb3JtO1xuICAgIGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBldnQgPT4ge1xuICAgICAgaWYgKGV2dC5rZXkgPT09IFwiRW50ZXJcIiAmJiAoaXNNYWMgPyBldnQubWV0YUtleSA6IGV2dC5jdHJsS2V5KSkge1xuICAgICAgICB0aGlzLiNkb3dubG9hZCgpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmICghZGF0YS5wb3B1cFJlZiAmJiB0aGlzLmhhc1BvcHVwRGF0YSkge1xuICAgICAgdGhpcy5fY3JlYXRlUG9wdXAoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHJpZ2dlci5jbGFzc0xpc3QuYWRkKFwicG9wdXBUcmlnZ2VyQXJlYVwiKTtcbiAgICB9XG4gICAgY29udGFpbmVyLmFwcGVuZCh0cmlnZ2VyKTtcbiAgICByZXR1cm4gY29udGFpbmVyO1xuICB9XG4gIGdldEVsZW1lbnRzVG9UcmlnZ2VyUG9wdXAoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3RyaWdnZXI7XG4gIH1cbiAgYWRkSGlnaGxpZ2h0QXJlYSgpIHtcbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwiaGlnaGxpZ2h0QXJlYVwiKTtcbiAgfVxuICAjZG93bmxvYWQoKSB7XG4gICAgdGhpcy5kb3dubG9hZE1hbmFnZXI/Lm9wZW5PckRvd25sb2FkRGF0YSh0aGlzLmNvbnRhaW5lciwgdGhpcy5jb250ZW50LCB0aGlzLmZpbGVuYW1lKTtcbiAgfVxufVxuY2xhc3MgQW5ub3RhdGlvbkxheWVyIHtcbiAgI2FjY2Vzc2liaWxpdHlNYW5hZ2VyID0gbnVsbDtcbiAgI2Fubm90YXRpb25DYW52YXNNYXAgPSBudWxsO1xuICAjZWRpdGFibGVBbm5vdGF0aW9ucyA9IG5ldyBNYXAoKTtcbiAgY29uc3RydWN0b3Ioe1xuICAgIGRpdixcbiAgICBhY2Nlc3NpYmlsaXR5TWFuYWdlcixcbiAgICBhbm5vdGF0aW9uQ2FudmFzTWFwLFxuICAgIGwxMG4sXG4gICAgcGFnZSxcbiAgICB2aWV3cG9ydFxuICB9KSB7XG4gICAgdGhpcy5kaXYgPSBkaXY7XG4gICAgdGhpcy4jYWNjZXNzaWJpbGl0eU1hbmFnZXIgPSBhY2Nlc3NpYmlsaXR5TWFuYWdlcjtcbiAgICB0aGlzLiNhbm5vdGF0aW9uQ2FudmFzTWFwID0gYW5ub3RhdGlvbkNhbnZhc01hcDtcbiAgICB0aGlzLmwxMG4gPSBsMTBuO1xuICAgIHRoaXMucGFnZSA9IHBhZ2U7XG4gICAgdGhpcy52aWV3cG9ydCA9IHZpZXdwb3J0O1xuICAgIHRoaXMuekluZGV4ID0gMDtcbiAgICB0aGlzLmwxMG4gfHw9IF9kaXNwbGF5TDEwbl91dGlscy5OdWxsTDEwbjtcbiAgfVxuICAjYXBwZW5kRWxlbWVudChlbGVtZW50LCBpZCkge1xuICAgIGNvbnN0IGNvbnRlbnRFbGVtZW50ID0gZWxlbWVudC5maXJzdENoaWxkIHx8IGVsZW1lbnQ7XG4gICAgY29udGVudEVsZW1lbnQuaWQgPSBgJHtfdXRpbC5Bbm5vdGF0aW9uUHJlZml4fSR7aWR9YDtcbiAgICB0aGlzLmRpdi5hcHBlbmQoZWxlbWVudCk7XG4gICAgdGhpcy4jYWNjZXNzaWJpbGl0eU1hbmFnZXI/Lm1vdmVFbGVtZW50SW5ET00odGhpcy5kaXYsIGVsZW1lbnQsIGNvbnRlbnRFbGVtZW50LCBmYWxzZSk7XG4gIH1cbiAgYXN5bmMgcmVuZGVyKHBhcmFtcykge1xuICAgIGNvbnN0IHtcbiAgICAgIGFubm90YXRpb25zXG4gICAgfSA9IHBhcmFtcztcbiAgICBjb25zdCBsYXllciA9IHRoaXMuZGl2O1xuICAgICgwLCBfZGlzcGxheV91dGlscy5zZXRMYXllckRpbWVuc2lvbnMpKGxheWVyLCB0aGlzLnZpZXdwb3J0KTtcbiAgICBjb25zdCBwb3B1cFRvRWxlbWVudHMgPSBuZXcgTWFwKCk7XG4gICAgY29uc3QgZWxlbWVudFBhcmFtcyA9IHtcbiAgICAgIGRhdGE6IG51bGwsXG4gICAgICBsYXllcixcbiAgICAgIGxpbmtTZXJ2aWNlOiBwYXJhbXMubGlua1NlcnZpY2UsXG4gICAgICBkb3dubG9hZE1hbmFnZXI6IHBhcmFtcy5kb3dubG9hZE1hbmFnZXIsXG4gICAgICBpbWFnZVJlc291cmNlc1BhdGg6IHBhcmFtcy5pbWFnZVJlc291cmNlc1BhdGggfHwgXCJcIixcbiAgICAgIHJlbmRlckZvcm1zOiBwYXJhbXMucmVuZGVyRm9ybXMgIT09IGZhbHNlLFxuICAgICAgc3ZnRmFjdG9yeTogbmV3IF9kaXNwbGF5X3V0aWxzLkRPTVNWR0ZhY3RvcnkoKSxcbiAgICAgIGFubm90YXRpb25TdG9yYWdlOiBwYXJhbXMuYW5ub3RhdGlvblN0b3JhZ2UgfHwgbmV3IF9hbm5vdGF0aW9uX3N0b3JhZ2UuQW5ub3RhdGlvblN0b3JhZ2UoKSxcbiAgICAgIGVuYWJsZVNjcmlwdGluZzogcGFyYW1zLmVuYWJsZVNjcmlwdGluZyA9PT0gdHJ1ZSxcbiAgICAgIGhhc0pTQWN0aW9uczogcGFyYW1zLmhhc0pTQWN0aW9ucyxcbiAgICAgIGZpZWxkT2JqZWN0czogcGFyYW1zLmZpZWxkT2JqZWN0cyxcbiAgICAgIHBhcmVudDogdGhpcyxcbiAgICAgIGVsZW1lbnRzOiBudWxsXG4gICAgfTtcbiAgICBmb3IgKGNvbnN0IGRhdGEgb2YgYW5ub3RhdGlvbnMpIHtcbiAgICAgIGlmIChkYXRhLm5vSFRNTCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGlzUG9wdXBBbm5vdGF0aW9uID0gZGF0YS5hbm5vdGF0aW9uVHlwZSA9PT0gX3V0aWwuQW5ub3RhdGlvblR5cGUuUE9QVVA7XG4gICAgICBpZiAoIWlzUG9wdXBBbm5vdGF0aW9uKSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICB3aWR0aCxcbiAgICAgICAgICBoZWlnaHRcbiAgICAgICAgfSA9IGdldFJlY3REaW1zKGRhdGEucmVjdCk7XG4gICAgICAgIGlmICh3aWR0aCA8PSAwIHx8IGhlaWdodCA8PSAwKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnRzID0gcG9wdXBUb0VsZW1lbnRzLmdldChkYXRhLmlkKTtcbiAgICAgICAgaWYgKCFlbGVtZW50cykge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsZW1lbnRQYXJhbXMuZWxlbWVudHMgPSBlbGVtZW50cztcbiAgICAgIH1cbiAgICAgIGVsZW1lbnRQYXJhbXMuZGF0YSA9IGRhdGE7XG4gICAgICBjb25zdCBlbGVtZW50ID0gQW5ub3RhdGlvbkVsZW1lbnRGYWN0b3J5LmNyZWF0ZShlbGVtZW50UGFyYW1zKTtcbiAgICAgIGlmICghZWxlbWVudC5pc1JlbmRlcmFibGUpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoIWlzUG9wdXBBbm5vdGF0aW9uICYmIGRhdGEucG9wdXBSZWYpIHtcbiAgICAgICAgY29uc3QgZWxlbWVudHMgPSBwb3B1cFRvRWxlbWVudHMuZ2V0KGRhdGEucG9wdXBSZWYpO1xuICAgICAgICBpZiAoIWVsZW1lbnRzKSB7XG4gICAgICAgICAgcG9wdXBUb0VsZW1lbnRzLnNldChkYXRhLnBvcHVwUmVmLCBbZWxlbWVudF0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVsZW1lbnRzLnB1c2goZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChlbGVtZW50LmFubm90YXRpb25FZGl0b3JUeXBlID4gMCkge1xuICAgICAgICB0aGlzLiNlZGl0YWJsZUFubm90YXRpb25zLnNldChlbGVtZW50LmRhdGEuaWQsIGVsZW1lbnQpO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVuZGVyZWQgPSBlbGVtZW50LnJlbmRlcigpO1xuICAgICAgaWYgKGRhdGEuaGlkZGVuKSB7XG4gICAgICAgIHJlbmRlcmVkLnN0eWxlLnZpc2liaWxpdHkgPSBcImhpZGRlblwiO1xuICAgICAgfVxuICAgICAgdGhpcy4jYXBwZW5kRWxlbWVudChyZW5kZXJlZCwgZGF0YS5pZCk7XG4gICAgfVxuICAgIHRoaXMuI3NldEFubm90YXRpb25DYW52YXNNYXAoKTtcbiAgICBhd2FpdCB0aGlzLmwxMG4udHJhbnNsYXRlKGxheWVyKTtcbiAgfVxuICB1cGRhdGUoe1xuICAgIHZpZXdwb3J0XG4gIH0pIHtcbiAgICBjb25zdCBsYXllciA9IHRoaXMuZGl2O1xuICAgIHRoaXMudmlld3BvcnQgPSB2aWV3cG9ydDtcbiAgICAoMCwgX2Rpc3BsYXlfdXRpbHMuc2V0TGF5ZXJEaW1lbnNpb25zKShsYXllciwge1xuICAgICAgcm90YXRpb246IHZpZXdwb3J0LnJvdGF0aW9uXG4gICAgfSk7XG4gICAgdGhpcy4jc2V0QW5ub3RhdGlvbkNhbnZhc01hcCgpO1xuICAgIGxheWVyLmhpZGRlbiA9IGZhbHNlO1xuICB9XG4gICNzZXRBbm5vdGF0aW9uQ2FudmFzTWFwKCkge1xuICAgIGlmICghdGhpcy4jYW5ub3RhdGlvbkNhbnZhc01hcCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBsYXllciA9IHRoaXMuZGl2O1xuICAgIGZvciAoY29uc3QgW2lkLCBjYW52YXNdIG9mIHRoaXMuI2Fubm90YXRpb25DYW52YXNNYXApIHtcbiAgICAgIGNvbnN0IGVsZW1lbnQgPSBsYXllci5xdWVyeVNlbGVjdG9yKGBbZGF0YS1hbm5vdGF0aW9uLWlkPVwiJHtpZH1cIl1gKTtcbiAgICAgIGlmICghZWxlbWVudCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZmlyc3RDaGlsZFxuICAgICAgfSA9IGVsZW1lbnQ7XG4gICAgICBpZiAoIWZpcnN0Q2hpbGQpIHtcbiAgICAgICAgZWxlbWVudC5hcHBlbmQoY2FudmFzKTtcbiAgICAgIH0gZWxzZSBpZiAoZmlyc3RDaGlsZC5ub2RlTmFtZSA9PT0gXCJDQU5WQVNcIikge1xuICAgICAgICBmaXJzdENoaWxkLnJlcGxhY2VXaXRoKGNhbnZhcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmaXJzdENoaWxkLmJlZm9yZShjYW52YXMpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLiNhbm5vdGF0aW9uQ2FudmFzTWFwLmNsZWFyKCk7XG4gIH1cbiAgZ2V0RWRpdGFibGVBbm5vdGF0aW9ucygpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLiNlZGl0YWJsZUFubm90YXRpb25zLnZhbHVlcygpKTtcbiAgfVxuICBnZXRFZGl0YWJsZUFubm90YXRpb24oaWQpIHtcbiAgICByZXR1cm4gdGhpcy4jZWRpdGFibGVBbm5vdGF0aW9ucy5nZXQoaWQpO1xuICB9XG59XG5leHBvcnRzLkFubm90YXRpb25MYXllciA9IEFubm90YXRpb25MYXllcjtcblxuLyoqKi8gfSksXG4vKiAzMCAqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cykgPT4ge1xuXG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xuZXhwb3J0cy5Db2xvckNvbnZlcnRlcnMgPSB2b2lkIDA7XG5mdW5jdGlvbiBtYWtlQ29sb3JDb21wKG4pIHtcbiAgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgbikpICogMjU1KS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgXCIwXCIpO1xufVxuZnVuY3Rpb24gc2NhbGVBbmRDbGFtcCh4KSB7XG4gIHJldHVybiBNYXRoLm1heCgwLCBNYXRoLm1pbigyNTUsIDI1NSAqIHgpKTtcbn1cbmNsYXNzIENvbG9yQ29udmVydGVycyB7XG4gIHN0YXRpYyBDTVlLX0coW2MsIHksIG0sIGtdKSB7XG4gICAgcmV0dXJuIFtcIkdcIiwgMSAtIE1hdGgubWluKDEsIDAuMyAqIGMgKyAwLjU5ICogbSArIDAuMTEgKiB5ICsgayldO1xuICB9XG4gIHN0YXRpYyBHX0NNWUsoW2ddKSB7XG4gICAgcmV0dXJuIFtcIkNNWUtcIiwgMCwgMCwgMCwgMSAtIGddO1xuICB9XG4gIHN0YXRpYyBHX1JHQihbZ10pIHtcbiAgICByZXR1cm4gW1wiUkdCXCIsIGcsIGcsIGddO1xuICB9XG4gIHN0YXRpYyBHX3JnYihbZ10pIHtcbiAgICBnID0gc2NhbGVBbmRDbGFtcChnKTtcbiAgICByZXR1cm4gW2csIGcsIGddO1xuICB9XG4gIHN0YXRpYyBHX0hUTUwoW2ddKSB7XG4gICAgY29uc3QgRyA9IG1ha2VDb2xvckNvbXAoZyk7XG4gICAgcmV0dXJuIGAjJHtHfSR7R30ke0d9YDtcbiAgfVxuICBzdGF0aWMgUkdCX0coW3IsIGcsIGJdKSB7XG4gICAgcmV0dXJuIFtcIkdcIiwgMC4zICogciArIDAuNTkgKiBnICsgMC4xMSAqIGJdO1xuICB9XG4gIHN0YXRpYyBSR0JfcmdiKGNvbG9yKSB7XG4gICAgcmV0dXJuIGNvbG9yLm1hcChzY2FsZUFuZENsYW1wKTtcbiAgfVxuICBzdGF0aWMgUkdCX0hUTUwoY29sb3IpIHtcbiAgICByZXR1cm4gYCMke2NvbG9yLm1hcChtYWtlQ29sb3JDb21wKS5qb2luKFwiXCIpfWA7XG4gIH1cbiAgc3RhdGljIFRfSFRNTCgpIHtcbiAgICByZXR1cm4gXCIjMDAwMDAwMDBcIjtcbiAgfVxuICBzdGF0aWMgVF9yZ2IoKSB7XG4gICAgcmV0dXJuIFtudWxsXTtcbiAgfVxuICBzdGF0aWMgQ01ZS19SR0IoW2MsIHksIG0sIGtdKSB7XG4gICAgcmV0dXJuIFtcIlJHQlwiLCAxIC0gTWF0aC5taW4oMSwgYyArIGspLCAxIC0gTWF0aC5taW4oMSwgbSArIGspLCAxIC0gTWF0aC5taW4oMSwgeSArIGspXTtcbiAgfVxuICBzdGF0aWMgQ01ZS19yZ2IoW2MsIHksIG0sIGtdKSB7XG4gICAgcmV0dXJuIFtzY2FsZUFuZENsYW1wKDEgLSBNYXRoLm1pbigxLCBjICsgaykpLCBzY2FsZUFuZENsYW1wKDEgLSBNYXRoLm1pbigxLCBtICsgaykpLCBzY2FsZUFuZENsYW1wKDEgLSBNYXRoLm1pbigxLCB5ICsgaykpXTtcbiAgfVxuICBzdGF0aWMgQ01ZS19IVE1MKGNvbXBvbmVudHMpIHtcbiAgICBjb25zdCByZ2IgPSB0aGlzLkNNWUtfUkdCKGNvbXBvbmVudHMpLnNsaWNlKDEpO1xuICAgIHJldHVybiB0aGlzLlJHQl9IVE1MKHJnYik7XG4gIH1cbiAgc3RhdGljIFJHQl9DTVlLKFtyLCBnLCBiXSkge1xuICAgIGNvbnN0IGMgPSAxIC0gcjtcbiAgICBjb25zdCBtID0gMSAtIGc7XG4gICAgY29uc3QgeSA9IDEgLSBiO1xuICAgIGNvbnN0IGsgPSBNYXRoLm1pbihjLCBtLCB5KTtcbiAgICByZXR1cm4gW1wiQ01ZS1wiLCBjLCBtLCB5LCBrXTtcbiAgfVxufVxuZXhwb3J0cy5Db2xvckNvbnZlcnRlcnMgPSBDb2xvckNvbnZlcnRlcnM7XG5cbi8qKiovIH0pLFxuLyogMzEgKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMpID0+IHtcblxuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcbmV4cG9ydHMuTnVsbEwxMG4gPSB2b2lkIDA7XG5leHBvcnRzLmdldEwxMG5GYWxsYmFjayA9IGdldEwxMG5GYWxsYmFjaztcbmNvbnN0IERFRkFVTFRfTDEwTl9TVFJJTkdTID0ge1xuICBvZl9wYWdlczogXCJvZiB7e3BhZ2VzQ291bnR9fVwiLFxuICBwYWdlX29mX3BhZ2VzOiBcIih7e3BhZ2VOdW1iZXJ9fSBvZiB7e3BhZ2VzQ291bnR9fSlcIixcbiAgZG9jdW1lbnRfcHJvcGVydGllc19rYjogXCJ7e3NpemVfa2J9fSBLQiAoe3tzaXplX2J9fSBieXRlcylcIixcbiAgZG9jdW1lbnRfcHJvcGVydGllc19tYjogXCJ7e3NpemVfbWJ9fSBNQiAoe3tzaXplX2J9fSBieXRlcylcIixcbiAgZG9jdW1lbnRfcHJvcGVydGllc19kYXRlX3N0cmluZzogXCJ7e2RhdGV9fSwge3t0aW1lfX1cIixcbiAgZG9jdW1lbnRfcHJvcGVydGllc19wYWdlX3NpemVfdW5pdF9pbmNoZXM6IFwiaW5cIixcbiAgZG9jdW1lbnRfcHJvcGVydGllc19wYWdlX3NpemVfdW5pdF9taWxsaW1ldGVyczogXCJtbVwiLFxuICBkb2N1bWVudF9wcm9wZXJ0aWVzX3BhZ2Vfc2l6ZV9vcmllbnRhdGlvbl9wb3J0cmFpdDogXCJwb3J0cmFpdFwiLFxuICBkb2N1bWVudF9wcm9wZXJ0aWVzX3BhZ2Vfc2l6ZV9vcmllbnRhdGlvbl9sYW5kc2NhcGU6IFwibGFuZHNjYXBlXCIsXG4gIGRvY3VtZW50X3Byb3BlcnRpZXNfcGFnZV9zaXplX25hbWVfYTM6IFwiQTNcIixcbiAgZG9jdW1lbnRfcHJvcGVydGllc19wYWdlX3NpemVfbmFtZV9hNDogXCJBNFwiLFxuICBkb2N1bWVudF9wcm9wZXJ0aWVzX3BhZ2Vfc2l6ZV9uYW1lX2xldHRlcjogXCJMZXR0ZXJcIixcbiAgZG9jdW1lbnRfcHJvcGVydGllc19wYWdlX3NpemVfbmFtZV9sZWdhbDogXCJMZWdhbFwiLFxuICBkb2N1bWVudF9wcm9wZXJ0aWVzX3BhZ2Vfc2l6ZV9kaW1lbnNpb25fc3RyaW5nOiBcInt7d2lkdGh9fSDDlyB7e2hlaWdodH19IHt7dW5pdH19ICh7e29yaWVudGF0aW9ufX0pXCIsXG4gIGRvY3VtZW50X3Byb3BlcnRpZXNfcGFnZV9zaXplX2RpbWVuc2lvbl9uYW1lX3N0cmluZzogXCJ7e3dpZHRofX0gw5cge3toZWlnaHR9fSB7e3VuaXR9fSAoe3tuYW1lfX0sIHt7b3JpZW50YXRpb259fSlcIixcbiAgZG9jdW1lbnRfcHJvcGVydGllc19saW5lYXJpemVkX3llczogXCJZZXNcIixcbiAgZG9jdW1lbnRfcHJvcGVydGllc19saW5lYXJpemVkX25vOiBcIk5vXCIsXG4gIGFkZGl0aW9uYWxfbGF5ZXJzOiBcIkFkZGl0aW9uYWwgTGF5ZXJzXCIsXG4gIHBhZ2VfbGFuZG1hcms6IFwiUGFnZSB7e3BhZ2V9fVwiLFxuICB0aHVtYl9wYWdlX3RpdGxlOiBcIlBhZ2Uge3twYWdlfX1cIixcbiAgdGh1bWJfcGFnZV9jYW52YXM6IFwiVGh1bWJuYWlsIG9mIFBhZ2Uge3twYWdlfX1cIixcbiAgZmluZF9yZWFjaGVkX3RvcDogXCJSZWFjaGVkIHRvcCBvZiBkb2N1bWVudCwgY29udGludWVkIGZyb20gYm90dG9tXCIsXG4gIGZpbmRfcmVhY2hlZF9ib3R0b206IFwiUmVhY2hlZCBlbmQgb2YgZG9jdW1lbnQsIGNvbnRpbnVlZCBmcm9tIHRvcFwiLFxuICBcImZpbmRfbWF0Y2hfY291bnRbb25lXVwiOiBcInt7Y3VycmVudH19IG9mIHt7dG90YWx9fSBtYXRjaFwiLFxuICBcImZpbmRfbWF0Y2hfY291bnRbb3RoZXJdXCI6IFwie3tjdXJyZW50fX0gb2Yge3t0b3RhbH19IG1hdGNoZXNcIixcbiAgXCJmaW5kX21hdGNoX2NvdW50X2xpbWl0W29uZV1cIjogXCJNb3JlIHRoYW4ge3tsaW1pdH19IG1hdGNoXCIsXG4gIFwiZmluZF9tYXRjaF9jb3VudF9saW1pdFtvdGhlcl1cIjogXCJNb3JlIHRoYW4ge3tsaW1pdH19IG1hdGNoZXNcIixcbiAgZmluZF9ub3RfZm91bmQ6IFwiUGhyYXNlIG5vdCBmb3VuZFwiLFxuICBwYWdlX3NjYWxlX3dpZHRoOiBcIlBhZ2UgV2lkdGhcIixcbiAgcGFnZV9zY2FsZV9maXQ6IFwiUGFnZSBGaXRcIixcbiAgcGFnZV9zY2FsZV9hdXRvOiBcIkF1dG9tYXRpYyBab29tXCIsXG4gIHBhZ2Vfc2NhbGVfYWN0dWFsOiBcIkFjdHVhbCBTaXplXCIsXG4gIHBhZ2Vfc2NhbGVfcGVyY2VudDogXCJ7e3NjYWxlfX0lXCIsXG4gIGxvYWRpbmdfZXJyb3I6IFwiQW4gZXJyb3Igb2NjdXJyZWQgd2hpbGUgbG9hZGluZyB0aGUgUERGLlwiLFxuICBpbnZhbGlkX2ZpbGVfZXJyb3I6IFwiSW52YWxpZCBvciBjb3JydXB0ZWQgUERGIGZpbGUuXCIsXG4gIG1pc3NpbmdfZmlsZV9lcnJvcjogXCJNaXNzaW5nIFBERiBmaWxlLlwiLFxuICB1bmV4cGVjdGVkX3Jlc3BvbnNlX2Vycm9yOiBcIlVuZXhwZWN0ZWQgc2VydmVyIHJlc3BvbnNlLlwiLFxuICByZW5kZXJpbmdfZXJyb3I6IFwiQW4gZXJyb3Igb2NjdXJyZWQgd2hpbGUgcmVuZGVyaW5nIHRoZSBwYWdlLlwiLFxuICBhbm5vdGF0aW9uX2RhdGVfc3RyaW5nOiBcInt7ZGF0ZX19LCB7e3RpbWV9fVwiLFxuICBwcmludGluZ19ub3Rfc3VwcG9ydGVkOiBcIldhcm5pbmc6IFByaW50aW5nIGlzIG5vdCBmdWxseSBzdXBwb3J0ZWQgYnkgdGhpcyBicm93c2VyLlwiLFxuICBwcmludGluZ19ub3RfcmVhZHk6IFwiV2FybmluZzogVGhlIFBERiBpcyBub3QgZnVsbHkgbG9hZGVkIGZvciBwcmludGluZy5cIixcbiAgd2ViX2ZvbnRzX2Rpc2FibGVkOiBcIldlYiBmb250cyBhcmUgZGlzYWJsZWQ6IHVuYWJsZSB0byB1c2UgZW1iZWRkZWQgUERGIGZvbnRzLlwiLFxuICBmcmVlX3RleHQyX2RlZmF1bHRfY29udGVudDogXCJTdGFydCB0eXBpbmfigKZcIixcbiAgZWRpdG9yX2ZyZWVfdGV4dDJfYXJpYV9sYWJlbDogXCJUZXh0IEVkaXRvclwiLFxuICBlZGl0b3JfaW5rMl9hcmlhX2xhYmVsOiBcIkRyYXcgRWRpdG9yXCIsXG4gIGVkaXRvcl9pbmtfY2FudmFzX2FyaWFfbGFiZWw6IFwiVXNlci1jcmVhdGVkIGltYWdlXCIsXG4gIGVkaXRvcl9hbHRfdGV4dF9idXR0b25fbGFiZWw6IFwiQWx0IHRleHRcIixcbiAgZWRpdG9yX2FsdF90ZXh0X2VkaXRfYnV0dG9uX2xhYmVsOiBcIkVkaXQgYWx0IHRleHRcIixcbiAgZWRpdG9yX2FsdF90ZXh0X2RlY29yYXRpdmVfdG9vbHRpcDogXCJNYXJrZWQgYXMgZGVjb3JhdGl2ZVwiXG59O1xue1xuICBERUZBVUxUX0wxME5fU1RSSU5HUy5wcmludF9wcm9ncmVzc19wZXJjZW50ID0gXCJ7e3Byb2dyZXNzfX0lXCI7XG59XG5mdW5jdGlvbiBnZXRMMTBuRmFsbGJhY2soa2V5LCBhcmdzKSB7XG4gIHN3aXRjaCAoa2V5KSB7XG4gICAgY2FzZSBcImZpbmRfbWF0Y2hfY291bnRcIjpcbiAgICAgIGtleSA9IGBmaW5kX21hdGNoX2NvdW50WyR7YXJncy50b3RhbCA9PT0gMSA/IFwib25lXCIgOiBcIm90aGVyXCJ9XWA7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiZmluZF9tYXRjaF9jb3VudF9saW1pdFwiOlxuICAgICAga2V5ID0gYGZpbmRfbWF0Y2hfY291bnRfbGltaXRbJHthcmdzLmxpbWl0ID09PSAxID8gXCJvbmVcIiA6IFwib3RoZXJcIn1dYDtcbiAgICAgIGJyZWFrO1xuICB9XG4gIHJldHVybiBERUZBVUxUX0wxME5fU1RSSU5HU1trZXldIHx8IFwiXCI7XG59XG5mdW5jdGlvbiBmb3JtYXRMMTBuVmFsdWUodGV4dCwgYXJncykge1xuICBpZiAoIWFyZ3MpIHtcbiAgICByZXR1cm4gdGV4dDtcbiAgfVxuICByZXR1cm4gdGV4dC5yZXBsYWNlQWxsKC9cXHtcXHtcXHMqKFxcdyspXFxzKlxcfVxcfS9nLCAoYWxsLCBuYW1lKSA9PiB7XG4gICAgcmV0dXJuIG5hbWUgaW4gYXJncyA/IGFyZ3NbbmFtZV0gOiBcInt7XCIgKyBuYW1lICsgXCJ9fVwiO1xuICB9KTtcbn1cbmNvbnN0IE51bGxMMTBuID0ge1xuICBhc3luYyBnZXRMYW5ndWFnZSgpIHtcbiAgICByZXR1cm4gXCJlbi11c1wiO1xuICB9LFxuICBhc3luYyBnZXREaXJlY3Rpb24oKSB7XG4gICAgcmV0dXJuIFwibHRyXCI7XG4gIH0sXG4gIGFzeW5jIGdldChrZXksIGFyZ3MgPSBudWxsLCBmYWxsYmFjayA9IGdldEwxMG5GYWxsYmFjayhrZXksIGFyZ3MpKSB7XG4gICAgcmV0dXJuIGZvcm1hdEwxMG5WYWx1ZShmYWxsYmFjaywgYXJncyk7XG4gIH0sXG4gIGFzeW5jIHRyYW5zbGF0ZShlbGVtZW50KSB7fVxufTtcbmV4cG9ydHMuTnVsbEwxMG4gPSBOdWxsTDEwbjtcblxuLyoqKi8gfSksXG4vKiAzMiAqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykgPT4ge1xuXG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xuZXhwb3J0cy5YZmFMYXllciA9IHZvaWQgMDtcbnZhciBfeGZhX3RleHQgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDI1KTtcbmNsYXNzIFhmYUxheWVyIHtcbiAgc3RhdGljIHNldHVwU3RvcmFnZShodG1sLCBpZCwgZWxlbWVudCwgc3RvcmFnZSwgaW50ZW50KSB7XG4gICAgY29uc3Qgc3RvcmVkRGF0YSA9IHN0b3JhZ2UuZ2V0VmFsdWUoaWQsIHtcbiAgICAgIHZhbHVlOiBudWxsXG4gICAgfSk7XG4gICAgc3dpdGNoIChlbGVtZW50Lm5hbWUpIHtcbiAgICAgIGNhc2UgXCJ0ZXh0YXJlYVwiOlxuICAgICAgICBpZiAoc3RvcmVkRGF0YS52YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgIGh0bWwudGV4dENvbnRlbnQgPSBzdG9yZWREYXRhLnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbnRlbnQgPT09IFwicHJpbnRcIikge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGh0bWwuYWRkRXZlbnRMaXN0ZW5lcihcImlucHV0XCIsIGV2ZW50ID0+IHtcbiAgICAgICAgICBzdG9yYWdlLnNldFZhbHVlKGlkLCB7XG4gICAgICAgICAgICB2YWx1ZTogZXZlbnQudGFyZ2V0LnZhbHVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJpbnB1dFwiOlxuICAgICAgICBpZiAoZWxlbWVudC5hdHRyaWJ1dGVzLnR5cGUgPT09IFwicmFkaW9cIiB8fCBlbGVtZW50LmF0dHJpYnV0ZXMudHlwZSA9PT0gXCJjaGVja2JveFwiKSB7XG4gICAgICAgICAgaWYgKHN0b3JlZERhdGEudmFsdWUgPT09IGVsZW1lbnQuYXR0cmlidXRlcy54ZmFPbikge1xuICAgICAgICAgICAgaHRtbC5zZXRBdHRyaWJ1dGUoXCJjaGVja2VkXCIsIHRydWUpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoc3RvcmVkRGF0YS52YWx1ZSA9PT0gZWxlbWVudC5hdHRyaWJ1dGVzLnhmYU9mZikge1xuICAgICAgICAgICAgaHRtbC5yZW1vdmVBdHRyaWJ1dGUoXCJjaGVja2VkXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaW50ZW50ID09PSBcInByaW50XCIpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBodG1sLmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgZXZlbnQgPT4ge1xuICAgICAgICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwge1xuICAgICAgICAgICAgICB2YWx1ZTogZXZlbnQudGFyZ2V0LmNoZWNrZWQgPyBldmVudC50YXJnZXQuZ2V0QXR0cmlidXRlKFwieGZhT25cIikgOiBldmVudC50YXJnZXQuZ2V0QXR0cmlidXRlKFwieGZhT2ZmXCIpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoc3RvcmVkRGF0YS52YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaHRtbC5zZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiLCBzdG9yZWREYXRhLnZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGludGVudCA9PT0gXCJwcmludFwiKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgaHRtbC5hZGRFdmVudExpc3RlbmVyKFwiaW5wdXRcIiwgZXZlbnQgPT4ge1xuICAgICAgICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwge1xuICAgICAgICAgICAgICB2YWx1ZTogZXZlbnQudGFyZ2V0LnZhbHVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJzZWxlY3RcIjpcbiAgICAgICAgaWYgKHN0b3JlZERhdGEudmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgICBodG1sLnNldEF0dHJpYnV0ZShcInZhbHVlXCIsIHN0b3JlZERhdGEudmFsdWUpO1xuICAgICAgICAgIGZvciAoY29uc3Qgb3B0aW9uIG9mIGVsZW1lbnQuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGlmIChvcHRpb24uYXR0cmlidXRlcy52YWx1ZSA9PT0gc3RvcmVkRGF0YS52YWx1ZSkge1xuICAgICAgICAgICAgICBvcHRpb24uYXR0cmlidXRlcy5zZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG9wdGlvbi5hdHRyaWJ1dGVzLmhhc093blByb3BlcnR5KFwic2VsZWN0ZWRcIikpIHtcbiAgICAgICAgICAgICAgZGVsZXRlIG9wdGlvbi5hdHRyaWJ1dGVzLnNlbGVjdGVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBodG1sLmFkZEV2ZW50TGlzdGVuZXIoXCJpbnB1dFwiLCBldmVudCA9PiB7XG4gICAgICAgICAgY29uc3Qgb3B0aW9ucyA9IGV2ZW50LnRhcmdldC5vcHRpb25zO1xuICAgICAgICAgIGNvbnN0IHZhbHVlID0gb3B0aW9ucy5zZWxlY3RlZEluZGV4ID09PSAtMSA/IFwiXCIgOiBvcHRpb25zW29wdGlvbnMuc2VsZWN0ZWRJbmRleF0udmFsdWU7XG4gICAgICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwge1xuICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgc2V0QXR0cmlidXRlcyh7XG4gICAgaHRtbCxcbiAgICBlbGVtZW50LFxuICAgIHN0b3JhZ2UgPSBudWxsLFxuICAgIGludGVudCxcbiAgICBsaW5rU2VydmljZVxuICB9KSB7XG4gICAgY29uc3Qge1xuICAgICAgYXR0cmlidXRlc1xuICAgIH0gPSBlbGVtZW50O1xuICAgIGNvbnN0IGlzSFRNTEFuY2hvckVsZW1lbnQgPSBodG1sIGluc3RhbmNlb2YgSFRNTEFuY2hvckVsZW1lbnQ7XG4gICAgaWYgKGF0dHJpYnV0ZXMudHlwZSA9PT0gXCJyYWRpb1wiKSB7XG4gICAgICBhdHRyaWJ1dGVzLm5hbWUgPSBgJHthdHRyaWJ1dGVzLm5hbWV9LSR7aW50ZW50fWA7XG4gICAgfVxuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGF0dHJpYnV0ZXMpKSB7XG4gICAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAoa2V5KSB7XG4gICAgICAgIGNhc2UgXCJjbGFzc1wiOlxuICAgICAgICAgIGlmICh2YWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGh0bWwuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUuam9pbihcIiBcIikpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImRhdGFJZFwiOlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiaWRcIjpcbiAgICAgICAgICBodG1sLnNldEF0dHJpYnV0ZShcImRhdGEtZWxlbWVudC1pZFwiLCB2YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJzdHlsZVwiOlxuICAgICAgICAgIE9iamVjdC5hc3NpZ24oaHRtbC5zdHlsZSwgdmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwidGV4dENvbnRlbnRcIjpcbiAgICAgICAgICBodG1sLnRleHRDb250ZW50ID0gdmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgaWYgKCFpc0hUTUxBbmNob3JFbGVtZW50IHx8IGtleSAhPT0gXCJocmVmXCIgJiYga2V5ICE9PSBcIm5ld1dpbmRvd1wiKSB7XG4gICAgICAgICAgICBodG1sLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpc0hUTUxBbmNob3JFbGVtZW50KSB7XG4gICAgICBsaW5rU2VydmljZS5hZGRMaW5rQXR0cmlidXRlcyhodG1sLCBhdHRyaWJ1dGVzLmhyZWYsIGF0dHJpYnV0ZXMubmV3V2luZG93KTtcbiAgICB9XG4gICAgaWYgKHN0b3JhZ2UgJiYgYXR0cmlidXRlcy5kYXRhSWQpIHtcbiAgICAgIHRoaXMuc2V0dXBTdG9yYWdlKGh0bWwsIGF0dHJpYnV0ZXMuZGF0YUlkLCBlbGVtZW50LCBzdG9yYWdlKTtcbiAgICB9XG4gIH1cbiAgc3RhdGljIHJlbmRlcihwYXJhbWV0ZXJzKSB7XG4gICAgY29uc3Qgc3RvcmFnZSA9IHBhcmFtZXRlcnMuYW5ub3RhdGlvblN0b3JhZ2U7XG4gICAgY29uc3QgbGlua1NlcnZpY2UgPSBwYXJhbWV0ZXJzLmxpbmtTZXJ2aWNlO1xuICAgIGNvbnN0IHJvb3QgPSBwYXJhbWV0ZXJzLnhmYUh0bWw7XG4gICAgY29uc3QgaW50ZW50ID0gcGFyYW1ldGVycy5pbnRlbnQgfHwgXCJkaXNwbGF5XCI7XG4gICAgY29uc3Qgcm9vdEh0bWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHJvb3QubmFtZSk7XG4gICAgaWYgKHJvb3QuYXR0cmlidXRlcykge1xuICAgICAgdGhpcy5zZXRBdHRyaWJ1dGVzKHtcbiAgICAgICAgaHRtbDogcm9vdEh0bWwsXG4gICAgICAgIGVsZW1lbnQ6IHJvb3QsXG4gICAgICAgIGludGVudCxcbiAgICAgICAgbGlua1NlcnZpY2VcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBzdGFjayA9IFtbcm9vdCwgLTEsIHJvb3RIdG1sXV07XG4gICAgY29uc3Qgcm9vdERpdiA9IHBhcmFtZXRlcnMuZGl2O1xuICAgIHJvb3REaXYuYXBwZW5kKHJvb3RIdG1sKTtcbiAgICBpZiAocGFyYW1ldGVycy52aWV3cG9ydCkge1xuICAgICAgY29uc3QgdHJhbnNmb3JtID0gYG1hdHJpeCgke3BhcmFtZXRlcnMudmlld3BvcnQudHJhbnNmb3JtLmpvaW4oXCIsXCIpfSlgO1xuICAgICAgcm9vdERpdi5zdHlsZS50cmFuc2Zvcm0gPSB0cmFuc2Zvcm07XG4gICAgfVxuICAgIGlmIChpbnRlbnQgIT09IFwicmljaFRleHRcIikge1xuICAgICAgcm9vdERpdi5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCBcInhmYUxheWVyIHhmYUZvbnRcIik7XG4gICAgfVxuICAgIGNvbnN0IHRleHREaXZzID0gW107XG4gICAgd2hpbGUgKHN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IFtwYXJlbnQsIGksIGh0bWxdID0gc3RhY2suYXQoLTEpO1xuICAgICAgaWYgKGkgKyAxID09PSBwYXJlbnQuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNoaWxkID0gcGFyZW50LmNoaWxkcmVuWysrc3RhY2suYXQoLTEpWzFdXTtcbiAgICAgIGlmIChjaGlsZCA9PT0gbnVsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbmFtZVxuICAgICAgfSA9IGNoaWxkO1xuICAgICAgaWYgKG5hbWUgPT09IFwiI3RleHRcIikge1xuICAgICAgICBjb25zdCBub2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY2hpbGQudmFsdWUpO1xuICAgICAgICB0ZXh0RGl2cy5wdXNoKG5vZGUpO1xuICAgICAgICBodG1sLmFwcGVuZChub2RlKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBjaGlsZEh0bWwgPSBjaGlsZD8uYXR0cmlidXRlcz8ueG1sbnMgPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoY2hpbGQuYXR0cmlidXRlcy54bWxucywgbmFtZSkgOiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KG5hbWUpO1xuICAgICAgaHRtbC5hcHBlbmQoY2hpbGRIdG1sKTtcbiAgICAgIGlmIChjaGlsZC5hdHRyaWJ1dGVzKSB7XG4gICAgICAgIHRoaXMuc2V0QXR0cmlidXRlcyh7XG4gICAgICAgICAgaHRtbDogY2hpbGRIdG1sLFxuICAgICAgICAgIGVsZW1lbnQ6IGNoaWxkLFxuICAgICAgICAgIHN0b3JhZ2UsXG4gICAgICAgICAgaW50ZW50LFxuICAgICAgICAgIGxpbmtTZXJ2aWNlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKGNoaWxkLmNoaWxkcmVuICYmIGNoaWxkLmNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgICAgc3RhY2sucHVzaChbY2hpbGQsIC0xLCBjaGlsZEh0bWxdKTtcbiAgICAgIH0gZWxzZSBpZiAoY2hpbGQudmFsdWUpIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNoaWxkLnZhbHVlKTtcbiAgICAgICAgaWYgKF94ZmFfdGV4dC5YZmFUZXh0LnNob3VsZEJ1aWxkVGV4dChuYW1lKSkge1xuICAgICAgICAgIHRleHREaXZzLnB1c2gobm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2hpbGRIdG1sLmFwcGVuZChub2RlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCBlbCBvZiByb290RGl2LnF1ZXJ5U2VsZWN0b3JBbGwoXCIueGZhTm9uSW50ZXJhY3RpdmUgaW5wdXQsIC54ZmFOb25JbnRlcmFjdGl2ZSB0ZXh0YXJlYVwiKSkge1xuICAgICAgZWwuc2V0QXR0cmlidXRlKFwicmVhZE9ubHlcIiwgdHJ1ZSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0ZXh0RGl2c1xuICAgIH07XG4gIH1cbiAgc3RhdGljIHVwZGF0ZShwYXJhbWV0ZXJzKSB7XG4gICAgY29uc3QgdHJhbnNmb3JtID0gYG1hdHJpeCgke3BhcmFtZXRlcnMudmlld3BvcnQudHJhbnNmb3JtLmpvaW4oXCIsXCIpfSlgO1xuICAgIHBhcmFtZXRlcnMuZGl2LnN0eWxlLnRyYW5zZm9ybSA9IHRyYW5zZm9ybTtcbiAgICBwYXJhbWV0ZXJzLmRpdi5oaWRkZW4gPSBmYWxzZTtcbiAgfVxufVxuZXhwb3J0cy5YZmFMYXllciA9IFhmYUxheWVyO1xuXG4vKioqLyB9KSxcbi8qIDMzICovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSA9PiB7XG5cblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5leHBvcnRzLklua0VkaXRvciA9IHZvaWQgMDtcbnZhciBfdXRpbCA9IF9fd19wZGZqc19yZXF1aXJlX18oMSk7XG52YXIgX2VkaXRvciA9IF9fd19wZGZqc19yZXF1aXJlX18oNCk7XG52YXIgX2Fubm90YXRpb25fbGF5ZXIgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDI5KTtcbnZhciBfZGlzcGxheV91dGlscyA9IF9fd19wZGZqc19yZXF1aXJlX18oNik7XG52YXIgX3Rvb2xzID0gX193X3BkZmpzX3JlcXVpcmVfXyg1KTtcbmNsYXNzIElua0VkaXRvciBleHRlbmRzIF9lZGl0b3IuQW5ub3RhdGlvbkVkaXRvciB7XG4gICNiYXNlSGVpZ2h0ID0gMDtcbiAgI2Jhc2VXaWR0aCA9IDA7XG4gICNib3VuZENhbnZhc1BvaW50ZXJtb3ZlID0gdGhpcy5jYW52YXNQb2ludGVybW92ZS5iaW5kKHRoaXMpO1xuICAjYm91bmRDYW52YXNQb2ludGVybGVhdmUgPSB0aGlzLmNhbnZhc1BvaW50ZXJsZWF2ZS5iaW5kKHRoaXMpO1xuICAjYm91bmRDYW52YXNQb2ludGVydXAgPSB0aGlzLmNhbnZhc1BvaW50ZXJ1cC5iaW5kKHRoaXMpO1xuICAjYm91bmRDYW52YXNQb2ludGVyZG93biA9IHRoaXMuY2FudmFzUG9pbnRlcmRvd24uYmluZCh0aGlzKTtcbiAgI2N1cnJlbnRQYXRoMkQgPSBuZXcgUGF0aDJEKCk7XG4gICNkaXNhYmxlRWRpdGluZyA9IGZhbHNlO1xuICAjaGFzU29tZXRoaW5nVG9EcmF3ID0gZmFsc2U7XG4gICNpc0NhbnZhc0luaXRpYWxpemVkID0gZmFsc2U7XG4gICNvYnNlcnZlciA9IG51bGw7XG4gICNyZWFsV2lkdGggPSAwO1xuICAjcmVhbEhlaWdodCA9IDA7XG4gICNyZXF1ZXN0RnJhbWVDYWxsYmFjayA9IG51bGw7XG4gIHN0YXRpYyBfZGVmYXVsdENvbG9yID0gbnVsbDtcbiAgc3RhdGljIF9kZWZhdWx0T3BhY2l0eSA9IDE7XG4gIHN0YXRpYyBfZGVmYXVsdFRoaWNrbmVzcyA9IDE7XG4gIHN0YXRpYyBfdHlwZSA9IFwiaW5rXCI7XG4gIGNvbnN0cnVjdG9yKHBhcmFtcykge1xuICAgIHN1cGVyKHtcbiAgICAgIC4uLnBhcmFtcyxcbiAgICAgIG5hbWU6IFwiaW5rRWRpdG9yXCJcbiAgICB9KTtcbiAgICB0aGlzLmNvbG9yID0gcGFyYW1zLmNvbG9yIHx8IG51bGw7XG4gICAgdGhpcy50aGlja25lc3MgPSBwYXJhbXMudGhpY2tuZXNzIHx8IG51bGw7XG4gICAgdGhpcy5vcGFjaXR5ID0gcGFyYW1zLm9wYWNpdHkgfHwgbnVsbDtcbiAgICB0aGlzLnBhdGhzID0gW107XG4gICAgdGhpcy5iZXppZXJQYXRoMkQgPSBbXTtcbiAgICB0aGlzLmFsbFJhd1BhdGhzID0gW107XG4gICAgdGhpcy5jdXJyZW50UGF0aCA9IFtdO1xuICAgIHRoaXMuc2NhbGVGYWN0b3IgPSAxO1xuICAgIHRoaXMudHJhbnNsYXRpb25YID0gdGhpcy50cmFuc2xhdGlvblkgPSAwO1xuICAgIHRoaXMueCA9IDA7XG4gICAgdGhpcy55ID0gMDtcbiAgICB0aGlzLl93aWxsS2VlcEFzcGVjdFJhdGlvID0gdHJ1ZTtcbiAgfVxuICBzdGF0aWMgaW5pdGlhbGl6ZShsMTBuKSB7XG4gICAgX2VkaXRvci5Bbm5vdGF0aW9uRWRpdG9yLmluaXRpYWxpemUobDEwbiwge1xuICAgICAgc3RyaW5nczogW1wiZWRpdG9yX2lua19jYW52YXNfYXJpYV9sYWJlbFwiLCBcImVkaXRvcl9pbmsyX2FyaWFfbGFiZWxcIl1cbiAgICB9KTtcbiAgfVxuICBzdGF0aWMgdXBkYXRlRGVmYXVsdFBhcmFtcyh0eXBlLCB2YWx1ZSkge1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSBfdXRpbC5Bbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5JTktfVEhJQ0tORVNTOlxuICAgICAgICBJbmtFZGl0b3IuX2RlZmF1bHRUaGlja25lc3MgPSB2YWx1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIF91dGlsLkFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLklOS19DT0xPUjpcbiAgICAgICAgSW5rRWRpdG9yLl9kZWZhdWx0Q29sb3IgPSB2YWx1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIF91dGlsLkFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLklOS19PUEFDSVRZOlxuICAgICAgICBJbmtFZGl0b3IuX2RlZmF1bHRPcGFjaXR5ID0gdmFsdWUgLyAxMDA7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICB1cGRhdGVQYXJhbXModHlwZSwgdmFsdWUpIHtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgX3V0aWwuQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuSU5LX1RISUNLTkVTUzpcbiAgICAgICAgdGhpcy4jdXBkYXRlVGhpY2tuZXNzKHZhbHVlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIF91dGlsLkFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLklOS19DT0xPUjpcbiAgICAgICAgdGhpcy4jdXBkYXRlQ29sb3IodmFsdWUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgX3V0aWwuQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuSU5LX09QQUNJVFk6XG4gICAgICAgIHRoaXMuI3VwZGF0ZU9wYWNpdHkodmFsdWUpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgc3RhdGljIGdldCBkZWZhdWx0UHJvcGVydGllc1RvVXBkYXRlKCkge1xuICAgIHJldHVybiBbW191dGlsLkFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLklOS19USElDS05FU1MsIElua0VkaXRvci5fZGVmYXVsdFRoaWNrbmVzc10sIFtfdXRpbC5Bbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5JTktfQ09MT1IsIElua0VkaXRvci5fZGVmYXVsdENvbG9yIHx8IF9lZGl0b3IuQW5ub3RhdGlvbkVkaXRvci5fZGVmYXVsdExpbmVDb2xvcl0sIFtfdXRpbC5Bbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5JTktfT1BBQ0lUWSwgTWF0aC5yb3VuZChJbmtFZGl0b3IuX2RlZmF1bHRPcGFjaXR5ICogMTAwKV1dO1xuICB9XG4gIGdldCBwcm9wZXJ0aWVzVG9VcGRhdGUoKSB7XG4gICAgcmV0dXJuIFtbX3V0aWwuQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuSU5LX1RISUNLTkVTUywgdGhpcy50aGlja25lc3MgfHwgSW5rRWRpdG9yLl9kZWZhdWx0VGhpY2tuZXNzXSwgW191dGlsLkFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLklOS19DT0xPUiwgdGhpcy5jb2xvciB8fCBJbmtFZGl0b3IuX2RlZmF1bHRDb2xvciB8fCBfZWRpdG9yLkFubm90YXRpb25FZGl0b3IuX2RlZmF1bHRMaW5lQ29sb3JdLCBbX3V0aWwuQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuSU5LX09QQUNJVFksIE1hdGgucm91bmQoMTAwICogKHRoaXMub3BhY2l0eSA/PyBJbmtFZGl0b3IuX2RlZmF1bHRPcGFjaXR5KSldXTtcbiAgfVxuICAjdXBkYXRlVGhpY2tuZXNzKHRoaWNrbmVzcykge1xuICAgIGNvbnN0IHNhdmVkVGhpY2tuZXNzID0gdGhpcy50aGlja25lc3M7XG4gICAgdGhpcy5hZGRDb21tYW5kcyh7XG4gICAgICBjbWQ6ICgpID0+IHtcbiAgICAgICAgdGhpcy50aGlja25lc3MgPSB0aGlja25lc3M7XG4gICAgICAgIHRoaXMuI2ZpdFRvQ29udGVudCgpO1xuICAgICAgfSxcbiAgICAgIHVuZG86ICgpID0+IHtcbiAgICAgICAgdGhpcy50aGlja25lc3MgPSBzYXZlZFRoaWNrbmVzcztcbiAgICAgICAgdGhpcy4jZml0VG9Db250ZW50KCk7XG4gICAgICB9LFxuICAgICAgbXVzdEV4ZWM6IHRydWUsXG4gICAgICB0eXBlOiBfdXRpbC5Bbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5JTktfVEhJQ0tORVNTLFxuICAgICAgb3ZlcndyaXRlSWZTYW1lVHlwZTogdHJ1ZSxcbiAgICAgIGtlZXBVbmRvOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgI3VwZGF0ZUNvbG9yKGNvbG9yKSB7XG4gICAgY29uc3Qgc2F2ZWRDb2xvciA9IHRoaXMuY29sb3I7XG4gICAgdGhpcy5hZGRDb21tYW5kcyh7XG4gICAgICBjbWQ6ICgpID0+IHtcbiAgICAgICAgdGhpcy5jb2xvciA9IGNvbG9yO1xuICAgICAgICB0aGlzLiNyZWRyYXcoKTtcbiAgICAgIH0sXG4gICAgICB1bmRvOiAoKSA9PiB7XG4gICAgICAgIHRoaXMuY29sb3IgPSBzYXZlZENvbG9yO1xuICAgICAgICB0aGlzLiNyZWRyYXcoKTtcbiAgICAgIH0sXG4gICAgICBtdXN0RXhlYzogdHJ1ZSxcbiAgICAgIHR5cGU6IF91dGlsLkFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLklOS19DT0xPUixcbiAgICAgIG92ZXJ3cml0ZUlmU2FtZVR5cGU6IHRydWUsXG4gICAgICBrZWVwVW5kbzogdHJ1ZVxuICAgIH0pO1xuICB9XG4gICN1cGRhdGVPcGFjaXR5KG9wYWNpdHkpIHtcbiAgICBvcGFjaXR5IC89IDEwMDtcbiAgICBjb25zdCBzYXZlZE9wYWNpdHkgPSB0aGlzLm9wYWNpdHk7XG4gICAgdGhpcy5hZGRDb21tYW5kcyh7XG4gICAgICBjbWQ6ICgpID0+IHtcbiAgICAgICAgdGhpcy5vcGFjaXR5ID0gb3BhY2l0eTtcbiAgICAgICAgdGhpcy4jcmVkcmF3KCk7XG4gICAgICB9LFxuICAgICAgdW5kbzogKCkgPT4ge1xuICAgICAgICB0aGlzLm9wYWNpdHkgPSBzYXZlZE9wYWNpdHk7XG4gICAgICAgIHRoaXMuI3JlZHJhdygpO1xuICAgICAgfSxcbiAgICAgIG11c3RFeGVjOiB0cnVlLFxuICAgICAgdHlwZTogX3V0aWwuQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuSU5LX09QQUNJVFksXG4gICAgICBvdmVyd3JpdGVJZlNhbWVUeXBlOiB0cnVlLFxuICAgICAga2VlcFVuZG86IHRydWVcbiAgICB9KTtcbiAgfVxuICByZWJ1aWxkKCkge1xuICAgIGlmICghdGhpcy5wYXJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3VwZXIucmVidWlsZCgpO1xuICAgIGlmICh0aGlzLmRpdiA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuY2FudmFzKSB7XG4gICAgICB0aGlzLiNjcmVhdGVDYW52YXMoKTtcbiAgICAgIHRoaXMuI2NyZWF0ZU9ic2VydmVyKCk7XG4gICAgfVxuICAgIGlmICghdGhpcy5pc0F0dGFjaGVkVG9ET00pIHtcbiAgICAgIHRoaXMucGFyZW50LmFkZCh0aGlzKTtcbiAgICAgIHRoaXMuI3NldENhbnZhc0RpbXMoKTtcbiAgICB9XG4gICAgdGhpcy4jZml0VG9Db250ZW50KCk7XG4gIH1cbiAgcmVtb3ZlKCkge1xuICAgIGlmICh0aGlzLmNhbnZhcyA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuaXNFbXB0eSgpKSB7XG4gICAgICB0aGlzLmNvbW1pdCgpO1xuICAgIH1cbiAgICB0aGlzLmNhbnZhcy53aWR0aCA9IHRoaXMuY2FudmFzLmhlaWdodCA9IDA7XG4gICAgdGhpcy5jYW52YXMucmVtb3ZlKCk7XG4gICAgdGhpcy5jYW52YXMgPSBudWxsO1xuICAgIHRoaXMuI29ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICB0aGlzLiNvYnNlcnZlciA9IG51bGw7XG4gICAgc3VwZXIucmVtb3ZlKCk7XG4gIH1cbiAgc2V0UGFyZW50KHBhcmVudCkge1xuICAgIGlmICghdGhpcy5wYXJlbnQgJiYgcGFyZW50KSB7XG4gICAgICB0aGlzLl91aU1hbmFnZXIucmVtb3ZlU2hvdWxkUmVzY2FsZSh0aGlzKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMucGFyZW50ICYmIHBhcmVudCA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5fdWlNYW5hZ2VyLmFkZFNob3VsZFJlc2NhbGUodGhpcyk7XG4gICAgfVxuICAgIHN1cGVyLnNldFBhcmVudChwYXJlbnQpO1xuICB9XG4gIG9uU2NhbGVDaGFuZ2luZygpIHtcbiAgICBjb25zdCBbcGFyZW50V2lkdGgsIHBhcmVudEhlaWdodF0gPSB0aGlzLnBhcmVudERpbWVuc2lvbnM7XG4gICAgY29uc3Qgd2lkdGggPSB0aGlzLndpZHRoICogcGFyZW50V2lkdGg7XG4gICAgY29uc3QgaGVpZ2h0ID0gdGhpcy5oZWlnaHQgKiBwYXJlbnRIZWlnaHQ7XG4gICAgdGhpcy5zZXREaW1lbnNpb25zKHdpZHRoLCBoZWlnaHQpO1xuICB9XG4gIGVuYWJsZUVkaXRNb2RlKCkge1xuICAgIGlmICh0aGlzLiNkaXNhYmxlRWRpdGluZyB8fCB0aGlzLmNhbnZhcyA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzdXBlci5lbmFibGVFZGl0TW9kZSgpO1xuICAgIHRoaXMuX2lzRHJhZ2dhYmxlID0gZmFsc2U7XG4gICAgdGhpcy5jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJkb3duXCIsIHRoaXMuI2JvdW5kQ2FudmFzUG9pbnRlcmRvd24pO1xuICB9XG4gIGRpc2FibGVFZGl0TW9kZSgpIHtcbiAgICBpZiAoIXRoaXMuaXNJbkVkaXRNb2RlKCkgfHwgdGhpcy5jYW52YXMgPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3VwZXIuZGlzYWJsZUVkaXRNb2RlKCk7XG4gICAgdGhpcy5faXNEcmFnZ2FibGUgPSAhdGhpcy5pc0VtcHR5KCk7XG4gICAgdGhpcy5kaXYuY2xhc3NMaXN0LnJlbW92ZShcImVkaXRpbmdcIik7XG4gICAgdGhpcy5jYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJkb3duXCIsIHRoaXMuI2JvdW5kQ2FudmFzUG9pbnRlcmRvd24pO1xuICB9XG4gIG9uY2VBZGRlZCgpIHtcbiAgICB0aGlzLl9pc0RyYWdnYWJsZSA9ICF0aGlzLmlzRW1wdHkoKTtcbiAgfVxuICBpc0VtcHR5KCkge1xuICAgIHJldHVybiB0aGlzLnBhdGhzLmxlbmd0aCA9PT0gMCB8fCB0aGlzLnBhdGhzLmxlbmd0aCA9PT0gMSAmJiB0aGlzLnBhdGhzWzBdLmxlbmd0aCA9PT0gMDtcbiAgfVxuICAjZ2V0SW5pdGlhbEJCb3goKSB7XG4gICAgY29uc3Qge1xuICAgICAgcGFyZW50Um90YXRpb24sXG4gICAgICBwYXJlbnREaW1lbnNpb25zOiBbd2lkdGgsIGhlaWdodF1cbiAgICB9ID0gdGhpcztcbiAgICBzd2l0Y2ggKHBhcmVudFJvdGF0aW9uKSB7XG4gICAgICBjYXNlIDkwOlxuICAgICAgICByZXR1cm4gWzAsIGhlaWdodCwgaGVpZ2h0LCB3aWR0aF07XG4gICAgICBjYXNlIDE4MDpcbiAgICAgICAgcmV0dXJuIFt3aWR0aCwgaGVpZ2h0LCB3aWR0aCwgaGVpZ2h0XTtcbiAgICAgIGNhc2UgMjcwOlxuICAgICAgICByZXR1cm4gW3dpZHRoLCAwLCBoZWlnaHQsIHdpZHRoXTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBbMCwgMCwgd2lkdGgsIGhlaWdodF07XG4gICAgfVxuICB9XG4gICNzZXRTdHJva2UoKSB7XG4gICAgY29uc3Qge1xuICAgICAgY3R4LFxuICAgICAgY29sb3IsXG4gICAgICBvcGFjaXR5LFxuICAgICAgdGhpY2tuZXNzLFxuICAgICAgcGFyZW50U2NhbGUsXG4gICAgICBzY2FsZUZhY3RvclxuICAgIH0gPSB0aGlzO1xuICAgIGN0eC5saW5lV2lkdGggPSB0aGlja25lc3MgKiBwYXJlbnRTY2FsZSAvIHNjYWxlRmFjdG9yO1xuICAgIGN0eC5saW5lQ2FwID0gXCJyb3VuZFwiO1xuICAgIGN0eC5saW5lSm9pbiA9IFwicm91bmRcIjtcbiAgICBjdHgubWl0ZXJMaW1pdCA9IDEwO1xuICAgIGN0eC5zdHJva2VTdHlsZSA9IGAke2NvbG9yfSR7KDAsIF90b29scy5vcGFjaXR5VG9IZXgpKG9wYWNpdHkpfWA7XG4gIH1cbiAgI3N0YXJ0RHJhd2luZyh4LCB5KSB7XG4gICAgdGhpcy5jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihcImNvbnRleHRtZW51XCIsIF9kaXNwbGF5X3V0aWxzLm5vQ29udGV4dE1lbnUpO1xuICAgIHRoaXMuY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVybGVhdmVcIiwgdGhpcy4jYm91bmRDYW52YXNQb2ludGVybGVhdmUpO1xuICAgIHRoaXMuY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVybW92ZVwiLCB0aGlzLiNib3VuZENhbnZhc1BvaW50ZXJtb3ZlKTtcbiAgICB0aGlzLmNhbnZhcy5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcnVwXCIsIHRoaXMuI2JvdW5kQ2FudmFzUG9pbnRlcnVwKTtcbiAgICB0aGlzLmNhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKFwicG9pbnRlcmRvd25cIiwgdGhpcy4jYm91bmRDYW52YXNQb2ludGVyZG93bik7XG4gICAgdGhpcy5pc0VkaXRpbmcgPSB0cnVlO1xuICAgIGlmICghdGhpcy4jaXNDYW52YXNJbml0aWFsaXplZCkge1xuICAgICAgdGhpcy4jaXNDYW52YXNJbml0aWFsaXplZCA9IHRydWU7XG4gICAgICB0aGlzLiNzZXRDYW52YXNEaW1zKCk7XG4gICAgICB0aGlzLnRoaWNrbmVzcyB8fD0gSW5rRWRpdG9yLl9kZWZhdWx0VGhpY2tuZXNzO1xuICAgICAgdGhpcy5jb2xvciB8fD0gSW5rRWRpdG9yLl9kZWZhdWx0Q29sb3IgfHwgX2VkaXRvci5Bbm5vdGF0aW9uRWRpdG9yLl9kZWZhdWx0TGluZUNvbG9yO1xuICAgICAgdGhpcy5vcGFjaXR5ID8/PSBJbmtFZGl0b3IuX2RlZmF1bHRPcGFjaXR5O1xuICAgIH1cbiAgICB0aGlzLmN1cnJlbnRQYXRoLnB1c2goW3gsIHldKTtcbiAgICB0aGlzLiNoYXNTb21ldGhpbmdUb0RyYXcgPSBmYWxzZTtcbiAgICB0aGlzLiNzZXRTdHJva2UoKTtcbiAgICB0aGlzLiNyZXF1ZXN0RnJhbWVDYWxsYmFjayA9ICgpID0+IHtcbiAgICAgIHRoaXMuI2RyYXdQb2ludHMoKTtcbiAgICAgIGlmICh0aGlzLiNyZXF1ZXN0RnJhbWVDYWxsYmFjaykge1xuICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMuI3JlcXVlc3RGcmFtZUNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy4jcmVxdWVzdEZyYW1lQ2FsbGJhY2spO1xuICB9XG4gICNkcmF3KHgsIHkpIHtcbiAgICBjb25zdCBbbGFzdFgsIGxhc3RZXSA9IHRoaXMuY3VycmVudFBhdGguYXQoLTEpO1xuICAgIGlmICh0aGlzLmN1cnJlbnRQYXRoLmxlbmd0aCA+IDEgJiYgeCA9PT0gbGFzdFggJiYgeSA9PT0gbGFzdFkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY3VycmVudFBhdGggPSB0aGlzLmN1cnJlbnRQYXRoO1xuICAgIGxldCBwYXRoMkQgPSB0aGlzLiNjdXJyZW50UGF0aDJEO1xuICAgIGN1cnJlbnRQYXRoLnB1c2goW3gsIHldKTtcbiAgICB0aGlzLiNoYXNTb21ldGhpbmdUb0RyYXcgPSB0cnVlO1xuICAgIGlmIChjdXJyZW50UGF0aC5sZW5ndGggPD0gMikge1xuICAgICAgcGF0aDJELm1vdmVUbyguLi5jdXJyZW50UGF0aFswXSk7XG4gICAgICBwYXRoMkQubGluZVRvKHgsIHkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoY3VycmVudFBhdGgubGVuZ3RoID09PSAzKSB7XG4gICAgICB0aGlzLiNjdXJyZW50UGF0aDJEID0gcGF0aDJEID0gbmV3IFBhdGgyRCgpO1xuICAgICAgcGF0aDJELm1vdmVUbyguLi5jdXJyZW50UGF0aFswXSk7XG4gICAgfVxuICAgIHRoaXMuI21ha2VCZXppZXJDdXJ2ZShwYXRoMkQsIC4uLmN1cnJlbnRQYXRoLmF0KC0zKSwgLi4uY3VycmVudFBhdGguYXQoLTIpLCB4LCB5KTtcbiAgfVxuICAjZW5kUGF0aCgpIHtcbiAgICBpZiAodGhpcy5jdXJyZW50UGF0aC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbGFzdFBvaW50ID0gdGhpcy5jdXJyZW50UGF0aC5hdCgtMSk7XG4gICAgdGhpcy4jY3VycmVudFBhdGgyRC5saW5lVG8oLi4ubGFzdFBvaW50KTtcbiAgfVxuICAjc3RvcERyYXdpbmcoeCwgeSkge1xuICAgIHRoaXMuI3JlcXVlc3RGcmFtZUNhbGxiYWNrID0gbnVsbDtcbiAgICB4ID0gTWF0aC5taW4oTWF0aC5tYXgoeCwgMCksIHRoaXMuY2FudmFzLndpZHRoKTtcbiAgICB5ID0gTWF0aC5taW4oTWF0aC5tYXgoeSwgMCksIHRoaXMuY2FudmFzLmhlaWdodCk7XG4gICAgdGhpcy4jZHJhdyh4LCB5KTtcbiAgICB0aGlzLiNlbmRQYXRoKCk7XG4gICAgbGV0IGJlemllcjtcbiAgICBpZiAodGhpcy5jdXJyZW50UGF0aC5sZW5ndGggIT09IDEpIHtcbiAgICAgIGJlemllciA9IHRoaXMuI2dlbmVyYXRlQmV6aWVyUG9pbnRzKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHh5ID0gW3gsIHldO1xuICAgICAgYmV6aWVyID0gW1t4eSwgeHkuc2xpY2UoKSwgeHkuc2xpY2UoKSwgeHldXTtcbiAgICB9XG4gICAgY29uc3QgcGF0aDJEID0gdGhpcy4jY3VycmVudFBhdGgyRDtcbiAgICBjb25zdCBjdXJyZW50UGF0aCA9IHRoaXMuY3VycmVudFBhdGg7XG4gICAgdGhpcy5jdXJyZW50UGF0aCA9IFtdO1xuICAgIHRoaXMuI2N1cnJlbnRQYXRoMkQgPSBuZXcgUGF0aDJEKCk7XG4gICAgY29uc3QgY21kID0gKCkgPT4ge1xuICAgICAgdGhpcy5hbGxSYXdQYXRocy5wdXNoKGN1cnJlbnRQYXRoKTtcbiAgICAgIHRoaXMucGF0aHMucHVzaChiZXppZXIpO1xuICAgICAgdGhpcy5iZXppZXJQYXRoMkQucHVzaChwYXRoMkQpO1xuICAgICAgdGhpcy5yZWJ1aWxkKCk7XG4gICAgfTtcbiAgICBjb25zdCB1bmRvID0gKCkgPT4ge1xuICAgICAgdGhpcy5hbGxSYXdQYXRocy5wb3AoKTtcbiAgICAgIHRoaXMucGF0aHMucG9wKCk7XG4gICAgICB0aGlzLmJlemllclBhdGgyRC5wb3AoKTtcbiAgICAgIGlmICh0aGlzLnBhdGhzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aGlzLnJlbW92ZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCF0aGlzLmNhbnZhcykge1xuICAgICAgICAgIHRoaXMuI2NyZWF0ZUNhbnZhcygpO1xuICAgICAgICAgIHRoaXMuI2NyZWF0ZU9ic2VydmVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jZml0VG9Db250ZW50KCk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmFkZENvbW1hbmRzKHtcbiAgICAgIGNtZCxcbiAgICAgIHVuZG8sXG4gICAgICBtdXN0RXhlYzogdHJ1ZVxuICAgIH0pO1xuICB9XG4gICNkcmF3UG9pbnRzKCkge1xuICAgIGlmICghdGhpcy4jaGFzU29tZXRoaW5nVG9EcmF3KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2hhc1NvbWV0aGluZ1RvRHJhdyA9IGZhbHNlO1xuICAgIGNvbnN0IHRoaWNrbmVzcyA9IE1hdGguY2VpbCh0aGlzLnRoaWNrbmVzcyAqIHRoaXMucGFyZW50U2NhbGUpO1xuICAgIGNvbnN0IGxhc3RQb2ludHMgPSB0aGlzLmN1cnJlbnRQYXRoLnNsaWNlKC0zKTtcbiAgICBjb25zdCB4ID0gbGFzdFBvaW50cy5tYXAoeHkgPT4geHlbMF0pO1xuICAgIGNvbnN0IHkgPSBsYXN0UG9pbnRzLm1hcCh4eSA9PiB4eVsxXSk7XG4gICAgY29uc3QgeE1pbiA9IE1hdGgubWluKC4uLngpIC0gdGhpY2tuZXNzO1xuICAgIGNvbnN0IHhNYXggPSBNYXRoLm1heCguLi54KSArIHRoaWNrbmVzcztcbiAgICBjb25zdCB5TWluID0gTWF0aC5taW4oLi4ueSkgLSB0aGlja25lc3M7XG4gICAgY29uc3QgeU1heCA9IE1hdGgubWF4KC4uLnkpICsgdGhpY2tuZXNzO1xuICAgIGNvbnN0IHtcbiAgICAgIGN0eFxuICAgIH0gPSB0aGlzO1xuICAgIGN0eC5zYXZlKCk7XG4gICAgY3R4LmNsZWFyUmVjdCgwLCAwLCB0aGlzLmNhbnZhcy53aWR0aCwgdGhpcy5jYW52YXMuaGVpZ2h0KTtcbiAgICBmb3IgKGNvbnN0IHBhdGggb2YgdGhpcy5iZXppZXJQYXRoMkQpIHtcbiAgICAgIGN0eC5zdHJva2UocGF0aCk7XG4gICAgfVxuICAgIGN0eC5zdHJva2UodGhpcy4jY3VycmVudFBhdGgyRCk7XG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgfVxuICAjbWFrZUJlemllckN1cnZlKHBhdGgyRCwgeDAsIHkwLCB4MSwgeTEsIHgyLCB5Mikge1xuICAgIGNvbnN0IHByZXZYID0gKHgwICsgeDEpIC8gMjtcbiAgICBjb25zdCBwcmV2WSA9ICh5MCArIHkxKSAvIDI7XG4gICAgY29uc3QgeDMgPSAoeDEgKyB4MikgLyAyO1xuICAgIGNvbnN0IHkzID0gKHkxICsgeTIpIC8gMjtcbiAgICBwYXRoMkQuYmV6aWVyQ3VydmVUbyhwcmV2WCArIDIgKiAoeDEgLSBwcmV2WCkgLyAzLCBwcmV2WSArIDIgKiAoeTEgLSBwcmV2WSkgLyAzLCB4MyArIDIgKiAoeDEgLSB4MykgLyAzLCB5MyArIDIgKiAoeTEgLSB5MykgLyAzLCB4MywgeTMpO1xuICB9XG4gICNnZW5lcmF0ZUJlemllclBvaW50cygpIHtcbiAgICBjb25zdCBwYXRoID0gdGhpcy5jdXJyZW50UGF0aDtcbiAgICBpZiAocGF0aC5sZW5ndGggPD0gMikge1xuICAgICAgcmV0dXJuIFtbcGF0aFswXSwgcGF0aFswXSwgcGF0aC5hdCgtMSksIHBhdGguYXQoLTEpXV07XG4gICAgfVxuICAgIGNvbnN0IGJlemllclBvaW50cyA9IFtdO1xuICAgIGxldCBpO1xuICAgIGxldCBbeDAsIHkwXSA9IHBhdGhbMF07XG4gICAgZm9yIChpID0gMTsgaSA8IHBhdGgubGVuZ3RoIC0gMjsgaSsrKSB7XG4gICAgICBjb25zdCBbeDEsIHkxXSA9IHBhdGhbaV07XG4gICAgICBjb25zdCBbeDIsIHkyXSA9IHBhdGhbaSArIDFdO1xuICAgICAgY29uc3QgeDMgPSAoeDEgKyB4MikgLyAyO1xuICAgICAgY29uc3QgeTMgPSAoeTEgKyB5MikgLyAyO1xuICAgICAgY29uc3QgY29udHJvbDEgPSBbeDAgKyAyICogKHgxIC0geDApIC8gMywgeTAgKyAyICogKHkxIC0geTApIC8gM107XG4gICAgICBjb25zdCBjb250cm9sMiA9IFt4MyArIDIgKiAoeDEgLSB4MykgLyAzLCB5MyArIDIgKiAoeTEgLSB5MykgLyAzXTtcbiAgICAgIGJlemllclBvaW50cy5wdXNoKFtbeDAsIHkwXSwgY29udHJvbDEsIGNvbnRyb2wyLCBbeDMsIHkzXV0pO1xuICAgICAgW3gwLCB5MF0gPSBbeDMsIHkzXTtcbiAgICB9XG4gICAgY29uc3QgW3gxLCB5MV0gPSBwYXRoW2ldO1xuICAgIGNvbnN0IFt4MiwgeTJdID0gcGF0aFtpICsgMV07XG4gICAgY29uc3QgY29udHJvbDEgPSBbeDAgKyAyICogKHgxIC0geDApIC8gMywgeTAgKyAyICogKHkxIC0geTApIC8gM107XG4gICAgY29uc3QgY29udHJvbDIgPSBbeDIgKyAyICogKHgxIC0geDIpIC8gMywgeTIgKyAyICogKHkxIC0geTIpIC8gM107XG4gICAgYmV6aWVyUG9pbnRzLnB1c2goW1t4MCwgeTBdLCBjb250cm9sMSwgY29udHJvbDIsIFt4MiwgeTJdXSk7XG4gICAgcmV0dXJuIGJlemllclBvaW50cztcbiAgfVxuICAjcmVkcmF3KCkge1xuICAgIGlmICh0aGlzLmlzRW1wdHkoKSkge1xuICAgICAgdGhpcy4jdXBkYXRlVHJhbnNmb3JtKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI3NldFN0cm9rZSgpO1xuICAgIGNvbnN0IHtcbiAgICAgIGNhbnZhcyxcbiAgICAgIGN0eFxuICAgIH0gPSB0aGlzO1xuICAgIGN0eC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG4gICAgY3R4LmNsZWFyUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgIHRoaXMuI3VwZGF0ZVRyYW5zZm9ybSgpO1xuICAgIGZvciAoY29uc3QgcGF0aCBvZiB0aGlzLmJlemllclBhdGgyRCkge1xuICAgICAgY3R4LnN0cm9rZShwYXRoKTtcbiAgICB9XG4gIH1cbiAgY29tbWl0KCkge1xuICAgIGlmICh0aGlzLiNkaXNhYmxlRWRpdGluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzdXBlci5jb21taXQoKTtcbiAgICB0aGlzLmlzRWRpdGluZyA9IGZhbHNlO1xuICAgIHRoaXMuZGlzYWJsZUVkaXRNb2RlKCk7XG4gICAgdGhpcy5zZXRJbkZvcmVncm91bmQoKTtcbiAgICB0aGlzLiNkaXNhYmxlRWRpdGluZyA9IHRydWU7XG4gICAgdGhpcy5kaXYuY2xhc3NMaXN0LmFkZChcImRpc2FibGVkXCIpO1xuICAgIHRoaXMuI2ZpdFRvQ29udGVudCh0cnVlKTtcbiAgICB0aGlzLm1ha2VSZXNpemFibGUoKTtcbiAgICB0aGlzLnBhcmVudC5hZGRJbmtFZGl0b3JJZk5lZWRlZCh0cnVlKTtcbiAgICB0aGlzLm1vdmVJbkRPTSgpO1xuICAgIHRoaXMuZGl2LmZvY3VzKHtcbiAgICAgIHByZXZlbnRTY3JvbGw6IHRydWVcbiAgICB9KTtcbiAgfVxuICBmb2N1c2luKGV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLl9mb2N1c0V2ZW50c0FsbG93ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3VwZXIuZm9jdXNpbihldmVudCk7XG4gICAgdGhpcy5lbmFibGVFZGl0TW9kZSgpO1xuICB9XG4gIGNhbnZhc1BvaW50ZXJkb3duKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LmJ1dHRvbiAhPT0gMCB8fCAhdGhpcy5pc0luRWRpdE1vZGUoKSB8fCB0aGlzLiNkaXNhYmxlRWRpdGluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnNldEluRm9yZWdyb3VuZCgpO1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgaWYgKGV2ZW50LnR5cGUgIT09IFwibW91c2VcIikge1xuICAgICAgdGhpcy5kaXYuZm9jdXMoKTtcbiAgICB9XG4gICAgdGhpcy4jc3RhcnREcmF3aW5nKGV2ZW50Lm9mZnNldFgsIGV2ZW50Lm9mZnNldFkpO1xuICB9XG4gIGNhbnZhc1BvaW50ZXJtb3ZlKGV2ZW50KSB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB0aGlzLiNkcmF3KGV2ZW50Lm9mZnNldFgsIGV2ZW50Lm9mZnNldFkpO1xuICB9XG4gIGNhbnZhc1BvaW50ZXJ1cChldmVudCkge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgdGhpcy4jZW5kRHJhd2luZyhldmVudCk7XG4gIH1cbiAgY2FudmFzUG9pbnRlcmxlYXZlKGV2ZW50KSB7XG4gICAgdGhpcy4jZW5kRHJhd2luZyhldmVudCk7XG4gIH1cbiAgI2VuZERyYXdpbmcoZXZlbnQpIHtcbiAgICB0aGlzLmNhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKFwicG9pbnRlcmxlYXZlXCIsIHRoaXMuI2JvdW5kQ2FudmFzUG9pbnRlcmxlYXZlKTtcbiAgICB0aGlzLmNhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKFwicG9pbnRlcm1vdmVcIiwgdGhpcy4jYm91bmRDYW52YXNQb2ludGVybW92ZSk7XG4gICAgdGhpcy5jYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJ1cFwiLCB0aGlzLiNib3VuZENhbnZhc1BvaW50ZXJ1cCk7XG4gICAgdGhpcy5jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJkb3duXCIsIHRoaXMuI2JvdW5kQ2FudmFzUG9pbnRlcmRvd24pO1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5jYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNvbnRleHRtZW51XCIsIF9kaXNwbGF5X3V0aWxzLm5vQ29udGV4dE1lbnUpO1xuICAgIH0sIDEwKTtcbiAgICB0aGlzLiNzdG9wRHJhd2luZyhldmVudC5vZmZzZXRYLCBldmVudC5vZmZzZXRZKTtcbiAgICB0aGlzLmFkZFRvQW5ub3RhdGlvblN0b3JhZ2UoKTtcbiAgICB0aGlzLnNldEluQmFja2dyb3VuZCgpO1xuICB9XG4gICNjcmVhdGVDYW52YXMoKSB7XG4gICAgdGhpcy5jYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgIHRoaXMuY2FudmFzLndpZHRoID0gdGhpcy5jYW52YXMuaGVpZ2h0ID0gMDtcbiAgICB0aGlzLmNhbnZhcy5jbGFzc05hbWUgPSBcImlua0VkaXRvckNhbnZhc1wiO1xuICAgIF9lZGl0b3IuQW5ub3RhdGlvbkVkaXRvci5fbDEwblByb21pc2UuZ2V0KFwiZWRpdG9yX2lua19jYW52YXNfYXJpYV9sYWJlbFwiKS50aGVuKG1zZyA9PiB0aGlzLmNhbnZhcz8uc2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiLCBtc2cpKTtcbiAgICB0aGlzLmRpdi5hcHBlbmQodGhpcy5jYW52YXMpO1xuICAgIHRoaXMuY3R4ID0gdGhpcy5jYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICB9XG4gICNjcmVhdGVPYnNlcnZlcigpIHtcbiAgICB0aGlzLiNvYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlcihlbnRyaWVzID0+IHtcbiAgICAgIGNvbnN0IHJlY3QgPSBlbnRyaWVzWzBdLmNvbnRlbnRSZWN0O1xuICAgICAgaWYgKHJlY3Qud2lkdGggJiYgcmVjdC5oZWlnaHQpIHtcbiAgICAgICAgdGhpcy5zZXREaW1lbnNpb25zKHJlY3Qud2lkdGgsIHJlY3QuaGVpZ2h0KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLiNvYnNlcnZlci5vYnNlcnZlKHRoaXMuZGl2KTtcbiAgfVxuICBnZXQgaXNSZXNpemFibGUoKSB7XG4gICAgcmV0dXJuICF0aGlzLmlzRW1wdHkoKSAmJiB0aGlzLiNkaXNhYmxlRWRpdGluZztcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgaWYgKHRoaXMuZGl2KSB7XG4gICAgICByZXR1cm4gdGhpcy5kaXY7XG4gICAgfVxuICAgIGxldCBiYXNlWCwgYmFzZVk7XG4gICAgaWYgKHRoaXMud2lkdGgpIHtcbiAgICAgIGJhc2VYID0gdGhpcy54O1xuICAgICAgYmFzZVkgPSB0aGlzLnk7XG4gICAgfVxuICAgIHN1cGVyLnJlbmRlcigpO1xuICAgIF9lZGl0b3IuQW5ub3RhdGlvbkVkaXRvci5fbDEwblByb21pc2UuZ2V0KFwiZWRpdG9yX2luazJfYXJpYV9sYWJlbFwiKS50aGVuKG1zZyA9PiB0aGlzLmRpdj8uc2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiLCBtc2cpKTtcbiAgICBjb25zdCBbeCwgeSwgdywgaF0gPSB0aGlzLiNnZXRJbml0aWFsQkJveCgpO1xuICAgIHRoaXMuc2V0QXQoeCwgeSwgMCwgMCk7XG4gICAgdGhpcy5zZXREaW1zKHcsIGgpO1xuICAgIHRoaXMuI2NyZWF0ZUNhbnZhcygpO1xuICAgIGlmICh0aGlzLndpZHRoKSB7XG4gICAgICBjb25zdCBbcGFyZW50V2lkdGgsIHBhcmVudEhlaWdodF0gPSB0aGlzLnBhcmVudERpbWVuc2lvbnM7XG4gICAgICB0aGlzLnNldEFzcGVjdFJhdGlvKHRoaXMud2lkdGggKiBwYXJlbnRXaWR0aCwgdGhpcy5oZWlnaHQgKiBwYXJlbnRIZWlnaHQpO1xuICAgICAgdGhpcy5zZXRBdChiYXNlWCAqIHBhcmVudFdpZHRoLCBiYXNlWSAqIHBhcmVudEhlaWdodCwgdGhpcy53aWR0aCAqIHBhcmVudFdpZHRoLCB0aGlzLmhlaWdodCAqIHBhcmVudEhlaWdodCk7XG4gICAgICB0aGlzLiNpc0NhbnZhc0luaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgIHRoaXMuI3NldENhbnZhc0RpbXMoKTtcbiAgICAgIHRoaXMuc2V0RGltcyh0aGlzLndpZHRoICogcGFyZW50V2lkdGgsIHRoaXMuaGVpZ2h0ICogcGFyZW50SGVpZ2h0KTtcbiAgICAgIHRoaXMuI3JlZHJhdygpO1xuICAgICAgdGhpcy5kaXYuY2xhc3NMaXN0LmFkZChcImRpc2FibGVkXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRpdi5jbGFzc0xpc3QuYWRkKFwiZWRpdGluZ1wiKTtcbiAgICAgIHRoaXMuZW5hYmxlRWRpdE1vZGUoKTtcbiAgICB9XG4gICAgdGhpcy4jY3JlYXRlT2JzZXJ2ZXIoKTtcbiAgICByZXR1cm4gdGhpcy5kaXY7XG4gIH1cbiAgI3NldENhbnZhc0RpbXMoKSB7XG4gICAgaWYgKCF0aGlzLiNpc0NhbnZhc0luaXRpYWxpemVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IFtwYXJlbnRXaWR0aCwgcGFyZW50SGVpZ2h0XSA9IHRoaXMucGFyZW50RGltZW5zaW9ucztcbiAgICB0aGlzLmNhbnZhcy53aWR0aCA9IE1hdGguY2VpbCh0aGlzLndpZHRoICogcGFyZW50V2lkdGgpO1xuICAgIHRoaXMuY2FudmFzLmhlaWdodCA9IE1hdGguY2VpbCh0aGlzLmhlaWdodCAqIHBhcmVudEhlaWdodCk7XG4gICAgdGhpcy4jdXBkYXRlVHJhbnNmb3JtKCk7XG4gIH1cbiAgc2V0RGltZW5zaW9ucyh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgY29uc3Qgcm91bmRlZFdpZHRoID0gTWF0aC5yb3VuZCh3aWR0aCk7XG4gICAgY29uc3Qgcm91bmRlZEhlaWdodCA9IE1hdGgucm91bmQoaGVpZ2h0KTtcbiAgICBpZiAodGhpcy4jcmVhbFdpZHRoID09PSByb3VuZGVkV2lkdGggJiYgdGhpcy4jcmVhbEhlaWdodCA9PT0gcm91bmRlZEhlaWdodCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNyZWFsV2lkdGggPSByb3VuZGVkV2lkdGg7XG4gICAgdGhpcy4jcmVhbEhlaWdodCA9IHJvdW5kZWRIZWlnaHQ7XG4gICAgdGhpcy5jYW52YXMuc3R5bGUudmlzaWJpbGl0eSA9IFwiaGlkZGVuXCI7XG4gICAgY29uc3QgW3BhcmVudFdpZHRoLCBwYXJlbnRIZWlnaHRdID0gdGhpcy5wYXJlbnREaW1lbnNpb25zO1xuICAgIHRoaXMud2lkdGggPSB3aWR0aCAvIHBhcmVudFdpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0IC8gcGFyZW50SGVpZ2h0O1xuICAgIHRoaXMuZml4QW5kU2V0UG9zaXRpb24oKTtcbiAgICBpZiAodGhpcy4jZGlzYWJsZUVkaXRpbmcpIHtcbiAgICAgIHRoaXMuI3NldFNjYWxlRmFjdG9yKHdpZHRoLCBoZWlnaHQpO1xuICAgIH1cbiAgICB0aGlzLiNzZXRDYW52YXNEaW1zKCk7XG4gICAgdGhpcy4jcmVkcmF3KCk7XG4gICAgdGhpcy5jYW52YXMuc3R5bGUudmlzaWJpbGl0eSA9IFwidmlzaWJsZVwiO1xuICAgIHRoaXMuZml4RGltcygpO1xuICB9XG4gICNzZXRTY2FsZUZhY3Rvcih3aWR0aCwgaGVpZ2h0KSB7XG4gICAgY29uc3QgcGFkZGluZyA9IHRoaXMuI2dldFBhZGRpbmcoKTtcbiAgICBjb25zdCBzY2FsZUZhY3RvclcgPSAod2lkdGggLSBwYWRkaW5nKSAvIHRoaXMuI2Jhc2VXaWR0aDtcbiAgICBjb25zdCBzY2FsZUZhY3RvckggPSAoaGVpZ2h0IC0gcGFkZGluZykgLyB0aGlzLiNiYXNlSGVpZ2h0O1xuICAgIHRoaXMuc2NhbGVGYWN0b3IgPSBNYXRoLm1pbihzY2FsZUZhY3RvclcsIHNjYWxlRmFjdG9ySCk7XG4gIH1cbiAgI3VwZGF0ZVRyYW5zZm9ybSgpIHtcbiAgICBjb25zdCBwYWRkaW5nID0gdGhpcy4jZ2V0UGFkZGluZygpIC8gMjtcbiAgICB0aGlzLmN0eC5zZXRUcmFuc2Zvcm0odGhpcy5zY2FsZUZhY3RvciwgMCwgMCwgdGhpcy5zY2FsZUZhY3RvciwgdGhpcy50cmFuc2xhdGlvblggKiB0aGlzLnNjYWxlRmFjdG9yICsgcGFkZGluZywgdGhpcy50cmFuc2xhdGlvblkgKiB0aGlzLnNjYWxlRmFjdG9yICsgcGFkZGluZyk7XG4gIH1cbiAgc3RhdGljICNidWlsZFBhdGgyRChiZXppZXIpIHtcbiAgICBjb25zdCBwYXRoMkQgPSBuZXcgUGF0aDJEKCk7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gYmV6aWVyLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgIGNvbnN0IFtmaXJzdCwgY29udHJvbDEsIGNvbnRyb2wyLCBzZWNvbmRdID0gYmV6aWVyW2ldO1xuICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgcGF0aDJELm1vdmVUbyguLi5maXJzdCk7XG4gICAgICB9XG4gICAgICBwYXRoMkQuYmV6aWVyQ3VydmVUbyhjb250cm9sMVswXSwgY29udHJvbDFbMV0sIGNvbnRyb2wyWzBdLCBjb250cm9sMlsxXSwgc2Vjb25kWzBdLCBzZWNvbmRbMV0pO1xuICAgIH1cbiAgICByZXR1cm4gcGF0aDJEO1xuICB9XG4gIHN0YXRpYyAjdG9QREZDb29yZGluYXRlcyhwb2ludHMsIHJlY3QsIHJvdGF0aW9uKSB7XG4gICAgY29uc3QgW2JsWCwgYmxZLCB0clgsIHRyWV0gPSByZWN0O1xuICAgIHN3aXRjaCAocm90YXRpb24pIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGlpID0gcG9pbnRzLmxlbmd0aDsgaSA8IGlpOyBpICs9IDIpIHtcbiAgICAgICAgICBwb2ludHNbaV0gKz0gYmxYO1xuICAgICAgICAgIHBvaW50c1tpICsgMV0gPSB0clkgLSBwb2ludHNbaSArIDFdO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA5MDpcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGlpID0gcG9pbnRzLmxlbmd0aDsgaSA8IGlpOyBpICs9IDIpIHtcbiAgICAgICAgICBjb25zdCB4ID0gcG9pbnRzW2ldO1xuICAgICAgICAgIHBvaW50c1tpXSA9IHBvaW50c1tpICsgMV0gKyBibFg7XG4gICAgICAgICAgcG9pbnRzW2kgKyAxXSA9IHggKyBibFk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDE4MDpcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGlpID0gcG9pbnRzLmxlbmd0aDsgaSA8IGlpOyBpICs9IDIpIHtcbiAgICAgICAgICBwb2ludHNbaV0gPSB0clggLSBwb2ludHNbaV07XG4gICAgICAgICAgcG9pbnRzW2kgKyAxXSArPSBibFk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI3MDpcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGlpID0gcG9pbnRzLmxlbmd0aDsgaSA8IGlpOyBpICs9IDIpIHtcbiAgICAgICAgICBjb25zdCB4ID0gcG9pbnRzW2ldO1xuICAgICAgICAgIHBvaW50c1tpXSA9IHRyWCAtIHBvaW50c1tpICsgMV07XG4gICAgICAgICAgcG9pbnRzW2kgKyAxXSA9IHRyWSAtIHg7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHJvdGF0aW9uXCIpO1xuICAgIH1cbiAgICByZXR1cm4gcG9pbnRzO1xuICB9XG4gIHN0YXRpYyAjZnJvbVBERkNvb3JkaW5hdGVzKHBvaW50cywgcmVjdCwgcm90YXRpb24pIHtcbiAgICBjb25zdCBbYmxYLCBibFksIHRyWCwgdHJZXSA9IHJlY3Q7XG4gICAgc3dpdGNoIChyb3RhdGlvbikge1xuICAgICAgY2FzZSAwOlxuICAgICAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBwb2ludHMubGVuZ3RoOyBpIDwgaWk7IGkgKz0gMikge1xuICAgICAgICAgIHBvaW50c1tpXSAtPSBibFg7XG4gICAgICAgICAgcG9pbnRzW2kgKyAxXSA9IHRyWSAtIHBvaW50c1tpICsgMV07XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDkwOlxuICAgICAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBwb2ludHMubGVuZ3RoOyBpIDwgaWk7IGkgKz0gMikge1xuICAgICAgICAgIGNvbnN0IHggPSBwb2ludHNbaV07XG4gICAgICAgICAgcG9pbnRzW2ldID0gcG9pbnRzW2kgKyAxXSAtIGJsWTtcbiAgICAgICAgICBwb2ludHNbaSArIDFdID0geCAtIGJsWDtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTgwOlxuICAgICAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBwb2ludHMubGVuZ3RoOyBpIDwgaWk7IGkgKz0gMikge1xuICAgICAgICAgIHBvaW50c1tpXSA9IHRyWCAtIHBvaW50c1tpXTtcbiAgICAgICAgICBwb2ludHNbaSArIDFdIC09IGJsWTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjcwOlxuICAgICAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBwb2ludHMubGVuZ3RoOyBpIDwgaWk7IGkgKz0gMikge1xuICAgICAgICAgIGNvbnN0IHggPSBwb2ludHNbaV07XG4gICAgICAgICAgcG9pbnRzW2ldID0gdHJZIC0gcG9pbnRzW2kgKyAxXTtcbiAgICAgICAgICBwb2ludHNbaSArIDFdID0gdHJYIC0geDtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgcm90YXRpb25cIik7XG4gICAgfVxuICAgIHJldHVybiBwb2ludHM7XG4gIH1cbiAgI3NlcmlhbGl6ZVBhdGhzKHMsIHR4LCB0eSwgcmVjdCkge1xuICAgIGNvbnN0IHBhdGhzID0gW107XG4gICAgY29uc3QgcGFkZGluZyA9IHRoaXMudGhpY2tuZXNzIC8gMjtcbiAgICBjb25zdCBzaGlmdFggPSBzICogdHggKyBwYWRkaW5nO1xuICAgIGNvbnN0IHNoaWZ0WSA9IHMgKiB0eSArIHBhZGRpbmc7XG4gICAgZm9yIChjb25zdCBiZXppZXIgb2YgdGhpcy5wYXRocykge1xuICAgICAgY29uc3QgYnVmZmVyID0gW107XG4gICAgICBjb25zdCBwb2ludHMgPSBbXTtcbiAgICAgIGZvciAobGV0IGogPSAwLCBqaiA9IGJlemllci5sZW5ndGg7IGogPCBqajsgaisrKSB7XG4gICAgICAgIGNvbnN0IFtmaXJzdCwgY29udHJvbDEsIGNvbnRyb2wyLCBzZWNvbmRdID0gYmV6aWVyW2pdO1xuICAgICAgICBjb25zdCBwMTAgPSBzICogZmlyc3RbMF0gKyBzaGlmdFg7XG4gICAgICAgIGNvbnN0IHAxMSA9IHMgKiBmaXJzdFsxXSArIHNoaWZ0WTtcbiAgICAgICAgY29uc3QgcDIwID0gcyAqIGNvbnRyb2wxWzBdICsgc2hpZnRYO1xuICAgICAgICBjb25zdCBwMjEgPSBzICogY29udHJvbDFbMV0gKyBzaGlmdFk7XG4gICAgICAgIGNvbnN0IHAzMCA9IHMgKiBjb250cm9sMlswXSArIHNoaWZ0WDtcbiAgICAgICAgY29uc3QgcDMxID0gcyAqIGNvbnRyb2wyWzFdICsgc2hpZnRZO1xuICAgICAgICBjb25zdCBwNDAgPSBzICogc2Vjb25kWzBdICsgc2hpZnRYO1xuICAgICAgICBjb25zdCBwNDEgPSBzICogc2Vjb25kWzFdICsgc2hpZnRZO1xuICAgICAgICBpZiAoaiA9PT0gMCkge1xuICAgICAgICAgIGJ1ZmZlci5wdXNoKHAxMCwgcDExKTtcbiAgICAgICAgICBwb2ludHMucHVzaChwMTAsIHAxMSk7XG4gICAgICAgIH1cbiAgICAgICAgYnVmZmVyLnB1c2gocDIwLCBwMjEsIHAzMCwgcDMxLCBwNDAsIHA0MSk7XG4gICAgICAgIHBvaW50cy5wdXNoKHAyMCwgcDIxKTtcbiAgICAgICAgaWYgKGogPT09IGpqIC0gMSkge1xuICAgICAgICAgIHBvaW50cy5wdXNoKHA0MCwgcDQxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcGF0aHMucHVzaCh7XG4gICAgICAgIGJlemllcjogSW5rRWRpdG9yLiN0b1BERkNvb3JkaW5hdGVzKGJ1ZmZlciwgcmVjdCwgdGhpcy5yb3RhdGlvbiksXG4gICAgICAgIHBvaW50czogSW5rRWRpdG9yLiN0b1BERkNvb3JkaW5hdGVzKHBvaW50cywgcmVjdCwgdGhpcy5yb3RhdGlvbilcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcGF0aHM7XG4gIH1cbiAgI2dldEJib3goKSB7XG4gICAgbGV0IHhNaW4gPSBJbmZpbml0eTtcbiAgICBsZXQgeE1heCA9IC1JbmZpbml0eTtcbiAgICBsZXQgeU1pbiA9IEluZmluaXR5O1xuICAgIGxldCB5TWF4ID0gLUluZmluaXR5O1xuICAgIGZvciAoY29uc3QgcGF0aCBvZiB0aGlzLnBhdGhzKSB7XG4gICAgICBmb3IgKGNvbnN0IFtmaXJzdCwgY29udHJvbDEsIGNvbnRyb2wyLCBzZWNvbmRdIG9mIHBhdGgpIHtcbiAgICAgICAgY29uc3QgYmJveCA9IF91dGlsLlV0aWwuYmV6aWVyQm91bmRpbmdCb3goLi4uZmlyc3QsIC4uLmNvbnRyb2wxLCAuLi5jb250cm9sMiwgLi4uc2Vjb25kKTtcbiAgICAgICAgeE1pbiA9IE1hdGgubWluKHhNaW4sIGJib3hbMF0pO1xuICAgICAgICB5TWluID0gTWF0aC5taW4oeU1pbiwgYmJveFsxXSk7XG4gICAgICAgIHhNYXggPSBNYXRoLm1heCh4TWF4LCBiYm94WzJdKTtcbiAgICAgICAgeU1heCA9IE1hdGgubWF4KHlNYXgsIGJib3hbM10pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gW3hNaW4sIHlNaW4sIHhNYXgsIHlNYXhdO1xuICB9XG4gICNnZXRQYWRkaW5nKCkge1xuICAgIHJldHVybiB0aGlzLiNkaXNhYmxlRWRpdGluZyA/IE1hdGguY2VpbCh0aGlzLnRoaWNrbmVzcyAqIHRoaXMucGFyZW50U2NhbGUpIDogMDtcbiAgfVxuICAjZml0VG9Db250ZW50KGZpcnN0VGltZSA9IGZhbHNlKSB7XG4gICAgaWYgKHRoaXMuaXNFbXB0eSgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghdGhpcy4jZGlzYWJsZUVkaXRpbmcpIHtcbiAgICAgIHRoaXMuI3JlZHJhdygpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBiYm94ID0gdGhpcy4jZ2V0QmJveCgpO1xuICAgIGNvbnN0IHBhZGRpbmcgPSB0aGlzLiNnZXRQYWRkaW5nKCk7XG4gICAgdGhpcy4jYmFzZVdpZHRoID0gTWF0aC5tYXgoX2VkaXRvci5Bbm5vdGF0aW9uRWRpdG9yLk1JTl9TSVpFLCBiYm94WzJdIC0gYmJveFswXSk7XG4gICAgdGhpcy4jYmFzZUhlaWdodCA9IE1hdGgubWF4KF9lZGl0b3IuQW5ub3RhdGlvbkVkaXRvci5NSU5fU0laRSwgYmJveFszXSAtIGJib3hbMV0pO1xuICAgIGNvbnN0IHdpZHRoID0gTWF0aC5jZWlsKHBhZGRpbmcgKyB0aGlzLiNiYXNlV2lkdGggKiB0aGlzLnNjYWxlRmFjdG9yKTtcbiAgICBjb25zdCBoZWlnaHQgPSBNYXRoLmNlaWwocGFkZGluZyArIHRoaXMuI2Jhc2VIZWlnaHQgKiB0aGlzLnNjYWxlRmFjdG9yKTtcbiAgICBjb25zdCBbcGFyZW50V2lkdGgsIHBhcmVudEhlaWdodF0gPSB0aGlzLnBhcmVudERpbWVuc2lvbnM7XG4gICAgdGhpcy53aWR0aCA9IHdpZHRoIC8gcGFyZW50V2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQgLyBwYXJlbnRIZWlnaHQ7XG4gICAgdGhpcy5zZXRBc3BlY3RSYXRpbyh3aWR0aCwgaGVpZ2h0KTtcbiAgICBjb25zdCBwcmV2VHJhbnNsYXRpb25YID0gdGhpcy50cmFuc2xhdGlvblg7XG4gICAgY29uc3QgcHJldlRyYW5zbGF0aW9uWSA9IHRoaXMudHJhbnNsYXRpb25ZO1xuICAgIHRoaXMudHJhbnNsYXRpb25YID0gLWJib3hbMF07XG4gICAgdGhpcy50cmFuc2xhdGlvblkgPSAtYmJveFsxXTtcbiAgICB0aGlzLiNzZXRDYW52YXNEaW1zKCk7XG4gICAgdGhpcy4jcmVkcmF3KCk7XG4gICAgdGhpcy4jcmVhbFdpZHRoID0gd2lkdGg7XG4gICAgdGhpcy4jcmVhbEhlaWdodCA9IGhlaWdodDtcbiAgICB0aGlzLnNldERpbXMod2lkdGgsIGhlaWdodCk7XG4gICAgY29uc3QgdW5zY2FsZWRQYWRkaW5nID0gZmlyc3RUaW1lID8gcGFkZGluZyAvIHRoaXMuc2NhbGVGYWN0b3IgLyAyIDogMDtcbiAgICB0aGlzLnRyYW5zbGF0ZShwcmV2VHJhbnNsYXRpb25YIC0gdGhpcy50cmFuc2xhdGlvblggLSB1bnNjYWxlZFBhZGRpbmcsIHByZXZUcmFuc2xhdGlvblkgLSB0aGlzLnRyYW5zbGF0aW9uWSAtIHVuc2NhbGVkUGFkZGluZyk7XG4gIH1cbiAgc3RhdGljIGRlc2VyaWFsaXplKGRhdGEsIHBhcmVudCwgdWlNYW5hZ2VyKSB7XG4gICAgaWYgKGRhdGEgaW5zdGFuY2VvZiBfYW5ub3RhdGlvbl9sYXllci5JbmtBbm5vdGF0aW9uRWxlbWVudCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGVkaXRvciA9IHN1cGVyLmRlc2VyaWFsaXplKGRhdGEsIHBhcmVudCwgdWlNYW5hZ2VyKTtcbiAgICBlZGl0b3IudGhpY2tuZXNzID0gZGF0YS50aGlja25lc3M7XG4gICAgZWRpdG9yLmNvbG9yID0gX3V0aWwuVXRpbC5tYWtlSGV4Q29sb3IoLi4uZGF0YS5jb2xvcik7XG4gICAgZWRpdG9yLm9wYWNpdHkgPSBkYXRhLm9wYWNpdHk7XG4gICAgY29uc3QgW3BhZ2VXaWR0aCwgcGFnZUhlaWdodF0gPSBlZGl0b3IucGFnZURpbWVuc2lvbnM7XG4gICAgY29uc3Qgd2lkdGggPSBlZGl0b3Iud2lkdGggKiBwYWdlV2lkdGg7XG4gICAgY29uc3QgaGVpZ2h0ID0gZWRpdG9yLmhlaWdodCAqIHBhZ2VIZWlnaHQ7XG4gICAgY29uc3Qgc2NhbGVGYWN0b3IgPSBlZGl0b3IucGFyZW50U2NhbGU7XG4gICAgY29uc3QgcGFkZGluZyA9IGRhdGEudGhpY2tuZXNzIC8gMjtcbiAgICBlZGl0b3IuI2Rpc2FibGVFZGl0aW5nID0gdHJ1ZTtcbiAgICBlZGl0b3IuI3JlYWxXaWR0aCA9IE1hdGgucm91bmQod2lkdGgpO1xuICAgIGVkaXRvci4jcmVhbEhlaWdodCA9IE1hdGgucm91bmQoaGVpZ2h0KTtcbiAgICBjb25zdCB7XG4gICAgICBwYXRocyxcbiAgICAgIHJlY3QsXG4gICAgICByb3RhdGlvblxuICAgIH0gPSBkYXRhO1xuICAgIGZvciAobGV0IHtcbiAgICAgIGJlemllclxuICAgIH0gb2YgcGF0aHMpIHtcbiAgICAgIGJlemllciA9IElua0VkaXRvci4jZnJvbVBERkNvb3JkaW5hdGVzKGJlemllciwgcmVjdCwgcm90YXRpb24pO1xuICAgICAgY29uc3QgcGF0aCA9IFtdO1xuICAgICAgZWRpdG9yLnBhdGhzLnB1c2gocGF0aCk7XG4gICAgICBsZXQgcDAgPSBzY2FsZUZhY3RvciAqIChiZXppZXJbMF0gLSBwYWRkaW5nKTtcbiAgICAgIGxldCBwMSA9IHNjYWxlRmFjdG9yICogKGJlemllclsxXSAtIHBhZGRpbmcpO1xuICAgICAgZm9yIChsZXQgaSA9IDIsIGlpID0gYmV6aWVyLmxlbmd0aDsgaSA8IGlpOyBpICs9IDYpIHtcbiAgICAgICAgY29uc3QgcDEwID0gc2NhbGVGYWN0b3IgKiAoYmV6aWVyW2ldIC0gcGFkZGluZyk7XG4gICAgICAgIGNvbnN0IHAxMSA9IHNjYWxlRmFjdG9yICogKGJlemllcltpICsgMV0gLSBwYWRkaW5nKTtcbiAgICAgICAgY29uc3QgcDIwID0gc2NhbGVGYWN0b3IgKiAoYmV6aWVyW2kgKyAyXSAtIHBhZGRpbmcpO1xuICAgICAgICBjb25zdCBwMjEgPSBzY2FsZUZhY3RvciAqIChiZXppZXJbaSArIDNdIC0gcGFkZGluZyk7XG4gICAgICAgIGNvbnN0IHAzMCA9IHNjYWxlRmFjdG9yICogKGJlemllcltpICsgNF0gLSBwYWRkaW5nKTtcbiAgICAgICAgY29uc3QgcDMxID0gc2NhbGVGYWN0b3IgKiAoYmV6aWVyW2kgKyA1XSAtIHBhZGRpbmcpO1xuICAgICAgICBwYXRoLnB1c2goW1twMCwgcDFdLCBbcDEwLCBwMTFdLCBbcDIwLCBwMjFdLCBbcDMwLCBwMzFdXSk7XG4gICAgICAgIHAwID0gcDMwO1xuICAgICAgICBwMSA9IHAzMTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHBhdGgyRCA9IHRoaXMuI2J1aWxkUGF0aDJEKHBhdGgpO1xuICAgICAgZWRpdG9yLmJlemllclBhdGgyRC5wdXNoKHBhdGgyRCk7XG4gICAgfVxuICAgIGNvbnN0IGJib3ggPSBlZGl0b3IuI2dldEJib3goKTtcbiAgICBlZGl0b3IuI2Jhc2VXaWR0aCA9IE1hdGgubWF4KF9lZGl0b3IuQW5ub3RhdGlvbkVkaXRvci5NSU5fU0laRSwgYmJveFsyXSAtIGJib3hbMF0pO1xuICAgIGVkaXRvci4jYmFzZUhlaWdodCA9IE1hdGgubWF4KF9lZGl0b3IuQW5ub3RhdGlvbkVkaXRvci5NSU5fU0laRSwgYmJveFszXSAtIGJib3hbMV0pO1xuICAgIGVkaXRvci4jc2V0U2NhbGVGYWN0b3Iod2lkdGgsIGhlaWdodCk7XG4gICAgcmV0dXJuIGVkaXRvcjtcbiAgfVxuICBzZXJpYWxpemUoKSB7XG4gICAgaWYgKHRoaXMuaXNFbXB0eSgpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgcmVjdCA9IHRoaXMuZ2V0UmVjdCgwLCAwKTtcbiAgICBjb25zdCBjb2xvciA9IF9lZGl0b3IuQW5ub3RhdGlvbkVkaXRvci5fY29sb3JNYW5hZ2VyLmNvbnZlcnQodGhpcy5jdHguc3Ryb2tlU3R5bGUpO1xuICAgIHJldHVybiB7XG4gICAgICBhbm5vdGF0aW9uVHlwZTogX3V0aWwuQW5ub3RhdGlvbkVkaXRvclR5cGUuSU5LLFxuICAgICAgY29sb3IsXG4gICAgICB0aGlja25lc3M6IHRoaXMudGhpY2tuZXNzLFxuICAgICAgb3BhY2l0eTogdGhpcy5vcGFjaXR5LFxuICAgICAgcGF0aHM6IHRoaXMuI3NlcmlhbGl6ZVBhdGhzKHRoaXMuc2NhbGVGYWN0b3IgLyB0aGlzLnBhcmVudFNjYWxlLCB0aGlzLnRyYW5zbGF0aW9uWCwgdGhpcy50cmFuc2xhdGlvblksIHJlY3QpLFxuICAgICAgcGFnZUluZGV4OiB0aGlzLnBhZ2VJbmRleCxcbiAgICAgIHJlY3QsXG4gICAgICByb3RhdGlvbjogdGhpcy5yb3RhdGlvbixcbiAgICAgIHN0cnVjdFRyZWVQYXJlbnRJZDogdGhpcy5fc3RydWN0VHJlZVBhcmVudElkXG4gICAgfTtcbiAgfVxufVxuZXhwb3J0cy5JbmtFZGl0b3IgPSBJbmtFZGl0b3I7XG5cbi8qKiovIH0pLFxuLyogMzQgKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pID0+IHtcblxuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcbmV4cG9ydHMuU3RhbXBFZGl0b3IgPSB2b2lkIDA7XG52YXIgX3V0aWwgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEpO1xudmFyIF9lZGl0b3IgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDQpO1xudmFyIF9kaXNwbGF5X3V0aWxzID0gX193X3BkZmpzX3JlcXVpcmVfXyg2KTtcbnZhciBfYW5ub3RhdGlvbl9sYXllciA9IF9fd19wZGZqc19yZXF1aXJlX18oMjkpO1xuY2xhc3MgU3RhbXBFZGl0b3IgZXh0ZW5kcyBfZWRpdG9yLkFubm90YXRpb25FZGl0b3Ige1xuICAjYml0bWFwID0gbnVsbDtcbiAgI2JpdG1hcElkID0gbnVsbDtcbiAgI2JpdG1hcFByb21pc2UgPSBudWxsO1xuICAjYml0bWFwVXJsID0gbnVsbDtcbiAgI2JpdG1hcEZpbGUgPSBudWxsO1xuICAjY2FudmFzID0gbnVsbDtcbiAgI29ic2VydmVyID0gbnVsbDtcbiAgI3Jlc2l6ZVRpbWVvdXRJZCA9IG51bGw7XG4gICNpc1N2ZyA9IGZhbHNlO1xuICAjaGFzQmVlbkFkZGVkSW5VbmRvU3RhY2sgPSBmYWxzZTtcbiAgc3RhdGljIF90eXBlID0gXCJzdGFtcFwiO1xuICBjb25zdHJ1Y3RvcihwYXJhbXMpIHtcbiAgICBzdXBlcih7XG4gICAgICAuLi5wYXJhbXMsXG4gICAgICBuYW1lOiBcInN0YW1wRWRpdG9yXCJcbiAgICB9KTtcbiAgICB0aGlzLiNiaXRtYXBVcmwgPSBwYXJhbXMuYml0bWFwVXJsO1xuICAgIHRoaXMuI2JpdG1hcEZpbGUgPSBwYXJhbXMuYml0bWFwRmlsZTtcbiAgfVxuICBzdGF0aWMgaW5pdGlhbGl6ZShsMTBuKSB7XG4gICAgX2VkaXRvci5Bbm5vdGF0aW9uRWRpdG9yLmluaXRpYWxpemUobDEwbik7XG4gIH1cbiAgc3RhdGljIGdldCBzdXBwb3J0ZWRUeXBlcygpIHtcbiAgICBjb25zdCB0eXBlcyA9IFtcImFwbmdcIiwgXCJhdmlmXCIsIFwiYm1wXCIsIFwiZ2lmXCIsIFwianBlZ1wiLCBcInBuZ1wiLCBcInN2Zyt4bWxcIiwgXCJ3ZWJwXCIsIFwieC1pY29uXCJdO1xuICAgIHJldHVybiAoMCwgX3V0aWwuc2hhZG93KSh0aGlzLCBcInN1cHBvcnRlZFR5cGVzXCIsIHR5cGVzLm1hcCh0eXBlID0+IGBpbWFnZS8ke3R5cGV9YCkpO1xuICB9XG4gIHN0YXRpYyBnZXQgc3VwcG9ydGVkVHlwZXNTdHIoKSB7XG4gICAgcmV0dXJuICgwLCBfdXRpbC5zaGFkb3cpKHRoaXMsIFwic3VwcG9ydGVkVHlwZXNTdHJcIiwgdGhpcy5zdXBwb3J0ZWRUeXBlcy5qb2luKFwiLFwiKSk7XG4gIH1cbiAgc3RhdGljIGlzSGFuZGxpbmdNaW1lRm9yUGFzdGluZyhtaW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuc3VwcG9ydGVkVHlwZXMuaW5jbHVkZXMobWltZSk7XG4gIH1cbiAgc3RhdGljIHBhc3RlKGl0ZW0sIHBhcmVudCkge1xuICAgIHBhcmVudC5wYXN0ZUVkaXRvcihfdXRpbC5Bbm5vdGF0aW9uRWRpdG9yVHlwZS5TVEFNUCwge1xuICAgICAgYml0bWFwRmlsZTogaXRlbS5nZXRBc0ZpbGUoKVxuICAgIH0pO1xuICB9XG4gICNnZXRCaXRtYXBGZXRjaGVkKGRhdGEsIGZyb21JZCA9IGZhbHNlKSB7XG4gICAgaWYgKCFkYXRhKSB7XG4gICAgICB0aGlzLnJlbW92ZSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNiaXRtYXAgPSBkYXRhLmJpdG1hcDtcbiAgICBpZiAoIWZyb21JZCkge1xuICAgICAgdGhpcy4jYml0bWFwSWQgPSBkYXRhLmlkO1xuICAgICAgdGhpcy4jaXNTdmcgPSBkYXRhLmlzU3ZnO1xuICAgIH1cbiAgICB0aGlzLiNjcmVhdGVDYW52YXMoKTtcbiAgfVxuICAjZ2V0Qml0bWFwRG9uZSgpIHtcbiAgICB0aGlzLiNiaXRtYXBQcm9taXNlID0gbnVsbDtcbiAgICB0aGlzLl91aU1hbmFnZXIuZW5hYmxlV2FpdGluZyhmYWxzZSk7XG4gICAgaWYgKHRoaXMuI2NhbnZhcykge1xuICAgICAgdGhpcy5kaXYuZm9jdXMoKTtcbiAgICB9XG4gIH1cbiAgI2dldEJpdG1hcCgpIHtcbiAgICBpZiAodGhpcy4jYml0bWFwSWQpIHtcbiAgICAgIHRoaXMuX3VpTWFuYWdlci5lbmFibGVXYWl0aW5nKHRydWUpO1xuICAgICAgdGhpcy5fdWlNYW5hZ2VyLmltYWdlTWFuYWdlci5nZXRGcm9tSWQodGhpcy4jYml0bWFwSWQpLnRoZW4oZGF0YSA9PiB0aGlzLiNnZXRCaXRtYXBGZXRjaGVkKGRhdGEsIHRydWUpKS5maW5hbGx5KCgpID0+IHRoaXMuI2dldEJpdG1hcERvbmUoKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLiNiaXRtYXBVcmwpIHtcbiAgICAgIGNvbnN0IHVybCA9IHRoaXMuI2JpdG1hcFVybDtcbiAgICAgIHRoaXMuI2JpdG1hcFVybCA9IG51bGw7XG4gICAgICB0aGlzLl91aU1hbmFnZXIuZW5hYmxlV2FpdGluZyh0cnVlKTtcbiAgICAgIHRoaXMuI2JpdG1hcFByb21pc2UgPSB0aGlzLl91aU1hbmFnZXIuaW1hZ2VNYW5hZ2VyLmdldEZyb21VcmwodXJsKS50aGVuKGRhdGEgPT4gdGhpcy4jZ2V0Qml0bWFwRmV0Y2hlZChkYXRhKSkuZmluYWxseSgoKSA9PiB0aGlzLiNnZXRCaXRtYXBEb25lKCkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy4jYml0bWFwRmlsZSkge1xuICAgICAgY29uc3QgZmlsZSA9IHRoaXMuI2JpdG1hcEZpbGU7XG4gICAgICB0aGlzLiNiaXRtYXBGaWxlID0gbnVsbDtcbiAgICAgIHRoaXMuX3VpTWFuYWdlci5lbmFibGVXYWl0aW5nKHRydWUpO1xuICAgICAgdGhpcy4jYml0bWFwUHJvbWlzZSA9IHRoaXMuX3VpTWFuYWdlci5pbWFnZU1hbmFnZXIuZ2V0RnJvbUZpbGUoZmlsZSkudGhlbihkYXRhID0+IHRoaXMuI2dldEJpdG1hcEZldGNoZWQoZGF0YSkpLmZpbmFsbHkoKCkgPT4gdGhpcy4jZ2V0Qml0bWFwRG9uZSgpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7XG4gICAgaW5wdXQudHlwZSA9IFwiZmlsZVwiO1xuICAgIGlucHV0LmFjY2VwdCA9IFN0YW1wRWRpdG9yLnN1cHBvcnRlZFR5cGVzU3RyO1xuICAgIHRoaXMuI2JpdG1hcFByb21pc2UgPSBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgIGlucHV0LmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgICBpZiAoIWlucHV0LmZpbGVzIHx8IGlucHV0LmZpbGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRoaXMucmVtb3ZlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fdWlNYW5hZ2VyLmVuYWJsZVdhaXRpbmcodHJ1ZSk7XG4gICAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHRoaXMuX3VpTWFuYWdlci5pbWFnZU1hbmFnZXIuZ2V0RnJvbUZpbGUoaW5wdXQuZmlsZXNbMF0pO1xuICAgICAgICAgIHRoaXMuI2dldEJpdG1hcEZldGNoZWQoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgfSk7XG4gICAgICBpbnB1dC5hZGRFdmVudExpc3RlbmVyKFwiY2FuY2VsXCIsICgpID0+IHtcbiAgICAgICAgdGhpcy5yZW1vdmUoKTtcbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgfSk7XG4gICAgfSkuZmluYWxseSgoKSA9PiB0aGlzLiNnZXRCaXRtYXBEb25lKCkpO1xuICAgIGlucHV0LmNsaWNrKCk7XG4gIH1cbiAgcmVtb3ZlKCkge1xuICAgIGlmICh0aGlzLiNiaXRtYXBJZCkge1xuICAgICAgdGhpcy4jYml0bWFwID0gbnVsbDtcbiAgICAgIHRoaXMuX3VpTWFuYWdlci5pbWFnZU1hbmFnZXIuZGVsZXRlSWQodGhpcy4jYml0bWFwSWQpO1xuICAgICAgdGhpcy4jY2FudmFzPy5yZW1vdmUoKTtcbiAgICAgIHRoaXMuI2NhbnZhcyA9IG51bGw7XG4gICAgICB0aGlzLiNvYnNlcnZlcj8uZGlzY29ubmVjdCgpO1xuICAgICAgdGhpcy4jb2JzZXJ2ZXIgPSBudWxsO1xuICAgIH1cbiAgICBzdXBlci5yZW1vdmUoKTtcbiAgfVxuICByZWJ1aWxkKCkge1xuICAgIGlmICghdGhpcy5wYXJlbnQpIHtcbiAgICAgIGlmICh0aGlzLiNiaXRtYXBJZCkge1xuICAgICAgICB0aGlzLiNnZXRCaXRtYXAoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3VwZXIucmVidWlsZCgpO1xuICAgIGlmICh0aGlzLmRpdiA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy4jYml0bWFwSWQpIHtcbiAgICAgIHRoaXMuI2dldEJpdG1hcCgpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuaXNBdHRhY2hlZFRvRE9NKSB7XG4gICAgICB0aGlzLnBhcmVudC5hZGQodGhpcyk7XG4gICAgfVxuICB9XG4gIG9uY2VBZGRlZCgpIHtcbiAgICB0aGlzLl9pc0RyYWdnYWJsZSA9IHRydWU7XG4gICAgdGhpcy5kaXYuZm9jdXMoKTtcbiAgfVxuICBpc0VtcHR5KCkge1xuICAgIHJldHVybiAhKHRoaXMuI2JpdG1hcFByb21pc2UgfHwgdGhpcy4jYml0bWFwIHx8IHRoaXMuI2JpdG1hcFVybCB8fCB0aGlzLiNiaXRtYXBGaWxlKTtcbiAgfVxuICBnZXQgaXNSZXNpemFibGUoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIGlmICh0aGlzLmRpdikge1xuICAgICAgcmV0dXJuIHRoaXMuZGl2O1xuICAgIH1cbiAgICBsZXQgYmFzZVgsIGJhc2VZO1xuICAgIGlmICh0aGlzLndpZHRoKSB7XG4gICAgICBiYXNlWCA9IHRoaXMueDtcbiAgICAgIGJhc2VZID0gdGhpcy55O1xuICAgIH1cbiAgICBzdXBlci5yZW5kZXIoKTtcbiAgICB0aGlzLmRpdi5oaWRkZW4gPSB0cnVlO1xuICAgIGlmICh0aGlzLiNiaXRtYXApIHtcbiAgICAgIHRoaXMuI2NyZWF0ZUNhbnZhcygpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLiNnZXRCaXRtYXAoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMud2lkdGgpIHtcbiAgICAgIGNvbnN0IFtwYXJlbnRXaWR0aCwgcGFyZW50SGVpZ2h0XSA9IHRoaXMucGFyZW50RGltZW5zaW9ucztcbiAgICAgIHRoaXMuc2V0QXQoYmFzZVggKiBwYXJlbnRXaWR0aCwgYmFzZVkgKiBwYXJlbnRIZWlnaHQsIHRoaXMud2lkdGggKiBwYXJlbnRXaWR0aCwgdGhpcy5oZWlnaHQgKiBwYXJlbnRIZWlnaHQpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5kaXY7XG4gIH1cbiAgI2NyZWF0ZUNhbnZhcygpIHtcbiAgICBjb25zdCB7XG4gICAgICBkaXZcbiAgICB9ID0gdGhpcztcbiAgICBsZXQge1xuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHRcbiAgICB9ID0gdGhpcy4jYml0bWFwO1xuICAgIGNvbnN0IFtwYWdlV2lkdGgsIHBhZ2VIZWlnaHRdID0gdGhpcy5wYWdlRGltZW5zaW9ucztcbiAgICBjb25zdCBNQVhfUkFUSU8gPSAwLjc1O1xuICAgIGlmICh0aGlzLndpZHRoKSB7XG4gICAgICB3aWR0aCA9IHRoaXMud2lkdGggKiBwYWdlV2lkdGg7XG4gICAgICBoZWlnaHQgPSB0aGlzLmhlaWdodCAqIHBhZ2VIZWlnaHQ7XG4gICAgfSBlbHNlIGlmICh3aWR0aCA+IE1BWF9SQVRJTyAqIHBhZ2VXaWR0aCB8fCBoZWlnaHQgPiBNQVhfUkFUSU8gKiBwYWdlSGVpZ2h0KSB7XG4gICAgICBjb25zdCBmYWN0b3IgPSBNYXRoLm1pbihNQVhfUkFUSU8gKiBwYWdlV2lkdGggLyB3aWR0aCwgTUFYX1JBVElPICogcGFnZUhlaWdodCAvIGhlaWdodCk7XG4gICAgICB3aWR0aCAqPSBmYWN0b3I7XG4gICAgICBoZWlnaHQgKj0gZmFjdG9yO1xuICAgIH1cbiAgICBjb25zdCBbcGFyZW50V2lkdGgsIHBhcmVudEhlaWdodF0gPSB0aGlzLnBhcmVudERpbWVuc2lvbnM7XG4gICAgdGhpcy5zZXREaW1zKHdpZHRoICogcGFyZW50V2lkdGggLyBwYWdlV2lkdGgsIGhlaWdodCAqIHBhcmVudEhlaWdodCAvIHBhZ2VIZWlnaHQpO1xuICAgIHRoaXMuX3VpTWFuYWdlci5lbmFibGVXYWl0aW5nKGZhbHNlKTtcbiAgICBjb25zdCBjYW52YXMgPSB0aGlzLiNjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgIGRpdi5hcHBlbmQoY2FudmFzKTtcbiAgICBkaXYuaGlkZGVuID0gZmFsc2U7XG4gICAgdGhpcy4jZHJhd0JpdG1hcCh3aWR0aCwgaGVpZ2h0KTtcbiAgICB0aGlzLiNjcmVhdGVPYnNlcnZlcigpO1xuICAgIGlmICghdGhpcy4jaGFzQmVlbkFkZGVkSW5VbmRvU3RhY2spIHtcbiAgICAgIHRoaXMucGFyZW50LmFkZFVuZG9hYmxlRWRpdG9yKHRoaXMpO1xuICAgICAgdGhpcy4jaGFzQmVlbkFkZGVkSW5VbmRvU3RhY2sgPSB0cnVlO1xuICAgIH1cbiAgICB0aGlzLl91aU1hbmFnZXIuX2V2ZW50QnVzLmRpc3BhdGNoKFwicmVwb3J0dGVsZW1ldHJ5XCIsIHtcbiAgICAgIHNvdXJjZTogdGhpcyxcbiAgICAgIGRldGFpbHM6IHtcbiAgICAgICAgdHlwZTogXCJlZGl0aW5nXCIsXG4gICAgICAgIHN1YnR5cGU6IHRoaXMuZWRpdG9yVHlwZSxcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIGFjdGlvbjogXCJpbnNlcnRlZF9pbWFnZVwiXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLmFkZEFsdFRleHRCdXR0b24oKTtcbiAgfVxuICAjc2V0RGltZW5zaW9ucyh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgY29uc3QgW3BhcmVudFdpZHRoLCBwYXJlbnRIZWlnaHRdID0gdGhpcy5wYXJlbnREaW1lbnNpb25zO1xuICAgIHRoaXMud2lkdGggPSB3aWR0aCAvIHBhcmVudFdpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0IC8gcGFyZW50SGVpZ2h0O1xuICAgIHRoaXMuc2V0RGltcyh3aWR0aCwgaGVpZ2h0KTtcbiAgICBpZiAodGhpcy5faW5pdGlhbE9wdGlvbnM/LmlzQ2VudGVyZWQpIHtcbiAgICAgIHRoaXMuY2VudGVyKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZml4QW5kU2V0UG9zaXRpb24oKTtcbiAgICB9XG4gICAgdGhpcy5faW5pdGlhbE9wdGlvbnMgPSBudWxsO1xuICAgIGlmICh0aGlzLiNyZXNpemVUaW1lb3V0SWQgIT09IG51bGwpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLiNyZXNpemVUaW1lb3V0SWQpO1xuICAgIH1cbiAgICBjb25zdCBUSU1FX1RPX1dBSVQgPSAyMDA7XG4gICAgdGhpcy4jcmVzaXplVGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLiNyZXNpemVUaW1lb3V0SWQgPSBudWxsO1xuICAgICAgdGhpcy4jZHJhd0JpdG1hcCh3aWR0aCwgaGVpZ2h0KTtcbiAgICB9LCBUSU1FX1RPX1dBSVQpO1xuICB9XG4gICNzY2FsZUJpdG1hcCh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgY29uc3Qge1xuICAgICAgd2lkdGg6IGJpdG1hcFdpZHRoLFxuICAgICAgaGVpZ2h0OiBiaXRtYXBIZWlnaHRcbiAgICB9ID0gdGhpcy4jYml0bWFwO1xuICAgIGxldCBuZXdXaWR0aCA9IGJpdG1hcFdpZHRoO1xuICAgIGxldCBuZXdIZWlnaHQgPSBiaXRtYXBIZWlnaHQ7XG4gICAgbGV0IGJpdG1hcCA9IHRoaXMuI2JpdG1hcDtcbiAgICB3aGlsZSAobmV3V2lkdGggPiAyICogd2lkdGggfHwgbmV3SGVpZ2h0ID4gMiAqIGhlaWdodCkge1xuICAgICAgY29uc3QgcHJldldpZHRoID0gbmV3V2lkdGg7XG4gICAgICBjb25zdCBwcmV2SGVpZ2h0ID0gbmV3SGVpZ2h0O1xuICAgICAgaWYgKG5ld1dpZHRoID4gMiAqIHdpZHRoKSB7XG4gICAgICAgIG5ld1dpZHRoID0gbmV3V2lkdGggPj0gMTYzODQgPyBNYXRoLmZsb29yKG5ld1dpZHRoIC8gMikgLSAxIDogTWF0aC5jZWlsKG5ld1dpZHRoIC8gMik7XG4gICAgICB9XG4gICAgICBpZiAobmV3SGVpZ2h0ID4gMiAqIGhlaWdodCkge1xuICAgICAgICBuZXdIZWlnaHQgPSBuZXdIZWlnaHQgPj0gMTYzODQgPyBNYXRoLmZsb29yKG5ld0hlaWdodCAvIDIpIC0gMSA6IE1hdGguY2VpbChuZXdIZWlnaHQgLyAyKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG9mZnNjcmVlbiA9IG5ldyBPZmZzY3JlZW5DYW52YXMobmV3V2lkdGgsIG5ld0hlaWdodCk7XG4gICAgICBjb25zdCBjdHggPSBvZmZzY3JlZW4uZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgICAgY3R4LmRyYXdJbWFnZShiaXRtYXAsIDAsIDAsIHByZXZXaWR0aCwgcHJldkhlaWdodCwgMCwgMCwgbmV3V2lkdGgsIG5ld0hlaWdodCk7XG4gICAgICBiaXRtYXAgPSBvZmZzY3JlZW4udHJhbnNmZXJUb0ltYWdlQml0bWFwKCk7XG4gICAgfVxuICAgIHJldHVybiBiaXRtYXA7XG4gIH1cbiAgI2RyYXdCaXRtYXAod2lkdGgsIGhlaWdodCkge1xuICAgIHdpZHRoID0gTWF0aC5jZWlsKHdpZHRoKTtcbiAgICBoZWlnaHQgPSBNYXRoLmNlaWwoaGVpZ2h0KTtcbiAgICBjb25zdCBjYW52YXMgPSB0aGlzLiNjYW52YXM7XG4gICAgaWYgKCFjYW52YXMgfHwgY2FudmFzLndpZHRoID09PSB3aWR0aCAmJiBjYW52YXMuaGVpZ2h0ID09PSBoZWlnaHQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY2FudmFzLndpZHRoID0gd2lkdGg7XG4gICAgY2FudmFzLmhlaWdodCA9IGhlaWdodDtcbiAgICBjb25zdCBiaXRtYXAgPSB0aGlzLiNpc1N2ZyA/IHRoaXMuI2JpdG1hcCA6IHRoaXMuI3NjYWxlQml0bWFwKHdpZHRoLCBoZWlnaHQpO1xuICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgY3R4LmZpbHRlciA9IHRoaXMuX3VpTWFuYWdlci5oY21GaWx0ZXI7XG4gICAgY3R4LmRyYXdJbWFnZShiaXRtYXAsIDAsIDAsIGJpdG1hcC53aWR0aCwgYml0bWFwLmhlaWdodCwgMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gIH1cbiAgI3NlcmlhbGl6ZUJpdG1hcCh0b1VybCkge1xuICAgIGlmICh0b1VybCkge1xuICAgICAgaWYgKHRoaXMuI2lzU3ZnKSB7XG4gICAgICAgIGNvbnN0IHVybCA9IHRoaXMuX3VpTWFuYWdlci5pbWFnZU1hbmFnZXIuZ2V0U3ZnVXJsKHRoaXMuI2JpdG1hcElkKTtcbiAgICAgICAgaWYgKHVybCkge1xuICAgICAgICAgIHJldHVybiB1cmw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gICAgICAoe1xuICAgICAgICB3aWR0aDogY2FudmFzLndpZHRoLFxuICAgICAgICBoZWlnaHQ6IGNhbnZhcy5oZWlnaHRcbiAgICAgIH0gPSB0aGlzLiNiaXRtYXApO1xuICAgICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICAgIGN0eC5kcmF3SW1hZ2UodGhpcy4jYml0bWFwLCAwLCAwKTtcbiAgICAgIHJldHVybiBjYW52YXMudG9EYXRhVVJMKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLiNpc1N2Zykge1xuICAgICAgY29uc3QgW3BhZ2VXaWR0aCwgcGFnZUhlaWdodF0gPSB0aGlzLnBhZ2VEaW1lbnNpb25zO1xuICAgICAgY29uc3Qgd2lkdGggPSBNYXRoLnJvdW5kKHRoaXMud2lkdGggKiBwYWdlV2lkdGggKiBfZGlzcGxheV91dGlscy5QaXhlbHNQZXJJbmNoLlBERl9UT19DU1NfVU5JVFMpO1xuICAgICAgY29uc3QgaGVpZ2h0ID0gTWF0aC5yb3VuZCh0aGlzLmhlaWdodCAqIHBhZ2VIZWlnaHQgKiBfZGlzcGxheV91dGlscy5QaXhlbHNQZXJJbmNoLlBERl9UT19DU1NfVU5JVFMpO1xuICAgICAgY29uc3Qgb2Zmc2NyZWVuID0gbmV3IE9mZnNjcmVlbkNhbnZhcyh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIGNvbnN0IGN0eCA9IG9mZnNjcmVlbi5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgICBjdHguZHJhd0ltYWdlKHRoaXMuI2JpdG1hcCwgMCwgMCwgdGhpcy4jYml0bWFwLndpZHRoLCB0aGlzLiNiaXRtYXAuaGVpZ2h0LCAwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIHJldHVybiBvZmZzY3JlZW4udHJhbnNmZXJUb0ltYWdlQml0bWFwKCk7XG4gICAgfVxuICAgIHJldHVybiBzdHJ1Y3R1cmVkQ2xvbmUodGhpcy4jYml0bWFwKTtcbiAgfVxuICAjY3JlYXRlT2JzZXJ2ZXIoKSB7XG4gICAgdGhpcy4jb2JzZXJ2ZXIgPSBuZXcgUmVzaXplT2JzZXJ2ZXIoZW50cmllcyA9PiB7XG4gICAgICBjb25zdCByZWN0ID0gZW50cmllc1swXS5jb250ZW50UmVjdDtcbiAgICAgIGlmIChyZWN0LndpZHRoICYmIHJlY3QuaGVpZ2h0KSB7XG4gICAgICAgIHRoaXMuI3NldERpbWVuc2lvbnMocmVjdC53aWR0aCwgcmVjdC5oZWlnaHQpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuI29ic2VydmVyLm9ic2VydmUodGhpcy5kaXYpO1xuICB9XG4gIHN0YXRpYyBkZXNlcmlhbGl6ZShkYXRhLCBwYXJlbnQsIHVpTWFuYWdlcikge1xuICAgIGlmIChkYXRhIGluc3RhbmNlb2YgX2Fubm90YXRpb25fbGF5ZXIuU3RhbXBBbm5vdGF0aW9uRWxlbWVudCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGVkaXRvciA9IHN1cGVyLmRlc2VyaWFsaXplKGRhdGEsIHBhcmVudCwgdWlNYW5hZ2VyKTtcbiAgICBjb25zdCB7XG4gICAgICByZWN0LFxuICAgICAgYml0bWFwVXJsLFxuICAgICAgYml0bWFwSWQsXG4gICAgICBpc1N2ZyxcbiAgICAgIGFjY2Vzc2liaWxpdHlEYXRhXG4gICAgfSA9IGRhdGE7XG4gICAgaWYgKGJpdG1hcElkICYmIHVpTWFuYWdlci5pbWFnZU1hbmFnZXIuaXNWYWxpZElkKGJpdG1hcElkKSkge1xuICAgICAgZWRpdG9yLiNiaXRtYXBJZCA9IGJpdG1hcElkO1xuICAgIH0gZWxzZSB7XG4gICAgICBlZGl0b3IuI2JpdG1hcFVybCA9IGJpdG1hcFVybDtcbiAgICB9XG4gICAgZWRpdG9yLiNpc1N2ZyA9IGlzU3ZnO1xuICAgIGNvbnN0IFtwYXJlbnRXaWR0aCwgcGFyZW50SGVpZ2h0XSA9IGVkaXRvci5wYWdlRGltZW5zaW9ucztcbiAgICBlZGl0b3Iud2lkdGggPSAocmVjdFsyXSAtIHJlY3RbMF0pIC8gcGFyZW50V2lkdGg7XG4gICAgZWRpdG9yLmhlaWdodCA9IChyZWN0WzNdIC0gcmVjdFsxXSkgLyBwYXJlbnRIZWlnaHQ7XG4gICAgaWYgKGFjY2Vzc2liaWxpdHlEYXRhKSB7XG4gICAgICBlZGl0b3IuYWx0VGV4dERhdGEgPSBhY2Nlc3NpYmlsaXR5RGF0YTtcbiAgICB9XG4gICAgcmV0dXJuIGVkaXRvcjtcbiAgfVxuICBzZXJpYWxpemUoaXNGb3JDb3B5aW5nID0gZmFsc2UsIGNvbnRleHQgPSBudWxsKSB7XG4gICAgaWYgKHRoaXMuaXNFbXB0eSgpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3Qgc2VyaWFsaXplZCA9IHtcbiAgICAgIGFubm90YXRpb25UeXBlOiBfdXRpbC5Bbm5vdGF0aW9uRWRpdG9yVHlwZS5TVEFNUCxcbiAgICAgIGJpdG1hcElkOiB0aGlzLiNiaXRtYXBJZCxcbiAgICAgIHBhZ2VJbmRleDogdGhpcy5wYWdlSW5kZXgsXG4gICAgICByZWN0OiB0aGlzLmdldFJlY3QoMCwgMCksXG4gICAgICByb3RhdGlvbjogdGhpcy5yb3RhdGlvbixcbiAgICAgIGlzU3ZnOiB0aGlzLiNpc1N2ZyxcbiAgICAgIHN0cnVjdFRyZWVQYXJlbnRJZDogdGhpcy5fc3RydWN0VHJlZVBhcmVudElkXG4gICAgfTtcbiAgICBpZiAoaXNGb3JDb3B5aW5nKSB7XG4gICAgICBzZXJpYWxpemVkLmJpdG1hcFVybCA9IHRoaXMuI3NlcmlhbGl6ZUJpdG1hcCh0cnVlKTtcbiAgICAgIHNlcmlhbGl6ZWQuYWNjZXNzaWJpbGl0eURhdGEgPSB0aGlzLmFsdFRleHREYXRhO1xuICAgICAgcmV0dXJuIHNlcmlhbGl6ZWQ7XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGRlY29yYXRpdmUsXG4gICAgICBhbHRUZXh0XG4gICAgfSA9IHRoaXMuYWx0VGV4dERhdGE7XG4gICAgaWYgKCFkZWNvcmF0aXZlICYmIGFsdFRleHQpIHtcbiAgICAgIHNlcmlhbGl6ZWQuYWNjZXNzaWJpbGl0eURhdGEgPSB7XG4gICAgICAgIHR5cGU6IFwiRmlndXJlXCIsXG4gICAgICAgIGFsdDogYWx0VGV4dFxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKGNvbnRleHQgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBzZXJpYWxpemVkO1xuICAgIH1cbiAgICBjb250ZXh0LnN0YW1wcyB8fD0gbmV3IE1hcCgpO1xuICAgIGNvbnN0IGFyZWEgPSB0aGlzLiNpc1N2ZyA/IChzZXJpYWxpemVkLnJlY3RbMl0gLSBzZXJpYWxpemVkLnJlY3RbMF0pICogKHNlcmlhbGl6ZWQucmVjdFszXSAtIHNlcmlhbGl6ZWQucmVjdFsxXSkgOiBudWxsO1xuICAgIGlmICghY29udGV4dC5zdGFtcHMuaGFzKHRoaXMuI2JpdG1hcElkKSkge1xuICAgICAgY29udGV4dC5zdGFtcHMuc2V0KHRoaXMuI2JpdG1hcElkLCB7XG4gICAgICAgIGFyZWEsXG4gICAgICAgIHNlcmlhbGl6ZWRcbiAgICAgIH0pO1xuICAgICAgc2VyaWFsaXplZC5iaXRtYXAgPSB0aGlzLiNzZXJpYWxpemVCaXRtYXAoZmFsc2UpO1xuICAgIH0gZWxzZSBpZiAodGhpcy4jaXNTdmcpIHtcbiAgICAgIGNvbnN0IHByZXZEYXRhID0gY29udGV4dC5zdGFtcHMuZ2V0KHRoaXMuI2JpdG1hcElkKTtcbiAgICAgIGlmIChhcmVhID4gcHJldkRhdGEuYXJlYSkge1xuICAgICAgICBwcmV2RGF0YS5hcmVhID0gYXJlYTtcbiAgICAgICAgcHJldkRhdGEuc2VyaWFsaXplZC5iaXRtYXAuY2xvc2UoKTtcbiAgICAgICAgcHJldkRhdGEuc2VyaWFsaXplZC5iaXRtYXAgPSB0aGlzLiNzZXJpYWxpemVCaXRtYXAoZmFsc2UpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2VyaWFsaXplZDtcbiAgfVxufVxuZXhwb3J0cy5TdGFtcEVkaXRvciA9IFN0YW1wRWRpdG9yO1xuXG4vKioqLyB9KVxuLyoqKioqKi8gXHRdKTtcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0dmFyIF9fd2VicGFja19tb2R1bGVfY2FjaGVfXyA9IHt9O1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIFx0ZnVuY3Rpb24gX193X3BkZmpzX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuLyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuLyoqKioqKi8gXHRcdHZhciBjYWNoZWRNb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdO1xuLyoqKioqKi8gXHRcdGlmIChjYWNoZWRNb2R1bGUgIT09IHVuZGVmaW5lZCkge1xuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGNhY2hlZE1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0Ly8gbm8gbW9kdWxlLmlkIG5lZWRlZFxuLyoqKioqKi8gXHRcdFx0Ly8gbm8gbW9kdWxlLmxvYWRlZCBuZWVkZWRcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9XG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdFx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0obW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXyk7XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHR9XG4vKioqKioqLyBcdFxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fID0ge307XG4vLyBUaGlzIGVudHJ5IG5lZWQgdG8gYmUgd3JhcHBlZCBpbiBhbiBJSUZFIGJlY2F1c2UgaXQgbmVlZCB0byBiZSBpc29sYXRlZCBhZ2FpbnN0IG90aGVyIG1vZHVsZXMgaW4gdGhlIGNodW5rLlxuKCgpID0+IHtcbnZhciBleHBvcnRzID0gX193ZWJwYWNrX2V4cG9ydHNfXztcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJBYm9ydEV4Y2VwdGlvblwiLCAoe1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX3V0aWwuQWJvcnRFeGNlcHRpb247XG4gIH1cbn0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkFubm90YXRpb25FZGl0b3JMYXllclwiLCAoe1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2Fubm90YXRpb25fZWRpdG9yX2xheWVyLkFubm90YXRpb25FZGl0b3JMYXllcjtcbiAgfVxufSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGVcIiwgKHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF91dGlsLkFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlO1xuICB9XG59KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJBbm5vdGF0aW9uRWRpdG9yVHlwZVwiLCAoe1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX3V0aWwuQW5ub3RhdGlvbkVkaXRvclR5cGU7XG4gIH1cbn0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkFubm90YXRpb25FZGl0b3JVSU1hbmFnZXJcIiwgKHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF90b29scy5Bbm5vdGF0aW9uRWRpdG9yVUlNYW5hZ2VyO1xuICB9XG59KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJBbm5vdGF0aW9uTGF5ZXJcIiwgKHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9hbm5vdGF0aW9uX2xheWVyLkFubm90YXRpb25MYXllcjtcbiAgfVxufSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQW5ub3RhdGlvbk1vZGVcIiwgKHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF91dGlsLkFubm90YXRpb25Nb2RlO1xuICB9XG59KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDTWFwQ29tcHJlc3Npb25UeXBlXCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfdXRpbC5DTWFwQ29tcHJlc3Npb25UeXBlO1xuICB9XG59KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJET01TVkdGYWN0b3J5XCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfZGlzcGxheV91dGlscy5ET01TVkdGYWN0b3J5O1xuICB9XG59KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJGZWF0dXJlVGVzdFwiLCAoe1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX3V0aWwuRmVhdHVyZVRlc3Q7XG4gIH1cbn0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkdsb2JhbFdvcmtlck9wdGlvbnNcIiwgKHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF93b3JrZXJfb3B0aW9ucy5HbG9iYWxXb3JrZXJPcHRpb25zO1xuICB9XG59KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJJbWFnZUtpbmRcIiwgKHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF91dGlsLkltYWdlS2luZDtcbiAgfVxufSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSW52YWxpZFBERkV4Y2VwdGlvblwiLCAoe1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX3V0aWwuSW52YWxpZFBERkV4Y2VwdGlvbjtcbiAgfVxufSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTWlzc2luZ1BERkV4Y2VwdGlvblwiLCAoe1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX3V0aWwuTWlzc2luZ1BERkV4Y2VwdGlvbjtcbiAgfVxufSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiT1BTXCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfdXRpbC5PUFM7XG4gIH1cbn0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlBERkRhdGFSYW5nZVRyYW5zcG9ydFwiLCAoe1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2FwaS5QREZEYXRhUmFuZ2VUcmFuc3BvcnQ7XG4gIH1cbn0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlBERkRhdGVTdHJpbmdcIiwgKHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9kaXNwbGF5X3V0aWxzLlBERkRhdGVTdHJpbmc7XG4gIH1cbn0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlBERldvcmtlclwiLCAoe1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2FwaS5QREZXb3JrZXI7XG4gIH1cbn0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlBhc3N3b3JkUmVzcG9uc2VzXCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfdXRpbC5QYXNzd29yZFJlc3BvbnNlcztcbiAgfVxufSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUGVybWlzc2lvbkZsYWdcIiwgKHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF91dGlsLlBlcm1pc3Npb25GbGFnO1xuICB9XG59KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJQaXhlbHNQZXJJbmNoXCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfZGlzcGxheV91dGlscy5QaXhlbHNQZXJJbmNoO1xuICB9XG59KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJQcm9taXNlQ2FwYWJpbGl0eVwiLCAoe1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX3V0aWwuUHJvbWlzZUNhcGFiaWxpdHk7XG4gIH1cbn0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJlbmRlcmluZ0NhbmNlbGxlZEV4Y2VwdGlvblwiLCAoe1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2Rpc3BsYXlfdXRpbHMuUmVuZGVyaW5nQ2FuY2VsbGVkRXhjZXB0aW9uO1xuICB9XG59KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJTVkdHcmFwaGljc1wiLCAoe1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2FwaS5TVkdHcmFwaGljcztcbiAgfVxufSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVW5leHBlY3RlZFJlc3BvbnNlRXhjZXB0aW9uXCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfdXRpbC5VbmV4cGVjdGVkUmVzcG9uc2VFeGNlcHRpb247XG4gIH1cbn0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlV0aWxcIiwgKHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF91dGlsLlV0aWw7XG4gIH1cbn0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlZlcmJvc2l0eUxldmVsXCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfdXRpbC5WZXJib3NpdHlMZXZlbDtcbiAgfVxufSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiWGZhTGF5ZXJcIiwgKHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF94ZmFfbGF5ZXIuWGZhTGF5ZXI7XG4gIH1cbn0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImJ1aWxkXCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfYXBpLmJ1aWxkO1xuICB9XG59KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjcmVhdGVWYWxpZEFic29sdXRlVXJsXCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfdXRpbC5jcmVhdGVWYWxpZEFic29sdXRlVXJsO1xuICB9XG59KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnZXREb2N1bWVudFwiLCAoe1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2FwaS5nZXREb2N1bWVudDtcbiAgfVxufSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZ2V0RmlsZW5hbWVGcm9tVXJsXCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfZGlzcGxheV91dGlscy5nZXRGaWxlbmFtZUZyb21Vcmw7XG4gIH1cbn0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImdldFBkZkZpbGVuYW1lRnJvbVVybFwiLCAoe1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2Rpc3BsYXlfdXRpbHMuZ2V0UGRmRmlsZW5hbWVGcm9tVXJsO1xuICB9XG59KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnZXRYZmFQYWdlVmlld3BvcnRcIiwgKHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9kaXNwbGF5X3V0aWxzLmdldFhmYVBhZ2VWaWV3cG9ydDtcbiAgfVxufSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaXNEYXRhU2NoZW1lXCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfZGlzcGxheV91dGlscy5pc0RhdGFTY2hlbWU7XG4gIH1cbn0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImlzUGRmRmlsZVwiLCAoe1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2Rpc3BsYXlfdXRpbHMuaXNQZGZGaWxlO1xuICB9XG59KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJsb2FkU2NyaXB0XCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfZGlzcGxheV91dGlscy5sb2FkU2NyaXB0O1xuICB9XG59KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJub0NvbnRleHRNZW51XCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfZGlzcGxheV91dGlscy5ub0NvbnRleHRNZW51O1xuICB9XG59KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJub3JtYWxpemVVbmljb2RlXCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfdXRpbC5ub3JtYWxpemVVbmljb2RlO1xuICB9XG59KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJyZW5kZXJUZXh0TGF5ZXJcIiwgKHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF90ZXh0X2xheWVyLnJlbmRlclRleHRMYXllcjtcbiAgfVxufSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic2V0TGF5ZXJEaW1lbnNpb25zXCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfZGlzcGxheV91dGlscy5zZXRMYXllckRpbWVuc2lvbnM7XG4gIH1cbn0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInNoYWRvd1wiLCAoe1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX3V0aWwuc2hhZG93O1xuICB9XG59KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ1cGRhdGVUZXh0TGF5ZXJcIiwgKHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF90ZXh0X2xheWVyLnVwZGF0ZVRleHRMYXllcjtcbiAgfVxufSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidmVyc2lvblwiLCAoe1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2FwaS52ZXJzaW9uO1xuICB9XG59KSk7XG52YXIgX3V0aWwgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEpO1xudmFyIF9hcGkgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDIpO1xudmFyIF9kaXNwbGF5X3V0aWxzID0gX193X3BkZmpzX3JlcXVpcmVfXyg2KTtcbnZhciBfdGV4dF9sYXllciA9IF9fd19wZGZqc19yZXF1aXJlX18oMjYpO1xudmFyIF9hbm5vdGF0aW9uX2VkaXRvcl9sYXllciA9IF9fd19wZGZqc19yZXF1aXJlX18oMjcpO1xudmFyIF90b29scyA9IF9fd19wZGZqc19yZXF1aXJlX18oNSk7XG52YXIgX2Fubm90YXRpb25fbGF5ZXIgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDI5KTtcbnZhciBfd29ya2VyX29wdGlvbnMgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDE0KTtcbnZhciBfeGZhX2xheWVyID0gX193X3BkZmpzX3JlcXVpcmVfXygzMik7XG5jb25zdCBwZGZqc1ZlcnNpb24gPSAnMy4xMS4xNzQnO1xuY29uc3QgcGRmanNCdWlsZCA9ICdjZTg3MTY3NDMnO1xufSkoKTtcblxuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX2V4cG9ydHNfXztcbi8qKioqKiovIH0pKClcbjtcbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGRmLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-pdf/node_modules/pdfjs-dist/build/pdf.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-pdftotext/dist/index.js":
/*!****************************************************!*\
  !*** ./node_modules/react-pdftotext/dist/index.js ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nvar _reactPdf = __webpack_require__(/*! react-pdf */ \"(app-pages-browser)/./node_modules/react-pdf/dist/cjs/index.js\");\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = \"function\" == typeof Symbol ? Symbol : {}, a = i.iterator || \"@@iterator\", c = i.asyncIterator || \"@@asyncIterator\", u = i.toStringTag || \"@@toStringTag\"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, \"\"); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, \"_invoke\", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: \"normal\", arg: t.call(e, r) }; } catch (t) { return { type: \"throw\", arg: t }; } } e.wrap = wrap; var h = \"suspendedStart\", l = \"suspendedYield\", f = \"executing\", s = \"completed\", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { [\"next\", \"throw\", \"return\"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if (\"throw\" !== c.type) { var u = c.arg, h = u.value; return h && \"object\" == _typeof(h) && n.call(h, \"__await\") ? e.resolve(h.__await).then(function (t) { invoke(\"next\", t, i, a); }, function (t) { invoke(\"throw\", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke(\"throw\", t, i, a); }); } a(c.arg); } var r; o(this, \"_invoke\", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error(\"Generator is already running\"); if (o === s) { if (\"throw\" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if (\"next\" === n.method) n.sent = n._sent = n.arg;else if (\"throw\" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else \"return\" === n.method && n.abrupt(\"return\", n.arg); o = f; var p = tryCatch(e, r, n); if (\"normal\" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } \"throw\" === p.type && (o = s, n.method = \"throw\", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, \"throw\" === n && e.iterator[\"return\"] && (r.method = \"return\", r.arg = t, maybeInvokeDelegate(e, r), \"throw\" === r.method) || \"return\" !== n && (r.method = \"throw\", r.arg = new TypeError(\"The iterator does not provide a '\" + n + \"' method\")), y; var i = tryCatch(o, e.iterator, r.arg); if (\"throw\" === i.type) return r.method = \"throw\", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, \"return\" !== r.method && (r.method = \"next\", r.arg = t), r.delegate = null, y) : a : (r.method = \"throw\", r.arg = new TypeError(\"iterator result is not an object\"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = \"normal\", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: \"root\" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || \"\" === e) { var r = e[a]; if (r) return r.call(e); if (\"function\" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + \" is not iterable\"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, \"constructor\", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, \"constructor\", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, \"GeneratorFunction\"), e.isGeneratorFunction = function (t) { var e = \"function\" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || \"GeneratorFunction\" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, \"GeneratorFunction\")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, \"Generator\"), define(g, a, function () { return this; }), define(g, \"toString\", function () { return \"[object Generator]\"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) \"t\" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if (\"throw\" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = \"throw\", a.arg = e, r.next = n, o && (r.method = \"next\", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if (\"root\" === i.tryLoc) return handle(\"end\"); if (i.tryLoc <= this.prev) { var c = n.call(i, \"catchLoc\"), u = n.call(i, \"finallyLoc\"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error(\"try statement without catch or finally\"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, \"finallyLoc\") && this.prev < o.finallyLoc) { var i = o; break; } } i && (\"break\" === t || \"continue\" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = \"next\", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if (\"throw\" === t.type) throw t.arg; return \"break\" === t.type || \"continue\" === t.type ? this.next = t.arg : \"return\" === t.type ? (this.rval = this.arg = t.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, \"catch\": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if (\"throw\" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, \"next\" === this.method && (this.arg = t), y; } }, e; }\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n// Path to the pdf.worker.js file\n_reactPdf.pdfjs.GlobalWorkerOptions.workerSrc = \"//cdnjs.cloudflare.com/ajax/libs/pdf.js/\".concat(_reactPdf.pdfjs.version, \"/pdf.worker.js\");\n\n/**\r\n * Extracts text content from a PDF file.\r\n * @param {File} file - The PDF file to extract text from.\r\n * @returns {Promise<string>} A promise that resolves with the extracted text content.\r\n */\nvar pdfToText = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(file) {\n    var blobUrl, loadingTask, extractedText, hadParsingError, pdf, numPages, pageNumber, page, textContent, pageText;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          // Create a blob URL for the PDF file\n          blobUrl = URL.createObjectURL(file); // Load the PDF file\n          loadingTask = _reactPdf.pdfjs.getDocument(blobUrl);\n          extractedText = \"\";\n          hadParsingError = false;\n          _context.prev = 4;\n          _context.next = 7;\n          return loadingTask.promise;\n        case 7:\n          pdf = _context.sent;\n          numPages = pdf.numPages; // Iterate through each page and extract text\n          pageNumber = 1;\n        case 10:\n          if (!(pageNumber <= numPages)) {\n            _context.next = 22;\n            break;\n          }\n          _context.next = 13;\n          return pdf.getPage(pageNumber);\n        case 13:\n          page = _context.sent;\n          _context.next = 16;\n          return page.getTextContent();\n        case 16:\n          textContent = _context.sent;\n          pageText = textContent.items.map(function (item) {\n            return item.str;\n          }).join(\" \");\n          extractedText += pageText;\n        case 19:\n          pageNumber++;\n          _context.next = 10;\n          break;\n        case 22:\n          _context.next = 28;\n          break;\n        case 24:\n          _context.prev = 24;\n          _context.t0 = _context[\"catch\"](4);\n          hadParsingError = true;\n          console.error(\"Error extracting text from PDF:\", _context.t0);\n        case 28:\n          // Clean up the blob URL\n          URL.revokeObjectURL(blobUrl);\n\n          // Free memory from loading task\n          loadingTask.destroy();\n          if (hadParsingError) {\n            _context.next = 32;\n            break;\n          }\n          return _context.abrupt(\"return\", extractedText);\n        case 32:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _callee, null, [[4, 24]]);\n  }));\n  return function pdfToText(_x) {\n    return _ref.apply(this, arguments);\n  };\n}();\nvar _default = exports[\"default\"] = pdfToText;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1wZGZ0b3RleHQvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixzQkFBc0IsMkJBQTJCLG9HQUFvRyxtQkFBbUIsaUJBQWlCLHNIQUFzSDtBQUMvUyw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRixrQkFBa0I7QUFDbEIsZ0JBQWdCLG1CQUFPLENBQUMsaUZBQVc7QUFDbkMsaUNBQWlDLGNBQWMsNE1BQTRNLGFBQWEsYUFBYSxnR0FBZ0csaUJBQWlCLCtDQUErQyxrSEFBa0gsMkJBQTJCLHFDQUFxQywwREFBMEQsV0FBVyxNQUFNLFNBQVMsU0FBUyxZQUFZLG9DQUFvQyxzQkFBc0IsNEJBQTRCLHlIQUF5SCx5QkFBeUIsa0NBQWtDLFFBQVEsNkJBQTZCLE1BQU0sU0FBUyx1Q0FBdUMsWUFBWSxTQUFTLDZCQUE2QixlQUFlLDBGQUEwRix3QkFBd0IsZ0NBQWdDLHlDQUF5QyxZQUFZLDJCQUEyQixjQUFjLEdBQUcsMERBQTBELHlDQUF5Qyx1RkFBdUYsb0NBQW9DLG1EQUFtRCw0QkFBNEIsNEJBQTRCLElBQUksS0FBSywrQkFBK0IsOEJBQThCLDhCQUE4QiwwQkFBMEIsNEJBQTRCLHNHQUFzRywwQkFBMEIsaUJBQWlCLDJCQUEyQixxQ0FBcUMsb0JBQW9CLGlCQUFpQixrQ0FBa0MsS0FBSyxZQUFZLE9BQU8scUJBQXFCLDhCQUE4Qix3Q0FBd0MsK0JBQStCLHFCQUFxQixLQUFLLGlIQUFpSCxLQUFLLHFDQUFxQyxXQUFXLHlCQUF5QiwwREFBMEQsZUFBZSw0QkFBNEIsU0FBUyx3QkFBd0IsOEJBQThCLElBQUksb0JBQW9CLFNBQVMsbUNBQW1DLFNBQVMsdUJBQXVCLGNBQWMsa0RBQWtELGlDQUFpQyxpQ0FBaUMsOEJBQThCLHlEQUF5RCxPQUFPLDJCQUEyQiwyQkFBMkIsK0NBQStDLFNBQVMsZ0NBQWdDLHlFQUF5RSxxQ0FBcUMscUNBQXFDLDZSQUE2Uix3Q0FBd0Msd0ZBQXdGLGVBQWUsa1FBQWtRLDJCQUEyQixVQUFVLGdCQUFnQiw4R0FBOEcsNEJBQTRCLDRCQUE0QixxREFBcUQsc0JBQXNCLHFCQUFxQixnQkFBZ0Isb0RBQW9ELHFCQUFxQixxQkFBcUIsY0FBYyx5QkFBeUIsMkNBQTJDLHdCQUF3QixrQ0FBa0MsT0FBTyxlQUFlLG9FQUFvRSxnREFBZ0QsdUJBQXVCLHdEQUF3RCx1RkFBdUYscURBQXFELGtEQUFrRCw0Q0FBNEMsc0lBQXNJLGlEQUFpRCwrRkFBK0YsMEJBQTBCLHlNQUF5TSwyQkFBMkIsU0FBUyxlQUFlLG1HQUFtRyxjQUFjLHlFQUF5RSwrQkFBK0IsZ0RBQWdELG1FQUFtRSxxQ0FBcUMsSUFBSSxrRkFBa0YsY0FBYyx1Q0FBdUMsOEJBQThCLDJCQUEyQiwyQkFBMkIsNEJBQTRCLHNDQUFzQyxPQUFPLFNBQVMsSUFBSSxpQkFBaUIsMkRBQTJELGlDQUFpQywyQ0FBMkMsaURBQWlELHlSQUF5UiwwQkFBMEIsZ0JBQWdCLHVDQUF1QyxxQ0FBcUMsbUJBQW1CLHFEQUFxRCx3QkFBd0IsY0FBYyx3QkFBd0IsNEZBQTRGLHlDQUF5QyxRQUFRLE9BQU8sOENBQThDLCtDQUErQyw2QkFBNkIsNERBQTRELGNBQWMsMkRBQTJELDZEQUE2RCxjQUFjLDZEQUE2RCxPQUFPLCtEQUErRCxrRUFBa0Usa0NBQWtDLHlDQUF5QyxRQUFRLE9BQU8sNEJBQTRCLG9GQUFvRixXQUFXLFdBQVcsOEZBQThGLCtCQUErQiwyR0FBMkcsc0NBQXNDLHFDQUFxQyw0TkFBNE4sK0JBQStCLHlDQUF5QyxRQUFRLE9BQU8sNEJBQTRCLGdHQUFnRyxnQ0FBZ0MseUNBQXlDLFFBQVEsT0FBTyw0QkFBNEIsc0JBQXNCLHNCQUFzQiwwQkFBMEIsZUFBZSxvQkFBb0IsY0FBYyx1Q0FBdUMsbURBQW1ELHlCQUF5QixnREFBZ0Qsa0RBQWtEO0FBQ24xUiw2RUFBNkUsTUFBTSwwQkFBMEIsMEJBQTBCLGdCQUFnQixlQUFlLFVBQVUsaUJBQWlCLGtCQUFrQixPQUFPO0FBQzFOLGlDQUFpQyxxQkFBcUIsbUNBQW1DLGdEQUFnRCxnQ0FBZ0Msd0JBQXdCLDBFQUEwRSx1QkFBdUIseUVBQXlFLG1CQUFtQjtBQUM5WDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsYUFBYSxpQkFBaUI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxlQUFlLGtCQUFrQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVhY3QtcGRmdG90ZXh0L2Rpc3QvaW5kZXguanM/YzhhNCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gX3R5cGVvZihvKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAobykgeyByZXR1cm4gdHlwZW9mIG87IH0gOiBmdW5jdGlvbiAobykgeyByZXR1cm4gbyAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgbyAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgbzsgfSwgX3R5cGVvZihvKTsgfVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gdm9pZCAwO1xudmFyIF9yZWFjdFBkZiA9IHJlcXVpcmUoXCJyZWFjdC1wZGZcIik7XG5mdW5jdGlvbiBfcmVnZW5lcmF0b3JSdW50aW1lKCkgeyBcInVzZSBzdHJpY3RcIjsgLyohIHJlZ2VuZXJhdG9yLXJ1bnRpbWUgLS0gQ29weXJpZ2h0IChjKSAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuIC0tIGxpY2Vuc2UgKE1JVCk6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWdlbmVyYXRvci9ibG9iL21haW4vTElDRU5TRSAqLyBfcmVnZW5lcmF0b3JSdW50aW1lID0gZnVuY3Rpb24gX3JlZ2VuZXJhdG9yUnVudGltZSgpIHsgcmV0dXJuIGU7IH07IHZhciB0LCBlID0ge30sIHIgPSBPYmplY3QucHJvdG90eXBlLCBuID0gci5oYXNPd25Qcm9wZXJ0eSwgbyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSB8fCBmdW5jdGlvbiAodCwgZSwgcikgeyB0W2VdID0gci52YWx1ZTsgfSwgaSA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sID8gU3ltYm9sIDoge30sIGEgPSBpLml0ZXJhdG9yIHx8IFwiQEBpdGVyYXRvclwiLCBjID0gaS5hc3luY0l0ZXJhdG9yIHx8IFwiQEBhc3luY0l0ZXJhdG9yXCIsIHUgPSBpLnRvU3RyaW5nVGFnIHx8IFwiQEB0b1N0cmluZ1RhZ1wiOyBmdW5jdGlvbiBkZWZpbmUodCwgZSwgcikgeyByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIGUsIHsgdmFsdWU6IHIsIGVudW1lcmFibGU6ICEwLCBjb25maWd1cmFibGU6ICEwLCB3cml0YWJsZTogITAgfSksIHRbZV07IH0gdHJ5IHsgZGVmaW5lKHt9LCBcIlwiKTsgfSBjYXRjaCAodCkgeyBkZWZpbmUgPSBmdW5jdGlvbiBkZWZpbmUodCwgZSwgcikgeyByZXR1cm4gdFtlXSA9IHI7IH07IH0gZnVuY3Rpb24gd3JhcCh0LCBlLCByLCBuKSB7IHZhciBpID0gZSAmJiBlLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvciA/IGUgOiBHZW5lcmF0b3IsIGEgPSBPYmplY3QuY3JlYXRlKGkucHJvdG90eXBlKSwgYyA9IG5ldyBDb250ZXh0KG4gfHwgW10pOyByZXR1cm4gbyhhLCBcIl9pbnZva2VcIiwgeyB2YWx1ZTogbWFrZUludm9rZU1ldGhvZCh0LCByLCBjKSB9KSwgYTsgfSBmdW5jdGlvbiB0cnlDYXRjaCh0LCBlLCByKSB7IHRyeSB7IHJldHVybiB7IHR5cGU6IFwibm9ybWFsXCIsIGFyZzogdC5jYWxsKGUsIHIpIH07IH0gY2F0Y2ggKHQpIHsgcmV0dXJuIHsgdHlwZTogXCJ0aHJvd1wiLCBhcmc6IHQgfTsgfSB9IGUud3JhcCA9IHdyYXA7IHZhciBoID0gXCJzdXNwZW5kZWRTdGFydFwiLCBsID0gXCJzdXNwZW5kZWRZaWVsZFwiLCBmID0gXCJleGVjdXRpbmdcIiwgcyA9IFwiY29tcGxldGVkXCIsIHkgPSB7fTsgZnVuY3Rpb24gR2VuZXJhdG9yKCkge30gZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb24oKSB7fSBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSgpIHt9IHZhciBwID0ge307IGRlZmluZShwLCBhLCBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9KTsgdmFyIGQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YsIHYgPSBkICYmIGQoZCh2YWx1ZXMoW10pKSk7IHYgJiYgdiAhPT0gciAmJiBuLmNhbGwodiwgYSkgJiYgKHAgPSB2KTsgdmFyIGcgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5wcm90b3R5cGUgPSBHZW5lcmF0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShwKTsgZnVuY3Rpb24gZGVmaW5lSXRlcmF0b3JNZXRob2RzKHQpIHsgW1wibmV4dFwiLCBcInRocm93XCIsIFwicmV0dXJuXCJdLmZvckVhY2goZnVuY3Rpb24gKGUpIHsgZGVmaW5lKHQsIGUsIGZ1bmN0aW9uICh0KSB7IHJldHVybiB0aGlzLl9pbnZva2UoZSwgdCk7IH0pOyB9KTsgfSBmdW5jdGlvbiBBc3luY0l0ZXJhdG9yKHQsIGUpIHsgZnVuY3Rpb24gaW52b2tlKHIsIG8sIGksIGEpIHsgdmFyIGMgPSB0cnlDYXRjaCh0W3JdLCB0LCBvKTsgaWYgKFwidGhyb3dcIiAhPT0gYy50eXBlKSB7IHZhciB1ID0gYy5hcmcsIGggPSB1LnZhbHVlOyByZXR1cm4gaCAmJiBcIm9iamVjdFwiID09IF90eXBlb2YoaCkgJiYgbi5jYWxsKGgsIFwiX19hd2FpdFwiKSA/IGUucmVzb2x2ZShoLl9fYXdhaXQpLnRoZW4oZnVuY3Rpb24gKHQpIHsgaW52b2tlKFwibmV4dFwiLCB0LCBpLCBhKTsgfSwgZnVuY3Rpb24gKHQpIHsgaW52b2tlKFwidGhyb3dcIiwgdCwgaSwgYSk7IH0pIDogZS5yZXNvbHZlKGgpLnRoZW4oZnVuY3Rpb24gKHQpIHsgdS52YWx1ZSA9IHQsIGkodSk7IH0sIGZ1bmN0aW9uICh0KSB7IHJldHVybiBpbnZva2UoXCJ0aHJvd1wiLCB0LCBpLCBhKTsgfSk7IH0gYShjLmFyZyk7IH0gdmFyIHI7IG8odGhpcywgXCJfaW52b2tlXCIsIHsgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKHQsIG4pIHsgZnVuY3Rpb24gY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKSB7IHJldHVybiBuZXcgZShmdW5jdGlvbiAoZSwgcikgeyBpbnZva2UodCwgbiwgZSwgcik7IH0pOyB9IHJldHVybiByID0gciA/IHIudGhlbihjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZywgY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcpIDogY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKTsgfSB9KTsgfSBmdW5jdGlvbiBtYWtlSW52b2tlTWV0aG9kKGUsIHIsIG4pIHsgdmFyIG8gPSBoOyByZXR1cm4gZnVuY3Rpb24gKGksIGEpIHsgaWYgKG8gPT09IGYpIHRocm93IEVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgcnVubmluZ1wiKTsgaWYgKG8gPT09IHMpIHsgaWYgKFwidGhyb3dcIiA9PT0gaSkgdGhyb3cgYTsgcmV0dXJuIHsgdmFsdWU6IHQsIGRvbmU6ICEwIH07IH0gZm9yIChuLm1ldGhvZCA9IGksIG4uYXJnID0gYTs7KSB7IHZhciBjID0gbi5kZWxlZ2F0ZTsgaWYgKGMpIHsgdmFyIHUgPSBtYXliZUludm9rZURlbGVnYXRlKGMsIG4pOyBpZiAodSkgeyBpZiAodSA9PT0geSkgY29udGludWU7IHJldHVybiB1OyB9IH0gaWYgKFwibmV4dFwiID09PSBuLm1ldGhvZCkgbi5zZW50ID0gbi5fc2VudCA9IG4uYXJnO2Vsc2UgaWYgKFwidGhyb3dcIiA9PT0gbi5tZXRob2QpIHsgaWYgKG8gPT09IGgpIHRocm93IG8gPSBzLCBuLmFyZzsgbi5kaXNwYXRjaEV4Y2VwdGlvbihuLmFyZyk7IH0gZWxzZSBcInJldHVyblwiID09PSBuLm1ldGhvZCAmJiBuLmFicnVwdChcInJldHVyblwiLCBuLmFyZyk7IG8gPSBmOyB2YXIgcCA9IHRyeUNhdGNoKGUsIHIsIG4pOyBpZiAoXCJub3JtYWxcIiA9PT0gcC50eXBlKSB7IGlmIChvID0gbi5kb25lID8gcyA6IGwsIHAuYXJnID09PSB5KSBjb250aW51ZTsgcmV0dXJuIHsgdmFsdWU6IHAuYXJnLCBkb25lOiBuLmRvbmUgfTsgfSBcInRocm93XCIgPT09IHAudHlwZSAmJiAobyA9IHMsIG4ubWV0aG9kID0gXCJ0aHJvd1wiLCBuLmFyZyA9IHAuYXJnKTsgfSB9OyB9IGZ1bmN0aW9uIG1heWJlSW52b2tlRGVsZWdhdGUoZSwgcikgeyB2YXIgbiA9IHIubWV0aG9kLCBvID0gZS5pdGVyYXRvcltuXTsgaWYgKG8gPT09IHQpIHJldHVybiByLmRlbGVnYXRlID0gbnVsbCwgXCJ0aHJvd1wiID09PSBuICYmIGUuaXRlcmF0b3JbXCJyZXR1cm5cIl0gJiYgKHIubWV0aG9kID0gXCJyZXR1cm5cIiwgci5hcmcgPSB0LCBtYXliZUludm9rZURlbGVnYXRlKGUsIHIpLCBcInRocm93XCIgPT09IHIubWV0aG9kKSB8fCBcInJldHVyblwiICE9PSBuICYmIChyLm1ldGhvZCA9IFwidGhyb3dcIiwgci5hcmcgPSBuZXcgVHlwZUVycm9yKFwiVGhlIGl0ZXJhdG9yIGRvZXMgbm90IHByb3ZpZGUgYSAnXCIgKyBuICsgXCInIG1ldGhvZFwiKSksIHk7IHZhciBpID0gdHJ5Q2F0Y2gobywgZS5pdGVyYXRvciwgci5hcmcpOyBpZiAoXCJ0aHJvd1wiID09PSBpLnR5cGUpIHJldHVybiByLm1ldGhvZCA9IFwidGhyb3dcIiwgci5hcmcgPSBpLmFyZywgci5kZWxlZ2F0ZSA9IG51bGwsIHk7IHZhciBhID0gaS5hcmc7IHJldHVybiBhID8gYS5kb25lID8gKHJbZS5yZXN1bHROYW1lXSA9IGEudmFsdWUsIHIubmV4dCA9IGUubmV4dExvYywgXCJyZXR1cm5cIiAhPT0gci5tZXRob2QgJiYgKHIubWV0aG9kID0gXCJuZXh0XCIsIHIuYXJnID0gdCksIHIuZGVsZWdhdGUgPSBudWxsLCB5KSA6IGEgOiAoci5tZXRob2QgPSBcInRocm93XCIsIHIuYXJnID0gbmV3IFR5cGVFcnJvcihcIml0ZXJhdG9yIHJlc3VsdCBpcyBub3QgYW4gb2JqZWN0XCIpLCByLmRlbGVnYXRlID0gbnVsbCwgeSk7IH0gZnVuY3Rpb24gcHVzaFRyeUVudHJ5KHQpIHsgdmFyIGUgPSB7IHRyeUxvYzogdFswXSB9OyAxIGluIHQgJiYgKGUuY2F0Y2hMb2MgPSB0WzFdKSwgMiBpbiB0ICYmIChlLmZpbmFsbHlMb2MgPSB0WzJdLCBlLmFmdGVyTG9jID0gdFszXSksIHRoaXMudHJ5RW50cmllcy5wdXNoKGUpOyB9IGZ1bmN0aW9uIHJlc2V0VHJ5RW50cnkodCkgeyB2YXIgZSA9IHQuY29tcGxldGlvbiB8fCB7fTsgZS50eXBlID0gXCJub3JtYWxcIiwgZGVsZXRlIGUuYXJnLCB0LmNvbXBsZXRpb24gPSBlOyB9IGZ1bmN0aW9uIENvbnRleHQodCkgeyB0aGlzLnRyeUVudHJpZXMgPSBbeyB0cnlMb2M6IFwicm9vdFwiIH1dLCB0LmZvckVhY2gocHVzaFRyeUVudHJ5LCB0aGlzKSwgdGhpcy5yZXNldCghMCk7IH0gZnVuY3Rpb24gdmFsdWVzKGUpIHsgaWYgKGUgfHwgXCJcIiA9PT0gZSkgeyB2YXIgciA9IGVbYV07IGlmIChyKSByZXR1cm4gci5jYWxsKGUpOyBpZiAoXCJmdW5jdGlvblwiID09IHR5cGVvZiBlLm5leHQpIHJldHVybiBlOyBpZiAoIWlzTmFOKGUubGVuZ3RoKSkgeyB2YXIgbyA9IC0xLCBpID0gZnVuY3Rpb24gbmV4dCgpIHsgZm9yICg7ICsrbyA8IGUubGVuZ3RoOykgaWYgKG4uY2FsbChlLCBvKSkgcmV0dXJuIG5leHQudmFsdWUgPSBlW29dLCBuZXh0LmRvbmUgPSAhMSwgbmV4dDsgcmV0dXJuIG5leHQudmFsdWUgPSB0LCBuZXh0LmRvbmUgPSAhMCwgbmV4dDsgfTsgcmV0dXJuIGkubmV4dCA9IGk7IH0gfSB0aHJvdyBuZXcgVHlwZUVycm9yKF90eXBlb2YoZSkgKyBcIiBpcyBub3QgaXRlcmFibGVcIik7IH0gcmV0dXJuIEdlbmVyYXRvckZ1bmN0aW9uLnByb3RvdHlwZSA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLCBvKGcsIFwiY29uc3RydWN0b3JcIiwgeyB2YWx1ZTogR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsIGNvbmZpZ3VyYWJsZTogITAgfSksIG8oR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsIFwiY29uc3RydWN0b3JcIiwgeyB2YWx1ZTogR2VuZXJhdG9yRnVuY3Rpb24sIGNvbmZpZ3VyYWJsZTogITAgfSksIEdlbmVyYXRvckZ1bmN0aW9uLmRpc3BsYXlOYW1lID0gZGVmaW5lKEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLCB1LCBcIkdlbmVyYXRvckZ1bmN0aW9uXCIpLCBlLmlzR2VuZXJhdG9yRnVuY3Rpb24gPSBmdW5jdGlvbiAodCkgeyB2YXIgZSA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgdCAmJiB0LmNvbnN0cnVjdG9yOyByZXR1cm4gISFlICYmIChlID09PSBHZW5lcmF0b3JGdW5jdGlvbiB8fCBcIkdlbmVyYXRvckZ1bmN0aW9uXCIgPT09IChlLmRpc3BsYXlOYW1lIHx8IGUubmFtZSkpOyB9LCBlLm1hcmsgPSBmdW5jdGlvbiAodCkgeyByZXR1cm4gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHQsIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKSA6ICh0Ll9fcHJvdG9fXyA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLCBkZWZpbmUodCwgdSwgXCJHZW5lcmF0b3JGdW5jdGlvblwiKSksIHQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShnKSwgdDsgfSwgZS5hd3JhcCA9IGZ1bmN0aW9uICh0KSB7IHJldHVybiB7IF9fYXdhaXQ6IHQgfTsgfSwgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEFzeW5jSXRlcmF0b3IucHJvdG90eXBlKSwgZGVmaW5lKEFzeW5jSXRlcmF0b3IucHJvdG90eXBlLCBjLCBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9KSwgZS5Bc3luY0l0ZXJhdG9yID0gQXN5bmNJdGVyYXRvciwgZS5hc3luYyA9IGZ1bmN0aW9uICh0LCByLCBuLCBvLCBpKSB7IHZvaWQgMCA9PT0gaSAmJiAoaSA9IFByb21pc2UpOyB2YXIgYSA9IG5ldyBBc3luY0l0ZXJhdG9yKHdyYXAodCwgciwgbiwgbyksIGkpOyByZXR1cm4gZS5pc0dlbmVyYXRvckZ1bmN0aW9uKHIpID8gYSA6IGEubmV4dCgpLnRoZW4oZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHQuZG9uZSA/IHQudmFsdWUgOiBhLm5leHQoKTsgfSk7IH0sIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhnKSwgZGVmaW5lKGcsIHUsIFwiR2VuZXJhdG9yXCIpLCBkZWZpbmUoZywgYSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSksIGRlZmluZShnLCBcInRvU3RyaW5nXCIsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIFwiW29iamVjdCBHZW5lcmF0b3JdXCI7IH0pLCBlLmtleXMgPSBmdW5jdGlvbiAodCkgeyB2YXIgZSA9IE9iamVjdCh0KSwgciA9IFtdOyBmb3IgKHZhciBuIGluIGUpIHIucHVzaChuKTsgcmV0dXJuIHIucmV2ZXJzZSgpLCBmdW5jdGlvbiBuZXh0KCkgeyBmb3IgKDsgci5sZW5ndGg7KSB7IHZhciB0ID0gci5wb3AoKTsgaWYgKHQgaW4gZSkgcmV0dXJuIG5leHQudmFsdWUgPSB0LCBuZXh0LmRvbmUgPSAhMSwgbmV4dDsgfSByZXR1cm4gbmV4dC5kb25lID0gITAsIG5leHQ7IH07IH0sIGUudmFsdWVzID0gdmFsdWVzLCBDb250ZXh0LnByb3RvdHlwZSA9IHsgY29uc3RydWN0b3I6IENvbnRleHQsIHJlc2V0OiBmdW5jdGlvbiByZXNldChlKSB7IGlmICh0aGlzLnByZXYgPSAwLCB0aGlzLm5leHQgPSAwLCB0aGlzLnNlbnQgPSB0aGlzLl9zZW50ID0gdCwgdGhpcy5kb25lID0gITEsIHRoaXMuZGVsZWdhdGUgPSBudWxsLCB0aGlzLm1ldGhvZCA9IFwibmV4dFwiLCB0aGlzLmFyZyA9IHQsIHRoaXMudHJ5RW50cmllcy5mb3JFYWNoKHJlc2V0VHJ5RW50cnkpLCAhZSkgZm9yICh2YXIgciBpbiB0aGlzKSBcInRcIiA9PT0gci5jaGFyQXQoMCkgJiYgbi5jYWxsKHRoaXMsIHIpICYmICFpc05hTigrci5zbGljZSgxKSkgJiYgKHRoaXNbcl0gPSB0KTsgfSwgc3RvcDogZnVuY3Rpb24gc3RvcCgpIHsgdGhpcy5kb25lID0gITA7IHZhciB0ID0gdGhpcy50cnlFbnRyaWVzWzBdLmNvbXBsZXRpb247IGlmIChcInRocm93XCIgPT09IHQudHlwZSkgdGhyb3cgdC5hcmc7IHJldHVybiB0aGlzLnJ2YWw7IH0sIGRpc3BhdGNoRXhjZXB0aW9uOiBmdW5jdGlvbiBkaXNwYXRjaEV4Y2VwdGlvbihlKSB7IGlmICh0aGlzLmRvbmUpIHRocm93IGU7IHZhciByID0gdGhpczsgZnVuY3Rpb24gaGFuZGxlKG4sIG8pIHsgcmV0dXJuIGEudHlwZSA9IFwidGhyb3dcIiwgYS5hcmcgPSBlLCByLm5leHQgPSBuLCBvICYmIChyLm1ldGhvZCA9IFwibmV4dFwiLCByLmFyZyA9IHQpLCAhIW87IH0gZm9yICh2YXIgbyA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBvID49IDA7IC0tbykgeyB2YXIgaSA9IHRoaXMudHJ5RW50cmllc1tvXSwgYSA9IGkuY29tcGxldGlvbjsgaWYgKFwicm9vdFwiID09PSBpLnRyeUxvYykgcmV0dXJuIGhhbmRsZShcImVuZFwiKTsgaWYgKGkudHJ5TG9jIDw9IHRoaXMucHJldikgeyB2YXIgYyA9IG4uY2FsbChpLCBcImNhdGNoTG9jXCIpLCB1ID0gbi5jYWxsKGksIFwiZmluYWxseUxvY1wiKTsgaWYgKGMgJiYgdSkgeyBpZiAodGhpcy5wcmV2IDwgaS5jYXRjaExvYykgcmV0dXJuIGhhbmRsZShpLmNhdGNoTG9jLCAhMCk7IGlmICh0aGlzLnByZXYgPCBpLmZpbmFsbHlMb2MpIHJldHVybiBoYW5kbGUoaS5maW5hbGx5TG9jKTsgfSBlbHNlIGlmIChjKSB7IGlmICh0aGlzLnByZXYgPCBpLmNhdGNoTG9jKSByZXR1cm4gaGFuZGxlKGkuY2F0Y2hMb2MsICEwKTsgfSBlbHNlIHsgaWYgKCF1KSB0aHJvdyBFcnJvcihcInRyeSBzdGF0ZW1lbnQgd2l0aG91dCBjYXRjaCBvciBmaW5hbGx5XCIpOyBpZiAodGhpcy5wcmV2IDwgaS5maW5hbGx5TG9jKSByZXR1cm4gaGFuZGxlKGkuZmluYWxseUxvYyk7IH0gfSB9IH0sIGFicnVwdDogZnVuY3Rpb24gYWJydXB0KHQsIGUpIHsgZm9yICh2YXIgciA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyByID49IDA7IC0tcikgeyB2YXIgbyA9IHRoaXMudHJ5RW50cmllc1tyXTsgaWYgKG8udHJ5TG9jIDw9IHRoaXMucHJldiAmJiBuLmNhbGwobywgXCJmaW5hbGx5TG9jXCIpICYmIHRoaXMucHJldiA8IG8uZmluYWxseUxvYykgeyB2YXIgaSA9IG87IGJyZWFrOyB9IH0gaSAmJiAoXCJicmVha1wiID09PSB0IHx8IFwiY29udGludWVcIiA9PT0gdCkgJiYgaS50cnlMb2MgPD0gZSAmJiBlIDw9IGkuZmluYWxseUxvYyAmJiAoaSA9IG51bGwpOyB2YXIgYSA9IGkgPyBpLmNvbXBsZXRpb24gOiB7fTsgcmV0dXJuIGEudHlwZSA9IHQsIGEuYXJnID0gZSwgaSA/ICh0aGlzLm1ldGhvZCA9IFwibmV4dFwiLCB0aGlzLm5leHQgPSBpLmZpbmFsbHlMb2MsIHkpIDogdGhpcy5jb21wbGV0ZShhKTsgfSwgY29tcGxldGU6IGZ1bmN0aW9uIGNvbXBsZXRlKHQsIGUpIHsgaWYgKFwidGhyb3dcIiA9PT0gdC50eXBlKSB0aHJvdyB0LmFyZzsgcmV0dXJuIFwiYnJlYWtcIiA9PT0gdC50eXBlIHx8IFwiY29udGludWVcIiA9PT0gdC50eXBlID8gdGhpcy5uZXh0ID0gdC5hcmcgOiBcInJldHVyblwiID09PSB0LnR5cGUgPyAodGhpcy5ydmFsID0gdGhpcy5hcmcgPSB0LmFyZywgdGhpcy5tZXRob2QgPSBcInJldHVyblwiLCB0aGlzLm5leHQgPSBcImVuZFwiKSA6IFwibm9ybWFsXCIgPT09IHQudHlwZSAmJiBlICYmICh0aGlzLm5leHQgPSBlKSwgeTsgfSwgZmluaXNoOiBmdW5jdGlvbiBmaW5pc2godCkgeyBmb3IgKHZhciBlID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGUgPj0gMDsgLS1lKSB7IHZhciByID0gdGhpcy50cnlFbnRyaWVzW2VdOyBpZiAoci5maW5hbGx5TG9jID09PSB0KSByZXR1cm4gdGhpcy5jb21wbGV0ZShyLmNvbXBsZXRpb24sIHIuYWZ0ZXJMb2MpLCByZXNldFRyeUVudHJ5KHIpLCB5OyB9IH0sIFwiY2F0Y2hcIjogZnVuY3Rpb24gX2NhdGNoKHQpIHsgZm9yICh2YXIgZSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBlID49IDA7IC0tZSkgeyB2YXIgciA9IHRoaXMudHJ5RW50cmllc1tlXTsgaWYgKHIudHJ5TG9jID09PSB0KSB7IHZhciBuID0gci5jb21wbGV0aW9uOyBpZiAoXCJ0aHJvd1wiID09PSBuLnR5cGUpIHsgdmFyIG8gPSBuLmFyZzsgcmVzZXRUcnlFbnRyeShyKTsgfSByZXR1cm4gbzsgfSB9IHRocm93IEVycm9yKFwiaWxsZWdhbCBjYXRjaCBhdHRlbXB0XCIpOyB9LCBkZWxlZ2F0ZVlpZWxkOiBmdW5jdGlvbiBkZWxlZ2F0ZVlpZWxkKGUsIHIsIG4pIHsgcmV0dXJuIHRoaXMuZGVsZWdhdGUgPSB7IGl0ZXJhdG9yOiB2YWx1ZXMoZSksIHJlc3VsdE5hbWU6IHIsIG5leHRMb2M6IG4gfSwgXCJuZXh0XCIgPT09IHRoaXMubWV0aG9kICYmICh0aGlzLmFyZyA9IHQpLCB5OyB9IH0sIGU7IH1cbmZ1bmN0aW9uIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywga2V5LCBhcmcpIHsgdHJ5IHsgdmFyIGluZm8gPSBnZW5ba2V5XShhcmcpOyB2YXIgdmFsdWUgPSBpbmZvLnZhbHVlOyB9IGNhdGNoIChlcnJvcikgeyByZWplY3QoZXJyb3IpOyByZXR1cm47IH0gaWYgKGluZm8uZG9uZSkgeyByZXNvbHZlKHZhbHVlKTsgfSBlbHNlIHsgUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKF9uZXh0LCBfdGhyb3cpOyB9IH1cbmZ1bmN0aW9uIF9hc3luY1RvR2VuZXJhdG9yKGZuKSB7IHJldHVybiBmdW5jdGlvbiAoKSB7IHZhciBzZWxmID0gdGhpcywgYXJncyA9IGFyZ3VtZW50czsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHsgdmFyIGdlbiA9IGZuLmFwcGx5KHNlbGYsIGFyZ3MpOyBmdW5jdGlvbiBfbmV4dCh2YWx1ZSkgeyBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIFwibmV4dFwiLCB2YWx1ZSk7IH0gZnVuY3Rpb24gX3Rocm93KGVycikgeyBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIFwidGhyb3dcIiwgZXJyKTsgfSBfbmV4dCh1bmRlZmluZWQpOyB9KTsgfTsgfVxuLy8gUGF0aCB0byB0aGUgcGRmLndvcmtlci5qcyBmaWxlXG5fcmVhY3RQZGYucGRmanMuR2xvYmFsV29ya2VyT3B0aW9ucy53b3JrZXJTcmMgPSBcIi8vY2RuanMuY2xvdWRmbGFyZS5jb20vYWpheC9saWJzL3BkZi5qcy9cIi5jb25jYXQoX3JlYWN0UGRmLnBkZmpzLnZlcnNpb24sIFwiL3BkZi53b3JrZXIuanNcIik7XG5cbi8qKlxyXG4gKiBFeHRyYWN0cyB0ZXh0IGNvbnRlbnQgZnJvbSBhIFBERiBmaWxlLlxyXG4gKiBAcGFyYW0ge0ZpbGV9IGZpbGUgLSBUaGUgUERGIGZpbGUgdG8gZXh0cmFjdCB0ZXh0IGZyb20uXHJcbiAqIEByZXR1cm5zIHtQcm9taXNlPHN0cmluZz59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIGV4dHJhY3RlZCB0ZXh0IGNvbnRlbnQuXHJcbiAqL1xudmFyIHBkZlRvVGV4dCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIHZhciBfcmVmID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlKGZpbGUpIHtcbiAgICB2YXIgYmxvYlVybCwgbG9hZGluZ1Rhc2ssIGV4dHJhY3RlZFRleHQsIGhhZFBhcnNpbmdFcnJvciwgcGRmLCBudW1QYWdlcywgcGFnZU51bWJlciwgcGFnZSwgdGV4dENvbnRlbnQsIHBhZ2VUZXh0O1xuICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgICAgd2hpbGUgKDEpIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIC8vIENyZWF0ZSBhIGJsb2IgVVJMIGZvciB0aGUgUERGIGZpbGVcbiAgICAgICAgICBibG9iVXJsID0gVVJMLmNyZWF0ZU9iamVjdFVSTChmaWxlKTsgLy8gTG9hZCB0aGUgUERGIGZpbGVcbiAgICAgICAgICBsb2FkaW5nVGFzayA9IF9yZWFjdFBkZi5wZGZqcy5nZXREb2N1bWVudChibG9iVXJsKTtcbiAgICAgICAgICBleHRyYWN0ZWRUZXh0ID0gXCJcIjtcbiAgICAgICAgICBoYWRQYXJzaW5nRXJyb3IgPSBmYWxzZTtcbiAgICAgICAgICBfY29udGV4dC5wcmV2ID0gNDtcbiAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNztcbiAgICAgICAgICByZXR1cm4gbG9hZGluZ1Rhc2sucHJvbWlzZTtcbiAgICAgICAgY2FzZSA3OlxuICAgICAgICAgIHBkZiA9IF9jb250ZXh0LnNlbnQ7XG4gICAgICAgICAgbnVtUGFnZXMgPSBwZGYubnVtUGFnZXM7IC8vIEl0ZXJhdGUgdGhyb3VnaCBlYWNoIHBhZ2UgYW5kIGV4dHJhY3QgdGV4dFxuICAgICAgICAgIHBhZ2VOdW1iZXIgPSAxO1xuICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgIGlmICghKHBhZ2VOdW1iZXIgPD0gbnVtUGFnZXMpKSB7XG4gICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMjI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgX2NvbnRleHQubmV4dCA9IDEzO1xuICAgICAgICAgIHJldHVybiBwZGYuZ2V0UGFnZShwYWdlTnVtYmVyKTtcbiAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICBwYWdlID0gX2NvbnRleHQuc2VudDtcbiAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTY7XG4gICAgICAgICAgcmV0dXJuIHBhZ2UuZ2V0VGV4dENvbnRlbnQoKTtcbiAgICAgICAgY2FzZSAxNjpcbiAgICAgICAgICB0ZXh0Q29udGVudCA9IF9jb250ZXh0LnNlbnQ7XG4gICAgICAgICAgcGFnZVRleHQgPSB0ZXh0Q29udGVudC5pdGVtcy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgIHJldHVybiBpdGVtLnN0cjtcbiAgICAgICAgICB9KS5qb2luKFwiIFwiKTtcbiAgICAgICAgICBleHRyYWN0ZWRUZXh0ICs9IHBhZ2VUZXh0O1xuICAgICAgICBjYXNlIDE5OlxuICAgICAgICAgIHBhZ2VOdW1iZXIrKztcbiAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjI6XG4gICAgICAgICAgX2NvbnRleHQubmV4dCA9IDI4O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI0OlxuICAgICAgICAgIF9jb250ZXh0LnByZXYgPSAyNDtcbiAgICAgICAgICBfY29udGV4dC50MCA9IF9jb250ZXh0W1wiY2F0Y2hcIl0oNCk7XG4gICAgICAgICAgaGFkUGFyc2luZ0Vycm9yID0gdHJ1ZTtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgZXh0cmFjdGluZyB0ZXh0IGZyb20gUERGOlwiLCBfY29udGV4dC50MCk7XG4gICAgICAgIGNhc2UgMjg6XG4gICAgICAgICAgLy8gQ2xlYW4gdXAgdGhlIGJsb2IgVVJMXG4gICAgICAgICAgVVJMLnJldm9rZU9iamVjdFVSTChibG9iVXJsKTtcblxuICAgICAgICAgIC8vIEZyZWUgbWVtb3J5IGZyb20gbG9hZGluZyB0YXNrXG4gICAgICAgICAgbG9hZGluZ1Rhc2suZGVzdHJveSgpO1xuICAgICAgICAgIGlmIChoYWRQYXJzaW5nRXJyb3IpIHtcbiAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAzMjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIGV4dHJhY3RlZFRleHQpO1xuICAgICAgICBjYXNlIDMyOlxuICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlLCBudWxsLCBbWzQsIDI0XV0pO1xuICB9KSk7XG4gIHJldHVybiBmdW5jdGlvbiBwZGZUb1RleHQoX3gpIHtcbiAgICByZXR1cm4gX3JlZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xufSgpO1xudmFyIF9kZWZhdWx0ID0gZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBwZGZUb1RleHQ7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-pdftotext/dist/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/tiny-invariant/dist/tiny-invariant.cjs.js":
/*!****************************************************************!*\
  !*** ./node_modules/tiny-invariant/dist/tiny-invariant.cjs.js ***!
  \****************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nvar isProduction = \"development\" === 'production';\nvar prefix = 'Invariant failed';\nfunction invariant(condition, message) {\n    if (condition) {\n        return;\n    }\n    if (isProduction) {\n        throw new Error(prefix);\n    }\n    var provided = typeof message === 'function' ? message() : message;\n    var value = provided ? \"\".concat(prefix, \": \").concat(provided) : prefix;\n    throw new Error(value);\n}\n\nmodule.exports = invariant;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90aW55LWludmFyaWFudC9kaXN0L3RpbnktaW52YXJpYW50LmNqcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixtQkFBbUIsYUFBb0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90aW55LWludmFyaWFudC9kaXN0L3RpbnktaW52YXJpYW50LmNqcy5qcz9lNWJkIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIGlzUHJvZHVjdGlvbiA9IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbic7XG52YXIgcHJlZml4ID0gJ0ludmFyaWFudCBmYWlsZWQnO1xuZnVuY3Rpb24gaW52YXJpYW50KGNvbmRpdGlvbiwgbWVzc2FnZSkge1xuICAgIGlmIChjb25kaXRpb24pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoaXNQcm9kdWN0aW9uKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihwcmVmaXgpO1xuICAgIH1cbiAgICB2YXIgcHJvdmlkZWQgPSB0eXBlb2YgbWVzc2FnZSA9PT0gJ2Z1bmN0aW9uJyA/IG1lc3NhZ2UoKSA6IG1lc3NhZ2U7XG4gICAgdmFyIHZhbHVlID0gcHJvdmlkZWQgPyBcIlwiLmNvbmNhdChwcmVmaXgsIFwiOiBcIikuY29uY2F0KHByb3ZpZGVkKSA6IHByZWZpeDtcbiAgICB0aHJvdyBuZXcgRXJyb3IodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGludmFyaWFudDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/tiny-invariant/dist/tiny-invariant.cjs.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/use-sync-external-store/cjs/use-sync-external-store-with-selector.development.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/use-sync-external-store/cjs/use-sync-external-store-with-selector.development.js ***!
  \*******************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * use-sync-external-store-with-selector.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nif (true) {\n  (function() {\n\n          'use strict';\n\n/* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\nif (\n  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' &&\n  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart ===\n    'function'\n) {\n  __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());\n}\n          var React = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n\n/**\n * inlined Object.is polyfill to avoid requiring consumers ship their own\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n */\nfunction is(x, y) {\n  return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y // eslint-disable-line no-self-compare\n  ;\n}\n\nvar objectIs = typeof Object.is === 'function' ? Object.is : is;\n\nvar useSyncExternalStore = React.useSyncExternalStore;\n\n// for CommonJS interop.\n\nvar useRef = React.useRef,\n    useEffect = React.useEffect,\n    useMemo = React.useMemo,\n    useDebugValue = React.useDebugValue; // Same as useSyncExternalStore, but supports selector and isEqual arguments.\n\nfunction useSyncExternalStoreWithSelector(subscribe, getSnapshot, getServerSnapshot, selector, isEqual) {\n  // Use this to track the rendered snapshot.\n  var instRef = useRef(null);\n  var inst;\n\n  if (instRef.current === null) {\n    inst = {\n      hasValue: false,\n      value: null\n    };\n    instRef.current = inst;\n  } else {\n    inst = instRef.current;\n  }\n\n  var _useMemo = useMemo(function () {\n    // Track the memoized state using closure variables that are local to this\n    // memoized instance of a getSnapshot function. Intentionally not using a\n    // useRef hook, because that state would be shared across all concurrent\n    // copies of the hook/component.\n    var hasMemo = false;\n    var memoizedSnapshot;\n    var memoizedSelection;\n\n    var memoizedSelector = function (nextSnapshot) {\n      if (!hasMemo) {\n        // The first time the hook is called, there is no memoized result.\n        hasMemo = true;\n        memoizedSnapshot = nextSnapshot;\n\n        var _nextSelection = selector(nextSnapshot);\n\n        if (isEqual !== undefined) {\n          // Even if the selector has changed, the currently rendered selection\n          // may be equal to the new selection. We should attempt to reuse the\n          // current value if possible, to preserve downstream memoizations.\n          if (inst.hasValue) {\n            var currentSelection = inst.value;\n\n            if (isEqual(currentSelection, _nextSelection)) {\n              memoizedSelection = currentSelection;\n              return currentSelection;\n            }\n          }\n        }\n\n        memoizedSelection = _nextSelection;\n        return _nextSelection;\n      } // We may be able to reuse the previous invocation's result.\n\n\n      // We may be able to reuse the previous invocation's result.\n      var prevSnapshot = memoizedSnapshot;\n      var prevSelection = memoizedSelection;\n\n      if (objectIs(prevSnapshot, nextSnapshot)) {\n        // The snapshot is the same as last time. Reuse the previous selection.\n        return prevSelection;\n      } // The snapshot has changed, so we need to compute a new selection.\n\n\n      // The snapshot has changed, so we need to compute a new selection.\n      var nextSelection = selector(nextSnapshot); // If a custom isEqual function is provided, use that to check if the data\n      // has changed. If it hasn't, return the previous selection. That signals\n      // to React that the selections are conceptually equal, and we can bail\n      // out of rendering.\n\n      // If a custom isEqual function is provided, use that to check if the data\n      // has changed. If it hasn't, return the previous selection. That signals\n      // to React that the selections are conceptually equal, and we can bail\n      // out of rendering.\n      if (isEqual !== undefined && isEqual(prevSelection, nextSelection)) {\n        return prevSelection;\n      }\n\n      memoizedSnapshot = nextSnapshot;\n      memoizedSelection = nextSelection;\n      return nextSelection;\n    }; // Assigning this to a constant so that Flow knows it can't change.\n\n\n    // Assigning this to a constant so that Flow knows it can't change.\n    var maybeGetServerSnapshot = getServerSnapshot === undefined ? null : getServerSnapshot;\n\n    var getSnapshotWithSelector = function () {\n      return memoizedSelector(getSnapshot());\n    };\n\n    var getServerSnapshotWithSelector = maybeGetServerSnapshot === null ? undefined : function () {\n      return memoizedSelector(maybeGetServerSnapshot());\n    };\n    return [getSnapshotWithSelector, getServerSnapshotWithSelector];\n  }, [getSnapshot, getServerSnapshot, selector, isEqual]),\n      getSelection = _useMemo[0],\n      getServerSelection = _useMemo[1];\n\n  var value = useSyncExternalStore(subscribe, getSelection, getServerSelection);\n  useEffect(function () {\n    inst.hasValue = true;\n    inst.value = value;\n  }, [value]);\n  useDebugValue(value);\n  return value;\n}\n\nexports.useSyncExternalStoreWithSelector = useSyncExternalStoreWithSelector;\n          /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\nif (\n  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' &&\n  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop ===\n    'function'\n) {\n  __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());\n}\n        \n  })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy91c2Utc3luYy1leHRlcm5hbC1zdG9yZS9janMvdXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUtd2l0aC1zZWxlY3Rvci5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsSUFBSSxJQUFxQztBQUN6Qzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG1CQUFPLENBQUMsbUZBQU87O0FBRXJDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUNBQXlDOztBQUV6QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTs7O0FBR1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7OztBQUdSO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOzs7QUFHUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy91c2Utc3luYy1leHRlcm5hbC1zdG9yZS9janMvdXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUtd2l0aC1zZWxlY3Rvci5kZXZlbG9wbWVudC5qcz83NzQ1Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2UgUmVhY3RcbiAqIHVzZS1zeW5jLWV4dGVybmFsLXN0b3JlLXdpdGgtc2VsZWN0b3IuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgKGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgJ3VzZSBzdHJpY3QnO1xuXG4vKiBnbG9iYWwgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fICovXG5pZiAoXG4gIHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gIT09ICd1bmRlZmluZWQnICYmXG4gIHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18ucmVnaXN0ZXJJbnRlcm5hbE1vZHVsZVN0YXJ0ID09PVxuICAgICdmdW5jdGlvbidcbikge1xuICBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18ucmVnaXN0ZXJJbnRlcm5hbE1vZHVsZVN0YXJ0KG5ldyBFcnJvcigpKTtcbn1cbiAgICAgICAgICB2YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG4vKipcbiAqIGlubGluZWQgT2JqZWN0LmlzIHBvbHlmaWxsIHRvIGF2b2lkIHJlcXVpcmluZyBjb25zdW1lcnMgc2hpcCB0aGVpciBvd25cbiAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9pc1xuICovXG5mdW5jdGlvbiBpcyh4LCB5KSB7XG4gIHJldHVybiB4ID09PSB5ICYmICh4ICE9PSAwIHx8IDEgLyB4ID09PSAxIC8geSkgfHwgeCAhPT0geCAmJiB5ICE9PSB5IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gIDtcbn1cblxudmFyIG9iamVjdElzID0gdHlwZW9mIE9iamVjdC5pcyA9PT0gJ2Z1bmN0aW9uJyA/IE9iamVjdC5pcyA6IGlzO1xuXG52YXIgdXNlU3luY0V4dGVybmFsU3RvcmUgPSBSZWFjdC51c2VTeW5jRXh0ZXJuYWxTdG9yZTtcblxuLy8gZm9yIENvbW1vbkpTIGludGVyb3AuXG5cbnZhciB1c2VSZWYgPSBSZWFjdC51c2VSZWYsXG4gICAgdXNlRWZmZWN0ID0gUmVhY3QudXNlRWZmZWN0LFxuICAgIHVzZU1lbW8gPSBSZWFjdC51c2VNZW1vLFxuICAgIHVzZURlYnVnVmFsdWUgPSBSZWFjdC51c2VEZWJ1Z1ZhbHVlOyAvLyBTYW1lIGFzIHVzZVN5bmNFeHRlcm5hbFN0b3JlLCBidXQgc3VwcG9ydHMgc2VsZWN0b3IgYW5kIGlzRXF1YWwgYXJndW1lbnRzLlxuXG5mdW5jdGlvbiB1c2VTeW5jRXh0ZXJuYWxTdG9yZVdpdGhTZWxlY3RvcihzdWJzY3JpYmUsIGdldFNuYXBzaG90LCBnZXRTZXJ2ZXJTbmFwc2hvdCwgc2VsZWN0b3IsIGlzRXF1YWwpIHtcbiAgLy8gVXNlIHRoaXMgdG8gdHJhY2sgdGhlIHJlbmRlcmVkIHNuYXBzaG90LlxuICB2YXIgaW5zdFJlZiA9IHVzZVJlZihudWxsKTtcbiAgdmFyIGluc3Q7XG5cbiAgaWYgKGluc3RSZWYuY3VycmVudCA9PT0gbnVsbCkge1xuICAgIGluc3QgPSB7XG4gICAgICBoYXNWYWx1ZTogZmFsc2UsXG4gICAgICB2YWx1ZTogbnVsbFxuICAgIH07XG4gICAgaW5zdFJlZi5jdXJyZW50ID0gaW5zdDtcbiAgfSBlbHNlIHtcbiAgICBpbnN0ID0gaW5zdFJlZi5jdXJyZW50O1xuICB9XG5cbiAgdmFyIF91c2VNZW1vID0gdXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgLy8gVHJhY2sgdGhlIG1lbW9pemVkIHN0YXRlIHVzaW5nIGNsb3N1cmUgdmFyaWFibGVzIHRoYXQgYXJlIGxvY2FsIHRvIHRoaXNcbiAgICAvLyBtZW1vaXplZCBpbnN0YW5jZSBvZiBhIGdldFNuYXBzaG90IGZ1bmN0aW9uLiBJbnRlbnRpb25hbGx5IG5vdCB1c2luZyBhXG4gICAgLy8gdXNlUmVmIGhvb2ssIGJlY2F1c2UgdGhhdCBzdGF0ZSB3b3VsZCBiZSBzaGFyZWQgYWNyb3NzIGFsbCBjb25jdXJyZW50XG4gICAgLy8gY29waWVzIG9mIHRoZSBob29rL2NvbXBvbmVudC5cbiAgICB2YXIgaGFzTWVtbyA9IGZhbHNlO1xuICAgIHZhciBtZW1vaXplZFNuYXBzaG90O1xuICAgIHZhciBtZW1vaXplZFNlbGVjdGlvbjtcblxuICAgIHZhciBtZW1vaXplZFNlbGVjdG9yID0gZnVuY3Rpb24gKG5leHRTbmFwc2hvdCkge1xuICAgICAgaWYgKCFoYXNNZW1vKSB7XG4gICAgICAgIC8vIFRoZSBmaXJzdCB0aW1lIHRoZSBob29rIGlzIGNhbGxlZCwgdGhlcmUgaXMgbm8gbWVtb2l6ZWQgcmVzdWx0LlxuICAgICAgICBoYXNNZW1vID0gdHJ1ZTtcbiAgICAgICAgbWVtb2l6ZWRTbmFwc2hvdCA9IG5leHRTbmFwc2hvdDtcblxuICAgICAgICB2YXIgX25leHRTZWxlY3Rpb24gPSBzZWxlY3RvcihuZXh0U25hcHNob3QpO1xuXG4gICAgICAgIGlmIChpc0VxdWFsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyBFdmVuIGlmIHRoZSBzZWxlY3RvciBoYXMgY2hhbmdlZCwgdGhlIGN1cnJlbnRseSByZW5kZXJlZCBzZWxlY3Rpb25cbiAgICAgICAgICAvLyBtYXkgYmUgZXF1YWwgdG8gdGhlIG5ldyBzZWxlY3Rpb24uIFdlIHNob3VsZCBhdHRlbXB0IHRvIHJldXNlIHRoZVxuICAgICAgICAgIC8vIGN1cnJlbnQgdmFsdWUgaWYgcG9zc2libGUsIHRvIHByZXNlcnZlIGRvd25zdHJlYW0gbWVtb2l6YXRpb25zLlxuICAgICAgICAgIGlmIChpbnN0Lmhhc1ZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgY3VycmVudFNlbGVjdGlvbiA9IGluc3QudmFsdWU7XG5cbiAgICAgICAgICAgIGlmIChpc0VxdWFsKGN1cnJlbnRTZWxlY3Rpb24sIF9uZXh0U2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgICBtZW1vaXplZFNlbGVjdGlvbiA9IGN1cnJlbnRTZWxlY3Rpb247XG4gICAgICAgICAgICAgIHJldHVybiBjdXJyZW50U2VsZWN0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIG1lbW9pemVkU2VsZWN0aW9uID0gX25leHRTZWxlY3Rpb247XG4gICAgICAgIHJldHVybiBfbmV4dFNlbGVjdGlvbjtcbiAgICAgIH0gLy8gV2UgbWF5IGJlIGFibGUgdG8gcmV1c2UgdGhlIHByZXZpb3VzIGludm9jYXRpb24ncyByZXN1bHQuXG5cblxuICAgICAgLy8gV2UgbWF5IGJlIGFibGUgdG8gcmV1c2UgdGhlIHByZXZpb3VzIGludm9jYXRpb24ncyByZXN1bHQuXG4gICAgICB2YXIgcHJldlNuYXBzaG90ID0gbWVtb2l6ZWRTbmFwc2hvdDtcbiAgICAgIHZhciBwcmV2U2VsZWN0aW9uID0gbWVtb2l6ZWRTZWxlY3Rpb247XG5cbiAgICAgIGlmIChvYmplY3RJcyhwcmV2U25hcHNob3QsIG5leHRTbmFwc2hvdCkpIHtcbiAgICAgICAgLy8gVGhlIHNuYXBzaG90IGlzIHRoZSBzYW1lIGFzIGxhc3QgdGltZS4gUmV1c2UgdGhlIHByZXZpb3VzIHNlbGVjdGlvbi5cbiAgICAgICAgcmV0dXJuIHByZXZTZWxlY3Rpb247XG4gICAgICB9IC8vIFRoZSBzbmFwc2hvdCBoYXMgY2hhbmdlZCwgc28gd2UgbmVlZCB0byBjb21wdXRlIGEgbmV3IHNlbGVjdGlvbi5cblxuXG4gICAgICAvLyBUaGUgc25hcHNob3QgaGFzIGNoYW5nZWQsIHNvIHdlIG5lZWQgdG8gY29tcHV0ZSBhIG5ldyBzZWxlY3Rpb24uXG4gICAgICB2YXIgbmV4dFNlbGVjdGlvbiA9IHNlbGVjdG9yKG5leHRTbmFwc2hvdCk7IC8vIElmIGEgY3VzdG9tIGlzRXF1YWwgZnVuY3Rpb24gaXMgcHJvdmlkZWQsIHVzZSB0aGF0IHRvIGNoZWNrIGlmIHRoZSBkYXRhXG4gICAgICAvLyBoYXMgY2hhbmdlZC4gSWYgaXQgaGFzbid0LCByZXR1cm4gdGhlIHByZXZpb3VzIHNlbGVjdGlvbi4gVGhhdCBzaWduYWxzXG4gICAgICAvLyB0byBSZWFjdCB0aGF0IHRoZSBzZWxlY3Rpb25zIGFyZSBjb25jZXB0dWFsbHkgZXF1YWwsIGFuZCB3ZSBjYW4gYmFpbFxuICAgICAgLy8gb3V0IG9mIHJlbmRlcmluZy5cblxuICAgICAgLy8gSWYgYSBjdXN0b20gaXNFcXVhbCBmdW5jdGlvbiBpcyBwcm92aWRlZCwgdXNlIHRoYXQgdG8gY2hlY2sgaWYgdGhlIGRhdGFcbiAgICAgIC8vIGhhcyBjaGFuZ2VkLiBJZiBpdCBoYXNuJ3QsIHJldHVybiB0aGUgcHJldmlvdXMgc2VsZWN0aW9uLiBUaGF0IHNpZ25hbHNcbiAgICAgIC8vIHRvIFJlYWN0IHRoYXQgdGhlIHNlbGVjdGlvbnMgYXJlIGNvbmNlcHR1YWxseSBlcXVhbCwgYW5kIHdlIGNhbiBiYWlsXG4gICAgICAvLyBvdXQgb2YgcmVuZGVyaW5nLlxuICAgICAgaWYgKGlzRXF1YWwgIT09IHVuZGVmaW5lZCAmJiBpc0VxdWFsKHByZXZTZWxlY3Rpb24sIG5leHRTZWxlY3Rpb24pKSB7XG4gICAgICAgIHJldHVybiBwcmV2U2VsZWN0aW9uO1xuICAgICAgfVxuXG4gICAgICBtZW1vaXplZFNuYXBzaG90ID0gbmV4dFNuYXBzaG90O1xuICAgICAgbWVtb2l6ZWRTZWxlY3Rpb24gPSBuZXh0U2VsZWN0aW9uO1xuICAgICAgcmV0dXJuIG5leHRTZWxlY3Rpb247XG4gICAgfTsgLy8gQXNzaWduaW5nIHRoaXMgdG8gYSBjb25zdGFudCBzbyB0aGF0IEZsb3cga25vd3MgaXQgY2FuJ3QgY2hhbmdlLlxuXG5cbiAgICAvLyBBc3NpZ25pbmcgdGhpcyB0byBhIGNvbnN0YW50IHNvIHRoYXQgRmxvdyBrbm93cyBpdCBjYW4ndCBjaGFuZ2UuXG4gICAgdmFyIG1heWJlR2V0U2VydmVyU25hcHNob3QgPSBnZXRTZXJ2ZXJTbmFwc2hvdCA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGdldFNlcnZlclNuYXBzaG90O1xuXG4gICAgdmFyIGdldFNuYXBzaG90V2l0aFNlbGVjdG9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG1lbW9pemVkU2VsZWN0b3IoZ2V0U25hcHNob3QoKSk7XG4gICAgfTtcblxuICAgIHZhciBnZXRTZXJ2ZXJTbmFwc2hvdFdpdGhTZWxlY3RvciA9IG1heWJlR2V0U2VydmVyU25hcHNob3QgPT09IG51bGwgPyB1bmRlZmluZWQgOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gbWVtb2l6ZWRTZWxlY3RvcihtYXliZUdldFNlcnZlclNuYXBzaG90KCkpO1xuICAgIH07XG4gICAgcmV0dXJuIFtnZXRTbmFwc2hvdFdpdGhTZWxlY3RvciwgZ2V0U2VydmVyU25hcHNob3RXaXRoU2VsZWN0b3JdO1xuICB9LCBbZ2V0U25hcHNob3QsIGdldFNlcnZlclNuYXBzaG90LCBzZWxlY3RvciwgaXNFcXVhbF0pLFxuICAgICAgZ2V0U2VsZWN0aW9uID0gX3VzZU1lbW9bMF0sXG4gICAgICBnZXRTZXJ2ZXJTZWxlY3Rpb24gPSBfdXNlTWVtb1sxXTtcblxuICB2YXIgdmFsdWUgPSB1c2VTeW5jRXh0ZXJuYWxTdG9yZShzdWJzY3JpYmUsIGdldFNlbGVjdGlvbiwgZ2V0U2VydmVyU2VsZWN0aW9uKTtcbiAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICBpbnN0Lmhhc1ZhbHVlID0gdHJ1ZTtcbiAgICBpbnN0LnZhbHVlID0gdmFsdWU7XG4gIH0sIFt2YWx1ZV0pO1xuICB1c2VEZWJ1Z1ZhbHVlKHZhbHVlKTtcbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5leHBvcnRzLnVzZVN5bmNFeHRlcm5hbFN0b3JlV2l0aFNlbGVjdG9yID0gdXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3I7XG4gICAgICAgICAgLyogZ2xvYmFsIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyAqL1xuaWYgKFxuICB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fICE9PSAndW5kZWZpbmVkJyAmJlxuICB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLnJlZ2lzdGVySW50ZXJuYWxNb2R1bGVTdG9wID09PVxuICAgICdmdW5jdGlvbidcbikge1xuICBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18ucmVnaXN0ZXJJbnRlcm5hbE1vZHVsZVN0b3AobmV3IEVycm9yKCkpO1xufVxuICAgICAgICBcbiAgfSkoKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/use-sync-external-store/cjs/use-sync-external-store-with-selector.development.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/use-sync-external-store/with-selector.js":
/*!***************************************************************!*\
  !*** ./node_modules/use-sync-external-store/with-selector.js ***!
  \***************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/use-sync-external-store-with-selector.development.js */ \"(app-pages-browser)/./node_modules/use-sync-external-store/cjs/use-sync-external-store-with-selector.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy91c2Utc3luYy1leHRlcm5hbC1zdG9yZS93aXRoLXNlbGVjdG9yLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLElBQUksS0FBcUMsRUFBRSxFQUUxQyxDQUFDO0FBQ0YsRUFBRSw2TkFBc0Y7QUFDeEYiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3VzZS1zeW5jLWV4dGVybmFsLXN0b3JlL3dpdGgtc2VsZWN0b3IuanM/OTMxMyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvdXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUtd2l0aC1zZWxlY3Rvci5wcm9kdWN0aW9uLm1pbi5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy91c2Utc3luYy1leHRlcm5hbC1zdG9yZS13aXRoLXNlbGVjdG9yLmRldmVsb3BtZW50LmpzJyk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/use-sync-external-store/with-selector.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/warning/warning.js":
/*!*****************************************!*\
  !*** ./node_modules/warning/warning.js ***!
  \*****************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\n/**\n * Similar to invariant but only logs a warning if the condition is not met.\n * This can be used to log issues in development environments in critical\n * paths. Removing the logging code for production environments will keep the\n * same logic and follow the same code paths.\n */\n\nvar __DEV__ = \"development\" !== 'production';\n\nvar warning = function() {};\n\nif (__DEV__) {\n  var printWarning = function printWarning(format, args) {\n    var len = arguments.length;\n    args = new Array(len > 1 ? len - 1 : 0);\n    for (var key = 1; key < len; key++) {\n      args[key - 1] = arguments[key];\n    }\n    var argIndex = 0;\n    var message = 'Warning: ' +\n      format.replace(/%s/g, function() {\n        return args[argIndex++];\n      });\n    if (typeof console !== 'undefined') {\n      console.error(message);\n    }\n    try {\n      // --- Welcome to debugging React ---\n      // This error was thrown as a convenience so that you can use this stack\n      // to find the callsite that caused this warning to fire.\n      throw new Error(message);\n    } catch (x) {}\n  }\n\n  warning = function(condition, format, args) {\n    var len = arguments.length;\n    args = new Array(len > 2 ? len - 2 : 0);\n    for (var key = 2; key < len; key++) {\n      args[key - 2] = arguments[key];\n    }\n    if (format === undefined) {\n      throw new Error(\n          '`warning(condition, format, ...args)` requires a warning ' +\n          'message argument'\n      );\n    }\n    if (!condition) {\n      printWarning.apply(null, [format].concat(args));\n    }\n  };\n}\n\nmodule.exports = warning;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy93YXJuaW5nL3dhcm5pbmcuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjLGFBQW9COztBQUVsQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixXQUFXO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixXQUFXO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy93YXJuaW5nL3dhcm5pbmcuanM/MjM3MSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBTaW1pbGFyIHRvIGludmFyaWFudCBidXQgb25seSBsb2dzIGEgd2FybmluZyBpZiB0aGUgY29uZGl0aW9uIGlzIG5vdCBtZXQuXG4gKiBUaGlzIGNhbiBiZSB1c2VkIHRvIGxvZyBpc3N1ZXMgaW4gZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnRzIGluIGNyaXRpY2FsXG4gKiBwYXRocy4gUmVtb3ZpbmcgdGhlIGxvZ2dpbmcgY29kZSBmb3IgcHJvZHVjdGlvbiBlbnZpcm9ubWVudHMgd2lsbCBrZWVwIHRoZVxuICogc2FtZSBsb2dpYyBhbmQgZm9sbG93IHRoZSBzYW1lIGNvZGUgcGF0aHMuXG4gKi9cblxudmFyIF9fREVWX18gPSBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nO1xuXG52YXIgd2FybmluZyA9IGZ1bmN0aW9uKCkge307XG5cbmlmIChfX0RFVl9fKSB7XG4gIHZhciBwcmludFdhcm5pbmcgPSBmdW5jdGlvbiBwcmludFdhcm5pbmcoZm9ybWF0LCBhcmdzKSB7XG4gICAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgYXJncyA9IG5ldyBBcnJheShsZW4gPiAxID8gbGVuIC0gMSA6IDApO1xuICAgIGZvciAodmFyIGtleSA9IDE7IGtleSA8IGxlbjsga2V5KyspIHtcbiAgICAgIGFyZ3Nba2V5IC0gMV0gPSBhcmd1bWVudHNba2V5XTtcbiAgICB9XG4gICAgdmFyIGFyZ0luZGV4ID0gMDtcbiAgICB2YXIgbWVzc2FnZSA9ICdXYXJuaW5nOiAnICtcbiAgICAgIGZvcm1hdC5yZXBsYWNlKC8lcy9nLCBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGFyZ3NbYXJnSW5kZXgrK107XG4gICAgICB9KTtcbiAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgLy8gLS0tIFdlbGNvbWUgdG8gZGVidWdnaW5nIFJlYWN0IC0tLVxuICAgICAgLy8gVGhpcyBlcnJvciB3YXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28gdGhhdCB5b3UgY2FuIHVzZSB0aGlzIHN0YWNrXG4gICAgICAvLyB0byBmaW5kIHRoZSBjYWxsc2l0ZSB0aGF0IGNhdXNlZCB0aGlzIHdhcm5pbmcgdG8gZmlyZS5cbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICB9IGNhdGNoICh4KSB7fVxuICB9XG5cbiAgd2FybmluZyA9IGZ1bmN0aW9uKGNvbmRpdGlvbiwgZm9ybWF0LCBhcmdzKSB7XG4gICAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgYXJncyA9IG5ldyBBcnJheShsZW4gPiAyID8gbGVuIC0gMiA6IDApO1xuICAgIGZvciAodmFyIGtleSA9IDI7IGtleSA8IGxlbjsga2V5KyspIHtcbiAgICAgIGFyZ3Nba2V5IC0gMl0gPSBhcmd1bWVudHNba2V5XTtcbiAgICB9XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgJ2B3YXJuaW5nKGNvbmRpdGlvbiwgZm9ybWF0LCAuLi5hcmdzKWAgcmVxdWlyZXMgYSB3YXJuaW5nICcgK1xuICAgICAgICAgICdtZXNzYWdlIGFyZ3VtZW50J1xuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKCFjb25kaXRpb24pIHtcbiAgICAgIHByaW50V2FybmluZy5hcHBseShudWxsLCBbZm9ybWF0XS5jb25jYXQoYXJncykpO1xuICAgIH1cbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB3YXJuaW5nO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/warning/warning.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./app/page.tsx":
/*!**********************!*\
  !*** ./app/page.tsx ***!
  \**********************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Home; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var next_navigation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/navigation */ \"(app-pages-browser)/./node_modules/next/dist/api/navigation.js\");\n/* harmony import */ var _components_PatentCard__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/components/PatentCard */ \"(app-pages-browser)/./components/PatentCard.tsx\");\n/* harmony import */ var _barrel_optimize_names_Download_lucide_react__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! __barrel_optimize__?names=Download!=!lucide-react */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/download.js\");\n/* harmony import */ var _components_modals_SavePatent__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/components/modals/SavePatent */ \"(app-pages-browser)/./components/modals/SavePatent.tsx\");\n/* harmony import */ var react_pdftotext__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! react-pdftotext */ \"(app-pages-browser)/./node_modules/react-pdftotext/dist/index.js\");\n/* harmony import */ var _lib_hooks__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../lib/hooks */ \"(app-pages-browser)/./lib/hooks.tsx\");\n/* harmony import */ var _lib_features_analyzeSlice__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../lib/features/analyzeSlice */ \"(app-pages-browser)/./lib/features/analyzeSlice.tsx\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\n\n\n\n\n\n\nfunction Home() {\n    _s();\n    const [uploadedFile, setUploadedFile] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)();\n    const [uploadedFileName, setUploadedFileName] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)();\n    const [isModalVisible, setIsModalVisible] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const router = (0,next_navigation__WEBPACK_IMPORTED_MODULE_2__.useRouter)();\n    const dispatch = (0,_lib_hooks__WEBPACK_IMPORTED_MODULE_6__.useAppDispatch)();\n    const data = (0,_lib_hooks__WEBPACK_IMPORTED_MODULE_6__.useAppSelector)(_lib_features_analyzeSlice__WEBPACK_IMPORTED_MODULE_7__.patents);\n    const handleUpload = (event)=>{\n        const file = event.target.files[0];\n        if (file) {\n            setUploadedFileName(file.name);\n            setUploadedFile(file);\n            setIsModalVisible(true); // Trigger the modal\n        }\n    };\n    function dropHandler(ev) {\n        console.log(\"File(s) dropped\");\n        // Prevent default behavior (Prevent file from being opened)\n        ev.preventDefault();\n        if (ev.dataTransfer.items) {\n            // Use DataTransferItemList interface to access the file(s)\n            [\n                ...ev.dataTransfer.items\n            ].forEach((item, i)=>{\n                // If dropped items aren't files, reject them\n                if (item.kind === \"file\") {\n                    const file = item.getAsFile();\n                    console.log(\" file[\".concat(i, \"].name = \").concat(file.name));\n                    setIsModalVisible(true); // Show the modal\n                }\n            });\n        } else {\n            // Use DataTransfer interface to access the file(s)\n            [\n                ...ev.dataTransfer.files\n            ].forEach((file, i)=>{\n                console.log(\" file[\".concat(i, \"].name = \").concat(file.name));\n                setUploadedFileName(file.name);\n                setUploadedFile(file);\n                setIsModalVisible(true); // Show the modal\n            });\n        }\n    }\n    function dragOverHandler(ev) {\n        console.log(\"File(s) in drop zone\");\n        ev.preventDefault();\n    }\n    async function storeNewPatent(url, patent_text) {\n        const summary_text = await getSummary(patent_text, true);\n        const uploadedPatent = {\n            title: \"\",\n            folder: \"\",\n            date: \"\",\n            tags: [],\n            status: \"\",\n            patentId: \"\",\n            url: url,\n            problem: \"\",\n            problemKeywords: [],\n            solution: \"\",\n            solutionKeywords: [],\n            summary: summary_text,\n            fulltext: patent_text\n        };\n        dispatch((0,_lib_features_analyzeSlice__WEBPACK_IMPORTED_MODULE_7__.storeFile)(uploadedPatent));\n    }\n    async function getSummary(patent_text) {\n        let dummy = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;\n        if (dummy) {\n            return \"bruh\";\n        }\n        const response = await fetch(\"https://noggin.rea.gent/unaware-narwhal-7693\", {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\",\n                Authorization: \"Bearer rg_v1_j0rj8cvquknfvmazs4itkskl736tclt8xc1j_ngk\"\n            },\n            body: JSON.stringify({\n                // replace \"bruh\" with patent_text\n                \"patent\": patent_text\n            })\n        }).then((response)=>response.text());\n        return response;\n    }\n    async function storePatent(info) {\n        dispatch((0,_lib_features_analyzeSlice__WEBPACK_IMPORTED_MODULE_7__.storeFile)(info));\n    }\n    function goToPatent(url, patent_text) {\n        storeNewPatent(url, patent_text).then(function(value) {\n            router.push(\"/patent\");\n        }, function(error) {\n            console.log(error);\n        });\n    }\n    function goToRecent(info) {\n        storePatent(info).then(function(value) {\n            router.push(\"/patent\");\n        }, function(error) {\n            console.log(error);\n        });\n    }\n    function analyzePatent() {\n        let patent_text = \"\";\n        if (uploadedFile) {\n            const url = URL.createObjectURL(uploadedFile);\n            (0,react_pdftotext__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(uploadedFile).then((text)=>{\n                patent_text = text;\n                console.log(text);\n            }).catch((error)=>console.error(\"Failed to extract text from pdf\"));\n            goToPatent(url, patent_text);\n        }\n    }\n    function renderPatentCard(entry) {\n        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_PatentCard__WEBPACK_IMPORTED_MODULE_3__[\"default\"], {\n            info: entry,\n            onClick: ()=>goToRecent(entry)\n        }, void 0, false, {\n            fileName: \"/Users/martinlacsamana/Documents/160/project/patent-analyzer/app/page.tsx\",\n            lineNumber: 143,\n            columnNumber: 7\n        }, this);\n    }\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"flex justify-center items-center pt-[24px]\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"main\", {\n                className: \"w-3/4 mt-10\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                        className: \"text-xl font-normal leading-9\",\n                        children: [\n                            \"Hi, \",\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                className: \"text-custom-blue\",\n                                children: \"researcher 102-6\"\n                            }, void 0, false, {\n                                fileName: \"/Users/martinlacsamana/Documents/160/project/patent-analyzer/app/page.tsx\",\n                                lineNumber: 154,\n                                columnNumber: 58\n                            }, this),\n                            \". Welcome back to your AI patent workspace.\"\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Users/martinlacsamana/Documents/160/project/patent-analyzer/app/page.tsx\",\n                        lineNumber: 154,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                        className: \"text-sm font-normal leading-6 pt-[6px]\",\n                        children: \"Simply upload a patent document and let our AI analyze the data in seconds. Uncover valuable insights to drive your innovation work.\"\n                    }, void 0, false, {\n                        fileName: \"/Users/martinlacsamana/Documents/160/project/patent-analyzer/app/page.tsx\",\n                        lineNumber: 155,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                        className: \"text-xl font-normal leading-9 pt-[24px] pb-[12px]\",\n                        children: \"Read a new patent\"\n                    }, void 0, false, {\n                        fileName: \"/Users/martinlacsamana/Documents/160/project/patent-analyzer/app/page.tsx\",\n                        lineNumber: 158,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"flex flex-col h-[230px] items-center justify-center shrink-0 rounded-lg border border-[#DAE5EA] bg-white\",\n                        style: {\n                            boxShadow: \"0px 1px 10px 0px rgba(0, 0, 0, 0.10)\"\n                        },\n                        id: \"drop_zone\",\n                        onDrop: dropHandler,\n                        onDragOver: dragOverHandler,\n                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"flex flex-col justify-center items-center\",\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    className: \"flex space-x-2\",\n                                    children: [\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                            className: \"bg-custom-blue rounded-full p-1\",\n                                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Download_lucide_react__WEBPACK_IMPORTED_MODULE_8__[\"default\"], {\n                                                size: 18,\n                                                color: \"#ffffff\"\n                                            }, void 0, false, {\n                                                fileName: \"/Users/martinlacsamana/Documents/160/project/patent-analyzer/app/page.tsx\",\n                                                lineNumber: 167,\n                                                columnNumber: 17\n                                            }, this)\n                                        }, void 0, false, {\n                                            fileName: \"/Users/martinlacsamana/Documents/160/project/patent-analyzer/app/page.tsx\",\n                                            lineNumber: 166,\n                                            columnNumber: 15\n                                        }, this),\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                            className: \"text-xl font-normal whitespace-nowrap\",\n                                            children: \"Upload or drop a file\"\n                                        }, void 0, false, {\n                                            fileName: \"/Users/martinlacsamana/Documents/160/project/patent-analyzer/app/page.tsx\",\n                                            lineNumber: 169,\n                                            columnNumber: 15\n                                        }, this)\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"/Users/martinlacsamana/Documents/160/project/patent-analyzer/app/page.tsx\",\n                                    lineNumber: 165,\n                                    columnNumber: 13\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                                    id: \"upload\",\n                                    className: \"text-sm cursor-pointer w-52\",\n                                    type: \"file\",\n                                    onChange: handleUpload\n                                }, void 0, false, {\n                                    fileName: \"/Users/martinlacsamana/Documents/160/project/patent-analyzer/app/page.tsx\",\n                                    lineNumber: 172,\n                                    columnNumber: 13\n                                }, this)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"/Users/martinlacsamana/Documents/160/project/patent-analyzer/app/page.tsx\",\n                            lineNumber: 164,\n                            columnNumber: 11\n                        }, this)\n                    }, void 0, false, {\n                        fileName: \"/Users/martinlacsamana/Documents/160/project/patent-analyzer/app/page.tsx\",\n                        lineNumber: 159,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                        className: \"text-xl font-normal leading-9 pt-[24px] pb-[12px]\",\n                        children: \"Recent History\"\n                    }, void 0, false, {\n                        fileName: \"/Users/martinlacsamana/Documents/160/project/patent-analyzer/app/page.tsx\",\n                        lineNumber: 187,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"flex justify-center w-full space-x-4 pb-10\",\n                        children: data.map((patent)=>renderPatentCard(patent))\n                    }, void 0, false, {\n                        fileName: \"/Users/martinlacsamana/Documents/160/project/patent-analyzer/app/page.tsx\",\n                        lineNumber: 188,\n                        columnNumber: 9\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/martinlacsamana/Documents/160/project/patent-analyzer/app/page.tsx\",\n                lineNumber: 152,\n                columnNumber: 7\n            }, this),\n            isModalVisible && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"fixed inset-0 bg-black bg-opacity-50 flex justify-center items-center z-40\",\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_modals_SavePatent__WEBPACK_IMPORTED_MODULE_4__[\"default\"], {\n                    title: uploadedFileName,\n                    onClose: ()=>setIsModalVisible(false),\n                    analyzePatent: analyzePatent\n                }, void 0, false, {\n                    fileName: \"/Users/martinlacsamana/Documents/160/project/patent-analyzer/app/page.tsx\",\n                    lineNumber: 198,\n                    columnNumber: 9\n                }, this)\n            }, void 0, false, {\n                fileName: \"/Users/martinlacsamana/Documents/160/project/patent-analyzer/app/page.tsx\",\n                lineNumber: 197,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/martinlacsamana/Documents/160/project/patent-analyzer/app/page.tsx\",\n        lineNumber: 151,\n        columnNumber: 5\n    }, this);\n}\n_s(Home, \"Hododk2maiQresjviYc/lGL4y74=\", false, function() {\n    return [\n        next_navigation__WEBPACK_IMPORTED_MODULE_2__.useRouter,\n        _lib_hooks__WEBPACK_IMPORTED_MODULE_6__.useAppDispatch,\n        _lib_hooks__WEBPACK_IMPORTED_MODULE_6__.useAppSelector\n    ];\n});\n_c = Home;\nvar _c;\n$RefreshReg$(_c, \"Home\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9wYWdlLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBQzhDO0FBQ0o7QUFDTztBQUlMO0FBQ1k7QUFDaEI7QUFDcUI7QUFHeEI7QUFHdEIsU0FBU1U7O0lBRXRCLE1BQU0sQ0FBQ0MsY0FBY0MsZ0JBQWdCLEdBQUdaLCtDQUFRQTtJQUNoRCxNQUFNLENBQUNhLGtCQUFrQkMsb0JBQW9CLEdBQUdkLCtDQUFRQTtJQUN4RCxNQUFNLENBQUNlLGdCQUFnQkMsa0JBQWtCLEdBQUdoQiwrQ0FBUUEsQ0FBQztJQUNyRCxNQUFNaUIsU0FBU2hCLDBEQUFTQTtJQUN4QixNQUFNaUIsV0FBV1gsMERBQWNBO0lBQy9CLE1BQU1ZLE9BQU9iLDBEQUFjQSxDQUFDRywrREFBT0E7SUFFbkMsTUFBTVcsZUFBZSxDQUFDQztRQUNwQixNQUFNQyxPQUFPRCxNQUFNRSxNQUFNLENBQUNDLEtBQUssQ0FBQyxFQUFFO1FBQ2xDLElBQUlGLE1BQU07WUFDUlIsb0JBQW9CUSxLQUFLRyxJQUFJO1lBQzdCYixnQkFBZ0JVO1lBQ2hCTixrQkFBa0IsT0FBTyxvQkFBb0I7UUFDL0M7SUFDRjtJQUVBLFNBQVNVLFlBQVlDLEVBQThFO1FBQ2pHQyxRQUFRQyxHQUFHLENBQUM7UUFFWiw0REFBNEQ7UUFDNURGLEdBQUdHLGNBQWM7UUFFakIsSUFBSUgsR0FBR0ksWUFBWSxDQUFDQyxLQUFLLEVBQUU7WUFDekIsMkRBQTJEO1lBQzNEO21CQUFJTCxHQUFHSSxZQUFZLENBQUNDLEtBQUs7YUFBQyxDQUFDQyxPQUFPLENBQUMsQ0FBQ0MsTUFBTUM7Z0JBQ3hDLDZDQUE2QztnQkFDN0MsSUFBSUQsS0FBS0UsSUFBSSxLQUFLLFFBQVE7b0JBQ3hCLE1BQU1kLE9BQU9ZLEtBQUtHLFNBQVM7b0JBQzNCVCxRQUFRQyxHQUFHLENBQUMsVUFBdUJQLE9BQWJhLEdBQUUsYUFBcUIsT0FBVmIsS0FBS0csSUFBSTtvQkFDNUNULGtCQUFrQixPQUFPLGlCQUFpQjtnQkFDNUM7WUFDRjtRQUNGLE9BQU87WUFDTCxtREFBbUQ7WUFDbkQ7bUJBQUlXLEdBQUdJLFlBQVksQ0FBQ1AsS0FBSzthQUFDLENBQUNTLE9BQU8sQ0FBQyxDQUFDWCxNQUFNYTtnQkFDeENQLFFBQVFDLEdBQUcsQ0FBQyxVQUF1QlAsT0FBYmEsR0FBRSxhQUFxQixPQUFWYixLQUFLRyxJQUFJO2dCQUM1Q1gsb0JBQW9CUSxLQUFLRyxJQUFJO2dCQUM3QmIsZ0JBQWdCVTtnQkFDaEJOLGtCQUFrQixPQUFPLGlCQUFpQjtZQUM1QztRQUNGO0lBQ0Y7SUFFQSxTQUFTc0IsZ0JBQWdCWCxFQUFtQztRQUMxREMsUUFBUUMsR0FBRyxDQUFDO1FBQ1pGLEdBQUdHLGNBQWM7SUFDbkI7SUFFQSxlQUFlUyxlQUFlQyxHQUFXLEVBQUVDLFdBQW1CO1FBQzVELE1BQU1DLGVBQWUsTUFBTUMsV0FBV0YsYUFBYTtRQUNuRCxNQUFNRyxpQkFBaUI7WUFDckJDLE9BQU87WUFDUEMsUUFBUTtZQUNSQyxNQUFNO1lBQ05DLE1BQU0sRUFBRTtZQUNSQyxRQUFRO1lBQ1JDLFVBQVU7WUFDVlYsS0FBS0E7WUFDTFcsU0FBUztZQUNUQyxpQkFBaUIsRUFBRTtZQUNuQkMsVUFBVTtZQUNWQyxrQkFBa0IsRUFBRTtZQUNwQkMsU0FBU2I7WUFDVGMsVUFBVWY7UUFDWjtRQUNBdkIsU0FBU1YscUVBQVNBLENBQUNvQztJQUNyQjtJQUVBLGVBQWVELFdBQVdGLFdBQW1CO1lBQUVnQixRQUFBQSxpRUFBZTtRQUM1RCxJQUFJQSxPQUFNO1lBQ1IsT0FBTztRQUNUO1FBQ0EsTUFBTUMsV0FBVyxNQUFNQyxNQUNyQixnREFDQTtZQUNFQyxRQUFRO1lBQ1JDLFNBQVM7Z0JBQ1AsZ0JBQWdCO2dCQUNoQkMsZUFBZTtZQUNqQjtZQUNBQyxNQUFNQyxLQUFLQyxTQUFTLENBQUM7Z0JBQ25CLGtDQUFrQztnQkFDbEMsVUFBVXhCO1lBQ1o7UUFDRixHQUNBeUIsSUFBSSxDQUFDUixDQUFBQSxXQUFZQSxTQUFTUyxJQUFJO1FBQ2hDLE9BQU9UO0lBQ1Q7SUFHQSxlQUFlVSxZQUFZQyxJQUFlO1FBQ3hDbkQsU0FBU1YscUVBQVNBLENBQUM2RDtJQUNyQjtJQUVBLFNBQVNDLFdBQVc5QixHQUFVLEVBQUVDLFdBQWtCO1FBQ2hERixlQUFlQyxLQUFLQyxhQUFheUIsSUFBSSxDQUNuQyxTQUFTSyxLQUFLO1lBQUd0RCxPQUFPdUQsSUFBSSxDQUFDO1FBQVcsR0FDeEMsU0FBU0MsS0FBSztZQUFHN0MsUUFBUUMsR0FBRyxDQUFDNEM7UUFBTztJQUV4QztJQUVBLFNBQVNDLFdBQVdMLElBQWU7UUFDakNELFlBQVlDLE1BQU1ILElBQUksQ0FDcEIsU0FBU0ssS0FBSztZQUFHdEQsT0FBT3VELElBQUksQ0FBQztRQUFXLEdBQ3hDLFNBQVNDLEtBQUs7WUFBRzdDLFFBQVFDLEdBQUcsQ0FBQzRDO1FBQU87SUFFeEM7SUFFQSxTQUFTRTtRQUNQLElBQUlsQyxjQUFzQjtRQUMxQixJQUFJOUIsY0FBYztZQUNoQixNQUFNNkIsTUFBTW9DLElBQUlDLGVBQWUsQ0FBQ2xFO1lBQ2hDTiwyREFBU0EsQ0FBQ00sY0FDUHVELElBQUksQ0FBQyxDQUFDQztnQkFDTDFCLGNBQWMwQjtnQkFDZHZDLFFBQVFDLEdBQUcsQ0FBQ3NDO1lBQ2QsR0FDQ1csS0FBSyxDQUFDLENBQUNMLFFBQWlCN0MsUUFBUTZDLEtBQUssQ0FBQztZQUN6Q0gsV0FBVzlCLEtBQUtDO1FBQ2xCO0lBQ0Y7SUFFQSxTQUFTc0MsaUJBQWlCQyxLQUFnQjtRQUN4QyxxQkFDRSw4REFBQzlFLDhEQUFVQTtZQUNUbUUsTUFBTVc7WUFDTkMsU0FBUyxJQUFNUCxXQUFXTTs7Ozs7O0lBRWhDO0lBRUEscUJBRUUsOERBQUNFO1FBQUlDLFdBQVU7OzBCQUNiLDhEQUFDQztnQkFBS0QsV0FBVTs7a0NBRWQsOERBQUNFO3dCQUFFRixXQUFVOzs0QkFBZ0M7MENBQUksOERBQUNHO2dDQUFLSCxXQUFVOzBDQUFtQjs7Ozs7OzRCQUF1Qjs7Ozs7OztrQ0FDM0csOERBQUNFO3dCQUFFRixXQUFVO2tDQUF5Qzs7Ozs7O2tDQUd0RCw4REFBQ0U7d0JBQUVGLFdBQVU7a0NBQW9EOzs7Ozs7a0NBQ2pFLDhEQUFDRDt3QkFDQ0MsV0FBVTt3QkFDVkksT0FBTzs0QkFBRUMsV0FBVzt3QkFBdUM7d0JBQzNEQyxJQUFHO3dCQUFZQyxRQUFRaEU7d0JBQWFpRSxZQUFZckQ7a0NBRWhELDRFQUFDNEM7NEJBQUlDLFdBQVU7OzhDQUNiLDhEQUFDRDtvQ0FBSUMsV0FBVTs7c0RBQ2IsOERBQUNEOzRDQUFJQyxXQUFVO3NEQUNiLDRFQUFDaEYsb0ZBQVFBO2dEQUFDeUYsTUFBTTtnREFBSUMsT0FBTTs7Ozs7Ozs7Ozs7c0RBRTVCLDhEQUFDUjs0Q0FBRUYsV0FBVTtzREFBd0M7Ozs7Ozs7Ozs7Ozs4Q0FHdkQsOERBQUNXO29DQUNHTCxJQUFHO29DQUNITixXQUFVO29DQUNWWSxNQUFLO29DQUNMQyxVQUFVNUU7Ozs7Ozs7Ozs7Ozs7Ozs7O2tDQVdsQiw4REFBQ2lFO3dCQUFFRixXQUFVO2tDQUFvRDs7Ozs7O2tDQUNqRSw4REFBQ0Q7d0JBQUlDLFdBQVU7a0NBRVpoRSxLQUFLOEUsR0FBRyxDQUFDLENBQUNDLFNBQVduQixpQkFBaUJtQjs7Ozs7Ozs7Ozs7O1lBTTFDbkYsZ0NBQ0QsOERBQUNtRTtnQkFBSUMsV0FBVTswQkFDYiw0RUFBQy9FLHFFQUFVQTtvQkFBQ3lDLE9BQU9oQztvQkFBa0JzRixTQUFTLElBQU1uRixrQkFBa0I7b0JBQVEyRCxlQUFlQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFNckc7R0EzTHdCakU7O1FBS1BULHNEQUFTQTtRQUNQTSxzREFBY0E7UUFDbEJELHNEQUFjQTs7O0tBUExJIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2FwcC9wYWdlLnRzeD83NjAzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50JztcbmltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7dXNlUm91dGVyfSBmcm9tICduZXh0L25hdmlnYXRpb24nO1xuaW1wb3J0IFBhdGVudENhcmQgZnJvbSBcIkAvY29tcG9uZW50cy9QYXRlbnRDYXJkXCI7XG5pbXBvcnQgUGF0ZW50SW5mbyBmcm9tIFwiQC9jb21wb25lbnRzL1BhdGVudEluZm9cIjtcbmltcG9ydCBQYXRlbnRVcGxvYWQgZnJvbSBcIkAvY29tcG9uZW50cy9QYXRlbnRVcGxvYWRcIjtcbmltcG9ydCBQYXRlbnRVcGxvYWRMb2FkaW5nIGZyb20gXCJAL2NvbXBvbmVudHMvUGF0ZW50VXBsb2FkTG9hZGluZ1wiO1xuaW1wb3J0IHtEb3dubG9hZCwgTGluazJ9IGZyb20gJ2x1Y2lkZS1yZWFjdCdcbmltcG9ydCBTYXZlUGF0ZW50IGZyb20gJ0AvY29tcG9uZW50cy9tb2RhbHMvU2F2ZVBhdGVudCc7XG5pbXBvcnQgcGRmVG9UZXh0IGZyb20gXCJyZWFjdC1wZGZ0b3RleHRcIjtcbmltcG9ydCB7IHVzZUFwcFNlbGVjdG9yLCB1c2VBcHBEaXNwYXRjaCB9IGZyb20gJy4uL2xpYi9ob29rcydcbmltcG9ydCB7XG4gIHN0b3JlRmlsZSwgcGF0ZW50c1xufSBmcm9tICcuLi9saWIvZmVhdHVyZXMvYW5hbHl6ZVNsaWNlJ1xuXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEhvbWUoKSB7XG5cbiAgY29uc3QgW3VwbG9hZGVkRmlsZSwgc2V0VXBsb2FkZWRGaWxlXSA9IHVzZVN0YXRlPEZpbGU+KCk7XG4gIGNvbnN0IFt1cGxvYWRlZEZpbGVOYW1lLCBzZXRVcGxvYWRlZEZpbGVOYW1lXSA9IHVzZVN0YXRlPHN0cmluZz4oKTtcbiAgY29uc3QgW2lzTW9kYWxWaXNpYmxlLCBzZXRJc01vZGFsVmlzaWJsZV0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IHJvdXRlciA9IHVzZVJvdXRlcigpO1xuICBjb25zdCBkaXNwYXRjaCA9IHVzZUFwcERpc3BhdGNoKCk7XG4gIGNvbnN0IGRhdGEgPSB1c2VBcHBTZWxlY3RvcihwYXRlbnRzKTtcblxuICBjb25zdCBoYW5kbGVVcGxvYWQgPSAoZXZlbnQ6IHsgdGFyZ2V0OiB7IGZpbGVzOiBhbnk7IH07IH0pID0+IHtcbiAgICBjb25zdCBmaWxlID0gZXZlbnQudGFyZ2V0LmZpbGVzWzBdO1xuICAgIGlmIChmaWxlKSB7XG4gICAgICBzZXRVcGxvYWRlZEZpbGVOYW1lKGZpbGUubmFtZSk7XG4gICAgICBzZXRVcGxvYWRlZEZpbGUoZmlsZSk7XG4gICAgICBzZXRJc01vZGFsVmlzaWJsZSh0cnVlKTsgLy8gVHJpZ2dlciB0aGUgbW9kYWxcbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gZHJvcEhhbmRsZXIoZXY6IHsgcHJldmVudERlZmF1bHQ6ICgpID0+IHZvaWQ7IGRhdGFUcmFuc2ZlcjogeyBpdGVtczogYW55OyBmaWxlczogYW55OyB9OyB9KSB7XG4gICAgY29uc29sZS5sb2coXCJGaWxlKHMpIGRyb3BwZWRcIik7XG4gIFxuICAgIC8vIFByZXZlbnQgZGVmYXVsdCBiZWhhdmlvciAoUHJldmVudCBmaWxlIGZyb20gYmVpbmcgb3BlbmVkKVxuICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gIFxuICAgIGlmIChldi5kYXRhVHJhbnNmZXIuaXRlbXMpIHtcbiAgICAgIC8vIFVzZSBEYXRhVHJhbnNmZXJJdGVtTGlzdCBpbnRlcmZhY2UgdG8gYWNjZXNzIHRoZSBmaWxlKHMpXG4gICAgICBbLi4uZXYuZGF0YVRyYW5zZmVyLml0ZW1zXS5mb3JFYWNoKChpdGVtLCBpKSA9PiB7XG4gICAgICAgIC8vIElmIGRyb3BwZWQgaXRlbXMgYXJlbid0IGZpbGVzLCByZWplY3QgdGhlbVxuICAgICAgICBpZiAoaXRlbS5raW5kID09PSBcImZpbGVcIikge1xuICAgICAgICAgIGNvbnN0IGZpbGUgPSBpdGVtLmdldEFzRmlsZSgpO1xuICAgICAgICAgIGNvbnNvbGUubG9nKGDigKYgZmlsZVske2l9XS5uYW1lID0gJHtmaWxlLm5hbWV9YCk7XG4gICAgICAgICAgc2V0SXNNb2RhbFZpc2libGUodHJ1ZSk7IC8vIFNob3cgdGhlIG1vZGFsXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBVc2UgRGF0YVRyYW5zZmVyIGludGVyZmFjZSB0byBhY2Nlc3MgdGhlIGZpbGUocylcbiAgICAgIFsuLi5ldi5kYXRhVHJhbnNmZXIuZmlsZXNdLmZvckVhY2goKGZpbGUsIGkpID0+IHtcbiAgICAgICAgY29uc29sZS5sb2coYOKApiBmaWxlWyR7aX1dLm5hbWUgPSAke2ZpbGUubmFtZX1gKTtcbiAgICAgICAgc2V0VXBsb2FkZWRGaWxlTmFtZShmaWxlLm5hbWUpO1xuICAgICAgICBzZXRVcGxvYWRlZEZpbGUoZmlsZSk7XG4gICAgICAgIHNldElzTW9kYWxWaXNpYmxlKHRydWUpOyAvLyBTaG93IHRoZSBtb2RhbFxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZHJhZ092ZXJIYW5kbGVyKGV2OiB7IHByZXZlbnREZWZhdWx0OiAoKSA9PiB2b2lkOyB9KSB7XG4gICAgY29uc29sZS5sb2coXCJGaWxlKHMpIGluIGRyb3Agem9uZVwiKTtcbiAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICB9XG5cbiAgYXN5bmMgZnVuY3Rpb24gc3RvcmVOZXdQYXRlbnQodXJsOiBzdHJpbmcsIHBhdGVudF90ZXh0OiBzdHJpbmcpIHtcbiAgICBjb25zdCBzdW1tYXJ5X3RleHQgPSBhd2FpdCBnZXRTdW1tYXJ5KHBhdGVudF90ZXh0LCB0cnVlKTtcbiAgICBjb25zdCB1cGxvYWRlZFBhdGVudCA9IHtcbiAgICAgIHRpdGxlOiBcIlwiLFxuICAgICAgZm9sZGVyOiBcIlwiLFxuICAgICAgZGF0ZTogXCJcIixcbiAgICAgIHRhZ3M6IFtdLFxuICAgICAgc3RhdHVzOiBcIlwiLFxuICAgICAgcGF0ZW50SWQ6IFwiXCIsXG4gICAgICB1cmw6IHVybCxcbiAgICAgIHByb2JsZW06IFwiXCIsXG4gICAgICBwcm9ibGVtS2V5d29yZHM6IFtdLFxuICAgICAgc29sdXRpb246IFwiXCIsXG4gICAgICBzb2x1dGlvbktleXdvcmRzOiBbXSxcbiAgICAgIHN1bW1hcnk6IHN1bW1hcnlfdGV4dCxcbiAgICAgIGZ1bGx0ZXh0OiBwYXRlbnRfdGV4dCxcbiAgICB9XG4gICAgZGlzcGF0Y2goc3RvcmVGaWxlKHVwbG9hZGVkUGF0ZW50KSk7XG4gIH1cblxuICBhc3luYyBmdW5jdGlvbiBnZXRTdW1tYXJ5KHBhdGVudF90ZXh0OiBzdHJpbmcsIGR1bW15OiBib29sZWFuPWZhbHNlKSB7XG4gICAgaWYgKGR1bW15KXtcbiAgICAgIHJldHVybiBcImJydWhcIjtcbiAgICB9XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChcbiAgICAgICdodHRwczovL25vZ2dpbi5yZWEuZ2VudC91bmF3YXJlLW5hcndoYWwtNzY5MycsXG4gICAgICB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICBBdXRob3JpemF0aW9uOiAnQmVhcmVyIHJnX3YxX2owcmo4Y3ZxdWtuZnZtYXpzNGl0a3NrbDczNnRjbHQ4eGMxal9uZ2snLFxuICAgICAgICB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgLy8gcmVwbGFjZSBcImJydWhcIiB3aXRoIHBhdGVudF90ZXh0XG4gICAgICAgICAgXCJwYXRlbnRcIjogcGF0ZW50X3RleHQsXG4gICAgICAgIH0pLFxuICAgICAgfVxuICAgICkudGhlbihyZXNwb25zZSA9PiByZXNwb25zZS50ZXh0KCkpO1xuICAgIHJldHVybiByZXNwb25zZTtcbiAgfVxuXG5cbiAgYXN5bmMgZnVuY3Rpb24gc3RvcmVQYXRlbnQoaW5mbzpQYXRlbnRJbmZvKSB7XG4gICAgZGlzcGF0Y2goc3RvcmVGaWxlKGluZm8pKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdvVG9QYXRlbnQodXJsOnN0cmluZywgcGF0ZW50X3RleHQ6c3RyaW5nKSB7XG4gICAgc3RvcmVOZXdQYXRlbnQodXJsLCBwYXRlbnRfdGV4dCkudGhlbihcbiAgICAgIGZ1bmN0aW9uKHZhbHVlKSB7cm91dGVyLnB1c2goJy9wYXRlbnQnKTt9LFxuICAgICAgZnVuY3Rpb24oZXJyb3IpIHtjb25zb2xlLmxvZyhlcnJvcik7fVxuICAgIClcbiAgfVxuXG4gIGZ1bmN0aW9uIGdvVG9SZWNlbnQoaW5mbzpQYXRlbnRJbmZvKSB7XG4gICAgc3RvcmVQYXRlbnQoaW5mbykudGhlbihcbiAgICAgIGZ1bmN0aW9uKHZhbHVlKSB7cm91dGVyLnB1c2goJy9wYXRlbnQnKTt9LFxuICAgICAgZnVuY3Rpb24oZXJyb3IpIHtjb25zb2xlLmxvZyhlcnJvcik7fVxuICAgIClcbiAgfVxuICBcbiAgZnVuY3Rpb24gYW5hbHl6ZVBhdGVudCgpIHtcbiAgICBsZXQgcGF0ZW50X3RleHQ6IHN0cmluZyA9IFwiXCI7XG4gICAgaWYgKHVwbG9hZGVkRmlsZSkge1xuICAgICAgY29uc3QgdXJsID0gVVJMLmNyZWF0ZU9iamVjdFVSTCh1cGxvYWRlZEZpbGUpO1xuICAgICAgcGRmVG9UZXh0KHVwbG9hZGVkRmlsZSlcbiAgICAgICAgLnRoZW4oKHRleHQ6IHN0cmluZykgPT4ge1xuICAgICAgICAgIHBhdGVudF90ZXh0ID0gdGV4dDtcbiAgICAgICAgICBjb25zb2xlLmxvZyh0ZXh0KTtcbiAgICAgICAgfSlcbiAgICAgICAgLmNhdGNoKChlcnJvcjogRXJyb3IpID0+IGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gZXh0cmFjdCB0ZXh0IGZyb20gcGRmXCIpKTtcbiAgICAgIGdvVG9QYXRlbnQodXJsLCBwYXRlbnRfdGV4dCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVuZGVyUGF0ZW50Q2FyZChlbnRyeTpQYXRlbnRJbmZvKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxQYXRlbnRDYXJkXG4gICAgICAgIGluZm89e2VudHJ5fVxuICAgICAgICBvbkNsaWNrPXsoKSA9PiBnb1RvUmVjZW50KGVudHJ5KX1cbiAgICAgIC8+KTtcbiAgfVxuXG4gIHJldHVybiAoXG4gICAgXG4gICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGp1c3RpZnktY2VudGVyIGl0ZW1zLWNlbnRlciBwdC1bMjRweF1cIj5cbiAgICAgIDxtYWluIGNsYXNzTmFtZT1cInctMy80IG10LTEwXCI+XG4gICAgICAgIHsvKiBIZWFkZXIgdGV4dCAqL31cbiAgICAgICAgPHAgY2xhc3NOYW1lPVwidGV4dC14bCBmb250LW5vcm1hbCBsZWFkaW5nLTlcIj5IaSwgPHNwYW4gY2xhc3NOYW1lPVwidGV4dC1jdXN0b20tYmx1ZVwiPnJlc2VhcmNoZXIgMTAyLTY8L3NwYW4+LiBXZWxjb21lIGJhY2sgdG8geW91ciBBSSBwYXRlbnQgd29ya3NwYWNlLjwvcD5cbiAgICAgICAgPHAgY2xhc3NOYW1lPVwidGV4dC1zbSBmb250LW5vcm1hbCBsZWFkaW5nLTYgcHQtWzZweF1cIj5TaW1wbHkgdXBsb2FkIGEgcGF0ZW50IGRvY3VtZW50IGFuZCBsZXQgb3VyIEFJIGFuYWx5emUgdGhlIGRhdGEgaW4gc2Vjb25kcy4gVW5jb3ZlciB2YWx1YWJsZSBpbnNpZ2h0cyB0byBkcml2ZSB5b3VyIGlubm92YXRpb24gd29yay48L3A+XG5cbiAgICAgICAgey8qIGBSZWFkIGEgbmV3IHBhdGVudGAgc2VjdGlvbiAqL31cbiAgICAgICAgPHAgY2xhc3NOYW1lPVwidGV4dC14bCBmb250LW5vcm1hbCBsZWFkaW5nLTkgcHQtWzI0cHhdIHBiLVsxMnB4XVwiPlJlYWQgYSBuZXcgcGF0ZW50PC9wPlxuICAgICAgICA8ZGl2IFxuICAgICAgICAgIGNsYXNzTmFtZT1cImZsZXggZmxleC1jb2wgaC1bMjMwcHhdIGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWNlbnRlciBzaHJpbmstMCByb3VuZGVkLWxnIGJvcmRlciBib3JkZXItWyNEQUU1RUFdIGJnLXdoaXRlXCIgXG4gICAgICAgICAgc3R5bGU9e3sgYm94U2hhZG93OiAnMHB4IDFweCAxMHB4IDBweCByZ2JhKDAsIDAsIDAsIDAuMTApJyB9fVxuICAgICAgICAgIGlkPVwiZHJvcF96b25lXCIgb25Ecm9wPXtkcm9wSGFuZGxlcn0gb25EcmFnT3Zlcj17ZHJhZ092ZXJIYW5kbGVyfVxuICAgICAgICAgID5cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXggZmxleC1jb2wganVzdGlmeS1jZW50ZXIgaXRlbXMtY2VudGVyXCI+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT0nZmxleCBzcGFjZS14LTInPlxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImJnLWN1c3RvbS1ibHVlIHJvdW5kZWQtZnVsbCBwLTFcIj5cbiAgICAgICAgICAgICAgICA8RG93bmxvYWQgc2l6ZT17MTh9IGNvbG9yPVwiI2ZmZmZmZlwiIC8+XG4gICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICA8cCBjbGFzc05hbWU9XCJ0ZXh0LXhsIGZvbnQtbm9ybWFsIHdoaXRlc3BhY2Utbm93cmFwXCI+VXBsb2FkIG9yIGRyb3AgYSBmaWxlPC9wPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgPGlucHV0XG4gICAgICAgICAgICAgICAgaWQ9J3VwbG9hZCdcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJ0ZXh0LXNtIGN1cnNvci1wb2ludGVyIHctNTJcIlxuICAgICAgICAgICAgICAgIHR5cGU9J2ZpbGUnXG4gICAgICAgICAgICAgICAgb25DaGFuZ2U9e2hhbmRsZVVwbG9hZH1cbiAgICAgICAgICAgIC8+XG4gICAgICAgICAgICB7LyogPGJ1dHRvbiBvbkNsaWNrPXsoKSA9PiBhbmFseXplUGF0ZW50KCl9PkdvPC9idXR0b24+ICovfVxuICAgICAgICAgICBcbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG5cbiAgICBcblxuXG4gICAgICAgIHsvKiBgUmVjZW50IEhpc3RvcnlgIHNlY3Rpb24gKi99XG4gICAgICAgIDxwIGNsYXNzTmFtZT1cInRleHQteGwgZm9udC1ub3JtYWwgbGVhZGluZy05IHB0LVsyNHB4XSBwYi1bMTJweF1cIj5SZWNlbnQgSGlzdG9yeTwvcD5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGp1c3RpZnktY2VudGVyIHctZnVsbCBzcGFjZS14LTQgcGItMTBcIj5cblxuICAgICAgICAgIHtkYXRhLm1hcCgocGF0ZW50KSA9PiByZW5kZXJQYXRlbnRDYXJkKHBhdGVudCkpfVxuICAgICAgICAgIFxuICAgICAgICA8L2Rpdj5cblxuICAgICAgPC9tYWluPlxuICAgICAgXG4gICAgICB7aXNNb2RhbFZpc2libGUgJiYgKFxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJmaXhlZCBpbnNldC0wIGJnLWJsYWNrIGJnLW9wYWNpdHktNTAgZmxleCBqdXN0aWZ5LWNlbnRlciBpdGVtcy1jZW50ZXIgei00MFwiPlxuICAgICAgICA8U2F2ZVBhdGVudCB0aXRsZT17dXBsb2FkZWRGaWxlTmFtZX0gb25DbG9zZT17KCkgPT4gc2V0SXNNb2RhbFZpc2libGUoZmFsc2UpfSBhbmFseXplUGF0ZW50PXthbmFseXplUGF0ZW50fSAvPlxuICAgICAgPC9kaXY+XG4gICAgKX1cblxuICAgIDwvZGl2PlxuICApO1xufSJdLCJuYW1lcyI6WyJ1c2VTdGF0ZSIsInVzZVJvdXRlciIsIlBhdGVudENhcmQiLCJEb3dubG9hZCIsIlNhdmVQYXRlbnQiLCJwZGZUb1RleHQiLCJ1c2VBcHBTZWxlY3RvciIsInVzZUFwcERpc3BhdGNoIiwic3RvcmVGaWxlIiwicGF0ZW50cyIsIkhvbWUiLCJ1cGxvYWRlZEZpbGUiLCJzZXRVcGxvYWRlZEZpbGUiLCJ1cGxvYWRlZEZpbGVOYW1lIiwic2V0VXBsb2FkZWRGaWxlTmFtZSIsImlzTW9kYWxWaXNpYmxlIiwic2V0SXNNb2RhbFZpc2libGUiLCJyb3V0ZXIiLCJkaXNwYXRjaCIsImRhdGEiLCJoYW5kbGVVcGxvYWQiLCJldmVudCIsImZpbGUiLCJ0YXJnZXQiLCJmaWxlcyIsIm5hbWUiLCJkcm9wSGFuZGxlciIsImV2IiwiY29uc29sZSIsImxvZyIsInByZXZlbnREZWZhdWx0IiwiZGF0YVRyYW5zZmVyIiwiaXRlbXMiLCJmb3JFYWNoIiwiaXRlbSIsImkiLCJraW5kIiwiZ2V0QXNGaWxlIiwiZHJhZ092ZXJIYW5kbGVyIiwic3RvcmVOZXdQYXRlbnQiLCJ1cmwiLCJwYXRlbnRfdGV4dCIsInN1bW1hcnlfdGV4dCIsImdldFN1bW1hcnkiLCJ1cGxvYWRlZFBhdGVudCIsInRpdGxlIiwiZm9sZGVyIiwiZGF0ZSIsInRhZ3MiLCJzdGF0dXMiLCJwYXRlbnRJZCIsInByb2JsZW0iLCJwcm9ibGVtS2V5d29yZHMiLCJzb2x1dGlvbiIsInNvbHV0aW9uS2V5d29yZHMiLCJzdW1tYXJ5IiwiZnVsbHRleHQiLCJkdW1teSIsInJlc3BvbnNlIiwiZmV0Y2giLCJtZXRob2QiLCJoZWFkZXJzIiwiQXV0aG9yaXphdGlvbiIsImJvZHkiLCJKU09OIiwic3RyaW5naWZ5IiwidGhlbiIsInRleHQiLCJzdG9yZVBhdGVudCIsImluZm8iLCJnb1RvUGF0ZW50IiwidmFsdWUiLCJwdXNoIiwiZXJyb3IiLCJnb1RvUmVjZW50IiwiYW5hbHl6ZVBhdGVudCIsIlVSTCIsImNyZWF0ZU9iamVjdFVSTCIsImNhdGNoIiwicmVuZGVyUGF0ZW50Q2FyZCIsImVudHJ5Iiwib25DbGljayIsImRpdiIsImNsYXNzTmFtZSIsIm1haW4iLCJwIiwic3BhbiIsInN0eWxlIiwiYm94U2hhZG93IiwiaWQiLCJvbkRyb3AiLCJvbkRyYWdPdmVyIiwic2l6ZSIsImNvbG9yIiwiaW5wdXQiLCJ0eXBlIiwib25DaGFuZ2UiLCJtYXAiLCJwYXRlbnQiLCJvbkNsb3NlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/page.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./components/PatentCard.tsx":
/*!***********************************!*\
  !*** ./components/PatentCard.tsx ***!
  \***********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n\nfunction PatentCard(param) {\n    let { info, onClick } = param;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"flex w-1/3 max-h-[230px] flex-col p-5 rounded-lg border border-[#DAE5EA] bg-white shadow hover:bg-custom-navbar cursor-pointer\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                    className: \"text-base font-normal h-[90px] cursor-pointer\",\n                    onClick: onClick,\n                    children: info.title\n                }, void 0, false, {\n                    fileName: \"/Users/martinlacsamana/Documents/160/project/patent-analyzer/components/PatentCard.tsx\",\n                    lineNumber: 13,\n                    columnNumber: 17\n                }, this)\n            }, void 0, false, {\n                fileName: \"/Users/martinlacsamana/Documents/160/project/patent-analyzer/components/PatentCard.tsx\",\n                lineNumber: 12,\n                columnNumber: 13\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"inline-flex items-center gap-[12px] flex-[0_0_auto] relative pt-6\",\n                children: info.tags.map((tag, index)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"border border-solid border-[#a0a0a1] h-[26px] flex-[0_0_auto] px-[16px] py-[4px] rounded-[8px] justify-center bg-white\",\n                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                            className: \"text-[#a0a0a1] text-xs font-normal\",\n                            children: tag\n                        }, void 0, false, {\n                            fileName: \"/Users/martinlacsamana/Documents/160/project/patent-analyzer/components/PatentCard.tsx\",\n                            lineNumber: 20,\n                            columnNumber: 17\n                        }, this)\n                    }, index, false, {\n                        fileName: \"/Users/martinlacsamana/Documents/160/project/patent-analyzer/components/PatentCard.tsx\",\n                        lineNumber: 19,\n                        columnNumber: 15\n                    }, this))\n            }, void 0, false, {\n                fileName: \"/Users/martinlacsamana/Documents/160/project/patent-analyzer/components/PatentCard.tsx\",\n                lineNumber: 17,\n                columnNumber: 11\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"w-full flex self-stretch items-center flex-[0_0_auto] justify-between pt-8\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"inline-flex items-center gap-[8px] flex-[0_0_auto] overflow-hidden rounded-[8px] relative\",\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"w-[8px] h-[8px] rounded-[4px] \".concat(info.status === \"Active\" ? \"bg-green-500\" : \"bg-[#0075ff]\", \" relative\")\n                            }, void 0, false, {\n                                fileName: \"/Users/martinlacsamana/Documents/160/project/patent-analyzer/components/PatentCard.tsx\",\n                                lineNumber: 28,\n                                columnNumber: 17\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \" w-fit relative text-center whitespace-nowrap\",\n                                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                    className: \"text-black text-xs font-normal\",\n                                    children: info.status\n                                }, void 0, false, {\n                                    fileName: \"/Users/martinlacsamana/Documents/160/project/patent-analyzer/components/PatentCard.tsx\",\n                                    lineNumber: 30,\n                                    columnNumber: 25\n                                }, this)\n                            }, void 0, false, {\n                                fileName: \"/Users/martinlacsamana/Documents/160/project/patent-analyzer/components/PatentCard.tsx\",\n                                lineNumber: 29,\n                                columnNumber: 21\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Users/martinlacsamana/Documents/160/project/patent-analyzer/components/PatentCard.tsx\",\n                        lineNumber: 27,\n                        columnNumber: 13\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"mt-[-1.00px] text-[#a0a0a1] whitespace-nowrap\",\n                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                            className: \"text-[#a0a0a1] text-xs font-normal\",\n                            children: info.patentId\n                        }, void 0, false, {\n                            fileName: \"/Users/martinlacsamana/Documents/160/project/patent-analyzer/components/PatentCard.tsx\",\n                            lineNumber: 34,\n                            columnNumber: 19\n                        }, this)\n                    }, void 0, false, {\n                        fileName: \"/Users/martinlacsamana/Documents/160/project/patent-analyzer/components/PatentCard.tsx\",\n                        lineNumber: 33,\n                        columnNumber: 17\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/martinlacsamana/Documents/160/project/patent-analyzer/components/PatentCard.tsx\",\n                lineNumber: 26,\n                columnNumber: 11\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/martinlacsamana/Documents/160/project/patent-analyzer/components/PatentCard.tsx\",\n        lineNumber: 11,\n        columnNumber: 9\n    }, this);\n}\n_c = PatentCard;\n/* harmony default export */ __webpack_exports__[\"default\"] = (PatentCard);\nvar _c;\n$RefreshReg$(_c, \"PatentCard\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbXBvbmVudHMvUGF0ZW50Q2FyZC50c3giLCJtYXBwaW5ncyI6Ijs7O0FBUUEsU0FBU0EsV0FBVyxLQUErQjtRQUEvQixFQUFDQyxJQUFJLEVBQUVDLE9BQU8sRUFBaUIsR0FBL0I7SUFDaEIscUJBQ0ksOERBQUNDO1FBQUlDLFdBQVU7OzBCQUNYLDhEQUFDRDswQkFDRyw0RUFBQ0U7b0JBQUVELFdBQVU7b0JBQWdERixTQUFTQTs4QkFBVUQsS0FBS0ssS0FBSzs7Ozs7Ozs7Ozs7MEJBSWhHLDhEQUFDSDtnQkFBSUMsV0FBVTswQkFDWkgsS0FBS00sSUFBSSxDQUFDQyxHQUFHLENBQUMsQ0FBQ0MsS0FBS0Msc0JBQ25CLDhEQUFDUDt3QkFBZ0JDLFdBQVU7a0NBQ3pCLDRFQUFDQzs0QkFBRUQsV0FBVTtzQ0FBc0NLOzs7Ozs7dUJBRDNDQzs7Ozs7Ozs7OzswQkFPZCw4REFBQ1A7Z0JBQUlDLFdBQVU7O2tDQUNiLDhEQUFDRDt3QkFBSUMsV0FBVTs7MENBQ1gsOERBQUNEO2dDQUFJQyxXQUFXLGlDQUE0RixPQUEzREgsS0FBS1UsTUFBTSxLQUFLLFdBQVcsaUJBQWlCLGdCQUFlOzs7Ozs7MENBQ3hHLDhEQUFDUjtnQ0FBSUMsV0FBVTswQ0FDWCw0RUFBQ0M7b0NBQUVELFdBQVU7OENBQWtDSCxLQUFLVSxNQUFNOzs7Ozs7Ozs7Ozs7Ozs7OztrQ0FHbEUsOERBQUNSO3dCQUFJQyxXQUFVO2tDQUNiLDRFQUFDQzs0QkFBRUQsV0FBVTtzQ0FBc0NILEtBQUtXLFFBQVE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBTWxGO0tBL0JTWjtBQWtDVCwrREFBZUEsVUFBVUEsRUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9jb21wb25lbnRzL1BhdGVudENhcmQudHN4P2RjN2IiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFBhdGVudEluZm8gZnJvbSBcIkAvY29tcG9uZW50cy9QYXRlbnRJbmZvXCI7XG5cbmludGVyZmFjZSBQYXRlbnRDYXJkUHJvcHMge1xuICBpbmZvOiBQYXRlbnRJbmZvO1xuICBvbkNsaWNrOiBhbnksXG59XG5cblxuZnVuY3Rpb24gUGF0ZW50Q2FyZCh7aW5mbywgb25DbGlja306UGF0ZW50Q2FyZFByb3BzKSB7XG4gICAgcmV0dXJuIChcbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IHctMS8zIG1heC1oLVsyMzBweF0gZmxleC1jb2wgcC01IHJvdW5kZWQtbGcgYm9yZGVyIGJvcmRlci1bI0RBRTVFQV0gYmctd2hpdGUgc2hhZG93IGhvdmVyOmJnLWN1c3RvbS1uYXZiYXIgY3Vyc29yLXBvaW50ZXJcIj5cbiAgICAgICAgICAgIDxkaXY+XG4gICAgICAgICAgICAgICAgPHAgY2xhc3NOYW1lPVwidGV4dC1iYXNlIGZvbnQtbm9ybWFsIGgtWzkwcHhdIGN1cnNvci1wb2ludGVyXCIgb25DbGljaz17b25DbGlja30+e2luZm8udGl0bGV9PC9wPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgXG4gICAgICAgICAgey8qIFRhZ3MgKi99XG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJpbmxpbmUtZmxleCBpdGVtcy1jZW50ZXIgZ2FwLVsxMnB4XSBmbGV4LVswXzBfYXV0b10gcmVsYXRpdmUgcHQtNlwiPlxuICAgICAgICAgICAge2luZm8udGFncy5tYXAoKHRhZywgaW5kZXgpID0+IChcbiAgICAgICAgICAgICAgPGRpdiBrZXk9e2luZGV4fSBjbGFzc05hbWU9XCJib3JkZXIgYm9yZGVyLXNvbGlkIGJvcmRlci1bI2EwYTBhMV0gaC1bMjZweF0gZmxleC1bMF8wX2F1dG9dIHB4LVsxNnB4XSBweS1bNHB4XSByb3VuZGVkLVs4cHhdIGp1c3RpZnktY2VudGVyIGJnLXdoaXRlXCI+XG4gICAgICAgICAgICAgICAgPHAgY2xhc3NOYW1lPVwidGV4dC1bI2EwYTBhMV0gdGV4dC14cyBmb250LW5vcm1hbFwiPnt0YWd9PC9wPlxuICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICkpfVxuICAgICAgICAgIDwvZGl2PlxuICAgIFxuICAgICAgICAgIHsvKiBQZW5kaW5nIFN0YXR1cyAmIFBhdGVudCBJRCAqL31cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInctZnVsbCBmbGV4IHNlbGYtc3RyZXRjaCBpdGVtcy1jZW50ZXIgZmxleC1bMF8wX2F1dG9dIGp1c3RpZnktYmV0d2VlbiBwdC04XCI+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImlubGluZS1mbGV4IGl0ZW1zLWNlbnRlciBnYXAtWzhweF0gZmxleC1bMF8wX2F1dG9dIG92ZXJmbG93LWhpZGRlbiByb3VuZGVkLVs4cHhdIHJlbGF0aXZlXCI+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2B3LVs4cHhdIGgtWzhweF0gcm91bmRlZC1bNHB4XSAke2luZm8uc3RhdHVzID09PSAnQWN0aXZlJyA/ICdiZy1ncmVlbi01MDAnIDogJ2JnLVsjMDA3NWZmXSd9IHJlbGF0aXZlYH0gLz5cbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCIgdy1maXQgcmVsYXRpdmUgdGV4dC1jZW50ZXIgd2hpdGVzcGFjZS1ub3dyYXBcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxwIGNsYXNzTmFtZT1cInRleHQtYmxhY2sgdGV4dC14cyBmb250LW5vcm1hbFwiPntpbmZvLnN0YXR1c308L3A+XG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwibXQtWy0xLjAwcHhdIHRleHQtWyNhMGEwYTFdIHdoaXRlc3BhY2Utbm93cmFwXCI+XG4gICAgICAgICAgICAgICAgICA8cCBjbGFzc05hbWU9XCJ0ZXh0LVsjYTBhMGExXSB0ZXh0LXhzIGZvbnQtbm9ybWFsXCI+e2luZm8ucGF0ZW50SWR9PC9wPlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgICk7XG5cbn1cblxuXG5leHBvcnQgZGVmYXVsdCBQYXRlbnRDYXJkIl0sIm5hbWVzIjpbIlBhdGVudENhcmQiLCJpbmZvIiwib25DbGljayIsImRpdiIsImNsYXNzTmFtZSIsInAiLCJ0aXRsZSIsInRhZ3MiLCJtYXAiLCJ0YWciLCJpbmRleCIsInN0YXR1cyIsInBhdGVudElkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./components/PatentCard.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./components/modals/CreateFolder.tsx":
/*!********************************************!*\
  !*** ./components/modals/CreateFolder.tsx ***!
  \********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n\nvar _s = $RefreshSig$();\n\nfunction CreateFolder(param) {\n    let { onClose, analyzePatent } = param;\n    _s();\n    const [selectedFolder, setSelectedFolder] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)();\n    // Function to handle folder selection\n    const handleFolderClick = (folderName)=>{\n        setSelectedFolder(folderName);\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"flex items-center justify-center min-h-screen\",\n        children: [\n            \" \",\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"flex flex-col h-[200px] w-[400px] rounded-xl border border-[#DCE4E7] bg-white shadow-lg p-4 pb-8 justify-between\",\n                children: [\n                    \" \",\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"mb-2 -mt-8 pt-10 flex items-center space-x-10\",\n                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                            className: \"text-lg font-medium whitespace-nowrap\",\n                            children: \"New Folder\"\n                        }, void 0, false, {\n                            fileName: \"/Users/martinlacsamana/Documents/160/project/patent-analyzer/components/modals/CreateFolder.tsx\",\n                            lineNumber: 24,\n                            columnNumber: 21\n                        }, this)\n                    }, void 0, false, {\n                        fileName: \"/Users/martinlacsamana/Documents/160/project/patent-analyzer/components/modals/CreateFolder.tsx\",\n                        lineNumber: 23,\n                        columnNumber: 17\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                        className: \"px-4 py-2 border border=[#C1C1C1] rounded rounded-lg\",\n                        type: \"\",\n                        placeholder: \"Type here...\"\n                    }, void 0, false, {\n                        fileName: \"/Users/martinlacsamana/Documents/160/project/patent-analyzer/components/modals/CreateFolder.tsx\",\n                        lineNumber: 28,\n                        columnNumber: 18\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"flex justify-end items-center w-full pl-4 pr-4 mt-6 space-x-2\",\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                className: \"flex items-center justify-center h-[30px] px-4 py-2 bg-white border border-[#DCE4E7] rounded-md rounded hover:bg-gray-300 hover:text-black text-sm whitespace-nowrap\",\n                                onClick: ()=>onClose(),\n                                children: \"Cancel\"\n                            }, void 0, false, {\n                                fileName: \"/Users/martinlacsamana/Documents/160/project/patent-analyzer/components/modals/CreateFolder.tsx\",\n                                lineNumber: 42,\n                                columnNumber: 21\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                className: \"flex items-center justify-center h-[30px] px-4 py-2 bg-[#59808C] text-white border border-[#DCE4E7] rounded-md rounded hover:bg-gray-600 text-sm whitespace-nowrap\",\n                                onClick: analyzePatent,\n                                children: \"Create\"\n                            }, void 0, false, {\n                                fileName: \"/Users/martinlacsamana/Documents/160/project/patent-analyzer/components/modals/CreateFolder.tsx\",\n                                lineNumber: 47,\n                                columnNumber: 21\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Users/martinlacsamana/Documents/160/project/patent-analyzer/components/modals/CreateFolder.tsx\",\n                        lineNumber: 41,\n                        columnNumber: 17\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/martinlacsamana/Documents/160/project/patent-analyzer/components/modals/CreateFolder.tsx\",\n                lineNumber: 20,\n                columnNumber: 13\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/martinlacsamana/Documents/160/project/patent-analyzer/components/modals/CreateFolder.tsx\",\n        lineNumber: 19,\n        columnNumber: 9\n    }, this);\n}\n_s(CreateFolder, \"2hYDfkKuS5onTt/6wYj6UwZNSwM=\");\n_c = CreateFolder;\n/* harmony default export */ __webpack_exports__[\"default\"] = (CreateFolder);\nvar _c;\n$RefreshReg$(_c, \"CreateFolder\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbXBvbmVudHMvbW9kYWxzL0NyZWF0ZUZvbGRlci50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQThDO0FBUTlDLFNBQVNDLGFBQWEsS0FBMkM7UUFBM0MsRUFBQ0MsT0FBTyxFQUFFQyxhQUFhLEVBQW9CLEdBQTNDOztJQUNsQixNQUFNLENBQUNDLGdCQUFnQkMsa0JBQWtCLEdBQUdMLCtDQUFRQTtJQUVwRCxzQ0FBc0M7SUFDdEMsTUFBTU0sb0JBQW9CLENBQUNDO1FBQ3ZCRixrQkFBa0JFO0lBQ3RCO0lBR0EscUJBQ0ksOERBQUNDO1FBQUlDLFdBQVU7O1lBQWdEOzBCQUMzRCw4REFBQ0Q7Z0JBQUlDLFdBQVU7O29CQUFtSDtrQ0FHOUgsOERBQUNEO3dCQUFJQyxXQUFVO2tDQUNYLDRFQUFDQzs0QkFBRUQsV0FBVTtzQ0FBd0M7Ozs7Ozs7Ozs7O2tDQUl4RCw4REFBQ0U7d0JBQ0VGLFdBQVU7d0JBQ1ZHLE1BQUs7d0JBQ0xDLGFBQVk7Ozs7OztrQ0FVaEIsOERBQUNMO3dCQUFJQyxXQUFVOzswQ0FDWCw4REFBQ0s7Z0NBQ0dMLFdBQVU7Z0NBQ1ZNLFNBQVMsSUFBTWI7MENBQVc7Ozs7OzswQ0FHOUIsOERBQUNZO2dDQUNHTCxXQUFVO2dDQUNWTSxTQUFTWjswQ0FDUjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBUXpCO0dBakRTRjtLQUFBQTtBQWtEVCwrREFBZUEsWUFBWUEsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9jb21wb25lbnRzL21vZGFscy9DcmVhdGVGb2xkZXIudHN4PzcwM2QiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgRm9sZGVyLCBGaWxlIH0gZnJvbSAnbHVjaWRlLXJlYWN0JztcblxuaW50ZXJmYWNlIENyZWF0ZUZvbGRlclByb3BzIHtcbiAgICBvbkNsb3NlOiAoKSA9PiB2b2lkO1xuICAgIGFuYWx5emVQYXRlbnQ6ICgpID0+IHZvaWQ7XG59XG5cbmZ1bmN0aW9uIENyZWF0ZUZvbGRlcih7b25DbG9zZSwgYW5hbHl6ZVBhdGVudH06IENyZWF0ZUZvbGRlclByb3BzKSB7XG4gICAgY29uc3QgW3NlbGVjdGVkRm9sZGVyLCBzZXRTZWxlY3RlZEZvbGRlcl0gPSB1c2VTdGF0ZTxTdHJpbmcgfCB1bmRlZmluZWQ+KClcblxuICAgIC8vIEZ1bmN0aW9uIHRvIGhhbmRsZSBmb2xkZXIgc2VsZWN0aW9uXG4gICAgY29uc3QgaGFuZGxlRm9sZGVyQ2xpY2sgPSAoZm9sZGVyTmFtZTogc3RyaW5nKSA9PiB7XG4gICAgICAgIHNldFNlbGVjdGVkRm9sZGVyKGZvbGRlck5hbWUpO1xuICAgIH07XG5cblxuICAgIHJldHVybiAoXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBpdGVtcy1jZW50ZXIganVzdGlmeS1jZW50ZXIgbWluLWgtc2NyZWVuXCI+IHsvKiBUaGlzIGRpdiBjZW50ZXJzIHRoZSBtb2RhbCAqL31cbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBmbGV4LWNvbCBoLVsyMDBweF0gdy1bNDAwcHhdIHJvdW5kZWQteGwgYm9yZGVyIGJvcmRlci1bI0RDRTRFN10gYmctd2hpdGUgc2hhZG93LWxnIHAtNCBwYi04IGp1c3RpZnktYmV0d2VlblwiPiB7LyogTWFrZSB0aGlzIGEgZmxleCBjb2x1bW4gY29udGFpbmVyICovfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHsvKiBIZWFkZXIgKi99XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJtYi0yIC1tdC04IHB0LTEwIGZsZXggaXRlbXMtY2VudGVyIHNwYWNlLXgtMTBcIj5cbiAgICAgICAgICAgICAgICAgICAgPHAgY2xhc3NOYW1lPVwidGV4dC1sZyBmb250LW1lZGl1bSB3aGl0ZXNwYWNlLW5vd3JhcFwiPk5ldyBGb2xkZXI8L3A+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgIHsvKiBJbnB1dCAqL31cbiAgICAgICAgICAgICAgICAgPGlucHV0IFxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJweC00IHB5LTIgYm9yZGVyIGJvcmRlcj1bI0MxQzFDMV0gcm91bmRlZCByb3VuZGVkLWxnXCJcbiAgICAgICAgICAgICAgICAgICAgdHlwZT1cIlwiXG4gICAgICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyPVwiVHlwZSBoZXJlLi4uXCJcbiAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICAgXG4gICAgICAgXG4gICAgICAgICAgICAgXG5cbiAgICAgICAgICAgICAgICB7LyogQnV0dG9ucyAqL31cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXgganVzdGlmeS1lbmQgaXRlbXMtY2VudGVyIHctZnVsbCBwbC00IHByLTQgbXQtNiBzcGFjZS14LTJcIj5cbiAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cImZsZXggaXRlbXMtY2VudGVyIGp1c3RpZnktY2VudGVyIGgtWzMwcHhdIHB4LTQgcHktMiBiZy13aGl0ZSBib3JkZXIgYm9yZGVyLVsjRENFNEU3XSByb3VuZGVkLW1kIHJvdW5kZWQgaG92ZXI6YmctZ3JheS0zMDAgaG92ZXI6dGV4dC1ibGFjayB0ZXh0LXNtIHdoaXRlc3BhY2Utbm93cmFwXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9eygpID0+IG9uQ2xvc2UoKX0+ICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIENhbmNlbFxuICAgICAgICAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cImZsZXggaXRlbXMtY2VudGVyIGp1c3RpZnktY2VudGVyIGgtWzMwcHhdIHB4LTQgcHktMiBiZy1bIzU5ODA4Q10gdGV4dC13aGl0ZSBib3JkZXIgYm9yZGVyLVsjRENFNEU3XSByb3VuZGVkLW1kIHJvdW5kZWQgaG92ZXI6YmctZ3JheS02MDAgdGV4dC1zbSB3aGl0ZXNwYWNlLW5vd3JhcFwiXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNsaWNrPXthbmFseXplUGF0ZW50fSAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIENyZWF0ZVxuICAgICAgICAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cblxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICk7XG59XG5leHBvcnQgZGVmYXVsdCBDcmVhdGVGb2xkZXI7Il0sIm5hbWVzIjpbInVzZVN0YXRlIiwiQ3JlYXRlRm9sZGVyIiwib25DbG9zZSIsImFuYWx5emVQYXRlbnQiLCJzZWxlY3RlZEZvbGRlciIsInNldFNlbGVjdGVkRm9sZGVyIiwiaGFuZGxlRm9sZGVyQ2xpY2siLCJmb2xkZXJOYW1lIiwiZGl2IiwiY2xhc3NOYW1lIiwicCIsImlucHV0IiwidHlwZSIsInBsYWNlaG9sZGVyIiwiYnV0dG9uIiwib25DbGljayJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./components/modals/CreateFolder.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./components/modals/SavePatent.tsx":
/*!******************************************!*\
  !*** ./components/modals/SavePatent.tsx ***!
  \******************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _barrel_optimize_names_File_Folder_lucide_react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! __barrel_optimize__?names=File,Folder!=!lucide-react */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/file.js\");\n/* harmony import */ var _barrel_optimize_names_File_Folder_lucide_react__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! __barrel_optimize__?names=File,Folder!=!lucide-react */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/folder.js\");\n/* harmony import */ var _CreateFolder__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./CreateFolder */ \"(app-pages-browser)/./components/modals/CreateFolder.tsx\");\n\nvar _s = $RefreshSig$();\n\n\n\nfunction SavePatent(param) {\n    let { onClose, title, analyzePatent } = param;\n    _s();\n    const [selectedFolder, setSelectedFolder] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)();\n    const [isModalVisible, setIsModalVisible] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    // Handles truncating the patent filename if it's too long\n    function formatTitle(title) {\n        let maxLength = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 28;\n        return title.length > maxLength ? \"\".concat(title.substring(0, maxLength), \"...\") : title;\n    }\n    // Function to handle folder selection\n    const handleFolderClick = (folderName)=>{\n        setSelectedFolder(folderName);\n    };\n    if (isModalVisible) {\n        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_CreateFolder__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {\n            onClose: ()=>setIsModalVisible(false),\n            analyzePatent: analyzePatent\n        }, void 0, false, {\n            fileName: \"/Users/martinlacsamana/Documents/160/project/patent-analyzer/components/modals/SavePatent.tsx\",\n            lineNumber: 26,\n            columnNumber: 16\n        }, this);\n    }\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"flex flex-col items-center justify-center min-h-screen\",\n        children: [\n            \" \",\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"flex flex-col h-[500px] w-[500px] rounded-xl border border-[#DCE4E7] bg-white shadow-lg p-4 pb-8 justify-between\",\n                children: [\n                    \" \",\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"relative float-right cursor-pointer\",\n                                onClick: onClose,\n                                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"svg\", {\n                                    xmlns: \"http://www.w3.org/2000/svg\",\n                                    className: \"h-5 w-5\",\n                                    fill: \"none\",\n                                    viewBox: \"0 0 24 24\",\n                                    stroke: \"#333333\",\n                                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"path\", {\n                                        strokeLinecap: \"round\",\n                                        strokeLinejoin: \"round\",\n                                        strokeWidth: \"2\",\n                                        d: \"M6 18L18 6M6 6l12 12\"\n                                    }, void 0, false, {\n                                        fileName: \"/Users/martinlacsamana/Documents/160/project/patent-analyzer/components/modals/SavePatent.tsx\",\n                                        lineNumber: 37,\n                                        columnNumber: 29\n                                    }, this)\n                                }, void 0, false, {\n                                    fileName: \"/Users/martinlacsamana/Documents/160/project/patent-analyzer/components/modals/SavePatent.tsx\",\n                                    lineNumber: 36,\n                                    columnNumber: 25\n                                }, this)\n                            }, void 0, false, {\n                                fileName: \"/Users/martinlacsamana/Documents/160/project/patent-analyzer/components/modals/SavePatent.tsx\",\n                                lineNumber: 35,\n                                columnNumber: 21\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"pl-4 pr-4 -mt-4\",\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                        className: \"mb-6 pt-10 flex items-center space-x-10\",\n                                        children: [\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                                className: \"text-lg font-medium whitespace-nowrap\",\n                                                children: \"Save the new patent\"\n                                            }, void 0, false, {\n                                                fileName: \"/Users/martinlacsamana/Documents/160/project/patent-analyzer/components/modals/SavePatent.tsx\",\n                                                lineNumber: 44,\n                                                columnNumber: 29\n                                            }, this),\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                className: \"flex items-center space-x-1 justify-center \",\n                                                children: [\n                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_File_Folder_lucide_react__WEBPACK_IMPORTED_MODULE_3__[\"default\"], {\n                                                        size: 14\n                                                    }, void 0, false, {\n                                                        fileName: \"/Users/martinlacsamana/Documents/160/project/patent-analyzer/components/modals/SavePatent.tsx\",\n                                                        lineNumber: 46,\n                                                        columnNumber: 33\n                                                    }, this),\n                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                                        className: \"text-xs  whitespace-nowrap\",\n                                                        children: formatTitle(title)\n                                                    }, void 0, false, {\n                                                        fileName: \"/Users/martinlacsamana/Documents/160/project/patent-analyzer/components/modals/SavePatent.tsx\",\n                                                        lineNumber: 47,\n                                                        columnNumber: 33\n                                                    }, this)\n                                                ]\n                                            }, void 0, true, {\n                                                fileName: \"/Users/martinlacsamana/Documents/160/project/patent-analyzer/components/modals/SavePatent.tsx\",\n                                                lineNumber: 45,\n                                                columnNumber: 29\n                                            }, this)\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"/Users/martinlacsamana/Documents/160/project/patent-analyzer/components/modals/SavePatent.tsx\",\n                                        lineNumber: 43,\n                                        columnNumber: 25\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                        className: \"flex flex-col space-y-2\",\n                                        children: [\n                                            \"Computer Vision for Medical\",\n                                            \"Biomedical Device\",\n                                            \"Innovation Strategy\"\n                                        ].map((folderName)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                className: \"flex items-center space-x-2 border border-[#DAE5EA] rounded-xl bg-white py-2 px-3 \".concat(selectedFolder === folderName ? \"bg-[#BCD3DB]\" : \"hover:bg-[#BCD3DB] cursor-pointer\"),\n                                                style: {\n                                                    boxShadow: \"0px 1px 10px 0px rgba(0, 0, 0, 0.10)\"\n                                                },\n                                                onClick: ()=>handleFolderClick(folderName),\n                                                children: [\n                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_File_Folder_lucide_react__WEBPACK_IMPORTED_MODULE_4__[\"default\"], {\n                                                        size: 15\n                                                    }, void 0, false, {\n                                                        fileName: \"/Users/martinlacsamana/Documents/160/project/patent-analyzer/components/modals/SavePatent.tsx\",\n                                                        lineNumber: 60,\n                                                        columnNumber: 37\n                                                    }, this),\n                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                                        className: \"text-sm\",\n                                                        children: folderName\n                                                    }, void 0, false, {\n                                                        fileName: \"/Users/martinlacsamana/Documents/160/project/patent-analyzer/components/modals/SavePatent.tsx\",\n                                                        lineNumber: 61,\n                                                        columnNumber: 37\n                                                    }, this)\n                                                ]\n                                            }, folderName, true, {\n                                                fileName: \"/Users/martinlacsamana/Documents/160/project/patent-analyzer/components/modals/SavePatent.tsx\",\n                                                lineNumber: 54,\n                                                columnNumber: 33\n                                            }, this))\n                                    }, void 0, false, {\n                                        fileName: \"/Users/martinlacsamana/Documents/160/project/patent-analyzer/components/modals/SavePatent.tsx\",\n                                        lineNumber: 52,\n                                        columnNumber: 25\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                        className: \"py-3\",\n                                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"svg\", {\n                                            xmlns: \"http://www.w3.org/2000/svg\",\n                                            width: \"220\",\n                                            height: \"2\",\n                                            viewBox: \"0 0 352 2\",\n                                            fill: \"none\",\n                                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"path\", {\n                                                d: \"M1 1H351\",\n                                                stroke: \"#DAE5EA\",\n                                                \"stroke-linecap\": \"round\"\n                                            }, void 0, false, {\n                                                fileName: \"/Users/martinlacsamana/Documents/160/project/patent-analyzer/components/modals/SavePatent.tsx\",\n                                                lineNumber: 69,\n                                                columnNumber: 33\n                                            }, this)\n                                        }, void 0, false, {\n                                            fileName: \"/Users/martinlacsamana/Documents/160/project/patent-analyzer/components/modals/SavePatent.tsx\",\n                                            lineNumber: 68,\n                                            columnNumber: 29\n                                        }, this)\n                                    }, void 0, false, {\n                                        fileName: \"/Users/martinlacsamana/Documents/160/project/patent-analyzer/components/modals/SavePatent.tsx\",\n                                        lineNumber: 67,\n                                        columnNumber: 25\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                        className: \"flex flex-col space-y-2\",\n                                        children: [\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                className: \"flex items-center space-x-2 border border-[#DAE5EA] rounded-xl bg-white py-2 px-3\",\n                                                style: {\n                                                    boxShadow: \"0px 1px 10px 0px rgba(0, 0, 0, 0.10)\"\n                                                },\n                                                children: [\n                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_File_Folder_lucide_react__WEBPACK_IMPORTED_MODULE_3__[\"default\"], {\n                                                        size: 15,\n                                                        color: \"#A0A0A1\"\n                                                    }, void 0, false, {\n                                                        fileName: \"/Users/martinlacsamana/Documents/160/project/patent-analyzer/components/modals/SavePatent.tsx\",\n                                                        lineNumber: 76,\n                                                        columnNumber: 33\n                                                    }, this),\n                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                                        className: \"text-sm text-[#A0A0A1]\",\n                                                        children: \"Method and Apparatus for Image-Based Navigation\"\n                                                    }, void 0, false, {\n                                                        fileName: \"/Users/martinlacsamana/Documents/160/project/patent-analyzer/components/modals/SavePatent.tsx\",\n                                                        lineNumber: 77,\n                                                        columnNumber: 33\n                                                    }, this)\n                                                ]\n                                            }, void 0, true, {\n                                                fileName: \"/Users/martinlacsamana/Documents/160/project/patent-analyzer/components/modals/SavePatent.tsx\",\n                                                lineNumber: 75,\n                                                columnNumber: 29\n                                            }, this),\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                className: \"flex items-center space-x-2 border border-[#DAE5EA] rounded-xl bg-white py-2 px-3\",\n                                                style: {\n                                                    boxShadow: \"0px 1px 10px 0px rgba(0, 0, 0, 0.10)\"\n                                                },\n                                                children: [\n                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_File_Folder_lucide_react__WEBPACK_IMPORTED_MODULE_3__[\"default\"], {\n                                                        size: 15,\n                                                        color: \"#A0A0A1\"\n                                                    }, void 0, false, {\n                                                        fileName: \"/Users/martinlacsamana/Documents/160/project/patent-analyzer/components/modals/SavePatent.tsx\",\n                                                        lineNumber: 81,\n                                                        columnNumber: 33\n                                                    }, this),\n                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                                        className: \"text-sm text-[#A0A0A1]\",\n                                                        children: \"Single sided light-actuated microfluidic device with...\"\n                                                    }, void 0, false, {\n                                                        fileName: \"/Users/martinlacsamana/Documents/160/project/patent-analyzer/components/modals/SavePatent.tsx\",\n                                                        lineNumber: 82,\n                                                        columnNumber: 33\n                                                    }, this)\n                                                ]\n                                            }, void 0, true, {\n                                                fileName: \"/Users/martinlacsamana/Documents/160/project/patent-analyzer/components/modals/SavePatent.tsx\",\n                                                lineNumber: 80,\n                                                columnNumber: 29\n                                            }, this)\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"/Users/martinlacsamana/Documents/160/project/patent-analyzer/components/modals/SavePatent.tsx\",\n                                        lineNumber: 74,\n                                        columnNumber: 25\n                                    }, this)\n                                ]\n                            }, void 0, true, {\n                                fileName: \"/Users/martinlacsamana/Documents/160/project/patent-analyzer/components/modals/SavePatent.tsx\",\n                                lineNumber: 41,\n                                columnNumber: 21\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Users/martinlacsamana/Documents/160/project/patent-analyzer/components/modals/SavePatent.tsx\",\n                        lineNumber: 34,\n                        columnNumber: 17\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"flex justify-between items-center w-full pl-4 pr-4 mt-6\",\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                className: \"flex items-center justify-center h-[30px] px-4 py-2 bg-white border border-[#DCE4E7] rounded-md rounded hover:bg-gray-300 hover:text-black text-sm whitespace-nowrap\",\n                                onClick: ()=>setIsModalVisible(true),\n                                children: \"Create New Folder\"\n                            }, void 0, false, {\n                                fileName: \"/Users/martinlacsamana/Documents/160/project/patent-analyzer/components/modals/SavePatent.tsx\",\n                                lineNumber: 91,\n                                columnNumber: 21\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"flex space-x-4\",\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                        className: \"flex items-center justify-center h-[30px] px-4 py-2 bg-white border border-[#DCE4E7] rounded-md rounded hover:bg-gray-300 hover:text-black text-sm whitespace-nowrap\",\n                                        onClick: analyzePatent,\n                                        children: \"Skip Saving\"\n                                    }, void 0, false, {\n                                        fileName: \"/Users/martinlacsamana/Documents/160/project/patent-analyzer/components/modals/SavePatent.tsx\",\n                                        lineNumber: 98,\n                                        columnNumber: 25\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                        className: \"flex items-center justify-center h-[30px] px-4 py-2 bg-[#59808C] text-white border border-[#DCE4E7] rounded-md rounded hover:bg-gray-600 text-sm whitespace-nowrap\",\n                                        children: \"Save\"\n                                    }, void 0, false, {\n                                        fileName: \"/Users/martinlacsamana/Documents/160/project/patent-analyzer/components/modals/SavePatent.tsx\",\n                                        lineNumber: 103,\n                                        columnNumber: 25\n                                    }, this)\n                                ]\n                            }, void 0, true, {\n                                fileName: \"/Users/martinlacsamana/Documents/160/project/patent-analyzer/components/modals/SavePatent.tsx\",\n                                lineNumber: 97,\n                                columnNumber: 21\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Users/martinlacsamana/Documents/160/project/patent-analyzer/components/modals/SavePatent.tsx\",\n                        lineNumber: 90,\n                        columnNumber: 17\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/martinlacsamana/Documents/160/project/patent-analyzer/components/modals/SavePatent.tsx\",\n                lineNumber: 32,\n                columnNumber: 13\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/martinlacsamana/Documents/160/project/patent-analyzer/components/modals/SavePatent.tsx\",\n        lineNumber: 31,\n        columnNumber: 9\n    }, this);\n}\n_s(SavePatent, \"J2x7A4Rd5/c6M2VONv107gP9FCk=\");\n_c = SavePatent;\n/* harmony default export */ __webpack_exports__[\"default\"] = (SavePatent);\nvar _c;\n$RefreshReg$(_c, \"SavePatent\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbXBvbmVudHMvbW9kYWxzL1NhdmVQYXRlbnQudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUE4QztBQUNGO0FBQ0Y7QUFRMUMsU0FBU0ksV0FBVyxLQUFnRDtRQUFoRCxFQUFDQyxPQUFPLEVBQUVDLEtBQUssRUFBRUMsYUFBYSxFQUFrQixHQUFoRDs7SUFDaEIsTUFBTSxDQUFDQyxnQkFBZ0JDLGtCQUFrQixHQUFHVCwrQ0FBUUE7SUFDcEQsTUFBTSxDQUFDVSxnQkFBZ0JDLGtCQUFrQixHQUFHWCwrQ0FBUUEsQ0FBQztJQUVyRCwwREFBMEQ7SUFDMUQsU0FBU1ksWUFBWU4sS0FBYTtZQUFFTyxZQUFBQSxpRUFBb0I7UUFDcEQsT0FBT1AsTUFBTVEsTUFBTSxHQUFHRCxZQUFZLEdBQWlDLE9BQTlCUCxNQUFNUyxTQUFTLENBQUMsR0FBR0YsWUFBVyxTQUFPUDtJQUM5RTtJQUVBLHNDQUFzQztJQUN0QyxNQUFNVSxvQkFBb0IsQ0FBQ0M7UUFDdkJSLGtCQUFrQlE7SUFDdEI7SUFFQSxJQUFJUCxnQkFBZ0I7UUFDaEIscUJBQU8sOERBQUNQLHFEQUFZQTtZQUFDRSxTQUFTLElBQU1NLGtCQUFrQjtZQUFRSixlQUFlQTs7Ozs7O0lBQ2pGO0lBR0EscUJBQ0ksOERBQUNXO1FBQUlDLFdBQVU7O1lBQXlEOzBCQUNwRSw4REFBQ0Q7Z0JBQUlDLFdBQVU7O29CQUFtSDtrQ0FFOUgsOERBQUNEOzswQ0FDRyw4REFBQ0E7Z0NBQUlDLFdBQVU7Z0NBQXNDQyxTQUFTZjswQ0FDMUQsNEVBQUNnQjtvQ0FBSUMsT0FBTTtvQ0FBNkJILFdBQVU7b0NBQVVJLE1BQUs7b0NBQU9DLFNBQVE7b0NBQVlDLFFBQU87OENBQy9GLDRFQUFDQzt3Q0FBS0MsZUFBYzt3Q0FBUUMsZ0JBQWU7d0NBQVFDLGFBQVk7d0NBQUlDLEdBQUU7Ozs7Ozs7Ozs7Ozs7Ozs7MENBSTdFLDhEQUFDWjtnQ0FBSUMsV0FBVTs7a0RBRVgsOERBQUNEO3dDQUFJQyxXQUFVOzswREFDWCw4REFBQ1k7Z0RBQUVaLFdBQVU7MERBQXdDOzs7Ozs7MERBQ3JELDhEQUFDRDtnREFBSUMsV0FBVTs7a0VBQ1gsOERBQUNqQix1RkFBSUE7d0RBQUM4QixNQUFNOzs7Ozs7a0VBQ1osOERBQUNEO3dEQUFFWixXQUFVO2tFQUE4QlAsWUFBWU47Ozs7Ozs7Ozs7Ozs7Ozs7OztrREFLL0QsOERBQUNZO3dDQUFJQyxXQUFVO2tEQUNWOzRDQUFDOzRDQUErQjs0Q0FBcUI7eUNBQXNCLENBQUNjLEdBQUcsQ0FBQyxDQUFDaEIsMkJBQzlFLDhEQUFDQztnREFFR0MsV0FBVyxxRkFBMEssT0FBckZYLG1CQUFtQlMsYUFBYSxpQkFBaUI7Z0RBQ2pKaUIsT0FBTztvREFBRUMsV0FBVztnREFBdUM7Z0RBQzNEZixTQUFTLElBQU1KLGtCQUFrQkM7O2tFQUVqQyw4REFBQ2hCLHVGQUFNQTt3REFBQytCLE1BQU07Ozs7OztrRUFDZCw4REFBQ0Q7d0RBQUVaLFdBQVU7a0VBQVdGOzs7Ozs7OytDQU5uQkE7Ozs7Ozs7Ozs7a0RBWWpCLDhEQUFDQzt3Q0FBSUMsV0FBVTtrREFDWCw0RUFBQ0U7NENBQUlDLE9BQU07NENBQTZCYyxPQUFNOzRDQUFNQyxRQUFPOzRDQUFJYixTQUFROzRDQUFZRCxNQUFLO3NEQUNwRiw0RUFBQ0c7Z0RBQUtJLEdBQUU7Z0RBQVdMLFFBQU87Z0RBQVVhLGtCQUFlOzs7Ozs7Ozs7Ozs7Ozs7O2tEQUszRCw4REFBQ3BCO3dDQUFJQyxXQUFVOzswREFDWCw4REFBQ0Q7Z0RBQUlDLFdBQVU7Z0RBQW9GZSxPQUFPO29EQUFFQyxXQUFXO2dEQUF1Qzs7a0VBQzFKLDhEQUFDakMsdUZBQUlBO3dEQUFDOEIsTUFBTTt3REFBSU8sT0FBTTs7Ozs7O2tFQUN0Qiw4REFBQ1I7d0RBQUVaLFdBQVU7a0VBQXlCOzs7Ozs7Ozs7Ozs7MERBRzFDLDhEQUFDRDtnREFBSUMsV0FBVTtnREFBb0ZlLE9BQU87b0RBQUVDLFdBQVc7Z0RBQXVDOztrRUFDMUosOERBQUNqQyx1RkFBSUE7d0RBQUM4QixNQUFNO3dEQUFJTyxPQUFNOzs7Ozs7a0VBQ3RCLDhEQUFDUjt3REFBRVosV0FBVTtrRUFBeUI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztrQ0FRdEQsOERBQUNEO3dCQUFJQyxXQUFVOzswQ0FDWCw4REFBQ3FCO2dDQUNHckIsV0FBVTtnQ0FDVkMsU0FBUyxJQUFNVCxrQkFBa0I7MENBQ2hDOzs7Ozs7MENBR0wsOERBQUNPO2dDQUFJQyxXQUFVOztrREFDWCw4REFBQ3FCO3dDQUNHckIsV0FBVTt3Q0FDVkMsU0FBU2I7a0RBQWU7Ozs7OztrREFHNUIsOERBQUNpQzt3Q0FBT3JCLFdBQVU7a0RBQXFLOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFRL007R0FwR1NmO0tBQUFBO0FBcUdULCtEQUFlQSxVQUFVQSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2NvbXBvbmVudHMvbW9kYWxzL1NhdmVQYXRlbnQudHN4P2UyYmMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgRm9sZGVyLCBGaWxlIH0gZnJvbSAnbHVjaWRlLXJlYWN0JztcbmltcG9ydCBDcmVhdGVGb2xkZXIgZnJvbSAnLi9DcmVhdGVGb2xkZXInO1xuXG5pbnRlcmZhY2UgU2F2ZVBhdGVudFByb3BzIHtcbiAgICBvbkNsb3NlOiAoKSA9PiB2b2lkO1xuICAgIGFuYWx5emVQYXRlbnQ6ICgpID0+IHZvaWQ7XG4gICAgdGl0bGU6IHN0cmluZyB8IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gU2F2ZVBhdGVudCh7b25DbG9zZSwgdGl0bGUsIGFuYWx5emVQYXRlbnR9OiBTYXZlUGF0ZW50UHJvcHMpIHtcbiAgICBjb25zdCBbc2VsZWN0ZWRGb2xkZXIsIHNldFNlbGVjdGVkRm9sZGVyXSA9IHVzZVN0YXRlPFN0cmluZyB8IHVuZGVmaW5lZD4oKVxuICAgIGNvbnN0IFtpc01vZGFsVmlzaWJsZSwgc2V0SXNNb2RhbFZpc2libGVdID0gdXNlU3RhdGUoZmFsc2UpO1xuXG4gICAgLy8gSGFuZGxlcyB0cnVuY2F0aW5nIHRoZSBwYXRlbnQgZmlsZW5hbWUgaWYgaXQncyB0b28gbG9uZ1xuICAgIGZ1bmN0aW9uIGZvcm1hdFRpdGxlKHRpdGxlOiBzdHJpbmcsIG1heExlbmd0aDogbnVtYmVyID0gMjgpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gdGl0bGUubGVuZ3RoID4gbWF4TGVuZ3RoID8gYCR7dGl0bGUuc3Vic3RyaW5nKDAsIG1heExlbmd0aCl9Li4uYCA6IHRpdGxlO1xuICAgIH1cblxuICAgIC8vIEZ1bmN0aW9uIHRvIGhhbmRsZSBmb2xkZXIgc2VsZWN0aW9uXG4gICAgY29uc3QgaGFuZGxlRm9sZGVyQ2xpY2sgPSAoZm9sZGVyTmFtZTogc3RyaW5nKSA9PiB7XG4gICAgICAgIHNldFNlbGVjdGVkRm9sZGVyKGZvbGRlck5hbWUpO1xuICAgIH07XG5cbiAgICBpZiAoaXNNb2RhbFZpc2libGUpIHtcbiAgICAgICAgcmV0dXJuIDxDcmVhdGVGb2xkZXIgb25DbG9zZT17KCkgPT4gc2V0SXNNb2RhbFZpc2libGUoZmFsc2UpfSBhbmFseXplUGF0ZW50PXthbmFseXplUGF0ZW50fSAvPjtcbiAgICB9XG5cblxuICAgIHJldHVybiAoXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBmbGV4LWNvbCBpdGVtcy1jZW50ZXIganVzdGlmeS1jZW50ZXIgbWluLWgtc2NyZWVuXCI+IHsvKiBUaGlzIGRpdiBjZW50ZXJzIHRoZSBtb2RhbCAqL31cbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBmbGV4LWNvbCBoLVs1MDBweF0gdy1bNTAwcHhdIHJvdW5kZWQteGwgYm9yZGVyIGJvcmRlci1bI0RDRTRFN10gYmctd2hpdGUgc2hhZG93LWxnIHAtNCBwYi04IGp1c3RpZnktYmV0d2VlblwiPiB7LyogTWFrZSB0aGlzIGEgZmxleCBjb2x1bW4gY29udGFpbmVyICovfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIDxkaXY+XG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwicmVsYXRpdmUgZmxvYXQtcmlnaHQgY3Vyc29yLXBvaW50ZXJcIiBvbkNsaWNrPXtvbkNsb3NlfT5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIGNsYXNzTmFtZT1cImgtNSB3LTVcIiBmaWxsPVwibm9uZVwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBzdHJva2U9XCIjMzMzMzMzXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHBhdGggc3Ryb2tlTGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlTGluZWpvaW49XCJyb3VuZFwiIHN0cm9rZVdpZHRoPVwiMlwiIGQ9XCJNNiAxOEwxOCA2TTYgNmwxMiAxMlwiIC8+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L3N2Zz5cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJwbC00IHByLTQgLW10LTRcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIHsvKiBIZWFkZXIgKi99XG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIm1iLTYgcHQtMTAgZmxleCBpdGVtcy1jZW50ZXIgc3BhY2UteC0xMFwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxwIGNsYXNzTmFtZT1cInRleHQtbGcgZm9udC1tZWRpdW0gd2hpdGVzcGFjZS1ub3dyYXBcIj5TYXZlIHRoZSBuZXcgcGF0ZW50PC9wPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBpdGVtcy1jZW50ZXIgc3BhY2UteC0xIGp1c3RpZnktY2VudGVyIFwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8RmlsZSBzaXplPXsxNH0vPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8cCBjbGFzc05hbWU9XCJ0ZXh0LXhzICB3aGl0ZXNwYWNlLW5vd3JhcFwiPntmb3JtYXRUaXRsZSh0aXRsZSEpfTwvcD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICB7LyogRm9sZGVycyBhIHVzZXIgY2FuIHNlbGVjdCBmcm9tICovfVxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGZsZXgtY29sIHNwYWNlLXktMlwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtbXCJDb21wdXRlciBWaXNpb24gZm9yIE1lZGljYWxcIiwgXCJCaW9tZWRpY2FsIERldmljZVwiLCBcIklubm92YXRpb24gU3RyYXRlZ3lcIl0ubWFwKChmb2xkZXJOYW1lKSA9PiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleT17Zm9sZGVyTmFtZX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17YGZsZXggaXRlbXMtY2VudGVyIHNwYWNlLXgtMiBib3JkZXIgYm9yZGVyLVsjREFFNUVBXSByb3VuZGVkLXhsIGJnLXdoaXRlIHB5LTIgcHgtMyAke3NlbGVjdGVkRm9sZGVyID09PSBmb2xkZXJOYW1lID8gJ2JnLVsjQkNEM0RCXScgOiAnaG92ZXI6YmctWyNCQ0QzREJdIGN1cnNvci1wb2ludGVyJ31gfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU9e3sgYm94U2hhZG93OiAnMHB4IDFweCAxMHB4IDBweCByZ2JhKDAsIDAsIDAsIDAuMTApJyB9fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DbGljaz17KCkgPT4gaGFuZGxlRm9sZGVyQ2xpY2soZm9sZGVyTmFtZSl9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxGb2xkZXIgc2l6ZT17MTV9Lz5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxwIGNsYXNzTmFtZT1cInRleHQtc21cIj57Zm9sZGVyTmFtZX08L3A+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICkpfVxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJweS0zXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgd2lkdGg9XCIyMjBcIiBoZWlnaHQ9XCIyXCIgdmlld0JveD1cIjAgMCAzNTIgMlwiIGZpbGw9XCJub25lXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9XCJNMSAxSDM1MVwiIHN0cm9rZT1cIiNEQUU1RUFcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIvPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvc3ZnPlxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHsvKiBQYXRlbnRzIHRoYXQgd2VyZSBwcmV2aW91c2x5IHNhdmVkISAqL31cbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBmbGV4LWNvbCBzcGFjZS15LTJcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXggaXRlbXMtY2VudGVyIHNwYWNlLXgtMiBib3JkZXIgYm9yZGVyLVsjREFFNUVBXSByb3VuZGVkLXhsIGJnLXdoaXRlIHB5LTIgcHgtM1wiIHN0eWxlPXt7IGJveFNoYWRvdzogJzBweCAxcHggMTBweCAwcHggcmdiYSgwLCAwLCAwLCAwLjEwKScgfX0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxGaWxlIHNpemU9ezE1fSBjb2xvcj1cIiNBMEEwQTFcIi8+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxwIGNsYXNzTmFtZT1cInRleHQtc20gdGV4dC1bI0EwQTBBMV1cIj5NZXRob2QgYW5kIEFwcGFyYXR1cyBmb3IgSW1hZ2UtQmFzZWQgTmF2aWdhdGlvbjwvcD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBpdGVtcy1jZW50ZXIgc3BhY2UteC0yIGJvcmRlciBib3JkZXItWyNEQUU1RUFdIHJvdW5kZWQteGwgYmctd2hpdGUgcHktMiBweC0zXCIgc3R5bGU9e3sgYm94U2hhZG93OiAnMHB4IDFweCAxMHB4IDBweCByZ2JhKDAsIDAsIDAsIDAuMTApJyB9fT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPEZpbGUgc2l6ZT17MTV9IGNvbG9yPVwiI0EwQTBBMVwiLz5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHAgY2xhc3NOYW1lPVwidGV4dC1zbSB0ZXh0LVsjQTBBMEExXVwiPlNpbmdsZSBzaWRlZCBsaWdodC1hY3R1YXRlZCBtaWNyb2ZsdWlkaWMgZGV2aWNlIHdpdGguLi48L3A+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cblxuICAgICAgICAgICAgICAgIHsvKiBCdXR0b25zICovfVxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBqdXN0aWZ5LWJldHdlZW4gaXRlbXMtY2VudGVyIHctZnVsbCBwbC00IHByLTQgbXQtNlwiPlxuICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIFxuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiZmxleCBpdGVtcy1jZW50ZXIganVzdGlmeS1jZW50ZXIgaC1bMzBweF0gcHgtNCBweS0yIGJnLXdoaXRlIGJvcmRlciBib3JkZXItWyNEQ0U0RTddIHJvdW5kZWQtbWQgcm91bmRlZCBob3ZlcjpiZy1ncmF5LTMwMCBob3Zlcjp0ZXh0LWJsYWNrIHRleHQtc20gd2hpdGVzcGFjZS1ub3dyYXBcIlxuICAgICAgICAgICAgICAgICAgICAgICAgb25DbGljaz17KCkgPT4gc2V0SXNNb2RhbFZpc2libGUodHJ1ZSl9XG4gICAgICAgICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQ3JlYXRlIE5ldyBGb2xkZXJcbiAgICAgICAgICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBzcGFjZS14LTRcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b24gXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiZmxleCBpdGVtcy1jZW50ZXIganVzdGlmeS1jZW50ZXIgaC1bMzBweF0gcHgtNCBweS0yIGJnLXdoaXRlIGJvcmRlciBib3JkZXItWyNEQ0U0RTddIHJvdW5kZWQtbWQgcm91bmRlZCBob3ZlcjpiZy1ncmF5LTMwMCBob3Zlcjp0ZXh0LWJsYWNrIHRleHQtc20gd2hpdGVzcGFjZS1ub3dyYXBcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9e2FuYWx5emVQYXRlbnR9PiAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgU2tpcCBTYXZpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBjbGFzc05hbWU9XCJmbGV4IGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWNlbnRlciBoLVszMHB4XSBweC00IHB5LTIgYmctWyM1OTgwOENdIHRleHQtd2hpdGUgYm9yZGVyIGJvcmRlci1bI0RDRTRFN10gcm91bmRlZC1tZCByb3VuZGVkIGhvdmVyOmJnLWdyYXktNjAwIHRleHQtc20gd2hpdGVzcGFjZS1ub3dyYXBcIj5TYXZlPC9idXR0b24+XG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgICBcbiAgICAgICAgPC9kaXY+XG4gICAgKTtcbn1cbmV4cG9ydCBkZWZhdWx0IFNhdmVQYXRlbnQ7Il0sIm5hbWVzIjpbInVzZVN0YXRlIiwiRm9sZGVyIiwiRmlsZSIsIkNyZWF0ZUZvbGRlciIsIlNhdmVQYXRlbnQiLCJvbkNsb3NlIiwidGl0bGUiLCJhbmFseXplUGF0ZW50Iiwic2VsZWN0ZWRGb2xkZXIiLCJzZXRTZWxlY3RlZEZvbGRlciIsImlzTW9kYWxWaXNpYmxlIiwic2V0SXNNb2RhbFZpc2libGUiLCJmb3JtYXRUaXRsZSIsIm1heExlbmd0aCIsImxlbmd0aCIsInN1YnN0cmluZyIsImhhbmRsZUZvbGRlckNsaWNrIiwiZm9sZGVyTmFtZSIsImRpdiIsImNsYXNzTmFtZSIsIm9uQ2xpY2siLCJzdmciLCJ4bWxucyIsImZpbGwiLCJ2aWV3Qm94Iiwic3Ryb2tlIiwicGF0aCIsInN0cm9rZUxpbmVjYXAiLCJzdHJva2VMaW5lam9pbiIsInN0cm9rZVdpZHRoIiwiZCIsInAiLCJzaXplIiwibWFwIiwic3R5bGUiLCJib3hTaGFkb3ciLCJ3aWR0aCIsImhlaWdodCIsInN0cm9rZS1saW5lY2FwIiwiY29sb3IiLCJidXR0b24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./components/modals/SavePatent.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./lib/features/analyzeSlice.tsx":
/*!***************************************!*\
  !*** ./lib/features/analyzeSlice.tsx ***!
  \***************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   analyzeSlice: function() { return /* binding */ analyzeSlice; },\n/* harmony export */   folders: function() { return /* binding */ folders; },\n/* harmony export */   patents: function() { return /* binding */ patents; },\n/* harmony export */   selectedPatent: function() { return /* binding */ selectedPatent; },\n/* harmony export */   storeFile: function() { return /* binding */ storeFile; }\n/* harmony export */ });\n/* harmony import */ var _reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @reduxjs/toolkit */ \"(app-pages-browser)/./node_modules/@reduxjs/toolkit/dist/redux-toolkit.modern.mjs\");\n\n// Define the initial state using that type\nconst initialState = {\n    selectedPatent: {\n        title: \"\",\n        folder: \"\",\n        date: \"\",\n        tags: [\n            \"\"\n        ],\n        status: \"\",\n        patentId: \"\",\n        url: \"\",\n        problem: \"\",\n        problemKeywords: [],\n        solution: \"\",\n        solutionKeywords: [],\n        summary: \"\",\n        fulltext: \"\"\n    },\n    patents: [\n        {\n            title: \"Microfluidic device for deformable beads enrichment and self-regulated ordering and encapsulation in droplets\",\n            folder: \"Microfluidics\",\n            date: \"\",\n            tags: [\n                \"Microfluidics\",\n                \"Droplets\"\n            ],\n            status: \"Pending\",\n            patentId: \"US20210331174A1\",\n            url: \"/examples/US20210331174A1.pdf\",\n            problem: \"The patent addresses the challenges of achieving robust ordered delivery of deformable beads in microfluidic devices, as well as the difficulty in achieving high percentage singlet encapsulation with a constant pressure source system.\",\n            problemKeywords: [\n                \"microfluidics\",\n                \"beads\",\n                \"singlet encapsulation\"\n            ],\n            solution: \"The inventors developed a microfluidic device that can reliably achieve high percentage singlet encapsulation with a constant pressure source system. This was achieved through the development of a pinch and reservoir sequence system for beads concentrating and delivery frequency stabilizing, as well as the design of a long funnel to guide and align deformable beads into a single row, and a core design to achieve self-regulated beads in droplets encapsulation within a constant pressure system.\",\n            solutionKeywords: [\n                \"pinch and reservoir\",\n                \"funnel\"\n            ],\n            summary: \"This invention introduces a novel microfluidic device designed to improve the handling and processing of deformable beads in a controlled environment. The device features a series of inlets and microfluidic channels that facilitate the encapsulation of these beads into droplets, a method that is crucial for advancing laboratory assays such as single-cell analyses and other microreactor applications.\",\n            fulltext: \"\"\n        },\n        {\n            title: \"Method and Apparatus for Image-Based Navigation\",\n            folder: \"Skeletal Navigation\",\n            date: \"\",\n            tags: [\n                \"MapNav\",\n                \"Surgical\"\n            ],\n            status: \"Pending\",\n            patentId: \"US20240024042A1\",\n            url: \"/examples/US20240024042A1.pdf\",\n            problem: \"\",\n            problemKeywords: [],\n            solution: \"\",\n            solutionKeywords: [],\n            summary: \"\",\n            fulltext: \"\"\n        },\n        {\n            title: \"Single sided light-actuated microfluidic device with integrated mesh ground\",\n            folder: \"Microfluidics\",\n            date: \"\",\n            tags: [\n                \"Microfluidics\",\n                \"Optowetting\"\n            ],\n            status: \"Active\",\n            patentId: \"US9815056B2\",\n            url: \"/examples/US9815056.pdf\",\n            problem: \"\",\n            problemKeywords: [],\n            solution: \"\",\n            solutionKeywords: [],\n            summary: \"\",\n            fulltext: \"\"\n        }\n    ],\n    folders: [\n        {\n            name: \"Microfluidics\",\n            date: \"April 29, 2024\"\n        },\n        {\n            name: \"Skeletal Navigation\",\n            date: \"15:33 PM today\"\n        }\n    ]\n};\nconst analyzeSlice = (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__.createSlice)({\n    name: \"analyze\",\n    // `createSlice` will infer the state type from the `initialState` argument\n    initialState,\n    reducers: {\n        // Use the PayloadAction type to declare the contents of `action.payload`\n        storeFile: (state, action)=>{\n            state.selectedPatent = action.payload;\n        }\n    }\n});\nconst { storeFile } = analyzeSlice.actions;\nconst selectedPatent = (state)=>state.analyze.selectedPatent;\nconst patents = (state)=>state.analyze.patents;\nconst folders = (state)=>state.analyze.folders;\n/* harmony default export */ __webpack_exports__[\"default\"] = (analyzeSlice.reducer);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9mZWF0dXJlcy9hbmFseXplU2xpY2UudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUE2RDtBQW1CN0QsMkNBQTJDO0FBQzNDLE1BQU1DLGVBQTZCO0lBQ2pDQyxnQkFBZ0I7UUFDZEMsT0FBTztRQUNQQyxRQUFRO1FBQ1JDLE1BQU07UUFDTkMsTUFBTTtZQUFDO1NBQUc7UUFDVkMsUUFBUTtRQUNSQyxVQUFVO1FBQ1ZDLEtBQUs7UUFDTEMsU0FBUztRQUNUQyxpQkFBaUIsRUFBRTtRQUNuQkMsVUFBVTtRQUNWQyxrQkFBa0IsRUFBRTtRQUNwQkMsU0FBUztRQUNUQyxVQUFVO0lBQ1o7SUFDQUMsU0FBUztRQUNQO1lBQ0ViLE9BQU87WUFDUEMsUUFBUTtZQUNSQyxNQUFNO1lBQ05DLE1BQU07Z0JBQUM7Z0JBQWlCO2FBQVc7WUFDbkNDLFFBQVE7WUFDUkMsVUFBVTtZQUNWQyxLQUFLO1lBQ0xDLFNBQVM7WUFDVEMsaUJBQWlCO2dCQUFDO2dCQUFpQjtnQkFBUzthQUF3QjtZQUNwRUMsVUFBVTtZQUNWQyxrQkFBa0I7Z0JBQUM7Z0JBQXVCO2FBQVM7WUFDbkRDLFNBQVM7WUFDVEMsVUFBVTtRQUNaO1FBQ0E7WUFDRVosT0FBTztZQUNQQyxRQUFRO1lBQ1JDLE1BQU07WUFDTkMsTUFBTTtnQkFBQztnQkFBVTthQUFXO1lBQzVCQyxRQUFRO1lBQ1JDLFVBQVU7WUFDVkMsS0FBSztZQUNMQyxTQUFTO1lBQ1RDLGlCQUFpQixFQUFFO1lBQ25CQyxVQUFVO1lBQ1ZDLGtCQUFrQixFQUFFO1lBQ3BCQyxTQUFTO1lBQ1RDLFVBQVU7UUFDWjtRQUNBO1lBQ0VaLE9BQU87WUFDUEMsUUFBUTtZQUNSQyxNQUFNO1lBQ05DLE1BQU07Z0JBQUM7Z0JBQWlCO2FBQWM7WUFDdENDLFFBQVE7WUFDUkMsVUFBVTtZQUNWQyxLQUFLO1lBQ0xDLFNBQVM7WUFDVEMsaUJBQWlCLEVBQUU7WUFDbkJDLFVBQVU7WUFDVkMsa0JBQWtCLEVBQUU7WUFDcEJDLFNBQVM7WUFDVEMsVUFBVTtRQUNaO0tBQ0Q7SUFDREUsU0FBUztRQUNQO1lBQUNDLE1BQU07WUFBaUJiLE1BQU07UUFBZ0I7UUFDOUM7WUFBQ2EsTUFBTTtZQUF1QmIsTUFBTTtRQUFnQjtLQUNyRDtBQUNIO0FBRU8sTUFBTWMsZUFBZW5CLDZEQUFXQSxDQUFDO0lBQ3RDa0IsTUFBTTtJQUNOLDJFQUEyRTtJQUMzRWpCO0lBQ0FtQixVQUFVO1FBQ1IseUVBQXlFO1FBQ3pFQyxXQUFXLENBQUNDLE9BQU9DO1lBQ2pCRCxNQUFNcEIsY0FBYyxHQUFHcUIsT0FBT0MsT0FBTztRQUN2QztJQUNGO0FBQ0YsR0FBRTtBQUVLLE1BQU0sRUFBRUgsU0FBUyxFQUFFLEdBQUdGLGFBQWFNLE9BQU87QUFDMUMsTUFBTXZCLGlCQUFpQixDQUFDb0IsUUFBcUJBLE1BQU1JLE9BQU8sQ0FBQ3hCLGNBQWM7QUFDekUsTUFBTWMsVUFBVSxDQUFDTSxRQUFxQkEsTUFBTUksT0FBTyxDQUFDVixPQUFPO0FBQzNELE1BQU1DLFVBQVUsQ0FBQ0ssUUFBcUJBLE1BQU1JLE9BQU8sQ0FBQ1QsT0FBTztBQUNsRSwrREFBZUUsYUFBYVEsT0FBTyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9saWIvZmVhdHVyZXMvYW5hbHl6ZVNsaWNlLnRzeD9mMWIwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNyZWF0ZVNsaWNlLCBQYXlsb2FkQWN0aW9uIH0gZnJvbSAnQHJlZHV4anMvdG9vbGtpdCdcbmltcG9ydCB0eXBlIHsgUm9vdFN0YXRlIH0gZnJvbSAnLi4vc3RvcmUnO1xuaW1wb3J0IFBhdGVudEluZm8gZnJvbSBcIkAvY29tcG9uZW50cy9QYXRlbnRJbmZvXCI7XG5cblxuZXhwb3J0IGludGVyZmFjZSBGb2xkZXIge1xuICBuYW1lOiBzdHJpbmc7XG4gIGRhdGU6IHN0cmluZyxcbn1cblxuZXhwb3J0IGludGVyZmFjZSBBbmFseXplU3RhdGUge1xuICBzZWxlY3RlZFBhdGVudDogUGF0ZW50SW5mbyxcbiAgcGF0ZW50czogQXJyYXk8UGF0ZW50SW5mbz4sXG4gIGZvbGRlcnM6IEFycmF5PEZvbGRlcj4sXG59XG5cblxuXG5cbi8vIERlZmluZSB0aGUgaW5pdGlhbCBzdGF0ZSB1c2luZyB0aGF0IHR5cGVcbmNvbnN0IGluaXRpYWxTdGF0ZTogQW5hbHl6ZVN0YXRlID0ge1xuICBzZWxlY3RlZFBhdGVudDoge1xuICAgIHRpdGxlOiBcIlwiLFxuICAgIGZvbGRlcjogXCJcIixcbiAgICBkYXRlOiBcIlwiLFxuICAgIHRhZ3M6IFtcIlwiXSxcbiAgICBzdGF0dXM6IFwiXCIsXG4gICAgcGF0ZW50SWQ6IFwiXCIsXG4gICAgdXJsOiBcIlwiLFxuICAgIHByb2JsZW06IFwiXCIsXG4gICAgcHJvYmxlbUtleXdvcmRzOiBbXSxcbiAgICBzb2x1dGlvbjogXCJcIixcbiAgICBzb2x1dGlvbktleXdvcmRzOiBbXSxcbiAgICBzdW1tYXJ5OiBcIlwiLFxuICAgIGZ1bGx0ZXh0OiBcIlwiLFxuICB9LFxuICBwYXRlbnRzOiBbXG4gICAge1xuICAgICAgdGl0bGU6IFwiTWljcm9mbHVpZGljIGRldmljZSBmb3IgZGVmb3JtYWJsZSBiZWFkcyBlbnJpY2htZW50IGFuZCBzZWxmLXJlZ3VsYXRlZCBvcmRlcmluZyBhbmQgZW5jYXBzdWxhdGlvbiBpbiBkcm9wbGV0c1wiLFxuICAgICAgZm9sZGVyOiBcIk1pY3JvZmx1aWRpY3NcIixcbiAgICAgIGRhdGU6IFwiXCIsXG4gICAgICB0YWdzOiBbXCJNaWNyb2ZsdWlkaWNzXCIsIFwiRHJvcGxldHNcIl0sXG4gICAgICBzdGF0dXM6IFwiUGVuZGluZ1wiLFxuICAgICAgcGF0ZW50SWQ6IFwiVVMyMDIxMDMzMTE3NEExXCIsXG4gICAgICB1cmw6IFwiL2V4YW1wbGVzL1VTMjAyMTAzMzExNzRBMS5wZGZcIixcbiAgICAgIHByb2JsZW06IFwiVGhlIHBhdGVudCBhZGRyZXNzZXMgdGhlIGNoYWxsZW5nZXMgb2YgYWNoaWV2aW5nIHJvYnVzdCBvcmRlcmVkIGRlbGl2ZXJ5IG9mIGRlZm9ybWFibGUgYmVhZHMgaW4gbWljcm9mbHVpZGljIGRldmljZXMsIGFzIHdlbGwgYXMgdGhlIGRpZmZpY3VsdHkgaW4gYWNoaWV2aW5nIGhpZ2ggcGVyY2VudGFnZSBzaW5nbGV0IGVuY2Fwc3VsYXRpb24gd2l0aCBhIGNvbnN0YW50IHByZXNzdXJlIHNvdXJjZSBzeXN0ZW0uXCIsXG4gICAgICBwcm9ibGVtS2V5d29yZHM6IFtcIm1pY3JvZmx1aWRpY3NcIiwgXCJiZWFkc1wiLCBcInNpbmdsZXQgZW5jYXBzdWxhdGlvblwiXSxcbiAgICAgIHNvbHV0aW9uOiBcIlRoZSBpbnZlbnRvcnMgZGV2ZWxvcGVkIGEgbWljcm9mbHVpZGljIGRldmljZSB0aGF0IGNhbiByZWxpYWJseSBhY2hpZXZlIGhpZ2ggcGVyY2VudGFnZSBzaW5nbGV0IGVuY2Fwc3VsYXRpb24gd2l0aCBhIGNvbnN0YW50IHByZXNzdXJlIHNvdXJjZSBzeXN0ZW0uIFRoaXMgd2FzIGFjaGlldmVkIHRocm91Z2ggdGhlIGRldmVsb3BtZW50IG9mIGEgcGluY2ggYW5kIHJlc2Vydm9pciBzZXF1ZW5jZSBzeXN0ZW0gZm9yIGJlYWRzIGNvbmNlbnRyYXRpbmcgYW5kIGRlbGl2ZXJ5IGZyZXF1ZW5jeSBzdGFiaWxpemluZywgYXMgd2VsbCBhcyB0aGUgZGVzaWduIG9mIGEgbG9uZyBmdW5uZWwgdG8gZ3VpZGUgYW5kIGFsaWduIGRlZm9ybWFibGUgYmVhZHMgaW50byBhIHNpbmdsZSByb3csIGFuZCBhIGNvcmUgZGVzaWduIHRvIGFjaGlldmUgc2VsZi1yZWd1bGF0ZWQgYmVhZHMgaW4gZHJvcGxldHMgZW5jYXBzdWxhdGlvbiB3aXRoaW4gYSBjb25zdGFudCBwcmVzc3VyZSBzeXN0ZW0uXCIsXG4gICAgICBzb2x1dGlvbktleXdvcmRzOiBbXCJwaW5jaCBhbmQgcmVzZXJ2b2lyXCIsIFwiZnVubmVsXCJdLFxuICAgICAgc3VtbWFyeTogXCJUaGlzIGludmVudGlvbiBpbnRyb2R1Y2VzIGEgbm92ZWwgbWljcm9mbHVpZGljIGRldmljZSBkZXNpZ25lZCB0byBpbXByb3ZlIHRoZSBoYW5kbGluZyBhbmQgcHJvY2Vzc2luZyBvZiBkZWZvcm1hYmxlIGJlYWRzIGluIGEgY29udHJvbGxlZCBlbnZpcm9ubWVudC4gVGhlIGRldmljZSBmZWF0dXJlcyBhIHNlcmllcyBvZiBpbmxldHMgYW5kIG1pY3JvZmx1aWRpYyBjaGFubmVscyB0aGF0IGZhY2lsaXRhdGUgdGhlIGVuY2Fwc3VsYXRpb24gb2YgdGhlc2UgYmVhZHMgaW50byBkcm9wbGV0cywgYSBtZXRob2QgdGhhdCBpcyBjcnVjaWFsIGZvciBhZHZhbmNpbmcgbGFib3JhdG9yeSBhc3NheXMgc3VjaCBhcyBzaW5nbGUtY2VsbCBhbmFseXNlcyBhbmQgb3RoZXIgbWljcm9yZWFjdG9yIGFwcGxpY2F0aW9ucy5cIixcbiAgICAgIGZ1bGx0ZXh0OiBcIlwiXG4gICAgfSxcbiAgICB7XG4gICAgICB0aXRsZTogXCJNZXRob2QgYW5kIEFwcGFyYXR1cyBmb3IgSW1hZ2UtQmFzZWQgTmF2aWdhdGlvblwiLFxuICAgICAgZm9sZGVyOiBcIlNrZWxldGFsIE5hdmlnYXRpb25cIixcbiAgICAgIGRhdGU6IFwiXCIsXG4gICAgICB0YWdzOiBbXCJNYXBOYXZcIiwgXCJTdXJnaWNhbFwiXSxcbiAgICAgIHN0YXR1czogXCJQZW5kaW5nXCIsXG4gICAgICBwYXRlbnRJZDogXCJVUzIwMjQwMDI0MDQyQTFcIixcbiAgICAgIHVybDogXCIvZXhhbXBsZXMvVVMyMDI0MDAyNDA0MkExLnBkZlwiLFxuICAgICAgcHJvYmxlbTogXCJcIixcbiAgICAgIHByb2JsZW1LZXl3b3JkczogW10sXG4gICAgICBzb2x1dGlvbjogXCJcIixcbiAgICAgIHNvbHV0aW9uS2V5d29yZHM6IFtdLFxuICAgICAgc3VtbWFyeTogXCJcIixcbiAgICAgIGZ1bGx0ZXh0OiBcIlwiXG4gICAgfSxcbiAgICB7XG4gICAgICB0aXRsZTogXCJTaW5nbGUgc2lkZWQgbGlnaHQtYWN0dWF0ZWQgbWljcm9mbHVpZGljIGRldmljZSB3aXRoIGludGVncmF0ZWQgbWVzaCBncm91bmRcIixcbiAgICAgIGZvbGRlcjogXCJNaWNyb2ZsdWlkaWNzXCIsXG4gICAgICBkYXRlOiBcIlwiLFxuICAgICAgdGFnczogW1wiTWljcm9mbHVpZGljc1wiLCBcIk9wdG93ZXR0aW5nXCJdLFxuICAgICAgc3RhdHVzOiBcIkFjdGl2ZVwiLFxuICAgICAgcGF0ZW50SWQ6IFwiVVM5ODE1MDU2QjJcIixcbiAgICAgIHVybDogXCIvZXhhbXBsZXMvVVM5ODE1MDU2LnBkZlwiLFxuICAgICAgcHJvYmxlbTogXCJcIixcbiAgICAgIHByb2JsZW1LZXl3b3JkczogW10sXG4gICAgICBzb2x1dGlvbjogXCJcIixcbiAgICAgIHNvbHV0aW9uS2V5d29yZHM6IFtdLFxuICAgICAgc3VtbWFyeTogXCJcIixcbiAgICAgIGZ1bGx0ZXh0OiBcIlwiXG4gICAgfSxcbiAgXSxcbiAgZm9sZGVyczogW1xuICAgIHtuYW1lOiBcIk1pY3JvZmx1aWRpY3NcIiwgZGF0ZTogXCJBcHJpbCAyOSwgMjAyNFwifSwgXG4gICAge25hbWU6IFwiU2tlbGV0YWwgTmF2aWdhdGlvblwiLCBkYXRlOiBcIjE1OjMzIFBNIHRvZGF5XCJ9XG4gIF1cbn1cblxuZXhwb3J0IGNvbnN0IGFuYWx5emVTbGljZSA9IGNyZWF0ZVNsaWNlKHtcbiAgbmFtZTogJ2FuYWx5emUnLFxuICAvLyBgY3JlYXRlU2xpY2VgIHdpbGwgaW5mZXIgdGhlIHN0YXRlIHR5cGUgZnJvbSB0aGUgYGluaXRpYWxTdGF0ZWAgYXJndW1lbnRcbiAgaW5pdGlhbFN0YXRlLFxuICByZWR1Y2Vyczoge1xuICAgIC8vIFVzZSB0aGUgUGF5bG9hZEFjdGlvbiB0eXBlIHRvIGRlY2xhcmUgdGhlIGNvbnRlbnRzIG9mIGBhY3Rpb24ucGF5bG9hZGBcbiAgICBzdG9yZUZpbGU6IChzdGF0ZSwgYWN0aW9uOiBQYXlsb2FkQWN0aW9uPFBhdGVudEluZm8+KSA9PiB7XG4gICAgICBzdGF0ZS5zZWxlY3RlZFBhdGVudCA9IGFjdGlvbi5wYXlsb2FkO1xuICAgIH1cbiAgfVxufSlcblxuZXhwb3J0IGNvbnN0IHsgc3RvcmVGaWxlIH0gPSBhbmFseXplU2xpY2UuYWN0aW9uc1xuZXhwb3J0IGNvbnN0IHNlbGVjdGVkUGF0ZW50ID0gKHN0YXRlOiBSb290U3RhdGUpID0+IHN0YXRlLmFuYWx5emUuc2VsZWN0ZWRQYXRlbnRcbmV4cG9ydCBjb25zdCBwYXRlbnRzID0gKHN0YXRlOiBSb290U3RhdGUpID0+IHN0YXRlLmFuYWx5emUucGF0ZW50c1xuZXhwb3J0IGNvbnN0IGZvbGRlcnMgPSAoc3RhdGU6IFJvb3RTdGF0ZSkgPT4gc3RhdGUuYW5hbHl6ZS5mb2xkZXJzXG5leHBvcnQgZGVmYXVsdCBhbmFseXplU2xpY2UucmVkdWNlciJdLCJuYW1lcyI6WyJjcmVhdGVTbGljZSIsImluaXRpYWxTdGF0ZSIsInNlbGVjdGVkUGF0ZW50IiwidGl0bGUiLCJmb2xkZXIiLCJkYXRlIiwidGFncyIsInN0YXR1cyIsInBhdGVudElkIiwidXJsIiwicHJvYmxlbSIsInByb2JsZW1LZXl3b3JkcyIsInNvbHV0aW9uIiwic29sdXRpb25LZXl3b3JkcyIsInN1bW1hcnkiLCJmdWxsdGV4dCIsInBhdGVudHMiLCJmb2xkZXJzIiwibmFtZSIsImFuYWx5emVTbGljZSIsInJlZHVjZXJzIiwic3RvcmVGaWxlIiwic3RhdGUiLCJhY3Rpb24iLCJwYXlsb2FkIiwiYWN0aW9ucyIsImFuYWx5emUiLCJyZWR1Y2VyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/features/analyzeSlice.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./lib/hooks.tsx":
/*!***********************!*\
  !*** ./lib/hooks.tsx ***!
  \***********************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useAppDispatch: function() { return /* binding */ useAppDispatch; },\n/* harmony export */   useAppSelector: function() { return /* binding */ useAppSelector; },\n/* harmony export */   useAppStore: function() { return /* binding */ useAppStore; }\n/* harmony export */ });\n/* harmony import */ var react_redux__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react-redux */ \"(app-pages-browser)/./node_modules/react-redux/dist/react-redux.mjs\");\n/* __next_internal_client_entry_do_not_use__ useAppDispatch,useAppSelector,useAppStore auto */ \n// Use throughout your app instead of plain `useDispatch` and `useSelector`\nconst useAppDispatch = react_redux__WEBPACK_IMPORTED_MODULE_0__.useDispatch.withTypes();\nconst useAppSelector = react_redux__WEBPACK_IMPORTED_MODULE_0__.useSelector.withTypes();\nconst useAppStore = react_redux__WEBPACK_IMPORTED_MODULE_0__.useStore.withTypes();\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9ob29rcy50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7OzsrRkFDZ0U7QUFHaEUsMkVBQTJFO0FBQ3BFLE1BQU1HLGlCQUFpQkgsb0RBQVdBLENBQUNJLFNBQVMsR0FBZTtBQUMzRCxNQUFNQyxpQkFBaUJKLG9EQUFXQSxDQUFDRyxTQUFTLEdBQWE7QUFDekQsTUFBTUUsY0FBY0osaURBQVFBLENBQUNFLFNBQVMsR0FBWSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9saWIvaG9va3MudHN4PzRlNDMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnXG5pbXBvcnQgeyB1c2VEaXNwYXRjaCwgdXNlU2VsZWN0b3IsIHVzZVN0b3JlIH0gZnJvbSAncmVhY3QtcmVkdXgnXG5pbXBvcnQgdHlwZSB7IEFwcERpc3BhdGNoLCBBcHBTdG9yZSwgUm9vdFN0YXRlIH0gZnJvbSAnLi9zdG9yZSdcblxuLy8gVXNlIHRocm91Z2hvdXQgeW91ciBhcHAgaW5zdGVhZCBvZiBwbGFpbiBgdXNlRGlzcGF0Y2hgIGFuZCBgdXNlU2VsZWN0b3JgXG5leHBvcnQgY29uc3QgdXNlQXBwRGlzcGF0Y2ggPSB1c2VEaXNwYXRjaC53aXRoVHlwZXM8QXBwRGlzcGF0Y2g+KClcbmV4cG9ydCBjb25zdCB1c2VBcHBTZWxlY3RvciA9IHVzZVNlbGVjdG9yLndpdGhUeXBlczxSb290U3RhdGU+KClcbmV4cG9ydCBjb25zdCB1c2VBcHBTdG9yZSA9IHVzZVN0b3JlLndpdGhUeXBlczxBcHBTdG9yZT4oKSJdLCJuYW1lcyI6WyJ1c2VEaXNwYXRjaCIsInVzZVNlbGVjdG9yIiwidXNlU3RvcmUiLCJ1c2VBcHBEaXNwYXRjaCIsIndpdGhUeXBlcyIsInVzZUFwcFNlbGVjdG9yIiwidXNlQXBwU3RvcmUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/hooks.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js ***!
  \****************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * react-jsx-dev-runtime.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nif (true) {\n  (function() {\n'use strict';\n\nvar React = __webpack_require__(/*! next/dist/compiled/react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n\n// ATTENTION\n// When adding new symbols to this file,\n// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n// The Symbol used to tag the ReactElement-like types.\nvar REACT_ELEMENT_TYPE = Symbol.for('react.element');\nvar REACT_PORTAL_TYPE = Symbol.for('react.portal');\nvar REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');\nvar REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode');\nvar REACT_PROFILER_TYPE = Symbol.for('react.profiler');\nvar REACT_PROVIDER_TYPE = Symbol.for('react.provider'); // TODO: Delete with enableRenderableContext\n\nvar REACT_CONSUMER_TYPE = Symbol.for('react.consumer');\nvar REACT_CONTEXT_TYPE = Symbol.for('react.context');\nvar REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');\nvar REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');\nvar REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');\nvar REACT_MEMO_TYPE = Symbol.for('react.memo');\nvar REACT_LAZY_TYPE = Symbol.for('react.lazy');\nvar REACT_OFFSCREEN_TYPE = Symbol.for('react.offscreen');\nvar REACT_CACHE_TYPE = Symbol.for('react.cache');\nvar MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\nvar FAUX_ITERATOR_SYMBOL = '@@iterator';\nfunction getIteratorFn(maybeIterable) {\n  if (maybeIterable === null || typeof maybeIterable !== 'object') {\n    return null;\n  }\n\n  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n\n  if (typeof maybeIterator === 'function') {\n    return maybeIterator;\n  }\n\n  return null;\n}\n\nvar ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n\nfunction error(format) {\n  {\n    {\n      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        args[_key2 - 1] = arguments[_key2];\n      }\n\n      printWarning('error', format, args);\n    }\n  }\n}\n\nfunction printWarning(level, format, args) {\n  // When changing this logic, you might want to also\n  // update consoleWithStackDev.www.js as well.\n  {\n    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n    var stack = ReactDebugCurrentFrame.getStackAddendum();\n\n    if (stack !== '') {\n      format += '%s';\n      args = args.concat([stack]);\n    } // eslint-disable-next-line react-internal/safe-string-coercion\n\n\n    var argsWithFormat = args.map(function (item) {\n      return String(item);\n    }); // Careful: RN currently depends on this prefix\n\n    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it\n    // breaks IE9: https://github.com/facebook/react/issues/13610\n    // eslint-disable-next-line react-internal/no-production-logging\n\n    Function.prototype.apply.call(console[level], console, argsWithFormat);\n  }\n}\n\n// -----------------------------------------------------------------------------\n\nvar enableScopeAPI = false; // Experimental Create Event Handle API.\nvar enableCacheElement = false;\nvar enableTransitionTracing = false; // No known bugs, but needs performance testing\n\nvar enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber\nvar enableRenderableContext = false;\n// stuff. Intended to enable React core members to more easily debug scheduling\n// issues in DEV builds.\n\nvar enableDebugTracing = false;\n\nfunction getWrappedName(outerType, innerType, wrapperName) {\n  var displayName = outerType.displayName;\n\n  if (displayName) {\n    return displayName;\n  }\n\n  var functionName = innerType.displayName || innerType.name || '';\n  return functionName !== '' ? wrapperName + \"(\" + functionName + \")\" : wrapperName;\n} // Keep in sync with react-reconciler/getComponentNameFromFiber\n\n\nfunction getContextName(type) {\n  return type.displayName || 'Context';\n}\n\nvar REACT_CLIENT_REFERENCE$2 = Symbol.for('react.client.reference'); // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.\n\nfunction getComponentNameFromType(type) {\n  if (type == null) {\n    // Host root, text node or just invalid type.\n    return null;\n  }\n\n  if (typeof type === 'function') {\n    if (type.$$typeof === REACT_CLIENT_REFERENCE$2) {\n      // TODO: Create a convention for naming client references with debug info.\n      return null;\n    }\n\n    return type.displayName || type.name || null;\n  }\n\n  if (typeof type === 'string') {\n    return type;\n  }\n\n  switch (type) {\n    case REACT_FRAGMENT_TYPE:\n      return 'Fragment';\n\n    case REACT_PORTAL_TYPE:\n      return 'Portal';\n\n    case REACT_PROFILER_TYPE:\n      return 'Profiler';\n\n    case REACT_STRICT_MODE_TYPE:\n      return 'StrictMode';\n\n    case REACT_SUSPENSE_TYPE:\n      return 'Suspense';\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return 'SuspenseList';\n\n    case REACT_CACHE_TYPE:\n      {\n        return 'Cache';\n      }\n\n  }\n\n  if (typeof type === 'object') {\n    {\n      if (typeof type.tag === 'number') {\n        error('Received an unexpected object in getComponentNameFromType(). ' + 'This is likely a bug in React. Please file an issue.');\n      }\n    }\n\n    switch (type.$$typeof) {\n      case REACT_PROVIDER_TYPE:\n        {\n          var provider = type;\n          return getContextName(provider._context) + '.Provider';\n        }\n\n      case REACT_CONTEXT_TYPE:\n        var context = type;\n\n        {\n          return getContextName(context) + '.Consumer';\n        }\n\n      case REACT_CONSUMER_TYPE:\n        {\n          return null;\n        }\n\n      case REACT_FORWARD_REF_TYPE:\n        return getWrappedName(type, type.render, 'ForwardRef');\n\n      case REACT_MEMO_TYPE:\n        var outerName = type.displayName || null;\n\n        if (outerName !== null) {\n          return outerName;\n        }\n\n        return getComponentNameFromType(type.type) || 'Memo';\n\n      case REACT_LAZY_TYPE:\n        {\n          var lazyComponent = type;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n\n          try {\n            return getComponentNameFromType(init(payload));\n          } catch (x) {\n            return null;\n          }\n        }\n    }\n  }\n\n  return null;\n}\n\n// $FlowFixMe[method-unbinding]\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nvar assign = Object.assign;\n\n/*\n * The `'' + value` pattern (used in perf-sensitive code) throws for Symbol\n * and Temporal.* types. See https://github.com/facebook/react/pull/22064.\n *\n * The functions in this module will throw an easier-to-understand,\n * easier-to-debug exception with a clear errors message message explaining the\n * problem. (Instead of a confusing exception thrown inside the implementation\n * of the `value` object).\n */\n// $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\nfunction typeName(value) {\n  {\n    // toStringTag is needed for namespaced types like Temporal.Instant\n    var hasToStringTag = typeof Symbol === 'function' && Symbol.toStringTag;\n    var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || 'Object'; // $FlowFixMe[incompatible-return]\n\n    return type;\n  }\n} // $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\n\n\nfunction willCoercionThrow(value) {\n  {\n    try {\n      testStringCoercion(value);\n      return false;\n    } catch (e) {\n      return true;\n    }\n  }\n}\n\nfunction testStringCoercion(value) {\n  // If you ended up here by following an exception call stack, here's what's\n  // happened: you supplied an object or symbol value to React (as a prop, key,\n  // DOM attribute, CSS property, string ref, etc.) and when React tried to\n  // coerce it to a string using `'' + value`, an exception was thrown.\n  //\n  // The most common types that will cause this exception are `Symbol` instances\n  // and Temporal objects like `Temporal.Instant`. But any object that has a\n  // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this\n  // exception. (Library authors do this to prevent users from using built-in\n  // numeric operators like `+` or comparison operators like `>=` because custom\n  // methods are needed to perform accurate arithmetic or comparison.)\n  //\n  // To fix the problem, coerce this object or symbol value to a string before\n  // passing it to React. The most reliable way is usually `String(value)`.\n  //\n  // To find which value is throwing, check the browser or debugger console.\n  // Before this exception was thrown, there should be `console.error` output\n  // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the\n  // problem and how that type was used: key, atrribute, input value prop, etc.\n  // In most cases, this console output also shows the component and its\n  // ancestor components where the exception happened.\n  //\n  // eslint-disable-next-line react-internal/safe-string-coercion\n  return '' + value;\n}\nfunction checkKeyStringCoercion(value) {\n  {\n    if (willCoercionThrow(value)) {\n      error('The provided key is an unsupported type %s.' + ' This value must be coerced to a string before using it here.', typeName(value));\n\n      return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n    }\n  }\n}\n\nvar REACT_CLIENT_REFERENCE$1 = Symbol.for('react.client.reference');\nfunction isValidElementType(type) {\n  if (typeof type === 'string' || typeof type === 'function') {\n    return true;\n  } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).\n\n\n  if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing  || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden  || type === REACT_OFFSCREEN_TYPE || enableScopeAPI  || enableCacheElement  || enableTransitionTracing ) {\n    return true;\n  }\n\n  if (typeof type === 'object' && type !== null) {\n    if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || enableRenderableContext  || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object\n    // types supported by any Flight configuration anywhere since\n    // we don't know which Flight build this will end up being used\n    // with.\n    type.$$typeof === REACT_CLIENT_REFERENCE$1 || type.getModuleId !== undefined) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nvar isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare\n\nfunction isArray(a) {\n  return isArrayImpl(a);\n}\n\n// Helpers to patch console.logs to avoid logging during side-effect free\n// replaying on render function. This currently only patches the object\n// lazily which won't cover if the log function was extracted eagerly.\n// We could also eagerly patch the method.\nvar disabledDepth = 0;\nvar prevLog;\nvar prevInfo;\nvar prevWarn;\nvar prevError;\nvar prevGroup;\nvar prevGroupCollapsed;\nvar prevGroupEnd;\n\nfunction disabledLog() {}\n\ndisabledLog.__reactDisabledLog = true;\nfunction disableLogs() {\n  {\n    if (disabledDepth === 0) {\n      /* eslint-disable react-internal/no-production-logging */\n      prevLog = console.log;\n      prevInfo = console.info;\n      prevWarn = console.warn;\n      prevError = console.error;\n      prevGroup = console.group;\n      prevGroupCollapsed = console.groupCollapsed;\n      prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099\n\n      var props = {\n        configurable: true,\n        enumerable: true,\n        value: disabledLog,\n        writable: true\n      }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n\n      Object.defineProperties(console, {\n        info: props,\n        log: props,\n        warn: props,\n        error: props,\n        group: props,\n        groupCollapsed: props,\n        groupEnd: props\n      });\n      /* eslint-enable react-internal/no-production-logging */\n    }\n\n    disabledDepth++;\n  }\n}\nfunction reenableLogs() {\n  {\n    disabledDepth--;\n\n    if (disabledDepth === 0) {\n      /* eslint-disable react-internal/no-production-logging */\n      var props = {\n        configurable: true,\n        enumerable: true,\n        writable: true\n      }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n\n      Object.defineProperties(console, {\n        log: assign({}, props, {\n          value: prevLog\n        }),\n        info: assign({}, props, {\n          value: prevInfo\n        }),\n        warn: assign({}, props, {\n          value: prevWarn\n        }),\n        error: assign({}, props, {\n          value: prevError\n        }),\n        group: assign({}, props, {\n          value: prevGroup\n        }),\n        groupCollapsed: assign({}, props, {\n          value: prevGroupCollapsed\n        }),\n        groupEnd: assign({}, props, {\n          value: prevGroupEnd\n        })\n      });\n      /* eslint-enable react-internal/no-production-logging */\n    }\n\n    if (disabledDepth < 0) {\n      error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');\n    }\n  }\n}\n\nvar ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\nvar prefix;\nfunction describeBuiltInComponentFrame(name, ownerFn) {\n  {\n    if (prefix === undefined) {\n      // Extract the VM specific prefix used by each line.\n      try {\n        throw Error();\n      } catch (x) {\n        var match = x.stack.trim().match(/\\n( *(at )?)/);\n        prefix = match && match[1] || '';\n      }\n    } // We use the prefix to ensure our stacks line up with native stack frames.\n\n\n    return '\\n' + prefix + name;\n  }\n}\nvar reentry = false;\nvar componentFrameCache;\n\n{\n  var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;\n  componentFrameCache = new PossiblyWeakMap();\n}\n/**\n * Leverages native browser/VM stack frames to get proper details (e.g.\n * filename, line + col number) for a single component in a component stack. We\n * do this by:\n *   (1) throwing and catching an error in the function - this will be our\n *       control error.\n *   (2) calling the component which will eventually throw an error that we'll\n *       catch - this will be our sample error.\n *   (3) diffing the control and sample error stacks to find the stack frame\n *       which represents our component.\n */\n\n\nfunction describeNativeComponentFrame(fn, construct) {\n  // If something asked for a stack inside a fake render, it should get ignored.\n  if (!fn || reentry) {\n    return '';\n  }\n\n  {\n    var frame = componentFrameCache.get(fn);\n\n    if (frame !== undefined) {\n      return frame;\n    }\n  }\n\n  reentry = true;\n  var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe[incompatible-type] It does accept undefined.\n\n  Error.prepareStackTrace = undefined;\n  var previousDispatcher;\n\n  {\n    previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function\n    // for warnings.\n\n    ReactCurrentDispatcher.current = null;\n    disableLogs();\n  }\n  /**\n   * Finding a common stack frame between sample and control errors can be\n   * tricky given the different types and levels of stack trace truncation from\n   * different JS VMs. So instead we'll attempt to control what that common\n   * frame should be through this object method:\n   * Having both the sample and control errors be in the function under the\n   * `DescribeNativeComponentFrameRoot` property, + setting the `name` and\n   * `displayName` properties of the function ensures that a stack\n   * frame exists that has the method name `DescribeNativeComponentFrameRoot` in\n   * it for both control and sample stacks.\n   */\n\n\n  var RunInRootFrame = {\n    DetermineComponentFrameRoot: function () {\n      var control;\n\n      try {\n        // This should throw.\n        if (construct) {\n          // Something should be setting the props in the constructor.\n          var Fake = function () {\n            throw Error();\n          }; // $FlowFixMe[prop-missing]\n\n\n          Object.defineProperty(Fake.prototype, 'props', {\n            set: function () {\n              // We use a throwing setter instead of frozen or non-writable props\n              // because that won't throw in a non-strict mode function.\n              throw Error();\n            }\n          });\n\n          if (typeof Reflect === 'object' && Reflect.construct) {\n            // We construct a different control for this case to include any extra\n            // frames added by the construct call.\n            try {\n              Reflect.construct(Fake, []);\n            } catch (x) {\n              control = x;\n            }\n\n            Reflect.construct(fn, [], Fake);\n          } else {\n            try {\n              Fake.call();\n            } catch (x) {\n              control = x;\n            } // $FlowFixMe[prop-missing] found when upgrading Flow\n\n\n            fn.call(Fake.prototype);\n          }\n        } else {\n          try {\n            throw Error();\n          } catch (x) {\n            control = x;\n          } // TODO(luna): This will currently only throw if the function component\n          // tries to access React/ReactDOM/props. We should probably make this throw\n          // in simple components too\n\n\n          var maybePromise = fn(); // If the function component returns a promise, it's likely an async\n          // component, which we don't yet support. Attach a noop catch handler to\n          // silence the error.\n          // TODO: Implement component stacks for async client components?\n\n          if (maybePromise && typeof maybePromise.catch === 'function') {\n            maybePromise.catch(function () {});\n          }\n        }\n      } catch (sample) {\n        // This is inlined manually because closure doesn't do it for us.\n        if (sample && control && typeof sample.stack === 'string') {\n          return [sample.stack, control.stack];\n        }\n      }\n\n      return [null, null];\n    }\n  }; // $FlowFixMe[prop-missing]\n\n  RunInRootFrame.DetermineComponentFrameRoot.displayName = 'DetermineComponentFrameRoot';\n  var namePropDescriptor = Object.getOwnPropertyDescriptor(RunInRootFrame.DetermineComponentFrameRoot, 'name'); // Before ES6, the `name` property was not configurable.\n\n  if (namePropDescriptor && namePropDescriptor.configurable) {\n    // V8 utilizes a function's `name` property when generating a stack trace.\n    Object.defineProperty(RunInRootFrame.DetermineComponentFrameRoot, // Configurable properties can be updated even if its writable descriptor\n    // is set to `false`.\n    // $FlowFixMe[cannot-write]\n    'name', {\n      value: 'DetermineComponentFrameRoot'\n    });\n  }\n\n  try {\n    var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(),\n        sampleStack = _RunInRootFrame$Deter[0],\n        controlStack = _RunInRootFrame$Deter[1];\n\n    if (sampleStack && controlStack) {\n      // This extracts the first frame from the sample that isn't also in the control.\n      // Skipping one frame that we assume is the frame that calls the two.\n      var sampleLines = sampleStack.split('\\n');\n      var controlLines = controlStack.split('\\n');\n      var s = 0;\n      var c = 0;\n\n      while (s < sampleLines.length && !sampleLines[s].includes('DetermineComponentFrameRoot')) {\n        s++;\n      }\n\n      while (c < controlLines.length && !controlLines[c].includes('DetermineComponentFrameRoot')) {\n        c++;\n      } // We couldn't find our intentionally injected common root frame, attempt\n      // to find another common root frame by search from the bottom of the\n      // control stack...\n\n\n      if (s === sampleLines.length || c === controlLines.length) {\n        s = sampleLines.length - 1;\n        c = controlLines.length - 1;\n\n        while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {\n          // We expect at least one stack frame to be shared.\n          // Typically this will be the root most one. However, stack frames may be\n          // cut off due to maximum stack limits. In this case, one maybe cut off\n          // earlier than the other. We assume that the sample is longer or the same\n          // and there for cut off earlier. So we should find the root most frame in\n          // the sample somewhere in the control.\n          c--;\n        }\n      }\n\n      for (; s >= 1 && c >= 0; s--, c--) {\n        // Next we find the first one that isn't the same which should be the\n        // frame that called our sample function and the control.\n        if (sampleLines[s] !== controlLines[c]) {\n          // In V8, the first line is describing the message but other VMs don't.\n          // If we're about to return the first line, and the control is also on the same\n          // line, that's a pretty good indicator that our sample threw at same line as\n          // the control. I.e. before we entered the sample frame. So we ignore this result.\n          // This can happen if you passed a class to function component, or non-function.\n          if (s !== 1 || c !== 1) {\n            do {\n              s--;\n              c--; // We may still have similar intermediate frames from the construct call.\n              // The next one that isn't the same should be our match though.\n\n              if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\n                var _frame = '\\n' + sampleLines[s].replace(' at new ', ' at '); // If our component frame is labeled \"<anonymous>\"\n                // but we have a user-provided \"displayName\"\n                // splice it in to make the stack more readable.\n\n\n                if (fn.displayName && _frame.includes('<anonymous>')) {\n                  _frame = _frame.replace('<anonymous>', fn.displayName);\n                }\n\n                if (true) {\n                  if (typeof fn === 'function') {\n                    componentFrameCache.set(fn, _frame);\n                  }\n                } // Return the line we found.\n\n\n                return _frame;\n              }\n            } while (s >= 1 && c >= 0);\n          }\n\n          break;\n        }\n      }\n    }\n  } finally {\n    reentry = false;\n\n    {\n      ReactCurrentDispatcher.current = previousDispatcher;\n      reenableLogs();\n    }\n\n    Error.prepareStackTrace = previousPrepareStackTrace;\n  } // Fallback to just using the name if we couldn't make it throw.\n\n\n  var name = fn ? fn.displayName || fn.name : '';\n  var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';\n\n  {\n    if (typeof fn === 'function') {\n      componentFrameCache.set(fn, syntheticFrame);\n    }\n  }\n\n  return syntheticFrame;\n}\nfunction describeFunctionComponentFrame(fn, ownerFn) {\n  {\n    return describeNativeComponentFrame(fn, false);\n  }\n}\n\nfunction shouldConstruct(Component) {\n  var prototype = Component.prototype;\n  return !!(prototype && prototype.isReactComponent);\n}\n\nfunction describeUnknownElementTypeFrameInDEV(type, ownerFn) {\n\n  if (type == null) {\n    return '';\n  }\n\n  if (typeof type === 'function') {\n    {\n      return describeNativeComponentFrame(type, shouldConstruct(type));\n    }\n  }\n\n  if (typeof type === 'string') {\n    return describeBuiltInComponentFrame(type);\n  }\n\n  switch (type) {\n    case REACT_SUSPENSE_TYPE:\n      return describeBuiltInComponentFrame('Suspense');\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return describeBuiltInComponentFrame('SuspenseList');\n  }\n\n  if (typeof type === 'object') {\n    switch (type.$$typeof) {\n      case REACT_FORWARD_REF_TYPE:\n        return describeFunctionComponentFrame(type.render);\n\n      case REACT_MEMO_TYPE:\n        // Memo may contain any component type so we recursively resolve it.\n        return describeUnknownElementTypeFrameInDEV(type.type, ownerFn);\n\n      case REACT_LAZY_TYPE:\n        {\n          var lazyComponent = type;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n\n          try {\n            // Lazy may contain any component type so we recursively resolve it.\n            return describeUnknownElementTypeFrameInDEV(init(payload), ownerFn);\n          } catch (x) {}\n        }\n    }\n  }\n\n  return '';\n}\n\nvar ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\nvar ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\nvar REACT_CLIENT_REFERENCE = Symbol.for('react.client.reference');\nvar specialPropKeyWarningShown;\nvar specialPropRefWarningShown;\nvar didWarnAboutStringRefs;\n\n{\n  didWarnAboutStringRefs = {};\n}\n\nfunction hasValidRef(config) {\n  {\n    if (hasOwnProperty.call(config, 'ref')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.ref !== undefined;\n}\n\nfunction hasValidKey(config) {\n  {\n    if (hasOwnProperty.call(config, 'key')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.key !== undefined;\n}\n\nfunction warnIfStringRefCannotBeAutoConverted(config, self) {\n  {\n    if (typeof config.ref === 'string' && ReactCurrentOwner.current && self && ReactCurrentOwner.current.stateNode !== self) {\n      var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);\n\n      if (!didWarnAboutStringRefs[componentName]) {\n        error('Component \"%s\" contains the string ref \"%s\". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', getComponentNameFromType(ReactCurrentOwner.current.type), config.ref);\n\n        didWarnAboutStringRefs[componentName] = true;\n      }\n    }\n  }\n}\n\nfunction defineKeyPropWarningGetter(props, displayName) {\n  {\n    var warnAboutAccessingKey = function () {\n      if (!specialPropKeyWarningShown) {\n        specialPropKeyWarningShown = true;\n\n        error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n      }\n    };\n\n    warnAboutAccessingKey.isReactWarning = true;\n    Object.defineProperty(props, 'key', {\n      get: warnAboutAccessingKey,\n      configurable: true\n    });\n  }\n}\n\nfunction defineRefPropWarningGetter(props, displayName) {\n  {\n    {\n      var warnAboutAccessingRef = function () {\n        if (!specialPropRefWarningShown) {\n          specialPropRefWarningShown = true;\n\n          error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n        }\n      };\n\n      warnAboutAccessingRef.isReactWarning = true;\n      Object.defineProperty(props, 'ref', {\n        get: warnAboutAccessingRef,\n        configurable: true\n      });\n    }\n  }\n}\n/**\n * Factory method to create a new React element. This no longer adheres to\n * the class pattern, so do not use new to call it. Also, instanceof check\n * will not work. Instead test $$typeof field against Symbol.for('react.element') to check\n * if something is a React Element.\n *\n * @param {*} type\n * @param {*} props\n * @param {*} key\n * @param {string|object} ref\n * @param {*} owner\n * @param {*} self A *temporary* helper to detect places where `this` is\n * different from the `owner` when React.createElement is called, so that we\n * can warn. We want to get rid of owner and replace string `ref`s with arrow\n * functions, and as long as `this` and owner are the same, there will be no\n * change in behavior.\n * @param {*} source An annotation object (added by a transpiler or otherwise)\n * indicating filename, line number, and/or other information.\n * @internal\n */\n\n\nfunction ReactElement(type, key, _ref, self, source, owner, props) {\n  var ref;\n\n  {\n    ref = _ref;\n  }\n\n  var element;\n\n  {\n    // In prod, `ref` is a regular property. It will be removed in a\n    // future release.\n    element = {\n      // This tag allows us to uniquely identify this as a React Element\n      $$typeof: REACT_ELEMENT_TYPE,\n      // Built-in properties that belong on the element\n      type: type,\n      key: key,\n      ref: ref,\n      props: props,\n      // Record the component responsible for creating this element.\n      _owner: owner\n    };\n  }\n\n  {\n    // The validation flag is currently mutative. We put it on\n    // an external backing store so that we can freeze the whole object.\n    // This can be replaced with a WeakMap once they are implemented in\n    // commonly used development environments.\n    element._store = {}; // To make comparing ReactElements easier for testing purposes, we make\n    // the validation flag non-enumerable (where possible, which should\n    // include every environment we run tests in), so the test framework\n    // ignores it.\n\n    Object.defineProperty(element._store, 'validated', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: false\n    }); // debugInfo contains Server Component debug information.\n\n    Object.defineProperty(element, '_debugInfo', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: null\n    });\n\n    if (Object.freeze) {\n      Object.freeze(element.props);\n      Object.freeze(element);\n    }\n  }\n\n  return element;\n}\nvar didWarnAboutKeySpread = {};\n/**\n * https://github.com/reactjs/rfcs/pull/107\n * @param {*} type\n * @param {object} props\n * @param {string} key\n */\n\nfunction jsxDEV$1(type, config, maybeKey, isStaticChildren, source, self) {\n  {\n    if (!isValidElementType(type)) {\n      // This is an invalid element type.\n      //\n      // We warn in this case but don't throw. We expect the element creation to\n      // succeed and there will likely be errors in render.\n      var info = '';\n\n      if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {\n        info += ' You likely forgot to export your component from the file ' + \"it's defined in, or you might have mixed up default and named imports.\";\n      }\n\n      var typeString;\n\n      if (type === null) {\n        typeString = 'null';\n      } else if (isArray(type)) {\n        typeString = 'array';\n      } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\n        typeString = \"<\" + (getComponentNameFromType(type.type) || 'Unknown') + \" />\";\n        info = ' Did you accidentally export a JSX literal instead of a component?';\n      } else {\n        typeString = typeof type;\n      }\n\n      error('React.jsx: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);\n    } else {\n      // This is a valid element type.\n      // Skip key warning if the type isn't valid since our key validation logic\n      // doesn't expect a non-string/function type and can throw confusing\n      // errors. We don't want exception behavior to differ between dev and\n      // prod. (Rendering will throw with a helpful message and as soon as the\n      // type is fixed, the key warnings will appear.)\n      var children = config.children;\n\n      if (children !== undefined) {\n        if (isStaticChildren) {\n          if (isArray(children)) {\n            for (var i = 0; i < children.length; i++) {\n              validateChildKeys(children[i], type);\n            }\n\n            if (Object.freeze) {\n              Object.freeze(children);\n            }\n          } else {\n            error('React.jsx: Static children should always be an array. ' + 'You are likely explicitly calling React.jsxs or React.jsxDEV. ' + 'Use the Babel transform instead.');\n          }\n        } else {\n          validateChildKeys(children, type);\n        }\n      }\n    } // Warn about key spread regardless of whether the type is valid.\n\n\n    if (hasOwnProperty.call(config, 'key')) {\n      var componentName = getComponentNameFromType(type);\n      var keys = Object.keys(config).filter(function (k) {\n        return k !== 'key';\n      });\n      var beforeExample = keys.length > 0 ? '{key: someKey, ' + keys.join(': ..., ') + ': ...}' : '{key: someKey}';\n\n      if (!didWarnAboutKeySpread[componentName + beforeExample]) {\n        var afterExample = keys.length > 0 ? '{' + keys.join(': ..., ') + ': ...}' : '{}';\n\n        error('A props object containing a \"key\" prop is being spread into JSX:\\n' + '  let props = %s;\\n' + '  <%s {...props} />\\n' + 'React keys must be passed directly to JSX without using spread:\\n' + '  let props = %s;\\n' + '  <%s key={someKey} {...props} />', beforeExample, componentName, afterExample, componentName);\n\n        didWarnAboutKeySpread[componentName + beforeExample] = true;\n      }\n    }\n\n    var propName; // Reserved names are extracted\n\n    var props = {};\n    var key = null;\n    var ref = null; // Currently, key can be spread in as a prop. This causes a potential\n    // issue if key is also explicitly declared (ie. <div {...props} key=\"Hi\" />\n    // or <div key=\"Hi\" {...props} /> ). We want to deprecate key spread,\n    // but as an intermediary step, we will use jsxDEV for everything except\n    // <div {...props} key=\"Hi\" />, because we aren't currently able to tell if\n    // key is explicitly declared to be undefined or not.\n\n    if (maybeKey !== undefined) {\n      {\n        checkKeyStringCoercion(maybeKey);\n      }\n\n      key = '' + maybeKey;\n    }\n\n    if (hasValidKey(config)) {\n      {\n        checkKeyStringCoercion(config.key);\n      }\n\n      key = '' + config.key;\n    }\n\n    if (hasValidRef(config)) {\n      {\n        ref = config.ref;\n      }\n\n      warnIfStringRefCannotBeAutoConverted(config, self);\n    } // Remaining properties are added to a new props object\n\n\n    for (propName in config) {\n      if (hasOwnProperty.call(config, propName) && // Skip over reserved prop names\n      propName !== 'key' && (propName !== 'ref')) {\n        props[propName] = config[propName];\n      }\n    } // Resolve default props\n\n\n    if (type && type.defaultProps) {\n      var defaultProps = type.defaultProps;\n\n      for (propName in defaultProps) {\n        if (props[propName] === undefined) {\n          props[propName] = defaultProps[propName];\n        }\n      }\n    }\n\n    if (key || ref) {\n      var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;\n\n      if (key) {\n        defineKeyPropWarningGetter(props, displayName);\n      }\n\n      if (ref) {\n        defineRefPropWarningGetter(props, displayName);\n      }\n    }\n\n    var element = ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);\n\n    if (type === REACT_FRAGMENT_TYPE) {\n      validateFragmentProps(element);\n    }\n\n    return element;\n  }\n}\n\nfunction getDeclarationErrorAddendum() {\n  {\n    if (ReactCurrentOwner.current) {\n      var name = getComponentNameFromType(ReactCurrentOwner.current.type);\n\n      if (name) {\n        return '\\n\\nCheck the render method of `' + name + '`.';\n      }\n    }\n\n    return '';\n  }\n}\n/**\n * Ensure that every element either is passed in a static location, in an\n * array with an explicit keys property defined, or in an object literal\n * with valid key property.\n *\n * @internal\n * @param {ReactNode} node Statically passed child of any type.\n * @param {*} parentType node's parent's type.\n */\n\n\nfunction validateChildKeys(node, parentType) {\n  {\n    if (typeof node !== 'object' || !node) {\n      return;\n    }\n\n    if (node.$$typeof === REACT_CLIENT_REFERENCE) ; else if (isArray(node)) {\n      for (var i = 0; i < node.length; i++) {\n        var child = node[i];\n\n        if (isValidElement(child)) {\n          validateExplicitKey(child, parentType);\n        }\n      }\n    } else if (isValidElement(node)) {\n      // This element was passed in a valid location.\n      if (node._store) {\n        node._store.validated = true;\n      }\n    } else {\n      var iteratorFn = getIteratorFn(node);\n\n      if (typeof iteratorFn === 'function') {\n        // Entry iterators used to provide implicit keys,\n        // but now we print a separate warning for them later.\n        if (iteratorFn !== node.entries) {\n          var iterator = iteratorFn.call(node);\n          var step;\n\n          while (!(step = iterator.next()).done) {\n            if (isValidElement(step.value)) {\n              validateExplicitKey(step.value, parentType);\n            }\n          }\n        }\n      }\n    }\n  }\n}\n/**\n * Verifies the object is a ReactElement.\n * See https://reactjs.org/docs/react-api.html#isvalidelement\n * @param {?object} object\n * @return {boolean} True if `object` is a ReactElement.\n * @final\n */\n\n\nfunction isValidElement(object) {\n  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n}\nvar ownerHasKeyUseWarning = {};\n/**\n * Warn if the element doesn't have an explicit key assigned to it.\n * This element is in an array. The array could grow and shrink or be\n * reordered. All children that haven't already been validated are required to\n * have a \"key\" property assigned to it. Error statuses are cached so a warning\n * will only be shown once.\n *\n * @internal\n * @param {ReactElement} element Element that requires a key.\n * @param {*} parentType element's parent's type.\n */\n\nfunction validateExplicitKey(element, parentType) {\n  {\n    if (!element._store || element._store.validated || element.key != null) {\n      return;\n    }\n\n    element._store.validated = true;\n    var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n\n    if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n      return;\n    }\n\n    ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a\n    // property, it may be the creator of the child that's responsible for\n    // assigning it a key.\n\n    var childOwner = '';\n\n    if (element && element._owner && element._owner !== ReactCurrentOwner.current) {\n      // Give the component that originally created this child.\n      childOwner = \" It was passed a child from \" + getComponentNameFromType(element._owner.type) + \".\";\n    }\n\n    setCurrentlyValidatingElement(element);\n\n    error('Each child in a list should have a unique \"key\" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);\n\n    setCurrentlyValidatingElement(null);\n  }\n}\n\nfunction setCurrentlyValidatingElement(element) {\n  {\n    if (element) {\n      var owner = element._owner;\n      var stack = describeUnknownElementTypeFrameInDEV(element.type, owner ? owner.type : null);\n      ReactDebugCurrentFrame.setExtraStackFrame(stack);\n    } else {\n      ReactDebugCurrentFrame.setExtraStackFrame(null);\n    }\n  }\n}\n\nfunction getCurrentComponentErrorInfo(parentType) {\n  {\n    var info = getDeclarationErrorAddendum();\n\n    if (!info) {\n      var parentName = getComponentNameFromType(parentType);\n\n      if (parentName) {\n        info = \"\\n\\nCheck the top-level render call using <\" + parentName + \">.\";\n      }\n    }\n\n    return info;\n  }\n}\n/**\n * Given a fragment, validate that it can only be provided with fragment props\n * @param {ReactElement} fragment\n */\n\n\nfunction validateFragmentProps(fragment) {\n  // TODO: Move this to render phase instead of at element creation.\n  {\n    var keys = Object.keys(fragment.props);\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n\n      if (key !== 'children' && key !== 'key') {\n        setCurrentlyValidatingElement(fragment);\n\n        error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);\n\n        setCurrentlyValidatingElement(null);\n        break;\n      }\n    }\n\n    if (fragment.ref !== null) {\n      setCurrentlyValidatingElement(fragment);\n\n      error('Invalid attribute `ref` supplied to `React.Fragment`.');\n\n      setCurrentlyValidatingElement(null);\n    }\n  }\n}\n\nvar jsxDEV = jsxDEV$1 ;\n\nexports.Fragment = REACT_FRAGMENT_TYPE;\nexports.jsxDEV = jsxDEV;\n  })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsSUFBSSxJQUFxQztBQUN6QztBQUNBOztBQUVBLFlBQVksbUJBQU8sQ0FBQyxzR0FBMEI7O0FBRTlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDs7QUFFeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlHQUFpRyxlQUFlO0FBQ2hIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQSxLQUFLLEdBQUc7O0FBRVIsa0RBQWtEO0FBQ2xEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLDRCQUE0QjtBQUM1QjtBQUNBLHFDQUFxQzs7QUFFckMsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBOztBQUVBLHFFQUFxRTs7QUFFckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0dBQWtHOztBQUVsRztBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpQ0FBaUM7O0FBRWpDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qzs7QUFFdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0EsU0FBUztBQUNULHVCQUF1QjtBQUN2QjtBQUNBLFNBQVM7QUFDVCx1QkFBdUI7QUFDdkI7QUFDQSxTQUFTO0FBQ1Qsd0JBQXdCO0FBQ3hCO0FBQ0EsU0FBUztBQUNULHdCQUF3QjtBQUN4QjtBQUNBLFNBQVM7QUFDVCxpQ0FBaUM7QUFDakM7QUFDQSxTQUFTO0FBQ1QsMkJBQTJCO0FBQzNCO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkRBQTJEOztBQUUzRDtBQUNBOztBQUVBO0FBQ0EseURBQXlEO0FBQ3pEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOzs7QUFHYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYzs7O0FBR2Q7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7OztBQUdBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsZ0hBQWdIOztBQUVoSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYSxrQkFBa0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjs7QUFFQTtBQUNBO0FBQ0EsZ0ZBQWdGO0FBQ2hGO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsSUFBSTtBQUN4QjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7OztBQUdsQjtBQUNBO0FBQ0EsY0FBYztBQUNkOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxXQUFXLEdBQUc7QUFDZCxXQUFXLEdBQUc7QUFDZCxXQUFXLGVBQWU7QUFDMUIsV0FBVyxHQUFHO0FBQ2QsV0FBVyxHQUFHO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxHQUFHOztBQUVSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHFCQUFxQjtBQUNqRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLDhDQUE4QyxnREFBZ0QsTUFBTSxhQUFhOztBQUVqSDtBQUNBLCtDQUErQyxrQ0FBa0MsT0FBTzs7QUFFeEYsdUdBQXVHLGNBQWMsVUFBVSxnR0FBZ0csa0JBQWtCLFVBQVUsVUFBVTs7QUFFclE7QUFDQTtBQUNBOztBQUVBLGtCQUFrQjs7QUFFbEI7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQiwyREFBMkQsVUFBVTtBQUNyRSx5QkFBeUIsVUFBVTtBQUNuQztBQUNBLGFBQWEsVUFBVTtBQUN2Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFdBQVc7QUFDdEIsV0FBVyxHQUFHO0FBQ2Q7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0RBQW9EO0FBQ3BELHNCQUFzQixpQkFBaUI7QUFDdkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFlBQVksU0FBUztBQUNyQjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekIsV0FBVyxHQUFHO0FBQ2Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw2REFBNkQ7QUFDN0Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixpQkFBaUI7QUFDckM7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGdCQUFnQjtBQUNoQixjQUFjO0FBQ2QsR0FBRztBQUNIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcz9jOTY5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2UgUmVhY3RcbiAqIHJlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIChmdW5jdGlvbigpIHtcbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0ID0gcmVxdWlyZShcIm5leHQvZGlzdC9jb21waWxlZC9yZWFjdFwiKTtcblxuLy8gQVRURU5USU9OXG4vLyBXaGVuIGFkZGluZyBuZXcgc3ltYm9scyB0byB0aGlzIGZpbGUsXG4vLyBQbGVhc2UgY29uc2lkZXIgYWxzbyBhZGRpbmcgdG8gJ3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvYmFja2VuZC9SZWFjdFN5bWJvbHMnXG4vLyBUaGUgU3ltYm9sIHVzZWQgdG8gdGFnIHRoZSBSZWFjdEVsZW1lbnQtbGlrZSB0eXBlcy5cbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50Jyk7XG52YXIgUkVBQ1RfUE9SVEFMX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5wb3J0YWwnKTtcbnZhciBSRUFDVF9GUkFHTUVOVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZnJhZ21lbnQnKTtcbnZhciBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc3RyaWN0X21vZGUnKTtcbnZhciBSRUFDVF9QUk9GSUxFUl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QucHJvZmlsZXInKTtcbnZhciBSRUFDVF9QUk9WSURFUl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QucHJvdmlkZXInKTsgLy8gVE9ETzogRGVsZXRlIHdpdGggZW5hYmxlUmVuZGVyYWJsZUNvbnRleHRcblxudmFyIFJFQUNUX0NPTlNVTUVSX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5jb25zdW1lcicpO1xudmFyIFJFQUNUX0NPTlRFWFRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNvbnRleHQnKTtcbnZhciBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZm9yd2FyZF9yZWYnKTtcbnZhciBSRUFDVF9TVVNQRU5TRV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc3VzcGVuc2UnKTtcbnZhciBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZV9saXN0Jyk7XG52YXIgUkVBQ1RfTUVNT19UWVBFID0gU3ltYm9sLmZvcigncmVhY3QubWVtbycpO1xudmFyIFJFQUNUX0xBWllfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmxhenknKTtcbnZhciBSRUFDVF9PRkZTQ1JFRU5fVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0Lm9mZnNjcmVlbicpO1xudmFyIFJFQUNUX0NBQ0hFX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5jYWNoZScpO1xudmFyIE1BWUJFX0lURVJBVE9SX1NZTUJPTCA9IFN5bWJvbC5pdGVyYXRvcjtcbnZhciBGQVVYX0lURVJBVE9SX1NZTUJPTCA9ICdAQGl0ZXJhdG9yJztcbmZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xuICBpZiAobWF5YmVJdGVyYWJsZSA9PT0gbnVsbCB8fCB0eXBlb2YgbWF5YmVJdGVyYWJsZSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBtYXliZUl0ZXJhdG9yID0gTUFZQkVfSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbTUFZQkVfSVRFUkFUT1JfU1lNQk9MXSB8fCBtYXliZUl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXTtcblxuICBpZiAodHlwZW9mIG1heWJlSXRlcmF0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gbWF5YmVJdGVyYXRvcjtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG52YXIgUmVhY3RTaGFyZWRJbnRlcm5hbHMgPSBSZWFjdC5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRDtcblxuZnVuY3Rpb24gZXJyb3IoZm9ybWF0KSB7XG4gIHtcbiAgICB7XG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIgPiAxID8gX2xlbjIgLSAxIDogMCksIF9rZXkyID0gMTsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICBhcmdzW19rZXkyIC0gMV0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICBwcmludFdhcm5pbmcoJ2Vycm9yJywgZm9ybWF0LCBhcmdzKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJpbnRXYXJuaW5nKGxldmVsLCBmb3JtYXQsIGFyZ3MpIHtcbiAgLy8gV2hlbiBjaGFuZ2luZyB0aGlzIGxvZ2ljLCB5b3UgbWlnaHQgd2FudCB0byBhbHNvXG4gIC8vIHVwZGF0ZSBjb25zb2xlV2l0aFN0YWNrRGV2Lnd3dy5qcyBhcyB3ZWxsLlxuICB7XG4gICAgdmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuICAgIHZhciBzdGFjayA9IFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0U3RhY2tBZGRlbmR1bSgpO1xuXG4gICAgaWYgKHN0YWNrICE9PSAnJykge1xuICAgICAgZm9ybWF0ICs9ICclcyc7XG4gICAgICBhcmdzID0gYXJncy5jb25jYXQoW3N0YWNrXSk7XG4gICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cblxuXG4gICAgdmFyIGFyZ3NXaXRoRm9ybWF0ID0gYXJncy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHJldHVybiBTdHJpbmcoaXRlbSk7XG4gICAgfSk7IC8vIENhcmVmdWw6IFJOIGN1cnJlbnRseSBkZXBlbmRzIG9uIHRoaXMgcHJlZml4XG5cbiAgICBhcmdzV2l0aEZvcm1hdC51bnNoaWZ0KCdXYXJuaW5nOiAnICsgZm9ybWF0KTsgLy8gV2UgaW50ZW50aW9uYWxseSBkb24ndCB1c2Ugc3ByZWFkIChvciAuYXBwbHkpIGRpcmVjdGx5IGJlY2F1c2UgaXRcbiAgICAvLyBicmVha3MgSUU5OiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzEzNjEwXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZ1xuXG4gICAgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwoY29uc29sZVtsZXZlbF0sIGNvbnNvbGUsIGFyZ3NXaXRoRm9ybWF0KTtcbiAgfVxufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG52YXIgZW5hYmxlU2NvcGVBUEkgPSBmYWxzZTsgLy8gRXhwZXJpbWVudGFsIENyZWF0ZSBFdmVudCBIYW5kbGUgQVBJLlxudmFyIGVuYWJsZUNhY2hlRWxlbWVudCA9IGZhbHNlO1xudmFyIGVuYWJsZVRyYW5zaXRpb25UcmFjaW5nID0gZmFsc2U7IC8vIE5vIGtub3duIGJ1Z3MsIGJ1dCBuZWVkcyBwZXJmb3JtYW5jZSB0ZXN0aW5nXG5cbnZhciBlbmFibGVMZWdhY3lIaWRkZW4gPSBmYWxzZTsgLy8gRW5hYmxlcyB1bnN0YWJsZV9hdm9pZFRoaXNGYWxsYmFjayBmZWF0dXJlIGluIEZpYmVyXG52YXIgZW5hYmxlUmVuZGVyYWJsZUNvbnRleHQgPSBmYWxzZTtcbi8vIHN0dWZmLiBJbnRlbmRlZCB0byBlbmFibGUgUmVhY3QgY29yZSBtZW1iZXJzIHRvIG1vcmUgZWFzaWx5IGRlYnVnIHNjaGVkdWxpbmdcbi8vIGlzc3VlcyBpbiBERVYgYnVpbGRzLlxuXG52YXIgZW5hYmxlRGVidWdUcmFjaW5nID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGdldFdyYXBwZWROYW1lKG91dGVyVHlwZSwgaW5uZXJUeXBlLCB3cmFwcGVyTmFtZSkge1xuICB2YXIgZGlzcGxheU5hbWUgPSBvdXRlclR5cGUuZGlzcGxheU5hbWU7XG5cbiAgaWYgKGRpc3BsYXlOYW1lKSB7XG4gICAgcmV0dXJuIGRpc3BsYXlOYW1lO1xuICB9XG5cbiAgdmFyIGZ1bmN0aW9uTmFtZSA9IGlubmVyVHlwZS5kaXNwbGF5TmFtZSB8fCBpbm5lclR5cGUubmFtZSB8fCAnJztcbiAgcmV0dXJuIGZ1bmN0aW9uTmFtZSAhPT0gJycgPyB3cmFwcGVyTmFtZSArIFwiKFwiICsgZnVuY3Rpb25OYW1lICsgXCIpXCIgOiB3cmFwcGVyTmFtZTtcbn0gLy8gS2VlcCBpbiBzeW5jIHdpdGggcmVhY3QtcmVjb25jaWxlci9nZXRDb21wb25lbnROYW1lRnJvbUZpYmVyXG5cblxuZnVuY3Rpb24gZ2V0Q29udGV4dE5hbWUodHlwZSkge1xuICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCAnQ29udGV4dCc7XG59XG5cbnZhciBSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDIgPSBTeW1ib2wuZm9yKCdyZWFjdC5jbGllbnQucmVmZXJlbmNlJyk7IC8vIE5vdGUgdGhhdCB0aGUgcmVjb25jaWxlciBwYWNrYWdlIHNob3VsZCBnZW5lcmFsbHkgcHJlZmVyIHRvIHVzZSBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKCkgaW5zdGVhZC5cblxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHtcbiAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgIC8vIEhvc3Qgcm9vdCwgdGV4dCBub2RlIG9yIGp1c3QgaW52YWxpZCB0eXBlLlxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaWYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UkMikge1xuICAgICAgLy8gVE9ETzogQ3JlYXRlIGEgY29udmVudGlvbiBmb3IgbmFtaW5nIGNsaWVudCByZWZlcmVuY2VzIHdpdGggZGVidWcgaW5mby5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB0eXBlO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOlxuICAgICAgcmV0dXJuICdGcmFnbWVudCc7XG5cbiAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgcmV0dXJuICdQb3J0YWwnO1xuXG4gICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgcmV0dXJuICdQcm9maWxlcic7XG5cbiAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XG4gICAgICByZXR1cm4gJ1N0cmljdE1vZGUnO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgcmV0dXJuICdTdXNwZW5zZSc7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiAnU3VzcGVuc2VMaXN0JztcblxuICAgIGNhc2UgUkVBQ1RfQ0FDSEVfVFlQRTpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuICdDYWNoZSc7XG4gICAgICB9XG5cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICB7XG4gICAgICBpZiAodHlwZW9mIHR5cGUudGFnID09PSAnbnVtYmVyJykge1xuICAgICAgICBlcnJvcignUmVjZWl2ZWQgYW4gdW5leHBlY3RlZCBvYmplY3QgaW4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKCkuICcgKyAnVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9QUk9WSURFUl9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHByb3ZpZGVyID0gdHlwZTtcbiAgICAgICAgICByZXR1cm4gZ2V0Q29udGV4dE5hbWUocHJvdmlkZXIuX2NvbnRleHQpICsgJy5Qcm92aWRlcic7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgIHZhciBjb250ZXh0ID0gdHlwZTtcblxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKGNvbnRleHQpICsgJy5Db25zdW1lcic7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBSRUFDVF9DT05TVU1FUl9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICByZXR1cm4gZ2V0V3JhcHBlZE5hbWUodHlwZSwgdHlwZS5yZW5kZXIsICdGb3J3YXJkUmVmJyk7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICB2YXIgb3V0ZXJOYW1lID0gdHlwZS5kaXNwbGF5TmFtZSB8fCBudWxsO1xuXG4gICAgICAgIGlmIChvdXRlck5hbWUgIT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gb3V0ZXJOYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8ICdNZW1vJztcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGluaXQocGF5bG9hZCkpO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG4vLyAkRmxvd0ZpeE1lW21ldGhvZC11bmJpbmRpbmddXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG52YXIgYXNzaWduID0gT2JqZWN0LmFzc2lnbjtcblxuLypcbiAqIFRoZSBgJycgKyB2YWx1ZWAgcGF0dGVybiAodXNlZCBpbiBwZXJmLXNlbnNpdGl2ZSBjb2RlKSB0aHJvd3MgZm9yIFN5bWJvbFxuICogYW5kIFRlbXBvcmFsLiogdHlwZXMuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC8yMjA2NC5cbiAqXG4gKiBUaGUgZnVuY3Rpb25zIGluIHRoaXMgbW9kdWxlIHdpbGwgdGhyb3cgYW4gZWFzaWVyLXRvLXVuZGVyc3RhbmQsXG4gKiBlYXNpZXItdG8tZGVidWcgZXhjZXB0aW9uIHdpdGggYSBjbGVhciBlcnJvcnMgbWVzc2FnZSBtZXNzYWdlIGV4cGxhaW5pbmcgdGhlXG4gKiBwcm9ibGVtLiAoSW5zdGVhZCBvZiBhIGNvbmZ1c2luZyBleGNlcHRpb24gdGhyb3duIGluc2lkZSB0aGUgaW1wbGVtZW50YXRpb25cbiAqIG9mIHRoZSBgdmFsdWVgIG9iamVjdCkuXG4gKi9cbi8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXJldHVybl0gb25seSBjYWxsZWQgaW4gREVWLCBzbyB2b2lkIHJldHVybiBpcyBub3QgcG9zc2libGUuXG5mdW5jdGlvbiB0eXBlTmFtZSh2YWx1ZSkge1xuICB7XG4gICAgLy8gdG9TdHJpbmdUYWcgaXMgbmVlZGVkIGZvciBuYW1lc3BhY2VkIHR5cGVzIGxpa2UgVGVtcG9yYWwuSW5zdGFudFxuICAgIHZhciBoYXNUb1N0cmluZ1RhZyA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLnRvU3RyaW5nVGFnO1xuICAgIHZhciB0eXBlID0gaGFzVG9TdHJpbmdUYWcgJiYgdmFsdWVbU3ltYm9sLnRvU3RyaW5nVGFnXSB8fCB2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lIHx8ICdPYmplY3QnOyAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dXG5cbiAgICByZXR1cm4gdHlwZTtcbiAgfVxufSAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dIG9ubHkgY2FsbGVkIGluIERFViwgc28gdm9pZCByZXR1cm4gaXMgbm90IHBvc3NpYmxlLlxuXG5cbmZ1bmN0aW9uIHdpbGxDb2VyY2lvblRocm93KHZhbHVlKSB7XG4gIHtcbiAgICB0cnkge1xuICAgICAgdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gIC8vIElmIHlvdSBlbmRlZCB1cCBoZXJlIGJ5IGZvbGxvd2luZyBhbiBleGNlcHRpb24gY2FsbCBzdGFjaywgaGVyZSdzIHdoYXQnc1xuICAvLyBoYXBwZW5lZDogeW91IHN1cHBsaWVkIGFuIG9iamVjdCBvciBzeW1ib2wgdmFsdWUgdG8gUmVhY3QgKGFzIGEgcHJvcCwga2V5LFxuICAvLyBET00gYXR0cmlidXRlLCBDU1MgcHJvcGVydHksIHN0cmluZyByZWYsIGV0Yy4pIGFuZCB3aGVuIFJlYWN0IHRyaWVkIHRvXG4gIC8vIGNvZXJjZSBpdCB0byBhIHN0cmluZyB1c2luZyBgJycgKyB2YWx1ZWAsIGFuIGV4Y2VwdGlvbiB3YXMgdGhyb3duLlxuICAvL1xuICAvLyBUaGUgbW9zdCBjb21tb24gdHlwZXMgdGhhdCB3aWxsIGNhdXNlIHRoaXMgZXhjZXB0aW9uIGFyZSBgU3ltYm9sYCBpbnN0YW5jZXNcbiAgLy8gYW5kIFRlbXBvcmFsIG9iamVjdHMgbGlrZSBgVGVtcG9yYWwuSW5zdGFudGAuIEJ1dCBhbnkgb2JqZWN0IHRoYXQgaGFzIGFcbiAgLy8gYHZhbHVlT2ZgIG9yIGBbU3ltYm9sLnRvUHJpbWl0aXZlXWAgbWV0aG9kIHRoYXQgdGhyb3dzIHdpbGwgYWxzbyBjYXVzZSB0aGlzXG4gIC8vIGV4Y2VwdGlvbi4gKExpYnJhcnkgYXV0aG9ycyBkbyB0aGlzIHRvIHByZXZlbnQgdXNlcnMgZnJvbSB1c2luZyBidWlsdC1pblxuICAvLyBudW1lcmljIG9wZXJhdG9ycyBsaWtlIGArYCBvciBjb21wYXJpc29uIG9wZXJhdG9ycyBsaWtlIGA+PWAgYmVjYXVzZSBjdXN0b21cbiAgLy8gbWV0aG9kcyBhcmUgbmVlZGVkIHRvIHBlcmZvcm0gYWNjdXJhdGUgYXJpdGhtZXRpYyBvciBjb21wYXJpc29uLilcbiAgLy9cbiAgLy8gVG8gZml4IHRoZSBwcm9ibGVtLCBjb2VyY2UgdGhpcyBvYmplY3Qgb3Igc3ltYm9sIHZhbHVlIHRvIGEgc3RyaW5nIGJlZm9yZVxuICAvLyBwYXNzaW5nIGl0IHRvIFJlYWN0LiBUaGUgbW9zdCByZWxpYWJsZSB3YXkgaXMgdXN1YWxseSBgU3RyaW5nKHZhbHVlKWAuXG4gIC8vXG4gIC8vIFRvIGZpbmQgd2hpY2ggdmFsdWUgaXMgdGhyb3dpbmcsIGNoZWNrIHRoZSBicm93c2VyIG9yIGRlYnVnZ2VyIGNvbnNvbGUuXG4gIC8vIEJlZm9yZSB0aGlzIGV4Y2VwdGlvbiB3YXMgdGhyb3duLCB0aGVyZSBzaG91bGQgYmUgYGNvbnNvbGUuZXJyb3JgIG91dHB1dFxuICAvLyB0aGF0IHNob3dzIHRoZSB0eXBlIChTeW1ib2wsIFRlbXBvcmFsLlBsYWluRGF0ZSwgZXRjLikgdGhhdCBjYXVzZWQgdGhlXG4gIC8vIHByb2JsZW0gYW5kIGhvdyB0aGF0IHR5cGUgd2FzIHVzZWQ6IGtleSwgYXRycmlidXRlLCBpbnB1dCB2YWx1ZSBwcm9wLCBldGMuXG4gIC8vIEluIG1vc3QgY2FzZXMsIHRoaXMgY29uc29sZSBvdXRwdXQgYWxzbyBzaG93cyB0aGUgY29tcG9uZW50IGFuZCBpdHNcbiAgLy8gYW5jZXN0b3IgY29tcG9uZW50cyB3aGVyZSB0aGUgZXhjZXB0aW9uIGhhcHBlbmVkLlxuICAvL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cbiAgcmV0dXJuICcnICsgdmFsdWU7XG59XG5mdW5jdGlvbiBjaGVja0tleVN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gIHtcbiAgICBpZiAod2lsbENvZXJjaW9uVGhyb3codmFsdWUpKSB7XG4gICAgICBlcnJvcignVGhlIHByb3ZpZGVkIGtleSBpcyBhbiB1bnN1cHBvcnRlZCB0eXBlICVzLicgKyAnIFRoaXMgdmFsdWUgbXVzdCBiZSBjb2VyY2VkIHRvIGEgc3RyaW5nIGJlZm9yZSB1c2luZyBpdCBoZXJlLicsIHR5cGVOYW1lKHZhbHVlKSk7XG5cbiAgICAgIHJldHVybiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpOyAvLyB0aHJvdyAodG8gaGVscCBjYWxsZXJzIGZpbmQgdHJvdWJsZXNob290aW5nIGNvbW1lbnRzKVxuICAgIH1cbiAgfVxufVxuXG52YXIgUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSQxID0gU3ltYm9sLmZvcigncmVhY3QuY2xpZW50LnJlZmVyZW5jZScpO1xuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpIHtcbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9IC8vIE5vdGU6IHR5cGVvZiBtaWdodCBiZSBvdGhlciB0aGFuICdzeW1ib2wnIG9yICdudW1iZXInIChlLmcuIGlmIGl0J3MgYSBwb2x5ZmlsbCkuXG5cblxuICBpZiAodHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9QUk9GSUxFUl9UWVBFIHx8IGVuYWJsZURlYnVnVHJhY2luZyAgfHwgdHlwZSA9PT0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSB8fCBlbmFibGVMZWdhY3lIaWRkZW4gIHx8IHR5cGUgPT09IFJFQUNUX09GRlNDUkVFTl9UWVBFIHx8IGVuYWJsZVNjb3BlQVBJICB8fCBlbmFibGVDYWNoZUVsZW1lbnQgIHx8IGVuYWJsZVRyYW5zaXRpb25UcmFjaW5nICkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsKSB7XG4gICAgaWYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX1BST1ZJREVSX1RZUEUgfHwgZW5hYmxlUmVuZGVyYWJsZUNvbnRleHQgIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgLy8gVGhpcyBuZWVkcyB0byBpbmNsdWRlIGFsbCBwb3NzaWJsZSBtb2R1bGUgcmVmZXJlbmNlIG9iamVjdFxuICAgIC8vIHR5cGVzIHN1cHBvcnRlZCBieSBhbnkgRmxpZ2h0IGNvbmZpZ3VyYXRpb24gYW55d2hlcmUgc2luY2VcbiAgICAvLyB3ZSBkb24ndCBrbm93IHdoaWNoIEZsaWdodCBidWlsZCB0aGlzIHdpbGwgZW5kIHVwIGJlaW5nIHVzZWRcbiAgICAvLyB3aXRoLlxuICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UkMSB8fCB0eXBlLmdldE1vZHVsZUlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxudmFyIGlzQXJyYXlJbXBsID0gQXJyYXkuaXNBcnJheTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxuXG5mdW5jdGlvbiBpc0FycmF5KGEpIHtcbiAgcmV0dXJuIGlzQXJyYXlJbXBsKGEpO1xufVxuXG4vLyBIZWxwZXJzIHRvIHBhdGNoIGNvbnNvbGUubG9ncyB0byBhdm9pZCBsb2dnaW5nIGR1cmluZyBzaWRlLWVmZmVjdCBmcmVlXG4vLyByZXBsYXlpbmcgb24gcmVuZGVyIGZ1bmN0aW9uLiBUaGlzIGN1cnJlbnRseSBvbmx5IHBhdGNoZXMgdGhlIG9iamVjdFxuLy8gbGF6aWx5IHdoaWNoIHdvbid0IGNvdmVyIGlmIHRoZSBsb2cgZnVuY3Rpb24gd2FzIGV4dHJhY3RlZCBlYWdlcmx5LlxuLy8gV2UgY291bGQgYWxzbyBlYWdlcmx5IHBhdGNoIHRoZSBtZXRob2QuXG52YXIgZGlzYWJsZWREZXB0aCA9IDA7XG52YXIgcHJldkxvZztcbnZhciBwcmV2SW5mbztcbnZhciBwcmV2V2FybjtcbnZhciBwcmV2RXJyb3I7XG52YXIgcHJldkdyb3VwO1xudmFyIHByZXZHcm91cENvbGxhcHNlZDtcbnZhciBwcmV2R3JvdXBFbmQ7XG5cbmZ1bmN0aW9uIGRpc2FibGVkTG9nKCkge31cblxuZGlzYWJsZWRMb2cuX19yZWFjdERpc2FibGVkTG9nID0gdHJ1ZTtcbmZ1bmN0aW9uIGRpc2FibGVMb2dzKCkge1xuICB7XG4gICAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgICAgcHJldkxvZyA9IGNvbnNvbGUubG9nO1xuICAgICAgcHJldkluZm8gPSBjb25zb2xlLmluZm87XG4gICAgICBwcmV2V2FybiA9IGNvbnNvbGUud2FybjtcbiAgICAgIHByZXZFcnJvciA9IGNvbnNvbGUuZXJyb3I7XG4gICAgICBwcmV2R3JvdXAgPSBjb25zb2xlLmdyb3VwO1xuICAgICAgcHJldkdyb3VwQ29sbGFwc2VkID0gY29uc29sZS5ncm91cENvbGxhcHNlZDtcbiAgICAgIHByZXZHcm91cEVuZCA9IGNvbnNvbGUuZ3JvdXBFbmQ7IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTkwOTlcblxuICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBkaXNhYmxlZExvZyxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH07IC8vICRGbG93Rml4TWVbY2Fubm90LXdyaXRlXSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICBpbmZvOiBwcm9wcyxcbiAgICAgICAgbG9nOiBwcm9wcyxcbiAgICAgICAgd2FybjogcHJvcHMsXG4gICAgICAgIGVycm9yOiBwcm9wcyxcbiAgICAgICAgZ3JvdXA6IHByb3BzLFxuICAgICAgICBncm91cENvbGxhcHNlZDogcHJvcHMsXG4gICAgICAgIGdyb3VwRW5kOiBwcm9wc1xuICAgICAgfSk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgIH1cblxuICAgIGRpc2FibGVkRGVwdGgrKztcbiAgfVxufVxuZnVuY3Rpb24gcmVlbmFibGVMb2dzKCkge1xuICB7XG4gICAgZGlzYWJsZWREZXB0aC0tO1xuXG4gICAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lW2Nhbm5vdC13cml0ZV0gRmxvdyB0aGlua3MgY29uc29sZSBpcyBpbW11dGFibGUuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgICAgbG9nOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZMb2dcbiAgICAgICAgfSksXG4gICAgICAgIGluZm86IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkluZm9cbiAgICAgICAgfSksXG4gICAgICAgIHdhcm46IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldldhcm5cbiAgICAgICAgfSksXG4gICAgICAgIGVycm9yOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZFcnJvclxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXA6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cENvbGxhcHNlZDogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBDb2xsYXBzZWRcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwRW5kOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cEVuZFxuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgIH1cblxuICAgIGlmIChkaXNhYmxlZERlcHRoIDwgMCkge1xuICAgICAgZXJyb3IoJ2Rpc2FibGVkRGVwdGggZmVsbCBiZWxvdyB6ZXJvLiAnICsgJ1RoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudERpc3BhdGNoZXI7XG52YXIgcHJlZml4O1xuZnVuY3Rpb24gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSwgb3duZXJGbikge1xuICB7XG4gICAgaWYgKHByZWZpeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBFeHRyYWN0IHRoZSBWTSBzcGVjaWZpYyBwcmVmaXggdXNlZCBieSBlYWNoIGxpbmUuXG4gICAgICB0cnkge1xuICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICB2YXIgbWF0Y2ggPSB4LnN0YWNrLnRyaW0oKS5tYXRjaCgvXFxuKCAqKGF0ICk/KS8pO1xuICAgICAgICBwcmVmaXggPSBtYXRjaCAmJiBtYXRjaFsxXSB8fCAnJztcbiAgICAgIH1cbiAgICB9IC8vIFdlIHVzZSB0aGUgcHJlZml4IHRvIGVuc3VyZSBvdXIgc3RhY2tzIGxpbmUgdXAgd2l0aCBuYXRpdmUgc3RhY2sgZnJhbWVzLlxuXG5cbiAgICByZXR1cm4gJ1xcbicgKyBwcmVmaXggKyBuYW1lO1xuICB9XG59XG52YXIgcmVlbnRyeSA9IGZhbHNlO1xudmFyIGNvbXBvbmVudEZyYW1lQ2FjaGU7XG5cbntcbiAgdmFyIFBvc3NpYmx5V2Vha01hcCA9IHR5cGVvZiBXZWFrTWFwID09PSAnZnVuY3Rpb24nID8gV2Vha01hcCA6IE1hcDtcbiAgY29tcG9uZW50RnJhbWVDYWNoZSA9IG5ldyBQb3NzaWJseVdlYWtNYXAoKTtcbn1cbi8qKlxuICogTGV2ZXJhZ2VzIG5hdGl2ZSBicm93c2VyL1ZNIHN0YWNrIGZyYW1lcyB0byBnZXQgcHJvcGVyIGRldGFpbHMgKGUuZy5cbiAqIGZpbGVuYW1lLCBsaW5lICsgY29sIG51bWJlcikgZm9yIGEgc2luZ2xlIGNvbXBvbmVudCBpbiBhIGNvbXBvbmVudCBzdGFjay4gV2VcbiAqIGRvIHRoaXMgYnk6XG4gKiAgICgxKSB0aHJvd2luZyBhbmQgY2F0Y2hpbmcgYW4gZXJyb3IgaW4gdGhlIGZ1bmN0aW9uIC0gdGhpcyB3aWxsIGJlIG91clxuICogICAgICAgY29udHJvbCBlcnJvci5cbiAqICAgKDIpIGNhbGxpbmcgdGhlIGNvbXBvbmVudCB3aGljaCB3aWxsIGV2ZW50dWFsbHkgdGhyb3cgYW4gZXJyb3IgdGhhdCB3ZSdsbFxuICogICAgICAgY2F0Y2ggLSB0aGlzIHdpbGwgYmUgb3VyIHNhbXBsZSBlcnJvci5cbiAqICAgKDMpIGRpZmZpbmcgdGhlIGNvbnRyb2wgYW5kIHNhbXBsZSBlcnJvciBzdGFja3MgdG8gZmluZCB0aGUgc3RhY2sgZnJhbWVcbiAqICAgICAgIHdoaWNoIHJlcHJlc2VudHMgb3VyIGNvbXBvbmVudC5cbiAqL1xuXG5cbmZ1bmN0aW9uIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGNvbnN0cnVjdCkge1xuICAvLyBJZiBzb21ldGhpbmcgYXNrZWQgZm9yIGEgc3RhY2sgaW5zaWRlIGEgZmFrZSByZW5kZXIsIGl0IHNob3VsZCBnZXQgaWdub3JlZC5cbiAgaWYgKCFmbiB8fCByZWVudHJ5KSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAge1xuICAgIHZhciBmcmFtZSA9IGNvbXBvbmVudEZyYW1lQ2FjaGUuZ2V0KGZuKTtcblxuICAgIGlmIChmcmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZnJhbWU7XG4gICAgfVxuICB9XG5cbiAgcmVlbnRyeSA9IHRydWU7XG4gIHZhciBwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlID0gRXJyb3IucHJlcGFyZVN0YWNrVHJhY2U7IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXR5cGVdIEl0IGRvZXMgYWNjZXB0IHVuZGVmaW5lZC5cblxuICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHVuZGVmaW5lZDtcbiAgdmFyIHByZXZpb3VzRGlzcGF0Y2hlcjtcblxuICB7XG4gICAgcHJldmlvdXNEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50OyAvLyBTZXQgdGhlIGRpc3BhdGNoZXIgaW4gREVWIGJlY2F1c2UgdGhpcyBtaWdodCBiZSBjYWxsIGluIHRoZSByZW5kZXIgZnVuY3Rpb25cbiAgICAvLyBmb3Igd2FybmluZ3MuXG5cbiAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQgPSBudWxsO1xuICAgIGRpc2FibGVMb2dzKCk7XG4gIH1cbiAgLyoqXG4gICAqIEZpbmRpbmcgYSBjb21tb24gc3RhY2sgZnJhbWUgYmV0d2VlbiBzYW1wbGUgYW5kIGNvbnRyb2wgZXJyb3JzIGNhbiBiZVxuICAgKiB0cmlja3kgZ2l2ZW4gdGhlIGRpZmZlcmVudCB0eXBlcyBhbmQgbGV2ZWxzIG9mIHN0YWNrIHRyYWNlIHRydW5jYXRpb24gZnJvbVxuICAgKiBkaWZmZXJlbnQgSlMgVk1zLiBTbyBpbnN0ZWFkIHdlJ2xsIGF0dGVtcHQgdG8gY29udHJvbCB3aGF0IHRoYXQgY29tbW9uXG4gICAqIGZyYW1lIHNob3VsZCBiZSB0aHJvdWdoIHRoaXMgb2JqZWN0IG1ldGhvZDpcbiAgICogSGF2aW5nIGJvdGggdGhlIHNhbXBsZSBhbmQgY29udHJvbCBlcnJvcnMgYmUgaW4gdGhlIGZ1bmN0aW9uIHVuZGVyIHRoZVxuICAgKiBgRGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZVJvb3RgIHByb3BlcnR5LCArIHNldHRpbmcgdGhlIGBuYW1lYCBhbmRcbiAgICogYGRpc3BsYXlOYW1lYCBwcm9wZXJ0aWVzIG9mIHRoZSBmdW5jdGlvbiBlbnN1cmVzIHRoYXQgYSBzdGFja1xuICAgKiBmcmFtZSBleGlzdHMgdGhhdCBoYXMgdGhlIG1ldGhvZCBuYW1lIGBEZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lUm9vdGAgaW5cbiAgICogaXQgZm9yIGJvdGggY29udHJvbCBhbmQgc2FtcGxlIHN0YWNrcy5cbiAgICovXG5cblxuICB2YXIgUnVuSW5Sb290RnJhbWUgPSB7XG4gICAgRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290OiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgY29udHJvbDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gVGhpcyBzaG91bGQgdGhyb3cuXG4gICAgICAgIGlmIChjb25zdHJ1Y3QpIHtcbiAgICAgICAgICAvLyBTb21ldGhpbmcgc2hvdWxkIGJlIHNldHRpbmcgdGhlIHByb3BzIGluIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgICAgICB2YXIgRmFrZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgfTsgLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG5cblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGYWtlLnByb3RvdHlwZSwgJ3Byb3BzJywge1xuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIC8vIFdlIHVzZSBhIHRocm93aW5nIHNldHRlciBpbnN0ZWFkIG9mIGZyb3plbiBvciBub24td3JpdGFibGUgcHJvcHNcbiAgICAgICAgICAgICAgLy8gYmVjYXVzZSB0aGF0IHdvbid0IHRocm93IGluIGEgbm9uLXN0cmljdCBtb2RlIGZ1bmN0aW9uLlxuICAgICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSAnb2JqZWN0JyAmJiBSZWZsZWN0LmNvbnN0cnVjdCkge1xuICAgICAgICAgICAgLy8gV2UgY29uc3RydWN0IGEgZGlmZmVyZW50IGNvbnRyb2wgZm9yIHRoaXMgY2FzZSB0byBpbmNsdWRlIGFueSBleHRyYVxuICAgICAgICAgICAgLy8gZnJhbWVzIGFkZGVkIGJ5IHRoZSBjb25zdHJ1Y3QgY2FsbC5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIFJlZmxlY3QuY29uc3RydWN0KEZha2UsIFtdKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIFJlZmxlY3QuY29uc3RydWN0KGZuLCBbXSwgRmFrZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIEZha2UuY2FsbCgpO1xuICAgICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgICBjb250cm9sID0geDtcbiAgICAgICAgICAgIH0gLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddIGZvdW5kIHdoZW4gdXBncmFkaW5nIEZsb3dcblxuXG4gICAgICAgICAgICBmbi5jYWxsKEZha2UucHJvdG90eXBlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgICAgfSAvLyBUT0RPKGx1bmEpOiBUaGlzIHdpbGwgY3VycmVudGx5IG9ubHkgdGhyb3cgaWYgdGhlIGZ1bmN0aW9uIGNvbXBvbmVudFxuICAgICAgICAgIC8vIHRyaWVzIHRvIGFjY2VzcyBSZWFjdC9SZWFjdERPTS9wcm9wcy4gV2Ugc2hvdWxkIHByb2JhYmx5IG1ha2UgdGhpcyB0aHJvd1xuICAgICAgICAgIC8vIGluIHNpbXBsZSBjb21wb25lbnRzIHRvb1xuXG5cbiAgICAgICAgICB2YXIgbWF5YmVQcm9taXNlID0gZm4oKTsgLy8gSWYgdGhlIGZ1bmN0aW9uIGNvbXBvbmVudCByZXR1cm5zIGEgcHJvbWlzZSwgaXQncyBsaWtlbHkgYW4gYXN5bmNcbiAgICAgICAgICAvLyBjb21wb25lbnQsIHdoaWNoIHdlIGRvbid0IHlldCBzdXBwb3J0LiBBdHRhY2ggYSBub29wIGNhdGNoIGhhbmRsZXIgdG9cbiAgICAgICAgICAvLyBzaWxlbmNlIHRoZSBlcnJvci5cbiAgICAgICAgICAvLyBUT0RPOiBJbXBsZW1lbnQgY29tcG9uZW50IHN0YWNrcyBmb3IgYXN5bmMgY2xpZW50IGNvbXBvbmVudHM/XG5cbiAgICAgICAgICBpZiAobWF5YmVQcm9taXNlICYmIHR5cGVvZiBtYXliZVByb21pc2UuY2F0Y2ggPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIG1heWJlUHJvbWlzZS5jYXRjaChmdW5jdGlvbiAoKSB7fSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChzYW1wbGUpIHtcbiAgICAgICAgLy8gVGhpcyBpcyBpbmxpbmVkIG1hbnVhbGx5IGJlY2F1c2UgY2xvc3VyZSBkb2Vzbid0IGRvIGl0IGZvciB1cy5cbiAgICAgICAgaWYgKHNhbXBsZSAmJiBjb250cm9sICYmIHR5cGVvZiBzYW1wbGUuc3RhY2sgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgcmV0dXJuIFtzYW1wbGUuc3RhY2ssIGNvbnRyb2wuc3RhY2tdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbbnVsbCwgbnVsbF07XG4gICAgfVxuICB9OyAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ11cblxuICBSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QuZGlzcGxheU5hbWUgPSAnRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290JztcbiAgdmFyIG5hbWVQcm9wRGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoUnVuSW5Sb290RnJhbWUuRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290LCAnbmFtZScpOyAvLyBCZWZvcmUgRVM2LCB0aGUgYG5hbWVgIHByb3BlcnR5IHdhcyBub3QgY29uZmlndXJhYmxlLlxuXG4gIGlmIChuYW1lUHJvcERlc2NyaXB0b3IgJiYgbmFtZVByb3BEZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSkge1xuICAgIC8vIFY4IHV0aWxpemVzIGEgZnVuY3Rpb24ncyBgbmFtZWAgcHJvcGVydHkgd2hlbiBnZW5lcmF0aW5nIGEgc3RhY2sgdHJhY2UuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJ1bkluUm9vdEZyYW1lLkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCwgLy8gQ29uZmlndXJhYmxlIHByb3BlcnRpZXMgY2FuIGJlIHVwZGF0ZWQgZXZlbiBpZiBpdHMgd3JpdGFibGUgZGVzY3JpcHRvclxuICAgIC8vIGlzIHNldCB0byBgZmFsc2VgLlxuICAgIC8vICRGbG93Rml4TWVbY2Fubm90LXdyaXRlXVxuICAgICduYW1lJywge1xuICAgICAgdmFsdWU6ICdEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QnXG4gICAgfSk7XG4gIH1cblxuICB0cnkge1xuICAgIHZhciBfUnVuSW5Sb290RnJhbWUkRGV0ZXIgPSBSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QoKSxcbiAgICAgICAgc2FtcGxlU3RhY2sgPSBfUnVuSW5Sb290RnJhbWUkRGV0ZXJbMF0sXG4gICAgICAgIGNvbnRyb2xTdGFjayA9IF9SdW5JblJvb3RGcmFtZSREZXRlclsxXTtcblxuICAgIGlmIChzYW1wbGVTdGFjayAmJiBjb250cm9sU3RhY2spIHtcbiAgICAgIC8vIFRoaXMgZXh0cmFjdHMgdGhlIGZpcnN0IGZyYW1lIGZyb20gdGhlIHNhbXBsZSB0aGF0IGlzbid0IGFsc28gaW4gdGhlIGNvbnRyb2wuXG4gICAgICAvLyBTa2lwcGluZyBvbmUgZnJhbWUgdGhhdCB3ZSBhc3N1bWUgaXMgdGhlIGZyYW1lIHRoYXQgY2FsbHMgdGhlIHR3by5cbiAgICAgIHZhciBzYW1wbGVMaW5lcyA9IHNhbXBsZVN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBjb250cm9sTGluZXMgPSBjb250cm9sU3RhY2suc3BsaXQoJ1xcbicpO1xuICAgICAgdmFyIHMgPSAwO1xuICAgICAgdmFyIGMgPSAwO1xuXG4gICAgICB3aGlsZSAocyA8IHNhbXBsZUxpbmVzLmxlbmd0aCAmJiAhc2FtcGxlTGluZXNbc10uaW5jbHVkZXMoJ0RldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCcpKSB7XG4gICAgICAgIHMrKztcbiAgICAgIH1cblxuICAgICAgd2hpbGUgKGMgPCBjb250cm9sTGluZXMubGVuZ3RoICYmICFjb250cm9sTGluZXNbY10uaW5jbHVkZXMoJ0RldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCcpKSB7XG4gICAgICAgIGMrKztcbiAgICAgIH0gLy8gV2UgY291bGRuJ3QgZmluZCBvdXIgaW50ZW50aW9uYWxseSBpbmplY3RlZCBjb21tb24gcm9vdCBmcmFtZSwgYXR0ZW1wdFxuICAgICAgLy8gdG8gZmluZCBhbm90aGVyIGNvbW1vbiByb290IGZyYW1lIGJ5IHNlYXJjaCBmcm9tIHRoZSBib3R0b20gb2YgdGhlXG4gICAgICAvLyBjb250cm9sIHN0YWNrLi4uXG5cblxuICAgICAgaWYgKHMgPT09IHNhbXBsZUxpbmVzLmxlbmd0aCB8fCBjID09PSBjb250cm9sTGluZXMubGVuZ3RoKSB7XG4gICAgICAgIHMgPSBzYW1wbGVMaW5lcy5sZW5ndGggLSAxO1xuICAgICAgICBjID0gY29udHJvbExpbmVzLmxlbmd0aCAtIDE7XG5cbiAgICAgICAgd2hpbGUgKHMgPj0gMSAmJiBjID49IDAgJiYgc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAgIC8vIFdlIGV4cGVjdCBhdCBsZWFzdCBvbmUgc3RhY2sgZnJhbWUgdG8gYmUgc2hhcmVkLlxuICAgICAgICAgIC8vIFR5cGljYWxseSB0aGlzIHdpbGwgYmUgdGhlIHJvb3QgbW9zdCBvbmUuIEhvd2V2ZXIsIHN0YWNrIGZyYW1lcyBtYXkgYmVcbiAgICAgICAgICAvLyBjdXQgb2ZmIGR1ZSB0byBtYXhpbXVtIHN0YWNrIGxpbWl0cy4gSW4gdGhpcyBjYXNlLCBvbmUgbWF5YmUgY3V0IG9mZlxuICAgICAgICAgIC8vIGVhcmxpZXIgdGhhbiB0aGUgb3RoZXIuIFdlIGFzc3VtZSB0aGF0IHRoZSBzYW1wbGUgaXMgbG9uZ2VyIG9yIHRoZSBzYW1lXG4gICAgICAgICAgLy8gYW5kIHRoZXJlIGZvciBjdXQgb2ZmIGVhcmxpZXIuIFNvIHdlIHNob3VsZCBmaW5kIHRoZSByb290IG1vc3QgZnJhbWUgaW5cbiAgICAgICAgICAvLyB0aGUgc2FtcGxlIHNvbWV3aGVyZSBpbiB0aGUgY29udHJvbC5cbiAgICAgICAgICBjLS07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yICg7IHMgPj0gMSAmJiBjID49IDA7IHMtLSwgYy0tKSB7XG4gICAgICAgIC8vIE5leHQgd2UgZmluZCB0aGUgZmlyc3Qgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgd2hpY2ggc2hvdWxkIGJlIHRoZVxuICAgICAgICAvLyBmcmFtZSB0aGF0IGNhbGxlZCBvdXIgc2FtcGxlIGZ1bmN0aW9uIGFuZCB0aGUgY29udHJvbC5cbiAgICAgICAgaWYgKHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAvLyBJbiBWOCwgdGhlIGZpcnN0IGxpbmUgaXMgZGVzY3JpYmluZyB0aGUgbWVzc2FnZSBidXQgb3RoZXIgVk1zIGRvbid0LlxuICAgICAgICAgIC8vIElmIHdlJ3JlIGFib3V0IHRvIHJldHVybiB0aGUgZmlyc3QgbGluZSwgYW5kIHRoZSBjb250cm9sIGlzIGFsc28gb24gdGhlIHNhbWVcbiAgICAgICAgICAvLyBsaW5lLCB0aGF0J3MgYSBwcmV0dHkgZ29vZCBpbmRpY2F0b3IgdGhhdCBvdXIgc2FtcGxlIHRocmV3IGF0IHNhbWUgbGluZSBhc1xuICAgICAgICAgIC8vIHRoZSBjb250cm9sLiBJLmUuIGJlZm9yZSB3ZSBlbnRlcmVkIHRoZSBzYW1wbGUgZnJhbWUuIFNvIHdlIGlnbm9yZSB0aGlzIHJlc3VsdC5cbiAgICAgICAgICAvLyBUaGlzIGNhbiBoYXBwZW4gaWYgeW91IHBhc3NlZCBhIGNsYXNzIHRvIGZ1bmN0aW9uIGNvbXBvbmVudCwgb3Igbm9uLWZ1bmN0aW9uLlxuICAgICAgICAgIGlmIChzICE9PSAxIHx8IGMgIT09IDEpIHtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgcy0tO1xuICAgICAgICAgICAgICBjLS07IC8vIFdlIG1heSBzdGlsbCBoYXZlIHNpbWlsYXIgaW50ZXJtZWRpYXRlIGZyYW1lcyBmcm9tIHRoZSBjb25zdHJ1Y3QgY2FsbC5cbiAgICAgICAgICAgICAgLy8gVGhlIG5leHQgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgc2hvdWxkIGJlIG91ciBtYXRjaCB0aG91Z2guXG5cbiAgICAgICAgICAgICAgaWYgKGMgPCAwIHx8IHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAgICAgICAvLyBWOCBhZGRzIGEgXCJuZXdcIiBwcmVmaXggZm9yIG5hdGl2ZSBjbGFzc2VzLiBMZXQncyByZW1vdmUgaXQgdG8gbWFrZSBpdCBwcmV0dGllci5cbiAgICAgICAgICAgICAgICB2YXIgX2ZyYW1lID0gJ1xcbicgKyBzYW1wbGVMaW5lc1tzXS5yZXBsYWNlKCcgYXQgbmV3ICcsICcgYXQgJyk7IC8vIElmIG91ciBjb21wb25lbnQgZnJhbWUgaXMgbGFiZWxlZCBcIjxhbm9ueW1vdXM+XCJcbiAgICAgICAgICAgICAgICAvLyBidXQgd2UgaGF2ZSBhIHVzZXItcHJvdmlkZWQgXCJkaXNwbGF5TmFtZVwiXG4gICAgICAgICAgICAgICAgLy8gc3BsaWNlIGl0IGluIHRvIG1ha2UgdGhlIHN0YWNrIG1vcmUgcmVhZGFibGUuXG5cblxuICAgICAgICAgICAgICAgIGlmIChmbi5kaXNwbGF5TmFtZSAmJiBfZnJhbWUuaW5jbHVkZXMoJzxhbm9ueW1vdXM+JykpIHtcbiAgICAgICAgICAgICAgICAgIF9mcmFtZSA9IF9mcmFtZS5yZXBsYWNlKCc8YW5vbnltb3VzPicsIGZuLmRpc3BsYXlOYW1lKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgX2ZyYW1lKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IC8vIFJldHVybiB0aGUgbGluZSB3ZSBmb3VuZC5cblxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9mcmFtZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSB3aGlsZSAocyA+PSAxICYmIGMgPj0gMCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZmluYWxseSB7XG4gICAgcmVlbnRyeSA9IGZhbHNlO1xuXG4gICAge1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50ID0gcHJldmlvdXNEaXNwYXRjaGVyO1xuICAgICAgcmVlbmFibGVMb2dzKCk7XG4gICAgfVxuXG4gICAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSBwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlO1xuICB9IC8vIEZhbGxiYWNrIHRvIGp1c3QgdXNpbmcgdGhlIG5hbWUgaWYgd2UgY291bGRuJ3QgbWFrZSBpdCB0aHJvdy5cblxuXG4gIHZhciBuYW1lID0gZm4gPyBmbi5kaXNwbGF5TmFtZSB8fCBmbi5uYW1lIDogJyc7XG4gIHZhciBzeW50aGV0aWNGcmFtZSA9IG5hbWUgPyBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lKSA6ICcnO1xuXG4gIHtcbiAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgc3ludGhldGljRnJhbWUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzeW50aGV0aWNGcmFtZTtcbn1cbmZ1bmN0aW9uIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZShmbiwgb3duZXJGbikge1xuICB7XG4gICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGZhbHNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzaG91bGRDb25zdHJ1Y3QoQ29tcG9uZW50KSB7XG4gIHZhciBwcm90b3R5cGUgPSBDb21wb25lbnQucHJvdG90eXBlO1xuICByZXR1cm4gISEocHJvdG90eXBlICYmIHByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50KTtcbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUsIG93bmVyRm4pIHtcblxuICBpZiAodHlwZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAge1xuICAgICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUodHlwZSwgc2hvdWxkQ29uc3RydWN0KHR5cGUpKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKHR5cGUpO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKCdTdXNwZW5zZScpO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlTGlzdCcpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICByZXR1cm4gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKHR5cGUucmVuZGVyKTtcblxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgIC8vIE1lbW8gbWF5IGNvbnRhaW4gYW55IGNvbXBvbmVudCB0eXBlIHNvIHdlIHJlY3Vyc2l2ZWx5IHJlc29sdmUgaXQuXG4gICAgICAgIHJldHVybiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYodHlwZS50eXBlLCBvd25lckZuKTtcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBMYXp5IG1heSBjb250YWluIGFueSBjb21wb25lbnQgdHlwZSBzbyB3ZSByZWN1cnNpdmVseSByZXNvbHZlIGl0LlxuICAgICAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihpbml0KHBheWxvYWQpLCBvd25lckZuKTtcbiAgICAgICAgICB9IGNhdGNoICh4KSB7fVxuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRPd25lcjtcbnZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcbnZhciBSRUFDVF9DTElFTlRfUkVGRVJFTkNFID0gU3ltYm9sLmZvcigncmVhY3QuY2xpZW50LnJlZmVyZW5jZScpO1xudmFyIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duO1xudmFyIHNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duO1xudmFyIGRpZFdhcm5BYm91dFN0cmluZ1JlZnM7XG5cbntcbiAgZGlkV2FybkFib3V0U3RyaW5nUmVmcyA9IHt9O1xufVxuXG5mdW5jdGlvbiBoYXNWYWxpZFJlZihjb25maWcpIHtcbiAge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgJ3JlZicpKSB7XG4gICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsICdyZWYnKS5nZXQ7XG5cbiAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29uZmlnLnJlZiAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBoYXNWYWxpZEtleShjb25maWcpIHtcbiAge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgJ2tleScpKSB7XG4gICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsICdrZXknKS5nZXQ7XG5cbiAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29uZmlnLmtleSAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiB3YXJuSWZTdHJpbmdSZWZDYW5ub3RCZUF1dG9Db252ZXJ0ZWQoY29uZmlnLCBzZWxmKSB7XG4gIHtcbiAgICBpZiAodHlwZW9mIGNvbmZpZy5yZWYgPT09ICdzdHJpbmcnICYmIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgJiYgc2VsZiAmJiBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnN0YXRlTm9kZSAhPT0gc2VsZikge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKTtcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRTdHJpbmdSZWZzW2NvbXBvbmVudE5hbWVdKSB7XG4gICAgICAgIGVycm9yKCdDb21wb25lbnQgXCIlc1wiIGNvbnRhaW5zIHRoZSBzdHJpbmcgcmVmIFwiJXNcIi4gJyArICdTdXBwb3J0IGZvciBzdHJpbmcgcmVmcyB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gJyArICdUaGlzIGNhc2UgY2Fubm90IGJlIGF1dG9tYXRpY2FsbHkgY29udmVydGVkIHRvIGFuIGFycm93IGZ1bmN0aW9uLiAnICsgJ1dlIGFzayB5b3UgdG8gbWFudWFsbHkgZml4IHRoaXMgY2FzZSBieSB1c2luZyB1c2VSZWYoKSBvciBjcmVhdGVSZWYoKSBpbnN0ZWFkLiAnICsgJ0xlYXJuIG1vcmUgYWJvdXQgdXNpbmcgcmVmcyBzYWZlbHkgaGVyZTogJyArICdodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3RyaWN0LW1vZGUtc3RyaW5nLXJlZicsIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnR5cGUpLCBjb25maWcucmVmKTtcblxuICAgICAgICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzW2NvbXBvbmVudE5hbWVdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gIHtcbiAgICB2YXIgd2FybkFib3V0QWNjZXNzaW5nS2V5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93bikge1xuICAgICAgICBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biA9IHRydWU7XG5cbiAgICAgICAgZXJyb3IoJyVzOiBga2V5YCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3NwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB3YXJuQWJvdXRBY2Nlc3NpbmdLZXkuaXNSZWFjdFdhcm5pbmcgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgJ2tleScsIHtcbiAgICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nS2V5LFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gIHtcbiAgICB7XG4gICAgICB2YXIgd2FybkFib3V0QWNjZXNzaW5nUmVmID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duKSB7XG4gICAgICAgICAgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24gPSB0cnVlO1xuXG4gICAgICAgICAgZXJyb3IoJyVzOiBgcmVmYCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3NwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYuaXNSZWFjdFdhcm5pbmcgPSB0cnVlO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCAncmVmJywge1xuICAgICAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ1JlZixcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogRmFjdG9yeSBtZXRob2QgdG8gY3JlYXRlIGEgbmV3IFJlYWN0IGVsZW1lbnQuIFRoaXMgbm8gbG9uZ2VyIGFkaGVyZXMgdG9cbiAqIHRoZSBjbGFzcyBwYXR0ZXJuLCBzbyBkbyBub3QgdXNlIG5ldyB0byBjYWxsIGl0LiBBbHNvLCBpbnN0YW5jZW9mIGNoZWNrXG4gKiB3aWxsIG5vdCB3b3JrLiBJbnN0ZWFkIHRlc3QgJCR0eXBlb2YgZmllbGQgYWdhaW5zdCBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50JykgdG8gY2hlY2tcbiAqIGlmIHNvbWV0aGluZyBpcyBhIFJlYWN0IEVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0geyp9IHByb3BzXG4gKiBAcGFyYW0geyp9IGtleVxuICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSByZWZcbiAqIEBwYXJhbSB7Kn0gb3duZXJcbiAqIEBwYXJhbSB7Kn0gc2VsZiBBICp0ZW1wb3JhcnkqIGhlbHBlciB0byBkZXRlY3QgcGxhY2VzIHdoZXJlIGB0aGlzYCBpc1xuICogZGlmZmVyZW50IGZyb20gdGhlIGBvd25lcmAgd2hlbiBSZWFjdC5jcmVhdGVFbGVtZW50IGlzIGNhbGxlZCwgc28gdGhhdCB3ZVxuICogY2FuIHdhcm4uIFdlIHdhbnQgdG8gZ2V0IHJpZCBvZiBvd25lciBhbmQgcmVwbGFjZSBzdHJpbmcgYHJlZmBzIHdpdGggYXJyb3dcbiAqIGZ1bmN0aW9ucywgYW5kIGFzIGxvbmcgYXMgYHRoaXNgIGFuZCBvd25lciBhcmUgdGhlIHNhbWUsIHRoZXJlIHdpbGwgYmUgbm9cbiAqIGNoYW5nZSBpbiBiZWhhdmlvci5cbiAqIEBwYXJhbSB7Kn0gc291cmNlIEFuIGFubm90YXRpb24gb2JqZWN0IChhZGRlZCBieSBhIHRyYW5zcGlsZXIgb3Igb3RoZXJ3aXNlKVxuICogaW5kaWNhdGluZyBmaWxlbmFtZSwgbGluZSBudW1iZXIsIGFuZC9vciBvdGhlciBpbmZvcm1hdGlvbi5cbiAqIEBpbnRlcm5hbFxuICovXG5cblxuZnVuY3Rpb24gUmVhY3RFbGVtZW50KHR5cGUsIGtleSwgX3JlZiwgc2VsZiwgc291cmNlLCBvd25lciwgcHJvcHMpIHtcbiAgdmFyIHJlZjtcblxuICB7XG4gICAgcmVmID0gX3JlZjtcbiAgfVxuXG4gIHZhciBlbGVtZW50O1xuXG4gIHtcbiAgICAvLyBJbiBwcm9kLCBgcmVmYCBpcyBhIHJlZ3VsYXIgcHJvcGVydHkuIEl0IHdpbGwgYmUgcmVtb3ZlZCBpbiBhXG4gICAgLy8gZnV0dXJlIHJlbGVhc2UuXG4gICAgZWxlbWVudCA9IHtcbiAgICAgIC8vIFRoaXMgdGFnIGFsbG93cyB1cyB0byB1bmlxdWVseSBpZGVudGlmeSB0aGlzIGFzIGEgUmVhY3QgRWxlbWVudFxuICAgICAgJCR0eXBlb2Y6IFJFQUNUX0VMRU1FTlRfVFlQRSxcbiAgICAgIC8vIEJ1aWx0LWluIHByb3BlcnRpZXMgdGhhdCBiZWxvbmcgb24gdGhlIGVsZW1lbnRcbiAgICAgIHR5cGU6IHR5cGUsXG4gICAgICBrZXk6IGtleSxcbiAgICAgIHJlZjogcmVmLFxuICAgICAgcHJvcHM6IHByb3BzLFxuICAgICAgLy8gUmVjb3JkIHRoZSBjb21wb25lbnQgcmVzcG9uc2libGUgZm9yIGNyZWF0aW5nIHRoaXMgZWxlbWVudC5cbiAgICAgIF9vd25lcjogb3duZXJcbiAgICB9O1xuICB9XG5cbiAge1xuICAgIC8vIFRoZSB2YWxpZGF0aW9uIGZsYWcgaXMgY3VycmVudGx5IG11dGF0aXZlLiBXZSBwdXQgaXQgb25cbiAgICAvLyBhbiBleHRlcm5hbCBiYWNraW5nIHN0b3JlIHNvIHRoYXQgd2UgY2FuIGZyZWV6ZSB0aGUgd2hvbGUgb2JqZWN0LlxuICAgIC8vIFRoaXMgY2FuIGJlIHJlcGxhY2VkIHdpdGggYSBXZWFrTWFwIG9uY2UgdGhleSBhcmUgaW1wbGVtZW50ZWQgaW5cbiAgICAvLyBjb21tb25seSB1c2VkIGRldmVsb3BtZW50IGVudmlyb25tZW50cy5cbiAgICBlbGVtZW50Ll9zdG9yZSA9IHt9OyAvLyBUbyBtYWtlIGNvbXBhcmluZyBSZWFjdEVsZW1lbnRzIGVhc2llciBmb3IgdGVzdGluZyBwdXJwb3Nlcywgd2UgbWFrZVxuICAgIC8vIHRoZSB2YWxpZGF0aW9uIGZsYWcgbm9uLWVudW1lcmFibGUgKHdoZXJlIHBvc3NpYmxlLCB3aGljaCBzaG91bGRcbiAgICAvLyBpbmNsdWRlIGV2ZXJ5IGVudmlyb25tZW50IHdlIHJ1biB0ZXN0cyBpbiksIHNvIHRoZSB0ZXN0IGZyYW1ld29ya1xuICAgIC8vIGlnbm9yZXMgaXQuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudC5fc3RvcmUsICd2YWxpZGF0ZWQnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH0pOyAvLyBkZWJ1Z0luZm8gY29udGFpbnMgU2VydmVyIENvbXBvbmVudCBkZWJ1ZyBpbmZvcm1hdGlvbi5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX2RlYnVnSW5mbycsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IG51bGxcbiAgICB9KTtcblxuICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQucHJvcHMpO1xuICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn1cbnZhciBkaWRXYXJuQWJvdXRLZXlTcHJlYWQgPSB7fTtcbi8qKlxuICogaHR0cHM6Ly9naXRodWIuY29tL3JlYWN0anMvcmZjcy9wdWxsLzEwN1xuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0ge29iamVjdH0gcHJvcHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAqL1xuXG5mdW5jdGlvbiBqc3hERVYkMSh0eXBlLCBjb25maWcsIG1heWJlS2V5LCBpc1N0YXRpY0NoaWxkcmVuLCBzb3VyY2UsIHNlbGYpIHtcbiAge1xuICAgIGlmICghaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpKSB7XG4gICAgICAvLyBUaGlzIGlzIGFuIGludmFsaWQgZWxlbWVudCB0eXBlLlxuICAgICAgLy9cbiAgICAgIC8vIFdlIHdhcm4gaW4gdGhpcyBjYXNlIGJ1dCBkb24ndCB0aHJvdy4gV2UgZXhwZWN0IHRoZSBlbGVtZW50IGNyZWF0aW9uIHRvXG4gICAgICAvLyBzdWNjZWVkIGFuZCB0aGVyZSB3aWxsIGxpa2VseSBiZSBlcnJvcnMgaW4gcmVuZGVyLlxuICAgICAgdmFyIGluZm8gPSAnJztcblxuICAgICAgaWYgKHR5cGUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCAmJiBPYmplY3Qua2V5cyh0eXBlKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgaW5mbyArPSAnIFlvdSBsaWtlbHkgZm9yZ290IHRvIGV4cG9ydCB5b3VyIGNvbXBvbmVudCBmcm9tIHRoZSBmaWxlICcgKyBcIml0J3MgZGVmaW5lZCBpbiwgb3IgeW91IG1pZ2h0IGhhdmUgbWl4ZWQgdXAgZGVmYXVsdCBhbmQgbmFtZWQgaW1wb3J0cy5cIjtcbiAgICAgIH1cblxuICAgICAgdmFyIHR5cGVTdHJpbmc7XG5cbiAgICAgIGlmICh0eXBlID09PSBudWxsKSB7XG4gICAgICAgIHR5cGVTdHJpbmcgPSAnbnVsbCc7XG4gICAgICB9IGVsc2UgaWYgKGlzQXJyYXkodHlwZSkpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9ICdhcnJheSc7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgIT09IHVuZGVmaW5lZCAmJiB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEUpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9IFwiPFwiICsgKGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8ICdVbmtub3duJykgKyBcIiAvPlwiO1xuICAgICAgICBpbmZvID0gJyBEaWQgeW91IGFjY2lkZW50YWxseSBleHBvcnQgYSBKU1ggbGl0ZXJhbCBpbnN0ZWFkIG9mIGEgY29tcG9uZW50Pyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0eXBlU3RyaW5nID0gdHlwZW9mIHR5cGU7XG4gICAgICB9XG5cbiAgICAgIGVycm9yKCdSZWFjdC5qc3g6IHR5cGUgaXMgaW52YWxpZCAtLSBleHBlY3RlZCBhIHN0cmluZyAoZm9yICcgKyAnYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSAnICsgJ2NvbXBvbmVudHMpIGJ1dCBnb3Q6ICVzLiVzJywgdHlwZVN0cmluZywgaW5mbyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoaXMgaXMgYSB2YWxpZCBlbGVtZW50IHR5cGUuXG4gICAgICAvLyBTa2lwIGtleSB3YXJuaW5nIGlmIHRoZSB0eXBlIGlzbid0IHZhbGlkIHNpbmNlIG91ciBrZXkgdmFsaWRhdGlvbiBsb2dpY1xuICAgICAgLy8gZG9lc24ndCBleHBlY3QgYSBub24tc3RyaW5nL2Z1bmN0aW9uIHR5cGUgYW5kIGNhbiB0aHJvdyBjb25mdXNpbmdcbiAgICAgIC8vIGVycm9ycy4gV2UgZG9uJ3Qgd2FudCBleGNlcHRpb24gYmVoYXZpb3IgdG8gZGlmZmVyIGJldHdlZW4gZGV2IGFuZFxuICAgICAgLy8gcHJvZC4gKFJlbmRlcmluZyB3aWxsIHRocm93IHdpdGggYSBoZWxwZnVsIG1lc3NhZ2UgYW5kIGFzIHNvb24gYXMgdGhlXG4gICAgICAvLyB0eXBlIGlzIGZpeGVkLCB0aGUga2V5IHdhcm5pbmdzIHdpbGwgYXBwZWFyLilcbiAgICAgIHZhciBjaGlsZHJlbiA9IGNvbmZpZy5jaGlsZHJlbjtcblxuICAgICAgaWYgKGNoaWxkcmVuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGlzU3RhdGljQ2hpbGRyZW4pIHtcbiAgICAgICAgICBpZiAoaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgdmFsaWRhdGVDaGlsZEtleXMoY2hpbGRyZW5baV0sIHR5cGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xuICAgICAgICAgICAgICBPYmplY3QuZnJlZXplKGNoaWxkcmVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXJyb3IoJ1JlYWN0LmpzeDogU3RhdGljIGNoaWxkcmVuIHNob3VsZCBhbHdheXMgYmUgYW4gYXJyYXkuICcgKyAnWW91IGFyZSBsaWtlbHkgZXhwbGljaXRseSBjYWxsaW5nIFJlYWN0LmpzeHMgb3IgUmVhY3QuanN4REVWLiAnICsgJ1VzZSB0aGUgQmFiZWwgdHJhbnNmb3JtIGluc3RlYWQuJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGNoaWxkcmVuLCB0eXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gLy8gV2FybiBhYm91dCBrZXkgc3ByZWFkIHJlZ2FyZGxlc3Mgb2Ygd2hldGhlciB0aGUgdHlwZSBpcyB2YWxpZC5cblxuXG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAna2V5JykpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhjb25maWcpLmZpbHRlcihmdW5jdGlvbiAoaykge1xuICAgICAgICByZXR1cm4gayAhPT0gJ2tleSc7XG4gICAgICB9KTtcbiAgICAgIHZhciBiZWZvcmVFeGFtcGxlID0ga2V5cy5sZW5ndGggPiAwID8gJ3trZXk6IHNvbWVLZXksICcgKyBrZXlzLmpvaW4oJzogLi4uLCAnKSArICc6IC4uLn0nIDogJ3trZXk6IHNvbWVLZXl9JztcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRLZXlTcHJlYWRbY29tcG9uZW50TmFtZSArIGJlZm9yZUV4YW1wbGVdKSB7XG4gICAgICAgIHZhciBhZnRlckV4YW1wbGUgPSBrZXlzLmxlbmd0aCA+IDAgPyAneycgKyBrZXlzLmpvaW4oJzogLi4uLCAnKSArICc6IC4uLn0nIDogJ3t9JztcblxuICAgICAgICBlcnJvcignQSBwcm9wcyBvYmplY3QgY29udGFpbmluZyBhIFwia2V5XCIgcHJvcCBpcyBiZWluZyBzcHJlYWQgaW50byBKU1g6XFxuJyArICcgIGxldCBwcm9wcyA9ICVzO1xcbicgKyAnICA8JXMgey4uLnByb3BzfSAvPlxcbicgKyAnUmVhY3Qga2V5cyBtdXN0IGJlIHBhc3NlZCBkaXJlY3RseSB0byBKU1ggd2l0aG91dCB1c2luZyBzcHJlYWQ6XFxuJyArICcgIGxldCBwcm9wcyA9ICVzO1xcbicgKyAnICA8JXMga2V5PXtzb21lS2V5fSB7Li4ucHJvcHN9IC8+JywgYmVmb3JlRXhhbXBsZSwgY29tcG9uZW50TmFtZSwgYWZ0ZXJFeGFtcGxlLCBjb21wb25lbnROYW1lKTtcblxuICAgICAgICBkaWRXYXJuQWJvdXRLZXlTcHJlYWRbY29tcG9uZW50TmFtZSArIGJlZm9yZUV4YW1wbGVdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcHJvcE5hbWU7IC8vIFJlc2VydmVkIG5hbWVzIGFyZSBleHRyYWN0ZWRcblxuICAgIHZhciBwcm9wcyA9IHt9O1xuICAgIHZhciBrZXkgPSBudWxsO1xuICAgIHZhciByZWYgPSBudWxsOyAvLyBDdXJyZW50bHksIGtleSBjYW4gYmUgc3ByZWFkIGluIGFzIGEgcHJvcC4gVGhpcyBjYXVzZXMgYSBwb3RlbnRpYWxcbiAgICAvLyBpc3N1ZSBpZiBrZXkgaXMgYWxzbyBleHBsaWNpdGx5IGRlY2xhcmVkIChpZS4gPGRpdiB7Li4ucHJvcHN9IGtleT1cIkhpXCIgLz5cbiAgICAvLyBvciA8ZGl2IGtleT1cIkhpXCIgey4uLnByb3BzfSAvPiApLiBXZSB3YW50IHRvIGRlcHJlY2F0ZSBrZXkgc3ByZWFkLFxuICAgIC8vIGJ1dCBhcyBhbiBpbnRlcm1lZGlhcnkgc3RlcCwgd2Ugd2lsbCB1c2UganN4REVWIGZvciBldmVyeXRoaW5nIGV4Y2VwdFxuICAgIC8vIDxkaXYgey4uLnByb3BzfSBrZXk9XCJIaVwiIC8+LCBiZWNhdXNlIHdlIGFyZW4ndCBjdXJyZW50bHkgYWJsZSB0byB0ZWxsIGlmXG4gICAgLy8ga2V5IGlzIGV4cGxpY2l0bHkgZGVjbGFyZWQgdG8gYmUgdW5kZWZpbmVkIG9yIG5vdC5cblxuICAgIGlmIChtYXliZUtleSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB7XG4gICAgICAgIGNoZWNrS2V5U3RyaW5nQ29lcmNpb24obWF5YmVLZXkpO1xuICAgICAgfVxuXG4gICAgICBrZXkgPSAnJyArIG1heWJlS2V5O1xuICAgIH1cblxuICAgIGlmIChoYXNWYWxpZEtleShjb25maWcpKSB7XG4gICAgICB7XG4gICAgICAgIGNoZWNrS2V5U3RyaW5nQ29lcmNpb24oY29uZmlnLmtleSk7XG4gICAgICB9XG5cbiAgICAgIGtleSA9ICcnICsgY29uZmlnLmtleTtcbiAgICB9XG5cbiAgICBpZiAoaGFzVmFsaWRSZWYoY29uZmlnKSkge1xuICAgICAge1xuICAgICAgICByZWYgPSBjb25maWcucmVmO1xuICAgICAgfVxuXG4gICAgICB3YXJuSWZTdHJpbmdSZWZDYW5ub3RCZUF1dG9Db252ZXJ0ZWQoY29uZmlnLCBzZWxmKTtcbiAgICB9IC8vIFJlbWFpbmluZyBwcm9wZXJ0aWVzIGFyZSBhZGRlZCB0byBhIG5ldyBwcm9wcyBvYmplY3RcblxuXG4gICAgZm9yIChwcm9wTmFtZSBpbiBjb25maWcpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgcHJvcE5hbWUpICYmIC8vIFNraXAgb3ZlciByZXNlcnZlZCBwcm9wIG5hbWVzXG4gICAgICBwcm9wTmFtZSAhPT0gJ2tleScgJiYgKHByb3BOYW1lICE9PSAncmVmJykpIHtcbiAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gY29uZmlnW3Byb3BOYW1lXTtcbiAgICAgIH1cbiAgICB9IC8vIFJlc29sdmUgZGVmYXVsdCBwcm9wc1xuXG5cbiAgICBpZiAodHlwZSAmJiB0eXBlLmRlZmF1bHRQcm9wcykge1xuICAgICAgdmFyIGRlZmF1bHRQcm9wcyA9IHR5cGUuZGVmYXVsdFByb3BzO1xuXG4gICAgICBmb3IgKHByb3BOYW1lIGluIGRlZmF1bHRQcm9wcykge1xuICAgICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBkZWZhdWx0UHJvcHNbcHJvcE5hbWVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGtleSB8fCByZWYpIHtcbiAgICAgIHZhciBkaXNwbGF5TmFtZSA9IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nID8gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgJ1Vua25vd24nIDogdHlwZTtcblxuICAgICAgaWYgKGtleSkge1xuICAgICAgICBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVmKSB7XG4gICAgICAgIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGVsZW1lbnQgPSBSZWFjdEVsZW1lbnQodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCwgcHJvcHMpO1xuXG4gICAgaWYgKHR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUpIHtcbiAgICAgIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhlbGVtZW50KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSB7XG4gIHtcbiAgICBpZiAoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKTtcblxuICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuICdcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfVxufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBldmVyeSBlbGVtZW50IGVpdGhlciBpcyBwYXNzZWQgaW4gYSBzdGF0aWMgbG9jYXRpb24sIGluIGFuXG4gKiBhcnJheSB3aXRoIGFuIGV4cGxpY2l0IGtleXMgcHJvcGVydHkgZGVmaW5lZCwgb3IgaW4gYW4gb2JqZWN0IGxpdGVyYWxcbiAqIHdpdGggdmFsaWQga2V5IHByb3BlcnR5LlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdE5vZGV9IG5vZGUgU3RhdGljYWxseSBwYXNzZWQgY2hpbGQgb2YgYW55IHR5cGUuXG4gKiBAcGFyYW0geyp9IHBhcmVudFR5cGUgbm9kZSdzIHBhcmVudCdzIHR5cGUuXG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZUNoaWxkS2V5cyhub2RlLCBwYXJlbnRUeXBlKSB7XG4gIHtcbiAgICBpZiAodHlwZW9mIG5vZGUgIT09ICdvYmplY3QnIHx8ICFub2RlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG5vZGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UpIDsgZWxzZSBpZiAoaXNBcnJheShub2RlKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGlsZCA9IG5vZGVbaV07XG5cbiAgICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KGNoaWxkKSkge1xuICAgICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoY2hpbGQsIHBhcmVudFR5cGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1ZhbGlkRWxlbWVudChub2RlKSkge1xuICAgICAgLy8gVGhpcyBlbGVtZW50IHdhcyBwYXNzZWQgaW4gYSB2YWxpZCBsb2NhdGlvbi5cbiAgICAgIGlmIChub2RlLl9zdG9yZSkge1xuICAgICAgICBub2RlLl9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obm9kZSk7XG5cbiAgICAgIGlmICh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBFbnRyeSBpdGVyYXRvcnMgdXNlZCB0byBwcm92aWRlIGltcGxpY2l0IGtleXMsXG4gICAgICAgIC8vIGJ1dCBub3cgd2UgcHJpbnQgYSBzZXBhcmF0ZSB3YXJuaW5nIGZvciB0aGVtIGxhdGVyLlxuICAgICAgICBpZiAoaXRlcmF0b3JGbiAhPT0gbm9kZS5lbnRyaWVzKSB7XG4gICAgICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKG5vZGUpO1xuICAgICAgICAgIHZhciBzdGVwO1xuXG4gICAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KHN0ZXAudmFsdWUpKSB7XG4gICAgICAgICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoc3RlcC52YWx1ZSwgcGFyZW50VHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4vKipcbiAqIFZlcmlmaWVzIHRoZSBvYmplY3QgaXMgYSBSZWFjdEVsZW1lbnQuXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI2lzdmFsaWRlbGVtZW50XG4gKiBAcGFyYW0gez9vYmplY3R9IG9iamVjdFxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBgb2JqZWN0YCBpcyBhIFJlYWN0RWxlbWVudC5cbiAqIEBmaW5hbFxuICovXG5cblxuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnQob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QgIT09IG51bGwgJiYgb2JqZWN0LiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEU7XG59XG52YXIgb3duZXJIYXNLZXlVc2VXYXJuaW5nID0ge307XG4vKipcbiAqIFdhcm4gaWYgdGhlIGVsZW1lbnQgZG9lc24ndCBoYXZlIGFuIGV4cGxpY2l0IGtleSBhc3NpZ25lZCB0byBpdC5cbiAqIFRoaXMgZWxlbWVudCBpcyBpbiBhbiBhcnJheS4gVGhlIGFycmF5IGNvdWxkIGdyb3cgYW5kIHNocmluayBvciBiZVxuICogcmVvcmRlcmVkLiBBbGwgY2hpbGRyZW4gdGhhdCBoYXZlbid0IGFscmVhZHkgYmVlbiB2YWxpZGF0ZWQgYXJlIHJlcXVpcmVkIHRvXG4gKiBoYXZlIGEgXCJrZXlcIiBwcm9wZXJ0eSBhc3NpZ25lZCB0byBpdC4gRXJyb3Igc3RhdHVzZXMgYXJlIGNhY2hlZCBzbyBhIHdhcm5pbmdcbiAqIHdpbGwgb25seSBiZSBzaG93biBvbmNlLlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0aGF0IHJlcXVpcmVzIGEga2V5LlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIGVsZW1lbnQncyBwYXJlbnQncyB0eXBlLlxuICovXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRXhwbGljaXRLZXkoZWxlbWVudCwgcGFyZW50VHlwZSkge1xuICB7XG4gICAgaWYgKCFlbGVtZW50Ll9zdG9yZSB8fCBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgfHwgZWxlbWVudC5rZXkgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG4gICAgdmFyIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8gPSBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpO1xuXG4gICAgaWYgKG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSA9IHRydWU7IC8vIFVzdWFsbHkgdGhlIGN1cnJlbnQgb3duZXIgaXMgdGhlIG9mZmVuZGVyLCBidXQgaWYgaXQgYWNjZXB0cyBjaGlsZHJlbiBhcyBhXG4gICAgLy8gcHJvcGVydHksIGl0IG1heSBiZSB0aGUgY3JlYXRvciBvZiB0aGUgY2hpbGQgdGhhdCdzIHJlc3BvbnNpYmxlIGZvclxuICAgIC8vIGFzc2lnbmluZyBpdCBhIGtleS5cblxuICAgIHZhciBjaGlsZE93bmVyID0gJyc7XG5cbiAgICBpZiAoZWxlbWVudCAmJiBlbGVtZW50Ll9vd25lciAmJiBlbGVtZW50Ll9vd25lciAhPT0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgICAgLy8gR2l2ZSB0aGUgY29tcG9uZW50IHRoYXQgb3JpZ2luYWxseSBjcmVhdGVkIHRoaXMgY2hpbGQuXG4gICAgICBjaGlsZE93bmVyID0gXCIgSXQgd2FzIHBhc3NlZCBhIGNoaWxkIGZyb20gXCIgKyBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoZWxlbWVudC5fb3duZXIudHlwZSkgKyBcIi5cIjtcbiAgICB9XG5cbiAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KTtcblxuICAgIGVycm9yKCdFYWNoIGNoaWxkIGluIGEgbGlzdCBzaG91bGQgaGF2ZSBhIHVuaXF1ZSBcImtleVwiIHByb3AuJyArICclcyVzIFNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvd2FybmluZy1rZXlzIGZvciBtb3JlIGluZm9ybWF0aW9uLicsIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8sIGNoaWxkT3duZXIpO1xuXG4gICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCkge1xuICB7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgdmFyIHN0YWNrID0gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGVsZW1lbnQudHlwZSwgb3duZXIgPyBvd25lci50eXBlIDogbnVsbCk7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLnNldEV4dHJhU3RhY2tGcmFtZShzdGFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuc2V0RXh0cmFTdGFja0ZyYW1lKG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpIHtcbiAge1xuICAgIHZhciBpbmZvID0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCk7XG5cbiAgICBpZiAoIWluZm8pIHtcbiAgICAgIHZhciBwYXJlbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHBhcmVudFR5cGUpO1xuXG4gICAgICBpZiAocGFyZW50TmFtZSkge1xuICAgICAgICBpbmZvID0gXCJcXG5cXG5DaGVjayB0aGUgdG9wLWxldmVsIHJlbmRlciBjYWxsIHVzaW5nIDxcIiArIHBhcmVudE5hbWUgKyBcIj4uXCI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGluZm87XG4gIH1cbn1cbi8qKlxuICogR2l2ZW4gYSBmcmFnbWVudCwgdmFsaWRhdGUgdGhhdCBpdCBjYW4gb25seSBiZSBwcm92aWRlZCB3aXRoIGZyYWdtZW50IHByb3BzXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZnJhZ21lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhmcmFnbWVudCkge1xuICAvLyBUT0RPOiBNb3ZlIHRoaXMgdG8gcmVuZGVyIHBoYXNlIGluc3RlYWQgb2YgYXQgZWxlbWVudCBjcmVhdGlvbi5cbiAge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZnJhZ21lbnQucHJvcHMpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcblxuICAgICAgaWYgKGtleSAhPT0gJ2NoaWxkcmVuJyAmJiBrZXkgIT09ICdrZXknKSB7XG4gICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGZyYWdtZW50KTtcblxuICAgICAgICBlcnJvcignSW52YWxpZCBwcm9wIGAlc2Agc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4gJyArICdSZWFjdC5GcmFnbWVudCBjYW4gb25seSBoYXZlIGBrZXlgIGFuZCBgY2hpbGRyZW5gIHByb3BzLicsIGtleSk7XG5cbiAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChmcmFnbWVudC5yZWYgIT09IG51bGwpIHtcbiAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGZyYWdtZW50KTtcblxuICAgICAgZXJyb3IoJ0ludmFsaWQgYXR0cmlidXRlIGByZWZgIHN1cHBsaWVkIHRvIGBSZWFjdC5GcmFnbWVudGAuJyk7XG5cbiAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG52YXIganN4REVWID0ganN4REVWJDEgO1xuXG5leHBvcnRzLkZyYWdtZW50ID0gUkVBQ1RfRlJBR01FTlRfVFlQRTtcbmV4cG9ydHMuanN4REVWID0ganN4REVWO1xuICB9KSgpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/jsx-dev-runtime.js ***!
  \******************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-jsx-dev-runtime.development.js */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvanN4LWRldi1ydW50aW1lLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLElBQUksS0FBcUMsRUFBRSxFQUUxQyxDQUFDO0FBQ0YsRUFBRSw4TEFBc0U7QUFDeEUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9yZWFjdC9qc3gtZGV2LXJ1bnRpbWUuanM/YWEwNCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLnByb2R1Y3Rpb24ubWluLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcycpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/make-cancellable-promise/dist/cjs/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/make-cancellable-promise/dist/cjs/index.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nfunction makeCancellablePromise(promise) {\n    var isCancelled = false;\n    var wrappedPromise = new Promise(function (resolve, reject) {\n        promise\n            .then(function (value) { return !isCancelled && resolve(value); })\n            .catch(function (error) { return !isCancelled && reject(error); });\n    });\n    return {\n        promise: wrappedPromise,\n        cancel: function () {\n            isCancelled = true;\n        },\n    };\n}\nexports[\"default\"] = makeCancellablePromise;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tYWtlLWNhbmNlbGxhYmxlLXByb21pc2UvZGlzdC9janMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsd0NBQXdDO0FBQzdFLHNDQUFzQyx1Q0FBdUM7QUFDN0UsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxrQkFBZSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbWFrZS1jYW5jZWxsYWJsZS1wcm9taXNlL2Rpc3QvY2pzL2luZGV4LmpzP2Y2OGIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5mdW5jdGlvbiBtYWtlQ2FuY2VsbGFibGVQcm9taXNlKHByb21pc2UpIHtcbiAgICB2YXIgaXNDYW5jZWxsZWQgPSBmYWxzZTtcbiAgICB2YXIgd3JhcHBlZFByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHByb21pc2VcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gIWlzQ2FuY2VsbGVkICYmIHJlc29sdmUodmFsdWUpOyB9KVxuICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikgeyByZXR1cm4gIWlzQ2FuY2VsbGVkICYmIHJlamVjdChlcnJvcik7IH0pO1xuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICAgIHByb21pc2U6IHdyYXBwZWRQcm9taXNlLFxuICAgICAgICBjYW5jZWw6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlzQ2FuY2VsbGVkID0gdHJ1ZTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gbWFrZUNhbmNlbGxhYmxlUHJvbWlzZTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/make-cancellable-promise/dist/cjs/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/make-event-props/dist/cjs/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/make-event-props/dist/cjs/index.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.allEvents = exports.changeEvents = exports.otherEvents = exports.transitionEvents = exports.animationEvents = exports.wheelEvents = exports.uiEvents = exports.pointerEvents = exports.touchEvents = exports.selectionEvents = exports.dragEvents = exports.mouseEvents = exports.mediaEvents = exports.keyboardEvents = exports.imageEvents = exports.formEvents = exports.focusEvents = exports.compositionEvents = exports.clipboardEvents = void 0;\n// As defined on the list of supported events: https://reactjs.org/docs/events.html\nexports.clipboardEvents = ['onCopy', 'onCut', 'onPaste'];\nexports.compositionEvents = [\n    'onCompositionEnd',\n    'onCompositionStart',\n    'onCompositionUpdate',\n];\nexports.focusEvents = ['onFocus', 'onBlur'];\nexports.formEvents = ['onInput', 'onInvalid', 'onReset', 'onSubmit'];\nexports.imageEvents = ['onLoad', 'onError'];\nexports.keyboardEvents = ['onKeyDown', 'onKeyPress', 'onKeyUp'];\nexports.mediaEvents = [\n    'onAbort',\n    'onCanPlay',\n    'onCanPlayThrough',\n    'onDurationChange',\n    'onEmptied',\n    'onEncrypted',\n    'onEnded',\n    'onError',\n    'onLoadedData',\n    'onLoadedMetadata',\n    'onLoadStart',\n    'onPause',\n    'onPlay',\n    'onPlaying',\n    'onProgress',\n    'onRateChange',\n    'onSeeked',\n    'onSeeking',\n    'onStalled',\n    'onSuspend',\n    'onTimeUpdate',\n    'onVolumeChange',\n    'onWaiting',\n];\nexports.mouseEvents = [\n    'onClick',\n    'onContextMenu',\n    'onDoubleClick',\n    'onMouseDown',\n    'onMouseEnter',\n    'onMouseLeave',\n    'onMouseMove',\n    'onMouseOut',\n    'onMouseOver',\n    'onMouseUp',\n];\nexports.dragEvents = [\n    'onDrag',\n    'onDragEnd',\n    'onDragEnter',\n    'onDragExit',\n    'onDragLeave',\n    'onDragOver',\n    'onDragStart',\n    'onDrop',\n];\nexports.selectionEvents = ['onSelect'];\nexports.touchEvents = ['onTouchCancel', 'onTouchEnd', 'onTouchMove', 'onTouchStart'];\nexports.pointerEvents = [\n    'onPointerDown',\n    'onPointerMove',\n    'onPointerUp',\n    'onPointerCancel',\n    'onGotPointerCapture',\n    'onLostPointerCapture',\n    'onPointerEnter',\n    'onPointerLeave',\n    'onPointerOver',\n    'onPointerOut',\n];\nexports.uiEvents = ['onScroll'];\nexports.wheelEvents = ['onWheel'];\nexports.animationEvents = [\n    'onAnimationStart',\n    'onAnimationEnd',\n    'onAnimationIteration',\n];\nexports.transitionEvents = ['onTransitionEnd'];\nexports.otherEvents = ['onToggle'];\nexports.changeEvents = ['onChange'];\nexports.allEvents = __spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray([], exports.clipboardEvents, true), exports.compositionEvents, true), exports.focusEvents, true), exports.formEvents, true), exports.imageEvents, true), exports.keyboardEvents, true), exports.mediaEvents, true), exports.mouseEvents, true), exports.dragEvents, true), exports.selectionEvents, true), exports.touchEvents, true), exports.pointerEvents, true), exports.uiEvents, true), exports.wheelEvents, true), exports.animationEvents, true), exports.transitionEvents, true), exports.changeEvents, true), exports.otherEvents, true);\n/**\n * Returns an object with on-event callback props curried with provided args.\n * @param {Object} props Props passed to a component.\n * @param {Function=} getArgs A function that returns argument(s) on-event callbacks\n *   shall be curried with.\n */\nfunction makeEventProps(props, getArgs) {\n    var eventProps = {};\n    exports.allEvents.forEach(function (eventName) {\n        var eventHandler = props[eventName];\n        if (!eventHandler) {\n            return;\n        }\n        if (getArgs) {\n            eventProps[eventName] = (function (event) {\n                return eventHandler(event, getArgs(eventName));\n            });\n        }\n        else {\n            eventProps[eventName] = eventHandler;\n        }\n    });\n    return eventProps;\n}\nexports[\"default\"] = makeEventProps;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tYWtlLWV2ZW50LXByb3BzL2Rpc3QvY2pzL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw2RUFBNkUsT0FBTztBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxpQkFBaUIsR0FBRyxvQkFBb0IsR0FBRyxtQkFBbUIsR0FBRyx3QkFBd0IsR0FBRyx1QkFBdUIsR0FBRyxtQkFBbUIsR0FBRyxnQkFBZ0IsR0FBRyxxQkFBcUIsR0FBRyxtQkFBbUIsR0FBRyx1QkFBdUIsR0FBRyxrQkFBa0IsR0FBRyxtQkFBbUIsR0FBRyxtQkFBbUIsR0FBRyxzQkFBc0IsR0FBRyxtQkFBbUIsR0FBRyxrQkFBa0IsR0FBRyxtQkFBbUIsR0FBRyx5QkFBeUIsR0FBRyx1QkFBdUI7QUFDcmI7QUFDQSx1QkFBdUI7QUFDdkIseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CLGtCQUFrQjtBQUNsQixtQkFBbUI7QUFDbkIsc0JBQXNCO0FBQ3RCLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsbUJBQW1CO0FBQ25CLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLG1CQUFtQjtBQUNuQix1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEIsbUJBQW1CO0FBQ25CLG9CQUFvQjtBQUNwQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFdBQVc7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxrQkFBZSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbWFrZS1ldmVudC1wcm9wcy9kaXN0L2Nqcy9pbmRleC5qcz8zMjU5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fc3ByZWFkQXJyYXkgPSAodGhpcyAmJiB0aGlzLl9fc3ByZWFkQXJyYXkpIHx8IGZ1bmN0aW9uICh0bywgZnJvbSwgcGFjaykge1xuICAgIGlmIChwYWNrIHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIGZvciAodmFyIGkgPSAwLCBsID0gZnJvbS5sZW5ndGgsIGFyOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGlmIChhciB8fCAhKGkgaW4gZnJvbSkpIHtcbiAgICAgICAgICAgIGlmICghYXIpIGFyID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSwgMCwgaSk7XG4gICAgICAgICAgICBhcltpXSA9IGZyb21baV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRvLmNvbmNhdChhciB8fCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tKSk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5hbGxFdmVudHMgPSBleHBvcnRzLmNoYW5nZUV2ZW50cyA9IGV4cG9ydHMub3RoZXJFdmVudHMgPSBleHBvcnRzLnRyYW5zaXRpb25FdmVudHMgPSBleHBvcnRzLmFuaW1hdGlvbkV2ZW50cyA9IGV4cG9ydHMud2hlZWxFdmVudHMgPSBleHBvcnRzLnVpRXZlbnRzID0gZXhwb3J0cy5wb2ludGVyRXZlbnRzID0gZXhwb3J0cy50b3VjaEV2ZW50cyA9IGV4cG9ydHMuc2VsZWN0aW9uRXZlbnRzID0gZXhwb3J0cy5kcmFnRXZlbnRzID0gZXhwb3J0cy5tb3VzZUV2ZW50cyA9IGV4cG9ydHMubWVkaWFFdmVudHMgPSBleHBvcnRzLmtleWJvYXJkRXZlbnRzID0gZXhwb3J0cy5pbWFnZUV2ZW50cyA9IGV4cG9ydHMuZm9ybUV2ZW50cyA9IGV4cG9ydHMuZm9jdXNFdmVudHMgPSBleHBvcnRzLmNvbXBvc2l0aW9uRXZlbnRzID0gZXhwb3J0cy5jbGlwYm9hcmRFdmVudHMgPSB2b2lkIDA7XG4vLyBBcyBkZWZpbmVkIG9uIHRoZSBsaXN0IG9mIHN1cHBvcnRlZCBldmVudHM6IGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9ldmVudHMuaHRtbFxuZXhwb3J0cy5jbGlwYm9hcmRFdmVudHMgPSBbJ29uQ29weScsICdvbkN1dCcsICdvblBhc3RlJ107XG5leHBvcnRzLmNvbXBvc2l0aW9uRXZlbnRzID0gW1xuICAgICdvbkNvbXBvc2l0aW9uRW5kJyxcbiAgICAnb25Db21wb3NpdGlvblN0YXJ0JyxcbiAgICAnb25Db21wb3NpdGlvblVwZGF0ZScsXG5dO1xuZXhwb3J0cy5mb2N1c0V2ZW50cyA9IFsnb25Gb2N1cycsICdvbkJsdXInXTtcbmV4cG9ydHMuZm9ybUV2ZW50cyA9IFsnb25JbnB1dCcsICdvbkludmFsaWQnLCAnb25SZXNldCcsICdvblN1Ym1pdCddO1xuZXhwb3J0cy5pbWFnZUV2ZW50cyA9IFsnb25Mb2FkJywgJ29uRXJyb3InXTtcbmV4cG9ydHMua2V5Ym9hcmRFdmVudHMgPSBbJ29uS2V5RG93bicsICdvbktleVByZXNzJywgJ29uS2V5VXAnXTtcbmV4cG9ydHMubWVkaWFFdmVudHMgPSBbXG4gICAgJ29uQWJvcnQnLFxuICAgICdvbkNhblBsYXknLFxuICAgICdvbkNhblBsYXlUaHJvdWdoJyxcbiAgICAnb25EdXJhdGlvbkNoYW5nZScsXG4gICAgJ29uRW1wdGllZCcsXG4gICAgJ29uRW5jcnlwdGVkJyxcbiAgICAnb25FbmRlZCcsXG4gICAgJ29uRXJyb3InLFxuICAgICdvbkxvYWRlZERhdGEnLFxuICAgICdvbkxvYWRlZE1ldGFkYXRhJyxcbiAgICAnb25Mb2FkU3RhcnQnLFxuICAgICdvblBhdXNlJyxcbiAgICAnb25QbGF5JyxcbiAgICAnb25QbGF5aW5nJyxcbiAgICAnb25Qcm9ncmVzcycsXG4gICAgJ29uUmF0ZUNoYW5nZScsXG4gICAgJ29uU2Vla2VkJyxcbiAgICAnb25TZWVraW5nJyxcbiAgICAnb25TdGFsbGVkJyxcbiAgICAnb25TdXNwZW5kJyxcbiAgICAnb25UaW1lVXBkYXRlJyxcbiAgICAnb25Wb2x1bWVDaGFuZ2UnLFxuICAgICdvbldhaXRpbmcnLFxuXTtcbmV4cG9ydHMubW91c2VFdmVudHMgPSBbXG4gICAgJ29uQ2xpY2snLFxuICAgICdvbkNvbnRleHRNZW51JyxcbiAgICAnb25Eb3VibGVDbGljaycsXG4gICAgJ29uTW91c2VEb3duJyxcbiAgICAnb25Nb3VzZUVudGVyJyxcbiAgICAnb25Nb3VzZUxlYXZlJyxcbiAgICAnb25Nb3VzZU1vdmUnLFxuICAgICdvbk1vdXNlT3V0JyxcbiAgICAnb25Nb3VzZU92ZXInLFxuICAgICdvbk1vdXNlVXAnLFxuXTtcbmV4cG9ydHMuZHJhZ0V2ZW50cyA9IFtcbiAgICAnb25EcmFnJyxcbiAgICAnb25EcmFnRW5kJyxcbiAgICAnb25EcmFnRW50ZXInLFxuICAgICdvbkRyYWdFeGl0JyxcbiAgICAnb25EcmFnTGVhdmUnLFxuICAgICdvbkRyYWdPdmVyJyxcbiAgICAnb25EcmFnU3RhcnQnLFxuICAgICdvbkRyb3AnLFxuXTtcbmV4cG9ydHMuc2VsZWN0aW9uRXZlbnRzID0gWydvblNlbGVjdCddO1xuZXhwb3J0cy50b3VjaEV2ZW50cyA9IFsnb25Ub3VjaENhbmNlbCcsICdvblRvdWNoRW5kJywgJ29uVG91Y2hNb3ZlJywgJ29uVG91Y2hTdGFydCddO1xuZXhwb3J0cy5wb2ludGVyRXZlbnRzID0gW1xuICAgICdvblBvaW50ZXJEb3duJyxcbiAgICAnb25Qb2ludGVyTW92ZScsXG4gICAgJ29uUG9pbnRlclVwJyxcbiAgICAnb25Qb2ludGVyQ2FuY2VsJyxcbiAgICAnb25Hb3RQb2ludGVyQ2FwdHVyZScsXG4gICAgJ29uTG9zdFBvaW50ZXJDYXB0dXJlJyxcbiAgICAnb25Qb2ludGVyRW50ZXInLFxuICAgICdvblBvaW50ZXJMZWF2ZScsXG4gICAgJ29uUG9pbnRlck92ZXInLFxuICAgICdvblBvaW50ZXJPdXQnLFxuXTtcbmV4cG9ydHMudWlFdmVudHMgPSBbJ29uU2Nyb2xsJ107XG5leHBvcnRzLndoZWVsRXZlbnRzID0gWydvbldoZWVsJ107XG5leHBvcnRzLmFuaW1hdGlvbkV2ZW50cyA9IFtcbiAgICAnb25BbmltYXRpb25TdGFydCcsXG4gICAgJ29uQW5pbWF0aW9uRW5kJyxcbiAgICAnb25BbmltYXRpb25JdGVyYXRpb24nLFxuXTtcbmV4cG9ydHMudHJhbnNpdGlvbkV2ZW50cyA9IFsnb25UcmFuc2l0aW9uRW5kJ107XG5leHBvcnRzLm90aGVyRXZlbnRzID0gWydvblRvZ2dsZSddO1xuZXhwb3J0cy5jaGFuZ2VFdmVudHMgPSBbJ29uQ2hhbmdlJ107XG5leHBvcnRzLmFsbEV2ZW50cyA9IF9fc3ByZWFkQXJyYXkoX19zcHJlYWRBcnJheShfX3NwcmVhZEFycmF5KF9fc3ByZWFkQXJyYXkoX19zcHJlYWRBcnJheShfX3NwcmVhZEFycmF5KF9fc3ByZWFkQXJyYXkoX19zcHJlYWRBcnJheShfX3NwcmVhZEFycmF5KF9fc3ByZWFkQXJyYXkoX19zcHJlYWRBcnJheShfX3NwcmVhZEFycmF5KF9fc3ByZWFkQXJyYXkoX19zcHJlYWRBcnJheShfX3NwcmVhZEFycmF5KF9fc3ByZWFkQXJyYXkoX19zcHJlYWRBcnJheShfX3NwcmVhZEFycmF5KFtdLCBleHBvcnRzLmNsaXBib2FyZEV2ZW50cywgdHJ1ZSksIGV4cG9ydHMuY29tcG9zaXRpb25FdmVudHMsIHRydWUpLCBleHBvcnRzLmZvY3VzRXZlbnRzLCB0cnVlKSwgZXhwb3J0cy5mb3JtRXZlbnRzLCB0cnVlKSwgZXhwb3J0cy5pbWFnZUV2ZW50cywgdHJ1ZSksIGV4cG9ydHMua2V5Ym9hcmRFdmVudHMsIHRydWUpLCBleHBvcnRzLm1lZGlhRXZlbnRzLCB0cnVlKSwgZXhwb3J0cy5tb3VzZUV2ZW50cywgdHJ1ZSksIGV4cG9ydHMuZHJhZ0V2ZW50cywgdHJ1ZSksIGV4cG9ydHMuc2VsZWN0aW9uRXZlbnRzLCB0cnVlKSwgZXhwb3J0cy50b3VjaEV2ZW50cywgdHJ1ZSksIGV4cG9ydHMucG9pbnRlckV2ZW50cywgdHJ1ZSksIGV4cG9ydHMudWlFdmVudHMsIHRydWUpLCBleHBvcnRzLndoZWVsRXZlbnRzLCB0cnVlKSwgZXhwb3J0cy5hbmltYXRpb25FdmVudHMsIHRydWUpLCBleHBvcnRzLnRyYW5zaXRpb25FdmVudHMsIHRydWUpLCBleHBvcnRzLmNoYW5nZUV2ZW50cywgdHJ1ZSksIGV4cG9ydHMub3RoZXJFdmVudHMsIHRydWUpO1xuLyoqXG4gKiBSZXR1cm5zIGFuIG9iamVjdCB3aXRoIG9uLWV2ZW50IGNhbGxiYWNrIHByb3BzIGN1cnJpZWQgd2l0aCBwcm92aWRlZCBhcmdzLlxuICogQHBhcmFtIHtPYmplY3R9IHByb3BzIFByb3BzIHBhc3NlZCB0byBhIGNvbXBvbmVudC5cbiAqIEBwYXJhbSB7RnVuY3Rpb249fSBnZXRBcmdzIEEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGFyZ3VtZW50KHMpIG9uLWV2ZW50IGNhbGxiYWNrc1xuICogICBzaGFsbCBiZSBjdXJyaWVkIHdpdGguXG4gKi9cbmZ1bmN0aW9uIG1ha2VFdmVudFByb3BzKHByb3BzLCBnZXRBcmdzKSB7XG4gICAgdmFyIGV2ZW50UHJvcHMgPSB7fTtcbiAgICBleHBvcnRzLmFsbEV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChldmVudE5hbWUpIHtcbiAgICAgICAgdmFyIGV2ZW50SGFuZGxlciA9IHByb3BzW2V2ZW50TmFtZV07XG4gICAgICAgIGlmICghZXZlbnRIYW5kbGVyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdldEFyZ3MpIHtcbiAgICAgICAgICAgIGV2ZW50UHJvcHNbZXZlbnROYW1lXSA9IChmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXZlbnRIYW5kbGVyKGV2ZW50LCBnZXRBcmdzKGV2ZW50TmFtZSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBldmVudFByb3BzW2V2ZW50TmFtZV0gPSBldmVudEhhbmRsZXI7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gZXZlbnRQcm9wcztcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IG1ha2VFdmVudFByb3BzO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/make-event-props/dist/cjs/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/merge-refs/dist/cjs/index.js":
/*!***************************************************!*\
  !*** ./node_modules/merge-refs/dist/cjs/index.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/**\n * A function that merges React refs into one.\n * Supports both functions and ref objects created using createRef() and useRef().\n *\n * Usage:\n * ```tsx\n * <div ref={mergeRefs(ref1, ref2, ref3)} />\n * ```\n *\n * @param {(React.Ref<T> | undefined)[]} inputRefs Array of refs\n * @returns {React.Ref<T> | React.RefCallback<T>} Merged refs\n */\nfunction mergeRefs() {\n    var inputRefs = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        inputRefs[_i] = arguments[_i];\n    }\n    var filteredInputRefs = inputRefs.filter(Boolean);\n    if (filteredInputRefs.length <= 1) {\n        var firstRef = filteredInputRefs[0];\n        return firstRef || null;\n    }\n    return function mergedRefs(ref) {\n        filteredInputRefs.forEach(function (inputRef) {\n            if (typeof inputRef === 'function') {\n                inputRef(ref);\n            }\n            else if (inputRef) {\n                inputRef.current = ref;\n            }\n        });\n    };\n}\nexports[\"default\"] = mergeRefs;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tZXJnZS1yZWZzL2Rpc3QvY2pzL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsNkJBQTZCO0FBQzFDO0FBQ0E7QUFDQSxXQUFXLDhCQUE4QjtBQUN6QyxhQUFhLHFDQUFxQztBQUNsRDtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsdUJBQXVCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esa0JBQWUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL21lcmdlLXJlZnMvZGlzdC9janMvaW5kZXguanM/MGU4ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogQSBmdW5jdGlvbiB0aGF0IG1lcmdlcyBSZWFjdCByZWZzIGludG8gb25lLlxuICogU3VwcG9ydHMgYm90aCBmdW5jdGlvbnMgYW5kIHJlZiBvYmplY3RzIGNyZWF0ZWQgdXNpbmcgY3JlYXRlUmVmKCkgYW5kIHVzZVJlZigpLlxuICpcbiAqIFVzYWdlOlxuICogYGBgdHN4XG4gKiA8ZGl2IHJlZj17bWVyZ2VSZWZzKHJlZjEsIHJlZjIsIHJlZjMpfSAvPlxuICogYGBgXG4gKlxuICogQHBhcmFtIHsoUmVhY3QuUmVmPFQ+IHwgdW5kZWZpbmVkKVtdfSBpbnB1dFJlZnMgQXJyYXkgb2YgcmVmc1xuICogQHJldHVybnMge1JlYWN0LlJlZjxUPiB8IFJlYWN0LlJlZkNhbGxiYWNrPFQ+fSBNZXJnZWQgcmVmc1xuICovXG5mdW5jdGlvbiBtZXJnZVJlZnMoKSB7XG4gICAgdmFyIGlucHV0UmVmcyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIGlucHV0UmVmc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICB2YXIgZmlsdGVyZWRJbnB1dFJlZnMgPSBpbnB1dFJlZnMuZmlsdGVyKEJvb2xlYW4pO1xuICAgIGlmIChmaWx0ZXJlZElucHV0UmVmcy5sZW5ndGggPD0gMSkge1xuICAgICAgICB2YXIgZmlyc3RSZWYgPSBmaWx0ZXJlZElucHV0UmVmc1swXTtcbiAgICAgICAgcmV0dXJuIGZpcnN0UmVmIHx8IG51bGw7XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbiBtZXJnZWRSZWZzKHJlZikge1xuICAgICAgICBmaWx0ZXJlZElucHV0UmVmcy5mb3JFYWNoKGZ1bmN0aW9uIChpbnB1dFJlZikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpbnB1dFJlZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGlucHV0UmVmKHJlZik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpbnB1dFJlZikge1xuICAgICAgICAgICAgICAgIGlucHV0UmVmLmN1cnJlbnQgPSByZWY7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG59XG5leHBvcnRzLmRlZmF1bHQgPSBtZXJnZVJlZnM7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/merge-refs/dist/cjs/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-pdf/dist/cjs/Document.js":
/*!*****************************************************!*\
  !*** ./node_modules/react-pdf/dist/cjs/Document.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/* __next_internal_client_entry_do_not_use__  cjs */ \nvar __createBinding = (void 0) && (void 0).__createBinding || (Object.create ? function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n        desc = {\n            enumerable: true,\n            get: function() {\n                return m[k];\n            }\n        };\n    }\n    Object.defineProperty(o, k2, desc);\n} : function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n});\nvar __setModuleDefault = (void 0) && (void 0).__setModuleDefault || (Object.create ? function(o, v) {\n    Object.defineProperty(o, \"default\", {\n        enumerable: true,\n        value: v\n    });\n} : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (void 0) && (void 0).__importStar || function(mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) {\n        for(var k in mod)if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    }\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __awaiter = (void 0) && (void 0).__awaiter || function(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __rest = (void 0) && (void 0).__rest || function(s, e) {\n    var t = {};\n    for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++){\n        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n    }\n    return t;\n};\nvar __importDefault = (void 0) && (void 0).__importDefault || function(mod) {\n    return mod && mod.__esModule ? mod : {\n        \"default\": mod\n    };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nconst react_1 = __importStar(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"));\nconst prop_types_1 = __importDefault(__webpack_require__(/*! prop-types */ \"(app-pages-browser)/./node_modules/prop-types/index.js\"));\nconst make_event_props_1 = __importDefault(__webpack_require__(/*! make-event-props */ \"(app-pages-browser)/./node_modules/make-event-props/dist/cjs/index.js\"));\nconst make_cancellable_promise_1 = __importDefault(__webpack_require__(/*! make-cancellable-promise */ \"(app-pages-browser)/./node_modules/make-cancellable-promise/dist/cjs/index.js\"));\nconst clsx_1 = __importDefault(__webpack_require__(/*! clsx */ \"(app-pages-browser)/./node_modules/clsx/dist/clsx.js\"));\nconst tiny_invariant_1 = __importDefault(__webpack_require__(/*! tiny-invariant */ \"(app-pages-browser)/./node_modules/tiny-invariant/dist/tiny-invariant.cjs.js\"));\nconst warning_1 = __importDefault(__webpack_require__(/*! warning */ \"(app-pages-browser)/./node_modules/warning/warning.js\"));\nconst dequal_1 = __webpack_require__(/*! dequal */ \"(app-pages-browser)/./node_modules/dequal/dist/index.js\");\nconst pdfjs_js_1 = __importDefault(__webpack_require__(/*! ./pdfjs.js */ \"(app-pages-browser)/./node_modules/react-pdf/dist/cjs/pdfjs.js\"));\nconst DocumentContext_js_1 = __importDefault(__webpack_require__(/*! ./DocumentContext.js */ \"(app-pages-browser)/./node_modules/react-pdf/dist/cjs/DocumentContext.js\"));\nconst Message_js_1 = __importDefault(__webpack_require__(/*! ./Message.js */ \"(app-pages-browser)/./node_modules/react-pdf/dist/cjs/Message.js\"));\nconst LinkService_js_1 = __importDefault(__webpack_require__(/*! ./LinkService.js */ \"(app-pages-browser)/./node_modules/react-pdf/dist/cjs/LinkService.js\"));\nconst PasswordResponses_js_1 = __importDefault(__webpack_require__(/*! ./PasswordResponses.js */ \"(app-pages-browser)/./node_modules/react-pdf/dist/cjs/PasswordResponses.js\"));\nconst utils_js_1 = __webpack_require__(/*! ./shared/utils.js */ \"(app-pages-browser)/./node_modules/react-pdf/dist/cjs/shared/utils.js\");\nconst useResolver_js_1 = __importDefault(__webpack_require__(/*! ./shared/hooks/useResolver.js */ \"(app-pages-browser)/./node_modules/react-pdf/dist/cjs/shared/hooks/useResolver.js\"));\nconst propTypes_js_1 = __webpack_require__(/*! ./shared/propTypes.js */ \"(app-pages-browser)/./node_modules/react-pdf/dist/cjs/shared/propTypes.js\");\nconst { PDFDataRangeTransport } = pdfjs_js_1.default;\nconst defaultOnPassword = (callback, reason)=>{\n    switch(reason){\n        case PasswordResponses_js_1.default.NEED_PASSWORD:\n            {\n                // eslint-disable-next-line no-alert\n                const password = prompt(\"Enter the password to open this PDF file.\");\n                callback(password);\n                break;\n            }\n        case PasswordResponses_js_1.default.INCORRECT_PASSWORD:\n            {\n                // eslint-disable-next-line no-alert\n                const password = prompt(\"Invalid password. Please try again.\");\n                callback(password);\n                break;\n            }\n        default:\n    }\n};\nfunction isParameterObject(file) {\n    return typeof file === \"object\" && file !== null && (\"data\" in file || \"range\" in file || \"url\" in file);\n}\n/**\n * Loads a document passed using `file` prop.\n */ const Document = (0, react_1.forwardRef)(function Document(_a, ref) {\n    var { children, className, error = \"Failed to load PDF file.\", externalLinkRel, externalLinkTarget, file, inputRef, imageResourcesPath, loading = \"Loading PDF\", noData = \"No PDF file specified.\", onItemClick, onLoadError: onLoadErrorProps, onLoadProgress, onLoadSuccess: onLoadSuccessProps, onPassword = defaultOnPassword, onSourceError: onSourceErrorProps, onSourceSuccess: onSourceSuccessProps, options, renderMode, rotate } = _a, otherProps = __rest(_a, [\n        \"children\",\n        \"className\",\n        \"error\",\n        \"externalLinkRel\",\n        \"externalLinkTarget\",\n        \"file\",\n        \"inputRef\",\n        \"imageResourcesPath\",\n        \"loading\",\n        \"noData\",\n        \"onItemClick\",\n        \"onLoadError\",\n        \"onLoadProgress\",\n        \"onLoadSuccess\",\n        \"onPassword\",\n        \"onSourceError\",\n        \"onSourceSuccess\",\n        \"options\",\n        \"renderMode\",\n        \"rotate\"\n    ]);\n    const [sourceState, sourceDispatch] = (0, useResolver_js_1.default)();\n    const { value: source, error: sourceError } = sourceState;\n    const [pdfState, pdfDispatch] = (0, useResolver_js_1.default)();\n    const { value: pdf, error: pdfError } = pdfState;\n    const linkService = (0, react_1.useRef)(new LinkService_js_1.default());\n    const pages = (0, react_1.useRef)([]);\n    const prevFile = (0, react_1.useRef)();\n    const prevOptions = (0, react_1.useRef)();\n    (0, react_1.useEffect)(()=>{\n        if (file && file !== prevFile.current && isParameterObject(file)) {\n            (0, warning_1.default)(!(0, dequal_1.dequal)(file, prevFile.current), 'File prop passed to <Document /> changed, but it\\'s equal to previous one. This might result in unnecessary reloads. Consider memoizing the value passed to \"file\" prop.');\n            prevFile.current = file;\n        }\n    }, [\n        file\n    ]);\n    // Detect non-memoized changes in options prop\n    (0, react_1.useEffect)(()=>{\n        if (options && options !== prevOptions.current) {\n            (0, warning_1.default)(!(0, dequal_1.dequal)(options, prevOptions.current), 'Options prop passed to <Document /> changed, but it\\'s equal to previous one. This might result in unnecessary reloads. Consider memoizing the value passed to \"options\" prop.');\n            prevOptions.current = options;\n        }\n    }, [\n        options\n    ]);\n    const viewer = (0, react_1.useRef)({\n        // Handling jumping to internal links target\n        scrollPageIntoView: (args)=>{\n            const { dest, pageNumber, pageIndex = pageNumber - 1 } = args;\n            // First, check if custom handling of onItemClick was provided\n            if (onItemClick) {\n                onItemClick({\n                    dest,\n                    pageIndex,\n                    pageNumber\n                });\n                return;\n            }\n            // If not, try to look for target page within the <Document>.\n            const page = pages.current[pageIndex];\n            if (page) {\n                // Scroll to the page automatically\n                page.scrollIntoView();\n                return;\n            }\n            (0, warning_1.default)(false, \"An internal link leading to page \".concat(pageNumber, \" was clicked, but neither <Document> was provided with onItemClick nor it was able to find the page within itself. Either provide onItemClick to <Document> and handle navigating by yourself or ensure that all pages are rendered within <Document>.\"));\n        }\n    });\n    (0, react_1.useImperativeHandle)(ref, ()=>({\n            linkService,\n            pages,\n            viewer\n        }), []);\n    /**\n     * Called when a document source is resolved correctly\n     */ function onSourceSuccess() {\n        if (onSourceSuccessProps) {\n            onSourceSuccessProps();\n        }\n    }\n    /**\n     * Called when a document source failed to be resolved correctly\n     */ function onSourceError() {\n        if (!sourceError) {\n            // Impossible, but TypeScript doesn't know that\n            return;\n        }\n        (0, warning_1.default)(false, sourceError.toString());\n        if (onSourceErrorProps) {\n            onSourceErrorProps(sourceError);\n        }\n    }\n    function resetSource() {\n        sourceDispatch({\n            type: \"RESET\"\n        });\n    }\n    (0, react_1.useEffect)(resetSource, [\n        file,\n        sourceDispatch\n    ]);\n    const findDocumentSource = (0, react_1.useCallback)(()=>__awaiter(this, void 0, void 0, function*() {\n            if (!file) {\n                return null;\n            }\n            // File is a string\n            if (typeof file === \"string\") {\n                if ((0, utils_js_1.isDataURI)(file)) {\n                    const fileByteString = (0, utils_js_1.dataURItoByteString)(file);\n                    return {\n                        data: fileByteString\n                    };\n                }\n                (0, utils_js_1.displayCORSWarning)();\n                return {\n                    url: file\n                };\n            }\n            // File is PDFDataRangeTransport\n            if (file instanceof PDFDataRangeTransport) {\n                return {\n                    range: file\n                };\n            }\n            // File is an ArrayBuffer\n            if ((0, utils_js_1.isArrayBuffer)(file)) {\n                return {\n                    data: file\n                };\n            }\n            /**\n         * The cases below are browser-only.\n         * If you're running on a non-browser environment, these cases will be of no use.\n         */ if (utils_js_1.isBrowser) {\n                // File is a Blob\n                if ((0, utils_js_1.isBlob)(file)) {\n                    const data = yield (0, utils_js_1.loadFromFile)(file);\n                    return {\n                        data\n                    };\n                }\n            }\n            // At this point, file must be an object\n            (0, tiny_invariant_1.default)(typeof file === \"object\", \"Invalid parameter in file, need either Uint8Array, string or a parameter object\");\n            (0, tiny_invariant_1.default)(isParameterObject(file), \"Invalid parameter object: need either .data, .range or .url\");\n            // File .url is a string\n            if (\"url\" in file && typeof file.url === \"string\") {\n                if ((0, utils_js_1.isDataURI)(file.url)) {\n                    const { url } = file, otherParams = __rest(file, [\n                        \"url\"\n                    ]);\n                    const fileByteString = (0, utils_js_1.dataURItoByteString)(url);\n                    return Object.assign({\n                        data: fileByteString\n                    }, otherParams);\n                }\n                (0, utils_js_1.displayCORSWarning)();\n            }\n            return file;\n        }), [\n        file\n    ]);\n    (0, react_1.useEffect)(()=>{\n        const cancellable = (0, make_cancellable_promise_1.default)(findDocumentSource());\n        cancellable.promise.then((nextSource)=>{\n            sourceDispatch({\n                type: \"RESOLVE\",\n                value: nextSource\n            });\n        }).catch((error)=>{\n            sourceDispatch({\n                type: \"REJECT\",\n                error\n            });\n        });\n        return ()=>{\n            (0, utils_js_1.cancelRunningTask)(cancellable);\n        };\n    }, [\n        findDocumentSource,\n        sourceDispatch\n    ]);\n    (0, react_1.useEffect)(()=>{\n        if (typeof source === \"undefined\") {\n            return;\n        }\n        if (source === false) {\n            onSourceError();\n            return;\n        }\n        onSourceSuccess();\n    }, // Ommitted callbacks so they are not called every time they change\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [\n        source\n    ]);\n    /**\n     * Called when a document is read successfully\n     */ function onLoadSuccess() {\n        if (!pdf) {\n            // Impossible, but TypeScript doesn't know that\n            return;\n        }\n        if (onLoadSuccessProps) {\n            onLoadSuccessProps(pdf);\n        }\n        pages.current = new Array(pdf.numPages);\n        linkService.current.setDocument(pdf);\n    }\n    /**\n     * Called when a document failed to read successfully\n     */ function onLoadError() {\n        if (!pdfError) {\n            // Impossible, but TypeScript doesn't know that\n            return;\n        }\n        (0, warning_1.default)(false, pdfError.toString());\n        if (onLoadErrorProps) {\n            onLoadErrorProps(pdfError);\n        }\n    }\n    function resetDocument() {\n        pdfDispatch({\n            type: \"RESET\"\n        });\n    }\n    (0, react_1.useEffect)(resetDocument, [\n        pdfDispatch,\n        source\n    ]);\n    function loadDocument() {\n        if (!source) {\n            return;\n        }\n        const documentInitParams = options ? Object.assign(Object.assign({}, source), options) : source;\n        const destroyable = pdfjs_js_1.default.getDocument(documentInitParams);\n        if (onLoadProgress) {\n            destroyable.onProgress = onLoadProgress;\n        }\n        if (onPassword) {\n            destroyable.onPassword = onPassword;\n        }\n        const loadingTask = destroyable;\n        loadingTask.promise.then((nextPdf)=>{\n            pdfDispatch({\n                type: \"RESOLVE\",\n                value: nextPdf\n            });\n        }).catch((error)=>{\n            if (loadingTask.destroyed) {\n                return;\n            }\n            pdfDispatch({\n                type: \"REJECT\",\n                error\n            });\n        });\n        return ()=>{\n            loadingTask.destroy();\n        };\n    }\n    (0, react_1.useEffect)(loadDocument, // Ommitted callbacks so they are not called every time they change\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [\n        options,\n        pdfDispatch,\n        source\n    ]);\n    (0, react_1.useEffect)(()=>{\n        if (typeof pdf === \"undefined\") {\n            return;\n        }\n        if (pdf === false) {\n            onLoadError();\n            return;\n        }\n        onLoadSuccess();\n    }, // Ommitted callbacks so they are not called every time they change\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [\n        pdf\n    ]);\n    function setupLinkService() {\n        linkService.current.setViewer(viewer.current);\n        linkService.current.setExternalLinkRel(externalLinkRel);\n        linkService.current.setExternalLinkTarget(externalLinkTarget);\n    }\n    (0, react_1.useEffect)(setupLinkService, [\n        externalLinkRel,\n        externalLinkTarget\n    ]);\n    function registerPage(pageIndex, ref) {\n        pages.current[pageIndex] = ref;\n    }\n    function unregisterPage(pageIndex) {\n        delete pages.current[pageIndex];\n    }\n    const childContext = (0, react_1.useMemo)(()=>({\n            imageResourcesPath,\n            linkService: linkService.current,\n            onItemClick,\n            pdf,\n            registerPage,\n            renderMode,\n            rotate,\n            unregisterPage\n        }), [\n        imageResourcesPath,\n        onItemClick,\n        pdf,\n        renderMode,\n        rotate\n    ]);\n    const eventProps = (0, react_1.useMemo)(()=>(0, make_event_props_1.default)(otherProps, ()=>pdf), [\n        otherProps,\n        pdf\n    ]);\n    function renderChildren() {\n        return react_1.default.createElement(DocumentContext_js_1.default.Provider, {\n            value: childContext\n        }, children);\n    }\n    function renderContent() {\n        if (!file) {\n            return react_1.default.createElement(Message_js_1.default, {\n                type: \"no-data\"\n            }, typeof noData === \"function\" ? noData() : noData);\n        }\n        if (pdf === undefined || pdf === null) {\n            return react_1.default.createElement(Message_js_1.default, {\n                type: \"loading\"\n            }, typeof loading === \"function\" ? loading() : loading);\n        }\n        if (pdf === false) {\n            return react_1.default.createElement(Message_js_1.default, {\n                type: \"error\"\n            }, typeof error === \"function\" ? error() : error);\n        }\n        return renderChildren();\n    }\n    return react_1.default.createElement(\"div\", Object.assign({\n        className: (0, clsx_1.default)(\"react-pdf__Document\", className),\n        ref: inputRef,\n        style: {\n            [\"--scale-factor\"]: \"1\"\n        }\n    }, eventProps), renderContent());\n});\nconst isFunctionOrNode = prop_types_1.default.oneOfType([\n    prop_types_1.default.func,\n    prop_types_1.default.node\n]);\nDocument.propTypes = Object.assign(Object.assign({}, propTypes_js_1.eventProps), {\n    children: prop_types_1.default.node,\n    className: propTypes_js_1.isClassName,\n    error: isFunctionOrNode,\n    externalLinkRel: prop_types_1.default.string,\n    externalLinkTarget: prop_types_1.default.oneOf([\n        \"_self\",\n        \"_blank\",\n        \"_parent\",\n        \"_top\"\n    ]),\n    file: propTypes_js_1.isFile,\n    imageResourcesPath: prop_types_1.default.string,\n    inputRef: propTypes_js_1.isRef,\n    loading: isFunctionOrNode,\n    noData: isFunctionOrNode,\n    onItemClick: prop_types_1.default.func,\n    onLoadError: prop_types_1.default.func,\n    onLoadProgress: prop_types_1.default.func,\n    onLoadSuccess: prop_types_1.default.func,\n    onPassword: prop_types_1.default.func,\n    onSourceError: prop_types_1.default.func,\n    onSourceSuccess: prop_types_1.default.func,\n    options: prop_types_1.default.shape({\n        canvasFactory: prop_types_1.default.any,\n        canvasMaxAreaInBytes: prop_types_1.default.number,\n        cMapPacked: prop_types_1.default.bool,\n        CMapReaderFactory: prop_types_1.default.any,\n        cMapUrl: prop_types_1.default.string,\n        disableAutoFetch: prop_types_1.default.bool,\n        disableFontFace: prop_types_1.default.bool,\n        disableRange: prop_types_1.default.bool,\n        disableStream: prop_types_1.default.bool,\n        docBaseUrl: prop_types_1.default.string,\n        enableXfa: prop_types_1.default.bool,\n        filterFactory: prop_types_1.default.any,\n        fontExtraProperties: prop_types_1.default.bool,\n        httpHeaders: prop_types_1.default.object,\n        isEvalSupported: prop_types_1.default.bool,\n        isOffscreenCanvasSupported: prop_types_1.default.bool,\n        length: prop_types_1.default.number,\n        maxImageSize: prop_types_1.default.number,\n        ownerDocument: prop_types_1.default.any,\n        password: prop_types_1.default.string,\n        pdfBug: prop_types_1.default.bool,\n        rangeChunkSize: prop_types_1.default.number,\n        StandardFontDataFactory: prop_types_1.default.any,\n        standardFontDataUrl: prop_types_1.default.string,\n        stopAtErrors: prop_types_1.default.bool,\n        useSystemFonts: prop_types_1.default.bool,\n        useWorkerFetch: prop_types_1.default.bool,\n        verbosity: prop_types_1.default.number,\n        withCredentials: prop_types_1.default.bool,\n        worker: prop_types_1.default.any\n    }),\n    rotate: prop_types_1.default.number\n});\nexports[\"default\"] = Document;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1wZGYvZGlzdC9janMvRG9jdW1lbnQuanMiLCJtYXBwaW5ncyI6InFEQUFhO0FBRWIsSUFBSUEsa0JBQWtCLENBQUMsTUFBRyxLQUFLLE9BQUcsRUFBRUEsZUFBZSxJQUFNQyxDQUFBQSxPQUFPQyxNQUFNLEdBQUksU0FBU0MsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLENBQUMsRUFBRUMsRUFBRTtJQUMxRixJQUFJQSxPQUFPQyxXQUFXRCxLQUFLRDtJQUMzQixJQUFJRyxPQUFPUCxPQUFPUSx3QkFBd0IsQ0FBQ0wsR0FBR0M7SUFDOUMsSUFBSSxDQUFDRyxRQUFTLFVBQVNBLE9BQU8sQ0FBQ0osRUFBRU0sVUFBVSxHQUFHRixLQUFLRyxRQUFRLElBQUlILEtBQUtJLFlBQVksR0FBRztRQUNqRkosT0FBTztZQUFFSyxZQUFZO1lBQU1DLEtBQUs7Z0JBQWEsT0FBT1YsQ0FBQyxDQUFDQyxFQUFFO1lBQUU7UUFBRTtJQUM5RDtJQUNBSixPQUFPYyxjQUFjLENBQUNaLEdBQUdHLElBQUlFO0FBQ2pDLElBQU0sU0FBU0wsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLENBQUMsRUFBRUMsRUFBRTtJQUN0QixJQUFJQSxPQUFPQyxXQUFXRCxLQUFLRDtJQUMzQkYsQ0FBQyxDQUFDRyxHQUFHLEdBQUdGLENBQUMsQ0FBQ0MsRUFBRTtBQUNoQixDQUFDO0FBQ0QsSUFBSVcscUJBQXFCLENBQUMsTUFBRyxLQUFLLE9BQUcsRUFBRUEsa0JBQWtCLElBQU1mLENBQUFBLE9BQU9DLE1BQU0sR0FBSSxTQUFTQyxDQUFDLEVBQUVjLENBQUM7SUFDekZoQixPQUFPYyxjQUFjLENBQUNaLEdBQUcsV0FBVztRQUFFVSxZQUFZO1FBQU1LLE9BQU9EO0lBQUU7QUFDckUsSUFBSyxTQUFTZCxDQUFDLEVBQUVjLENBQUM7SUFDZGQsQ0FBQyxDQUFDLFVBQVUsR0FBR2M7QUFDbkI7QUFDQSxJQUFJRSxlQUFlLENBQUMsTUFBRyxLQUFLLE9BQUcsRUFBRUEsWUFBWSxJQUFLLFNBQVVDLEdBQUc7SUFDM0QsSUFBSUEsT0FBT0EsSUFBSVYsVUFBVSxFQUFFLE9BQU9VO0lBQ2xDLElBQUlDLFNBQVMsQ0FBQztJQUNkLElBQUlELE9BQU8sTUFBTTtRQUFBLElBQUssSUFBSWYsS0FBS2UsSUFBSyxJQUFJZixNQUFNLGFBQWFKLE9BQU9xQixTQUFTLENBQUNDLGNBQWMsQ0FBQ0MsSUFBSSxDQUFDSixLQUFLZixJQUFJTCxnQkFBZ0JxQixRQUFRRCxLQUFLZjtJQUFFO0lBQ3hJVyxtQkFBbUJLLFFBQVFEO0lBQzNCLE9BQU9DO0FBQ1g7QUFDQSxJQUFJSSxZQUFZLENBQUMsTUFBRyxLQUFLLE9BQUcsRUFBRUEsU0FBUyxJQUFLLFNBQVVDLE9BQU8sRUFBRUMsVUFBVSxFQUFFQyxDQUFDLEVBQUVDLFNBQVM7SUFDbkYsU0FBU0MsTUFBTVosS0FBSztRQUFJLE9BQU9BLGlCQUFpQlUsSUFBSVYsUUFBUSxJQUFJVSxFQUFFLFNBQVVHLE9BQU87WUFBSUEsUUFBUWI7UUFBUTtJQUFJO0lBQzNHLE9BQU8sSUFBS1UsQ0FBQUEsS0FBTUEsQ0FBQUEsSUFBSUksT0FBTSxDQUFDLEVBQUcsU0FBVUQsT0FBTyxFQUFFRSxNQUFNO1FBQ3JELFNBQVNDLFVBQVVoQixLQUFLO1lBQUksSUFBSTtnQkFBRWlCLEtBQUtOLFVBQVVPLElBQUksQ0FBQ2xCO1lBQVMsRUFBRSxPQUFPbUIsR0FBRztnQkFBRUosT0FBT0k7WUFBSTtRQUFFO1FBQzFGLFNBQVNDLFNBQVNwQixLQUFLO1lBQUksSUFBSTtnQkFBRWlCLEtBQUtOLFNBQVMsQ0FBQyxRQUFRLENBQUNYO1lBQVMsRUFBRSxPQUFPbUIsR0FBRztnQkFBRUosT0FBT0k7WUFBSTtRQUFFO1FBQzdGLFNBQVNGLEtBQUtkLE1BQU07WUFBSUEsT0FBT2tCLElBQUksR0FBR1IsUUFBUVYsT0FBT0gsS0FBSyxJQUFJWSxNQUFNVCxPQUFPSCxLQUFLLEVBQUVzQixJQUFJLENBQUNOLFdBQVdJO1FBQVc7UUFDN0dILEtBQUssQ0FBQ04sWUFBWUEsVUFBVVksS0FBSyxDQUFDZixTQUFTQyxjQUFjLEVBQUUsR0FBR1MsSUFBSTtJQUN0RTtBQUNKO0FBQ0EsSUFBSU0sU0FBUyxDQUFDLE1BQUcsS0FBSyxPQUFHLEVBQUVBLE1BQU0sSUFBSyxTQUFVQyxDQUFDLEVBQUVOLENBQUM7SUFDaEQsSUFBSU8sSUFBSSxDQUFDO0lBQ1QsSUFBSyxJQUFJQyxLQUFLRixFQUFHLElBQUkxQyxPQUFPcUIsU0FBUyxDQUFDQyxjQUFjLENBQUNDLElBQUksQ0FBQ21CLEdBQUdFLE1BQU1SLEVBQUVTLE9BQU8sQ0FBQ0QsS0FBSyxHQUM5RUQsQ0FBQyxDQUFDQyxFQUFFLEdBQUdGLENBQUMsQ0FBQ0UsRUFBRTtJQUNmLElBQUlGLEtBQUssUUFBUSxPQUFPMUMsT0FBTzhDLHFCQUFxQixLQUFLLFlBQ3JELElBQUssSUFBSUMsSUFBSSxHQUFHSCxJQUFJNUMsT0FBTzhDLHFCQUFxQixDQUFDSixJQUFJSyxJQUFJSCxFQUFFSSxNQUFNLEVBQUVELElBQUs7UUFDcEUsSUFBSVgsRUFBRVMsT0FBTyxDQUFDRCxDQUFDLENBQUNHLEVBQUUsSUFBSSxLQUFLL0MsT0FBT3FCLFNBQVMsQ0FBQzRCLG9CQUFvQixDQUFDMUIsSUFBSSxDQUFDbUIsR0FBR0UsQ0FBQyxDQUFDRyxFQUFFLEdBQ3pFSixDQUFDLENBQUNDLENBQUMsQ0FBQ0csRUFBRSxDQUFDLEdBQUdMLENBQUMsQ0FBQ0UsQ0FBQyxDQUFDRyxFQUFFLENBQUM7SUFDekI7SUFDSixPQUFPSjtBQUNYO0FBQ0EsSUFBSU8sa0JBQWtCLENBQUMsTUFBRyxLQUFLLE9BQUcsRUFBRUEsZUFBZSxJQUFLLFNBQVUvQixHQUFHO0lBQ2pFLE9BQU8sT0FBUUEsSUFBSVYsVUFBVSxHQUFJVSxNQUFNO1FBQUUsV0FBV0E7SUFBSTtBQUM1RDtBQUNBbkIsOENBQTZDO0lBQUVpQixPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdELE1BQU1tQyxVQUFVbEMsYUFBYW1DLG1CQUFPQSxDQUFDLG1GQUFPO0FBQzVDLE1BQU1DLGVBQWVKLGdCQUFnQkcsbUJBQU9BLENBQUMsMEVBQVk7QUFDekQsTUFBTUUscUJBQXFCTCxnQkFBZ0JHLG1CQUFPQSxDQUFDLCtGQUFrQjtBQUNyRSxNQUFNRyw2QkFBNkJOLGdCQUFnQkcsbUJBQU9BLENBQUMsK0dBQTBCO0FBQ3JGLE1BQU1JLFNBQVNQLGdCQUFnQkcsbUJBQU9BLENBQUMsa0VBQU07QUFDN0MsTUFBTUssbUJBQW1CUixnQkFBZ0JHLG1CQUFPQSxDQUFDLG9HQUFnQjtBQUNqRSxNQUFNTSxZQUFZVCxnQkFBZ0JHLG1CQUFPQSxDQUFDLHNFQUFTO0FBQ25ELE1BQU1PLFdBQVdQLG1CQUFPQSxDQUFDLHVFQUFRO0FBQ2pDLE1BQU1RLGFBQWFYLGdCQUFnQkcsbUJBQU9BLENBQUMsa0ZBQVk7QUFDdkQsTUFBTVMsdUJBQXVCWixnQkFBZ0JHLG1CQUFPQSxDQUFDLHNHQUFzQjtBQUMzRSxNQUFNVSxlQUFlYixnQkFBZ0JHLG1CQUFPQSxDQUFDLHNGQUFjO0FBQzNELE1BQU1XLG1CQUFtQmQsZ0JBQWdCRyxtQkFBT0EsQ0FBQyw4RkFBa0I7QUFDbkUsTUFBTVkseUJBQXlCZixnQkFBZ0JHLG1CQUFPQSxDQUFDLDBHQUF3QjtBQUMvRSxNQUFNYSxhQUFhYixtQkFBT0EsQ0FBQyxnR0FBbUI7QUFDOUMsTUFBTWMsbUJBQW1CakIsZ0JBQWdCRyxtQkFBT0EsQ0FBQyx3SEFBK0I7QUFDaEYsTUFBTWUsaUJBQWlCZixtQkFBT0EsQ0FBQyx3R0FBdUI7QUFDdEQsTUFBTSxFQUFFZ0IscUJBQXFCLEVBQUUsR0FBR1IsV0FBV1MsT0FBTztBQUNwRCxNQUFNQyxvQkFBb0IsQ0FBQ0MsVUFBVUM7SUFDakMsT0FBUUE7UUFDSixLQUFLUix1QkFBdUJLLE9BQU8sQ0FBQ0ksYUFBYTtZQUFFO2dCQUMvQyxvQ0FBb0M7Z0JBQ3BDLE1BQU1DLFdBQVdDLE9BQU87Z0JBQ3hCSixTQUFTRztnQkFDVDtZQUNKO1FBQ0EsS0FBS1YsdUJBQXVCSyxPQUFPLENBQUNPLGtCQUFrQjtZQUFFO2dCQUNwRCxvQ0FBb0M7Z0JBQ3BDLE1BQU1GLFdBQVdDLE9BQU87Z0JBQ3hCSixTQUFTRztnQkFDVDtZQUNKO1FBQ0E7SUFDSjtBQUNKO0FBQ0EsU0FBU0csa0JBQWtCQyxJQUFJO0lBQzNCLE9BQVEsT0FBT0EsU0FBUyxZQUNwQkEsU0FBUyxRQUNSLFdBQVVBLFFBQVEsV0FBV0EsUUFBUSxTQUFTQSxJQUFHO0FBQzFEO0FBQ0E7O0NBRUMsR0FDRCxNQUFNQyxXQUFXLENBQUMsR0FBRzVCLFFBQVE2QixVQUFVLEVBQUUsU0FBU0QsU0FBU0UsRUFBRSxFQUFFQyxHQUFHO0lBQzlELElBQUksRUFBRUMsUUFBUSxFQUFFQyxTQUFTLEVBQUVDLFFBQVEsMEJBQTBCLEVBQUVDLGVBQWUsRUFBRUMsa0JBQWtCLEVBQUVULElBQUksRUFBRVUsUUFBUSxFQUFFQyxrQkFBa0IsRUFBRUMsVUFBVSxjQUFjLEVBQUVDLFNBQVMsd0JBQXdCLEVBQUVDLFdBQVcsRUFBRUMsYUFBYUMsZ0JBQWdCLEVBQUVDLGNBQWMsRUFBRUMsZUFBZUMsa0JBQWtCLEVBQUVDLGFBQWE1QixpQkFBaUIsRUFBRTZCLGVBQWVDLGtCQUFrQixFQUFFQyxpQkFBaUJDLG9CQUFvQixFQUFFQyxPQUFPLEVBQUVDLFVBQVUsRUFBRUMsTUFBTSxFQUFFLEdBQUd4QixJQUFJeUIsYUFBYWxFLE9BQU95QyxJQUFJO1FBQUM7UUFBWTtRQUFhO1FBQVM7UUFBbUI7UUFBc0I7UUFBUTtRQUFZO1FBQXNCO1FBQVc7UUFBVTtRQUFlO1FBQWU7UUFBa0I7UUFBaUI7UUFBYztRQUFpQjtRQUFtQjtRQUFXO1FBQWM7S0FBUztJQUMxdUIsTUFBTSxDQUFDMEIsYUFBYUMsZUFBZSxHQUFHLENBQUMsR0FBRzFDLGlCQUFpQkcsT0FBTztJQUNsRSxNQUFNLEVBQUVyRCxPQUFPNkYsTUFBTSxFQUFFeEIsT0FBT3lCLFdBQVcsRUFBRSxHQUFHSDtJQUM5QyxNQUFNLENBQUNJLFVBQVVDLFlBQVksR0FBRyxDQUFDLEdBQUc5QyxpQkFBaUJHLE9BQU87SUFDNUQsTUFBTSxFQUFFckQsT0FBT2lHLEdBQUcsRUFBRTVCLE9BQU82QixRQUFRLEVBQUUsR0FBR0g7SUFDeEMsTUFBTUksY0FBYyxDQUFDLEdBQUdoRSxRQUFRaUUsTUFBTSxFQUFFLElBQUlyRCxpQkFBaUJNLE9BQU87SUFDcEUsTUFBTWdELFFBQVEsQ0FBQyxHQUFHbEUsUUFBUWlFLE1BQU0sRUFBRSxFQUFFO0lBQ3BDLE1BQU1FLFdBQVcsQ0FBQyxHQUFHbkUsUUFBUWlFLE1BQU07SUFDbkMsTUFBTUcsY0FBYyxDQUFDLEdBQUdwRSxRQUFRaUUsTUFBTTtJQUNyQyxJQUFHakUsUUFBUXFFLFNBQVMsRUFBRTtRQUNuQixJQUFJMUMsUUFBUUEsU0FBU3dDLFNBQVNHLE9BQU8sSUFBSTVDLGtCQUFrQkMsT0FBTztZQUM3RCxJQUFHcEIsVUFBVVcsT0FBTyxFQUFFLENBQUMsQ0FBQyxHQUFHVixTQUFTK0QsTUFBTSxFQUFFNUMsTUFBTXdDLFNBQVNHLE9BQU8sR0FBSTtZQUN2RUgsU0FBU0csT0FBTyxHQUFHM0M7UUFDdkI7SUFDSixHQUFHO1FBQUNBO0tBQUs7SUFDVCw4Q0FBOEM7SUFDN0MsSUFBRzNCLFFBQVFxRSxTQUFTLEVBQUU7UUFDbkIsSUFBSWpCLFdBQVdBLFlBQVlnQixZQUFZRSxPQUFPLEVBQUU7WUFDM0MsSUFBRy9ELFVBQVVXLE9BQU8sRUFBRSxDQUFDLENBQUMsR0FBR1YsU0FBUytELE1BQU0sRUFBRW5CLFNBQVNnQixZQUFZRSxPQUFPLEdBQUk7WUFDN0VGLFlBQVlFLE9BQU8sR0FBR2xCO1FBQzFCO0lBQ0osR0FBRztRQUFDQTtLQUFRO0lBQ1osTUFBTW9CLFNBQVMsQ0FBQyxHQUFHeEUsUUFBUWlFLE1BQU0sRUFBRTtRQUMvQiw0Q0FBNEM7UUFDNUNRLG9CQUFvQixDQUFDQztZQUNqQixNQUFNLEVBQUVDLElBQUksRUFBRUMsVUFBVSxFQUFFQyxZQUFZRCxhQUFhLENBQUMsRUFBRSxHQUFHRjtZQUN6RCw4REFBOEQ7WUFDOUQsSUFBSWpDLGFBQWE7Z0JBQ2JBLFlBQVk7b0JBQUVrQztvQkFBTUU7b0JBQVdEO2dCQUFXO2dCQUMxQztZQUNKO1lBQ0EsNkRBQTZEO1lBQzdELE1BQU1FLE9BQU9aLE1BQU1JLE9BQU8sQ0FBQ08sVUFBVTtZQUNyQyxJQUFJQyxNQUFNO2dCQUNOLG1DQUFtQztnQkFDbkNBLEtBQUtDLGNBQWM7Z0JBQ25CO1lBQ0o7WUFDQyxJQUFHeEUsVUFBVVcsT0FBTyxFQUFFLE9BQU8sb0NBQStDLE9BQVgwRCxZQUFXO1FBQ2pGO0lBQ0o7SUFDQyxJQUFHNUUsUUFBUWdGLG1CQUFtQixFQUFFakQsS0FBSyxJQUFPO1lBQ3pDaUM7WUFDQUU7WUFDQU07UUFDSixJQUFJLEVBQUU7SUFDTjs7S0FFQyxHQUNELFNBQVN0QjtRQUNMLElBQUlDLHNCQUFzQjtZQUN0QkE7UUFDSjtJQUNKO0lBQ0E7O0tBRUMsR0FDRCxTQUFTSDtRQUNMLElBQUksQ0FBQ1csYUFBYTtZQUNkLCtDQUErQztZQUMvQztRQUNKO1FBQ0MsSUFBR3BELFVBQVVXLE9BQU8sRUFBRSxPQUFPeUMsWUFBWXNCLFFBQVE7UUFDbEQsSUFBSWhDLG9CQUFvQjtZQUNwQkEsbUJBQW1CVTtRQUN2QjtJQUNKO0lBQ0EsU0FBU3VCO1FBQ0x6QixlQUFlO1lBQUUwQixNQUFNO1FBQVE7SUFDbkM7SUFDQyxJQUFHbkYsUUFBUXFFLFNBQVMsRUFBRWEsYUFBYTtRQUFDdkQ7UUFBTThCO0tBQWU7SUFDMUQsTUFBTTJCLHFCQUFxQixDQUFDLEdBQUdwRixRQUFRcUYsV0FBVyxFQUFFLElBQU1qSCxVQUFVLElBQUksRUFBRSxLQUFLLEdBQUcsS0FBSyxHQUFHO1lBQ3RGLElBQUksQ0FBQ3VELE1BQU07Z0JBQ1AsT0FBTztZQUNYO1lBQ0EsbUJBQW1CO1lBQ25CLElBQUksT0FBT0EsU0FBUyxVQUFVO2dCQUMxQixJQUFJLENBQUMsR0FBR2IsV0FBV3dFLFNBQVMsRUFBRTNELE9BQU87b0JBQ2pDLE1BQU00RCxpQkFBaUIsQ0FBQyxHQUFHekUsV0FBVzBFLG1CQUFtQixFQUFFN0Q7b0JBQzNELE9BQU87d0JBQUU4RCxNQUFNRjtvQkFBZTtnQkFDbEM7Z0JBQ0MsSUFBR3pFLFdBQVc0RSxrQkFBa0I7Z0JBQ2pDLE9BQU87b0JBQUVDLEtBQUtoRTtnQkFBSztZQUN2QjtZQUNBLGdDQUFnQztZQUNoQyxJQUFJQSxnQkFBZ0JWLHVCQUF1QjtnQkFDdkMsT0FBTztvQkFBRTJFLE9BQU9qRTtnQkFBSztZQUN6QjtZQUNBLHlCQUF5QjtZQUN6QixJQUFJLENBQUMsR0FBR2IsV0FBVytFLGFBQWEsRUFBRWxFLE9BQU87Z0JBQ3JDLE9BQU87b0JBQUU4RCxNQUFNOUQ7Z0JBQUs7WUFDeEI7WUFDQTs7O1NBR0MsR0FDRCxJQUFJYixXQUFXZ0YsU0FBUyxFQUFFO2dCQUN0QixpQkFBaUI7Z0JBQ2pCLElBQUksQ0FBQyxHQUFHaEYsV0FBV2lGLE1BQU0sRUFBRXBFLE9BQU87b0JBQzlCLE1BQU04RCxPQUFPLE1BQU0sQ0FBQyxHQUFHM0UsV0FBV2tGLFlBQVksRUFBRXJFO29CQUNoRCxPQUFPO3dCQUFFOEQ7b0JBQUs7Z0JBQ2xCO1lBQ0o7WUFDQSx3Q0FBd0M7WUFDdkMsSUFBR25GLGlCQUFpQlksT0FBTyxFQUFFLE9BQU9TLFNBQVMsVUFBVTtZQUN2RCxJQUFHckIsaUJBQWlCWSxPQUFPLEVBQUVRLGtCQUFrQkMsT0FBTztZQUN2RCx3QkFBd0I7WUFDeEIsSUFBSSxTQUFTQSxRQUFRLE9BQU9BLEtBQUtnRSxHQUFHLEtBQUssVUFBVTtnQkFDL0MsSUFBSSxDQUFDLEdBQUc3RSxXQUFXd0UsU0FBUyxFQUFFM0QsS0FBS2dFLEdBQUcsR0FBRztvQkFDckMsTUFBTSxFQUFFQSxHQUFHLEVBQUUsR0FBR2hFLE1BQU1zRSxjQUFjNUcsT0FBT3NDLE1BQU07d0JBQUM7cUJBQU07b0JBQ3hELE1BQU00RCxpQkFBaUIsQ0FBQyxHQUFHekUsV0FBVzBFLG1CQUFtQixFQUFFRztvQkFDM0QsT0FBTy9JLE9BQU9zSixNQUFNLENBQUM7d0JBQUVULE1BQU1GO29CQUFlLEdBQUdVO2dCQUNuRDtnQkFDQyxJQUFHbkYsV0FBVzRFLGtCQUFrQjtZQUNyQztZQUNBLE9BQU8vRDtRQUNYLElBQUk7UUFBQ0E7S0FBSztJQUNULElBQUczQixRQUFRcUUsU0FBUyxFQUFFO1FBQ25CLE1BQU04QixjQUFjLENBQUMsR0FBRy9GLDJCQUEyQmMsT0FBTyxFQUFFa0U7UUFDNURlLFlBQVlDLE9BQU8sQ0FDZGpILElBQUksQ0FBQyxDQUFDa0g7WUFDUDVDLGVBQWU7Z0JBQUUwQixNQUFNO2dCQUFXdEgsT0FBT3dJO1lBQVc7UUFDeEQsR0FDS0MsS0FBSyxDQUFDLENBQUNwRTtZQUNSdUIsZUFBZTtnQkFBRTBCLE1BQU07Z0JBQVVqRDtZQUFNO1FBQzNDO1FBQ0EsT0FBTztZQUNGLElBQUdwQixXQUFXeUYsaUJBQWlCLEVBQUVKO1FBQ3RDO0lBQ0osR0FBRztRQUFDZjtRQUFvQjNCO0tBQWU7SUFDdEMsSUFBR3pELFFBQVFxRSxTQUFTLEVBQUU7UUFDbkIsSUFBSSxPQUFPWCxXQUFXLGFBQWE7WUFDL0I7UUFDSjtRQUNBLElBQUlBLFdBQVcsT0FBTztZQUNsQlY7WUFDQTtRQUNKO1FBQ0FFO0lBQ0osR0FDQSxtRUFBbUU7SUFDbkUsdURBQXVEO0lBQ3ZEO1FBQUNRO0tBQU87SUFDUjs7S0FFQyxHQUNELFNBQVNiO1FBQ0wsSUFBSSxDQUFDaUIsS0FBSztZQUNOLCtDQUErQztZQUMvQztRQUNKO1FBQ0EsSUFBSWhCLG9CQUFvQjtZQUNwQkEsbUJBQW1CZ0I7UUFDdkI7UUFDQUksTUFBTUksT0FBTyxHQUFHLElBQUlrQyxNQUFNMUMsSUFBSTJDLFFBQVE7UUFDdEN6QyxZQUFZTSxPQUFPLENBQUNvQyxXQUFXLENBQUM1QztJQUNwQztJQUNBOztLQUVDLEdBQ0QsU0FBU3BCO1FBQ0wsSUFBSSxDQUFDcUIsVUFBVTtZQUNYLCtDQUErQztZQUMvQztRQUNKO1FBQ0MsSUFBR3hELFVBQVVXLE9BQU8sRUFBRSxPQUFPNkMsU0FBU2tCLFFBQVE7UUFDL0MsSUFBSXRDLGtCQUFrQjtZQUNsQkEsaUJBQWlCb0I7UUFDckI7SUFDSjtJQUNBLFNBQVM0QztRQUNMOUMsWUFBWTtZQUFFc0IsTUFBTTtRQUFRO0lBQ2hDO0lBQ0MsSUFBR25GLFFBQVFxRSxTQUFTLEVBQUVzQyxlQUFlO1FBQUM5QztRQUFhSDtLQUFPO0lBQzNELFNBQVNrRDtRQUNMLElBQUksQ0FBQ2xELFFBQVE7WUFDVDtRQUNKO1FBQ0EsTUFBTW1ELHFCQUFxQnpELFVBQ3JCeEcsT0FBT3NKLE1BQU0sQ0FBQ3RKLE9BQU9zSixNQUFNLENBQUMsQ0FBQyxHQUFHeEMsU0FBU04sV0FBV007UUFDMUQsTUFBTW9ELGNBQWNyRyxXQUFXUyxPQUFPLENBQUM2RixXQUFXLENBQUNGO1FBQ25ELElBQUlqRSxnQkFBZ0I7WUFDaEJrRSxZQUFZRSxVQUFVLEdBQUdwRTtRQUM3QjtRQUNBLElBQUlHLFlBQVk7WUFDWitELFlBQVkvRCxVQUFVLEdBQUdBO1FBQzdCO1FBQ0EsTUFBTWtFLGNBQWNIO1FBQ3BCRyxZQUFZYixPQUFPLENBQ2RqSCxJQUFJLENBQUMsQ0FBQytIO1lBQ1ByRCxZQUFZO2dCQUFFc0IsTUFBTTtnQkFBV3RILE9BQU9xSjtZQUFRO1FBQ2xELEdBQ0taLEtBQUssQ0FBQyxDQUFDcEU7WUFDUixJQUFJK0UsWUFBWUUsU0FBUyxFQUFFO2dCQUN2QjtZQUNKO1lBQ0F0RCxZQUFZO2dCQUFFc0IsTUFBTTtnQkFBVWpEO1lBQU07UUFDeEM7UUFDQSxPQUFPO1lBQ0grRSxZQUFZRyxPQUFPO1FBQ3ZCO0lBQ0o7SUFDQyxJQUFHcEgsUUFBUXFFLFNBQVMsRUFBRXVDLGNBQ3ZCLG1FQUFtRTtJQUNuRSx1REFBdUQ7SUFDdkQ7UUFBQ3hEO1FBQVNTO1FBQWFIO0tBQU87SUFDN0IsSUFBRzFELFFBQVFxRSxTQUFTLEVBQUU7UUFDbkIsSUFBSSxPQUFPUCxRQUFRLGFBQWE7WUFDNUI7UUFDSjtRQUNBLElBQUlBLFFBQVEsT0FBTztZQUNmcEI7WUFDQTtRQUNKO1FBQ0FHO0lBQ0osR0FDQSxtRUFBbUU7SUFDbkUsdURBQXVEO0lBQ3ZEO1FBQUNpQjtLQUFJO0lBQ0wsU0FBU3VEO1FBQ0xyRCxZQUFZTSxPQUFPLENBQUNnRCxTQUFTLENBQUM5QyxPQUFPRixPQUFPO1FBQzVDTixZQUFZTSxPQUFPLENBQUNpRCxrQkFBa0IsQ0FBQ3BGO1FBQ3ZDNkIsWUFBWU0sT0FBTyxDQUFDa0QscUJBQXFCLENBQUNwRjtJQUM5QztJQUNDLElBQUdwQyxRQUFRcUUsU0FBUyxFQUFFZ0Qsa0JBQWtCO1FBQUNsRjtRQUFpQkM7S0FBbUI7SUFDOUUsU0FBU3FGLGFBQWE1QyxTQUFTLEVBQUU5QyxHQUFHO1FBQ2hDbUMsTUFBTUksT0FBTyxDQUFDTyxVQUFVLEdBQUc5QztJQUMvQjtJQUNBLFNBQVMyRixlQUFlN0MsU0FBUztRQUM3QixPQUFPWCxNQUFNSSxPQUFPLENBQUNPLFVBQVU7SUFDbkM7SUFDQSxNQUFNOEMsZUFBZSxDQUFDLEdBQUczSCxRQUFRNEgsT0FBTyxFQUFFLElBQU87WUFDN0N0RjtZQUNBMEIsYUFBYUEsWUFBWU0sT0FBTztZQUNoQzdCO1lBQ0FxQjtZQUNBMkQ7WUFDQXBFO1lBQ0FDO1lBQ0FvRTtRQUNKLElBQUk7UUFBQ3BGO1FBQW9CRztRQUFhcUI7UUFBS1Q7UUFBWUM7S0FBTztJQUM5RCxNQUFNdUUsYUFBYSxDQUFDLEdBQUc3SCxRQUFRNEgsT0FBTyxFQUFFLElBQU0sQ0FBQyxHQUFHekgsbUJBQW1CZSxPQUFPLEVBQUVxQyxZQUFZLElBQU1PLE1BQU07UUFBQ1A7UUFBWU87S0FBSTtJQUN2SCxTQUFTZ0U7UUFDTCxPQUFPOUgsUUFBUWtCLE9BQU8sQ0FBQzZHLGFBQWEsQ0FBQ3JILHFCQUFxQlEsT0FBTyxDQUFDOEcsUUFBUSxFQUFFO1lBQUVuSyxPQUFPOEo7UUFBYSxHQUFHM0Y7SUFDekc7SUFDQSxTQUFTaUc7UUFDTCxJQUFJLENBQUN0RyxNQUFNO1lBQ1AsT0FBTzNCLFFBQVFrQixPQUFPLENBQUM2RyxhQUFhLENBQUNwSCxhQUFhTyxPQUFPLEVBQUU7Z0JBQUVpRSxNQUFNO1lBQVUsR0FBRyxPQUFPM0MsV0FBVyxhQUFhQSxXQUFXQTtRQUM5SDtRQUNBLElBQUlzQixRQUFRNUcsYUFBYTRHLFFBQVEsTUFBTTtZQUNuQyxPQUFROUQsUUFBUWtCLE9BQU8sQ0FBQzZHLGFBQWEsQ0FBQ3BILGFBQWFPLE9BQU8sRUFBRTtnQkFBRWlFLE1BQU07WUFBVSxHQUFHLE9BQU81QyxZQUFZLGFBQWFBLFlBQVlBO1FBQ2pJO1FBQ0EsSUFBSXVCLFFBQVEsT0FBTztZQUNmLE9BQU85RCxRQUFRa0IsT0FBTyxDQUFDNkcsYUFBYSxDQUFDcEgsYUFBYU8sT0FBTyxFQUFFO2dCQUFFaUUsTUFBTTtZQUFRLEdBQUcsT0FBT2pELFVBQVUsYUFBYUEsVUFBVUE7UUFDMUg7UUFDQSxPQUFPNEY7SUFDWDtJQUNBLE9BQVE5SCxRQUFRa0IsT0FBTyxDQUFDNkcsYUFBYSxDQUFDLE9BQU9uTCxPQUFPc0osTUFBTSxDQUFDO1FBQUVqRSxXQUFXLENBQUMsR0FBRzVCLE9BQU9hLE9BQU8sRUFBRSx1QkFBdUJlO1FBQVlGLEtBQUtNO1FBQVU2RixPQUFPO1lBQzdJLENBQUMsaUJBQWlCLEVBQUU7UUFDeEI7SUFBRSxHQUFHTCxhQUFhSTtBQUMxQjtBQUNBLE1BQU1FLG1CQUFtQmpJLGFBQWFnQixPQUFPLENBQUNrSCxTQUFTLENBQUM7SUFBQ2xJLGFBQWFnQixPQUFPLENBQUNtSCxJQUFJO0lBQUVuSSxhQUFhZ0IsT0FBTyxDQUFDb0gsSUFBSTtDQUFDO0FBQzlHMUcsU0FBUzJHLFNBQVMsR0FBRzNMLE9BQU9zSixNQUFNLENBQUN0SixPQUFPc0osTUFBTSxDQUFDLENBQUMsR0FBR2xGLGVBQWU2RyxVQUFVLEdBQUc7SUFBRTdGLFVBQVU5QixhQUFhZ0IsT0FBTyxDQUFDb0gsSUFBSTtJQUFFckcsV0FBV2pCLGVBQWV3SCxXQUFXO0lBQUV0RyxPQUFPaUc7SUFBa0JoRyxpQkFBaUJqQyxhQUFhZ0IsT0FBTyxDQUFDdUgsTUFBTTtJQUFFckcsb0JBQW9CbEMsYUFBYWdCLE9BQU8sQ0FBQ3dILEtBQUssQ0FBQztRQUFDO1FBQVM7UUFBVTtRQUFXO0tBQU87SUFBRy9HLE1BQU1YLGVBQWUySCxNQUFNO0lBQUVyRyxvQkFBb0JwQyxhQUFhZ0IsT0FBTyxDQUFDdUgsTUFBTTtJQUFFcEcsVUFBVXJCLGVBQWU0SCxLQUFLO0lBQUVyRyxTQUFTNEY7SUFBa0IzRixRQUFRMkY7SUFBa0IxRixhQUFhdkMsYUFBYWdCLE9BQU8sQ0FBQ21ILElBQUk7SUFBRTNGLGFBQWF4QyxhQUFhZ0IsT0FBTyxDQUFDbUgsSUFBSTtJQUFFekYsZ0JBQWdCMUMsYUFBYWdCLE9BQU8sQ0FBQ21ILElBQUk7SUFBRXhGLGVBQWUzQyxhQUFhZ0IsT0FBTyxDQUFDbUgsSUFBSTtJQUFFdEYsWUFBWTdDLGFBQWFnQixPQUFPLENBQUNtSCxJQUFJO0lBQUVyRixlQUFlOUMsYUFBYWdCLE9BQU8sQ0FBQ21ILElBQUk7SUFBRW5GLGlCQUFpQmhELGFBQWFnQixPQUFPLENBQUNtSCxJQUFJO0lBQUVqRixTQUFTbEQsYUFBYWdCLE9BQU8sQ0FBQzJILEtBQUssQ0FBQztRQUMveEJDLGVBQWU1SSxhQUFhZ0IsT0FBTyxDQUFDNkgsR0FBRztRQUN2Q0Msc0JBQXNCOUksYUFBYWdCLE9BQU8sQ0FBQytILE1BQU07UUFDakRDLFlBQVloSixhQUFhZ0IsT0FBTyxDQUFDaUksSUFBSTtRQUNyQ0MsbUJBQW1CbEosYUFBYWdCLE9BQU8sQ0FBQzZILEdBQUc7UUFDM0NNLFNBQVNuSixhQUFhZ0IsT0FBTyxDQUFDdUgsTUFBTTtRQUNwQ2Esa0JBQWtCcEosYUFBYWdCLE9BQU8sQ0FBQ2lJLElBQUk7UUFDM0NJLGlCQUFpQnJKLGFBQWFnQixPQUFPLENBQUNpSSxJQUFJO1FBQzFDSyxjQUFjdEosYUFBYWdCLE9BQU8sQ0FBQ2lJLElBQUk7UUFDdkNNLGVBQWV2SixhQUFhZ0IsT0FBTyxDQUFDaUksSUFBSTtRQUN4Q08sWUFBWXhKLGFBQWFnQixPQUFPLENBQUN1SCxNQUFNO1FBQ3ZDa0IsV0FBV3pKLGFBQWFnQixPQUFPLENBQUNpSSxJQUFJO1FBQ3BDUyxlQUFlMUosYUFBYWdCLE9BQU8sQ0FBQzZILEdBQUc7UUFDdkNjLHFCQUFxQjNKLGFBQWFnQixPQUFPLENBQUNpSSxJQUFJO1FBQzlDVyxhQUFhNUosYUFBYWdCLE9BQU8sQ0FBQzZJLE1BQU07UUFDeENDLGlCQUFpQjlKLGFBQWFnQixPQUFPLENBQUNpSSxJQUFJO1FBQzFDYyw0QkFBNEIvSixhQUFhZ0IsT0FBTyxDQUFDaUksSUFBSTtRQUNyRHZKLFFBQVFNLGFBQWFnQixPQUFPLENBQUMrSCxNQUFNO1FBQ25DaUIsY0FBY2hLLGFBQWFnQixPQUFPLENBQUMrSCxNQUFNO1FBQ3pDa0IsZUFBZWpLLGFBQWFnQixPQUFPLENBQUM2SCxHQUFHO1FBQ3ZDeEgsVUFBVXJCLGFBQWFnQixPQUFPLENBQUN1SCxNQUFNO1FBQ3JDMkIsUUFBUWxLLGFBQWFnQixPQUFPLENBQUNpSSxJQUFJO1FBQ2pDa0IsZ0JBQWdCbkssYUFBYWdCLE9BQU8sQ0FBQytILE1BQU07UUFDM0NxQix5QkFBeUJwSyxhQUFhZ0IsT0FBTyxDQUFDNkgsR0FBRztRQUNqRHdCLHFCQUFxQnJLLGFBQWFnQixPQUFPLENBQUN1SCxNQUFNO1FBQ2hEK0IsY0FBY3RLLGFBQWFnQixPQUFPLENBQUNpSSxJQUFJO1FBQ3ZDc0IsZ0JBQWdCdkssYUFBYWdCLE9BQU8sQ0FBQ2lJLElBQUk7UUFDekN1QixnQkFBZ0J4SyxhQUFhZ0IsT0FBTyxDQUFDaUksSUFBSTtRQUN6Q3dCLFdBQVd6SyxhQUFhZ0IsT0FBTyxDQUFDK0gsTUFBTTtRQUN0QzJCLGlCQUFpQjFLLGFBQWFnQixPQUFPLENBQUNpSSxJQUFJO1FBQzFDMEIsUUFBUTNLLGFBQWFnQixPQUFPLENBQUM2SCxHQUFHO0lBQ3BDO0lBQUl6RixRQUFRcEQsYUFBYWdCLE9BQU8sQ0FBQytILE1BQU07QUFBQztBQUM1Q2xKLGtCQUFlLEdBQUc2QiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVhY3QtcGRmL2Rpc3QvY2pzL0RvY3VtZW50LmpzPzFmYjQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4ndXNlIGNsaWVudCc7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9fcmVzdCA9ICh0aGlzICYmIHRoaXMuX19yZXN0KSB8fCBmdW5jdGlvbiAocywgZSkge1xuICAgIHZhciB0ID0ge307XG4gICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApXG4gICAgICAgIHRbcF0gPSBzW3BdO1xuICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDAgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHBbaV0pKVxuICAgICAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xuICAgICAgICB9XG4gICAgcmV0dXJuIHQ7XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgcmVhY3RfMSA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwicmVhY3RcIikpO1xuY29uc3QgcHJvcF90eXBlc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJwcm9wLXR5cGVzXCIpKTtcbmNvbnN0IG1ha2VfZXZlbnRfcHJvcHNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwibWFrZS1ldmVudC1wcm9wc1wiKSk7XG5jb25zdCBtYWtlX2NhbmNlbGxhYmxlX3Byb21pc2VfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwibWFrZS1jYW5jZWxsYWJsZS1wcm9taXNlXCIpKTtcbmNvbnN0IGNsc3hfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiY2xzeFwiKSk7XG5jb25zdCB0aW55X2ludmFyaWFudF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJ0aW55LWludmFyaWFudFwiKSk7XG5jb25zdCB3YXJuaW5nXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIndhcm5pbmdcIikpO1xuY29uc3QgZGVxdWFsXzEgPSByZXF1aXJlKFwiZGVxdWFsXCIpO1xuY29uc3QgcGRmanNfanNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9wZGZqcy5qc1wiKSk7XG5jb25zdCBEb2N1bWVudENvbnRleHRfanNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9Eb2N1bWVudENvbnRleHQuanNcIikpO1xuY29uc3QgTWVzc2FnZV9qc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL01lc3NhZ2UuanNcIikpO1xuY29uc3QgTGlua1NlcnZpY2VfanNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9MaW5rU2VydmljZS5qc1wiKSk7XG5jb25zdCBQYXNzd29yZFJlc3BvbnNlc19qc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL1Bhc3N3b3JkUmVzcG9uc2VzLmpzXCIpKTtcbmNvbnN0IHV0aWxzX2pzXzEgPSByZXF1aXJlKFwiLi9zaGFyZWQvdXRpbHMuanNcIik7XG5jb25zdCB1c2VSZXNvbHZlcl9qc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL3NoYXJlZC9ob29rcy91c2VSZXNvbHZlci5qc1wiKSk7XG5jb25zdCBwcm9wVHlwZXNfanNfMSA9IHJlcXVpcmUoXCIuL3NoYXJlZC9wcm9wVHlwZXMuanNcIik7XG5jb25zdCB7IFBERkRhdGFSYW5nZVRyYW5zcG9ydCB9ID0gcGRmanNfanNfMS5kZWZhdWx0O1xuY29uc3QgZGVmYXVsdE9uUGFzc3dvcmQgPSAoY2FsbGJhY2ssIHJlYXNvbikgPT4ge1xuICAgIHN3aXRjaCAocmVhc29uKSB7XG4gICAgICAgIGNhc2UgUGFzc3dvcmRSZXNwb25zZXNfanNfMS5kZWZhdWx0Lk5FRURfUEFTU1dPUkQ6IHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1hbGVydFxuICAgICAgICAgICAgY29uc3QgcGFzc3dvcmQgPSBwcm9tcHQoJ0VudGVyIHRoZSBwYXNzd29yZCB0byBvcGVuIHRoaXMgUERGIGZpbGUuJyk7XG4gICAgICAgICAgICBjYWxsYmFjayhwYXNzd29yZCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFBhc3N3b3JkUmVzcG9uc2VzX2pzXzEuZGVmYXVsdC5JTkNPUlJFQ1RfUEFTU1dPUkQ6IHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1hbGVydFxuICAgICAgICAgICAgY29uc3QgcGFzc3dvcmQgPSBwcm9tcHQoJ0ludmFsaWQgcGFzc3dvcmQuIFBsZWFzZSB0cnkgYWdhaW4uJyk7XG4gICAgICAgICAgICBjYWxsYmFjayhwYXNzd29yZCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgIH1cbn07XG5mdW5jdGlvbiBpc1BhcmFtZXRlck9iamVjdChmaWxlKSB7XG4gICAgcmV0dXJuICh0eXBlb2YgZmlsZSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgZmlsZSAhPT0gbnVsbCAmJlxuICAgICAgICAoJ2RhdGEnIGluIGZpbGUgfHwgJ3JhbmdlJyBpbiBmaWxlIHx8ICd1cmwnIGluIGZpbGUpKTtcbn1cbi8qKlxuICogTG9hZHMgYSBkb2N1bWVudCBwYXNzZWQgdXNpbmcgYGZpbGVgIHByb3AuXG4gKi9cbmNvbnN0IERvY3VtZW50ID0gKDAsIHJlYWN0XzEuZm9yd2FyZFJlZikoZnVuY3Rpb24gRG9jdW1lbnQoX2EsIHJlZikge1xuICAgIHZhciB7IGNoaWxkcmVuLCBjbGFzc05hbWUsIGVycm9yID0gJ0ZhaWxlZCB0byBsb2FkIFBERiBmaWxlLicsIGV4dGVybmFsTGlua1JlbCwgZXh0ZXJuYWxMaW5rVGFyZ2V0LCBmaWxlLCBpbnB1dFJlZiwgaW1hZ2VSZXNvdXJjZXNQYXRoLCBsb2FkaW5nID0gJ0xvYWRpbmcgUERG4oCmJywgbm9EYXRhID0gJ05vIFBERiBmaWxlIHNwZWNpZmllZC4nLCBvbkl0ZW1DbGljaywgb25Mb2FkRXJyb3I6IG9uTG9hZEVycm9yUHJvcHMsIG9uTG9hZFByb2dyZXNzLCBvbkxvYWRTdWNjZXNzOiBvbkxvYWRTdWNjZXNzUHJvcHMsIG9uUGFzc3dvcmQgPSBkZWZhdWx0T25QYXNzd29yZCwgb25Tb3VyY2VFcnJvcjogb25Tb3VyY2VFcnJvclByb3BzLCBvblNvdXJjZVN1Y2Nlc3M6IG9uU291cmNlU3VjY2Vzc1Byb3BzLCBvcHRpb25zLCByZW5kZXJNb2RlLCByb3RhdGUgfSA9IF9hLCBvdGhlclByb3BzID0gX19yZXN0KF9hLCBbXCJjaGlsZHJlblwiLCBcImNsYXNzTmFtZVwiLCBcImVycm9yXCIsIFwiZXh0ZXJuYWxMaW5rUmVsXCIsIFwiZXh0ZXJuYWxMaW5rVGFyZ2V0XCIsIFwiZmlsZVwiLCBcImlucHV0UmVmXCIsIFwiaW1hZ2VSZXNvdXJjZXNQYXRoXCIsIFwibG9hZGluZ1wiLCBcIm5vRGF0YVwiLCBcIm9uSXRlbUNsaWNrXCIsIFwib25Mb2FkRXJyb3JcIiwgXCJvbkxvYWRQcm9ncmVzc1wiLCBcIm9uTG9hZFN1Y2Nlc3NcIiwgXCJvblBhc3N3b3JkXCIsIFwib25Tb3VyY2VFcnJvclwiLCBcIm9uU291cmNlU3VjY2Vzc1wiLCBcIm9wdGlvbnNcIiwgXCJyZW5kZXJNb2RlXCIsIFwicm90YXRlXCJdKTtcbiAgICBjb25zdCBbc291cmNlU3RhdGUsIHNvdXJjZURpc3BhdGNoXSA9ICgwLCB1c2VSZXNvbHZlcl9qc18xLmRlZmF1bHQpKCk7XG4gICAgY29uc3QgeyB2YWx1ZTogc291cmNlLCBlcnJvcjogc291cmNlRXJyb3IgfSA9IHNvdXJjZVN0YXRlO1xuICAgIGNvbnN0IFtwZGZTdGF0ZSwgcGRmRGlzcGF0Y2hdID0gKDAsIHVzZVJlc29sdmVyX2pzXzEuZGVmYXVsdCkoKTtcbiAgICBjb25zdCB7IHZhbHVlOiBwZGYsIGVycm9yOiBwZGZFcnJvciB9ID0gcGRmU3RhdGU7XG4gICAgY29uc3QgbGlua1NlcnZpY2UgPSAoMCwgcmVhY3RfMS51c2VSZWYpKG5ldyBMaW5rU2VydmljZV9qc18xLmRlZmF1bHQoKSk7XG4gICAgY29uc3QgcGFnZXMgPSAoMCwgcmVhY3RfMS51c2VSZWYpKFtdKTtcbiAgICBjb25zdCBwcmV2RmlsZSA9ICgwLCByZWFjdF8xLnVzZVJlZikoKTtcbiAgICBjb25zdCBwcmV2T3B0aW9ucyA9ICgwLCByZWFjdF8xLnVzZVJlZikoKTtcbiAgICAoMCwgcmVhY3RfMS51c2VFZmZlY3QpKCgpID0+IHtcbiAgICAgICAgaWYgKGZpbGUgJiYgZmlsZSAhPT0gcHJldkZpbGUuY3VycmVudCAmJiBpc1BhcmFtZXRlck9iamVjdChmaWxlKSkge1xuICAgICAgICAgICAgKDAsIHdhcm5pbmdfMS5kZWZhdWx0KSghKDAsIGRlcXVhbF8xLmRlcXVhbCkoZmlsZSwgcHJldkZpbGUuY3VycmVudCksIGBGaWxlIHByb3AgcGFzc2VkIHRvIDxEb2N1bWVudCAvPiBjaGFuZ2VkLCBidXQgaXQncyBlcXVhbCB0byBwcmV2aW91cyBvbmUuIFRoaXMgbWlnaHQgcmVzdWx0IGluIHVubmVjZXNzYXJ5IHJlbG9hZHMuIENvbnNpZGVyIG1lbW9pemluZyB0aGUgdmFsdWUgcGFzc2VkIHRvIFwiZmlsZVwiIHByb3AuYCk7XG4gICAgICAgICAgICBwcmV2RmlsZS5jdXJyZW50ID0gZmlsZTtcbiAgICAgICAgfVxuICAgIH0sIFtmaWxlXSk7XG4gICAgLy8gRGV0ZWN0IG5vbi1tZW1vaXplZCBjaGFuZ2VzIGluIG9wdGlvbnMgcHJvcFxuICAgICgwLCByZWFjdF8xLnVzZUVmZmVjdCkoKCkgPT4ge1xuICAgICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zICE9PSBwcmV2T3B0aW9ucy5jdXJyZW50KSB7XG4gICAgICAgICAgICAoMCwgd2FybmluZ18xLmRlZmF1bHQpKCEoMCwgZGVxdWFsXzEuZGVxdWFsKShvcHRpb25zLCBwcmV2T3B0aW9ucy5jdXJyZW50KSwgYE9wdGlvbnMgcHJvcCBwYXNzZWQgdG8gPERvY3VtZW50IC8+IGNoYW5nZWQsIGJ1dCBpdCdzIGVxdWFsIHRvIHByZXZpb3VzIG9uZS4gVGhpcyBtaWdodCByZXN1bHQgaW4gdW5uZWNlc3NhcnkgcmVsb2Fkcy4gQ29uc2lkZXIgbWVtb2l6aW5nIHRoZSB2YWx1ZSBwYXNzZWQgdG8gXCJvcHRpb25zXCIgcHJvcC5gKTtcbiAgICAgICAgICAgIHByZXZPcHRpb25zLmN1cnJlbnQgPSBvcHRpb25zO1xuICAgICAgICB9XG4gICAgfSwgW29wdGlvbnNdKTtcbiAgICBjb25zdCB2aWV3ZXIgPSAoMCwgcmVhY3RfMS51c2VSZWYpKHtcbiAgICAgICAgLy8gSGFuZGxpbmcganVtcGluZyB0byBpbnRlcm5hbCBsaW5rcyB0YXJnZXRcbiAgICAgICAgc2Nyb2xsUGFnZUludG9WaWV3OiAoYXJncykgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBkZXN0LCBwYWdlTnVtYmVyLCBwYWdlSW5kZXggPSBwYWdlTnVtYmVyIC0gMSB9ID0gYXJncztcbiAgICAgICAgICAgIC8vIEZpcnN0LCBjaGVjayBpZiBjdXN0b20gaGFuZGxpbmcgb2Ygb25JdGVtQ2xpY2sgd2FzIHByb3ZpZGVkXG4gICAgICAgICAgICBpZiAob25JdGVtQ2xpY2spIHtcbiAgICAgICAgICAgICAgICBvbkl0ZW1DbGljayh7IGRlc3QsIHBhZ2VJbmRleCwgcGFnZU51bWJlciB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiBub3QsIHRyeSB0byBsb29rIGZvciB0YXJnZXQgcGFnZSB3aXRoaW4gdGhlIDxEb2N1bWVudD4uXG4gICAgICAgICAgICBjb25zdCBwYWdlID0gcGFnZXMuY3VycmVudFtwYWdlSW5kZXhdO1xuICAgICAgICAgICAgaWYgKHBhZ2UpIHtcbiAgICAgICAgICAgICAgICAvLyBTY3JvbGwgdG8gdGhlIHBhZ2UgYXV0b21hdGljYWxseVxuICAgICAgICAgICAgICAgIHBhZ2Uuc2Nyb2xsSW50b1ZpZXcoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAoMCwgd2FybmluZ18xLmRlZmF1bHQpKGZhbHNlLCBgQW4gaW50ZXJuYWwgbGluayBsZWFkaW5nIHRvIHBhZ2UgJHtwYWdlTnVtYmVyfSB3YXMgY2xpY2tlZCwgYnV0IG5laXRoZXIgPERvY3VtZW50PiB3YXMgcHJvdmlkZWQgd2l0aCBvbkl0ZW1DbGljayBub3IgaXQgd2FzIGFibGUgdG8gZmluZCB0aGUgcGFnZSB3aXRoaW4gaXRzZWxmLiBFaXRoZXIgcHJvdmlkZSBvbkl0ZW1DbGljayB0byA8RG9jdW1lbnQ+IGFuZCBoYW5kbGUgbmF2aWdhdGluZyBieSB5b3Vyc2VsZiBvciBlbnN1cmUgdGhhdCBhbGwgcGFnZXMgYXJlIHJlbmRlcmVkIHdpdGhpbiA8RG9jdW1lbnQ+LmApO1xuICAgICAgICB9LFxuICAgIH0pO1xuICAgICgwLCByZWFjdF8xLnVzZUltcGVyYXRpdmVIYW5kbGUpKHJlZiwgKCkgPT4gKHtcbiAgICAgICAgbGlua1NlcnZpY2UsXG4gICAgICAgIHBhZ2VzLFxuICAgICAgICB2aWV3ZXIsXG4gICAgfSksIFtdKTtcbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbiBhIGRvY3VtZW50IHNvdXJjZSBpcyByZXNvbHZlZCBjb3JyZWN0bHlcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvblNvdXJjZVN1Y2Nlc3MoKSB7XG4gICAgICAgIGlmIChvblNvdXJjZVN1Y2Nlc3NQcm9wcykge1xuICAgICAgICAgICAgb25Tb3VyY2VTdWNjZXNzUHJvcHMoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbiBhIGRvY3VtZW50IHNvdXJjZSBmYWlsZWQgdG8gYmUgcmVzb2x2ZWQgY29ycmVjdGx5XG4gICAgICovXG4gICAgZnVuY3Rpb24gb25Tb3VyY2VFcnJvcigpIHtcbiAgICAgICAgaWYgKCFzb3VyY2VFcnJvcikge1xuICAgICAgICAgICAgLy8gSW1wb3NzaWJsZSwgYnV0IFR5cGVTY3JpcHQgZG9lc24ndCBrbm93IHRoYXRcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAoMCwgd2FybmluZ18xLmRlZmF1bHQpKGZhbHNlLCBzb3VyY2VFcnJvci50b1N0cmluZygpKTtcbiAgICAgICAgaWYgKG9uU291cmNlRXJyb3JQcm9wcykge1xuICAgICAgICAgICAgb25Tb3VyY2VFcnJvclByb3BzKHNvdXJjZUVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiByZXNldFNvdXJjZSgpIHtcbiAgICAgICAgc291cmNlRGlzcGF0Y2goeyB0eXBlOiAnUkVTRVQnIH0pO1xuICAgIH1cbiAgICAoMCwgcmVhY3RfMS51c2VFZmZlY3QpKHJlc2V0U291cmNlLCBbZmlsZSwgc291cmNlRGlzcGF0Y2hdKTtcbiAgICBjb25zdCBmaW5kRG9jdW1lbnRTb3VyY2UgPSAoMCwgcmVhY3RfMS51c2VDYWxsYmFjaykoKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICBpZiAoIWZpbGUpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZpbGUgaXMgYSBzdHJpbmdcbiAgICAgICAgaWYgKHR5cGVvZiBmaWxlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgaWYgKCgwLCB1dGlsc19qc18xLmlzRGF0YVVSSSkoZmlsZSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmaWxlQnl0ZVN0cmluZyA9ICgwLCB1dGlsc19qc18xLmRhdGFVUkl0b0J5dGVTdHJpbmcpKGZpbGUpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IGZpbGVCeXRlU3RyaW5nIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAoMCwgdXRpbHNfanNfMS5kaXNwbGF5Q09SU1dhcm5pbmcpKCk7XG4gICAgICAgICAgICByZXR1cm4geyB1cmw6IGZpbGUgfTtcbiAgICAgICAgfVxuICAgICAgICAvLyBGaWxlIGlzIFBERkRhdGFSYW5nZVRyYW5zcG9ydFxuICAgICAgICBpZiAoZmlsZSBpbnN0YW5jZW9mIFBERkRhdGFSYW5nZVRyYW5zcG9ydCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgcmFuZ2U6IGZpbGUgfTtcbiAgICAgICAgfVxuICAgICAgICAvLyBGaWxlIGlzIGFuIEFycmF5QnVmZmVyXG4gICAgICAgIGlmICgoMCwgdXRpbHNfanNfMS5pc0FycmF5QnVmZmVyKShmaWxlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogZmlsZSB9O1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgY2FzZXMgYmVsb3cgYXJlIGJyb3dzZXItb25seS5cbiAgICAgICAgICogSWYgeW91J3JlIHJ1bm5pbmcgb24gYSBub24tYnJvd3NlciBlbnZpcm9ubWVudCwgdGhlc2UgY2FzZXMgd2lsbCBiZSBvZiBubyB1c2UuXG4gICAgICAgICAqL1xuICAgICAgICBpZiAodXRpbHNfanNfMS5pc0Jyb3dzZXIpIHtcbiAgICAgICAgICAgIC8vIEZpbGUgaXMgYSBCbG9iXG4gICAgICAgICAgICBpZiAoKDAsIHV0aWxzX2pzXzEuaXNCbG9iKShmaWxlKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSB5aWVsZCAoMCwgdXRpbHNfanNfMS5sb2FkRnJvbUZpbGUpKGZpbGUpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGEgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBBdCB0aGlzIHBvaW50LCBmaWxlIG11c3QgYmUgYW4gb2JqZWN0XG4gICAgICAgICgwLCB0aW55X2ludmFyaWFudF8xLmRlZmF1bHQpKHR5cGVvZiBmaWxlID09PSAnb2JqZWN0JywgJ0ludmFsaWQgcGFyYW1ldGVyIGluIGZpbGUsIG5lZWQgZWl0aGVyIFVpbnQ4QXJyYXksIHN0cmluZyBvciBhIHBhcmFtZXRlciBvYmplY3QnKTtcbiAgICAgICAgKDAsIHRpbnlfaW52YXJpYW50XzEuZGVmYXVsdCkoaXNQYXJhbWV0ZXJPYmplY3QoZmlsZSksICdJbnZhbGlkIHBhcmFtZXRlciBvYmplY3Q6IG5lZWQgZWl0aGVyIC5kYXRhLCAucmFuZ2Ugb3IgLnVybCcpO1xuICAgICAgICAvLyBGaWxlIC51cmwgaXMgYSBzdHJpbmdcbiAgICAgICAgaWYgKCd1cmwnIGluIGZpbGUgJiYgdHlwZW9mIGZpbGUudXJsID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgaWYgKCgwLCB1dGlsc19qc18xLmlzRGF0YVVSSSkoZmlsZS51cmwpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyB1cmwgfSA9IGZpbGUsIG90aGVyUGFyYW1zID0gX19yZXN0KGZpbGUsIFtcInVybFwiXSk7XG4gICAgICAgICAgICAgICAgY29uc3QgZmlsZUJ5dGVTdHJpbmcgPSAoMCwgdXRpbHNfanNfMS5kYXRhVVJJdG9CeXRlU3RyaW5nKSh1cmwpO1xuICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHsgZGF0YTogZmlsZUJ5dGVTdHJpbmcgfSwgb3RoZXJQYXJhbXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKDAsIHV0aWxzX2pzXzEuZGlzcGxheUNPUlNXYXJuaW5nKSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmaWxlO1xuICAgIH0pLCBbZmlsZV0pO1xuICAgICgwLCByZWFjdF8xLnVzZUVmZmVjdCkoKCkgPT4ge1xuICAgICAgICBjb25zdCBjYW5jZWxsYWJsZSA9ICgwLCBtYWtlX2NhbmNlbGxhYmxlX3Byb21pc2VfMS5kZWZhdWx0KShmaW5kRG9jdW1lbnRTb3VyY2UoKSk7XG4gICAgICAgIGNhbmNlbGxhYmxlLnByb21pc2VcbiAgICAgICAgICAgIC50aGVuKChuZXh0U291cmNlKSA9PiB7XG4gICAgICAgICAgICBzb3VyY2VEaXNwYXRjaCh7IHR5cGU6ICdSRVNPTFZFJywgdmFsdWU6IG5leHRTb3VyY2UgfSk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICBzb3VyY2VEaXNwYXRjaCh7IHR5cGU6ICdSRUpFQ1QnLCBlcnJvciB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICAoMCwgdXRpbHNfanNfMS5jYW5jZWxSdW5uaW5nVGFzaykoY2FuY2VsbGFibGUpO1xuICAgICAgICB9O1xuICAgIH0sIFtmaW5kRG9jdW1lbnRTb3VyY2UsIHNvdXJjZURpc3BhdGNoXSk7XG4gICAgKDAsIHJlYWN0XzEudXNlRWZmZWN0KSgoKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2Ygc291cmNlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzb3VyY2UgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBvblNvdXJjZUVycm9yKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgb25Tb3VyY2VTdWNjZXNzKCk7XG4gICAgfSwgXG4gICAgLy8gT21taXR0ZWQgY2FsbGJhY2tzIHNvIHRoZXkgYXJlIG5vdCBjYWxsZWQgZXZlcnkgdGltZSB0aGV5IGNoYW5nZVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgICBbc291cmNlXSk7XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW4gYSBkb2N1bWVudCBpcyByZWFkIHN1Y2Nlc3NmdWxseVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG9uTG9hZFN1Y2Nlc3MoKSB7XG4gICAgICAgIGlmICghcGRmKSB7XG4gICAgICAgICAgICAvLyBJbXBvc3NpYmxlLCBidXQgVHlwZVNjcmlwdCBkb2Vzbid0IGtub3cgdGhhdFxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvbkxvYWRTdWNjZXNzUHJvcHMpIHtcbiAgICAgICAgICAgIG9uTG9hZFN1Y2Nlc3NQcm9wcyhwZGYpO1xuICAgICAgICB9XG4gICAgICAgIHBhZ2VzLmN1cnJlbnQgPSBuZXcgQXJyYXkocGRmLm51bVBhZ2VzKTtcbiAgICAgICAgbGlua1NlcnZpY2UuY3VycmVudC5zZXREb2N1bWVudChwZGYpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbiBhIGRvY3VtZW50IGZhaWxlZCB0byByZWFkIHN1Y2Nlc3NmdWxseVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG9uTG9hZEVycm9yKCkge1xuICAgICAgICBpZiAoIXBkZkVycm9yKSB7XG4gICAgICAgICAgICAvLyBJbXBvc3NpYmxlLCBidXQgVHlwZVNjcmlwdCBkb2Vzbid0IGtub3cgdGhhdFxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgICgwLCB3YXJuaW5nXzEuZGVmYXVsdCkoZmFsc2UsIHBkZkVycm9yLnRvU3RyaW5nKCkpO1xuICAgICAgICBpZiAob25Mb2FkRXJyb3JQcm9wcykge1xuICAgICAgICAgICAgb25Mb2FkRXJyb3JQcm9wcyhwZGZFcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcmVzZXREb2N1bWVudCgpIHtcbiAgICAgICAgcGRmRGlzcGF0Y2goeyB0eXBlOiAnUkVTRVQnIH0pO1xuICAgIH1cbiAgICAoMCwgcmVhY3RfMS51c2VFZmZlY3QpKHJlc2V0RG9jdW1lbnQsIFtwZGZEaXNwYXRjaCwgc291cmNlXSk7XG4gICAgZnVuY3Rpb24gbG9hZERvY3VtZW50KCkge1xuICAgICAgICBpZiAoIXNvdXJjZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRvY3VtZW50SW5pdFBhcmFtcyA9IG9wdGlvbnNcbiAgICAgICAgICAgID8gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzb3VyY2UpLCBvcHRpb25zKSA6IHNvdXJjZTtcbiAgICAgICAgY29uc3QgZGVzdHJveWFibGUgPSBwZGZqc19qc18xLmRlZmF1bHQuZ2V0RG9jdW1lbnQoZG9jdW1lbnRJbml0UGFyYW1zKTtcbiAgICAgICAgaWYgKG9uTG9hZFByb2dyZXNzKSB7XG4gICAgICAgICAgICBkZXN0cm95YWJsZS5vblByb2dyZXNzID0gb25Mb2FkUHJvZ3Jlc3M7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9uUGFzc3dvcmQpIHtcbiAgICAgICAgICAgIGRlc3Ryb3lhYmxlLm9uUGFzc3dvcmQgPSBvblBhc3N3b3JkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxvYWRpbmdUYXNrID0gZGVzdHJveWFibGU7XG4gICAgICAgIGxvYWRpbmdUYXNrLnByb21pc2VcbiAgICAgICAgICAgIC50aGVuKChuZXh0UGRmKSA9PiB7XG4gICAgICAgICAgICBwZGZEaXNwYXRjaCh7IHR5cGU6ICdSRVNPTFZFJywgdmFsdWU6IG5leHRQZGYgfSk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICBpZiAobG9hZGluZ1Rhc2suZGVzdHJveWVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGRmRGlzcGF0Y2goeyB0eXBlOiAnUkVKRUNUJywgZXJyb3IgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgbG9hZGluZ1Rhc2suZGVzdHJveSgpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICAoMCwgcmVhY3RfMS51c2VFZmZlY3QpKGxvYWREb2N1bWVudCwgXG4gICAgLy8gT21taXR0ZWQgY2FsbGJhY2tzIHNvIHRoZXkgYXJlIG5vdCBjYWxsZWQgZXZlcnkgdGltZSB0aGV5IGNoYW5nZVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgICBbb3B0aW9ucywgcGRmRGlzcGF0Y2gsIHNvdXJjZV0pO1xuICAgICgwLCByZWFjdF8xLnVzZUVmZmVjdCkoKCkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIHBkZiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGRmID09PSBmYWxzZSkge1xuICAgICAgICAgICAgb25Mb2FkRXJyb3IoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBvbkxvYWRTdWNjZXNzKCk7XG4gICAgfSwgXG4gICAgLy8gT21taXR0ZWQgY2FsbGJhY2tzIHNvIHRoZXkgYXJlIG5vdCBjYWxsZWQgZXZlcnkgdGltZSB0aGV5IGNoYW5nZVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgICBbcGRmXSk7XG4gICAgZnVuY3Rpb24gc2V0dXBMaW5rU2VydmljZSgpIHtcbiAgICAgICAgbGlua1NlcnZpY2UuY3VycmVudC5zZXRWaWV3ZXIodmlld2VyLmN1cnJlbnQpO1xuICAgICAgICBsaW5rU2VydmljZS5jdXJyZW50LnNldEV4dGVybmFsTGlua1JlbChleHRlcm5hbExpbmtSZWwpO1xuICAgICAgICBsaW5rU2VydmljZS5jdXJyZW50LnNldEV4dGVybmFsTGlua1RhcmdldChleHRlcm5hbExpbmtUYXJnZXQpO1xuICAgIH1cbiAgICAoMCwgcmVhY3RfMS51c2VFZmZlY3QpKHNldHVwTGlua1NlcnZpY2UsIFtleHRlcm5hbExpbmtSZWwsIGV4dGVybmFsTGlua1RhcmdldF0pO1xuICAgIGZ1bmN0aW9uIHJlZ2lzdGVyUGFnZShwYWdlSW5kZXgsIHJlZikge1xuICAgICAgICBwYWdlcy5jdXJyZW50W3BhZ2VJbmRleF0gPSByZWY7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVucmVnaXN0ZXJQYWdlKHBhZ2VJbmRleCkge1xuICAgICAgICBkZWxldGUgcGFnZXMuY3VycmVudFtwYWdlSW5kZXhdO1xuICAgIH1cbiAgICBjb25zdCBjaGlsZENvbnRleHQgPSAoMCwgcmVhY3RfMS51c2VNZW1vKSgoKSA9PiAoe1xuICAgICAgICBpbWFnZVJlc291cmNlc1BhdGgsXG4gICAgICAgIGxpbmtTZXJ2aWNlOiBsaW5rU2VydmljZS5jdXJyZW50LFxuICAgICAgICBvbkl0ZW1DbGljayxcbiAgICAgICAgcGRmLFxuICAgICAgICByZWdpc3RlclBhZ2UsXG4gICAgICAgIHJlbmRlck1vZGUsXG4gICAgICAgIHJvdGF0ZSxcbiAgICAgICAgdW5yZWdpc3RlclBhZ2UsXG4gICAgfSksIFtpbWFnZVJlc291cmNlc1BhdGgsIG9uSXRlbUNsaWNrLCBwZGYsIHJlbmRlck1vZGUsIHJvdGF0ZV0pO1xuICAgIGNvbnN0IGV2ZW50UHJvcHMgPSAoMCwgcmVhY3RfMS51c2VNZW1vKSgoKSA9PiAoMCwgbWFrZV9ldmVudF9wcm9wc18xLmRlZmF1bHQpKG90aGVyUHJvcHMsICgpID0+IHBkZiksIFtvdGhlclByb3BzLCBwZGZdKTtcbiAgICBmdW5jdGlvbiByZW5kZXJDaGlsZHJlbigpIHtcbiAgICAgICAgcmV0dXJuIHJlYWN0XzEuZGVmYXVsdC5jcmVhdGVFbGVtZW50KERvY3VtZW50Q29udGV4dF9qc18xLmRlZmF1bHQuUHJvdmlkZXIsIHsgdmFsdWU6IGNoaWxkQ29udGV4dCB9LCBjaGlsZHJlbik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlbmRlckNvbnRlbnQoKSB7XG4gICAgICAgIGlmICghZmlsZSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlYWN0XzEuZGVmYXVsdC5jcmVhdGVFbGVtZW50KE1lc3NhZ2VfanNfMS5kZWZhdWx0LCB7IHR5cGU6IFwibm8tZGF0YVwiIH0sIHR5cGVvZiBub0RhdGEgPT09ICdmdW5jdGlvbicgPyBub0RhdGEoKSA6IG5vRGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBkZiA9PT0gdW5kZWZpbmVkIHx8IHBkZiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIChyZWFjdF8xLmRlZmF1bHQuY3JlYXRlRWxlbWVudChNZXNzYWdlX2pzXzEuZGVmYXVsdCwgeyB0eXBlOiBcImxvYWRpbmdcIiB9LCB0eXBlb2YgbG9hZGluZyA9PT0gJ2Z1bmN0aW9uJyA/IGxvYWRpbmcoKSA6IGxvYWRpbmcpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGRmID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlYWN0XzEuZGVmYXVsdC5jcmVhdGVFbGVtZW50KE1lc3NhZ2VfanNfMS5kZWZhdWx0LCB7IHR5cGU6IFwiZXJyb3JcIiB9LCB0eXBlb2YgZXJyb3IgPT09ICdmdW5jdGlvbicgPyBlcnJvcigpIDogZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZW5kZXJDaGlsZHJlbigpO1xuICAgIH1cbiAgICByZXR1cm4gKHJlYWN0XzEuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIE9iamVjdC5hc3NpZ24oeyBjbGFzc05hbWU6ICgwLCBjbHN4XzEuZGVmYXVsdCkoJ3JlYWN0LXBkZl9fRG9jdW1lbnQnLCBjbGFzc05hbWUpLCByZWY6IGlucHV0UmVmLCBzdHlsZToge1xuICAgICAgICAgICAgWyctLXNjYWxlLWZhY3RvciddOiAnMScsXG4gICAgICAgIH0gfSwgZXZlbnRQcm9wcyksIHJlbmRlckNvbnRlbnQoKSkpO1xufSk7XG5jb25zdCBpc0Z1bmN0aW9uT3JOb2RlID0gcHJvcF90eXBlc18xLmRlZmF1bHQub25lT2ZUeXBlKFtwcm9wX3R5cGVzXzEuZGVmYXVsdC5mdW5jLCBwcm9wX3R5cGVzXzEuZGVmYXVsdC5ub2RlXSk7XG5Eb2N1bWVudC5wcm9wVHlwZXMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHByb3BUeXBlc19qc18xLmV2ZW50UHJvcHMpLCB7IGNoaWxkcmVuOiBwcm9wX3R5cGVzXzEuZGVmYXVsdC5ub2RlLCBjbGFzc05hbWU6IHByb3BUeXBlc19qc18xLmlzQ2xhc3NOYW1lLCBlcnJvcjogaXNGdW5jdGlvbk9yTm9kZSwgZXh0ZXJuYWxMaW5rUmVsOiBwcm9wX3R5cGVzXzEuZGVmYXVsdC5zdHJpbmcsIGV4dGVybmFsTGlua1RhcmdldDogcHJvcF90eXBlc18xLmRlZmF1bHQub25lT2YoWydfc2VsZicsICdfYmxhbmsnLCAnX3BhcmVudCcsICdfdG9wJ10pLCBmaWxlOiBwcm9wVHlwZXNfanNfMS5pc0ZpbGUsIGltYWdlUmVzb3VyY2VzUGF0aDogcHJvcF90eXBlc18xLmRlZmF1bHQuc3RyaW5nLCBpbnB1dFJlZjogcHJvcFR5cGVzX2pzXzEuaXNSZWYsIGxvYWRpbmc6IGlzRnVuY3Rpb25Pck5vZGUsIG5vRGF0YTogaXNGdW5jdGlvbk9yTm9kZSwgb25JdGVtQ2xpY2s6IHByb3BfdHlwZXNfMS5kZWZhdWx0LmZ1bmMsIG9uTG9hZEVycm9yOiBwcm9wX3R5cGVzXzEuZGVmYXVsdC5mdW5jLCBvbkxvYWRQcm9ncmVzczogcHJvcF90eXBlc18xLmRlZmF1bHQuZnVuYywgb25Mb2FkU3VjY2VzczogcHJvcF90eXBlc18xLmRlZmF1bHQuZnVuYywgb25QYXNzd29yZDogcHJvcF90eXBlc18xLmRlZmF1bHQuZnVuYywgb25Tb3VyY2VFcnJvcjogcHJvcF90eXBlc18xLmRlZmF1bHQuZnVuYywgb25Tb3VyY2VTdWNjZXNzOiBwcm9wX3R5cGVzXzEuZGVmYXVsdC5mdW5jLCBvcHRpb25zOiBwcm9wX3R5cGVzXzEuZGVmYXVsdC5zaGFwZSh7XG4gICAgICAgIGNhbnZhc0ZhY3Rvcnk6IHByb3BfdHlwZXNfMS5kZWZhdWx0LmFueSxcbiAgICAgICAgY2FudmFzTWF4QXJlYUluQnl0ZXM6IHByb3BfdHlwZXNfMS5kZWZhdWx0Lm51bWJlcixcbiAgICAgICAgY01hcFBhY2tlZDogcHJvcF90eXBlc18xLmRlZmF1bHQuYm9vbCxcbiAgICAgICAgQ01hcFJlYWRlckZhY3Rvcnk6IHByb3BfdHlwZXNfMS5kZWZhdWx0LmFueSxcbiAgICAgICAgY01hcFVybDogcHJvcF90eXBlc18xLmRlZmF1bHQuc3RyaW5nLFxuICAgICAgICBkaXNhYmxlQXV0b0ZldGNoOiBwcm9wX3R5cGVzXzEuZGVmYXVsdC5ib29sLFxuICAgICAgICBkaXNhYmxlRm9udEZhY2U6IHByb3BfdHlwZXNfMS5kZWZhdWx0LmJvb2wsXG4gICAgICAgIGRpc2FibGVSYW5nZTogcHJvcF90eXBlc18xLmRlZmF1bHQuYm9vbCxcbiAgICAgICAgZGlzYWJsZVN0cmVhbTogcHJvcF90eXBlc18xLmRlZmF1bHQuYm9vbCxcbiAgICAgICAgZG9jQmFzZVVybDogcHJvcF90eXBlc18xLmRlZmF1bHQuc3RyaW5nLFxuICAgICAgICBlbmFibGVYZmE6IHByb3BfdHlwZXNfMS5kZWZhdWx0LmJvb2wsXG4gICAgICAgIGZpbHRlckZhY3Rvcnk6IHByb3BfdHlwZXNfMS5kZWZhdWx0LmFueSxcbiAgICAgICAgZm9udEV4dHJhUHJvcGVydGllczogcHJvcF90eXBlc18xLmRlZmF1bHQuYm9vbCxcbiAgICAgICAgaHR0cEhlYWRlcnM6IHByb3BfdHlwZXNfMS5kZWZhdWx0Lm9iamVjdCxcbiAgICAgICAgaXNFdmFsU3VwcG9ydGVkOiBwcm9wX3R5cGVzXzEuZGVmYXVsdC5ib29sLFxuICAgICAgICBpc09mZnNjcmVlbkNhbnZhc1N1cHBvcnRlZDogcHJvcF90eXBlc18xLmRlZmF1bHQuYm9vbCxcbiAgICAgICAgbGVuZ3RoOiBwcm9wX3R5cGVzXzEuZGVmYXVsdC5udW1iZXIsXG4gICAgICAgIG1heEltYWdlU2l6ZTogcHJvcF90eXBlc18xLmRlZmF1bHQubnVtYmVyLFxuICAgICAgICBvd25lckRvY3VtZW50OiBwcm9wX3R5cGVzXzEuZGVmYXVsdC5hbnksXG4gICAgICAgIHBhc3N3b3JkOiBwcm9wX3R5cGVzXzEuZGVmYXVsdC5zdHJpbmcsXG4gICAgICAgIHBkZkJ1ZzogcHJvcF90eXBlc18xLmRlZmF1bHQuYm9vbCxcbiAgICAgICAgcmFuZ2VDaHVua1NpemU6IHByb3BfdHlwZXNfMS5kZWZhdWx0Lm51bWJlcixcbiAgICAgICAgU3RhbmRhcmRGb250RGF0YUZhY3Rvcnk6IHByb3BfdHlwZXNfMS5kZWZhdWx0LmFueSxcbiAgICAgICAgc3RhbmRhcmRGb250RGF0YVVybDogcHJvcF90eXBlc18xLmRlZmF1bHQuc3RyaW5nLFxuICAgICAgICBzdG9wQXRFcnJvcnM6IHByb3BfdHlwZXNfMS5kZWZhdWx0LmJvb2wsXG4gICAgICAgIHVzZVN5c3RlbUZvbnRzOiBwcm9wX3R5cGVzXzEuZGVmYXVsdC5ib29sLFxuICAgICAgICB1c2VXb3JrZXJGZXRjaDogcHJvcF90eXBlc18xLmRlZmF1bHQuYm9vbCxcbiAgICAgICAgdmVyYm9zaXR5OiBwcm9wX3R5cGVzXzEuZGVmYXVsdC5udW1iZXIsXG4gICAgICAgIHdpdGhDcmVkZW50aWFsczogcHJvcF90eXBlc18xLmRlZmF1bHQuYm9vbCxcbiAgICAgICAgd29ya2VyOiBwcm9wX3R5cGVzXzEuZGVmYXVsdC5hbnksXG4gICAgfSksIHJvdGF0ZTogcHJvcF90eXBlc18xLmRlZmF1bHQubnVtYmVyIH0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gRG9jdW1lbnQ7XG4iXSwibmFtZXMiOlsiX19jcmVhdGVCaW5kaW5nIiwiT2JqZWN0IiwiY3JlYXRlIiwibyIsIm0iLCJrIiwiazIiLCJ1bmRlZmluZWQiLCJkZXNjIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiX19lc01vZHVsZSIsIndyaXRhYmxlIiwiY29uZmlndXJhYmxlIiwiZW51bWVyYWJsZSIsImdldCIsImRlZmluZVByb3BlcnR5IiwiX19zZXRNb2R1bGVEZWZhdWx0IiwidiIsInZhbHVlIiwiX19pbXBvcnRTdGFyIiwibW9kIiwicmVzdWx0IiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiX19hd2FpdGVyIiwidGhpc0FyZyIsIl9hcmd1bWVudHMiLCJQIiwiZ2VuZXJhdG9yIiwiYWRvcHQiLCJyZXNvbHZlIiwiUHJvbWlzZSIsInJlamVjdCIsImZ1bGZpbGxlZCIsInN0ZXAiLCJuZXh0IiwiZSIsInJlamVjdGVkIiwiZG9uZSIsInRoZW4iLCJhcHBseSIsIl9fcmVzdCIsInMiLCJ0IiwicCIsImluZGV4T2YiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJpIiwibGVuZ3RoIiwicHJvcGVydHlJc0VudW1lcmFibGUiLCJfX2ltcG9ydERlZmF1bHQiLCJleHBvcnRzIiwicmVhY3RfMSIsInJlcXVpcmUiLCJwcm9wX3R5cGVzXzEiLCJtYWtlX2V2ZW50X3Byb3BzXzEiLCJtYWtlX2NhbmNlbGxhYmxlX3Byb21pc2VfMSIsImNsc3hfMSIsInRpbnlfaW52YXJpYW50XzEiLCJ3YXJuaW5nXzEiLCJkZXF1YWxfMSIsInBkZmpzX2pzXzEiLCJEb2N1bWVudENvbnRleHRfanNfMSIsIk1lc3NhZ2VfanNfMSIsIkxpbmtTZXJ2aWNlX2pzXzEiLCJQYXNzd29yZFJlc3BvbnNlc19qc18xIiwidXRpbHNfanNfMSIsInVzZVJlc29sdmVyX2pzXzEiLCJwcm9wVHlwZXNfanNfMSIsIlBERkRhdGFSYW5nZVRyYW5zcG9ydCIsImRlZmF1bHQiLCJkZWZhdWx0T25QYXNzd29yZCIsImNhbGxiYWNrIiwicmVhc29uIiwiTkVFRF9QQVNTV09SRCIsInBhc3N3b3JkIiwicHJvbXB0IiwiSU5DT1JSRUNUX1BBU1NXT1JEIiwiaXNQYXJhbWV0ZXJPYmplY3QiLCJmaWxlIiwiRG9jdW1lbnQiLCJmb3J3YXJkUmVmIiwiX2EiLCJyZWYiLCJjaGlsZHJlbiIsImNsYXNzTmFtZSIsImVycm9yIiwiZXh0ZXJuYWxMaW5rUmVsIiwiZXh0ZXJuYWxMaW5rVGFyZ2V0IiwiaW5wdXRSZWYiLCJpbWFnZVJlc291cmNlc1BhdGgiLCJsb2FkaW5nIiwibm9EYXRhIiwib25JdGVtQ2xpY2siLCJvbkxvYWRFcnJvciIsIm9uTG9hZEVycm9yUHJvcHMiLCJvbkxvYWRQcm9ncmVzcyIsIm9uTG9hZFN1Y2Nlc3MiLCJvbkxvYWRTdWNjZXNzUHJvcHMiLCJvblBhc3N3b3JkIiwib25Tb3VyY2VFcnJvciIsIm9uU291cmNlRXJyb3JQcm9wcyIsIm9uU291cmNlU3VjY2VzcyIsIm9uU291cmNlU3VjY2Vzc1Byb3BzIiwib3B0aW9ucyIsInJlbmRlck1vZGUiLCJyb3RhdGUiLCJvdGhlclByb3BzIiwic291cmNlU3RhdGUiLCJzb3VyY2VEaXNwYXRjaCIsInNvdXJjZSIsInNvdXJjZUVycm9yIiwicGRmU3RhdGUiLCJwZGZEaXNwYXRjaCIsInBkZiIsInBkZkVycm9yIiwibGlua1NlcnZpY2UiLCJ1c2VSZWYiLCJwYWdlcyIsInByZXZGaWxlIiwicHJldk9wdGlvbnMiLCJ1c2VFZmZlY3QiLCJjdXJyZW50IiwiZGVxdWFsIiwidmlld2VyIiwic2Nyb2xsUGFnZUludG9WaWV3IiwiYXJncyIsImRlc3QiLCJwYWdlTnVtYmVyIiwicGFnZUluZGV4IiwicGFnZSIsInNjcm9sbEludG9WaWV3IiwidXNlSW1wZXJhdGl2ZUhhbmRsZSIsInRvU3RyaW5nIiwicmVzZXRTb3VyY2UiLCJ0eXBlIiwiZmluZERvY3VtZW50U291cmNlIiwidXNlQ2FsbGJhY2siLCJpc0RhdGFVUkkiLCJmaWxlQnl0ZVN0cmluZyIsImRhdGFVUkl0b0J5dGVTdHJpbmciLCJkYXRhIiwiZGlzcGxheUNPUlNXYXJuaW5nIiwidXJsIiwicmFuZ2UiLCJpc0FycmF5QnVmZmVyIiwiaXNCcm93c2VyIiwiaXNCbG9iIiwibG9hZEZyb21GaWxlIiwib3RoZXJQYXJhbXMiLCJhc3NpZ24iLCJjYW5jZWxsYWJsZSIsInByb21pc2UiLCJuZXh0U291cmNlIiwiY2F0Y2giLCJjYW5jZWxSdW5uaW5nVGFzayIsIkFycmF5IiwibnVtUGFnZXMiLCJzZXREb2N1bWVudCIsInJlc2V0RG9jdW1lbnQiLCJsb2FkRG9jdW1lbnQiLCJkb2N1bWVudEluaXRQYXJhbXMiLCJkZXN0cm95YWJsZSIsImdldERvY3VtZW50Iiwib25Qcm9ncmVzcyIsImxvYWRpbmdUYXNrIiwibmV4dFBkZiIsImRlc3Ryb3llZCIsImRlc3Ryb3kiLCJzZXR1cExpbmtTZXJ2aWNlIiwic2V0Vmlld2VyIiwic2V0RXh0ZXJuYWxMaW5rUmVsIiwic2V0RXh0ZXJuYWxMaW5rVGFyZ2V0IiwicmVnaXN0ZXJQYWdlIiwidW5yZWdpc3RlclBhZ2UiLCJjaGlsZENvbnRleHQiLCJ1c2VNZW1vIiwiZXZlbnRQcm9wcyIsInJlbmRlckNoaWxkcmVuIiwiY3JlYXRlRWxlbWVudCIsIlByb3ZpZGVyIiwicmVuZGVyQ29udGVudCIsInN0eWxlIiwiaXNGdW5jdGlvbk9yTm9kZSIsIm9uZU9mVHlwZSIsImZ1bmMiLCJub2RlIiwicHJvcFR5cGVzIiwiaXNDbGFzc05hbWUiLCJzdHJpbmciLCJvbmVPZiIsImlzRmlsZSIsImlzUmVmIiwic2hhcGUiLCJjYW52YXNGYWN0b3J5IiwiYW55IiwiY2FudmFzTWF4QXJlYUluQnl0ZXMiLCJudW1iZXIiLCJjTWFwUGFja2VkIiwiYm9vbCIsIkNNYXBSZWFkZXJGYWN0b3J5IiwiY01hcFVybCIsImRpc2FibGVBdXRvRmV0Y2giLCJkaXNhYmxlRm9udEZhY2UiLCJkaXNhYmxlUmFuZ2UiLCJkaXNhYmxlU3RyZWFtIiwiZG9jQmFzZVVybCIsImVuYWJsZVhmYSIsImZpbHRlckZhY3RvcnkiLCJmb250RXh0cmFQcm9wZXJ0aWVzIiwiaHR0cEhlYWRlcnMiLCJvYmplY3QiLCJpc0V2YWxTdXBwb3J0ZWQiLCJpc09mZnNjcmVlbkNhbnZhc1N1cHBvcnRlZCIsIm1heEltYWdlU2l6ZSIsIm93bmVyRG9jdW1lbnQiLCJwZGZCdWciLCJyYW5nZUNodW5rU2l6ZSIsIlN0YW5kYXJkRm9udERhdGFGYWN0b3J5Iiwic3RhbmRhcmRGb250RGF0YVVybCIsInN0b3BBdEVycm9ycyIsInVzZVN5c3RlbUZvbnRzIiwidXNlV29ya2VyRmV0Y2giLCJ2ZXJib3NpdHkiLCJ3aXRoQ3JlZGVudGlhbHMiLCJ3b3JrZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-pdf/dist/cjs/Document.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-pdf/dist/cjs/DocumentContext.js":
/*!************************************************************!*\
  !*** ./node_modules/react-pdf/dist/cjs/DocumentContext.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/* __next_internal_client_entry_do_not_use__  cjs */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nconst react_1 = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\nexports[\"default\"] = (0, react_1.createContext)(null);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1wZGYvZGlzdC9janMvRG9jdW1lbnRDb250ZXh0LmpzIiwibWFwcGluZ3MiOiJxREFBYTtBQUViQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3RCxNQUFNQyxVQUFVQyxtQkFBT0EsQ0FBQyxtRkFBTztBQUMvQkgsa0JBQWUsR0FBRyxDQUFDLEdBQUdFLFFBQVFHLGFBQWEsRUFBRSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVhY3QtcGRmL2Rpc3QvY2pzL0RvY3VtZW50Q29udGV4dC5qcz85Nzg3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuJ3VzZSBjbGllbnQnO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgcmVhY3RfMSA9IHJlcXVpcmUoXCJyZWFjdFwiKTtcbmV4cG9ydHMuZGVmYXVsdCA9ICgwLCByZWFjdF8xLmNyZWF0ZUNvbnRleHQpKG51bGwpO1xuIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwicmVhY3RfMSIsInJlcXVpcmUiLCJkZWZhdWx0IiwiY3JlYXRlQ29udGV4dCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-pdf/dist/cjs/DocumentContext.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-pdf/dist/cjs/LinkService.js":
/*!********************************************************!*\
  !*** ./node_modules/react-pdf/dist/cjs/LinkService.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/* Copyright 2015 Mozilla Foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst tiny_invariant_1 = __importDefault(__webpack_require__(/*! tiny-invariant */ \"(app-pages-browser)/./node_modules/tiny-invariant/dist/tiny-invariant.cjs.js\"));\nconst DEFAULT_LINK_REL = 'noopener noreferrer nofollow';\nclass LinkService {\n    constructor() {\n        this.externalLinkEnabled = true;\n        this.externalLinkRel = undefined;\n        this.externalLinkTarget = undefined;\n        this.isInPresentationMode = false;\n        this.pdfDocument = undefined;\n        this.pdfViewer = undefined;\n    }\n    setDocument(pdfDocument) {\n        this.pdfDocument = pdfDocument;\n    }\n    setViewer(pdfViewer) {\n        this.pdfViewer = pdfViewer;\n    }\n    setExternalLinkRel(externalLinkRel) {\n        this.externalLinkRel = externalLinkRel;\n    }\n    setExternalLinkTarget(externalLinkTarget) {\n        this.externalLinkTarget = externalLinkTarget;\n    }\n    setHistory() {\n        // Intentionally empty\n    }\n    get pagesCount() {\n        return this.pdfDocument ? this.pdfDocument.numPages : 0;\n    }\n    get page() {\n        (0, tiny_invariant_1.default)(this.pdfViewer, 'PDF viewer is not initialized.');\n        return this.pdfViewer.currentPageNumber || 0;\n    }\n    set page(value) {\n        (0, tiny_invariant_1.default)(this.pdfViewer, 'PDF viewer is not initialized.');\n        this.pdfViewer.currentPageNumber = value;\n    }\n    // eslint-disable-next-line @typescript-eslint/class-literal-property-style\n    get rotation() {\n        return 0;\n    }\n    set rotation(value) {\n        // Intentionally empty\n    }\n    goToDestination(dest) {\n        return new Promise((resolve) => {\n            (0, tiny_invariant_1.default)(this.pdfDocument, 'PDF document not loaded.');\n            (0, tiny_invariant_1.default)(dest, 'Destination is not specified.');\n            if (typeof dest === 'string') {\n                this.pdfDocument.getDestination(dest).then(resolve);\n            }\n            else if (Array.isArray(dest)) {\n                resolve(dest);\n            }\n            else {\n                dest.then(resolve);\n            }\n        }).then((explicitDest) => {\n            (0, tiny_invariant_1.default)(Array.isArray(explicitDest), `\"${explicitDest}\" is not a valid destination array.`);\n            const destRef = explicitDest[0];\n            new Promise((resolve) => {\n                (0, tiny_invariant_1.default)(this.pdfDocument, 'PDF document not loaded.');\n                if (destRef instanceof Object) {\n                    this.pdfDocument\n                        .getPageIndex(destRef)\n                        .then((pageIndex) => {\n                        resolve(pageIndex);\n                    })\n                        .catch(() => {\n                        (0, tiny_invariant_1.default)(false, `\"${destRef}\" is not a valid page reference.`);\n                    });\n                }\n                else if (typeof destRef === 'number') {\n                    resolve(destRef);\n                }\n                else {\n                    (0, tiny_invariant_1.default)(false, `\"${destRef}\" is not a valid destination reference.`);\n                }\n            }).then((pageIndex) => {\n                const pageNumber = pageIndex + 1;\n                (0, tiny_invariant_1.default)(this.pdfViewer, 'PDF viewer is not initialized.');\n                (0, tiny_invariant_1.default)(pageNumber >= 1 && pageNumber <= this.pagesCount, `\"${pageNumber}\" is not a valid page number.`);\n                this.pdfViewer.scrollPageIntoView({\n                    dest: explicitDest,\n                    pageIndex,\n                    pageNumber,\n                });\n            });\n        });\n    }\n    navigateTo(dest) {\n        this.goToDestination(dest);\n    }\n    goToPage(pageNumber) {\n        const pageIndex = pageNumber - 1;\n        (0, tiny_invariant_1.default)(this.pdfViewer, 'PDF viewer is not initialized.');\n        (0, tiny_invariant_1.default)(pageNumber >= 1 && pageNumber <= this.pagesCount, `\"${pageNumber}\" is not a valid page number.`);\n        this.pdfViewer.scrollPageIntoView({\n            pageIndex,\n            pageNumber,\n        });\n    }\n    addLinkAttributes(link, url, newWindow) {\n        link.href = url;\n        link.rel = this.externalLinkRel || DEFAULT_LINK_REL;\n        link.target = newWindow ? '_blank' : this.externalLinkTarget || '';\n    }\n    getDestinationHash() {\n        return '#';\n    }\n    getAnchorUrl() {\n        return '#';\n    }\n    setHash() {\n        // Intentionally empty\n    }\n    executeNamedAction() {\n        // Intentionally empty\n    }\n    cachePageRef() {\n        // Intentionally empty\n    }\n    isPageVisible() {\n        return true;\n    }\n    isPageCached() {\n        return true;\n    }\n    executeSetOCGState() {\n        // Intentionally empty\n    }\n}\nexports[\"default\"] = LinkService;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1wZGYvZGlzdC9janMvTGlua1NlcnZpY2UuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLG1CQUFPLENBQUMsb0dBQWdCO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsMkVBQTJFLGFBQWE7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGlFQUFpRSxRQUFRO0FBQ3pFLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELFFBQVE7QUFDckU7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLG9HQUFvRyxXQUFXO0FBQy9HO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RkFBNEYsV0FBVztBQUN2RztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBZSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVhY3QtcGRmL2Rpc3QvY2pzL0xpbmtTZXJ2aWNlLmpzP2NiMmMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKiBDb3B5cmlnaHQgMjAxNSBNb3ppbGxhIEZvdW5kYXRpb25cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmNvbnN0IHRpbnlfaW52YXJpYW50XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcInRpbnktaW52YXJpYW50XCIpKTtcbmNvbnN0IERFRkFVTFRfTElOS19SRUwgPSAnbm9vcGVuZXIgbm9yZWZlcnJlciBub2ZvbGxvdyc7XG5jbGFzcyBMaW5rU2VydmljZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuZXh0ZXJuYWxMaW5rRW5hYmxlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuZXh0ZXJuYWxMaW5rUmVsID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmV4dGVybmFsTGlua1RhcmdldCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5pc0luUHJlc2VudGF0aW9uTW9kZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnBkZkRvY3VtZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnBkZlZpZXdlciA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgc2V0RG9jdW1lbnQocGRmRG9jdW1lbnQpIHtcbiAgICAgICAgdGhpcy5wZGZEb2N1bWVudCA9IHBkZkRvY3VtZW50O1xuICAgIH1cbiAgICBzZXRWaWV3ZXIocGRmVmlld2VyKSB7XG4gICAgICAgIHRoaXMucGRmVmlld2VyID0gcGRmVmlld2VyO1xuICAgIH1cbiAgICBzZXRFeHRlcm5hbExpbmtSZWwoZXh0ZXJuYWxMaW5rUmVsKSB7XG4gICAgICAgIHRoaXMuZXh0ZXJuYWxMaW5rUmVsID0gZXh0ZXJuYWxMaW5rUmVsO1xuICAgIH1cbiAgICBzZXRFeHRlcm5hbExpbmtUYXJnZXQoZXh0ZXJuYWxMaW5rVGFyZ2V0KSB7XG4gICAgICAgIHRoaXMuZXh0ZXJuYWxMaW5rVGFyZ2V0ID0gZXh0ZXJuYWxMaW5rVGFyZ2V0O1xuICAgIH1cbiAgICBzZXRIaXN0b3J5KCkge1xuICAgICAgICAvLyBJbnRlbnRpb25hbGx5IGVtcHR5XG4gICAgfVxuICAgIGdldCBwYWdlc0NvdW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wZGZEb2N1bWVudCA/IHRoaXMucGRmRG9jdW1lbnQubnVtUGFnZXMgOiAwO1xuICAgIH1cbiAgICBnZXQgcGFnZSgpIHtcbiAgICAgICAgKDAsIHRpbnlfaW52YXJpYW50XzEuZGVmYXVsdCkodGhpcy5wZGZWaWV3ZXIsICdQREYgdmlld2VyIGlzIG5vdCBpbml0aWFsaXplZC4nKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGRmVmlld2VyLmN1cnJlbnRQYWdlTnVtYmVyIHx8IDA7XG4gICAgfVxuICAgIHNldCBwYWdlKHZhbHVlKSB7XG4gICAgICAgICgwLCB0aW55X2ludmFyaWFudF8xLmRlZmF1bHQpKHRoaXMucGRmVmlld2VyLCAnUERGIHZpZXdlciBpcyBub3QgaW5pdGlhbGl6ZWQuJyk7XG4gICAgICAgIHRoaXMucGRmVmlld2VyLmN1cnJlbnRQYWdlTnVtYmVyID0gdmFsdWU7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvY2xhc3MtbGl0ZXJhbC1wcm9wZXJ0eS1zdHlsZVxuICAgIGdldCByb3RhdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIHNldCByb3RhdGlvbih2YWx1ZSkge1xuICAgICAgICAvLyBJbnRlbnRpb25hbGx5IGVtcHR5XG4gICAgfVxuICAgIGdvVG9EZXN0aW5hdGlvbihkZXN0KSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgKDAsIHRpbnlfaW52YXJpYW50XzEuZGVmYXVsdCkodGhpcy5wZGZEb2N1bWVudCwgJ1BERiBkb2N1bWVudCBub3QgbG9hZGVkLicpO1xuICAgICAgICAgICAgKDAsIHRpbnlfaW52YXJpYW50XzEuZGVmYXVsdCkoZGVzdCwgJ0Rlc3RpbmF0aW9uIGlzIG5vdCBzcGVjaWZpZWQuJyk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGRlc3QgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wZGZEb2N1bWVudC5nZXREZXN0aW5hdGlvbihkZXN0KS50aGVuKHJlc29sdmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShkZXN0KSkge1xuICAgICAgICAgICAgICAgIHJlc29sdmUoZGVzdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZXN0LnRoZW4ocmVzb2x2ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLnRoZW4oKGV4cGxpY2l0RGVzdCkgPT4ge1xuICAgICAgICAgICAgKDAsIHRpbnlfaW52YXJpYW50XzEuZGVmYXVsdCkoQXJyYXkuaXNBcnJheShleHBsaWNpdERlc3QpLCBgXCIke2V4cGxpY2l0RGVzdH1cIiBpcyBub3QgYSB2YWxpZCBkZXN0aW5hdGlvbiBhcnJheS5gKTtcbiAgICAgICAgICAgIGNvbnN0IGRlc3RSZWYgPSBleHBsaWNpdERlc3RbMF07XG4gICAgICAgICAgICBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgICAgICgwLCB0aW55X2ludmFyaWFudF8xLmRlZmF1bHQpKHRoaXMucGRmRG9jdW1lbnQsICdQREYgZG9jdW1lbnQgbm90IGxvYWRlZC4nKTtcbiAgICAgICAgICAgICAgICBpZiAoZGVzdFJlZiBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBkZkRvY3VtZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAuZ2V0UGFnZUluZGV4KGRlc3RSZWYpXG4gICAgICAgICAgICAgICAgICAgICAgICAudGhlbigocGFnZUluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHBhZ2VJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAuY2F0Y2goKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgKDAsIHRpbnlfaW52YXJpYW50XzEuZGVmYXVsdCkoZmFsc2UsIGBcIiR7ZGVzdFJlZn1cIiBpcyBub3QgYSB2YWxpZCBwYWdlIHJlZmVyZW5jZS5gKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBkZXN0UmVmID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGRlc3RSZWYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgKDAsIHRpbnlfaW52YXJpYW50XzEuZGVmYXVsdCkoZmFsc2UsIGBcIiR7ZGVzdFJlZn1cIiBpcyBub3QgYSB2YWxpZCBkZXN0aW5hdGlvbiByZWZlcmVuY2UuYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkudGhlbigocGFnZUluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFnZU51bWJlciA9IHBhZ2VJbmRleCArIDE7XG4gICAgICAgICAgICAgICAgKDAsIHRpbnlfaW52YXJpYW50XzEuZGVmYXVsdCkodGhpcy5wZGZWaWV3ZXIsICdQREYgdmlld2VyIGlzIG5vdCBpbml0aWFsaXplZC4nKTtcbiAgICAgICAgICAgICAgICAoMCwgdGlueV9pbnZhcmlhbnRfMS5kZWZhdWx0KShwYWdlTnVtYmVyID49IDEgJiYgcGFnZU51bWJlciA8PSB0aGlzLnBhZ2VzQ291bnQsIGBcIiR7cGFnZU51bWJlcn1cIiBpcyBub3QgYSB2YWxpZCBwYWdlIG51bWJlci5gKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBkZlZpZXdlci5zY3JvbGxQYWdlSW50b1ZpZXcoe1xuICAgICAgICAgICAgICAgICAgICBkZXN0OiBleHBsaWNpdERlc3QsXG4gICAgICAgICAgICAgICAgICAgIHBhZ2VJbmRleCxcbiAgICAgICAgICAgICAgICAgICAgcGFnZU51bWJlcixcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgbmF2aWdhdGVUbyhkZXN0KSB7XG4gICAgICAgIHRoaXMuZ29Ub0Rlc3RpbmF0aW9uKGRlc3QpO1xuICAgIH1cbiAgICBnb1RvUGFnZShwYWdlTnVtYmVyKSB7XG4gICAgICAgIGNvbnN0IHBhZ2VJbmRleCA9IHBhZ2VOdW1iZXIgLSAxO1xuICAgICAgICAoMCwgdGlueV9pbnZhcmlhbnRfMS5kZWZhdWx0KSh0aGlzLnBkZlZpZXdlciwgJ1BERiB2aWV3ZXIgaXMgbm90IGluaXRpYWxpemVkLicpO1xuICAgICAgICAoMCwgdGlueV9pbnZhcmlhbnRfMS5kZWZhdWx0KShwYWdlTnVtYmVyID49IDEgJiYgcGFnZU51bWJlciA8PSB0aGlzLnBhZ2VzQ291bnQsIGBcIiR7cGFnZU51bWJlcn1cIiBpcyBub3QgYSB2YWxpZCBwYWdlIG51bWJlci5gKTtcbiAgICAgICAgdGhpcy5wZGZWaWV3ZXIuc2Nyb2xsUGFnZUludG9WaWV3KHtcbiAgICAgICAgICAgIHBhZ2VJbmRleCxcbiAgICAgICAgICAgIHBhZ2VOdW1iZXIsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhZGRMaW5rQXR0cmlidXRlcyhsaW5rLCB1cmwsIG5ld1dpbmRvdykge1xuICAgICAgICBsaW5rLmhyZWYgPSB1cmw7XG4gICAgICAgIGxpbmsucmVsID0gdGhpcy5leHRlcm5hbExpbmtSZWwgfHwgREVGQVVMVF9MSU5LX1JFTDtcbiAgICAgICAgbGluay50YXJnZXQgPSBuZXdXaW5kb3cgPyAnX2JsYW5rJyA6IHRoaXMuZXh0ZXJuYWxMaW5rVGFyZ2V0IHx8ICcnO1xuICAgIH1cbiAgICBnZXREZXN0aW5hdGlvbkhhc2goKSB7XG4gICAgICAgIHJldHVybiAnIyc7XG4gICAgfVxuICAgIGdldEFuY2hvclVybCgpIHtcbiAgICAgICAgcmV0dXJuICcjJztcbiAgICB9XG4gICAgc2V0SGFzaCgpIHtcbiAgICAgICAgLy8gSW50ZW50aW9uYWxseSBlbXB0eVxuICAgIH1cbiAgICBleGVjdXRlTmFtZWRBY3Rpb24oKSB7XG4gICAgICAgIC8vIEludGVudGlvbmFsbHkgZW1wdHlcbiAgICB9XG4gICAgY2FjaGVQYWdlUmVmKCkge1xuICAgICAgICAvLyBJbnRlbnRpb25hbGx5IGVtcHR5XG4gICAgfVxuICAgIGlzUGFnZVZpc2libGUoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpc1BhZ2VDYWNoZWQoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBleGVjdXRlU2V0T0NHU3RhdGUoKSB7XG4gICAgICAgIC8vIEludGVudGlvbmFsbHkgZW1wdHlcbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBMaW5rU2VydmljZTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-pdf/dist/cjs/LinkService.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-pdf/dist/cjs/Message.js":
/*!****************************************************!*\
  !*** ./node_modules/react-pdf/dist/cjs/Message.js ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst react_1 = __importDefault(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"));\nfunction Message({ children, type }) {\n    return react_1.default.createElement(\"div\", { className: `react-pdf__message react-pdf__message--${type}` }, children);\n}\nexports[\"default\"] = Message;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1wZGYvZGlzdC9janMvTWVzc2FnZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGdDQUFnQyxtQkFBTyxDQUFDLG1GQUFPO0FBQy9DLG1CQUFtQixnQkFBZ0I7QUFDbkMsa0RBQWtELHFEQUFxRCxLQUFLLEdBQUc7QUFDL0c7QUFDQSxrQkFBZSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVhY3QtcGRmL2Rpc3QvY2pzL01lc3NhZ2UuanM/NTczMCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHJlYWN0XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcInJlYWN0XCIpKTtcbmZ1bmN0aW9uIE1lc3NhZ2UoeyBjaGlsZHJlbiwgdHlwZSB9KSB7XG4gICAgcmV0dXJuIHJlYWN0XzEuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBgcmVhY3QtcGRmX19tZXNzYWdlIHJlYWN0LXBkZl9fbWVzc2FnZS0tJHt0eXBlfWAgfSwgY2hpbGRyZW4pO1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gTWVzc2FnZTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-pdf/dist/cjs/Message.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-pdf/dist/cjs/Outline.js":
/*!****************************************************!*\
  !*** ./node_modules/react-pdf/dist/cjs/Outline.js ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/* __next_internal_client_entry_do_not_use__  cjs */ \nvar __createBinding = (void 0) && (void 0).__createBinding || (Object.create ? function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n        desc = {\n            enumerable: true,\n            get: function() {\n                return m[k];\n            }\n        };\n    }\n    Object.defineProperty(o, k2, desc);\n} : function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n});\nvar __setModuleDefault = (void 0) && (void 0).__setModuleDefault || (Object.create ? function(o, v) {\n    Object.defineProperty(o, \"default\", {\n        enumerable: true,\n        value: v\n    });\n} : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (void 0) && (void 0).__importStar || function(mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) {\n        for(var k in mod)if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    }\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __rest = (void 0) && (void 0).__rest || function(s, e) {\n    var t = {};\n    for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++){\n        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n    }\n    return t;\n};\nvar __importDefault = (void 0) && (void 0).__importDefault || function(mod) {\n    return mod && mod.__esModule ? mod : {\n        \"default\": mod\n    };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nconst react_1 = __importStar(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"));\nconst prop_types_1 = __importDefault(__webpack_require__(/*! prop-types */ \"(app-pages-browser)/./node_modules/prop-types/index.js\"));\nconst make_cancellable_promise_1 = __importDefault(__webpack_require__(/*! make-cancellable-promise */ \"(app-pages-browser)/./node_modules/make-cancellable-promise/dist/cjs/index.js\"));\nconst make_event_props_1 = __importDefault(__webpack_require__(/*! make-event-props */ \"(app-pages-browser)/./node_modules/make-event-props/dist/cjs/index.js\"));\nconst clsx_1 = __importDefault(__webpack_require__(/*! clsx */ \"(app-pages-browser)/./node_modules/clsx/dist/clsx.js\"));\nconst tiny_invariant_1 = __importDefault(__webpack_require__(/*! tiny-invariant */ \"(app-pages-browser)/./node_modules/tiny-invariant/dist/tiny-invariant.cjs.js\"));\nconst warning_1 = __importDefault(__webpack_require__(/*! warning */ \"(app-pages-browser)/./node_modules/warning/warning.js\"));\nconst OutlineContext_js_1 = __importDefault(__webpack_require__(/*! ./OutlineContext.js */ \"(app-pages-browser)/./node_modules/react-pdf/dist/cjs/OutlineContext.js\"));\nconst OutlineItem_js_1 = __importDefault(__webpack_require__(/*! ./OutlineItem.js */ \"(app-pages-browser)/./node_modules/react-pdf/dist/cjs/OutlineItem.js\"));\nconst utils_js_1 = __webpack_require__(/*! ./shared/utils.js */ \"(app-pages-browser)/./node_modules/react-pdf/dist/cjs/shared/utils.js\");\nconst useDocumentContext_js_1 = __importDefault(__webpack_require__(/*! ./shared/hooks/useDocumentContext.js */ \"(app-pages-browser)/./node_modules/react-pdf/dist/cjs/shared/hooks/useDocumentContext.js\"));\nconst useResolver_js_1 = __importDefault(__webpack_require__(/*! ./shared/hooks/useResolver.js */ \"(app-pages-browser)/./node_modules/react-pdf/dist/cjs/shared/hooks/useResolver.js\"));\nconst propTypes_js_1 = __webpack_require__(/*! ./shared/propTypes.js */ \"(app-pages-browser)/./node_modules/react-pdf/dist/cjs/shared/propTypes.js\");\n/**\n * Displays an outline (table of contents).\n *\n * Should be placed inside `<Document />`. Alternatively, it can have `pdf` prop passed, which can be obtained from `<Document />`'s `onLoadSuccess` callback function.\n */ const Outline = function Outline(props) {\n    const documentContext = (0, useDocumentContext_js_1.default)();\n    const mergedProps = Object.assign(Object.assign({}, documentContext), props);\n    const { className, inputRef, onItemClick, onLoadError: onLoadErrorProps, onLoadSuccess: onLoadSuccessProps, pdf } = mergedProps, otherProps = __rest(mergedProps, [\n        \"className\",\n        \"inputRef\",\n        \"onItemClick\",\n        \"onLoadError\",\n        \"onLoadSuccess\",\n        \"pdf\"\n    ]);\n    (0, tiny_invariant_1.default)(pdf, \"Attempted to load an outline, but no document was specified. Wrap <Outline /> in a <Document /> or pass explicit `pdf` prop.\");\n    const [outlineState, outlineDispatch] = (0, useResolver_js_1.default)();\n    const { value: outline, error: outlineError } = outlineState;\n    /**\n     * Called when an outline is read successfully\n     */ function onLoadSuccess() {\n        if (typeof outline === \"undefined\" || outline === false) {\n            return;\n        }\n        if (onLoadSuccessProps) {\n            onLoadSuccessProps(outline);\n        }\n    }\n    /**\n     * Called when an outline failed to read successfully\n     */ function onLoadError() {\n        if (!outlineError) {\n            // Impossible, but TypeScript doesn't know that\n            return;\n        }\n        (0, warning_1.default)(false, outlineError.toString());\n        if (onLoadErrorProps) {\n            onLoadErrorProps(outlineError);\n        }\n    }\n    function resetOutline() {\n        outlineDispatch({\n            type: \"RESET\"\n        });\n    }\n    (0, react_1.useEffect)(resetOutline, [\n        outlineDispatch,\n        pdf\n    ]);\n    function loadOutline() {\n        if (!pdf) {\n            // Impossible, but TypeScript doesn't know that\n            return;\n        }\n        const cancellable = (0, make_cancellable_promise_1.default)(pdf.getOutline());\n        const runningTask = cancellable;\n        cancellable.promise.then((nextOutline)=>{\n            outlineDispatch({\n                type: \"RESOLVE\",\n                value: nextOutline\n            });\n        }).catch((error)=>{\n            outlineDispatch({\n                type: \"REJECT\",\n                error\n            });\n        });\n        return ()=>(0, utils_js_1.cancelRunningTask)(runningTask);\n    }\n    (0, react_1.useEffect)(loadOutline, [\n        outlineDispatch,\n        pdf\n    ]);\n    (0, react_1.useEffect)(()=>{\n        if (outline === undefined) {\n            return;\n        }\n        if (outline === false) {\n            onLoadError();\n            return;\n        }\n        onLoadSuccess();\n    }, // Ommitted callbacks so they are not called every time they change\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [\n        outline\n    ]);\n    const childContext = (0, react_1.useMemo)(()=>({\n            onItemClick\n        }), [\n        onItemClick\n    ]);\n    const eventProps = (0, react_1.useMemo)(()=>(0, make_event_props_1.default)(otherProps, ()=>outline), [\n        otherProps,\n        outline\n    ]);\n    if (!outline) {\n        return null;\n    }\n    function renderOutline() {\n        if (!outline) {\n            return null;\n        }\n        return react_1.default.createElement(\"ul\", null, outline.map((item, itemIndex)=>react_1.default.createElement(OutlineItem_js_1.default, {\n                key: typeof item.dest === \"string\" ? item.dest : itemIndex,\n                item: item,\n                pdf: pdf\n            })));\n    }\n    return react_1.default.createElement(\"div\", Object.assign({\n        className: (0, clsx_1.default)(\"react-pdf__Outline\", className),\n        ref: inputRef\n    }, eventProps), react_1.default.createElement(OutlineContext_js_1.default.Provider, {\n        value: childContext\n    }, renderOutline()));\n};\n_c = Outline;\nOutline.propTypes = Object.assign(Object.assign({}, propTypes_js_1.eventProps), {\n    className: propTypes_js_1.isClassName,\n    inputRef: propTypes_js_1.isRef,\n    onItemClick: prop_types_1.default.func,\n    onLoadError: prop_types_1.default.func,\n    onLoadSuccess: prop_types_1.default.func,\n    pdf: propTypes_js_1.isPdf\n});\nexports[\"default\"] = Outline;\nvar _c;\n$RefreshReg$(_c, \"Outline\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1wZGYvZGlzdC9janMvT3V0bGluZS5qcyIsIm1hcHBpbmdzIjoicURBQWE7QUFFYixJQUFJQSxrQkFBa0IsQ0FBQyxNQUFHLEtBQUssT0FBRyxFQUFFQSxlQUFlLElBQU1DLENBQUFBLE9BQU9DLE1BQU0sR0FBSSxTQUFTQyxDQUFDLEVBQUVDLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxFQUFFO0lBQzFGLElBQUlBLE9BQU9DLFdBQVdELEtBQUtEO0lBQzNCLElBQUlHLE9BQU9QLE9BQU9RLHdCQUF3QixDQUFDTCxHQUFHQztJQUM5QyxJQUFJLENBQUNHLFFBQVMsVUFBU0EsT0FBTyxDQUFDSixFQUFFTSxVQUFVLEdBQUdGLEtBQUtHLFFBQVEsSUFBSUgsS0FBS0ksWUFBWSxHQUFHO1FBQ2pGSixPQUFPO1lBQUVLLFlBQVk7WUFBTUMsS0FBSztnQkFBYSxPQUFPVixDQUFDLENBQUNDLEVBQUU7WUFBRTtRQUFFO0lBQzlEO0lBQ0FKLE9BQU9jLGNBQWMsQ0FBQ1osR0FBR0csSUFBSUU7QUFDakMsSUFBTSxTQUFTTCxDQUFDLEVBQUVDLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxFQUFFO0lBQ3RCLElBQUlBLE9BQU9DLFdBQVdELEtBQUtEO0lBQzNCRixDQUFDLENBQUNHLEdBQUcsR0FBR0YsQ0FBQyxDQUFDQyxFQUFFO0FBQ2hCLENBQUM7QUFDRCxJQUFJVyxxQkFBcUIsQ0FBQyxNQUFHLEtBQUssT0FBRyxFQUFFQSxrQkFBa0IsSUFBTWYsQ0FBQUEsT0FBT0MsTUFBTSxHQUFJLFNBQVNDLENBQUMsRUFBRWMsQ0FBQztJQUN6RmhCLE9BQU9jLGNBQWMsQ0FBQ1osR0FBRyxXQUFXO1FBQUVVLFlBQVk7UUFBTUssT0FBT0Q7SUFBRTtBQUNyRSxJQUFLLFNBQVNkLENBQUMsRUFBRWMsQ0FBQztJQUNkZCxDQUFDLENBQUMsVUFBVSxHQUFHYztBQUNuQjtBQUNBLElBQUlFLGVBQWUsQ0FBQyxNQUFHLEtBQUssT0FBRyxFQUFFQSxZQUFZLElBQUssU0FBVUMsR0FBRztJQUMzRCxJQUFJQSxPQUFPQSxJQUFJVixVQUFVLEVBQUUsT0FBT1U7SUFDbEMsSUFBSUMsU0FBUyxDQUFDO0lBQ2QsSUFBSUQsT0FBTyxNQUFNO1FBQUEsSUFBSyxJQUFJZixLQUFLZSxJQUFLLElBQUlmLE1BQU0sYUFBYUosT0FBT3FCLFNBQVMsQ0FBQ0MsY0FBYyxDQUFDQyxJQUFJLENBQUNKLEtBQUtmLElBQUlMLGdCQUFnQnFCLFFBQVFELEtBQUtmO0lBQUU7SUFDeElXLG1CQUFtQkssUUFBUUQ7SUFDM0IsT0FBT0M7QUFDWDtBQUNBLElBQUlJLFNBQVMsQ0FBQyxNQUFHLEtBQUssT0FBRyxFQUFFQSxNQUFNLElBQUssU0FBVUMsQ0FBQyxFQUFFQyxDQUFDO0lBQ2hELElBQUlDLElBQUksQ0FBQztJQUNULElBQUssSUFBSUMsS0FBS0gsRUFBRyxJQUFJekIsT0FBT3FCLFNBQVMsQ0FBQ0MsY0FBYyxDQUFDQyxJQUFJLENBQUNFLEdBQUdHLE1BQU1GLEVBQUVHLE9BQU8sQ0FBQ0QsS0FBSyxHQUM5RUQsQ0FBQyxDQUFDQyxFQUFFLEdBQUdILENBQUMsQ0FBQ0csRUFBRTtJQUNmLElBQUlILEtBQUssUUFBUSxPQUFPekIsT0FBTzhCLHFCQUFxQixLQUFLLFlBQ3JELElBQUssSUFBSUMsSUFBSSxHQUFHSCxJQUFJNUIsT0FBTzhCLHFCQUFxQixDQUFDTCxJQUFJTSxJQUFJSCxFQUFFSSxNQUFNLEVBQUVELElBQUs7UUFDcEUsSUFBSUwsRUFBRUcsT0FBTyxDQUFDRCxDQUFDLENBQUNHLEVBQUUsSUFBSSxLQUFLL0IsT0FBT3FCLFNBQVMsQ0FBQ1ksb0JBQW9CLENBQUNWLElBQUksQ0FBQ0UsR0FBR0csQ0FBQyxDQUFDRyxFQUFFLEdBQ3pFSixDQUFDLENBQUNDLENBQUMsQ0FBQ0csRUFBRSxDQUFDLEdBQUdOLENBQUMsQ0FBQ0csQ0FBQyxDQUFDRyxFQUFFLENBQUM7SUFDekI7SUFDSixPQUFPSjtBQUNYO0FBQ0EsSUFBSU8sa0JBQWtCLENBQUMsTUFBRyxLQUFLLE9BQUcsRUFBRUEsZUFBZSxJQUFLLFNBQVVmLEdBQUc7SUFDakUsT0FBTyxPQUFRQSxJQUFJVixVQUFVLEdBQUlVLE1BQU07UUFBRSxXQUFXQTtJQUFJO0FBQzVEO0FBQ0FuQiw4Q0FBNkM7SUFBRWlCLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0QsTUFBTW1CLFVBQVVsQixhQUFhbUIsbUJBQU9BLENBQUMsbUZBQU87QUFDNUMsTUFBTUMsZUFBZUosZ0JBQWdCRyxtQkFBT0EsQ0FBQywwRUFBWTtBQUN6RCxNQUFNRSw2QkFBNkJMLGdCQUFnQkcsbUJBQU9BLENBQUMsK0dBQTBCO0FBQ3JGLE1BQU1HLHFCQUFxQk4sZ0JBQWdCRyxtQkFBT0EsQ0FBQywrRkFBa0I7QUFDckUsTUFBTUksU0FBU1AsZ0JBQWdCRyxtQkFBT0EsQ0FBQyxrRUFBTTtBQUM3QyxNQUFNSyxtQkFBbUJSLGdCQUFnQkcsbUJBQU9BLENBQUMsb0dBQWdCO0FBQ2pFLE1BQU1NLFlBQVlULGdCQUFnQkcsbUJBQU9BLENBQUMsc0VBQVM7QUFDbkQsTUFBTU8sc0JBQXNCVixnQkFBZ0JHLG1CQUFPQSxDQUFDLG9HQUFxQjtBQUN6RSxNQUFNUSxtQkFBbUJYLGdCQUFnQkcsbUJBQU9BLENBQUMsOEZBQWtCO0FBQ25FLE1BQU1TLGFBQWFULG1CQUFPQSxDQUFDLGdHQUFtQjtBQUM5QyxNQUFNVSwwQkFBMEJiLGdCQUFnQkcsbUJBQU9BLENBQUMsc0lBQXNDO0FBQzlGLE1BQU1XLG1CQUFtQmQsZ0JBQWdCRyxtQkFBT0EsQ0FBQyx3SEFBK0I7QUFDaEYsTUFBTVksaUJBQWlCWixtQkFBT0EsQ0FBQyx3R0FBdUI7QUFDdEQ7Ozs7Q0FJQyxHQUNELE1BQU1hLFVBQVUsU0FBU0EsUUFBUUMsS0FBSztJQUNsQyxNQUFNQyxrQkFBa0IsQ0FBQyxHQUFHTCx3QkFBd0JNLE9BQU87SUFDM0QsTUFBTUMsY0FBY3RELE9BQU91RCxNQUFNLENBQUN2RCxPQUFPdUQsTUFBTSxDQUFDLENBQUMsR0FBR0gsa0JBQWtCRDtJQUN0RSxNQUFNLEVBQUVLLFNBQVMsRUFBRUMsUUFBUSxFQUFFQyxXQUFXLEVBQUVDLGFBQWFDLGdCQUFnQixFQUFFQyxlQUFlQyxrQkFBa0IsRUFBRUMsR0FBRyxFQUFFLEdBQUdULGFBQWFVLGFBQWF4QyxPQUFPOEIsYUFBYTtRQUFDO1FBQWE7UUFBWTtRQUFlO1FBQWU7UUFBaUI7S0FBTTtJQUNoUCxJQUFHWixpQkFBaUJXLE9BQU8sRUFBRVUsS0FBSztJQUNuQyxNQUFNLENBQUNFLGNBQWNDLGdCQUFnQixHQUFHLENBQUMsR0FBR2xCLGlCQUFpQkssT0FBTztJQUNwRSxNQUFNLEVBQUVwQyxPQUFPa0QsT0FBTyxFQUFFQyxPQUFPQyxZQUFZLEVBQUUsR0FBR0o7SUFDaEQ7O0tBRUMsR0FDRCxTQUFTSjtRQUNMLElBQUksT0FBT00sWUFBWSxlQUFlQSxZQUFZLE9BQU87WUFDckQ7UUFDSjtRQUNBLElBQUlMLG9CQUFvQjtZQUNwQkEsbUJBQW1CSztRQUN2QjtJQUNKO0lBQ0E7O0tBRUMsR0FDRCxTQUFTUjtRQUNMLElBQUksQ0FBQ1UsY0FBYztZQUNmLCtDQUErQztZQUMvQztRQUNKO1FBQ0MsSUFBRzFCLFVBQVVVLE9BQU8sRUFBRSxPQUFPZ0IsYUFBYUMsUUFBUTtRQUNuRCxJQUFJVixrQkFBa0I7WUFDbEJBLGlCQUFpQlM7UUFDckI7SUFDSjtJQUNBLFNBQVNFO1FBQ0xMLGdCQUFnQjtZQUFFTSxNQUFNO1FBQVE7SUFDcEM7SUFDQyxJQUFHcEMsUUFBUXFDLFNBQVMsRUFBRUYsY0FBYztRQUFDTDtRQUFpQkg7S0FBSTtJQUMzRCxTQUFTVztRQUNMLElBQUksQ0FBQ1gsS0FBSztZQUNOLCtDQUErQztZQUMvQztRQUNKO1FBQ0EsTUFBTVksY0FBYyxDQUFDLEdBQUdwQywyQkFBMkJjLE9BQU8sRUFBRVUsSUFBSWEsVUFBVTtRQUMxRSxNQUFNQyxjQUFjRjtRQUNwQkEsWUFBWUcsT0FBTyxDQUNkQyxJQUFJLENBQUMsQ0FBQ0M7WUFDUGQsZ0JBQWdCO2dCQUFFTSxNQUFNO2dCQUFXdkQsT0FBTytEO1lBQVk7UUFDMUQsR0FDS0MsS0FBSyxDQUFDLENBQUNiO1lBQ1JGLGdCQUFnQjtnQkFBRU0sTUFBTTtnQkFBVUo7WUFBTTtRQUM1QztRQUNBLE9BQU8sSUFBTSxDQUFDLEdBQUd0QixXQUFXb0MsaUJBQWlCLEVBQUVMO0lBQ25EO0lBQ0MsSUFBR3pDLFFBQVFxQyxTQUFTLEVBQUVDLGFBQWE7UUFBQ1I7UUFBaUJIO0tBQUk7SUFDekQsSUFBRzNCLFFBQVFxQyxTQUFTLEVBQUU7UUFDbkIsSUFBSU4sWUFBWTdELFdBQVc7WUFDdkI7UUFDSjtRQUNBLElBQUk2RCxZQUFZLE9BQU87WUFDbkJSO1lBQ0E7UUFDSjtRQUNBRTtJQUNKLEdBQ0EsbUVBQW1FO0lBQ25FLHVEQUF1RDtJQUN2RDtRQUFDTTtLQUFRO0lBQ1QsTUFBTWdCLGVBQWUsQ0FBQyxHQUFHL0MsUUFBUWdELE9BQU8sRUFBRSxJQUFPO1lBQzdDMUI7UUFDSixJQUFJO1FBQUNBO0tBQVk7SUFDakIsTUFBTTJCLGFBQWEsQ0FBQyxHQUFHakQsUUFBUWdELE9BQU8sRUFBRSxJQUFNLENBQUMsR0FBRzVDLG1CQUFtQmEsT0FBTyxFQUFFVyxZQUFZLElBQU1HLFVBQVU7UUFBQ0g7UUFBWUc7S0FBUTtJQUMvSCxJQUFJLENBQUNBLFNBQVM7UUFDVixPQUFPO0lBQ1g7SUFDQSxTQUFTbUI7UUFDTCxJQUFJLENBQUNuQixTQUFTO1lBQ1YsT0FBTztRQUNYO1FBQ0EsT0FBUS9CLFFBQVFpQixPQUFPLENBQUNrQyxhQUFhLENBQUMsTUFBTSxNQUFNcEIsUUFBUXFCLEdBQUcsQ0FBQyxDQUFDQyxNQUFNQyxZQUFldEQsUUFBUWlCLE9BQU8sQ0FBQ2tDLGFBQWEsQ0FBQzFDLGlCQUFpQlEsT0FBTyxFQUFFO2dCQUFFc0MsS0FBSyxPQUFPRixLQUFLRyxJQUFJLEtBQUssV0FBV0gsS0FBS0csSUFBSSxHQUFHRjtnQkFBV0QsTUFBTUE7Z0JBQU0xQixLQUFLQTtZQUFJO0lBQ25PO0lBQ0EsT0FBUTNCLFFBQVFpQixPQUFPLENBQUNrQyxhQUFhLENBQUMsT0FBT3ZGLE9BQU91RCxNQUFNLENBQUM7UUFBRUMsV0FBVyxDQUFDLEdBQUdmLE9BQU9ZLE9BQU8sRUFBRSxzQkFBc0JHO1FBQVlxQyxLQUFLcEM7SUFBUyxHQUFHNEIsYUFDM0lqRCxRQUFRaUIsT0FBTyxDQUFDa0MsYUFBYSxDQUFDM0Msb0JBQW9CUyxPQUFPLENBQUN5QyxRQUFRLEVBQUU7UUFBRTdFLE9BQU9rRTtJQUFhLEdBQUdHO0FBQ3JHO0tBaEZNcEM7QUFpRk5BLFFBQVE2QyxTQUFTLEdBQUcvRixPQUFPdUQsTUFBTSxDQUFDdkQsT0FBT3VELE1BQU0sQ0FBQyxDQUFDLEdBQUdOLGVBQWVvQyxVQUFVLEdBQUc7SUFBRTdCLFdBQVdQLGVBQWUrQyxXQUFXO0lBQUV2QyxVQUFVUixlQUFlZ0QsS0FBSztJQUFFdkMsYUFBYXBCLGFBQWFlLE9BQU8sQ0FBQzZDLElBQUk7SUFBRXZDLGFBQWFyQixhQUFhZSxPQUFPLENBQUM2QyxJQUFJO0lBQUVyQyxlQUFldkIsYUFBYWUsT0FBTyxDQUFDNkMsSUFBSTtJQUFFbkMsS0FBS2QsZUFBZWtELEtBQUs7QUFBQztBQUM3U2hFLGtCQUFlLEdBQUdlIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFjdC1wZGYvZGlzdC9janMvT3V0bGluZS5qcz84MGVmIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuJ3VzZSBjbGllbnQnO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgX19yZXN0ID0gKHRoaXMgJiYgdGhpcy5fX3Jlc3QpIHx8IGZ1bmN0aW9uIChzLCBlKSB7XG4gICAgdmFyIHQgPSB7fTtcbiAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcbiAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMCAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocywgcFtpXSkpXG4gICAgICAgICAgICAgICAgdFtwW2ldXSA9IHNbcFtpXV07XG4gICAgICAgIH1cbiAgICByZXR1cm4gdDtcbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCByZWFjdF8xID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJyZWFjdFwiKSk7XG5jb25zdCBwcm9wX3R5cGVzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcInByb3AtdHlwZXNcIikpO1xuY29uc3QgbWFrZV9jYW5jZWxsYWJsZV9wcm9taXNlXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIm1ha2UtY2FuY2VsbGFibGUtcHJvbWlzZVwiKSk7XG5jb25zdCBtYWtlX2V2ZW50X3Byb3BzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIm1ha2UtZXZlbnQtcHJvcHNcIikpO1xuY29uc3QgY2xzeF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJjbHN4XCIpKTtcbmNvbnN0IHRpbnlfaW52YXJpYW50XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcInRpbnktaW52YXJpYW50XCIpKTtcbmNvbnN0IHdhcm5pbmdfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwid2FybmluZ1wiKSk7XG5jb25zdCBPdXRsaW5lQ29udGV4dF9qc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL091dGxpbmVDb250ZXh0LmpzXCIpKTtcbmNvbnN0IE91dGxpbmVJdGVtX2pzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vT3V0bGluZUl0ZW0uanNcIikpO1xuY29uc3QgdXRpbHNfanNfMSA9IHJlcXVpcmUoXCIuL3NoYXJlZC91dGlscy5qc1wiKTtcbmNvbnN0IHVzZURvY3VtZW50Q29udGV4dF9qc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL3NoYXJlZC9ob29rcy91c2VEb2N1bWVudENvbnRleHQuanNcIikpO1xuY29uc3QgdXNlUmVzb2x2ZXJfanNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9zaGFyZWQvaG9va3MvdXNlUmVzb2x2ZXIuanNcIikpO1xuY29uc3QgcHJvcFR5cGVzX2pzXzEgPSByZXF1aXJlKFwiLi9zaGFyZWQvcHJvcFR5cGVzLmpzXCIpO1xuLyoqXG4gKiBEaXNwbGF5cyBhbiBvdXRsaW5lICh0YWJsZSBvZiBjb250ZW50cykuXG4gKlxuICogU2hvdWxkIGJlIHBsYWNlZCBpbnNpZGUgYDxEb2N1bWVudCAvPmAuIEFsdGVybmF0aXZlbHksIGl0IGNhbiBoYXZlIGBwZGZgIHByb3AgcGFzc2VkLCB3aGljaCBjYW4gYmUgb2J0YWluZWQgZnJvbSBgPERvY3VtZW50IC8+YCdzIGBvbkxvYWRTdWNjZXNzYCBjYWxsYmFjayBmdW5jdGlvbi5cbiAqL1xuY29uc3QgT3V0bGluZSA9IGZ1bmN0aW9uIE91dGxpbmUocHJvcHMpIHtcbiAgICBjb25zdCBkb2N1bWVudENvbnRleHQgPSAoMCwgdXNlRG9jdW1lbnRDb250ZXh0X2pzXzEuZGVmYXVsdCkoKTtcbiAgICBjb25zdCBtZXJnZWRQcm9wcyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZG9jdW1lbnRDb250ZXh0KSwgcHJvcHMpO1xuICAgIGNvbnN0IHsgY2xhc3NOYW1lLCBpbnB1dFJlZiwgb25JdGVtQ2xpY2ssIG9uTG9hZEVycm9yOiBvbkxvYWRFcnJvclByb3BzLCBvbkxvYWRTdWNjZXNzOiBvbkxvYWRTdWNjZXNzUHJvcHMsIHBkZiB9ID0gbWVyZ2VkUHJvcHMsIG90aGVyUHJvcHMgPSBfX3Jlc3QobWVyZ2VkUHJvcHMsIFtcImNsYXNzTmFtZVwiLCBcImlucHV0UmVmXCIsIFwib25JdGVtQ2xpY2tcIiwgXCJvbkxvYWRFcnJvclwiLCBcIm9uTG9hZFN1Y2Nlc3NcIiwgXCJwZGZcIl0pO1xuICAgICgwLCB0aW55X2ludmFyaWFudF8xLmRlZmF1bHQpKHBkZiwgJ0F0dGVtcHRlZCB0byBsb2FkIGFuIG91dGxpbmUsIGJ1dCBubyBkb2N1bWVudCB3YXMgc3BlY2lmaWVkLiBXcmFwIDxPdXRsaW5lIC8+IGluIGEgPERvY3VtZW50IC8+IG9yIHBhc3MgZXhwbGljaXQgYHBkZmAgcHJvcC4nKTtcbiAgICBjb25zdCBbb3V0bGluZVN0YXRlLCBvdXRsaW5lRGlzcGF0Y2hdID0gKDAsIHVzZVJlc29sdmVyX2pzXzEuZGVmYXVsdCkoKTtcbiAgICBjb25zdCB7IHZhbHVlOiBvdXRsaW5lLCBlcnJvcjogb3V0bGluZUVycm9yIH0gPSBvdXRsaW5lU3RhdGU7XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW4gYW4gb3V0bGluZSBpcyByZWFkIHN1Y2Nlc3NmdWxseVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG9uTG9hZFN1Y2Nlc3MoKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb3V0bGluZSA9PT0gJ3VuZGVmaW5lZCcgfHwgb3V0bGluZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAob25Mb2FkU3VjY2Vzc1Byb3BzKSB7XG4gICAgICAgICAgICBvbkxvYWRTdWNjZXNzUHJvcHMob3V0bGluZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW4gYW4gb3V0bGluZSBmYWlsZWQgdG8gcmVhZCBzdWNjZXNzZnVsbHlcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvbkxvYWRFcnJvcigpIHtcbiAgICAgICAgaWYgKCFvdXRsaW5lRXJyb3IpIHtcbiAgICAgICAgICAgIC8vIEltcG9zc2libGUsIGJ1dCBUeXBlU2NyaXB0IGRvZXNuJ3Qga25vdyB0aGF0XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgKDAsIHdhcm5pbmdfMS5kZWZhdWx0KShmYWxzZSwgb3V0bGluZUVycm9yLnRvU3RyaW5nKCkpO1xuICAgICAgICBpZiAob25Mb2FkRXJyb3JQcm9wcykge1xuICAgICAgICAgICAgb25Mb2FkRXJyb3JQcm9wcyhvdXRsaW5lRXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlc2V0T3V0bGluZSgpIHtcbiAgICAgICAgb3V0bGluZURpc3BhdGNoKHsgdHlwZTogJ1JFU0VUJyB9KTtcbiAgICB9XG4gICAgKDAsIHJlYWN0XzEudXNlRWZmZWN0KShyZXNldE91dGxpbmUsIFtvdXRsaW5lRGlzcGF0Y2gsIHBkZl0pO1xuICAgIGZ1bmN0aW9uIGxvYWRPdXRsaW5lKCkge1xuICAgICAgICBpZiAoIXBkZikge1xuICAgICAgICAgICAgLy8gSW1wb3NzaWJsZSwgYnV0IFR5cGVTY3JpcHQgZG9lc24ndCBrbm93IHRoYXRcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjYW5jZWxsYWJsZSA9ICgwLCBtYWtlX2NhbmNlbGxhYmxlX3Byb21pc2VfMS5kZWZhdWx0KShwZGYuZ2V0T3V0bGluZSgpKTtcbiAgICAgICAgY29uc3QgcnVubmluZ1Rhc2sgPSBjYW5jZWxsYWJsZTtcbiAgICAgICAgY2FuY2VsbGFibGUucHJvbWlzZVxuICAgICAgICAgICAgLnRoZW4oKG5leHRPdXRsaW5lKSA9PiB7XG4gICAgICAgICAgICBvdXRsaW5lRGlzcGF0Y2goeyB0eXBlOiAnUkVTT0xWRScsIHZhbHVlOiBuZXh0T3V0bGluZSB9KTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgICAgIG91dGxpbmVEaXNwYXRjaCh7IHR5cGU6ICdSRUpFQ1QnLCBlcnJvciB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiAoKSA9PiAoMCwgdXRpbHNfanNfMS5jYW5jZWxSdW5uaW5nVGFzaykocnVubmluZ1Rhc2spO1xuICAgIH1cbiAgICAoMCwgcmVhY3RfMS51c2VFZmZlY3QpKGxvYWRPdXRsaW5lLCBbb3V0bGluZURpc3BhdGNoLCBwZGZdKTtcbiAgICAoMCwgcmVhY3RfMS51c2VFZmZlY3QpKCgpID0+IHtcbiAgICAgICAgaWYgKG91dGxpbmUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvdXRsaW5lID09PSBmYWxzZSkge1xuICAgICAgICAgICAgb25Mb2FkRXJyb3IoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBvbkxvYWRTdWNjZXNzKCk7XG4gICAgfSwgXG4gICAgLy8gT21taXR0ZWQgY2FsbGJhY2tzIHNvIHRoZXkgYXJlIG5vdCBjYWxsZWQgZXZlcnkgdGltZSB0aGV5IGNoYW5nZVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgICBbb3V0bGluZV0pO1xuICAgIGNvbnN0IGNoaWxkQ29udGV4dCA9ICgwLCByZWFjdF8xLnVzZU1lbW8pKCgpID0+ICh7XG4gICAgICAgIG9uSXRlbUNsaWNrLFxuICAgIH0pLCBbb25JdGVtQ2xpY2tdKTtcbiAgICBjb25zdCBldmVudFByb3BzID0gKDAsIHJlYWN0XzEudXNlTWVtbykoKCkgPT4gKDAsIG1ha2VfZXZlbnRfcHJvcHNfMS5kZWZhdWx0KShvdGhlclByb3BzLCAoKSA9PiBvdXRsaW5lKSwgW290aGVyUHJvcHMsIG91dGxpbmVdKTtcbiAgICBpZiAoIW91dGxpbmUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlbmRlck91dGxpbmUoKSB7XG4gICAgICAgIGlmICghb3V0bGluZSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChyZWFjdF8xLmRlZmF1bHQuY3JlYXRlRWxlbWVudChcInVsXCIsIG51bGwsIG91dGxpbmUubWFwKChpdGVtLCBpdGVtSW5kZXgpID0+IChyZWFjdF8xLmRlZmF1bHQuY3JlYXRlRWxlbWVudChPdXRsaW5lSXRlbV9qc18xLmRlZmF1bHQsIHsga2V5OiB0eXBlb2YgaXRlbS5kZXN0ID09PSAnc3RyaW5nJyA/IGl0ZW0uZGVzdCA6IGl0ZW1JbmRleCwgaXRlbTogaXRlbSwgcGRmOiBwZGYgfSkpKSkpO1xuICAgIH1cbiAgICByZXR1cm4gKHJlYWN0XzEuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIE9iamVjdC5hc3NpZ24oeyBjbGFzc05hbWU6ICgwLCBjbHN4XzEuZGVmYXVsdCkoJ3JlYWN0LXBkZl9fT3V0bGluZScsIGNsYXNzTmFtZSksIHJlZjogaW5wdXRSZWYgfSwgZXZlbnRQcm9wcyksXG4gICAgICAgIHJlYWN0XzEuZGVmYXVsdC5jcmVhdGVFbGVtZW50KE91dGxpbmVDb250ZXh0X2pzXzEuZGVmYXVsdC5Qcm92aWRlciwgeyB2YWx1ZTogY2hpbGRDb250ZXh0IH0sIHJlbmRlck91dGxpbmUoKSkpKTtcbn07XG5PdXRsaW5lLnByb3BUeXBlcyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcHJvcFR5cGVzX2pzXzEuZXZlbnRQcm9wcyksIHsgY2xhc3NOYW1lOiBwcm9wVHlwZXNfanNfMS5pc0NsYXNzTmFtZSwgaW5wdXRSZWY6IHByb3BUeXBlc19qc18xLmlzUmVmLCBvbkl0ZW1DbGljazogcHJvcF90eXBlc18xLmRlZmF1bHQuZnVuYywgb25Mb2FkRXJyb3I6IHByb3BfdHlwZXNfMS5kZWZhdWx0LmZ1bmMsIG9uTG9hZFN1Y2Nlc3M6IHByb3BfdHlwZXNfMS5kZWZhdWx0LmZ1bmMsIHBkZjogcHJvcFR5cGVzX2pzXzEuaXNQZGYgfSk7XG5leHBvcnRzLmRlZmF1bHQgPSBPdXRsaW5lO1xuIl0sIm5hbWVzIjpbIl9fY3JlYXRlQmluZGluZyIsIk9iamVjdCIsImNyZWF0ZSIsIm8iLCJtIiwiayIsImsyIiwidW5kZWZpbmVkIiwiZGVzYyIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsIl9fZXNNb2R1bGUiLCJ3cml0YWJsZSIsImNvbmZpZ3VyYWJsZSIsImVudW1lcmFibGUiLCJnZXQiLCJkZWZpbmVQcm9wZXJ0eSIsIl9fc2V0TW9kdWxlRGVmYXVsdCIsInYiLCJ2YWx1ZSIsIl9faW1wb3J0U3RhciIsIm1vZCIsInJlc3VsdCIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsIl9fcmVzdCIsInMiLCJlIiwidCIsInAiLCJpbmRleE9mIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwiaSIsImxlbmd0aCIsInByb3BlcnR5SXNFbnVtZXJhYmxlIiwiX19pbXBvcnREZWZhdWx0IiwiZXhwb3J0cyIsInJlYWN0XzEiLCJyZXF1aXJlIiwicHJvcF90eXBlc18xIiwibWFrZV9jYW5jZWxsYWJsZV9wcm9taXNlXzEiLCJtYWtlX2V2ZW50X3Byb3BzXzEiLCJjbHN4XzEiLCJ0aW55X2ludmFyaWFudF8xIiwid2FybmluZ18xIiwiT3V0bGluZUNvbnRleHRfanNfMSIsIk91dGxpbmVJdGVtX2pzXzEiLCJ1dGlsc19qc18xIiwidXNlRG9jdW1lbnRDb250ZXh0X2pzXzEiLCJ1c2VSZXNvbHZlcl9qc18xIiwicHJvcFR5cGVzX2pzXzEiLCJPdXRsaW5lIiwicHJvcHMiLCJkb2N1bWVudENvbnRleHQiLCJkZWZhdWx0IiwibWVyZ2VkUHJvcHMiLCJhc3NpZ24iLCJjbGFzc05hbWUiLCJpbnB1dFJlZiIsIm9uSXRlbUNsaWNrIiwib25Mb2FkRXJyb3IiLCJvbkxvYWRFcnJvclByb3BzIiwib25Mb2FkU3VjY2VzcyIsIm9uTG9hZFN1Y2Nlc3NQcm9wcyIsInBkZiIsIm90aGVyUHJvcHMiLCJvdXRsaW5lU3RhdGUiLCJvdXRsaW5lRGlzcGF0Y2giLCJvdXRsaW5lIiwiZXJyb3IiLCJvdXRsaW5lRXJyb3IiLCJ0b1N0cmluZyIsInJlc2V0T3V0bGluZSIsInR5cGUiLCJ1c2VFZmZlY3QiLCJsb2FkT3V0bGluZSIsImNhbmNlbGxhYmxlIiwiZ2V0T3V0bGluZSIsInJ1bm5pbmdUYXNrIiwicHJvbWlzZSIsInRoZW4iLCJuZXh0T3V0bGluZSIsImNhdGNoIiwiY2FuY2VsUnVubmluZ1Rhc2siLCJjaGlsZENvbnRleHQiLCJ1c2VNZW1vIiwiZXZlbnRQcm9wcyIsInJlbmRlck91dGxpbmUiLCJjcmVhdGVFbGVtZW50IiwibWFwIiwiaXRlbSIsIml0ZW1JbmRleCIsImtleSIsImRlc3QiLCJyZWYiLCJQcm92aWRlciIsInByb3BUeXBlcyIsImlzQ2xhc3NOYW1lIiwiaXNSZWYiLCJmdW5jIiwiaXNQZGYiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-pdf/dist/cjs/Outline.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-pdf/dist/cjs/OutlineContext.js":
/*!***********************************************************!*\
  !*** ./node_modules/react-pdf/dist/cjs/OutlineContext.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/* __next_internal_client_entry_do_not_use__  cjs */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nconst react_1 = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\nexports[\"default\"] = (0, react_1.createContext)(null);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1wZGYvZGlzdC9janMvT3V0bGluZUNvbnRleHQuanMiLCJtYXBwaW5ncyI6InFEQUFhO0FBRWJBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdELE1BQU1DLFVBQVVDLG1CQUFPQSxDQUFDLG1GQUFPO0FBQy9CSCxrQkFBZSxHQUFHLENBQUMsR0FBR0UsUUFBUUcsYUFBYSxFQUFFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFjdC1wZGYvZGlzdC9janMvT3V0bGluZUNvbnRleHQuanM/ZjU5NyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbid1c2UgY2xpZW50Jztcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHJlYWN0XzEgPSByZXF1aXJlKFwicmVhY3RcIik7XG5leHBvcnRzLmRlZmF1bHQgPSAoMCwgcmVhY3RfMS5jcmVhdGVDb250ZXh0KShudWxsKTtcbiJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsInJlYWN0XzEiLCJyZXF1aXJlIiwiZGVmYXVsdCIsImNyZWF0ZUNvbnRleHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-pdf/dist/cjs/OutlineContext.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-pdf/dist/cjs/OutlineItem.js":
/*!********************************************************!*\
  !*** ./node_modules/react-pdf/dist/cjs/OutlineItem.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst react_1 = __importDefault(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"));\nconst tiny_invariant_1 = __importDefault(__webpack_require__(/*! tiny-invariant */ \"(app-pages-browser)/./node_modules/tiny-invariant/dist/tiny-invariant.cjs.js\"));\nconst Ref_js_1 = __importDefault(__webpack_require__(/*! ./Ref.js */ \"(app-pages-browser)/./node_modules/react-pdf/dist/cjs/Ref.js\"));\nconst useCachedValue_js_1 = __importDefault(__webpack_require__(/*! ./shared/hooks/useCachedValue.js */ \"(app-pages-browser)/./node_modules/react-pdf/dist/cjs/shared/hooks/useCachedValue.js\"));\nconst useDocumentContext_js_1 = __importDefault(__webpack_require__(/*! ./shared/hooks/useDocumentContext.js */ \"(app-pages-browser)/./node_modules/react-pdf/dist/cjs/shared/hooks/useDocumentContext.js\"));\nconst useOutlineContext_js_1 = __importDefault(__webpack_require__(/*! ./shared/hooks/useOutlineContext.js */ \"(app-pages-browser)/./node_modules/react-pdf/dist/cjs/shared/hooks/useOutlineContext.js\"));\nfunction OutlineItem(props) {\n    const documentContext = (0, useDocumentContext_js_1.default)();\n    const outlineContext = (0, useOutlineContext_js_1.default)();\n    (0, tiny_invariant_1.default)(outlineContext, 'Unable to find Outline context.');\n    const mergedProps = Object.assign(Object.assign(Object.assign({}, documentContext), outlineContext), props);\n    const { item, linkService, onItemClick, pdf } = mergedProps, otherProps = __rest(mergedProps, [\"item\", \"linkService\", \"onItemClick\", \"pdf\"]);\n    (0, tiny_invariant_1.default)(pdf, 'Attempted to load an outline, but no document was specified. Wrap <Outline /> in a <Document /> or pass explicit `pdf` prop.');\n    const getDestination = (0, useCachedValue_js_1.default)(() => {\n        if (typeof item.dest === 'string') {\n            return pdf.getDestination(item.dest);\n        }\n        return item.dest;\n    });\n    const getPageIndex = (0, useCachedValue_js_1.default)(() => __awaiter(this, void 0, void 0, function* () {\n        const destination = yield getDestination();\n        if (!destination) {\n            throw new Error('Destination not found.');\n        }\n        const [ref] = destination;\n        return pdf.getPageIndex(new Ref_js_1.default(ref));\n    }));\n    const getPageNumber = (0, useCachedValue_js_1.default)(() => __awaiter(this, void 0, void 0, function* () {\n        const pageIndex = yield getPageIndex();\n        return pageIndex + 1;\n    }));\n    function onClick(event) {\n        event.preventDefault();\n        (0, tiny_invariant_1.default)(onItemClick || linkService, 'Either onItemClick callback or linkService must be defined in order to navigate to an outline item.');\n        if (onItemClick) {\n            Promise.all([getDestination(), getPageIndex(), getPageNumber()]).then(([dest, pageIndex, pageNumber]) => {\n                onItemClick({\n                    dest,\n                    pageIndex,\n                    pageNumber,\n                });\n            });\n        }\n        else if (linkService) {\n            linkService.goToDestination(item.dest);\n        }\n    }\n    function renderSubitems() {\n        if (!item.items || !item.items.length) {\n            return null;\n        }\n        const { items: subitems } = item;\n        return (react_1.default.createElement(\"ul\", null, subitems.map((subitem, subitemIndex) => (react_1.default.createElement(OutlineItem, Object.assign({ key: typeof subitem.dest === 'string' ? subitem.dest : subitemIndex, item: subitem, pdf: pdf }, otherProps))))));\n    }\n    return (react_1.default.createElement(\"li\", null,\n        react_1.default.createElement(\"a\", { href: \"#\", onClick: onClick }, item.title),\n        renderSubitems()));\n}\nexports[\"default\"] = OutlineItem;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1wZGYvZGlzdC9janMvT3V0bGluZUl0ZW0uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLDRCQUE0QiwrREFBK0QsaUJBQWlCO0FBQzVHO0FBQ0Esb0NBQW9DLE1BQU0sK0JBQStCLFlBQVk7QUFDckYsbUNBQW1DLE1BQU0sbUNBQW1DLFlBQVk7QUFDeEYsZ0NBQWdDO0FBQ2hDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxjQUFjO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxnQ0FBZ0MsbUJBQU8sQ0FBQyxtRkFBTztBQUMvQyx5Q0FBeUMsbUJBQU8sQ0FBQyxvR0FBZ0I7QUFDakUsaUNBQWlDLG1CQUFPLENBQUMsOEVBQVU7QUFDbkQsNENBQTRDLG1CQUFPLENBQUMsOEhBQWtDO0FBQ3RGLGdEQUFnRCxtQkFBTyxDQUFDLHNJQUFzQztBQUM5RiwrQ0FBK0MsbUJBQU8sQ0FBQyxvSUFBcUM7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0U7QUFDcEUsWUFBWSxzQ0FBc0M7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixrQkFBa0I7QUFDbEMsOEpBQThKLDhGQUE4RjtBQUM1UDtBQUNBO0FBQ0EsNkNBQTZDLDZCQUE2QjtBQUMxRTtBQUNBO0FBQ0Esa0JBQWUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXBkZi9kaXN0L2Nqcy9PdXRsaW5lSXRlbS5qcz9kYzBlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19yZXN0ID0gKHRoaXMgJiYgdGhpcy5fX3Jlc3QpIHx8IGZ1bmN0aW9uIChzLCBlKSB7XG4gICAgdmFyIHQgPSB7fTtcbiAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcbiAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMCAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocywgcFtpXSkpXG4gICAgICAgICAgICAgICAgdFtwW2ldXSA9IHNbcFtpXV07XG4gICAgICAgIH1cbiAgICByZXR1cm4gdDtcbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCByZWFjdF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJyZWFjdFwiKSk7XG5jb25zdCB0aW55X2ludmFyaWFudF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJ0aW55LWludmFyaWFudFwiKSk7XG5jb25zdCBSZWZfanNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9SZWYuanNcIikpO1xuY29uc3QgdXNlQ2FjaGVkVmFsdWVfanNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9zaGFyZWQvaG9va3MvdXNlQ2FjaGVkVmFsdWUuanNcIikpO1xuY29uc3QgdXNlRG9jdW1lbnRDb250ZXh0X2pzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vc2hhcmVkL2hvb2tzL3VzZURvY3VtZW50Q29udGV4dC5qc1wiKSk7XG5jb25zdCB1c2VPdXRsaW5lQ29udGV4dF9qc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL3NoYXJlZC9ob29rcy91c2VPdXRsaW5lQ29udGV4dC5qc1wiKSk7XG5mdW5jdGlvbiBPdXRsaW5lSXRlbShwcm9wcykge1xuICAgIGNvbnN0IGRvY3VtZW50Q29udGV4dCA9ICgwLCB1c2VEb2N1bWVudENvbnRleHRfanNfMS5kZWZhdWx0KSgpO1xuICAgIGNvbnN0IG91dGxpbmVDb250ZXh0ID0gKDAsIHVzZU91dGxpbmVDb250ZXh0X2pzXzEuZGVmYXVsdCkoKTtcbiAgICAoMCwgdGlueV9pbnZhcmlhbnRfMS5kZWZhdWx0KShvdXRsaW5lQ29udGV4dCwgJ1VuYWJsZSB0byBmaW5kIE91dGxpbmUgY29udGV4dC4nKTtcbiAgICBjb25zdCBtZXJnZWRQcm9wcyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBkb2N1bWVudENvbnRleHQpLCBvdXRsaW5lQ29udGV4dCksIHByb3BzKTtcbiAgICBjb25zdCB7IGl0ZW0sIGxpbmtTZXJ2aWNlLCBvbkl0ZW1DbGljaywgcGRmIH0gPSBtZXJnZWRQcm9wcywgb3RoZXJQcm9wcyA9IF9fcmVzdChtZXJnZWRQcm9wcywgW1wiaXRlbVwiLCBcImxpbmtTZXJ2aWNlXCIsIFwib25JdGVtQ2xpY2tcIiwgXCJwZGZcIl0pO1xuICAgICgwLCB0aW55X2ludmFyaWFudF8xLmRlZmF1bHQpKHBkZiwgJ0F0dGVtcHRlZCB0byBsb2FkIGFuIG91dGxpbmUsIGJ1dCBubyBkb2N1bWVudCB3YXMgc3BlY2lmaWVkLiBXcmFwIDxPdXRsaW5lIC8+IGluIGEgPERvY3VtZW50IC8+IG9yIHBhc3MgZXhwbGljaXQgYHBkZmAgcHJvcC4nKTtcbiAgICBjb25zdCBnZXREZXN0aW5hdGlvbiA9ICgwLCB1c2VDYWNoZWRWYWx1ZV9qc18xLmRlZmF1bHQpKCgpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiBpdGVtLmRlc3QgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gcGRmLmdldERlc3RpbmF0aW9uKGl0ZW0uZGVzdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGl0ZW0uZGVzdDtcbiAgICB9KTtcbiAgICBjb25zdCBnZXRQYWdlSW5kZXggPSAoMCwgdXNlQ2FjaGVkVmFsdWVfanNfMS5kZWZhdWx0KSgoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIGNvbnN0IGRlc3RpbmF0aW9uID0geWllbGQgZ2V0RGVzdGluYXRpb24oKTtcbiAgICAgICAgaWYgKCFkZXN0aW5hdGlvbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEZXN0aW5hdGlvbiBub3QgZm91bmQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgW3JlZl0gPSBkZXN0aW5hdGlvbjtcbiAgICAgICAgcmV0dXJuIHBkZi5nZXRQYWdlSW5kZXgobmV3IFJlZl9qc18xLmRlZmF1bHQocmVmKSk7XG4gICAgfSkpO1xuICAgIGNvbnN0IGdldFBhZ2VOdW1iZXIgPSAoMCwgdXNlQ2FjaGVkVmFsdWVfanNfMS5kZWZhdWx0KSgoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIGNvbnN0IHBhZ2VJbmRleCA9IHlpZWxkIGdldFBhZ2VJbmRleCgpO1xuICAgICAgICByZXR1cm4gcGFnZUluZGV4ICsgMTtcbiAgICB9KSk7XG4gICAgZnVuY3Rpb24gb25DbGljayhldmVudCkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAoMCwgdGlueV9pbnZhcmlhbnRfMS5kZWZhdWx0KShvbkl0ZW1DbGljayB8fCBsaW5rU2VydmljZSwgJ0VpdGhlciBvbkl0ZW1DbGljayBjYWxsYmFjayBvciBsaW5rU2VydmljZSBtdXN0IGJlIGRlZmluZWQgaW4gb3JkZXIgdG8gbmF2aWdhdGUgdG8gYW4gb3V0bGluZSBpdGVtLicpO1xuICAgICAgICBpZiAob25JdGVtQ2xpY2spIHtcbiAgICAgICAgICAgIFByb21pc2UuYWxsKFtnZXREZXN0aW5hdGlvbigpLCBnZXRQYWdlSW5kZXgoKSwgZ2V0UGFnZU51bWJlcigpXSkudGhlbigoW2Rlc3QsIHBhZ2VJbmRleCwgcGFnZU51bWJlcl0pID0+IHtcbiAgICAgICAgICAgICAgICBvbkl0ZW1DbGljayh7XG4gICAgICAgICAgICAgICAgICAgIGRlc3QsXG4gICAgICAgICAgICAgICAgICAgIHBhZ2VJbmRleCxcbiAgICAgICAgICAgICAgICAgICAgcGFnZU51bWJlcixcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGxpbmtTZXJ2aWNlKSB7XG4gICAgICAgICAgICBsaW5rU2VydmljZS5nb1RvRGVzdGluYXRpb24oaXRlbS5kZXN0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiByZW5kZXJTdWJpdGVtcygpIHtcbiAgICAgICAgaWYgKCFpdGVtLml0ZW1zIHx8ICFpdGVtLml0ZW1zLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBpdGVtczogc3ViaXRlbXMgfSA9IGl0ZW07XG4gICAgICAgIHJldHVybiAocmVhY3RfMS5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJ1bFwiLCBudWxsLCBzdWJpdGVtcy5tYXAoKHN1Yml0ZW0sIHN1Yml0ZW1JbmRleCkgPT4gKHJlYWN0XzEuZGVmYXVsdC5jcmVhdGVFbGVtZW50KE91dGxpbmVJdGVtLCBPYmplY3QuYXNzaWduKHsga2V5OiB0eXBlb2Ygc3ViaXRlbS5kZXN0ID09PSAnc3RyaW5nJyA/IHN1Yml0ZW0uZGVzdCA6IHN1Yml0ZW1JbmRleCwgaXRlbTogc3ViaXRlbSwgcGRmOiBwZGYgfSwgb3RoZXJQcm9wcykpKSkpKTtcbiAgICB9XG4gICAgcmV0dXJuIChyZWFjdF8xLmRlZmF1bHQuY3JlYXRlRWxlbWVudChcImxpXCIsIG51bGwsXG4gICAgICAgIHJlYWN0XzEuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiYVwiLCB7IGhyZWY6IFwiI1wiLCBvbkNsaWNrOiBvbkNsaWNrIH0sIGl0ZW0udGl0bGUpLFxuICAgICAgICByZW5kZXJTdWJpdGVtcygpKSk7XG59XG5leHBvcnRzLmRlZmF1bHQgPSBPdXRsaW5lSXRlbTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-pdf/dist/cjs/OutlineItem.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-pdf/dist/cjs/Page.js":
/*!*************************************************!*\
  !*** ./node_modules/react-pdf/dist/cjs/Page.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/* __next_internal_client_entry_do_not_use__  cjs */ \nvar __createBinding = (void 0) && (void 0).__createBinding || (Object.create ? function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n        desc = {\n            enumerable: true,\n            get: function() {\n                return m[k];\n            }\n        };\n    }\n    Object.defineProperty(o, k2, desc);\n} : function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n});\nvar __setModuleDefault = (void 0) && (void 0).__setModuleDefault || (Object.create ? function(o, v) {\n    Object.defineProperty(o, \"default\", {\n        enumerable: true,\n        value: v\n    });\n} : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (void 0) && (void 0).__importStar || function(mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) {\n        for(var k in mod)if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    }\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __rest = (void 0) && (void 0).__rest || function(s, e) {\n    var t = {};\n    for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++){\n        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n    }\n    return t;\n};\nvar __importDefault = (void 0) && (void 0).__importDefault || function(mod) {\n    return mod && mod.__esModule ? mod : {\n        \"default\": mod\n    };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nconst react_1 = __importStar(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"));\nconst prop_types_1 = __importDefault(__webpack_require__(/*! prop-types */ \"(app-pages-browser)/./node_modules/prop-types/index.js\"));\nconst make_cancellable_promise_1 = __importDefault(__webpack_require__(/*! make-cancellable-promise */ \"(app-pages-browser)/./node_modules/make-cancellable-promise/dist/cjs/index.js\"));\nconst make_event_props_1 = __importDefault(__webpack_require__(/*! make-event-props */ \"(app-pages-browser)/./node_modules/make-event-props/dist/cjs/index.js\"));\nconst clsx_1 = __importDefault(__webpack_require__(/*! clsx */ \"(app-pages-browser)/./node_modules/clsx/dist/clsx.js\"));\nconst merge_refs_1 = __importDefault(__webpack_require__(/*! merge-refs */ \"(app-pages-browser)/./node_modules/merge-refs/dist/cjs/index.js\"));\nconst tiny_invariant_1 = __importDefault(__webpack_require__(/*! tiny-invariant */ \"(app-pages-browser)/./node_modules/tiny-invariant/dist/tiny-invariant.cjs.js\"));\nconst warning_1 = __importDefault(__webpack_require__(/*! warning */ \"(app-pages-browser)/./node_modules/warning/warning.js\"));\nconst PageContext_js_1 = __importDefault(__webpack_require__(/*! ./PageContext.js */ \"(app-pages-browser)/./node_modules/react-pdf/dist/cjs/PageContext.js\"));\nconst Message_js_1 = __importDefault(__webpack_require__(/*! ./Message.js */ \"(app-pages-browser)/./node_modules/react-pdf/dist/cjs/Message.js\"));\nconst PageCanvas_js_1 = __importDefault(__webpack_require__(/*! ./Page/PageCanvas.js */ \"(app-pages-browser)/./node_modules/react-pdf/dist/cjs/Page/PageCanvas.js\"));\nconst PageSVG_js_1 = __importDefault(__webpack_require__(/*! ./Page/PageSVG.js */ \"(app-pages-browser)/./node_modules/react-pdf/dist/cjs/Page/PageSVG.js\"));\nconst TextLayer_js_1 = __importDefault(__webpack_require__(/*! ./Page/TextLayer.js */ \"(app-pages-browser)/./node_modules/react-pdf/dist/cjs/Page/TextLayer.js\"));\nconst AnnotationLayer_js_1 = __importDefault(__webpack_require__(/*! ./Page/AnnotationLayer.js */ \"(app-pages-browser)/./node_modules/react-pdf/dist/cjs/Page/AnnotationLayer.js\"));\nconst utils_js_1 = __webpack_require__(/*! ./shared/utils.js */ \"(app-pages-browser)/./node_modules/react-pdf/dist/cjs/shared/utils.js\");\nconst useDocumentContext_js_1 = __importDefault(__webpack_require__(/*! ./shared/hooks/useDocumentContext.js */ \"(app-pages-browser)/./node_modules/react-pdf/dist/cjs/shared/hooks/useDocumentContext.js\"));\nconst useResolver_js_1 = __importDefault(__webpack_require__(/*! ./shared/hooks/useResolver.js */ \"(app-pages-browser)/./node_modules/react-pdf/dist/cjs/shared/hooks/useResolver.js\"));\nconst propTypes_js_1 = __webpack_require__(/*! ./shared/propTypes.js */ \"(app-pages-browser)/./node_modules/react-pdf/dist/cjs/shared/propTypes.js\");\nconst defaultScale = 1;\n/**\n * Displays a page.\n *\n * Should be placed inside `<Document />`. Alternatively, it can have `pdf` prop passed, which can be obtained from `<Document />`'s `onLoadSuccess` callback function, however some advanced functions like linking between pages inside a document may not be working correctly.\n */ const Page = function Page(props) {\n    const documentContext = (0, useDocumentContext_js_1.default)();\n    const mergedProps = Object.assign(Object.assign({}, documentContext), props);\n    const { _className = \"react-pdf__Page\", _enableRegisterUnregisterPage = true, canvasBackground, canvasRef, children, className, customRenderer: CustomRenderer, customTextRenderer, devicePixelRatio, error = \"Failed to load the page.\", height, inputRef, loading = \"Loading page\", noData = \"No page specified.\", onGetAnnotationsError: onGetAnnotationsErrorProps, onGetAnnotationsSuccess: onGetAnnotationsSuccessProps, onGetStructTreeError: onGetStructTreeErrorProps, onGetStructTreeSuccess: onGetStructTreeSuccessProps, onGetTextError: onGetTextErrorProps, onGetTextSuccess: onGetTextSuccessProps, onLoadError: onLoadErrorProps, onLoadSuccess: onLoadSuccessProps, onRenderAnnotationLayerError: onRenderAnnotationLayerErrorProps, onRenderAnnotationLayerSuccess: onRenderAnnotationLayerSuccessProps, onRenderError: onRenderErrorProps, onRenderSuccess: onRenderSuccessProps, onRenderTextLayerError: onRenderTextLayerErrorProps, onRenderTextLayerSuccess: onRenderTextLayerSuccessProps, pageIndex: pageIndexProps, pageNumber: pageNumberProps, pdf, registerPage, renderAnnotationLayer: renderAnnotationLayerProps = true, renderForms = false, renderMode = \"canvas\", renderTextLayer: renderTextLayerProps = true, rotate: rotateProps, scale: scaleProps = defaultScale, unregisterPage, width } = mergedProps, otherProps = __rest(mergedProps, [\n        \"_className\",\n        \"_enableRegisterUnregisterPage\",\n        \"canvasBackground\",\n        \"canvasRef\",\n        \"children\",\n        \"className\",\n        \"customRenderer\",\n        \"customTextRenderer\",\n        \"devicePixelRatio\",\n        \"error\",\n        \"height\",\n        \"inputRef\",\n        \"loading\",\n        \"noData\",\n        \"onGetAnnotationsError\",\n        \"onGetAnnotationsSuccess\",\n        \"onGetStructTreeError\",\n        \"onGetStructTreeSuccess\",\n        \"onGetTextError\",\n        \"onGetTextSuccess\",\n        \"onLoadError\",\n        \"onLoadSuccess\",\n        \"onRenderAnnotationLayerError\",\n        \"onRenderAnnotationLayerSuccess\",\n        \"onRenderError\",\n        \"onRenderSuccess\",\n        \"onRenderTextLayerError\",\n        \"onRenderTextLayerSuccess\",\n        \"pageIndex\",\n        \"pageNumber\",\n        \"pdf\",\n        \"registerPage\",\n        \"renderAnnotationLayer\",\n        \"renderForms\",\n        \"renderMode\",\n        \"renderTextLayer\",\n        \"rotate\",\n        \"scale\",\n        \"unregisterPage\",\n        \"width\"\n    ]);\n    const [pageState, pageDispatch] = (0, useResolver_js_1.default)();\n    const { value: page, error: pageError } = pageState;\n    const pageElement = (0, react_1.useRef)(null);\n    (0, tiny_invariant_1.default)(pdf, \"Attempted to load a page, but no document was specified. Wrap <Page /> in a <Document /> or pass explicit `pdf` prop.\");\n    const pageIndex = (0, utils_js_1.isProvided)(pageNumberProps) ? pageNumberProps - 1 : pageIndexProps !== null && pageIndexProps !== void 0 ? pageIndexProps : null;\n    const pageNumber = pageNumberProps !== null && pageNumberProps !== void 0 ? pageNumberProps : (0, utils_js_1.isProvided)(pageIndexProps) ? pageIndexProps + 1 : null;\n    const rotate = rotateProps !== null && rotateProps !== void 0 ? rotateProps : page ? page.rotate : null;\n    const scale = (0, react_1.useMemo)(()=>{\n        if (!page) {\n            return null;\n        }\n        // Be default, we'll render page at 100% * scale width.\n        let pageScale = 1;\n        // Passing scale explicitly null would cause the page not to render\n        const scaleWithDefault = scaleProps !== null && scaleProps !== void 0 ? scaleProps : defaultScale;\n        // If width/height is defined, calculate the scale of the page so it could be of desired width.\n        if (width || height) {\n            const viewport = page.getViewport({\n                scale: 1,\n                rotation: rotate\n            });\n            if (width) {\n                pageScale = width / viewport.width;\n            } else if (height) {\n                pageScale = height / viewport.height;\n            }\n        }\n        return scaleWithDefault * pageScale;\n    }, [\n        height,\n        page,\n        rotate,\n        scaleProps,\n        width\n    ]);\n    function hook() {\n        return ()=>{\n            if (!(0, utils_js_1.isProvided)(pageIndex)) {\n                // Impossible, but TypeScript doesn't know that\n                return;\n            }\n            if (_enableRegisterUnregisterPage && unregisterPage) {\n                unregisterPage(pageIndex);\n            }\n        };\n    }\n    (0, react_1.useEffect)(hook, [\n        _enableRegisterUnregisterPage,\n        pdf,\n        pageIndex,\n        unregisterPage\n    ]);\n    /**\n     * Called when a page is loaded successfully\n     */ function onLoadSuccess() {\n        if (onLoadSuccessProps) {\n            if (!page || !scale) {\n                // Impossible, but TypeScript doesn't know that\n                return;\n            }\n            onLoadSuccessProps((0, utils_js_1.makePageCallback)(page, scale));\n        }\n        if (_enableRegisterUnregisterPage && registerPage) {\n            if (!(0, utils_js_1.isProvided)(pageIndex) || !pageElement.current) {\n                // Impossible, but TypeScript doesn't know that\n                return;\n            }\n            registerPage(pageIndex, pageElement.current);\n        }\n    }\n    /**\n     * Called when a page failed to load\n     */ function onLoadError() {\n        if (!pageError) {\n            // Impossible, but TypeScript doesn't know that\n            return;\n        }\n        (0, warning_1.default)(false, pageError.toString());\n        if (onLoadErrorProps) {\n            onLoadErrorProps(pageError);\n        }\n    }\n    function resetPage() {\n        pageDispatch({\n            type: \"RESET\"\n        });\n    }\n    (0, react_1.useEffect)(resetPage, [\n        pageDispatch,\n        pdf,\n        pageIndex\n    ]);\n    function loadPage() {\n        if (!pdf || !pageNumber) {\n            return;\n        }\n        const cancellable = (0, make_cancellable_promise_1.default)(pdf.getPage(pageNumber));\n        const runningTask = cancellable;\n        cancellable.promise.then((nextPage)=>{\n            pageDispatch({\n                type: \"RESOLVE\",\n                value: nextPage\n            });\n        }).catch((error)=>{\n            pageDispatch({\n                type: \"REJECT\",\n                error\n            });\n        });\n        return ()=>(0, utils_js_1.cancelRunningTask)(runningTask);\n    }\n    (0, react_1.useEffect)(loadPage, [\n        pageDispatch,\n        pdf,\n        pageIndex,\n        pageNumber,\n        registerPage\n    ]);\n    (0, react_1.useEffect)(()=>{\n        if (page === undefined) {\n            return;\n        }\n        if (page === false) {\n            onLoadError();\n            return;\n        }\n        onLoadSuccess();\n    }, // Ommitted callbacks so they are not called every time they change\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [\n        page,\n        scale\n    ]);\n    const childContext = (0, react_1.useMemo)(()=>// Technically there cannot be page without pageIndex, pageNumber, rotate and scale, but TypeScript doesn't know that\n        page && (0, utils_js_1.isProvided)(pageIndex) && pageNumber && (0, utils_js_1.isProvided)(rotate) && (0, utils_js_1.isProvided)(scale) ? {\n            _className,\n            canvasBackground,\n            customTextRenderer,\n            devicePixelRatio,\n            onGetAnnotationsError: onGetAnnotationsErrorProps,\n            onGetAnnotationsSuccess: onGetAnnotationsSuccessProps,\n            onGetStructTreeError: onGetStructTreeErrorProps,\n            onGetStructTreeSuccess: onGetStructTreeSuccessProps,\n            onGetTextError: onGetTextErrorProps,\n            onGetTextSuccess: onGetTextSuccessProps,\n            onRenderAnnotationLayerError: onRenderAnnotationLayerErrorProps,\n            onRenderAnnotationLayerSuccess: onRenderAnnotationLayerSuccessProps,\n            onRenderError: onRenderErrorProps,\n            onRenderSuccess: onRenderSuccessProps,\n            onRenderTextLayerError: onRenderTextLayerErrorProps,\n            onRenderTextLayerSuccess: onRenderTextLayerSuccessProps,\n            page,\n            pageIndex,\n            pageNumber,\n            renderForms,\n            renderTextLayer: renderTextLayerProps,\n            rotate,\n            scale\n        } : null, [\n        _className,\n        canvasBackground,\n        customTextRenderer,\n        devicePixelRatio,\n        onGetAnnotationsErrorProps,\n        onGetAnnotationsSuccessProps,\n        onGetStructTreeErrorProps,\n        onGetStructTreeSuccessProps,\n        onGetTextErrorProps,\n        onGetTextSuccessProps,\n        onRenderAnnotationLayerErrorProps,\n        onRenderAnnotationLayerSuccessProps,\n        onRenderErrorProps,\n        onRenderSuccessProps,\n        onRenderTextLayerErrorProps,\n        onRenderTextLayerSuccessProps,\n        page,\n        pageIndex,\n        pageNumber,\n        renderForms,\n        renderTextLayerProps,\n        rotate,\n        scale\n    ]);\n    const eventProps = (0, react_1.useMemo)(()=>(0, make_event_props_1.default)(otherProps, ()=>page ? scale ? (0, utils_js_1.makePageCallback)(page, scale) : undefined : page), [\n        otherProps,\n        page,\n        scale\n    ]);\n    const pageKey = \"\".concat(pageIndex, \"@\").concat(scale, \"/\").concat(rotate);\n    const pageKeyNoScale = \"\".concat(pageIndex, \"/\").concat(rotate);\n    function renderMainLayer() {\n        switch(renderMode){\n            case \"custom\":\n                {\n                    (0, tiny_invariant_1.default)(CustomRenderer, 'renderMode was set to \"custom\", but no customRenderer was passed.');\n                    return react_1.default.createElement(CustomRenderer, {\n                        key: \"\".concat(pageKey, \"_custom\")\n                    });\n                }\n            case \"none\":\n                return null;\n            case \"svg\":\n                return react_1.default.createElement(PageSVG_js_1.default, {\n                    key: \"\".concat(pageKeyNoScale, \"_svg\")\n                });\n            case \"canvas\":\n            default:\n                return react_1.default.createElement(PageCanvas_js_1.default, {\n                    key: \"\".concat(pageKey, \"_canvas\"),\n                    canvasRef: canvasRef\n                });\n        }\n    }\n    function renderTextLayer() {\n        if (!renderTextLayerProps) {\n            return null;\n        }\n        return react_1.default.createElement(TextLayer_js_1.default, {\n            key: \"\".concat(pageKey, \"_text\")\n        });\n    }\n    function renderAnnotationLayer() {\n        if (!renderAnnotationLayerProps) {\n            return null;\n        }\n        /**\n         * As of now, PDF.js 2.0.943 returns warnings on unimplemented annotations in SVG mode.\n         * Therefore, as a fallback, we render \"traditional\" AnnotationLayer component.\n         */ return react_1.default.createElement(AnnotationLayer_js_1.default, {\n            key: \"\".concat(pageKey, \"_annotations\")\n        });\n    }\n    function renderChildren() {\n        return react_1.default.createElement(PageContext_js_1.default.Provider, {\n            value: childContext\n        }, renderMainLayer(), renderTextLayer(), renderAnnotationLayer(), children);\n    }\n    function renderContent() {\n        if (!pageNumber) {\n            return react_1.default.createElement(Message_js_1.default, {\n                type: \"no-data\"\n            }, typeof noData === \"function\" ? noData() : noData);\n        }\n        if (pdf === null || page === undefined || page === null) {\n            return react_1.default.createElement(Message_js_1.default, {\n                type: \"loading\"\n            }, typeof loading === \"function\" ? loading() : loading);\n        }\n        if (pdf === false || page === false) {\n            return react_1.default.createElement(Message_js_1.default, {\n                type: \"error\"\n            }, typeof error === \"function\" ? error() : error);\n        }\n        return renderChildren();\n    }\n    return react_1.default.createElement(\"div\", Object.assign({\n        className: (0, clsx_1.default)(_className, className),\n        \"data-page-number\": pageNumber,\n        ref: (0, merge_refs_1.default)(inputRef, pageElement),\n        style: {\n            [\"--scale-factor\"]: \"\".concat(scale),\n            backgroundColor: canvasBackground || \"white\",\n            position: \"relative\",\n            minWidth: \"min-content\",\n            minHeight: \"min-content\"\n        }\n    }, eventProps), renderContent());\n};\n_c = Page;\nconst isFunctionOrNode = prop_types_1.default.oneOfType([\n    prop_types_1.default.func,\n    prop_types_1.default.node\n]);\nPage.propTypes = Object.assign(Object.assign({}, propTypes_js_1.eventProps), {\n    canvasBackground: prop_types_1.default.string,\n    canvasRef: propTypes_js_1.isRef,\n    children: prop_types_1.default.node,\n    className: propTypes_js_1.isClassName,\n    customRenderer: prop_types_1.default.func,\n    customTextRenderer: prop_types_1.default.func,\n    devicePixelRatio: prop_types_1.default.number,\n    error: isFunctionOrNode,\n    height: prop_types_1.default.number,\n    imageResourcesPath: prop_types_1.default.string,\n    inputRef: propTypes_js_1.isRef,\n    loading: isFunctionOrNode,\n    noData: isFunctionOrNode,\n    onGetTextError: prop_types_1.default.func,\n    onGetTextSuccess: prop_types_1.default.func,\n    onLoadError: prop_types_1.default.func,\n    onLoadSuccess: prop_types_1.default.func,\n    onRenderError: prop_types_1.default.func,\n    onRenderSuccess: prop_types_1.default.func,\n    onRenderTextLayerError: prop_types_1.default.func,\n    onRenderTextLayerSuccess: prop_types_1.default.func,\n    pageIndex: propTypes_js_1.isPageIndex,\n    pageNumber: propTypes_js_1.isPageNumber,\n    pdf: propTypes_js_1.isPdf,\n    renderAnnotationLayer: prop_types_1.default.bool,\n    renderForms: prop_types_1.default.bool,\n    renderMode: propTypes_js_1.isRenderMode,\n    renderTextLayer: prop_types_1.default.bool,\n    rotate: propTypes_js_1.isRotate,\n    scale: prop_types_1.default.number,\n    width: prop_types_1.default.number\n});\nexports[\"default\"] = Page;\nvar _c;\n$RefreshReg$(_c, \"Page\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1wZGYvZGlzdC9janMvUGFnZS5qcyIsIm1hcHBpbmdzIjoicURBQWE7QUFFYixJQUFJQSxrQkFBa0IsQ0FBQyxNQUFHLEtBQUssT0FBRyxFQUFFQSxlQUFlLElBQU1DLENBQUFBLE9BQU9DLE1BQU0sR0FBSSxTQUFTQyxDQUFDLEVBQUVDLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxFQUFFO0lBQzFGLElBQUlBLE9BQU9DLFdBQVdELEtBQUtEO0lBQzNCLElBQUlHLE9BQU9QLE9BQU9RLHdCQUF3QixDQUFDTCxHQUFHQztJQUM5QyxJQUFJLENBQUNHLFFBQVMsVUFBU0EsT0FBTyxDQUFDSixFQUFFTSxVQUFVLEdBQUdGLEtBQUtHLFFBQVEsSUFBSUgsS0FBS0ksWUFBWSxHQUFHO1FBQ2pGSixPQUFPO1lBQUVLLFlBQVk7WUFBTUMsS0FBSztnQkFBYSxPQUFPVixDQUFDLENBQUNDLEVBQUU7WUFBRTtRQUFFO0lBQzlEO0lBQ0FKLE9BQU9jLGNBQWMsQ0FBQ1osR0FBR0csSUFBSUU7QUFDakMsSUFBTSxTQUFTTCxDQUFDLEVBQUVDLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxFQUFFO0lBQ3RCLElBQUlBLE9BQU9DLFdBQVdELEtBQUtEO0lBQzNCRixDQUFDLENBQUNHLEdBQUcsR0FBR0YsQ0FBQyxDQUFDQyxFQUFFO0FBQ2hCLENBQUM7QUFDRCxJQUFJVyxxQkFBcUIsQ0FBQyxNQUFHLEtBQUssT0FBRyxFQUFFQSxrQkFBa0IsSUFBTWYsQ0FBQUEsT0FBT0MsTUFBTSxHQUFJLFNBQVNDLENBQUMsRUFBRWMsQ0FBQztJQUN6RmhCLE9BQU9jLGNBQWMsQ0FBQ1osR0FBRyxXQUFXO1FBQUVVLFlBQVk7UUFBTUssT0FBT0Q7SUFBRTtBQUNyRSxJQUFLLFNBQVNkLENBQUMsRUFBRWMsQ0FBQztJQUNkZCxDQUFDLENBQUMsVUFBVSxHQUFHYztBQUNuQjtBQUNBLElBQUlFLGVBQWUsQ0FBQyxNQUFHLEtBQUssT0FBRyxFQUFFQSxZQUFZLElBQUssU0FBVUMsR0FBRztJQUMzRCxJQUFJQSxPQUFPQSxJQUFJVixVQUFVLEVBQUUsT0FBT1U7SUFDbEMsSUFBSUMsU0FBUyxDQUFDO0lBQ2QsSUFBSUQsT0FBTyxNQUFNO1FBQUEsSUFBSyxJQUFJZixLQUFLZSxJQUFLLElBQUlmLE1BQU0sYUFBYUosT0FBT3FCLFNBQVMsQ0FBQ0MsY0FBYyxDQUFDQyxJQUFJLENBQUNKLEtBQUtmLElBQUlMLGdCQUFnQnFCLFFBQVFELEtBQUtmO0lBQUU7SUFDeElXLG1CQUFtQkssUUFBUUQ7SUFDM0IsT0FBT0M7QUFDWDtBQUNBLElBQUlJLFNBQVMsQ0FBQyxNQUFHLEtBQUssT0FBRyxFQUFFQSxNQUFNLElBQUssU0FBVUMsQ0FBQyxFQUFFQyxDQUFDO0lBQ2hELElBQUlDLElBQUksQ0FBQztJQUNULElBQUssSUFBSUMsS0FBS0gsRUFBRyxJQUFJekIsT0FBT3FCLFNBQVMsQ0FBQ0MsY0FBYyxDQUFDQyxJQUFJLENBQUNFLEdBQUdHLE1BQU1GLEVBQUVHLE9BQU8sQ0FBQ0QsS0FBSyxHQUM5RUQsQ0FBQyxDQUFDQyxFQUFFLEdBQUdILENBQUMsQ0FBQ0csRUFBRTtJQUNmLElBQUlILEtBQUssUUFBUSxPQUFPekIsT0FBTzhCLHFCQUFxQixLQUFLLFlBQ3JELElBQUssSUFBSUMsSUFBSSxHQUFHSCxJQUFJNUIsT0FBTzhCLHFCQUFxQixDQUFDTCxJQUFJTSxJQUFJSCxFQUFFSSxNQUFNLEVBQUVELElBQUs7UUFDcEUsSUFBSUwsRUFBRUcsT0FBTyxDQUFDRCxDQUFDLENBQUNHLEVBQUUsSUFBSSxLQUFLL0IsT0FBT3FCLFNBQVMsQ0FBQ1ksb0JBQW9CLENBQUNWLElBQUksQ0FBQ0UsR0FBR0csQ0FBQyxDQUFDRyxFQUFFLEdBQ3pFSixDQUFDLENBQUNDLENBQUMsQ0FBQ0csRUFBRSxDQUFDLEdBQUdOLENBQUMsQ0FBQ0csQ0FBQyxDQUFDRyxFQUFFLENBQUM7SUFDekI7SUFDSixPQUFPSjtBQUNYO0FBQ0EsSUFBSU8sa0JBQWtCLENBQUMsTUFBRyxLQUFLLE9BQUcsRUFBRUEsZUFBZSxJQUFLLFNBQVVmLEdBQUc7SUFDakUsT0FBTyxPQUFRQSxJQUFJVixVQUFVLEdBQUlVLE1BQU07UUFBRSxXQUFXQTtJQUFJO0FBQzVEO0FBQ0FuQiw4Q0FBNkM7SUFBRWlCLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0QsTUFBTW1CLFVBQVVsQixhQUFhbUIsbUJBQU9BLENBQUMsbUZBQU87QUFDNUMsTUFBTUMsZUFBZUosZ0JBQWdCRyxtQkFBT0EsQ0FBQywwRUFBWTtBQUN6RCxNQUFNRSw2QkFBNkJMLGdCQUFnQkcsbUJBQU9BLENBQUMsK0dBQTBCO0FBQ3JGLE1BQU1HLHFCQUFxQk4sZ0JBQWdCRyxtQkFBT0EsQ0FBQywrRkFBa0I7QUFDckUsTUFBTUksU0FBU1AsZ0JBQWdCRyxtQkFBT0EsQ0FBQyxrRUFBTTtBQUM3QyxNQUFNSyxlQUFlUixnQkFBZ0JHLG1CQUFPQSxDQUFDLG1GQUFZO0FBQ3pELE1BQU1NLG1CQUFtQlQsZ0JBQWdCRyxtQkFBT0EsQ0FBQyxvR0FBZ0I7QUFDakUsTUFBTU8sWUFBWVYsZ0JBQWdCRyxtQkFBT0EsQ0FBQyxzRUFBUztBQUNuRCxNQUFNUSxtQkFBbUJYLGdCQUFnQkcsbUJBQU9BLENBQUMsOEZBQWtCO0FBQ25FLE1BQU1TLGVBQWVaLGdCQUFnQkcsbUJBQU9BLENBQUMsc0ZBQWM7QUFDM0QsTUFBTVUsa0JBQWtCYixnQkFBZ0JHLG1CQUFPQSxDQUFDLHNHQUFzQjtBQUN0RSxNQUFNVyxlQUFlZCxnQkFBZ0JHLG1CQUFPQSxDQUFDLGdHQUFtQjtBQUNoRSxNQUFNWSxpQkFBaUJmLGdCQUFnQkcsbUJBQU9BLENBQUMsb0dBQXFCO0FBQ3BFLE1BQU1hLHVCQUF1QmhCLGdCQUFnQkcsbUJBQU9BLENBQUMsZ0hBQTJCO0FBQ2hGLE1BQU1jLGFBQWFkLG1CQUFPQSxDQUFDLGdHQUFtQjtBQUM5QyxNQUFNZSwwQkFBMEJsQixnQkFBZ0JHLG1CQUFPQSxDQUFDLHNJQUFzQztBQUM5RixNQUFNZ0IsbUJBQW1CbkIsZ0JBQWdCRyxtQkFBT0EsQ0FBQyx3SEFBK0I7QUFDaEYsTUFBTWlCLGlCQUFpQmpCLG1CQUFPQSxDQUFDLHdHQUF1QjtBQUN0RCxNQUFNa0IsZUFBZTtBQUNyQjs7OztDQUlDLEdBQ0QsTUFBTUMsT0FBTyxTQUFTQSxLQUFLQyxLQUFLO0lBQzVCLE1BQU1DLGtCQUFrQixDQUFDLEdBQUdOLHdCQUF3Qk8sT0FBTztJQUMzRCxNQUFNQyxjQUFjNUQsT0FBTzZELE1BQU0sQ0FBQzdELE9BQU82RCxNQUFNLENBQUMsQ0FBQyxHQUFHSCxrQkFBa0JEO0lBQ3RFLE1BQU0sRUFBRUssYUFBYSxpQkFBaUIsRUFBRUMsZ0NBQWdDLElBQUksRUFBRUMsZ0JBQWdCLEVBQUVDLFNBQVMsRUFBRUMsUUFBUSxFQUFFQyxTQUFTLEVBQUVDLGdCQUFnQkMsY0FBYyxFQUFFQyxrQkFBa0IsRUFBRUMsZ0JBQWdCLEVBQUVDLFFBQVEsMEJBQTBCLEVBQUVDLE1BQU0sRUFBRUMsUUFBUSxFQUFFQyxVQUFVLGVBQWUsRUFBRUMsU0FBUyxvQkFBb0IsRUFBRUMsdUJBQXVCQywwQkFBMEIsRUFBRUMseUJBQXlCQyw0QkFBNEIsRUFBRUMsc0JBQXNCQyx5QkFBeUIsRUFBRUMsd0JBQXdCQywyQkFBMkIsRUFBRUMsZ0JBQWdCQyxtQkFBbUIsRUFBRUMsa0JBQWtCQyxxQkFBcUIsRUFBRUMsYUFBYUMsZ0JBQWdCLEVBQUVDLGVBQWVDLGtCQUFrQixFQUFFQyw4QkFBOEJDLGlDQUFpQyxFQUFFQyxnQ0FBZ0NDLG1DQUFtQyxFQUFFQyxlQUFlQyxrQkFBa0IsRUFBRUMsaUJBQWlCQyxvQkFBb0IsRUFBRUMsd0JBQXdCQywyQkFBMkIsRUFBRUMsMEJBQTBCQyw2QkFBNkIsRUFBRUMsV0FBV0MsY0FBYyxFQUFFQyxZQUFZQyxlQUFlLEVBQUVDLEdBQUcsRUFBRUMsWUFBWSxFQUFFQyx1QkFBdUJDLDZCQUE2QixJQUFJLEVBQUVDLGNBQWMsS0FBSyxFQUFFQyxhQUFhLFFBQVEsRUFBRUMsaUJBQWlCQyx1QkFBdUIsSUFBSSxFQUFFQyxRQUFRQyxXQUFXLEVBQUVDLE9BQU9DLGFBQWFqRSxZQUFZLEVBQUVrRSxjQUFjLEVBQUVDLEtBQUssRUFBRSxHQUFHOUQsYUFBYStELGFBQWFuRyxPQUFPb0MsYUFBYTtRQUFDO1FBQWM7UUFBaUM7UUFBb0I7UUFBYTtRQUFZO1FBQWE7UUFBa0I7UUFBc0I7UUFBb0I7UUFBUztRQUFVO1FBQVk7UUFBVztRQUFVO1FBQXlCO1FBQTJCO1FBQXdCO1FBQTBCO1FBQWtCO1FBQW9CO1FBQWU7UUFBaUI7UUFBZ0M7UUFBa0M7UUFBaUI7UUFBbUI7UUFBMEI7UUFBNEI7UUFBYTtRQUFjO1FBQU87UUFBZ0I7UUFBeUI7UUFBZTtRQUFjO1FBQW1CO1FBQVU7UUFBUztRQUFrQjtLQUFRO0lBQzUvRCxNQUFNLENBQUNnRSxXQUFXQyxhQUFhLEdBQUcsQ0FBQyxHQUFHeEUsaUJBQWlCTSxPQUFPO0lBQzlELE1BQU0sRUFBRTFDLE9BQU82RyxJQUFJLEVBQUV0RCxPQUFPdUQsU0FBUyxFQUFFLEdBQUdIO0lBQzFDLE1BQU1JLGNBQWMsQ0FBQyxHQUFHNUYsUUFBUTZGLE1BQU0sRUFBRTtJQUN2QyxJQUFHdEYsaUJBQWlCZ0IsT0FBTyxFQUFFa0QsS0FBSztJQUNuQyxNQUFNSixZQUFZLENBQUMsR0FBR3RELFdBQVcrRSxVQUFVLEVBQUV0QixtQkFBbUJBLGtCQUFrQixJQUFJRixtQkFBbUIsUUFBUUEsbUJBQW1CLEtBQUssSUFBSUEsaUJBQWlCO0lBQzlKLE1BQU1DLGFBQWFDLG9CQUFvQixRQUFRQSxvQkFBb0IsS0FBSyxJQUFJQSxrQkFBbUIsQ0FBQyxHQUFHekQsV0FBVytFLFVBQVUsRUFBRXhCLGtCQUFrQkEsaUJBQWlCLElBQUk7SUFDakssTUFBTVcsU0FBU0MsZ0JBQWdCLFFBQVFBLGdCQUFnQixLQUFLLElBQUlBLGNBQWVRLE9BQU9BLEtBQUtULE1BQU0sR0FBRztJQUNwRyxNQUFNRSxRQUFRLENBQUMsR0FBR25GLFFBQVErRixPQUFPLEVBQUU7UUFDL0IsSUFBSSxDQUFDTCxNQUFNO1lBQ1AsT0FBTztRQUNYO1FBQ0EsdURBQXVEO1FBQ3ZELElBQUlNLFlBQVk7UUFDaEIsbUVBQW1FO1FBQ25FLE1BQU1DLG1CQUFtQmIsZUFBZSxRQUFRQSxlQUFlLEtBQUssSUFBSUEsYUFBYWpFO1FBQ3JGLCtGQUErRjtRQUMvRixJQUFJbUUsU0FBU2pELFFBQVE7WUFDakIsTUFBTTZELFdBQVdSLEtBQUtTLFdBQVcsQ0FBQztnQkFBRWhCLE9BQU87Z0JBQUdpQixVQUFVbkI7WUFBTztZQUMvRCxJQUFJSyxPQUFPO2dCQUNQVSxZQUFZVixRQUFRWSxTQUFTWixLQUFLO1lBQ3RDLE9BQ0ssSUFBSWpELFFBQVE7Z0JBQ2IyRCxZQUFZM0QsU0FBUzZELFNBQVM3RCxNQUFNO1lBQ3hDO1FBQ0o7UUFDQSxPQUFPNEQsbUJBQW1CRDtJQUM5QixHQUFHO1FBQUMzRDtRQUFRcUQ7UUFBTVQ7UUFBUUc7UUFBWUU7S0FBTTtJQUM1QyxTQUFTZTtRQUNMLE9BQU87WUFDSCxJQUFJLENBQUMsQ0FBQyxHQUFHdEYsV0FBVytFLFVBQVUsRUFBRXpCLFlBQVk7Z0JBQ3hDLCtDQUErQztnQkFDL0M7WUFDSjtZQUNBLElBQUkxQyxpQ0FBaUMwRCxnQkFBZ0I7Z0JBQ2pEQSxlQUFlaEI7WUFDbkI7UUFDSjtJQUNKO0lBQ0MsSUFBR3JFLFFBQVFzRyxTQUFTLEVBQUVELE1BQU07UUFBQzFFO1FBQStCOEM7UUFBS0o7UUFBV2dCO0tBQWU7SUFDNUY7O0tBRUMsR0FDRCxTQUFTOUI7UUFDTCxJQUFJQyxvQkFBb0I7WUFDcEIsSUFBSSxDQUFDa0MsUUFBUSxDQUFDUCxPQUFPO2dCQUNqQiwrQ0FBK0M7Z0JBQy9DO1lBQ0o7WUFDQTNCLG1CQUFtQixDQUFDLEdBQUd6QyxXQUFXd0YsZ0JBQWdCLEVBQUViLE1BQU1QO1FBQzlEO1FBQ0EsSUFBSXhELGlDQUFpQytDLGNBQWM7WUFDL0MsSUFBSSxDQUFDLENBQUMsR0FBRzNELFdBQVcrRSxVQUFVLEVBQUV6QixjQUFjLENBQUN1QixZQUFZWSxPQUFPLEVBQUU7Z0JBQ2hFLCtDQUErQztnQkFDL0M7WUFDSjtZQUNBOUIsYUFBYUwsV0FBV3VCLFlBQVlZLE9BQU87UUFDL0M7SUFDSjtJQUNBOztLQUVDLEdBQ0QsU0FBU25EO1FBQ0wsSUFBSSxDQUFDc0MsV0FBVztZQUNaLCtDQUErQztZQUMvQztRQUNKO1FBQ0MsSUFBR25GLFVBQVVlLE9BQU8sRUFBRSxPQUFPb0UsVUFBVWMsUUFBUTtRQUNoRCxJQUFJbkQsa0JBQWtCO1lBQ2xCQSxpQkFBaUJxQztRQUNyQjtJQUNKO0lBQ0EsU0FBU2U7UUFDTGpCLGFBQWE7WUFBRWtCLE1BQU07UUFBUTtJQUNqQztJQUNDLElBQUczRyxRQUFRc0csU0FBUyxFQUFFSSxXQUFXO1FBQUNqQjtRQUFjaEI7UUFBS0o7S0FBVTtJQUNoRSxTQUFTdUM7UUFDTCxJQUFJLENBQUNuQyxPQUFPLENBQUNGLFlBQVk7WUFDckI7UUFDSjtRQUNBLE1BQU1zQyxjQUFjLENBQUMsR0FBRzFHLDJCQUEyQm9CLE9BQU8sRUFBRWtELElBQUlxQyxPQUFPLENBQUN2QztRQUN4RSxNQUFNd0MsY0FBY0Y7UUFDcEJBLFlBQVlHLE9BQU8sQ0FDZEMsSUFBSSxDQUFDLENBQUNDO1lBQ1B6QixhQUFhO2dCQUFFa0IsTUFBTTtnQkFBVzlILE9BQU9xSTtZQUFTO1FBQ3BELEdBQ0tDLEtBQUssQ0FBQyxDQUFDL0U7WUFDUnFELGFBQWE7Z0JBQUVrQixNQUFNO2dCQUFVdkU7WUFBTTtRQUN6QztRQUNBLE9BQU8sSUFBTSxDQUFDLEdBQUdyQixXQUFXcUcsaUJBQWlCLEVBQUVMO0lBQ25EO0lBQ0MsSUFBRy9HLFFBQVFzRyxTQUFTLEVBQUVNLFVBQVU7UUFBQ25CO1FBQWNoQjtRQUFLSjtRQUFXRTtRQUFZRztLQUFhO0lBQ3hGLElBQUcxRSxRQUFRc0csU0FBUyxFQUFFO1FBQ25CLElBQUlaLFNBQVN4SCxXQUFXO1lBQ3BCO1FBQ0o7UUFDQSxJQUFJd0gsU0FBUyxPQUFPO1lBQ2hCckM7WUFDQTtRQUNKO1FBQ0FFO0lBQ0osR0FDQSxtRUFBbUU7SUFDbkUsdURBQXVEO0lBQ3ZEO1FBQUNtQztRQUFNUDtLQUFNO0lBQ2IsTUFBTWtDLGVBQWUsQ0FBQyxHQUFHckgsUUFBUStGLE9BQU8sRUFBRSxJQUMxQyxxSEFBcUg7UUFDckhMLFFBQVEsQ0FBQyxHQUFHM0UsV0FBVytFLFVBQVUsRUFBRXpCLGNBQWNFLGNBQWMsQ0FBQyxHQUFHeEQsV0FBVytFLFVBQVUsRUFBRWIsV0FBVyxDQUFDLEdBQUdsRSxXQUFXK0UsVUFBVSxFQUFFWCxTQUMxSDtZQUNFekQ7WUFDQUU7WUFDQU07WUFDQUM7WUFDQU0sdUJBQXVCQztZQUN2QkMseUJBQXlCQztZQUN6QkMsc0JBQXNCQztZQUN0QkMsd0JBQXdCQztZQUN4QkMsZ0JBQWdCQztZQUNoQkMsa0JBQWtCQztZQUNsQkssOEJBQThCQztZQUM5QkMsZ0NBQWdDQztZQUNoQ0MsZUFBZUM7WUFDZkMsaUJBQWlCQztZQUNqQkMsd0JBQXdCQztZQUN4QkMsMEJBQTBCQztZQUMxQnNCO1lBQ0FyQjtZQUNBRTtZQUNBTTtZQUNBRSxpQkFBaUJDO1lBQ2pCQztZQUNBRTtRQUNKLElBQ0UsTUFBTTtRQUNSekQ7UUFDQUU7UUFDQU07UUFDQUM7UUFDQU87UUFDQUU7UUFDQUU7UUFDQUU7UUFDQUU7UUFDQUU7UUFDQU07UUFDQUU7UUFDQUU7UUFDQUU7UUFDQUU7UUFDQUU7UUFDQXNCO1FBQ0FyQjtRQUNBRTtRQUNBTTtRQUNBRztRQUNBQztRQUNBRTtLQUNIO0lBQ0QsTUFBTW1DLGFBQWEsQ0FBQyxHQUFHdEgsUUFBUStGLE9BQU8sRUFBRSxJQUFNLENBQUMsR0FBRzNGLG1CQUFtQm1CLE9BQU8sRUFBRWdFLFlBQVksSUFBTUcsT0FBUVAsUUFBUSxDQUFDLEdBQUdwRSxXQUFXd0YsZ0JBQWdCLEVBQUViLE1BQU1QLFNBQVNqSCxZQUFhd0gsT0FBTztRQUFDSDtRQUFZRztRQUFNUDtLQUFNO0lBQzdNLE1BQU1vQyxVQUFVLEdBQWdCcEMsT0FBYmQsV0FBVSxLQUFZWSxPQUFURSxPQUFNLEtBQVUsT0FBUEY7SUFDekMsTUFBTXVDLGlCQUFpQixHQUFnQnZDLE9BQWJaLFdBQVUsS0FBVSxPQUFQWTtJQUN2QyxTQUFTd0M7UUFDTCxPQUFRM0M7WUFDSixLQUFLO2dCQUFVO29CQUNWLElBQUd2RSxpQkFBaUJnQixPQUFPLEVBQUVVLGdCQUFpQjtvQkFDL0MsT0FBT2pDLFFBQVF1QixPQUFPLENBQUNtRyxhQUFhLENBQUN6RixnQkFBZ0I7d0JBQUUwRixLQUFLLEdBQVcsT0FBUkosU0FBUTtvQkFBUztnQkFDcEY7WUFDQSxLQUFLO2dCQUNELE9BQU87WUFDWCxLQUFLO2dCQUNELE9BQU92SCxRQUFRdUIsT0FBTyxDQUFDbUcsYUFBYSxDQUFDOUcsYUFBYVcsT0FBTyxFQUFFO29CQUFFb0csS0FBSyxHQUFrQixPQUFmSCxnQkFBZTtnQkFBTTtZQUM5RixLQUFLO1lBQ0w7Z0JBQ0ksT0FBT3hILFFBQVF1QixPQUFPLENBQUNtRyxhQUFhLENBQUMvRyxnQkFBZ0JZLE9BQU8sRUFBRTtvQkFBRW9HLEtBQUssR0FBVyxPQUFSSixTQUFRO29CQUFVMUYsV0FBV0E7Z0JBQVU7UUFDdkg7SUFDSjtJQUNBLFNBQVNrRDtRQUNMLElBQUksQ0FBQ0Msc0JBQXNCO1lBQ3ZCLE9BQU87UUFDWDtRQUNBLE9BQU9oRixRQUFRdUIsT0FBTyxDQUFDbUcsYUFBYSxDQUFDN0csZUFBZVUsT0FBTyxFQUFFO1lBQUVvRyxLQUFLLEdBQVcsT0FBUkosU0FBUTtRQUFPO0lBQzFGO0lBQ0EsU0FBUzVDO1FBQ0wsSUFBSSxDQUFDQyw0QkFBNEI7WUFDN0IsT0FBTztRQUNYO1FBQ0E7OztTQUdDLEdBQ0QsT0FBTzVFLFFBQVF1QixPQUFPLENBQUNtRyxhQUFhLENBQUM1RyxxQkFBcUJTLE9BQU8sRUFBRTtZQUFFb0csS0FBSyxHQUFXLE9BQVJKLFNBQVE7UUFBYztJQUN2RztJQUNBLFNBQVNLO1FBQ0wsT0FBUTVILFFBQVF1QixPQUFPLENBQUNtRyxhQUFhLENBQUNqSCxpQkFBaUJjLE9BQU8sQ0FBQ3NHLFFBQVEsRUFBRTtZQUFFaEosT0FBT3dJO1FBQWEsR0FDM0ZJLG1CQUNBMUMsbUJBQ0FKLHlCQUNBN0M7SUFDUjtJQUNBLFNBQVNnRztRQUNMLElBQUksQ0FBQ3ZELFlBQVk7WUFDYixPQUFPdkUsUUFBUXVCLE9BQU8sQ0FBQ21HLGFBQWEsQ0FBQ2hILGFBQWFhLE9BQU8sRUFBRTtnQkFBRW9GLE1BQU07WUFBVSxHQUFHLE9BQU9uRSxXQUFXLGFBQWFBLFdBQVdBO1FBQzlIO1FBQ0EsSUFBSWlDLFFBQVEsUUFBUWlCLFNBQVN4SCxhQUFhd0gsU0FBUyxNQUFNO1lBQ3JELE9BQVExRixRQUFRdUIsT0FBTyxDQUFDbUcsYUFBYSxDQUFDaEgsYUFBYWEsT0FBTyxFQUFFO2dCQUFFb0YsTUFBTTtZQUFVLEdBQUcsT0FBT3BFLFlBQVksYUFBYUEsWUFBWUE7UUFDakk7UUFDQSxJQUFJa0MsUUFBUSxTQUFTaUIsU0FBUyxPQUFPO1lBQ2pDLE9BQU8xRixRQUFRdUIsT0FBTyxDQUFDbUcsYUFBYSxDQUFDaEgsYUFBYWEsT0FBTyxFQUFFO2dCQUFFb0YsTUFBTTtZQUFRLEdBQUcsT0FBT3ZFLFVBQVUsYUFBYUEsVUFBVUE7UUFDMUg7UUFDQSxPQUFPd0Y7SUFDWDtJQUNBLE9BQVE1SCxRQUFRdUIsT0FBTyxDQUFDbUcsYUFBYSxDQUFDLE9BQU85SixPQUFPNkQsTUFBTSxDQUFDO1FBQUVNLFdBQVcsQ0FBQyxHQUFHMUIsT0FBT2tCLE9BQU8sRUFBRUcsWUFBWUs7UUFBWSxvQkFBb0J3QztRQUFZd0QsS0FBSyxDQUFDLEdBQUd6SCxhQUFhaUIsT0FBTyxFQUFFZSxVQUFVc0Q7UUFBY29DLE9BQU87WUFDMU0sQ0FBQyxpQkFBaUIsRUFBRSxHQUFTLE9BQU43QztZQUN2QjhDLGlCQUFpQnJHLG9CQUFvQjtZQUNyQ3NHLFVBQVU7WUFDVkMsVUFBVTtZQUNWQyxXQUFXO1FBQ2Y7SUFBRSxHQUFHZCxhQUFhUTtBQUMxQjtLQTdOTTFHO0FBOE5OLE1BQU1pSCxtQkFBbUJuSSxhQUFhcUIsT0FBTyxDQUFDK0csU0FBUyxDQUFDO0lBQUNwSSxhQUFhcUIsT0FBTyxDQUFDZ0gsSUFBSTtJQUFFckksYUFBYXFCLE9BQU8sQ0FBQ2lILElBQUk7Q0FBQztBQUM5R3BILEtBQUtxSCxTQUFTLEdBQUc3SyxPQUFPNkQsTUFBTSxDQUFDN0QsT0FBTzZELE1BQU0sQ0FBQyxDQUFDLEdBQUdQLGVBQWVvRyxVQUFVLEdBQUc7SUFBRTFGLGtCQUFrQjFCLGFBQWFxQixPQUFPLENBQUNtSCxNQUFNO0lBQUU3RyxXQUFXWCxlQUFleUgsS0FBSztJQUFFN0csVUFBVTVCLGFBQWFxQixPQUFPLENBQUNpSCxJQUFJO0lBQUV6RyxXQUFXYixlQUFlMEgsV0FBVztJQUFFNUcsZ0JBQWdCOUIsYUFBYXFCLE9BQU8sQ0FBQ2dILElBQUk7SUFBRXJHLG9CQUFvQmhDLGFBQWFxQixPQUFPLENBQUNnSCxJQUFJO0lBQUVwRyxrQkFBa0JqQyxhQUFhcUIsT0FBTyxDQUFDc0gsTUFBTTtJQUFFekcsT0FBT2lHO0lBQWtCaEcsUUFBUW5DLGFBQWFxQixPQUFPLENBQUNzSCxNQUFNO0lBQUVDLG9CQUFvQjVJLGFBQWFxQixPQUFPLENBQUNtSCxNQUFNO0lBQUVwRyxVQUFVcEIsZUFBZXlILEtBQUs7SUFBRXBHLFNBQVM4RjtJQUFrQjdGLFFBQVE2RjtJQUFrQnBGLGdCQUFnQi9DLGFBQWFxQixPQUFPLENBQUNnSCxJQUFJO0lBQUVwRixrQkFBa0JqRCxhQUFhcUIsT0FBTyxDQUFDZ0gsSUFBSTtJQUFFbEYsYUFBYW5ELGFBQWFxQixPQUFPLENBQUNnSCxJQUFJO0lBQUVoRixlQUFlckQsYUFBYXFCLE9BQU8sQ0FBQ2dILElBQUk7SUFBRTFFLGVBQWUzRCxhQUFhcUIsT0FBTyxDQUFDZ0gsSUFBSTtJQUFFeEUsaUJBQWlCN0QsYUFBYXFCLE9BQU8sQ0FBQ2dILElBQUk7SUFBRXRFLHdCQUF3Qi9ELGFBQWFxQixPQUFPLENBQUNnSCxJQUFJO0lBQUVwRSwwQkFBMEJqRSxhQUFhcUIsT0FBTyxDQUFDZ0gsSUFBSTtJQUFFbEUsV0FBV25ELGVBQWU2SCxXQUFXO0lBQUV4RSxZQUFZckQsZUFBZThILFlBQVk7SUFBRXZFLEtBQUt2RCxlQUFlK0gsS0FBSztJQUFFdEUsdUJBQXVCekUsYUFBYXFCLE9BQU8sQ0FBQzJILElBQUk7SUFBRXJFLGFBQWEzRSxhQUFhcUIsT0FBTyxDQUFDMkgsSUFBSTtJQUFFcEUsWUFBWTVELGVBQWVpSSxZQUFZO0lBQUVwRSxpQkFBaUI3RSxhQUFhcUIsT0FBTyxDQUFDMkgsSUFBSTtJQUFFakUsUUFBUS9ELGVBQWVrSSxRQUFRO0lBQUVqRSxPQUFPakYsYUFBYXFCLE9BQU8sQ0FBQ3NILE1BQU07SUFBRXZELE9BQU9wRixhQUFhcUIsT0FBTyxDQUFDc0gsTUFBTTtBQUFDO0FBQ2x5QzlJLGtCQUFlLEdBQUdxQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVhY3QtcGRmL2Rpc3QvY2pzL1BhZ2UuanM/YTEwOCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbid1c2UgY2xpZW50JztcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xudmFyIF9fcmVzdCA9ICh0aGlzICYmIHRoaXMuX19yZXN0KSB8fCBmdW5jdGlvbiAocywgZSkge1xuICAgIHZhciB0ID0ge307XG4gICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApXG4gICAgICAgIHRbcF0gPSBzW3BdO1xuICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDAgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHBbaV0pKVxuICAgICAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xuICAgICAgICB9XG4gICAgcmV0dXJuIHQ7XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgcmVhY3RfMSA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwicmVhY3RcIikpO1xuY29uc3QgcHJvcF90eXBlc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJwcm9wLXR5cGVzXCIpKTtcbmNvbnN0IG1ha2VfY2FuY2VsbGFibGVfcHJvbWlzZV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJtYWtlLWNhbmNlbGxhYmxlLXByb21pc2VcIikpO1xuY29uc3QgbWFrZV9ldmVudF9wcm9wc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJtYWtlLWV2ZW50LXByb3BzXCIpKTtcbmNvbnN0IGNsc3hfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiY2xzeFwiKSk7XG5jb25zdCBtZXJnZV9yZWZzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIm1lcmdlLXJlZnNcIikpO1xuY29uc3QgdGlueV9pbnZhcmlhbnRfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwidGlueS1pbnZhcmlhbnRcIikpO1xuY29uc3Qgd2FybmluZ18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJ3YXJuaW5nXCIpKTtcbmNvbnN0IFBhZ2VDb250ZXh0X2pzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vUGFnZUNvbnRleHQuanNcIikpO1xuY29uc3QgTWVzc2FnZV9qc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL01lc3NhZ2UuanNcIikpO1xuY29uc3QgUGFnZUNhbnZhc19qc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL1BhZ2UvUGFnZUNhbnZhcy5qc1wiKSk7XG5jb25zdCBQYWdlU1ZHX2pzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vUGFnZS9QYWdlU1ZHLmpzXCIpKTtcbmNvbnN0IFRleHRMYXllcl9qc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL1BhZ2UvVGV4dExheWVyLmpzXCIpKTtcbmNvbnN0IEFubm90YXRpb25MYXllcl9qc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL1BhZ2UvQW5ub3RhdGlvbkxheWVyLmpzXCIpKTtcbmNvbnN0IHV0aWxzX2pzXzEgPSByZXF1aXJlKFwiLi9zaGFyZWQvdXRpbHMuanNcIik7XG5jb25zdCB1c2VEb2N1bWVudENvbnRleHRfanNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9zaGFyZWQvaG9va3MvdXNlRG9jdW1lbnRDb250ZXh0LmpzXCIpKTtcbmNvbnN0IHVzZVJlc29sdmVyX2pzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vc2hhcmVkL2hvb2tzL3VzZVJlc29sdmVyLmpzXCIpKTtcbmNvbnN0IHByb3BUeXBlc19qc18xID0gcmVxdWlyZShcIi4vc2hhcmVkL3Byb3BUeXBlcy5qc1wiKTtcbmNvbnN0IGRlZmF1bHRTY2FsZSA9IDE7XG4vKipcbiAqIERpc3BsYXlzIGEgcGFnZS5cbiAqXG4gKiBTaG91bGQgYmUgcGxhY2VkIGluc2lkZSBgPERvY3VtZW50IC8+YC4gQWx0ZXJuYXRpdmVseSwgaXQgY2FuIGhhdmUgYHBkZmAgcHJvcCBwYXNzZWQsIHdoaWNoIGNhbiBiZSBvYnRhaW5lZCBmcm9tIGA8RG9jdW1lbnQgLz5gJ3MgYG9uTG9hZFN1Y2Nlc3NgIGNhbGxiYWNrIGZ1bmN0aW9uLCBob3dldmVyIHNvbWUgYWR2YW5jZWQgZnVuY3Rpb25zIGxpa2UgbGlua2luZyBiZXR3ZWVuIHBhZ2VzIGluc2lkZSBhIGRvY3VtZW50IG1heSBub3QgYmUgd29ya2luZyBjb3JyZWN0bHkuXG4gKi9cbmNvbnN0IFBhZ2UgPSBmdW5jdGlvbiBQYWdlKHByb3BzKSB7XG4gICAgY29uc3QgZG9jdW1lbnRDb250ZXh0ID0gKDAsIHVzZURvY3VtZW50Q29udGV4dF9qc18xLmRlZmF1bHQpKCk7XG4gICAgY29uc3QgbWVyZ2VkUHJvcHMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGRvY3VtZW50Q29udGV4dCksIHByb3BzKTtcbiAgICBjb25zdCB7IF9jbGFzc05hbWUgPSAncmVhY3QtcGRmX19QYWdlJywgX2VuYWJsZVJlZ2lzdGVyVW5yZWdpc3RlclBhZ2UgPSB0cnVlLCBjYW52YXNCYWNrZ3JvdW5kLCBjYW52YXNSZWYsIGNoaWxkcmVuLCBjbGFzc05hbWUsIGN1c3RvbVJlbmRlcmVyOiBDdXN0b21SZW5kZXJlciwgY3VzdG9tVGV4dFJlbmRlcmVyLCBkZXZpY2VQaXhlbFJhdGlvLCBlcnJvciA9ICdGYWlsZWQgdG8gbG9hZCB0aGUgcGFnZS4nLCBoZWlnaHQsIGlucHV0UmVmLCBsb2FkaW5nID0gJ0xvYWRpbmcgcGFnZeKApicsIG5vRGF0YSA9ICdObyBwYWdlIHNwZWNpZmllZC4nLCBvbkdldEFubm90YXRpb25zRXJyb3I6IG9uR2V0QW5ub3RhdGlvbnNFcnJvclByb3BzLCBvbkdldEFubm90YXRpb25zU3VjY2Vzczogb25HZXRBbm5vdGF0aW9uc1N1Y2Nlc3NQcm9wcywgb25HZXRTdHJ1Y3RUcmVlRXJyb3I6IG9uR2V0U3RydWN0VHJlZUVycm9yUHJvcHMsIG9uR2V0U3RydWN0VHJlZVN1Y2Nlc3M6IG9uR2V0U3RydWN0VHJlZVN1Y2Nlc3NQcm9wcywgb25HZXRUZXh0RXJyb3I6IG9uR2V0VGV4dEVycm9yUHJvcHMsIG9uR2V0VGV4dFN1Y2Nlc3M6IG9uR2V0VGV4dFN1Y2Nlc3NQcm9wcywgb25Mb2FkRXJyb3I6IG9uTG9hZEVycm9yUHJvcHMsIG9uTG9hZFN1Y2Nlc3M6IG9uTG9hZFN1Y2Nlc3NQcm9wcywgb25SZW5kZXJBbm5vdGF0aW9uTGF5ZXJFcnJvcjogb25SZW5kZXJBbm5vdGF0aW9uTGF5ZXJFcnJvclByb3BzLCBvblJlbmRlckFubm90YXRpb25MYXllclN1Y2Nlc3M6IG9uUmVuZGVyQW5ub3RhdGlvbkxheWVyU3VjY2Vzc1Byb3BzLCBvblJlbmRlckVycm9yOiBvblJlbmRlckVycm9yUHJvcHMsIG9uUmVuZGVyU3VjY2Vzczogb25SZW5kZXJTdWNjZXNzUHJvcHMsIG9uUmVuZGVyVGV4dExheWVyRXJyb3I6IG9uUmVuZGVyVGV4dExheWVyRXJyb3JQcm9wcywgb25SZW5kZXJUZXh0TGF5ZXJTdWNjZXNzOiBvblJlbmRlclRleHRMYXllclN1Y2Nlc3NQcm9wcywgcGFnZUluZGV4OiBwYWdlSW5kZXhQcm9wcywgcGFnZU51bWJlcjogcGFnZU51bWJlclByb3BzLCBwZGYsIHJlZ2lzdGVyUGFnZSwgcmVuZGVyQW5ub3RhdGlvbkxheWVyOiByZW5kZXJBbm5vdGF0aW9uTGF5ZXJQcm9wcyA9IHRydWUsIHJlbmRlckZvcm1zID0gZmFsc2UsIHJlbmRlck1vZGUgPSAnY2FudmFzJywgcmVuZGVyVGV4dExheWVyOiByZW5kZXJUZXh0TGF5ZXJQcm9wcyA9IHRydWUsIHJvdGF0ZTogcm90YXRlUHJvcHMsIHNjYWxlOiBzY2FsZVByb3BzID0gZGVmYXVsdFNjYWxlLCB1bnJlZ2lzdGVyUGFnZSwgd2lkdGggfSA9IG1lcmdlZFByb3BzLCBvdGhlclByb3BzID0gX19yZXN0KG1lcmdlZFByb3BzLCBbXCJfY2xhc3NOYW1lXCIsIFwiX2VuYWJsZVJlZ2lzdGVyVW5yZWdpc3RlclBhZ2VcIiwgXCJjYW52YXNCYWNrZ3JvdW5kXCIsIFwiY2FudmFzUmVmXCIsIFwiY2hpbGRyZW5cIiwgXCJjbGFzc05hbWVcIiwgXCJjdXN0b21SZW5kZXJlclwiLCBcImN1c3RvbVRleHRSZW5kZXJlclwiLCBcImRldmljZVBpeGVsUmF0aW9cIiwgXCJlcnJvclwiLCBcImhlaWdodFwiLCBcImlucHV0UmVmXCIsIFwibG9hZGluZ1wiLCBcIm5vRGF0YVwiLCBcIm9uR2V0QW5ub3RhdGlvbnNFcnJvclwiLCBcIm9uR2V0QW5ub3RhdGlvbnNTdWNjZXNzXCIsIFwib25HZXRTdHJ1Y3RUcmVlRXJyb3JcIiwgXCJvbkdldFN0cnVjdFRyZWVTdWNjZXNzXCIsIFwib25HZXRUZXh0RXJyb3JcIiwgXCJvbkdldFRleHRTdWNjZXNzXCIsIFwib25Mb2FkRXJyb3JcIiwgXCJvbkxvYWRTdWNjZXNzXCIsIFwib25SZW5kZXJBbm5vdGF0aW9uTGF5ZXJFcnJvclwiLCBcIm9uUmVuZGVyQW5ub3RhdGlvbkxheWVyU3VjY2Vzc1wiLCBcIm9uUmVuZGVyRXJyb3JcIiwgXCJvblJlbmRlclN1Y2Nlc3NcIiwgXCJvblJlbmRlclRleHRMYXllckVycm9yXCIsIFwib25SZW5kZXJUZXh0TGF5ZXJTdWNjZXNzXCIsIFwicGFnZUluZGV4XCIsIFwicGFnZU51bWJlclwiLCBcInBkZlwiLCBcInJlZ2lzdGVyUGFnZVwiLCBcInJlbmRlckFubm90YXRpb25MYXllclwiLCBcInJlbmRlckZvcm1zXCIsIFwicmVuZGVyTW9kZVwiLCBcInJlbmRlclRleHRMYXllclwiLCBcInJvdGF0ZVwiLCBcInNjYWxlXCIsIFwidW5yZWdpc3RlclBhZ2VcIiwgXCJ3aWR0aFwiXSk7XG4gICAgY29uc3QgW3BhZ2VTdGF0ZSwgcGFnZURpc3BhdGNoXSA9ICgwLCB1c2VSZXNvbHZlcl9qc18xLmRlZmF1bHQpKCk7XG4gICAgY29uc3QgeyB2YWx1ZTogcGFnZSwgZXJyb3I6IHBhZ2VFcnJvciB9ID0gcGFnZVN0YXRlO1xuICAgIGNvbnN0IHBhZ2VFbGVtZW50ID0gKDAsIHJlYWN0XzEudXNlUmVmKShudWxsKTtcbiAgICAoMCwgdGlueV9pbnZhcmlhbnRfMS5kZWZhdWx0KShwZGYsICdBdHRlbXB0ZWQgdG8gbG9hZCBhIHBhZ2UsIGJ1dCBubyBkb2N1bWVudCB3YXMgc3BlY2lmaWVkLiBXcmFwIDxQYWdlIC8+IGluIGEgPERvY3VtZW50IC8+IG9yIHBhc3MgZXhwbGljaXQgYHBkZmAgcHJvcC4nKTtcbiAgICBjb25zdCBwYWdlSW5kZXggPSAoMCwgdXRpbHNfanNfMS5pc1Byb3ZpZGVkKShwYWdlTnVtYmVyUHJvcHMpID8gcGFnZU51bWJlclByb3BzIC0gMSA6IHBhZ2VJbmRleFByb3BzICE9PSBudWxsICYmIHBhZ2VJbmRleFByb3BzICE9PSB2b2lkIDAgPyBwYWdlSW5kZXhQcm9wcyA6IG51bGw7XG4gICAgY29uc3QgcGFnZU51bWJlciA9IHBhZ2VOdW1iZXJQcm9wcyAhPT0gbnVsbCAmJiBwYWdlTnVtYmVyUHJvcHMgIT09IHZvaWQgMCA/IHBhZ2VOdW1iZXJQcm9wcyA6ICgoMCwgdXRpbHNfanNfMS5pc1Byb3ZpZGVkKShwYWdlSW5kZXhQcm9wcykgPyBwYWdlSW5kZXhQcm9wcyArIDEgOiBudWxsKTtcbiAgICBjb25zdCByb3RhdGUgPSByb3RhdGVQcm9wcyAhPT0gbnVsbCAmJiByb3RhdGVQcm9wcyAhPT0gdm9pZCAwID8gcm90YXRlUHJvcHMgOiAocGFnZSA/IHBhZ2Uucm90YXRlIDogbnVsbCk7XG4gICAgY29uc3Qgc2NhbGUgPSAoMCwgcmVhY3RfMS51c2VNZW1vKSgoKSA9PiB7XG4gICAgICAgIGlmICghcGFnZSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQmUgZGVmYXVsdCwgd2UnbGwgcmVuZGVyIHBhZ2UgYXQgMTAwJSAqIHNjYWxlIHdpZHRoLlxuICAgICAgICBsZXQgcGFnZVNjYWxlID0gMTtcbiAgICAgICAgLy8gUGFzc2luZyBzY2FsZSBleHBsaWNpdGx5IG51bGwgd291bGQgY2F1c2UgdGhlIHBhZ2Ugbm90IHRvIHJlbmRlclxuICAgICAgICBjb25zdCBzY2FsZVdpdGhEZWZhdWx0ID0gc2NhbGVQcm9wcyAhPT0gbnVsbCAmJiBzY2FsZVByb3BzICE9PSB2b2lkIDAgPyBzY2FsZVByb3BzIDogZGVmYXVsdFNjYWxlO1xuICAgICAgICAvLyBJZiB3aWR0aC9oZWlnaHQgaXMgZGVmaW5lZCwgY2FsY3VsYXRlIHRoZSBzY2FsZSBvZiB0aGUgcGFnZSBzbyBpdCBjb3VsZCBiZSBvZiBkZXNpcmVkIHdpZHRoLlxuICAgICAgICBpZiAod2lkdGggfHwgaGVpZ2h0KSB7XG4gICAgICAgICAgICBjb25zdCB2aWV3cG9ydCA9IHBhZ2UuZ2V0Vmlld3BvcnQoeyBzY2FsZTogMSwgcm90YXRpb246IHJvdGF0ZSB9KTtcbiAgICAgICAgICAgIGlmICh3aWR0aCkge1xuICAgICAgICAgICAgICAgIHBhZ2VTY2FsZSA9IHdpZHRoIC8gdmlld3BvcnQud2lkdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChoZWlnaHQpIHtcbiAgICAgICAgICAgICAgICBwYWdlU2NhbGUgPSBoZWlnaHQgLyB2aWV3cG9ydC5oZWlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNjYWxlV2l0aERlZmF1bHQgKiBwYWdlU2NhbGU7XG4gICAgfSwgW2hlaWdodCwgcGFnZSwgcm90YXRlLCBzY2FsZVByb3BzLCB3aWR0aF0pO1xuICAgIGZ1bmN0aW9uIGhvb2soKSB7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoISgwLCB1dGlsc19qc18xLmlzUHJvdmlkZWQpKHBhZ2VJbmRleCkpIHtcbiAgICAgICAgICAgICAgICAvLyBJbXBvc3NpYmxlLCBidXQgVHlwZVNjcmlwdCBkb2Vzbid0IGtub3cgdGhhdFxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChfZW5hYmxlUmVnaXN0ZXJVbnJlZ2lzdGVyUGFnZSAmJiB1bnJlZ2lzdGVyUGFnZSkge1xuICAgICAgICAgICAgICAgIHVucmVnaXN0ZXJQYWdlKHBhZ2VJbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgICgwLCByZWFjdF8xLnVzZUVmZmVjdCkoaG9vaywgW19lbmFibGVSZWdpc3RlclVucmVnaXN0ZXJQYWdlLCBwZGYsIHBhZ2VJbmRleCwgdW5yZWdpc3RlclBhZ2VdKTtcbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbiBhIHBhZ2UgaXMgbG9hZGVkIHN1Y2Nlc3NmdWxseVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG9uTG9hZFN1Y2Nlc3MoKSB7XG4gICAgICAgIGlmIChvbkxvYWRTdWNjZXNzUHJvcHMpIHtcbiAgICAgICAgICAgIGlmICghcGFnZSB8fCAhc2NhbGUpIHtcbiAgICAgICAgICAgICAgICAvLyBJbXBvc3NpYmxlLCBidXQgVHlwZVNjcmlwdCBkb2Vzbid0IGtub3cgdGhhdFxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9uTG9hZFN1Y2Nlc3NQcm9wcygoMCwgdXRpbHNfanNfMS5tYWtlUGFnZUNhbGxiYWNrKShwYWdlLCBzY2FsZSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChfZW5hYmxlUmVnaXN0ZXJVbnJlZ2lzdGVyUGFnZSAmJiByZWdpc3RlclBhZ2UpIHtcbiAgICAgICAgICAgIGlmICghKDAsIHV0aWxzX2pzXzEuaXNQcm92aWRlZCkocGFnZUluZGV4KSB8fCAhcGFnZUVsZW1lbnQuY3VycmVudCkge1xuICAgICAgICAgICAgICAgIC8vIEltcG9zc2libGUsIGJ1dCBUeXBlU2NyaXB0IGRvZXNuJ3Qga25vdyB0aGF0XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVnaXN0ZXJQYWdlKHBhZ2VJbmRleCwgcGFnZUVsZW1lbnQuY3VycmVudCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW4gYSBwYWdlIGZhaWxlZCB0byBsb2FkXG4gICAgICovXG4gICAgZnVuY3Rpb24gb25Mb2FkRXJyb3IoKSB7XG4gICAgICAgIGlmICghcGFnZUVycm9yKSB7XG4gICAgICAgICAgICAvLyBJbXBvc3NpYmxlLCBidXQgVHlwZVNjcmlwdCBkb2Vzbid0IGtub3cgdGhhdFxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgICgwLCB3YXJuaW5nXzEuZGVmYXVsdCkoZmFsc2UsIHBhZ2VFcnJvci50b1N0cmluZygpKTtcbiAgICAgICAgaWYgKG9uTG9hZEVycm9yUHJvcHMpIHtcbiAgICAgICAgICAgIG9uTG9hZEVycm9yUHJvcHMocGFnZUVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiByZXNldFBhZ2UoKSB7XG4gICAgICAgIHBhZ2VEaXNwYXRjaCh7IHR5cGU6ICdSRVNFVCcgfSk7XG4gICAgfVxuICAgICgwLCByZWFjdF8xLnVzZUVmZmVjdCkocmVzZXRQYWdlLCBbcGFnZURpc3BhdGNoLCBwZGYsIHBhZ2VJbmRleF0pO1xuICAgIGZ1bmN0aW9uIGxvYWRQYWdlKCkge1xuICAgICAgICBpZiAoIXBkZiB8fCAhcGFnZU51bWJlcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNhbmNlbGxhYmxlID0gKDAsIG1ha2VfY2FuY2VsbGFibGVfcHJvbWlzZV8xLmRlZmF1bHQpKHBkZi5nZXRQYWdlKHBhZ2VOdW1iZXIpKTtcbiAgICAgICAgY29uc3QgcnVubmluZ1Rhc2sgPSBjYW5jZWxsYWJsZTtcbiAgICAgICAgY2FuY2VsbGFibGUucHJvbWlzZVxuICAgICAgICAgICAgLnRoZW4oKG5leHRQYWdlKSA9PiB7XG4gICAgICAgICAgICBwYWdlRGlzcGF0Y2goeyB0eXBlOiAnUkVTT0xWRScsIHZhbHVlOiBuZXh0UGFnZSB9KTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgICAgIHBhZ2VEaXNwYXRjaCh7IHR5cGU6ICdSRUpFQ1QnLCBlcnJvciB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiAoKSA9PiAoMCwgdXRpbHNfanNfMS5jYW5jZWxSdW5uaW5nVGFzaykocnVubmluZ1Rhc2spO1xuICAgIH1cbiAgICAoMCwgcmVhY3RfMS51c2VFZmZlY3QpKGxvYWRQYWdlLCBbcGFnZURpc3BhdGNoLCBwZGYsIHBhZ2VJbmRleCwgcGFnZU51bWJlciwgcmVnaXN0ZXJQYWdlXSk7XG4gICAgKDAsIHJlYWN0XzEudXNlRWZmZWN0KSgoKSA9PiB7XG4gICAgICAgIGlmIChwYWdlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFnZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIG9uTG9hZEVycm9yKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgb25Mb2FkU3VjY2VzcygpO1xuICAgIH0sIFxuICAgIC8vIE9tbWl0dGVkIGNhbGxiYWNrcyBzbyB0aGV5IGFyZSBub3QgY2FsbGVkIGV2ZXJ5IHRpbWUgdGhleSBjaGFuZ2VcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gICAgW3BhZ2UsIHNjYWxlXSk7XG4gICAgY29uc3QgY2hpbGRDb250ZXh0ID0gKDAsIHJlYWN0XzEudXNlTWVtbykoKCkgPT4gXG4gICAgLy8gVGVjaG5pY2FsbHkgdGhlcmUgY2Fubm90IGJlIHBhZ2Ugd2l0aG91dCBwYWdlSW5kZXgsIHBhZ2VOdW1iZXIsIHJvdGF0ZSBhbmQgc2NhbGUsIGJ1dCBUeXBlU2NyaXB0IGRvZXNuJ3Qga25vdyB0aGF0XG4gICAgcGFnZSAmJiAoMCwgdXRpbHNfanNfMS5pc1Byb3ZpZGVkKShwYWdlSW5kZXgpICYmIHBhZ2VOdW1iZXIgJiYgKDAsIHV0aWxzX2pzXzEuaXNQcm92aWRlZCkocm90YXRlKSAmJiAoMCwgdXRpbHNfanNfMS5pc1Byb3ZpZGVkKShzY2FsZSlcbiAgICAgICAgPyB7XG4gICAgICAgICAgICBfY2xhc3NOYW1lLFxuICAgICAgICAgICAgY2FudmFzQmFja2dyb3VuZCxcbiAgICAgICAgICAgIGN1c3RvbVRleHRSZW5kZXJlcixcbiAgICAgICAgICAgIGRldmljZVBpeGVsUmF0aW8sXG4gICAgICAgICAgICBvbkdldEFubm90YXRpb25zRXJyb3I6IG9uR2V0QW5ub3RhdGlvbnNFcnJvclByb3BzLFxuICAgICAgICAgICAgb25HZXRBbm5vdGF0aW9uc1N1Y2Nlc3M6IG9uR2V0QW5ub3RhdGlvbnNTdWNjZXNzUHJvcHMsXG4gICAgICAgICAgICBvbkdldFN0cnVjdFRyZWVFcnJvcjogb25HZXRTdHJ1Y3RUcmVlRXJyb3JQcm9wcyxcbiAgICAgICAgICAgIG9uR2V0U3RydWN0VHJlZVN1Y2Nlc3M6IG9uR2V0U3RydWN0VHJlZVN1Y2Nlc3NQcm9wcyxcbiAgICAgICAgICAgIG9uR2V0VGV4dEVycm9yOiBvbkdldFRleHRFcnJvclByb3BzLFxuICAgICAgICAgICAgb25HZXRUZXh0U3VjY2Vzczogb25HZXRUZXh0U3VjY2Vzc1Byb3BzLFxuICAgICAgICAgICAgb25SZW5kZXJBbm5vdGF0aW9uTGF5ZXJFcnJvcjogb25SZW5kZXJBbm5vdGF0aW9uTGF5ZXJFcnJvclByb3BzLFxuICAgICAgICAgICAgb25SZW5kZXJBbm5vdGF0aW9uTGF5ZXJTdWNjZXNzOiBvblJlbmRlckFubm90YXRpb25MYXllclN1Y2Nlc3NQcm9wcyxcbiAgICAgICAgICAgIG9uUmVuZGVyRXJyb3I6IG9uUmVuZGVyRXJyb3JQcm9wcyxcbiAgICAgICAgICAgIG9uUmVuZGVyU3VjY2Vzczogb25SZW5kZXJTdWNjZXNzUHJvcHMsXG4gICAgICAgICAgICBvblJlbmRlclRleHRMYXllckVycm9yOiBvblJlbmRlclRleHRMYXllckVycm9yUHJvcHMsXG4gICAgICAgICAgICBvblJlbmRlclRleHRMYXllclN1Y2Nlc3M6IG9uUmVuZGVyVGV4dExheWVyU3VjY2Vzc1Byb3BzLFxuICAgICAgICAgICAgcGFnZSxcbiAgICAgICAgICAgIHBhZ2VJbmRleCxcbiAgICAgICAgICAgIHBhZ2VOdW1iZXIsXG4gICAgICAgICAgICByZW5kZXJGb3JtcyxcbiAgICAgICAgICAgIHJlbmRlclRleHRMYXllcjogcmVuZGVyVGV4dExheWVyUHJvcHMsXG4gICAgICAgICAgICByb3RhdGUsXG4gICAgICAgICAgICBzY2FsZSxcbiAgICAgICAgfVxuICAgICAgICA6IG51bGwsIFtcbiAgICAgICAgX2NsYXNzTmFtZSxcbiAgICAgICAgY2FudmFzQmFja2dyb3VuZCxcbiAgICAgICAgY3VzdG9tVGV4dFJlbmRlcmVyLFxuICAgICAgICBkZXZpY2VQaXhlbFJhdGlvLFxuICAgICAgICBvbkdldEFubm90YXRpb25zRXJyb3JQcm9wcyxcbiAgICAgICAgb25HZXRBbm5vdGF0aW9uc1N1Y2Nlc3NQcm9wcyxcbiAgICAgICAgb25HZXRTdHJ1Y3RUcmVlRXJyb3JQcm9wcyxcbiAgICAgICAgb25HZXRTdHJ1Y3RUcmVlU3VjY2Vzc1Byb3BzLFxuICAgICAgICBvbkdldFRleHRFcnJvclByb3BzLFxuICAgICAgICBvbkdldFRleHRTdWNjZXNzUHJvcHMsXG4gICAgICAgIG9uUmVuZGVyQW5ub3RhdGlvbkxheWVyRXJyb3JQcm9wcyxcbiAgICAgICAgb25SZW5kZXJBbm5vdGF0aW9uTGF5ZXJTdWNjZXNzUHJvcHMsXG4gICAgICAgIG9uUmVuZGVyRXJyb3JQcm9wcyxcbiAgICAgICAgb25SZW5kZXJTdWNjZXNzUHJvcHMsXG4gICAgICAgIG9uUmVuZGVyVGV4dExheWVyRXJyb3JQcm9wcyxcbiAgICAgICAgb25SZW5kZXJUZXh0TGF5ZXJTdWNjZXNzUHJvcHMsXG4gICAgICAgIHBhZ2UsXG4gICAgICAgIHBhZ2VJbmRleCxcbiAgICAgICAgcGFnZU51bWJlcixcbiAgICAgICAgcmVuZGVyRm9ybXMsXG4gICAgICAgIHJlbmRlclRleHRMYXllclByb3BzLFxuICAgICAgICByb3RhdGUsXG4gICAgICAgIHNjYWxlLFxuICAgIF0pO1xuICAgIGNvbnN0IGV2ZW50UHJvcHMgPSAoMCwgcmVhY3RfMS51c2VNZW1vKSgoKSA9PiAoMCwgbWFrZV9ldmVudF9wcm9wc18xLmRlZmF1bHQpKG90aGVyUHJvcHMsICgpID0+IHBhZ2UgPyAoc2NhbGUgPyAoMCwgdXRpbHNfanNfMS5tYWtlUGFnZUNhbGxiYWNrKShwYWdlLCBzY2FsZSkgOiB1bmRlZmluZWQpIDogcGFnZSksIFtvdGhlclByb3BzLCBwYWdlLCBzY2FsZV0pO1xuICAgIGNvbnN0IHBhZ2VLZXkgPSBgJHtwYWdlSW5kZXh9QCR7c2NhbGV9LyR7cm90YXRlfWA7XG4gICAgY29uc3QgcGFnZUtleU5vU2NhbGUgPSBgJHtwYWdlSW5kZXh9LyR7cm90YXRlfWA7XG4gICAgZnVuY3Rpb24gcmVuZGVyTWFpbkxheWVyKCkge1xuICAgICAgICBzd2l0Y2ggKHJlbmRlck1vZGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2N1c3RvbSc6IHtcbiAgICAgICAgICAgICAgICAoMCwgdGlueV9pbnZhcmlhbnRfMS5kZWZhdWx0KShDdXN0b21SZW5kZXJlciwgYHJlbmRlck1vZGUgd2FzIHNldCB0byBcImN1c3RvbVwiLCBidXQgbm8gY3VzdG9tUmVuZGVyZXIgd2FzIHBhc3NlZC5gKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVhY3RfMS5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoQ3VzdG9tUmVuZGVyZXIsIHsga2V5OiBgJHtwYWdlS2V5fV9jdXN0b21gIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnbm9uZSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBjYXNlICdzdmcnOlxuICAgICAgICAgICAgICAgIHJldHVybiByZWFjdF8xLmRlZmF1bHQuY3JlYXRlRWxlbWVudChQYWdlU1ZHX2pzXzEuZGVmYXVsdCwgeyBrZXk6IGAke3BhZ2VLZXlOb1NjYWxlfV9zdmdgIH0pO1xuICAgICAgICAgICAgY2FzZSAnY2FudmFzJzpcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlYWN0XzEuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFBhZ2VDYW52YXNfanNfMS5kZWZhdWx0LCB7IGtleTogYCR7cGFnZUtleX1fY2FudmFzYCwgY2FudmFzUmVmOiBjYW52YXNSZWYgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcmVuZGVyVGV4dExheWVyKCkge1xuICAgICAgICBpZiAoIXJlbmRlclRleHRMYXllclByb3BzKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVhY3RfMS5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoVGV4dExheWVyX2pzXzEuZGVmYXVsdCwgeyBrZXk6IGAke3BhZ2VLZXl9X3RleHRgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZW5kZXJBbm5vdGF0aW9uTGF5ZXIoKSB7XG4gICAgICAgIGlmICghcmVuZGVyQW5ub3RhdGlvbkxheWVyUHJvcHMpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBcyBvZiBub3csIFBERi5qcyAyLjAuOTQzIHJldHVybnMgd2FybmluZ3Mgb24gdW5pbXBsZW1lbnRlZCBhbm5vdGF0aW9ucyBpbiBTVkcgbW9kZS5cbiAgICAgICAgICogVGhlcmVmb3JlLCBhcyBhIGZhbGxiYWNrLCB3ZSByZW5kZXIgXCJ0cmFkaXRpb25hbFwiIEFubm90YXRpb25MYXllciBjb21wb25lbnQuXG4gICAgICAgICAqL1xuICAgICAgICByZXR1cm4gcmVhY3RfMS5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoQW5ub3RhdGlvbkxheWVyX2pzXzEuZGVmYXVsdCwgeyBrZXk6IGAke3BhZ2VLZXl9X2Fubm90YXRpb25zYCB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVuZGVyQ2hpbGRyZW4oKSB7XG4gICAgICAgIHJldHVybiAocmVhY3RfMS5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoUGFnZUNvbnRleHRfanNfMS5kZWZhdWx0LlByb3ZpZGVyLCB7IHZhbHVlOiBjaGlsZENvbnRleHQgfSxcbiAgICAgICAgICAgIHJlbmRlck1haW5MYXllcigpLFxuICAgICAgICAgICAgcmVuZGVyVGV4dExheWVyKCksXG4gICAgICAgICAgICByZW5kZXJBbm5vdGF0aW9uTGF5ZXIoKSxcbiAgICAgICAgICAgIGNoaWxkcmVuKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlbmRlckNvbnRlbnQoKSB7XG4gICAgICAgIGlmICghcGFnZU51bWJlcikge1xuICAgICAgICAgICAgcmV0dXJuIHJlYWN0XzEuZGVmYXVsdC5jcmVhdGVFbGVtZW50KE1lc3NhZ2VfanNfMS5kZWZhdWx0LCB7IHR5cGU6IFwibm8tZGF0YVwiIH0sIHR5cGVvZiBub0RhdGEgPT09ICdmdW5jdGlvbicgPyBub0RhdGEoKSA6IG5vRGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBkZiA9PT0gbnVsbCB8fCBwYWdlID09PSB1bmRlZmluZWQgfHwgcGFnZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIChyZWFjdF8xLmRlZmF1bHQuY3JlYXRlRWxlbWVudChNZXNzYWdlX2pzXzEuZGVmYXVsdCwgeyB0eXBlOiBcImxvYWRpbmdcIiB9LCB0eXBlb2YgbG9hZGluZyA9PT0gJ2Z1bmN0aW9uJyA/IGxvYWRpbmcoKSA6IGxvYWRpbmcpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGRmID09PSBmYWxzZSB8fCBwYWdlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlYWN0XzEuZGVmYXVsdC5jcmVhdGVFbGVtZW50KE1lc3NhZ2VfanNfMS5kZWZhdWx0LCB7IHR5cGU6IFwiZXJyb3JcIiB9LCB0eXBlb2YgZXJyb3IgPT09ICdmdW5jdGlvbicgPyBlcnJvcigpIDogZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZW5kZXJDaGlsZHJlbigpO1xuICAgIH1cbiAgICByZXR1cm4gKHJlYWN0XzEuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIE9iamVjdC5hc3NpZ24oeyBjbGFzc05hbWU6ICgwLCBjbHN4XzEuZGVmYXVsdCkoX2NsYXNzTmFtZSwgY2xhc3NOYW1lKSwgXCJkYXRhLXBhZ2UtbnVtYmVyXCI6IHBhZ2VOdW1iZXIsIHJlZjogKDAsIG1lcmdlX3JlZnNfMS5kZWZhdWx0KShpbnB1dFJlZiwgcGFnZUVsZW1lbnQpLCBzdHlsZToge1xuICAgICAgICAgICAgWyctLXNjYWxlLWZhY3RvciddOiBgJHtzY2FsZX1gLFxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBjYW52YXNCYWNrZ3JvdW5kIHx8ICd3aGl0ZScsXG4gICAgICAgICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcbiAgICAgICAgICAgIG1pbldpZHRoOiAnbWluLWNvbnRlbnQnLFxuICAgICAgICAgICAgbWluSGVpZ2h0OiAnbWluLWNvbnRlbnQnLFxuICAgICAgICB9IH0sIGV2ZW50UHJvcHMpLCByZW5kZXJDb250ZW50KCkpKTtcbn07XG5jb25zdCBpc0Z1bmN0aW9uT3JOb2RlID0gcHJvcF90eXBlc18xLmRlZmF1bHQub25lT2ZUeXBlKFtwcm9wX3R5cGVzXzEuZGVmYXVsdC5mdW5jLCBwcm9wX3R5cGVzXzEuZGVmYXVsdC5ub2RlXSk7XG5QYWdlLnByb3BUeXBlcyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcHJvcFR5cGVzX2pzXzEuZXZlbnRQcm9wcyksIHsgY2FudmFzQmFja2dyb3VuZDogcHJvcF90eXBlc18xLmRlZmF1bHQuc3RyaW5nLCBjYW52YXNSZWY6IHByb3BUeXBlc19qc18xLmlzUmVmLCBjaGlsZHJlbjogcHJvcF90eXBlc18xLmRlZmF1bHQubm9kZSwgY2xhc3NOYW1lOiBwcm9wVHlwZXNfanNfMS5pc0NsYXNzTmFtZSwgY3VzdG9tUmVuZGVyZXI6IHByb3BfdHlwZXNfMS5kZWZhdWx0LmZ1bmMsIGN1c3RvbVRleHRSZW5kZXJlcjogcHJvcF90eXBlc18xLmRlZmF1bHQuZnVuYywgZGV2aWNlUGl4ZWxSYXRpbzogcHJvcF90eXBlc18xLmRlZmF1bHQubnVtYmVyLCBlcnJvcjogaXNGdW5jdGlvbk9yTm9kZSwgaGVpZ2h0OiBwcm9wX3R5cGVzXzEuZGVmYXVsdC5udW1iZXIsIGltYWdlUmVzb3VyY2VzUGF0aDogcHJvcF90eXBlc18xLmRlZmF1bHQuc3RyaW5nLCBpbnB1dFJlZjogcHJvcFR5cGVzX2pzXzEuaXNSZWYsIGxvYWRpbmc6IGlzRnVuY3Rpb25Pck5vZGUsIG5vRGF0YTogaXNGdW5jdGlvbk9yTm9kZSwgb25HZXRUZXh0RXJyb3I6IHByb3BfdHlwZXNfMS5kZWZhdWx0LmZ1bmMsIG9uR2V0VGV4dFN1Y2Nlc3M6IHByb3BfdHlwZXNfMS5kZWZhdWx0LmZ1bmMsIG9uTG9hZEVycm9yOiBwcm9wX3R5cGVzXzEuZGVmYXVsdC5mdW5jLCBvbkxvYWRTdWNjZXNzOiBwcm9wX3R5cGVzXzEuZGVmYXVsdC5mdW5jLCBvblJlbmRlckVycm9yOiBwcm9wX3R5cGVzXzEuZGVmYXVsdC5mdW5jLCBvblJlbmRlclN1Y2Nlc3M6IHByb3BfdHlwZXNfMS5kZWZhdWx0LmZ1bmMsIG9uUmVuZGVyVGV4dExheWVyRXJyb3I6IHByb3BfdHlwZXNfMS5kZWZhdWx0LmZ1bmMsIG9uUmVuZGVyVGV4dExheWVyU3VjY2VzczogcHJvcF90eXBlc18xLmRlZmF1bHQuZnVuYywgcGFnZUluZGV4OiBwcm9wVHlwZXNfanNfMS5pc1BhZ2VJbmRleCwgcGFnZU51bWJlcjogcHJvcFR5cGVzX2pzXzEuaXNQYWdlTnVtYmVyLCBwZGY6IHByb3BUeXBlc19qc18xLmlzUGRmLCByZW5kZXJBbm5vdGF0aW9uTGF5ZXI6IHByb3BfdHlwZXNfMS5kZWZhdWx0LmJvb2wsIHJlbmRlckZvcm1zOiBwcm9wX3R5cGVzXzEuZGVmYXVsdC5ib29sLCByZW5kZXJNb2RlOiBwcm9wVHlwZXNfanNfMS5pc1JlbmRlck1vZGUsIHJlbmRlclRleHRMYXllcjogcHJvcF90eXBlc18xLmRlZmF1bHQuYm9vbCwgcm90YXRlOiBwcm9wVHlwZXNfanNfMS5pc1JvdGF0ZSwgc2NhbGU6IHByb3BfdHlwZXNfMS5kZWZhdWx0Lm51bWJlciwgd2lkdGg6IHByb3BfdHlwZXNfMS5kZWZhdWx0Lm51bWJlciB9KTtcbmV4cG9ydHMuZGVmYXVsdCA9IFBhZ2U7XG4iXSwibmFtZXMiOlsiX19jcmVhdGVCaW5kaW5nIiwiT2JqZWN0IiwiY3JlYXRlIiwibyIsIm0iLCJrIiwiazIiLCJ1bmRlZmluZWQiLCJkZXNjIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiX19lc01vZHVsZSIsIndyaXRhYmxlIiwiY29uZmlndXJhYmxlIiwiZW51bWVyYWJsZSIsImdldCIsImRlZmluZVByb3BlcnR5IiwiX19zZXRNb2R1bGVEZWZhdWx0IiwidiIsInZhbHVlIiwiX19pbXBvcnRTdGFyIiwibW9kIiwicmVzdWx0IiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiX19yZXN0IiwicyIsImUiLCJ0IiwicCIsImluZGV4T2YiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJpIiwibGVuZ3RoIiwicHJvcGVydHlJc0VudW1lcmFibGUiLCJfX2ltcG9ydERlZmF1bHQiLCJleHBvcnRzIiwicmVhY3RfMSIsInJlcXVpcmUiLCJwcm9wX3R5cGVzXzEiLCJtYWtlX2NhbmNlbGxhYmxlX3Byb21pc2VfMSIsIm1ha2VfZXZlbnRfcHJvcHNfMSIsImNsc3hfMSIsIm1lcmdlX3JlZnNfMSIsInRpbnlfaW52YXJpYW50XzEiLCJ3YXJuaW5nXzEiLCJQYWdlQ29udGV4dF9qc18xIiwiTWVzc2FnZV9qc18xIiwiUGFnZUNhbnZhc19qc18xIiwiUGFnZVNWR19qc18xIiwiVGV4dExheWVyX2pzXzEiLCJBbm5vdGF0aW9uTGF5ZXJfanNfMSIsInV0aWxzX2pzXzEiLCJ1c2VEb2N1bWVudENvbnRleHRfanNfMSIsInVzZVJlc29sdmVyX2pzXzEiLCJwcm9wVHlwZXNfanNfMSIsImRlZmF1bHRTY2FsZSIsIlBhZ2UiLCJwcm9wcyIsImRvY3VtZW50Q29udGV4dCIsImRlZmF1bHQiLCJtZXJnZWRQcm9wcyIsImFzc2lnbiIsIl9jbGFzc05hbWUiLCJfZW5hYmxlUmVnaXN0ZXJVbnJlZ2lzdGVyUGFnZSIsImNhbnZhc0JhY2tncm91bmQiLCJjYW52YXNSZWYiLCJjaGlsZHJlbiIsImNsYXNzTmFtZSIsImN1c3RvbVJlbmRlcmVyIiwiQ3VzdG9tUmVuZGVyZXIiLCJjdXN0b21UZXh0UmVuZGVyZXIiLCJkZXZpY2VQaXhlbFJhdGlvIiwiZXJyb3IiLCJoZWlnaHQiLCJpbnB1dFJlZiIsImxvYWRpbmciLCJub0RhdGEiLCJvbkdldEFubm90YXRpb25zRXJyb3IiLCJvbkdldEFubm90YXRpb25zRXJyb3JQcm9wcyIsIm9uR2V0QW5ub3RhdGlvbnNTdWNjZXNzIiwib25HZXRBbm5vdGF0aW9uc1N1Y2Nlc3NQcm9wcyIsIm9uR2V0U3RydWN0VHJlZUVycm9yIiwib25HZXRTdHJ1Y3RUcmVlRXJyb3JQcm9wcyIsIm9uR2V0U3RydWN0VHJlZVN1Y2Nlc3MiLCJvbkdldFN0cnVjdFRyZWVTdWNjZXNzUHJvcHMiLCJvbkdldFRleHRFcnJvciIsIm9uR2V0VGV4dEVycm9yUHJvcHMiLCJvbkdldFRleHRTdWNjZXNzIiwib25HZXRUZXh0U3VjY2Vzc1Byb3BzIiwib25Mb2FkRXJyb3IiLCJvbkxvYWRFcnJvclByb3BzIiwib25Mb2FkU3VjY2VzcyIsIm9uTG9hZFN1Y2Nlc3NQcm9wcyIsIm9uUmVuZGVyQW5ub3RhdGlvbkxheWVyRXJyb3IiLCJvblJlbmRlckFubm90YXRpb25MYXllckVycm9yUHJvcHMiLCJvblJlbmRlckFubm90YXRpb25MYXllclN1Y2Nlc3MiLCJvblJlbmRlckFubm90YXRpb25MYXllclN1Y2Nlc3NQcm9wcyIsIm9uUmVuZGVyRXJyb3IiLCJvblJlbmRlckVycm9yUHJvcHMiLCJvblJlbmRlclN1Y2Nlc3MiLCJvblJlbmRlclN1Y2Nlc3NQcm9wcyIsIm9uUmVuZGVyVGV4dExheWVyRXJyb3IiLCJvblJlbmRlclRleHRMYXllckVycm9yUHJvcHMiLCJvblJlbmRlclRleHRMYXllclN1Y2Nlc3MiLCJvblJlbmRlclRleHRMYXllclN1Y2Nlc3NQcm9wcyIsInBhZ2VJbmRleCIsInBhZ2VJbmRleFByb3BzIiwicGFnZU51bWJlciIsInBhZ2VOdW1iZXJQcm9wcyIsInBkZiIsInJlZ2lzdGVyUGFnZSIsInJlbmRlckFubm90YXRpb25MYXllciIsInJlbmRlckFubm90YXRpb25MYXllclByb3BzIiwicmVuZGVyRm9ybXMiLCJyZW5kZXJNb2RlIiwicmVuZGVyVGV4dExheWVyIiwicmVuZGVyVGV4dExheWVyUHJvcHMiLCJyb3RhdGUiLCJyb3RhdGVQcm9wcyIsInNjYWxlIiwic2NhbGVQcm9wcyIsInVucmVnaXN0ZXJQYWdlIiwid2lkdGgiLCJvdGhlclByb3BzIiwicGFnZVN0YXRlIiwicGFnZURpc3BhdGNoIiwicGFnZSIsInBhZ2VFcnJvciIsInBhZ2VFbGVtZW50IiwidXNlUmVmIiwiaXNQcm92aWRlZCIsInVzZU1lbW8iLCJwYWdlU2NhbGUiLCJzY2FsZVdpdGhEZWZhdWx0Iiwidmlld3BvcnQiLCJnZXRWaWV3cG9ydCIsInJvdGF0aW9uIiwiaG9vayIsInVzZUVmZmVjdCIsIm1ha2VQYWdlQ2FsbGJhY2siLCJjdXJyZW50IiwidG9TdHJpbmciLCJyZXNldFBhZ2UiLCJ0eXBlIiwibG9hZFBhZ2UiLCJjYW5jZWxsYWJsZSIsImdldFBhZ2UiLCJydW5uaW5nVGFzayIsInByb21pc2UiLCJ0aGVuIiwibmV4dFBhZ2UiLCJjYXRjaCIsImNhbmNlbFJ1bm5pbmdUYXNrIiwiY2hpbGRDb250ZXh0IiwiZXZlbnRQcm9wcyIsInBhZ2VLZXkiLCJwYWdlS2V5Tm9TY2FsZSIsInJlbmRlck1haW5MYXllciIsImNyZWF0ZUVsZW1lbnQiLCJrZXkiLCJyZW5kZXJDaGlsZHJlbiIsIlByb3ZpZGVyIiwicmVuZGVyQ29udGVudCIsInJlZiIsInN0eWxlIiwiYmFja2dyb3VuZENvbG9yIiwicG9zaXRpb24iLCJtaW5XaWR0aCIsIm1pbkhlaWdodCIsImlzRnVuY3Rpb25Pck5vZGUiLCJvbmVPZlR5cGUiLCJmdW5jIiwibm9kZSIsInByb3BUeXBlcyIsInN0cmluZyIsImlzUmVmIiwiaXNDbGFzc05hbWUiLCJudW1iZXIiLCJpbWFnZVJlc291cmNlc1BhdGgiLCJpc1BhZ2VJbmRleCIsImlzUGFnZU51bWJlciIsImlzUGRmIiwiYm9vbCIsImlzUmVuZGVyTW9kZSIsImlzUm90YXRlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-pdf/dist/cjs/Page.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-pdf/dist/cjs/Page/AnnotationLayer.js":
/*!*****************************************************************!*\
  !*** ./node_modules/react-pdf/dist/cjs/Page/AnnotationLayer.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/* __next_internal_client_entry_do_not_use__  cjs */ \nvar __createBinding = (void 0) && (void 0).__createBinding || (Object.create ? function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n        desc = {\n            enumerable: true,\n            get: function() {\n                return m[k];\n            }\n        };\n    }\n    Object.defineProperty(o, k2, desc);\n} : function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n});\nvar __setModuleDefault = (void 0) && (void 0).__setModuleDefault || (Object.create ? function(o, v) {\n    Object.defineProperty(o, \"default\", {\n        enumerable: true,\n        value: v\n    });\n} : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (void 0) && (void 0).__importStar || function(mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) {\n        for(var k in mod)if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    }\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (void 0) && (void 0).__importDefault || function(mod) {\n    return mod && mod.__esModule ? mod : {\n        \"default\": mod\n    };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nconst react_1 = __importStar(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"));\nconst make_cancellable_promise_1 = __importDefault(__webpack_require__(/*! make-cancellable-promise */ \"(app-pages-browser)/./node_modules/make-cancellable-promise/dist/cjs/index.js\"));\nconst clsx_1 = __importDefault(__webpack_require__(/*! clsx */ \"(app-pages-browser)/./node_modules/clsx/dist/clsx.js\"));\nconst tiny_invariant_1 = __importDefault(__webpack_require__(/*! tiny-invariant */ \"(app-pages-browser)/./node_modules/tiny-invariant/dist/tiny-invariant.cjs.js\"));\nconst warning_1 = __importDefault(__webpack_require__(/*! warning */ \"(app-pages-browser)/./node_modules/warning/warning.js\"));\nconst pdfjs_js_1 = __importDefault(__webpack_require__(/*! ../pdfjs.js */ \"(app-pages-browser)/./node_modules/react-pdf/dist/cjs/pdfjs.js\"));\nconst useDocumentContext_js_1 = __importDefault(__webpack_require__(/*! ../shared/hooks/useDocumentContext.js */ \"(app-pages-browser)/./node_modules/react-pdf/dist/cjs/shared/hooks/useDocumentContext.js\"));\nconst usePageContext_js_1 = __importDefault(__webpack_require__(/*! ../shared/hooks/usePageContext.js */ \"(app-pages-browser)/./node_modules/react-pdf/dist/cjs/shared/hooks/usePageContext.js\"));\nconst useResolver_js_1 = __importDefault(__webpack_require__(/*! ../shared/hooks/useResolver.js */ \"(app-pages-browser)/./node_modules/react-pdf/dist/cjs/shared/hooks/useResolver.js\"));\nconst utils_js_1 = __webpack_require__(/*! ../shared/utils.js */ \"(app-pages-browser)/./node_modules/react-pdf/dist/cjs/shared/utils.js\");\nfunction AnnotationLayer() {\n    const documentContext = (0, useDocumentContext_js_1.default)();\n    const pageContext = (0, usePageContext_js_1.default)();\n    (0, tiny_invariant_1.default)(pageContext, \"Unable to find Page context.\");\n    const mergedProps = Object.assign(Object.assign({}, documentContext), pageContext);\n    const { imageResourcesPath, linkService, onGetAnnotationsError: onGetAnnotationsErrorProps, onGetAnnotationsSuccess: onGetAnnotationsSuccessProps, onRenderAnnotationLayerError: onRenderAnnotationLayerErrorProps, onRenderAnnotationLayerSuccess: onRenderAnnotationLayerSuccessProps, page, pdf, renderForms, rotate, scale = 1 } = mergedProps;\n    (0, tiny_invariant_1.default)(pdf, \"Attempted to load page annotations, but no document was specified. Wrap <Page /> in a <Document /> or pass explicit `pdf` prop.\");\n    (0, tiny_invariant_1.default)(page, \"Attempted to load page annotations, but no page was specified.\");\n    (0, tiny_invariant_1.default)(linkService, \"Attempted to load page annotations, but no linkService was specified.\");\n    const [annotationsState, annotationsDispatch] = (0, useResolver_js_1.default)();\n    const { value: annotations, error: annotationsError } = annotationsState;\n    const layerElement = (0, react_1.useRef)(null);\n    (0, warning_1.default)(parseInt(window.getComputedStyle(document.body).getPropertyValue(\"--react-pdf-annotation-layer\"), 10) === 1, \"AnnotationLayer styles not found. Read more: https://github.com/wojtekmaj/react-pdf#support-for-annotations\");\n    function onLoadSuccess() {\n        if (!annotations) {\n            // Impossible, but TypeScript doesn't know that\n            return;\n        }\n        if (onGetAnnotationsSuccessProps) {\n            onGetAnnotationsSuccessProps(annotations);\n        }\n    }\n    function onLoadError() {\n        if (!annotationsError) {\n            // Impossible, but TypeScript doesn't know that\n            return;\n        }\n        (0, warning_1.default)(false, annotationsError.toString());\n        if (onGetAnnotationsErrorProps) {\n            onGetAnnotationsErrorProps(annotationsError);\n        }\n    }\n    function resetAnnotations() {\n        annotationsDispatch({\n            type: \"RESET\"\n        });\n    }\n    (0, react_1.useEffect)(resetAnnotations, [\n        annotationsDispatch,\n        page\n    ]);\n    function loadAnnotations() {\n        if (!page) {\n            return;\n        }\n        const cancellable = (0, make_cancellable_promise_1.default)(page.getAnnotations());\n        const runningTask = cancellable;\n        cancellable.promise.then((nextAnnotations)=>{\n            annotationsDispatch({\n                type: \"RESOLVE\",\n                value: nextAnnotations\n            });\n        }).catch((error)=>{\n            annotationsDispatch({\n                type: \"REJECT\",\n                error\n            });\n        });\n        return ()=>{\n            (0, utils_js_1.cancelRunningTask)(runningTask);\n        };\n    }\n    (0, react_1.useEffect)(loadAnnotations, [\n        annotationsDispatch,\n        page,\n        renderForms\n    ]);\n    (0, react_1.useEffect)(()=>{\n        if (annotations === undefined) {\n            return;\n        }\n        if (annotations === false) {\n            onLoadError();\n            return;\n        }\n        onLoadSuccess();\n    }, // Ommitted callbacks so they are not called every time they change\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [\n        annotations\n    ]);\n    function onRenderSuccess() {\n        if (onRenderAnnotationLayerSuccessProps) {\n            onRenderAnnotationLayerSuccessProps();\n        }\n    }\n    function onRenderError(error) {\n        (0, warning_1.default)(false, \"\".concat(error));\n        if (onRenderAnnotationLayerErrorProps) {\n            onRenderAnnotationLayerErrorProps(error);\n        }\n    }\n    const viewport = (0, react_1.useMemo)(()=>page.getViewport({\n            scale,\n            rotation: rotate\n        }), [\n        page,\n        rotate,\n        scale\n    ]);\n    function renderAnnotationLayer() {\n        if (!pdf || !page || !linkService || !annotations) {\n            return;\n        }\n        const { current: layer } = layerElement;\n        if (!layer) {\n            return;\n        }\n        const clonedViewport = viewport.clone({\n            dontFlip: true\n        });\n        const annotationLayerParameters = {\n            accessibilityManager: null,\n            annotationCanvasMap: null,\n            div: layer,\n            l10n: null,\n            page,\n            viewport: clonedViewport\n        };\n        const renderParameters = {\n            annotations,\n            annotationStorage: pdf.annotationStorage,\n            div: layer,\n            // See https://github.com/mozilla/pdf.js/issues/17029\n            downloadManager: null,\n            imageResourcesPath,\n            linkService,\n            page,\n            renderForms,\n            viewport: clonedViewport\n        };\n        layer.innerHTML = \"\";\n        try {\n            new pdfjs_js_1.default.AnnotationLayer(annotationLayerParameters).render(renderParameters);\n            // Intentional immediate callback\n            onRenderSuccess();\n        } catch (error) {\n            onRenderError(error);\n        }\n        return ()=>{\n        // TODO: Cancel running task?\n        };\n    }\n    (0, react_1.useEffect)(renderAnnotationLayer, // Ommitted callbacks so they are not called every time they change\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [\n        annotations,\n        imageResourcesPath,\n        linkService,\n        page,\n        renderForms,\n        viewport\n    ]);\n    return react_1.default.createElement(\"div\", {\n        className: (0, clsx_1.default)(\"react-pdf__Page__annotations\", \"annotationLayer\"),\n        ref: layerElement\n    });\n}\n_c = AnnotationLayer;\nexports[\"default\"] = AnnotationLayer;\nvar _c;\n$RefreshReg$(_c, \"AnnotationLayer\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1wZGYvZGlzdC9janMvUGFnZS9Bbm5vdGF0aW9uTGF5ZXIuanMiLCJtYXBwaW5ncyI6InFEQUFhO0FBRWIsSUFBSUEsa0JBQWtCLENBQUMsTUFBRyxLQUFLLE9BQUcsRUFBRUEsZUFBZSxJQUFNQyxDQUFBQSxPQUFPQyxNQUFNLEdBQUksU0FBU0MsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLENBQUMsRUFBRUMsRUFBRTtJQUMxRixJQUFJQSxPQUFPQyxXQUFXRCxLQUFLRDtJQUMzQixJQUFJRyxPQUFPUCxPQUFPUSx3QkFBd0IsQ0FBQ0wsR0FBR0M7SUFDOUMsSUFBSSxDQUFDRyxRQUFTLFVBQVNBLE9BQU8sQ0FBQ0osRUFBRU0sVUFBVSxHQUFHRixLQUFLRyxRQUFRLElBQUlILEtBQUtJLFlBQVksR0FBRztRQUNqRkosT0FBTztZQUFFSyxZQUFZO1lBQU1DLEtBQUs7Z0JBQWEsT0FBT1YsQ0FBQyxDQUFDQyxFQUFFO1lBQUU7UUFBRTtJQUM5RDtJQUNBSixPQUFPYyxjQUFjLENBQUNaLEdBQUdHLElBQUlFO0FBQ2pDLElBQU0sU0FBU0wsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLENBQUMsRUFBRUMsRUFBRTtJQUN0QixJQUFJQSxPQUFPQyxXQUFXRCxLQUFLRDtJQUMzQkYsQ0FBQyxDQUFDRyxHQUFHLEdBQUdGLENBQUMsQ0FBQ0MsRUFBRTtBQUNoQixDQUFDO0FBQ0QsSUFBSVcscUJBQXFCLENBQUMsTUFBRyxLQUFLLE9BQUcsRUFBRUEsa0JBQWtCLElBQU1mLENBQUFBLE9BQU9DLE1BQU0sR0FBSSxTQUFTQyxDQUFDLEVBQUVjLENBQUM7SUFDekZoQixPQUFPYyxjQUFjLENBQUNaLEdBQUcsV0FBVztRQUFFVSxZQUFZO1FBQU1LLE9BQU9EO0lBQUU7QUFDckUsSUFBSyxTQUFTZCxDQUFDLEVBQUVjLENBQUM7SUFDZGQsQ0FBQyxDQUFDLFVBQVUsR0FBR2M7QUFDbkI7QUFDQSxJQUFJRSxlQUFlLENBQUMsTUFBRyxLQUFLLE9BQUcsRUFBRUEsWUFBWSxJQUFLLFNBQVVDLEdBQUc7SUFDM0QsSUFBSUEsT0FBT0EsSUFBSVYsVUFBVSxFQUFFLE9BQU9VO0lBQ2xDLElBQUlDLFNBQVMsQ0FBQztJQUNkLElBQUlELE9BQU8sTUFBTTtRQUFBLElBQUssSUFBSWYsS0FBS2UsSUFBSyxJQUFJZixNQUFNLGFBQWFKLE9BQU9xQixTQUFTLENBQUNDLGNBQWMsQ0FBQ0MsSUFBSSxDQUFDSixLQUFLZixJQUFJTCxnQkFBZ0JxQixRQUFRRCxLQUFLZjtJQUFFO0lBQ3hJVyxtQkFBbUJLLFFBQVFEO0lBQzNCLE9BQU9DO0FBQ1g7QUFDQSxJQUFJSSxrQkFBa0IsQ0FBQyxNQUFHLEtBQUssT0FBRyxFQUFFQSxlQUFlLElBQUssU0FBVUwsR0FBRztJQUNqRSxPQUFPLE9BQVFBLElBQUlWLFVBQVUsR0FBSVUsTUFBTTtRQUFFLFdBQVdBO0lBQUk7QUFDNUQ7QUFDQW5CLDhDQUE2QztJQUFFaUIsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3RCxNQUFNUyxVQUFVUixhQUFhUyxtQkFBT0EsQ0FBQyxtRkFBTztBQUM1QyxNQUFNQyw2QkFBNkJKLGdCQUFnQkcsbUJBQU9BLENBQUMsK0dBQTBCO0FBQ3JGLE1BQU1FLFNBQVNMLGdCQUFnQkcsbUJBQU9BLENBQUMsa0VBQU07QUFDN0MsTUFBTUcsbUJBQW1CTixnQkFBZ0JHLG1CQUFPQSxDQUFDLG9HQUFnQjtBQUNqRSxNQUFNSSxZQUFZUCxnQkFBZ0JHLG1CQUFPQSxDQUFDLHNFQUFTO0FBQ25ELE1BQU1LLGFBQWFSLGdCQUFnQkcsbUJBQU9BLENBQUMsbUZBQWE7QUFDeEQsTUFBTU0sMEJBQTBCVCxnQkFBZ0JHLG1CQUFPQSxDQUFDLHVJQUF1QztBQUMvRixNQUFNTyxzQkFBc0JWLGdCQUFnQkcsbUJBQU9BLENBQUMsK0hBQW1DO0FBQ3ZGLE1BQU1RLG1CQUFtQlgsZ0JBQWdCRyxtQkFBT0EsQ0FBQyx5SEFBZ0M7QUFDakYsTUFBTVMsYUFBYVQsbUJBQU9BLENBQUMsaUdBQW9CO0FBQy9DLFNBQVNVO0lBQ0wsTUFBTUMsa0JBQWtCLENBQUMsR0FBR0wsd0JBQXdCTSxPQUFPO0lBQzNELE1BQU1DLGNBQWMsQ0FBQyxHQUFHTixvQkFBb0JLLE9BQU87SUFDbEQsSUFBR1QsaUJBQWlCUyxPQUFPLEVBQUVDLGFBQWE7SUFDM0MsTUFBTUMsY0FBY3pDLE9BQU8wQyxNQUFNLENBQUMxQyxPQUFPMEMsTUFBTSxDQUFDLENBQUMsR0FBR0osa0JBQWtCRTtJQUN0RSxNQUFNLEVBQUVHLGtCQUFrQixFQUFFQyxXQUFXLEVBQUVDLHVCQUF1QkMsMEJBQTBCLEVBQUVDLHlCQUF5QkMsNEJBQTRCLEVBQUVDLDhCQUE4QkMsaUNBQWlDLEVBQUVDLGdDQUFnQ0MsbUNBQW1DLEVBQUVDLElBQUksRUFBRUMsR0FBRyxFQUFFQyxXQUFXLEVBQUVDLE1BQU0sRUFBRUMsUUFBUSxDQUFDLEVBQUcsR0FBR2hCO0lBQ3ZVLElBQUdYLGlCQUFpQlMsT0FBTyxFQUFFZSxLQUFLO0lBQ2xDLElBQUd4QixpQkFBaUJTLE9BQU8sRUFBRWMsTUFBTTtJQUNuQyxJQUFHdkIsaUJBQWlCUyxPQUFPLEVBQUVLLGFBQWE7SUFDM0MsTUFBTSxDQUFDYyxrQkFBa0JDLG9CQUFvQixHQUFHLENBQUMsR0FBR3hCLGlCQUFpQkksT0FBTztJQUM1RSxNQUFNLEVBQUV0QixPQUFPMkMsV0FBVyxFQUFFQyxPQUFPQyxnQkFBZ0IsRUFBRSxHQUFHSjtJQUN4RCxNQUFNSyxlQUFlLENBQUMsR0FBR3JDLFFBQVFzQyxNQUFNLEVBQUU7SUFDeEMsSUFBR2pDLFVBQVVRLE9BQU8sRUFBRTBCLFNBQVNDLE9BQU9DLGdCQUFnQixDQUFDQyxTQUFTQyxJQUFJLEVBQUVDLGdCQUFnQixDQUFDLGlDQUFpQyxRQUFRLEdBQUc7SUFDcEksU0FBU0M7UUFDTCxJQUFJLENBQUNYLGFBQWE7WUFDZCwrQ0FBK0M7WUFDL0M7UUFDSjtRQUNBLElBQUlaLDhCQUE4QjtZQUM5QkEsNkJBQTZCWTtRQUNqQztJQUNKO0lBQ0EsU0FBU1k7UUFDTCxJQUFJLENBQUNWLGtCQUFrQjtZQUNuQiwrQ0FBK0M7WUFDL0M7UUFDSjtRQUNDLElBQUcvQixVQUFVUSxPQUFPLEVBQUUsT0FBT3VCLGlCQUFpQlcsUUFBUTtRQUN2RCxJQUFJM0IsNEJBQTRCO1lBQzVCQSwyQkFBMkJnQjtRQUMvQjtJQUNKO0lBQ0EsU0FBU1k7UUFDTGYsb0JBQW9CO1lBQUVnQixNQUFNO1FBQVE7SUFDeEM7SUFDQyxJQUFHakQsUUFBUWtELFNBQVMsRUFBRUYsa0JBQWtCO1FBQUNmO1FBQXFCTjtLQUFLO0lBQ3BFLFNBQVN3QjtRQUNMLElBQUksQ0FBQ3hCLE1BQU07WUFDUDtRQUNKO1FBQ0EsTUFBTXlCLGNBQWMsQ0FBQyxHQUFHbEQsMkJBQTJCVyxPQUFPLEVBQUVjLEtBQUswQixjQUFjO1FBQy9FLE1BQU1DLGNBQWNGO1FBQ3BCQSxZQUFZRyxPQUFPLENBQ2RDLElBQUksQ0FBQyxDQUFDQztZQUNQeEIsb0JBQW9CO2dCQUFFZ0IsTUFBTTtnQkFBVzFELE9BQU9rRTtZQUFnQjtRQUNsRSxHQUNLQyxLQUFLLENBQUMsQ0FBQ3ZCO1lBQ1JGLG9CQUFvQjtnQkFBRWdCLE1BQU07Z0JBQVVkO1lBQU07UUFDaEQ7UUFDQSxPQUFPO1lBQ0YsSUFBR3pCLFdBQVdpRCxpQkFBaUIsRUFBRUw7UUFDdEM7SUFDSjtJQUNDLElBQUd0RCxRQUFRa0QsU0FBUyxFQUFFQyxpQkFBaUI7UUFBQ2xCO1FBQXFCTjtRQUFNRTtLQUFZO0lBQy9FLElBQUc3QixRQUFRa0QsU0FBUyxFQUFFO1FBQ25CLElBQUloQixnQkFBZ0J0RCxXQUFXO1lBQzNCO1FBQ0o7UUFDQSxJQUFJc0QsZ0JBQWdCLE9BQU87WUFDdkJZO1lBQ0E7UUFDSjtRQUNBRDtJQUNKLEdBQ0EsbUVBQW1FO0lBQ25FLHVEQUF1RDtJQUN2RDtRQUFDWDtLQUFZO0lBQ2IsU0FBUzBCO1FBQ0wsSUFBSWxDLHFDQUFxQztZQUNyQ0E7UUFDSjtJQUNKO0lBQ0EsU0FBU21DLGNBQWMxQixLQUFLO1FBQ3ZCLElBQUc5QixVQUFVUSxPQUFPLEVBQUUsT0FBTyxHQUFTLE9BQU5zQjtRQUNqQyxJQUFJWCxtQ0FBbUM7WUFDbkNBLGtDQUFrQ1c7UUFDdEM7SUFDSjtJQUNBLE1BQU0yQixXQUFXLENBQUMsR0FBRzlELFFBQVErRCxPQUFPLEVBQUUsSUFBTXBDLEtBQUtxQyxXQUFXLENBQUM7WUFBRWpDO1lBQU9rQyxVQUFVbkM7UUFBTyxJQUFJO1FBQUNIO1FBQU1HO1FBQVFDO0tBQU07SUFDaEgsU0FBU21DO1FBQ0wsSUFBSSxDQUFDdEMsT0FBTyxDQUFDRCxRQUFRLENBQUNULGVBQWUsQ0FBQ2dCLGFBQWE7WUFDL0M7UUFDSjtRQUNBLE1BQU0sRUFBRWlDLFNBQVNDLEtBQUssRUFBRSxHQUFHL0I7UUFDM0IsSUFBSSxDQUFDK0IsT0FBTztZQUNSO1FBQ0o7UUFDQSxNQUFNQyxpQkFBaUJQLFNBQVNRLEtBQUssQ0FBQztZQUFFQyxVQUFVO1FBQUs7UUFDdkQsTUFBTUMsNEJBQTRCO1lBQzlCQyxzQkFBc0I7WUFDdEJDLHFCQUFxQjtZQUNyQkMsS0FBS1A7WUFDTFEsTUFBTTtZQUNOakQ7WUFDQW1DLFVBQVVPO1FBQ2Q7UUFDQSxNQUFNUSxtQkFBbUI7WUFDckIzQztZQUNBNEMsbUJBQW1CbEQsSUFBSWtELGlCQUFpQjtZQUN4Q0gsS0FBS1A7WUFDTCxxREFBcUQ7WUFDckRXLGlCQUFpQjtZQUNqQjlEO1lBQ0FDO1lBQ0FTO1lBQ0FFO1lBQ0FpQyxVQUFVTztRQUNkO1FBQ0FELE1BQU1ZLFNBQVMsR0FBRztRQUNsQixJQUFJO1lBQ0EsSUFBSTFFLFdBQVdPLE9BQU8sQ0FBQ0YsZUFBZSxDQUFDNkQsMkJBQTJCUyxNQUFNLENBQUNKO1lBQ3pFLGlDQUFpQztZQUNqQ2pCO1FBQ0osRUFDQSxPQUFPekIsT0FBTztZQUNWMEIsY0FBYzFCO1FBQ2xCO1FBQ0EsT0FBTztRQUNILDZCQUE2QjtRQUNqQztJQUNKO0lBQ0MsSUFBR25DLFFBQVFrRCxTQUFTLEVBQUVnQix1QkFDdkIsbUVBQW1FO0lBQ25FLHVEQUF1RDtJQUN2RDtRQUFDaEM7UUFBYWpCO1FBQW9CQztRQUFhUztRQUFNRTtRQUFhaUM7S0FBUztJQUMzRSxPQUFROUQsUUFBUWEsT0FBTyxDQUFDcUUsYUFBYSxDQUFDLE9BQU87UUFBRUMsV0FBVyxDQUFDLEdBQUdoRixPQUFPVSxPQUFPLEVBQUUsZ0NBQWdDO1FBQW9CdUUsS0FBSy9DO0lBQWE7QUFDeEo7S0E5SFMxQjtBQStIVFosa0JBQWUsR0FBR1kiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXBkZi9kaXN0L2Nqcy9QYWdlL0Fubm90YXRpb25MYXllci5qcz8yNDNhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuJ3VzZSBjbGllbnQnO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCByZWFjdF8xID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJyZWFjdFwiKSk7XG5jb25zdCBtYWtlX2NhbmNlbGxhYmxlX3Byb21pc2VfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwibWFrZS1jYW5jZWxsYWJsZS1wcm9taXNlXCIpKTtcbmNvbnN0IGNsc3hfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiY2xzeFwiKSk7XG5jb25zdCB0aW55X2ludmFyaWFudF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJ0aW55LWludmFyaWFudFwiKSk7XG5jb25zdCB3YXJuaW5nXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIndhcm5pbmdcIikpO1xuY29uc3QgcGRmanNfanNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vcGRmanMuanNcIikpO1xuY29uc3QgdXNlRG9jdW1lbnRDb250ZXh0X2pzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL3NoYXJlZC9ob29rcy91c2VEb2N1bWVudENvbnRleHQuanNcIikpO1xuY29uc3QgdXNlUGFnZUNvbnRleHRfanNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vc2hhcmVkL2hvb2tzL3VzZVBhZ2VDb250ZXh0LmpzXCIpKTtcbmNvbnN0IHVzZVJlc29sdmVyX2pzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL3NoYXJlZC9ob29rcy91c2VSZXNvbHZlci5qc1wiKSk7XG5jb25zdCB1dGlsc19qc18xID0gcmVxdWlyZShcIi4uL3NoYXJlZC91dGlscy5qc1wiKTtcbmZ1bmN0aW9uIEFubm90YXRpb25MYXllcigpIHtcbiAgICBjb25zdCBkb2N1bWVudENvbnRleHQgPSAoMCwgdXNlRG9jdW1lbnRDb250ZXh0X2pzXzEuZGVmYXVsdCkoKTtcbiAgICBjb25zdCBwYWdlQ29udGV4dCA9ICgwLCB1c2VQYWdlQ29udGV4dF9qc18xLmRlZmF1bHQpKCk7XG4gICAgKDAsIHRpbnlfaW52YXJpYW50XzEuZGVmYXVsdCkocGFnZUNvbnRleHQsICdVbmFibGUgdG8gZmluZCBQYWdlIGNvbnRleHQuJyk7XG4gICAgY29uc3QgbWVyZ2VkUHJvcHMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGRvY3VtZW50Q29udGV4dCksIHBhZ2VDb250ZXh0KTtcbiAgICBjb25zdCB7IGltYWdlUmVzb3VyY2VzUGF0aCwgbGlua1NlcnZpY2UsIG9uR2V0QW5ub3RhdGlvbnNFcnJvcjogb25HZXRBbm5vdGF0aW9uc0Vycm9yUHJvcHMsIG9uR2V0QW5ub3RhdGlvbnNTdWNjZXNzOiBvbkdldEFubm90YXRpb25zU3VjY2Vzc1Byb3BzLCBvblJlbmRlckFubm90YXRpb25MYXllckVycm9yOiBvblJlbmRlckFubm90YXRpb25MYXllckVycm9yUHJvcHMsIG9uUmVuZGVyQW5ub3RhdGlvbkxheWVyU3VjY2Vzczogb25SZW5kZXJBbm5vdGF0aW9uTGF5ZXJTdWNjZXNzUHJvcHMsIHBhZ2UsIHBkZiwgcmVuZGVyRm9ybXMsIHJvdGF0ZSwgc2NhbGUgPSAxLCB9ID0gbWVyZ2VkUHJvcHM7XG4gICAgKDAsIHRpbnlfaW52YXJpYW50XzEuZGVmYXVsdCkocGRmLCAnQXR0ZW1wdGVkIHRvIGxvYWQgcGFnZSBhbm5vdGF0aW9ucywgYnV0IG5vIGRvY3VtZW50IHdhcyBzcGVjaWZpZWQuIFdyYXAgPFBhZ2UgLz4gaW4gYSA8RG9jdW1lbnQgLz4gb3IgcGFzcyBleHBsaWNpdCBgcGRmYCBwcm9wLicpO1xuICAgICgwLCB0aW55X2ludmFyaWFudF8xLmRlZmF1bHQpKHBhZ2UsICdBdHRlbXB0ZWQgdG8gbG9hZCBwYWdlIGFubm90YXRpb25zLCBidXQgbm8gcGFnZSB3YXMgc3BlY2lmaWVkLicpO1xuICAgICgwLCB0aW55X2ludmFyaWFudF8xLmRlZmF1bHQpKGxpbmtTZXJ2aWNlLCAnQXR0ZW1wdGVkIHRvIGxvYWQgcGFnZSBhbm5vdGF0aW9ucywgYnV0IG5vIGxpbmtTZXJ2aWNlIHdhcyBzcGVjaWZpZWQuJyk7XG4gICAgY29uc3QgW2Fubm90YXRpb25zU3RhdGUsIGFubm90YXRpb25zRGlzcGF0Y2hdID0gKDAsIHVzZVJlc29sdmVyX2pzXzEuZGVmYXVsdCkoKTtcbiAgICBjb25zdCB7IHZhbHVlOiBhbm5vdGF0aW9ucywgZXJyb3I6IGFubm90YXRpb25zRXJyb3IgfSA9IGFubm90YXRpb25zU3RhdGU7XG4gICAgY29uc3QgbGF5ZXJFbGVtZW50ID0gKDAsIHJlYWN0XzEudXNlUmVmKShudWxsKTtcbiAgICAoMCwgd2FybmluZ18xLmRlZmF1bHQpKHBhcnNlSW50KHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGRvY3VtZW50LmJvZHkpLmdldFByb3BlcnR5VmFsdWUoJy0tcmVhY3QtcGRmLWFubm90YXRpb24tbGF5ZXInKSwgMTApID09PSAxLCAnQW5ub3RhdGlvbkxheWVyIHN0eWxlcyBub3QgZm91bmQuIFJlYWQgbW9yZTogaHR0cHM6Ly9naXRodWIuY29tL3dvanRla21hai9yZWFjdC1wZGYjc3VwcG9ydC1mb3ItYW5ub3RhdGlvbnMnKTtcbiAgICBmdW5jdGlvbiBvbkxvYWRTdWNjZXNzKCkge1xuICAgICAgICBpZiAoIWFubm90YXRpb25zKSB7XG4gICAgICAgICAgICAvLyBJbXBvc3NpYmxlLCBidXQgVHlwZVNjcmlwdCBkb2Vzbid0IGtub3cgdGhhdFxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvbkdldEFubm90YXRpb25zU3VjY2Vzc1Byb3BzKSB7XG4gICAgICAgICAgICBvbkdldEFubm90YXRpb25zU3VjY2Vzc1Byb3BzKGFubm90YXRpb25zKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBvbkxvYWRFcnJvcigpIHtcbiAgICAgICAgaWYgKCFhbm5vdGF0aW9uc0Vycm9yKSB7XG4gICAgICAgICAgICAvLyBJbXBvc3NpYmxlLCBidXQgVHlwZVNjcmlwdCBkb2Vzbid0IGtub3cgdGhhdFxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgICgwLCB3YXJuaW5nXzEuZGVmYXVsdCkoZmFsc2UsIGFubm90YXRpb25zRXJyb3IudG9TdHJpbmcoKSk7XG4gICAgICAgIGlmIChvbkdldEFubm90YXRpb25zRXJyb3JQcm9wcykge1xuICAgICAgICAgICAgb25HZXRBbm5vdGF0aW9uc0Vycm9yUHJvcHMoYW5ub3RhdGlvbnNFcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcmVzZXRBbm5vdGF0aW9ucygpIHtcbiAgICAgICAgYW5ub3RhdGlvbnNEaXNwYXRjaCh7IHR5cGU6ICdSRVNFVCcgfSk7XG4gICAgfVxuICAgICgwLCByZWFjdF8xLnVzZUVmZmVjdCkocmVzZXRBbm5vdGF0aW9ucywgW2Fubm90YXRpb25zRGlzcGF0Y2gsIHBhZ2VdKTtcbiAgICBmdW5jdGlvbiBsb2FkQW5ub3RhdGlvbnMoKSB7XG4gICAgICAgIGlmICghcGFnZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNhbmNlbGxhYmxlID0gKDAsIG1ha2VfY2FuY2VsbGFibGVfcHJvbWlzZV8xLmRlZmF1bHQpKHBhZ2UuZ2V0QW5ub3RhdGlvbnMoKSk7XG4gICAgICAgIGNvbnN0IHJ1bm5pbmdUYXNrID0gY2FuY2VsbGFibGU7XG4gICAgICAgIGNhbmNlbGxhYmxlLnByb21pc2VcbiAgICAgICAgICAgIC50aGVuKChuZXh0QW5ub3RhdGlvbnMpID0+IHtcbiAgICAgICAgICAgIGFubm90YXRpb25zRGlzcGF0Y2goeyB0eXBlOiAnUkVTT0xWRScsIHZhbHVlOiBuZXh0QW5ub3RhdGlvbnMgfSk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICBhbm5vdGF0aW9uc0Rpc3BhdGNoKHsgdHlwZTogJ1JFSkVDVCcsIGVycm9yIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgICgwLCB1dGlsc19qc18xLmNhbmNlbFJ1bm5pbmdUYXNrKShydW5uaW5nVGFzayk7XG4gICAgICAgIH07XG4gICAgfVxuICAgICgwLCByZWFjdF8xLnVzZUVmZmVjdCkobG9hZEFubm90YXRpb25zLCBbYW5ub3RhdGlvbnNEaXNwYXRjaCwgcGFnZSwgcmVuZGVyRm9ybXNdKTtcbiAgICAoMCwgcmVhY3RfMS51c2VFZmZlY3QpKCgpID0+IHtcbiAgICAgICAgaWYgKGFubm90YXRpb25zID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYW5ub3RhdGlvbnMgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBvbkxvYWRFcnJvcigpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG9uTG9hZFN1Y2Nlc3MoKTtcbiAgICB9LCBcbiAgICAvLyBPbW1pdHRlZCBjYWxsYmFja3Mgc28gdGhleSBhcmUgbm90IGNhbGxlZCBldmVyeSB0aW1lIHRoZXkgY2hhbmdlXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICAgIFthbm5vdGF0aW9uc10pO1xuICAgIGZ1bmN0aW9uIG9uUmVuZGVyU3VjY2VzcygpIHtcbiAgICAgICAgaWYgKG9uUmVuZGVyQW5ub3RhdGlvbkxheWVyU3VjY2Vzc1Byb3BzKSB7XG4gICAgICAgICAgICBvblJlbmRlckFubm90YXRpb25MYXllclN1Y2Nlc3NQcm9wcygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uUmVuZGVyRXJyb3IoZXJyb3IpIHtcbiAgICAgICAgKDAsIHdhcm5pbmdfMS5kZWZhdWx0KShmYWxzZSwgYCR7ZXJyb3J9YCk7XG4gICAgICAgIGlmIChvblJlbmRlckFubm90YXRpb25MYXllckVycm9yUHJvcHMpIHtcbiAgICAgICAgICAgIG9uUmVuZGVyQW5ub3RhdGlvbkxheWVyRXJyb3JQcm9wcyhlcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qgdmlld3BvcnQgPSAoMCwgcmVhY3RfMS51c2VNZW1vKSgoKSA9PiBwYWdlLmdldFZpZXdwb3J0KHsgc2NhbGUsIHJvdGF0aW9uOiByb3RhdGUgfSksIFtwYWdlLCByb3RhdGUsIHNjYWxlXSk7XG4gICAgZnVuY3Rpb24gcmVuZGVyQW5ub3RhdGlvbkxheWVyKCkge1xuICAgICAgICBpZiAoIXBkZiB8fCAhcGFnZSB8fCAhbGlua1NlcnZpY2UgfHwgIWFubm90YXRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBjdXJyZW50OiBsYXllciB9ID0gbGF5ZXJFbGVtZW50O1xuICAgICAgICBpZiAoIWxheWVyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2xvbmVkVmlld3BvcnQgPSB2aWV3cG9ydC5jbG9uZSh7IGRvbnRGbGlwOiB0cnVlIH0pO1xuICAgICAgICBjb25zdCBhbm5vdGF0aW9uTGF5ZXJQYXJhbWV0ZXJzID0ge1xuICAgICAgICAgICAgYWNjZXNzaWJpbGl0eU1hbmFnZXI6IG51bGwsIC8vIFRPRE86IEltcGxlbWVudCB0aGlzXG4gICAgICAgICAgICBhbm5vdGF0aW9uQ2FudmFzTWFwOiBudWxsLCAvLyBUT0RPOiBJbXBsZW1lbnQgdGhpc1xuICAgICAgICAgICAgZGl2OiBsYXllcixcbiAgICAgICAgICAgIGwxMG46IG51bGwsIC8vIFRPRE86IEltcGxlbWVudCB0aGlzXG4gICAgICAgICAgICBwYWdlLFxuICAgICAgICAgICAgdmlld3BvcnQ6IGNsb25lZFZpZXdwb3J0LFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCByZW5kZXJQYXJhbWV0ZXJzID0ge1xuICAgICAgICAgICAgYW5ub3RhdGlvbnMsXG4gICAgICAgICAgICBhbm5vdGF0aW9uU3RvcmFnZTogcGRmLmFubm90YXRpb25TdG9yYWdlLFxuICAgICAgICAgICAgZGl2OiBsYXllcixcbiAgICAgICAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vbW96aWxsYS9wZGYuanMvaXNzdWVzLzE3MDI5XG4gICAgICAgICAgICBkb3dubG9hZE1hbmFnZXI6IG51bGwsXG4gICAgICAgICAgICBpbWFnZVJlc291cmNlc1BhdGgsXG4gICAgICAgICAgICBsaW5rU2VydmljZSxcbiAgICAgICAgICAgIHBhZ2UsXG4gICAgICAgICAgICByZW5kZXJGb3JtcyxcbiAgICAgICAgICAgIHZpZXdwb3J0OiBjbG9uZWRWaWV3cG9ydCxcbiAgICAgICAgfTtcbiAgICAgICAgbGF5ZXIuaW5uZXJIVE1MID0gJyc7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBuZXcgcGRmanNfanNfMS5kZWZhdWx0LkFubm90YXRpb25MYXllcihhbm5vdGF0aW9uTGF5ZXJQYXJhbWV0ZXJzKS5yZW5kZXIocmVuZGVyUGFyYW1ldGVycyk7XG4gICAgICAgICAgICAvLyBJbnRlbnRpb25hbCBpbW1lZGlhdGUgY2FsbGJhY2tcbiAgICAgICAgICAgIG9uUmVuZGVyU3VjY2VzcygpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgb25SZW5kZXJFcnJvcihlcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIC8vIFRPRE86IENhbmNlbCBydW5uaW5nIHRhc2s/XG4gICAgICAgIH07XG4gICAgfVxuICAgICgwLCByZWFjdF8xLnVzZUVmZmVjdCkocmVuZGVyQW5ub3RhdGlvbkxheWVyLCBcbiAgICAvLyBPbW1pdHRlZCBjYWxsYmFja3Mgc28gdGhleSBhcmUgbm90IGNhbGxlZCBldmVyeSB0aW1lIHRoZXkgY2hhbmdlXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICAgIFthbm5vdGF0aW9ucywgaW1hZ2VSZXNvdXJjZXNQYXRoLCBsaW5rU2VydmljZSwgcGFnZSwgcmVuZGVyRm9ybXMsIHZpZXdwb3J0XSk7XG4gICAgcmV0dXJuIChyZWFjdF8xLmRlZmF1bHQuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogKDAsIGNsc3hfMS5kZWZhdWx0KSgncmVhY3QtcGRmX19QYWdlX19hbm5vdGF0aW9ucycsICdhbm5vdGF0aW9uTGF5ZXInKSwgcmVmOiBsYXllckVsZW1lbnQgfSkpO1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gQW5ub3RhdGlvbkxheWVyO1xuIl0sIm5hbWVzIjpbIl9fY3JlYXRlQmluZGluZyIsIk9iamVjdCIsImNyZWF0ZSIsIm8iLCJtIiwiayIsImsyIiwidW5kZWZpbmVkIiwiZGVzYyIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsIl9fZXNNb2R1bGUiLCJ3cml0YWJsZSIsImNvbmZpZ3VyYWJsZSIsImVudW1lcmFibGUiLCJnZXQiLCJkZWZpbmVQcm9wZXJ0eSIsIl9fc2V0TW9kdWxlRGVmYXVsdCIsInYiLCJ2YWx1ZSIsIl9faW1wb3J0U3RhciIsIm1vZCIsInJlc3VsdCIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsIl9faW1wb3J0RGVmYXVsdCIsImV4cG9ydHMiLCJyZWFjdF8xIiwicmVxdWlyZSIsIm1ha2VfY2FuY2VsbGFibGVfcHJvbWlzZV8xIiwiY2xzeF8xIiwidGlueV9pbnZhcmlhbnRfMSIsIndhcm5pbmdfMSIsInBkZmpzX2pzXzEiLCJ1c2VEb2N1bWVudENvbnRleHRfanNfMSIsInVzZVBhZ2VDb250ZXh0X2pzXzEiLCJ1c2VSZXNvbHZlcl9qc18xIiwidXRpbHNfanNfMSIsIkFubm90YXRpb25MYXllciIsImRvY3VtZW50Q29udGV4dCIsImRlZmF1bHQiLCJwYWdlQ29udGV4dCIsIm1lcmdlZFByb3BzIiwiYXNzaWduIiwiaW1hZ2VSZXNvdXJjZXNQYXRoIiwibGlua1NlcnZpY2UiLCJvbkdldEFubm90YXRpb25zRXJyb3IiLCJvbkdldEFubm90YXRpb25zRXJyb3JQcm9wcyIsIm9uR2V0QW5ub3RhdGlvbnNTdWNjZXNzIiwib25HZXRBbm5vdGF0aW9uc1N1Y2Nlc3NQcm9wcyIsIm9uUmVuZGVyQW5ub3RhdGlvbkxheWVyRXJyb3IiLCJvblJlbmRlckFubm90YXRpb25MYXllckVycm9yUHJvcHMiLCJvblJlbmRlckFubm90YXRpb25MYXllclN1Y2Nlc3MiLCJvblJlbmRlckFubm90YXRpb25MYXllclN1Y2Nlc3NQcm9wcyIsInBhZ2UiLCJwZGYiLCJyZW5kZXJGb3JtcyIsInJvdGF0ZSIsInNjYWxlIiwiYW5ub3RhdGlvbnNTdGF0ZSIsImFubm90YXRpb25zRGlzcGF0Y2giLCJhbm5vdGF0aW9ucyIsImVycm9yIiwiYW5ub3RhdGlvbnNFcnJvciIsImxheWVyRWxlbWVudCIsInVzZVJlZiIsInBhcnNlSW50Iiwid2luZG93IiwiZ2V0Q29tcHV0ZWRTdHlsZSIsImRvY3VtZW50IiwiYm9keSIsImdldFByb3BlcnR5VmFsdWUiLCJvbkxvYWRTdWNjZXNzIiwib25Mb2FkRXJyb3IiLCJ0b1N0cmluZyIsInJlc2V0QW5ub3RhdGlvbnMiLCJ0eXBlIiwidXNlRWZmZWN0IiwibG9hZEFubm90YXRpb25zIiwiY2FuY2VsbGFibGUiLCJnZXRBbm5vdGF0aW9ucyIsInJ1bm5pbmdUYXNrIiwicHJvbWlzZSIsInRoZW4iLCJuZXh0QW5ub3RhdGlvbnMiLCJjYXRjaCIsImNhbmNlbFJ1bm5pbmdUYXNrIiwib25SZW5kZXJTdWNjZXNzIiwib25SZW5kZXJFcnJvciIsInZpZXdwb3J0IiwidXNlTWVtbyIsImdldFZpZXdwb3J0Iiwicm90YXRpb24iLCJyZW5kZXJBbm5vdGF0aW9uTGF5ZXIiLCJjdXJyZW50IiwibGF5ZXIiLCJjbG9uZWRWaWV3cG9ydCIsImNsb25lIiwiZG9udEZsaXAiLCJhbm5vdGF0aW9uTGF5ZXJQYXJhbWV0ZXJzIiwiYWNjZXNzaWJpbGl0eU1hbmFnZXIiLCJhbm5vdGF0aW9uQ2FudmFzTWFwIiwiZGl2IiwibDEwbiIsInJlbmRlclBhcmFtZXRlcnMiLCJhbm5vdGF0aW9uU3RvcmFnZSIsImRvd25sb2FkTWFuYWdlciIsImlubmVySFRNTCIsInJlbmRlciIsImNyZWF0ZUVsZW1lbnQiLCJjbGFzc05hbWUiLCJyZWYiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-pdf/dist/cjs/Page/AnnotationLayer.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-pdf/dist/cjs/Page/PageCanvas.js":
/*!************************************************************!*\
  !*** ./node_modules/react-pdf/dist/cjs/Page/PageCanvas.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/* __next_internal_client_entry_do_not_use__  cjs */ \nvar __createBinding = (void 0) && (void 0).__createBinding || (Object.create ? function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n        desc = {\n            enumerable: true,\n            get: function() {\n                return m[k];\n            }\n        };\n    }\n    Object.defineProperty(o, k2, desc);\n} : function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n});\nvar __setModuleDefault = (void 0) && (void 0).__setModuleDefault || (Object.create ? function(o, v) {\n    Object.defineProperty(o, \"default\", {\n        enumerable: true,\n        value: v\n    });\n} : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (void 0) && (void 0).__importStar || function(mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) {\n        for(var k in mod)if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    }\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (void 0) && (void 0).__importDefault || function(mod) {\n    return mod && mod.__esModule ? mod : {\n        \"default\": mod\n    };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nconst react_1 = __importStar(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"));\nconst merge_refs_1 = __importDefault(__webpack_require__(/*! merge-refs */ \"(app-pages-browser)/./node_modules/merge-refs/dist/cjs/index.js\"));\nconst tiny_invariant_1 = __importDefault(__webpack_require__(/*! tiny-invariant */ \"(app-pages-browser)/./node_modules/tiny-invariant/dist/tiny-invariant.cjs.js\"));\nconst warning_1 = __importDefault(__webpack_require__(/*! warning */ \"(app-pages-browser)/./node_modules/warning/warning.js\"));\nconst pdfjs_js_1 = __importDefault(__webpack_require__(/*! ../pdfjs.js */ \"(app-pages-browser)/./node_modules/react-pdf/dist/cjs/pdfjs.js\"));\nconst StructTree_js_1 = __importDefault(__webpack_require__(/*! ../StructTree.js */ \"(app-pages-browser)/./node_modules/react-pdf/dist/cjs/StructTree.js\"));\nconst usePageContext_js_1 = __importDefault(__webpack_require__(/*! ../shared/hooks/usePageContext.js */ \"(app-pages-browser)/./node_modules/react-pdf/dist/cjs/shared/hooks/usePageContext.js\"));\nconst utils_js_1 = __webpack_require__(/*! ../shared/utils.js */ \"(app-pages-browser)/./node_modules/react-pdf/dist/cjs/shared/utils.js\");\nconst ANNOTATION_MODE = pdfjs_js_1.default.AnnotationMode;\nfunction PageCanvas(props) {\n    const pageContext = (0, usePageContext_js_1.default)();\n    (0, tiny_invariant_1.default)(pageContext, \"Unable to find Page context.\");\n    const mergedProps = Object.assign(Object.assign({}, pageContext), props);\n    const { _className, canvasBackground, devicePixelRatio = (0, utils_js_1.getDevicePixelRatio)(), onRenderError: onRenderErrorProps, onRenderSuccess: onRenderSuccessProps, page, renderForms, renderTextLayer, rotate, scale } = mergedProps;\n    const { canvasRef } = props;\n    (0, tiny_invariant_1.default)(page, \"Attempted to render page canvas, but no page was specified.\");\n    const canvasElement = (0, react_1.useRef)(null);\n    /**\n     * Called when a page is rendered successfully.\n     */ function onRenderSuccess() {\n        if (!page) {\n            // Impossible, but TypeScript doesn't know that\n            return;\n        }\n        if (onRenderSuccessProps) {\n            onRenderSuccessProps((0, utils_js_1.makePageCallback)(page, scale));\n        }\n    }\n    /**\n     * Called when a page fails to render.\n     */ function onRenderError(error) {\n        if ((0, utils_js_1.isCancelException)(error)) {\n            return;\n        }\n        (0, warning_1.default)(false, error.toString());\n        if (onRenderErrorProps) {\n            onRenderErrorProps(error);\n        }\n    }\n    const renderViewport = (0, react_1.useMemo)(()=>page.getViewport({\n            scale: scale * devicePixelRatio,\n            rotation: rotate\n        }), [\n        devicePixelRatio,\n        page,\n        rotate,\n        scale\n    ]);\n    const viewport = (0, react_1.useMemo)(()=>page.getViewport({\n            scale,\n            rotation: rotate\n        }), [\n        page,\n        rotate,\n        scale\n    ]);\n    function drawPageOnCanvas() {\n        if (!page) {\n            return;\n        }\n        // Ensures the canvas will be re-rendered from scratch. Otherwise all form data will stay.\n        page.cleanup();\n        const { current: canvas } = canvasElement;\n        if (!canvas) {\n            return;\n        }\n        canvas.width = renderViewport.width;\n        canvas.height = renderViewport.height;\n        canvas.style.width = \"\".concat(Math.floor(viewport.width), \"px\");\n        canvas.style.height = \"\".concat(Math.floor(viewport.height), \"px\");\n        canvas.style.visibility = \"hidden\";\n        const renderContext = {\n            annotationMode: renderForms ? ANNOTATION_MODE.ENABLE_FORMS : ANNOTATION_MODE.ENABLE,\n            canvasContext: canvas.getContext(\"2d\", {\n                alpha: false\n            }),\n            viewport: renderViewport\n        };\n        if (canvasBackground) {\n            renderContext.background = canvasBackground;\n        }\n        const cancellable = page.render(renderContext);\n        const runningTask = cancellable;\n        cancellable.promise.then(()=>{\n            canvas.style.visibility = \"\";\n            onRenderSuccess();\n        }).catch(onRenderError);\n        return ()=>(0, utils_js_1.cancelRunningTask)(runningTask);\n    }\n    (0, react_1.useEffect)(drawPageOnCanvas, // Ommitted callbacks so they are not called every time they change\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [\n        canvasBackground,\n        canvasElement,\n        devicePixelRatio,\n        page,\n        renderForms,\n        renderViewport,\n        viewport\n    ]);\n    const cleanup = (0, react_1.useCallback)(()=>{\n        const { current: canvas } = canvasElement;\n        /**\n         * Zeroing the width and height cause most browsers to release graphics\n         * resources immediately, which can greatly reduce memory consumption.\n         */ if (canvas) {\n            canvas.width = 0;\n            canvas.height = 0;\n        }\n    }, [\n        canvasElement\n    ]);\n    (0, react_1.useEffect)(()=>cleanup, [\n        cleanup\n    ]);\n    return react_1.default.createElement(\"canvas\", {\n        className: \"\".concat(_className, \"__canvas\"),\n        dir: \"ltr\",\n        ref: (0, merge_refs_1.default)(canvasRef, canvasElement),\n        style: {\n            display: \"block\",\n            userSelect: \"none\"\n        }\n    }, renderTextLayer ? react_1.default.createElement(StructTree_js_1.default, null) : null);\n}\n_c = PageCanvas;\nexports[\"default\"] = PageCanvas;\nvar _c;\n$RefreshReg$(_c, \"PageCanvas\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1wZGYvZGlzdC9janMvUGFnZS9QYWdlQ2FudmFzLmpzIiwibWFwcGluZ3MiOiJxREFBYTtBQUViLElBQUlBLGtCQUFrQixDQUFDLE1BQUcsS0FBSyxPQUFHLEVBQUVBLGVBQWUsSUFBTUMsQ0FBQUEsT0FBT0MsTUFBTSxHQUFJLFNBQVNDLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLEVBQUU7SUFDMUYsSUFBSUEsT0FBT0MsV0FBV0QsS0FBS0Q7SUFDM0IsSUFBSUcsT0FBT1AsT0FBT1Esd0JBQXdCLENBQUNMLEdBQUdDO0lBQzlDLElBQUksQ0FBQ0csUUFBUyxVQUFTQSxPQUFPLENBQUNKLEVBQUVNLFVBQVUsR0FBR0YsS0FBS0csUUFBUSxJQUFJSCxLQUFLSSxZQUFZLEdBQUc7UUFDakZKLE9BQU87WUFBRUssWUFBWTtZQUFNQyxLQUFLO2dCQUFhLE9BQU9WLENBQUMsQ0FBQ0MsRUFBRTtZQUFFO1FBQUU7SUFDOUQ7SUFDQUosT0FBT2MsY0FBYyxDQUFDWixHQUFHRyxJQUFJRTtBQUNqQyxJQUFNLFNBQVNMLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLEVBQUU7SUFDdEIsSUFBSUEsT0FBT0MsV0FBV0QsS0FBS0Q7SUFDM0JGLENBQUMsQ0FBQ0csR0FBRyxHQUFHRixDQUFDLENBQUNDLEVBQUU7QUFDaEIsQ0FBQztBQUNELElBQUlXLHFCQUFxQixDQUFDLE1BQUcsS0FBSyxPQUFHLEVBQUVBLGtCQUFrQixJQUFNZixDQUFBQSxPQUFPQyxNQUFNLEdBQUksU0FBU0MsQ0FBQyxFQUFFYyxDQUFDO0lBQ3pGaEIsT0FBT2MsY0FBYyxDQUFDWixHQUFHLFdBQVc7UUFBRVUsWUFBWTtRQUFNSyxPQUFPRDtJQUFFO0FBQ3JFLElBQUssU0FBU2QsQ0FBQyxFQUFFYyxDQUFDO0lBQ2RkLENBQUMsQ0FBQyxVQUFVLEdBQUdjO0FBQ25CO0FBQ0EsSUFBSUUsZUFBZSxDQUFDLE1BQUcsS0FBSyxPQUFHLEVBQUVBLFlBQVksSUFBSyxTQUFVQyxHQUFHO0lBQzNELElBQUlBLE9BQU9BLElBQUlWLFVBQVUsRUFBRSxPQUFPVTtJQUNsQyxJQUFJQyxTQUFTLENBQUM7SUFDZCxJQUFJRCxPQUFPLE1BQU07UUFBQSxJQUFLLElBQUlmLEtBQUtlLElBQUssSUFBSWYsTUFBTSxhQUFhSixPQUFPcUIsU0FBUyxDQUFDQyxjQUFjLENBQUNDLElBQUksQ0FBQ0osS0FBS2YsSUFBSUwsZ0JBQWdCcUIsUUFBUUQsS0FBS2Y7SUFBRTtJQUN4SVcsbUJBQW1CSyxRQUFRRDtJQUMzQixPQUFPQztBQUNYO0FBQ0EsSUFBSUksa0JBQWtCLENBQUMsTUFBRyxLQUFLLE9BQUcsRUFBRUEsZUFBZSxJQUFLLFNBQVVMLEdBQUc7SUFDakUsT0FBTyxPQUFRQSxJQUFJVixVQUFVLEdBQUlVLE1BQU07UUFBRSxXQUFXQTtJQUFJO0FBQzVEO0FBQ0FuQiw4Q0FBNkM7SUFBRWlCLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0QsTUFBTVMsVUFBVVIsYUFBYVMsbUJBQU9BLENBQUMsbUZBQU87QUFDNUMsTUFBTUMsZUFBZUosZ0JBQWdCRyxtQkFBT0EsQ0FBQyxtRkFBWTtBQUN6RCxNQUFNRSxtQkFBbUJMLGdCQUFnQkcsbUJBQU9BLENBQUMsb0dBQWdCO0FBQ2pFLE1BQU1HLFlBQVlOLGdCQUFnQkcsbUJBQU9BLENBQUMsc0VBQVM7QUFDbkQsTUFBTUksYUFBYVAsZ0JBQWdCRyxtQkFBT0EsQ0FBQyxtRkFBYTtBQUN4RCxNQUFNSyxrQkFBa0JSLGdCQUFnQkcsbUJBQU9BLENBQUMsNkZBQWtCO0FBQ2xFLE1BQU1NLHNCQUFzQlQsZ0JBQWdCRyxtQkFBT0EsQ0FBQywrSEFBbUM7QUFDdkYsTUFBTU8sYUFBYVAsbUJBQU9BLENBQUMsaUdBQW9CO0FBQy9DLE1BQU1RLGtCQUFrQkosV0FBV0ssT0FBTyxDQUFDQyxjQUFjO0FBQ3pELFNBQVNDLFdBQVdDLEtBQUs7SUFDckIsTUFBTUMsY0FBYyxDQUFDLEdBQUdQLG9CQUFvQkcsT0FBTztJQUNsRCxJQUFHUCxpQkFBaUJPLE9BQU8sRUFBRUksYUFBYTtJQUMzQyxNQUFNQyxjQUFjekMsT0FBTzBDLE1BQU0sQ0FBQzFDLE9BQU8wQyxNQUFNLENBQUMsQ0FBQyxHQUFHRixjQUFjRDtJQUNsRSxNQUFNLEVBQUVJLFVBQVUsRUFBRUMsZ0JBQWdCLEVBQUVDLG1CQUFtQixDQUFDLEdBQUdYLFdBQVdZLG1CQUFtQixHQUFHLEVBQUVDLGVBQWVDLGtCQUFrQixFQUFFQyxpQkFBaUJDLG9CQUFvQixFQUFFQyxJQUFJLEVBQUVDLFdBQVcsRUFBRUMsZUFBZSxFQUFFQyxNQUFNLEVBQUVDLEtBQUssRUFBRyxHQUFHZDtJQUNqTyxNQUFNLEVBQUVlLFNBQVMsRUFBRSxHQUFHakI7SUFDckIsSUFBR1YsaUJBQWlCTyxPQUFPLEVBQUVlLE1BQU07SUFDcEMsTUFBTU0sZ0JBQWdCLENBQUMsR0FBRy9CLFFBQVFnQyxNQUFNLEVBQUU7SUFDMUM7O0tBRUMsR0FDRCxTQUFTVDtRQUNMLElBQUksQ0FBQ0UsTUFBTTtZQUNQLCtDQUErQztZQUMvQztRQUNKO1FBQ0EsSUFBSUQsc0JBQXNCO1lBQ3RCQSxxQkFBcUIsQ0FBQyxHQUFHaEIsV0FBV3lCLGdCQUFnQixFQUFFUixNQUFNSTtRQUNoRTtJQUNKO0lBQ0E7O0tBRUMsR0FDRCxTQUFTUixjQUFjYSxLQUFLO1FBQ3hCLElBQUksQ0FBQyxHQUFHMUIsV0FBVzJCLGlCQUFpQixFQUFFRCxRQUFRO1lBQzFDO1FBQ0o7UUFDQyxJQUFHOUIsVUFBVU0sT0FBTyxFQUFFLE9BQU93QixNQUFNRSxRQUFRO1FBQzVDLElBQUlkLG9CQUFvQjtZQUNwQkEsbUJBQW1CWTtRQUN2QjtJQUNKO0lBQ0EsTUFBTUcsaUJBQWlCLENBQUMsR0FBR3JDLFFBQVFzQyxPQUFPLEVBQUUsSUFBTWIsS0FBS2MsV0FBVyxDQUFDO1lBQUVWLE9BQU9BLFFBQVFWO1lBQWtCcUIsVUFBVVo7UUFBTyxJQUFJO1FBQUNUO1FBQWtCTTtRQUFNRztRQUFRQztLQUFNO0lBQ2xLLE1BQU1ZLFdBQVcsQ0FBQyxHQUFHekMsUUFBUXNDLE9BQU8sRUFBRSxJQUFNYixLQUFLYyxXQUFXLENBQUM7WUFBRVY7WUFBT1csVUFBVVo7UUFBTyxJQUFJO1FBQUNIO1FBQU1HO1FBQVFDO0tBQU07SUFDaEgsU0FBU2E7UUFDTCxJQUFJLENBQUNqQixNQUFNO1lBQ1A7UUFDSjtRQUNBLDBGQUEwRjtRQUMxRkEsS0FBS2tCLE9BQU87UUFDWixNQUFNLEVBQUVDLFNBQVNDLE1BQU0sRUFBRSxHQUFHZDtRQUM1QixJQUFJLENBQUNjLFFBQVE7WUFDVDtRQUNKO1FBQ0FBLE9BQU9DLEtBQUssR0FBR1QsZUFBZVMsS0FBSztRQUNuQ0QsT0FBT0UsTUFBTSxHQUFHVixlQUFlVSxNQUFNO1FBQ3JDRixPQUFPRyxLQUFLLENBQUNGLEtBQUssR0FBRyxHQUE4QixPQUEzQkcsS0FBS0MsS0FBSyxDQUFDVCxTQUFTSyxLQUFLLEdBQUU7UUFDbkRELE9BQU9HLEtBQUssQ0FBQ0QsTUFBTSxHQUFHLEdBQStCLE9BQTVCRSxLQUFLQyxLQUFLLENBQUNULFNBQVNNLE1BQU0sR0FBRTtRQUNyREYsT0FBT0csS0FBSyxDQUFDRyxVQUFVLEdBQUc7UUFDMUIsTUFBTUMsZ0JBQWdCO1lBQ2xCQyxnQkFBZ0IzQixjQUFjakIsZ0JBQWdCNkMsWUFBWSxHQUFHN0MsZ0JBQWdCOEMsTUFBTTtZQUNuRkMsZUFBZVgsT0FBT1ksVUFBVSxDQUFDLE1BQU07Z0JBQUVDLE9BQU87WUFBTTtZQUN0RGpCLFVBQVVKO1FBQ2Q7UUFDQSxJQUFJbkIsa0JBQWtCO1lBQ2xCa0MsY0FBY08sVUFBVSxHQUFHekM7UUFDL0I7UUFDQSxNQUFNMEMsY0FBY25DLEtBQUtvQyxNQUFNLENBQUNUO1FBQ2hDLE1BQU1VLGNBQWNGO1FBQ3BCQSxZQUFZRyxPQUFPLENBQ2RDLElBQUksQ0FBQztZQUNObkIsT0FBT0csS0FBSyxDQUFDRyxVQUFVLEdBQUc7WUFDMUI1QjtRQUNKLEdBQ0swQyxLQUFLLENBQUM1QztRQUNYLE9BQU8sSUFBTSxDQUFDLEdBQUdiLFdBQVcwRCxpQkFBaUIsRUFBRUo7SUFDbkQ7SUFDQyxJQUFHOUQsUUFBUW1FLFNBQVMsRUFBRXpCLGtCQUN2QixtRUFBbUU7SUFDbkUsdURBQXVEO0lBQ3ZEO1FBQ0l4QjtRQUNBYTtRQUNBWjtRQUNBTTtRQUNBQztRQUNBVztRQUNBSTtLQUNIO0lBQ0QsTUFBTUUsVUFBVSxDQUFDLEdBQUczQyxRQUFRb0UsV0FBVyxFQUFFO1FBQ3JDLE1BQU0sRUFBRXhCLFNBQVNDLE1BQU0sRUFBRSxHQUFHZDtRQUM1Qjs7O1NBR0MsR0FDRCxJQUFJYyxRQUFRO1lBQ1JBLE9BQU9DLEtBQUssR0FBRztZQUNmRCxPQUFPRSxNQUFNLEdBQUc7UUFDcEI7SUFDSixHQUFHO1FBQUNoQjtLQUFjO0lBQ2pCLElBQUcvQixRQUFRbUUsU0FBUyxFQUFFLElBQU14QixTQUFTO1FBQUNBO0tBQVE7SUFDL0MsT0FBUTNDLFFBQVFVLE9BQU8sQ0FBQzJELGFBQWEsQ0FBQyxVQUFVO1FBQUVDLFdBQVcsR0FBYyxPQUFYckQsWUFBVztRQUFXc0QsS0FBSztRQUFPQyxLQUFLLENBQUMsR0FBR3RFLGFBQWFRLE9BQU8sRUFBRW9CLFdBQVdDO1FBQWdCaUIsT0FBTztZQUMzSnlCLFNBQVM7WUFDVEMsWUFBWTtRQUNoQjtJQUFFLEdBQUcvQyxrQkFBa0IzQixRQUFRVSxPQUFPLENBQUMyRCxhQUFhLENBQUMvRCxnQkFBZ0JJLE9BQU8sRUFBRSxRQUFRO0FBQzlGO0tBL0ZTRTtBQWdHVGIsa0JBQWUsR0FBR2EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXBkZi9kaXN0L2Nqcy9QYWdlL1BhZ2VDYW52YXMuanM/OTM1NiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbid1c2UgY2xpZW50JztcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgcmVhY3RfMSA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwicmVhY3RcIikpO1xuY29uc3QgbWVyZ2VfcmVmc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJtZXJnZS1yZWZzXCIpKTtcbmNvbnN0IHRpbnlfaW52YXJpYW50XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcInRpbnktaW52YXJpYW50XCIpKTtcbmNvbnN0IHdhcm5pbmdfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwid2FybmluZ1wiKSk7XG5jb25zdCBwZGZqc19qc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9wZGZqcy5qc1wiKSk7XG5jb25zdCBTdHJ1Y3RUcmVlX2pzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL1N0cnVjdFRyZWUuanNcIikpO1xuY29uc3QgdXNlUGFnZUNvbnRleHRfanNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vc2hhcmVkL2hvb2tzL3VzZVBhZ2VDb250ZXh0LmpzXCIpKTtcbmNvbnN0IHV0aWxzX2pzXzEgPSByZXF1aXJlKFwiLi4vc2hhcmVkL3V0aWxzLmpzXCIpO1xuY29uc3QgQU5OT1RBVElPTl9NT0RFID0gcGRmanNfanNfMS5kZWZhdWx0LkFubm90YXRpb25Nb2RlO1xuZnVuY3Rpb24gUGFnZUNhbnZhcyhwcm9wcykge1xuICAgIGNvbnN0IHBhZ2VDb250ZXh0ID0gKDAsIHVzZVBhZ2VDb250ZXh0X2pzXzEuZGVmYXVsdCkoKTtcbiAgICAoMCwgdGlueV9pbnZhcmlhbnRfMS5kZWZhdWx0KShwYWdlQ29udGV4dCwgJ1VuYWJsZSB0byBmaW5kIFBhZ2UgY29udGV4dC4nKTtcbiAgICBjb25zdCBtZXJnZWRQcm9wcyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcGFnZUNvbnRleHQpLCBwcm9wcyk7XG4gICAgY29uc3QgeyBfY2xhc3NOYW1lLCBjYW52YXNCYWNrZ3JvdW5kLCBkZXZpY2VQaXhlbFJhdGlvID0gKDAsIHV0aWxzX2pzXzEuZ2V0RGV2aWNlUGl4ZWxSYXRpbykoKSwgb25SZW5kZXJFcnJvcjogb25SZW5kZXJFcnJvclByb3BzLCBvblJlbmRlclN1Y2Nlc3M6IG9uUmVuZGVyU3VjY2Vzc1Byb3BzLCBwYWdlLCByZW5kZXJGb3JtcywgcmVuZGVyVGV4dExheWVyLCByb3RhdGUsIHNjYWxlLCB9ID0gbWVyZ2VkUHJvcHM7XG4gICAgY29uc3QgeyBjYW52YXNSZWYgfSA9IHByb3BzO1xuICAgICgwLCB0aW55X2ludmFyaWFudF8xLmRlZmF1bHQpKHBhZ2UsICdBdHRlbXB0ZWQgdG8gcmVuZGVyIHBhZ2UgY2FudmFzLCBidXQgbm8gcGFnZSB3YXMgc3BlY2lmaWVkLicpO1xuICAgIGNvbnN0IGNhbnZhc0VsZW1lbnQgPSAoMCwgcmVhY3RfMS51c2VSZWYpKG51bGwpO1xuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuIGEgcGFnZSBpcyByZW5kZXJlZCBzdWNjZXNzZnVsbHkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gb25SZW5kZXJTdWNjZXNzKCkge1xuICAgICAgICBpZiAoIXBhZ2UpIHtcbiAgICAgICAgICAgIC8vIEltcG9zc2libGUsIGJ1dCBUeXBlU2NyaXB0IGRvZXNuJ3Qga25vdyB0aGF0XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9uUmVuZGVyU3VjY2Vzc1Byb3BzKSB7XG4gICAgICAgICAgICBvblJlbmRlclN1Y2Nlc3NQcm9wcygoMCwgdXRpbHNfanNfMS5tYWtlUGFnZUNhbGxiYWNrKShwYWdlLCBzY2FsZSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuIGEgcGFnZSBmYWlscyB0byByZW5kZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gb25SZW5kZXJFcnJvcihlcnJvcikge1xuICAgICAgICBpZiAoKDAsIHV0aWxzX2pzXzEuaXNDYW5jZWxFeGNlcHRpb24pKGVycm9yKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgICgwLCB3YXJuaW5nXzEuZGVmYXVsdCkoZmFsc2UsIGVycm9yLnRvU3RyaW5nKCkpO1xuICAgICAgICBpZiAob25SZW5kZXJFcnJvclByb3BzKSB7XG4gICAgICAgICAgICBvblJlbmRlckVycm9yUHJvcHMoZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHJlbmRlclZpZXdwb3J0ID0gKDAsIHJlYWN0XzEudXNlTWVtbykoKCkgPT4gcGFnZS5nZXRWaWV3cG9ydCh7IHNjYWxlOiBzY2FsZSAqIGRldmljZVBpeGVsUmF0aW8sIHJvdGF0aW9uOiByb3RhdGUgfSksIFtkZXZpY2VQaXhlbFJhdGlvLCBwYWdlLCByb3RhdGUsIHNjYWxlXSk7XG4gICAgY29uc3Qgdmlld3BvcnQgPSAoMCwgcmVhY3RfMS51c2VNZW1vKSgoKSA9PiBwYWdlLmdldFZpZXdwb3J0KHsgc2NhbGUsIHJvdGF0aW9uOiByb3RhdGUgfSksIFtwYWdlLCByb3RhdGUsIHNjYWxlXSk7XG4gICAgZnVuY3Rpb24gZHJhd1BhZ2VPbkNhbnZhcygpIHtcbiAgICAgICAgaWYgKCFwYWdlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gRW5zdXJlcyB0aGUgY2FudmFzIHdpbGwgYmUgcmUtcmVuZGVyZWQgZnJvbSBzY3JhdGNoLiBPdGhlcndpc2UgYWxsIGZvcm0gZGF0YSB3aWxsIHN0YXkuXG4gICAgICAgIHBhZ2UuY2xlYW51cCgpO1xuICAgICAgICBjb25zdCB7IGN1cnJlbnQ6IGNhbnZhcyB9ID0gY2FudmFzRWxlbWVudDtcbiAgICAgICAgaWYgKCFjYW52YXMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjYW52YXMud2lkdGggPSByZW5kZXJWaWV3cG9ydC53aWR0aDtcbiAgICAgICAgY2FudmFzLmhlaWdodCA9IHJlbmRlclZpZXdwb3J0LmhlaWdodDtcbiAgICAgICAgY2FudmFzLnN0eWxlLndpZHRoID0gYCR7TWF0aC5mbG9vcih2aWV3cG9ydC53aWR0aCl9cHhgO1xuICAgICAgICBjYW52YXMuc3R5bGUuaGVpZ2h0ID0gYCR7TWF0aC5mbG9vcih2aWV3cG9ydC5oZWlnaHQpfXB4YDtcbiAgICAgICAgY2FudmFzLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcbiAgICAgICAgY29uc3QgcmVuZGVyQ29udGV4dCA9IHtcbiAgICAgICAgICAgIGFubm90YXRpb25Nb2RlOiByZW5kZXJGb3JtcyA/IEFOTk9UQVRJT05fTU9ERS5FTkFCTEVfRk9STVMgOiBBTk5PVEFUSU9OX01PREUuRU5BQkxFLFxuICAgICAgICAgICAgY2FudmFzQ29udGV4dDogY2FudmFzLmdldENvbnRleHQoJzJkJywgeyBhbHBoYTogZmFsc2UgfSksXG4gICAgICAgICAgICB2aWV3cG9ydDogcmVuZGVyVmlld3BvcnQsXG4gICAgICAgIH07XG4gICAgICAgIGlmIChjYW52YXNCYWNrZ3JvdW5kKSB7XG4gICAgICAgICAgICByZW5kZXJDb250ZXh0LmJhY2tncm91bmQgPSBjYW52YXNCYWNrZ3JvdW5kO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNhbmNlbGxhYmxlID0gcGFnZS5yZW5kZXIocmVuZGVyQ29udGV4dCk7XG4gICAgICAgIGNvbnN0IHJ1bm5pbmdUYXNrID0gY2FuY2VsbGFibGU7XG4gICAgICAgIGNhbmNlbGxhYmxlLnByb21pc2VcbiAgICAgICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIGNhbnZhcy5zdHlsZS52aXNpYmlsaXR5ID0gJyc7XG4gICAgICAgICAgICBvblJlbmRlclN1Y2Nlc3MoKTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRjaChvblJlbmRlckVycm9yKTtcbiAgICAgICAgcmV0dXJuICgpID0+ICgwLCB1dGlsc19qc18xLmNhbmNlbFJ1bm5pbmdUYXNrKShydW5uaW5nVGFzayk7XG4gICAgfVxuICAgICgwLCByZWFjdF8xLnVzZUVmZmVjdCkoZHJhd1BhZ2VPbkNhbnZhcywgXG4gICAgLy8gT21taXR0ZWQgY2FsbGJhY2tzIHNvIHRoZXkgYXJlIG5vdCBjYWxsZWQgZXZlcnkgdGltZSB0aGV5IGNoYW5nZVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgICBbXG4gICAgICAgIGNhbnZhc0JhY2tncm91bmQsXG4gICAgICAgIGNhbnZhc0VsZW1lbnQsXG4gICAgICAgIGRldmljZVBpeGVsUmF0aW8sXG4gICAgICAgIHBhZ2UsXG4gICAgICAgIHJlbmRlckZvcm1zLFxuICAgICAgICByZW5kZXJWaWV3cG9ydCxcbiAgICAgICAgdmlld3BvcnQsXG4gICAgXSk7XG4gICAgY29uc3QgY2xlYW51cCA9ICgwLCByZWFjdF8xLnVzZUNhbGxiYWNrKSgoKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgY3VycmVudDogY2FudmFzIH0gPSBjYW52YXNFbGVtZW50O1xuICAgICAgICAvKipcbiAgICAgICAgICogWmVyb2luZyB0aGUgd2lkdGggYW5kIGhlaWdodCBjYXVzZSBtb3N0IGJyb3dzZXJzIHRvIHJlbGVhc2UgZ3JhcGhpY3NcbiAgICAgICAgICogcmVzb3VyY2VzIGltbWVkaWF0ZWx5LCB3aGljaCBjYW4gZ3JlYXRseSByZWR1Y2UgbWVtb3J5IGNvbnN1bXB0aW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKGNhbnZhcykge1xuICAgICAgICAgICAgY2FudmFzLndpZHRoID0gMDtcbiAgICAgICAgICAgIGNhbnZhcy5oZWlnaHQgPSAwO1xuICAgICAgICB9XG4gICAgfSwgW2NhbnZhc0VsZW1lbnRdKTtcbiAgICAoMCwgcmVhY3RfMS51c2VFZmZlY3QpKCgpID0+IGNsZWFudXAsIFtjbGVhbnVwXSk7XG4gICAgcmV0dXJuIChyZWFjdF8xLmRlZmF1bHQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiLCB7IGNsYXNzTmFtZTogYCR7X2NsYXNzTmFtZX1fX2NhbnZhc2AsIGRpcjogXCJsdHJcIiwgcmVmOiAoMCwgbWVyZ2VfcmVmc18xLmRlZmF1bHQpKGNhbnZhc1JlZiwgY2FudmFzRWxlbWVudCksIHN0eWxlOiB7XG4gICAgICAgICAgICBkaXNwbGF5OiAnYmxvY2snLFxuICAgICAgICAgICAgdXNlclNlbGVjdDogJ25vbmUnLFxuICAgICAgICB9IH0sIHJlbmRlclRleHRMYXllciA/IHJlYWN0XzEuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFN0cnVjdFRyZWVfanNfMS5kZWZhdWx0LCBudWxsKSA6IG51bGwpKTtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IFBhZ2VDYW52YXM7XG4iXSwibmFtZXMiOlsiX19jcmVhdGVCaW5kaW5nIiwiT2JqZWN0IiwiY3JlYXRlIiwibyIsIm0iLCJrIiwiazIiLCJ1bmRlZmluZWQiLCJkZXNjIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiX19lc01vZHVsZSIsIndyaXRhYmxlIiwiY29uZmlndXJhYmxlIiwiZW51bWVyYWJsZSIsImdldCIsImRlZmluZVByb3BlcnR5IiwiX19zZXRNb2R1bGVEZWZhdWx0IiwidiIsInZhbHVlIiwiX19pbXBvcnRTdGFyIiwibW9kIiwicmVzdWx0IiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiX19pbXBvcnREZWZhdWx0IiwiZXhwb3J0cyIsInJlYWN0XzEiLCJyZXF1aXJlIiwibWVyZ2VfcmVmc18xIiwidGlueV9pbnZhcmlhbnRfMSIsIndhcm5pbmdfMSIsInBkZmpzX2pzXzEiLCJTdHJ1Y3RUcmVlX2pzXzEiLCJ1c2VQYWdlQ29udGV4dF9qc18xIiwidXRpbHNfanNfMSIsIkFOTk9UQVRJT05fTU9ERSIsImRlZmF1bHQiLCJBbm5vdGF0aW9uTW9kZSIsIlBhZ2VDYW52YXMiLCJwcm9wcyIsInBhZ2VDb250ZXh0IiwibWVyZ2VkUHJvcHMiLCJhc3NpZ24iLCJfY2xhc3NOYW1lIiwiY2FudmFzQmFja2dyb3VuZCIsImRldmljZVBpeGVsUmF0aW8iLCJnZXREZXZpY2VQaXhlbFJhdGlvIiwib25SZW5kZXJFcnJvciIsIm9uUmVuZGVyRXJyb3JQcm9wcyIsIm9uUmVuZGVyU3VjY2VzcyIsIm9uUmVuZGVyU3VjY2Vzc1Byb3BzIiwicGFnZSIsInJlbmRlckZvcm1zIiwicmVuZGVyVGV4dExheWVyIiwicm90YXRlIiwic2NhbGUiLCJjYW52YXNSZWYiLCJjYW52YXNFbGVtZW50IiwidXNlUmVmIiwibWFrZVBhZ2VDYWxsYmFjayIsImVycm9yIiwiaXNDYW5jZWxFeGNlcHRpb24iLCJ0b1N0cmluZyIsInJlbmRlclZpZXdwb3J0IiwidXNlTWVtbyIsImdldFZpZXdwb3J0Iiwicm90YXRpb24iLCJ2aWV3cG9ydCIsImRyYXdQYWdlT25DYW52YXMiLCJjbGVhbnVwIiwiY3VycmVudCIsImNhbnZhcyIsIndpZHRoIiwiaGVpZ2h0Iiwic3R5bGUiLCJNYXRoIiwiZmxvb3IiLCJ2aXNpYmlsaXR5IiwicmVuZGVyQ29udGV4dCIsImFubm90YXRpb25Nb2RlIiwiRU5BQkxFX0ZPUk1TIiwiRU5BQkxFIiwiY2FudmFzQ29udGV4dCIsImdldENvbnRleHQiLCJhbHBoYSIsImJhY2tncm91bmQiLCJjYW5jZWxsYWJsZSIsInJlbmRlciIsInJ1bm5pbmdUYXNrIiwicHJvbWlzZSIsInRoZW4iLCJjYXRjaCIsImNhbmNlbFJ1bm5pbmdUYXNrIiwidXNlRWZmZWN0IiwidXNlQ2FsbGJhY2siLCJjcmVhdGVFbGVtZW50IiwiY2xhc3NOYW1lIiwiZGlyIiwicmVmIiwiZGlzcGxheSIsInVzZXJTZWxlY3QiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-pdf/dist/cjs/Page/PageCanvas.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-pdf/dist/cjs/Page/PageSVG.js":
/*!*********************************************************!*\
  !*** ./node_modules/react-pdf/dist/cjs/Page/PageSVG.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst react_1 = __importStar(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"));\nconst make_cancellable_promise_1 = __importDefault(__webpack_require__(/*! make-cancellable-promise */ \"(app-pages-browser)/./node_modules/make-cancellable-promise/dist/cjs/index.js\"));\nconst tiny_invariant_1 = __importDefault(__webpack_require__(/*! tiny-invariant */ \"(app-pages-browser)/./node_modules/tiny-invariant/dist/tiny-invariant.cjs.js\"));\nconst warning_1 = __importDefault(__webpack_require__(/*! warning */ \"(app-pages-browser)/./node_modules/warning/warning.js\"));\nconst pdfjs_js_1 = __importDefault(__webpack_require__(/*! ../pdfjs.js */ \"(app-pages-browser)/./node_modules/react-pdf/dist/cjs/pdfjs.js\"));\nconst usePageContext_js_1 = __importDefault(__webpack_require__(/*! ../shared/hooks/usePageContext.js */ \"(app-pages-browser)/./node_modules/react-pdf/dist/cjs/shared/hooks/usePageContext.js\"));\nconst useResolver_js_1 = __importDefault(__webpack_require__(/*! ../shared/hooks/useResolver.js */ \"(app-pages-browser)/./node_modules/react-pdf/dist/cjs/shared/hooks/useResolver.js\"));\nconst utils_js_1 = __webpack_require__(/*! ../shared/utils.js */ \"(app-pages-browser)/./node_modules/react-pdf/dist/cjs/shared/utils.js\");\nfunction PageSVG() {\n    const pageContext = (0, usePageContext_js_1.default)();\n    (0, tiny_invariant_1.default)(pageContext, 'Unable to find Page context.');\n    const { _className, onRenderSuccess: onRenderSuccessProps, onRenderError: onRenderErrorProps, page, rotate, scale, } = pageContext;\n    (0, tiny_invariant_1.default)(page, 'Attempted to render page SVG, but no page was specified.');\n    const [svgState, svgDispatch] = (0, useResolver_js_1.default)();\n    const { value: svg, error: svgError } = svgState;\n    /**\n     * Called when a page is rendered successfully\n     */\n    function onRenderSuccess() {\n        if (!page) {\n            // Impossible, but TypeScript doesn't know that\n            return;\n        }\n        if (onRenderSuccessProps) {\n            onRenderSuccessProps((0, utils_js_1.makePageCallback)(page, scale));\n        }\n    }\n    /**\n     * Called when a page fails to render\n     */\n    function onRenderError() {\n        if (!svgError) {\n            // Impossible, but TypeScript doesn't know that\n            return;\n        }\n        if ((0, utils_js_1.isCancelException)(svgError)) {\n            return;\n        }\n        (0, warning_1.default)(false, svgError.toString());\n        if (onRenderErrorProps) {\n            onRenderErrorProps(svgError);\n        }\n    }\n    const viewport = (0, react_1.useMemo)(() => page.getViewport({ scale, rotation: rotate }), [page, rotate, scale]);\n    function resetSVG() {\n        svgDispatch({ type: 'RESET' });\n    }\n    (0, react_1.useEffect)(resetSVG, [page, svgDispatch, viewport]);\n    function renderSVG() {\n        if (!page) {\n            return;\n        }\n        const cancellable = (0, make_cancellable_promise_1.default)(page.getOperatorList());\n        cancellable.promise\n            .then((operatorList) => {\n            const svgGfx = new pdfjs_js_1.default.SVGGraphics(page.commonObjs, page.objs);\n            svgGfx\n                .getSVG(operatorList, viewport)\n                .then((nextSvg) => {\n                // See https://github.com/mozilla/pdf.js/issues/16745\n                if (!(nextSvg instanceof SVGElement)) {\n                    throw new Error('getSVG returned unexpected result.');\n                }\n                svgDispatch({ type: 'RESOLVE', value: nextSvg });\n            })\n                .catch((error) => {\n                svgDispatch({ type: 'REJECT', error });\n            });\n        })\n            .catch((error) => {\n            svgDispatch({ type: 'REJECT', error });\n        });\n        return () => (0, utils_js_1.cancelRunningTask)(cancellable);\n    }\n    (0, react_1.useEffect)(renderSVG, [page, svgDispatch, viewport]);\n    (0, react_1.useEffect)(() => {\n        if (svg === undefined) {\n            return;\n        }\n        if (svg === false) {\n            onRenderError();\n            return;\n        }\n        onRenderSuccess();\n    }, \n    // Ommitted callbacks so they are not called every time they change\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [svg]);\n    function drawPageOnContainer(element) {\n        if (!element || !svg) {\n            return;\n        }\n        // Append SVG element to the main container, if this hasn't been done already\n        if (!element.firstElementChild) {\n            element.appendChild(svg);\n        }\n        const { width, height } = viewport;\n        svg.setAttribute('width', `${width}`);\n        svg.setAttribute('height', `${height}`);\n    }\n    const { width, height } = viewport;\n    return (react_1.default.createElement(\"div\", { className: `${_className}__svg`, \n        // Note: This cannot be shortened, as we need this function to be called with each render.\n        ref: (ref) => drawPageOnContainer(ref), style: {\n            display: 'block',\n            backgroundColor: 'white',\n            overflow: 'hidden',\n            width,\n            height,\n            userSelect: 'none',\n        } }));\n}\nexports[\"default\"] = PageSVG;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1wZGYvZGlzdC9janMvUGFnZS9QYWdlU1ZHLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSwwQ0FBMEMsNEJBQTRCO0FBQ3RFLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDZCQUE2QixtQkFBTyxDQUFDLG1GQUFPO0FBQzVDLG1EQUFtRCxtQkFBTyxDQUFDLCtHQUEwQjtBQUNyRix5Q0FBeUMsbUJBQU8sQ0FBQyxvR0FBZ0I7QUFDakUsa0NBQWtDLG1CQUFPLENBQUMsc0VBQVM7QUFDbkQsbUNBQW1DLG1CQUFPLENBQUMsbUZBQWE7QUFDeEQsNENBQTRDLG1CQUFPLENBQUMsK0hBQW1DO0FBQ3ZGLHlDQUF5QyxtQkFBTyxDQUFDLHlIQUFnQztBQUNqRixtQkFBbUIsbUJBQU8sQ0FBQyxpR0FBb0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0EsWUFBWSw2R0FBNkc7QUFDekg7QUFDQTtBQUNBLFlBQVksOEJBQThCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLHlCQUF5QjtBQUM1RjtBQUNBLHNCQUFzQixlQUFlO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsaUNBQWlDO0FBQy9ELGFBQWE7QUFDYjtBQUNBLDhCQUE4Qix1QkFBdUI7QUFDckQsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBLDBCQUEwQix1QkFBdUI7QUFDakQsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGdCQUFnQjtBQUNoQyxxQ0FBcUMsTUFBTTtBQUMzQyxzQ0FBc0MsT0FBTztBQUM3QztBQUNBLFlBQVksZ0JBQWdCO0FBQzVCLG1EQUFtRCxjQUFjLFdBQVc7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLGtCQUFlIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFjdC1wZGYvZGlzdC9janMvUGFnZS9QYWdlU1ZHLmpzPzg0YmMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHJlYWN0XzEgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcInJlYWN0XCIpKTtcbmNvbnN0IG1ha2VfY2FuY2VsbGFibGVfcHJvbWlzZV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJtYWtlLWNhbmNlbGxhYmxlLXByb21pc2VcIikpO1xuY29uc3QgdGlueV9pbnZhcmlhbnRfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwidGlueS1pbnZhcmlhbnRcIikpO1xuY29uc3Qgd2FybmluZ18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJ3YXJuaW5nXCIpKTtcbmNvbnN0IHBkZmpzX2pzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL3BkZmpzLmpzXCIpKTtcbmNvbnN0IHVzZVBhZ2VDb250ZXh0X2pzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL3NoYXJlZC9ob29rcy91c2VQYWdlQ29udGV4dC5qc1wiKSk7XG5jb25zdCB1c2VSZXNvbHZlcl9qc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9zaGFyZWQvaG9va3MvdXNlUmVzb2x2ZXIuanNcIikpO1xuY29uc3QgdXRpbHNfanNfMSA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvdXRpbHMuanNcIik7XG5mdW5jdGlvbiBQYWdlU1ZHKCkge1xuICAgIGNvbnN0IHBhZ2VDb250ZXh0ID0gKDAsIHVzZVBhZ2VDb250ZXh0X2pzXzEuZGVmYXVsdCkoKTtcbiAgICAoMCwgdGlueV9pbnZhcmlhbnRfMS5kZWZhdWx0KShwYWdlQ29udGV4dCwgJ1VuYWJsZSB0byBmaW5kIFBhZ2UgY29udGV4dC4nKTtcbiAgICBjb25zdCB7IF9jbGFzc05hbWUsIG9uUmVuZGVyU3VjY2Vzczogb25SZW5kZXJTdWNjZXNzUHJvcHMsIG9uUmVuZGVyRXJyb3I6IG9uUmVuZGVyRXJyb3JQcm9wcywgcGFnZSwgcm90YXRlLCBzY2FsZSwgfSA9IHBhZ2VDb250ZXh0O1xuICAgICgwLCB0aW55X2ludmFyaWFudF8xLmRlZmF1bHQpKHBhZ2UsICdBdHRlbXB0ZWQgdG8gcmVuZGVyIHBhZ2UgU1ZHLCBidXQgbm8gcGFnZSB3YXMgc3BlY2lmaWVkLicpO1xuICAgIGNvbnN0IFtzdmdTdGF0ZSwgc3ZnRGlzcGF0Y2hdID0gKDAsIHVzZVJlc29sdmVyX2pzXzEuZGVmYXVsdCkoKTtcbiAgICBjb25zdCB7IHZhbHVlOiBzdmcsIGVycm9yOiBzdmdFcnJvciB9ID0gc3ZnU3RhdGU7XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW4gYSBwYWdlIGlzIHJlbmRlcmVkIHN1Y2Nlc3NmdWxseVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG9uUmVuZGVyU3VjY2VzcygpIHtcbiAgICAgICAgaWYgKCFwYWdlKSB7XG4gICAgICAgICAgICAvLyBJbXBvc3NpYmxlLCBidXQgVHlwZVNjcmlwdCBkb2Vzbid0IGtub3cgdGhhdFxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvblJlbmRlclN1Y2Nlc3NQcm9wcykge1xuICAgICAgICAgICAgb25SZW5kZXJTdWNjZXNzUHJvcHMoKDAsIHV0aWxzX2pzXzEubWFrZVBhZ2VDYWxsYmFjaykocGFnZSwgc2NhbGUpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbiBhIHBhZ2UgZmFpbHMgdG8gcmVuZGVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gb25SZW5kZXJFcnJvcigpIHtcbiAgICAgICAgaWYgKCFzdmdFcnJvcikge1xuICAgICAgICAgICAgLy8gSW1wb3NzaWJsZSwgYnV0IFR5cGVTY3JpcHQgZG9lc24ndCBrbm93IHRoYXRcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKDAsIHV0aWxzX2pzXzEuaXNDYW5jZWxFeGNlcHRpb24pKHN2Z0Vycm9yKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgICgwLCB3YXJuaW5nXzEuZGVmYXVsdCkoZmFsc2UsIHN2Z0Vycm9yLnRvU3RyaW5nKCkpO1xuICAgICAgICBpZiAob25SZW5kZXJFcnJvclByb3BzKSB7XG4gICAgICAgICAgICBvblJlbmRlckVycm9yUHJvcHMoc3ZnRXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHZpZXdwb3J0ID0gKDAsIHJlYWN0XzEudXNlTWVtbykoKCkgPT4gcGFnZS5nZXRWaWV3cG9ydCh7IHNjYWxlLCByb3RhdGlvbjogcm90YXRlIH0pLCBbcGFnZSwgcm90YXRlLCBzY2FsZV0pO1xuICAgIGZ1bmN0aW9uIHJlc2V0U1ZHKCkge1xuICAgICAgICBzdmdEaXNwYXRjaCh7IHR5cGU6ICdSRVNFVCcgfSk7XG4gICAgfVxuICAgICgwLCByZWFjdF8xLnVzZUVmZmVjdCkocmVzZXRTVkcsIFtwYWdlLCBzdmdEaXNwYXRjaCwgdmlld3BvcnRdKTtcbiAgICBmdW5jdGlvbiByZW5kZXJTVkcoKSB7XG4gICAgICAgIGlmICghcGFnZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNhbmNlbGxhYmxlID0gKDAsIG1ha2VfY2FuY2VsbGFibGVfcHJvbWlzZV8xLmRlZmF1bHQpKHBhZ2UuZ2V0T3BlcmF0b3JMaXN0KCkpO1xuICAgICAgICBjYW5jZWxsYWJsZS5wcm9taXNlXG4gICAgICAgICAgICAudGhlbigob3BlcmF0b3JMaXN0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzdmdHZnggPSBuZXcgcGRmanNfanNfMS5kZWZhdWx0LlNWR0dyYXBoaWNzKHBhZ2UuY29tbW9uT2JqcywgcGFnZS5vYmpzKTtcbiAgICAgICAgICAgIHN2Z0dmeFxuICAgICAgICAgICAgICAgIC5nZXRTVkcob3BlcmF0b3JMaXN0LCB2aWV3cG9ydClcbiAgICAgICAgICAgICAgICAudGhlbigobmV4dFN2ZykgPT4ge1xuICAgICAgICAgICAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vbW96aWxsYS9wZGYuanMvaXNzdWVzLzE2NzQ1XG4gICAgICAgICAgICAgICAgaWYgKCEobmV4dFN2ZyBpbnN0YW5jZW9mIFNWR0VsZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZ2V0U1ZHIHJldHVybmVkIHVuZXhwZWN0ZWQgcmVzdWx0LicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdmdEaXNwYXRjaCh7IHR5cGU6ICdSRVNPTFZFJywgdmFsdWU6IG5leHRTdmcgfSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICBzdmdEaXNwYXRjaCh7IHR5cGU6ICdSRUpFQ1QnLCBlcnJvciB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICAgICAgc3ZnRGlzcGF0Y2goeyB0eXBlOiAnUkVKRUNUJywgZXJyb3IgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gKCkgPT4gKDAsIHV0aWxzX2pzXzEuY2FuY2VsUnVubmluZ1Rhc2spKGNhbmNlbGxhYmxlKTtcbiAgICB9XG4gICAgKDAsIHJlYWN0XzEudXNlRWZmZWN0KShyZW5kZXJTVkcsIFtwYWdlLCBzdmdEaXNwYXRjaCwgdmlld3BvcnRdKTtcbiAgICAoMCwgcmVhY3RfMS51c2VFZmZlY3QpKCgpID0+IHtcbiAgICAgICAgaWYgKHN2ZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN2ZyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIG9uUmVuZGVyRXJyb3IoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBvblJlbmRlclN1Y2Nlc3MoKTtcbiAgICB9LCBcbiAgICAvLyBPbW1pdHRlZCBjYWxsYmFja3Mgc28gdGhleSBhcmUgbm90IGNhbGxlZCBldmVyeSB0aW1lIHRoZXkgY2hhbmdlXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICAgIFtzdmddKTtcbiAgICBmdW5jdGlvbiBkcmF3UGFnZU9uQ29udGFpbmVyKGVsZW1lbnQpIHtcbiAgICAgICAgaWYgKCFlbGVtZW50IHx8ICFzdmcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBBcHBlbmQgU1ZHIGVsZW1lbnQgdG8gdGhlIG1haW4gY29udGFpbmVyLCBpZiB0aGlzIGhhc24ndCBiZWVuIGRvbmUgYWxyZWFkeVxuICAgICAgICBpZiAoIWVsZW1lbnQuZmlyc3RFbGVtZW50Q2hpbGQpIHtcbiAgICAgICAgICAgIGVsZW1lbnQuYXBwZW5kQ2hpbGQoc3ZnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IHZpZXdwb3J0O1xuICAgICAgICBzdmcuc2V0QXR0cmlidXRlKCd3aWR0aCcsIGAke3dpZHRofWApO1xuICAgICAgICBzdmcuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCBgJHtoZWlnaHR9YCk7XG4gICAgfVxuICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gdmlld3BvcnQ7XG4gICAgcmV0dXJuIChyZWFjdF8xLmRlZmF1bHQuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogYCR7X2NsYXNzTmFtZX1fX3N2Z2AsIFxuICAgICAgICAvLyBOb3RlOiBUaGlzIGNhbm5vdCBiZSBzaG9ydGVuZWQsIGFzIHdlIG5lZWQgdGhpcyBmdW5jdGlvbiB0byBiZSBjYWxsZWQgd2l0aCBlYWNoIHJlbmRlci5cbiAgICAgICAgcmVmOiAocmVmKSA9PiBkcmF3UGFnZU9uQ29udGFpbmVyKHJlZiksIHN0eWxlOiB7XG4gICAgICAgICAgICBkaXNwbGF5OiAnYmxvY2snLFxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAnd2hpdGUnLFxuICAgICAgICAgICAgb3ZlcmZsb3c6ICdoaWRkZW4nLFxuICAgICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQsXG4gICAgICAgICAgICB1c2VyU2VsZWN0OiAnbm9uZScsXG4gICAgICAgIH0gfSkpO1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gUGFnZVNWRztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-pdf/dist/cjs/Page/PageSVG.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-pdf/dist/cjs/Page/TextLayer.js":
/*!***********************************************************!*\
  !*** ./node_modules/react-pdf/dist/cjs/Page/TextLayer.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/* __next_internal_client_entry_do_not_use__  cjs */ \nvar __createBinding = (void 0) && (void 0).__createBinding || (Object.create ? function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n        desc = {\n            enumerable: true,\n            get: function() {\n                return m[k];\n            }\n        };\n    }\n    Object.defineProperty(o, k2, desc);\n} : function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n});\nvar __setModuleDefault = (void 0) && (void 0).__setModuleDefault || (Object.create ? function(o, v) {\n    Object.defineProperty(o, \"default\", {\n        enumerable: true,\n        value: v\n    });\n} : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (void 0) && (void 0).__importStar || function(mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) {\n        for(var k in mod)if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    }\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (void 0) && (void 0).__importDefault || function(mod) {\n    return mod && mod.__esModule ? mod : {\n        \"default\": mod\n    };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nconst react_1 = __importStar(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"));\nconst make_cancellable_promise_1 = __importDefault(__webpack_require__(/*! make-cancellable-promise */ \"(app-pages-browser)/./node_modules/make-cancellable-promise/dist/cjs/index.js\"));\nconst clsx_1 = __importDefault(__webpack_require__(/*! clsx */ \"(app-pages-browser)/./node_modules/clsx/dist/clsx.js\"));\nconst tiny_invariant_1 = __importDefault(__webpack_require__(/*! tiny-invariant */ \"(app-pages-browser)/./node_modules/tiny-invariant/dist/tiny-invariant.cjs.js\"));\nconst warning_1 = __importDefault(__webpack_require__(/*! warning */ \"(app-pages-browser)/./node_modules/warning/warning.js\"));\nconst pdfjs_js_1 = __importDefault(__webpack_require__(/*! ../pdfjs.js */ \"(app-pages-browser)/./node_modules/react-pdf/dist/cjs/pdfjs.js\"));\nconst usePageContext_js_1 = __importDefault(__webpack_require__(/*! ../shared/hooks/usePageContext.js */ \"(app-pages-browser)/./node_modules/react-pdf/dist/cjs/shared/hooks/usePageContext.js\"));\nconst useResolver_js_1 = __importDefault(__webpack_require__(/*! ../shared/hooks/useResolver.js */ \"(app-pages-browser)/./node_modules/react-pdf/dist/cjs/shared/hooks/useResolver.js\"));\nconst utils_js_1 = __webpack_require__(/*! ../shared/utils.js */ \"(app-pages-browser)/./node_modules/react-pdf/dist/cjs/shared/utils.js\");\nfunction isTextItem(item) {\n    return \"str\" in item;\n}\nfunction TextLayer() {\n    const pageContext = (0, usePageContext_js_1.default)();\n    (0, tiny_invariant_1.default)(pageContext, \"Unable to find Page context.\");\n    const { customTextRenderer, onGetTextError, onGetTextSuccess, onRenderTextLayerError, onRenderTextLayerSuccess, page, pageIndex, pageNumber, rotate, scale } = pageContext;\n    (0, tiny_invariant_1.default)(page, \"Attempted to load page text content, but no page was specified.\");\n    const [textContentState, textContentDispatch] = (0, useResolver_js_1.default)();\n    const { value: textContent, error: textContentError } = textContentState;\n    const layerElement = (0, react_1.useRef)(null);\n    const endElement = (0, react_1.useRef)();\n    (0, warning_1.default)(parseInt(window.getComputedStyle(document.body).getPropertyValue(\"--react-pdf-text-layer\"), 10) === 1, \"TextLayer styles not found. Read more: https://github.com/wojtekmaj/react-pdf#support-for-text-layer\");\n    /**\n     * Called when a page text content is read successfully\n     */ function onLoadSuccess() {\n        if (!textContent) {\n            // Impossible, but TypeScript doesn't know that\n            return;\n        }\n        if (onGetTextSuccess) {\n            onGetTextSuccess(textContent);\n        }\n    }\n    /**\n     * Called when a page text content failed to read successfully\n     */ function onLoadError() {\n        if (!textContentError) {\n            // Impossible, but TypeScript doesn't know that\n            return;\n        }\n        (0, warning_1.default)(false, textContentError.toString());\n        if (onGetTextError) {\n            onGetTextError(textContentError);\n        }\n    }\n    function resetTextContent() {\n        textContentDispatch({\n            type: \"RESET\"\n        });\n    }\n    (0, react_1.useEffect)(resetTextContent, [\n        page,\n        textContentDispatch\n    ]);\n    function loadTextContent() {\n        if (!page) {\n            return;\n        }\n        const cancellable = (0, make_cancellable_promise_1.default)(page.getTextContent());\n        const runningTask = cancellable;\n        cancellable.promise.then((nextTextContent)=>{\n            textContentDispatch({\n                type: \"RESOLVE\",\n                value: nextTextContent\n            });\n        }).catch((error)=>{\n            textContentDispatch({\n                type: \"REJECT\",\n                error\n            });\n        });\n        return ()=>(0, utils_js_1.cancelRunningTask)(runningTask);\n    }\n    (0, react_1.useEffect)(loadTextContent, [\n        page,\n        textContentDispatch\n    ]);\n    (0, react_1.useEffect)(()=>{\n        if (textContent === undefined) {\n            return;\n        }\n        if (textContent === false) {\n            onLoadError();\n            return;\n        }\n        onLoadSuccess();\n    }, // Ommitted callbacks so they are not called every time they change\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [\n        textContent\n    ]);\n    /**\n     * Called when a text layer is rendered successfully\n     */ const onRenderSuccess = (0, react_1.useCallback)(()=>{\n        if (onRenderTextLayerSuccess) {\n            onRenderTextLayerSuccess();\n        }\n    }, [\n        onRenderTextLayerSuccess\n    ]);\n    /**\n     * Called when a text layer failed to render successfully\n     */ const onRenderError = (0, react_1.useCallback)((error)=>{\n        (0, warning_1.default)(false, error.toString());\n        if (onRenderTextLayerError) {\n            onRenderTextLayerError(error);\n        }\n    }, [\n        onRenderTextLayerError\n    ]);\n    function onMouseDown() {\n        const end = endElement.current;\n        if (!end) {\n            return;\n        }\n        end.classList.add(\"active\");\n    }\n    function onMouseUp() {\n        const end = endElement.current;\n        if (!end) {\n            return;\n        }\n        end.classList.remove(\"active\");\n    }\n    const viewport = (0, react_1.useMemo)(()=>page.getViewport({\n            scale,\n            rotation: rotate\n        }), [\n        page,\n        rotate,\n        scale\n    ]);\n    function renderTextLayer() {\n        if (!page || !textContent) {\n            return;\n        }\n        const { current: layer } = layerElement;\n        if (!layer) {\n            return;\n        }\n        layer.innerHTML = \"\";\n        const textContentSource = page.streamTextContent({\n            includeMarkedContent: true\n        });\n        const parameters = {\n            container: layer,\n            textContentSource,\n            viewport\n        };\n        const cancellable = pdfjs_js_1.default.renderTextLayer(parameters);\n        const runningTask = cancellable;\n        cancellable.promise.then(()=>{\n            const end = document.createElement(\"div\");\n            end.className = \"endOfContent\";\n            layer.append(end);\n            endElement.current = end;\n            const layerChildren = layer.querySelectorAll('[role=\"presentation\"]');\n            if (customTextRenderer) {\n                let index = 0;\n                textContent.items.forEach((item, itemIndex)=>{\n                    if (!isTextItem(item)) {\n                        return;\n                    }\n                    const child = layerChildren[index];\n                    if (!child) {\n                        return;\n                    }\n                    const content = customTextRenderer(Object.assign({\n                        pageIndex,\n                        pageNumber,\n                        itemIndex\n                    }, item));\n                    child.innerHTML = content;\n                    index += item.str && item.hasEOL ? 2 : 1;\n                });\n            }\n            // Intentional immediate callback\n            onRenderSuccess();\n        }).catch(onRenderError);\n        return ()=>(0, utils_js_1.cancelRunningTask)(runningTask);\n    }\n    (0, react_1.useLayoutEffect)(renderTextLayer, [\n        customTextRenderer,\n        onRenderError,\n        onRenderSuccess,\n        page,\n        pageIndex,\n        pageNumber,\n        textContent,\n        viewport\n    ]);\n    return(// eslint-disable-next-line jsx-a11y/no-static-element-interactions\n    react_1.default.createElement(\"div\", {\n        className: (0, clsx_1.default)(\"react-pdf__Page__textContent\", \"textLayer\"),\n        onMouseUp: onMouseUp,\n        onMouseDown: onMouseDown,\n        ref: layerElement\n    }));\n}\n_c = TextLayer;\nexports[\"default\"] = TextLayer;\nvar _c;\n$RefreshReg$(_c, \"TextLayer\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1wZGYvZGlzdC9janMvUGFnZS9UZXh0TGF5ZXIuanMiLCJtYXBwaW5ncyI6InFEQUFhO0FBRWIsSUFBSUEsa0JBQWtCLENBQUMsTUFBRyxLQUFLLE9BQUcsRUFBRUEsZUFBZSxJQUFNQyxDQUFBQSxPQUFPQyxNQUFNLEdBQUksU0FBU0MsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLENBQUMsRUFBRUMsRUFBRTtJQUMxRixJQUFJQSxPQUFPQyxXQUFXRCxLQUFLRDtJQUMzQixJQUFJRyxPQUFPUCxPQUFPUSx3QkFBd0IsQ0FBQ0wsR0FBR0M7SUFDOUMsSUFBSSxDQUFDRyxRQUFTLFVBQVNBLE9BQU8sQ0FBQ0osRUFBRU0sVUFBVSxHQUFHRixLQUFLRyxRQUFRLElBQUlILEtBQUtJLFlBQVksR0FBRztRQUNqRkosT0FBTztZQUFFSyxZQUFZO1lBQU1DLEtBQUs7Z0JBQWEsT0FBT1YsQ0FBQyxDQUFDQyxFQUFFO1lBQUU7UUFBRTtJQUM5RDtJQUNBSixPQUFPYyxjQUFjLENBQUNaLEdBQUdHLElBQUlFO0FBQ2pDLElBQU0sU0FBU0wsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLENBQUMsRUFBRUMsRUFBRTtJQUN0QixJQUFJQSxPQUFPQyxXQUFXRCxLQUFLRDtJQUMzQkYsQ0FBQyxDQUFDRyxHQUFHLEdBQUdGLENBQUMsQ0FBQ0MsRUFBRTtBQUNoQixDQUFDO0FBQ0QsSUFBSVcscUJBQXFCLENBQUMsTUFBRyxLQUFLLE9BQUcsRUFBRUEsa0JBQWtCLElBQU1mLENBQUFBLE9BQU9DLE1BQU0sR0FBSSxTQUFTQyxDQUFDLEVBQUVjLENBQUM7SUFDekZoQixPQUFPYyxjQUFjLENBQUNaLEdBQUcsV0FBVztRQUFFVSxZQUFZO1FBQU1LLE9BQU9EO0lBQUU7QUFDckUsSUFBSyxTQUFTZCxDQUFDLEVBQUVjLENBQUM7SUFDZGQsQ0FBQyxDQUFDLFVBQVUsR0FBR2M7QUFDbkI7QUFDQSxJQUFJRSxlQUFlLENBQUMsTUFBRyxLQUFLLE9BQUcsRUFBRUEsWUFBWSxJQUFLLFNBQVVDLEdBQUc7SUFDM0QsSUFBSUEsT0FBT0EsSUFBSVYsVUFBVSxFQUFFLE9BQU9VO0lBQ2xDLElBQUlDLFNBQVMsQ0FBQztJQUNkLElBQUlELE9BQU8sTUFBTTtRQUFBLElBQUssSUFBSWYsS0FBS2UsSUFBSyxJQUFJZixNQUFNLGFBQWFKLE9BQU9xQixTQUFTLENBQUNDLGNBQWMsQ0FBQ0MsSUFBSSxDQUFDSixLQUFLZixJQUFJTCxnQkFBZ0JxQixRQUFRRCxLQUFLZjtJQUFFO0lBQ3hJVyxtQkFBbUJLLFFBQVFEO0lBQzNCLE9BQU9DO0FBQ1g7QUFDQSxJQUFJSSxrQkFBa0IsQ0FBQyxNQUFHLEtBQUssT0FBRyxFQUFFQSxlQUFlLElBQUssU0FBVUwsR0FBRztJQUNqRSxPQUFPLE9BQVFBLElBQUlWLFVBQVUsR0FBSVUsTUFBTTtRQUFFLFdBQVdBO0lBQUk7QUFDNUQ7QUFDQW5CLDhDQUE2QztJQUFFaUIsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3RCxNQUFNUyxVQUFVUixhQUFhUyxtQkFBT0EsQ0FBQyxtRkFBTztBQUM1QyxNQUFNQyw2QkFBNkJKLGdCQUFnQkcsbUJBQU9BLENBQUMsK0dBQTBCO0FBQ3JGLE1BQU1FLFNBQVNMLGdCQUFnQkcsbUJBQU9BLENBQUMsa0VBQU07QUFDN0MsTUFBTUcsbUJBQW1CTixnQkFBZ0JHLG1CQUFPQSxDQUFDLG9HQUFnQjtBQUNqRSxNQUFNSSxZQUFZUCxnQkFBZ0JHLG1CQUFPQSxDQUFDLHNFQUFTO0FBQ25ELE1BQU1LLGFBQWFSLGdCQUFnQkcsbUJBQU9BLENBQUMsbUZBQWE7QUFDeEQsTUFBTU0sc0JBQXNCVCxnQkFBZ0JHLG1CQUFPQSxDQUFDLCtIQUFtQztBQUN2RixNQUFNTyxtQkFBbUJWLGdCQUFnQkcsbUJBQU9BLENBQUMseUhBQWdDO0FBQ2pGLE1BQU1RLGFBQWFSLG1CQUFPQSxDQUFDLGlHQUFvQjtBQUMvQyxTQUFTUyxXQUFXQyxJQUFJO0lBQ3BCLE9BQU8sU0FBU0E7QUFDcEI7QUFDQSxTQUFTQztJQUNMLE1BQU1DLGNBQWMsQ0FBQyxHQUFHTixvQkFBb0JPLE9BQU87SUFDbEQsSUFBR1YsaUJBQWlCVSxPQUFPLEVBQUVELGFBQWE7SUFDM0MsTUFBTSxFQUFFRSxrQkFBa0IsRUFBRUMsY0FBYyxFQUFFQyxnQkFBZ0IsRUFBRUMsc0JBQXNCLEVBQUVDLHdCQUF3QixFQUFFQyxJQUFJLEVBQUVDLFNBQVMsRUFBRUMsVUFBVSxFQUFFQyxNQUFNLEVBQUVDLEtBQUssRUFBRyxHQUFHWDtJQUMvSixJQUFHVCxpQkFBaUJVLE9BQU8sRUFBRU0sTUFBTTtJQUNwQyxNQUFNLENBQUNLLGtCQUFrQkMsb0JBQW9CLEdBQUcsQ0FBQyxHQUFHbEIsaUJBQWlCTSxPQUFPO0lBQzVFLE1BQU0sRUFBRXZCLE9BQU9vQyxXQUFXLEVBQUVDLE9BQU9DLGdCQUFnQixFQUFFLEdBQUdKO0lBQ3hELE1BQU1LLGVBQWUsQ0FBQyxHQUFHOUIsUUFBUStCLE1BQU0sRUFBRTtJQUN6QyxNQUFNQyxhQUFhLENBQUMsR0FBR2hDLFFBQVErQixNQUFNO0lBQ3BDLElBQUcxQixVQUFVUyxPQUFPLEVBQUVtQixTQUFTQyxPQUFPQyxnQkFBZ0IsQ0FBQ0MsU0FBU0MsSUFBSSxFQUFFQyxnQkFBZ0IsQ0FBQywyQkFBMkIsUUFBUSxHQUFHO0lBQzlIOztLQUVDLEdBQ0QsU0FBU0M7UUFDTCxJQUFJLENBQUNaLGFBQWE7WUFDZCwrQ0FBK0M7WUFDL0M7UUFDSjtRQUNBLElBQUlWLGtCQUFrQjtZQUNsQkEsaUJBQWlCVTtRQUNyQjtJQUNKO0lBQ0E7O0tBRUMsR0FDRCxTQUFTYTtRQUNMLElBQUksQ0FBQ1gsa0JBQWtCO1lBQ25CLCtDQUErQztZQUMvQztRQUNKO1FBQ0MsSUFBR3hCLFVBQVVTLE9BQU8sRUFBRSxPQUFPZSxpQkFBaUJZLFFBQVE7UUFDdkQsSUFBSXpCLGdCQUFnQjtZQUNoQkEsZUFBZWE7UUFDbkI7SUFDSjtJQUNBLFNBQVNhO1FBQ0xoQixvQkFBb0I7WUFBRWlCLE1BQU07UUFBUTtJQUN4QztJQUNDLElBQUczQyxRQUFRNEMsU0FBUyxFQUFFRixrQkFBa0I7UUFBQ3RCO1FBQU1NO0tBQW9CO0lBQ3BFLFNBQVNtQjtRQUNMLElBQUksQ0FBQ3pCLE1BQU07WUFDUDtRQUNKO1FBQ0EsTUFBTTBCLGNBQWMsQ0FBQyxHQUFHNUMsMkJBQTJCWSxPQUFPLEVBQUVNLEtBQUsyQixjQUFjO1FBQy9FLE1BQU1DLGNBQWNGO1FBQ3BCQSxZQUFZRyxPQUFPLENBQ2RDLElBQUksQ0FBQyxDQUFDQztZQUNQekIsb0JBQW9CO2dCQUFFaUIsTUFBTTtnQkFBV3BELE9BQU80RDtZQUFnQjtRQUNsRSxHQUNLQyxLQUFLLENBQUMsQ0FBQ3hCO1lBQ1JGLG9CQUFvQjtnQkFBRWlCLE1BQU07Z0JBQVVmO1lBQU07UUFDaEQ7UUFDQSxPQUFPLElBQU0sQ0FBQyxHQUFHbkIsV0FBVzRDLGlCQUFpQixFQUFFTDtJQUNuRDtJQUNDLElBQUdoRCxRQUFRNEMsU0FBUyxFQUFFQyxpQkFBaUI7UUFBQ3pCO1FBQU1NO0tBQW9CO0lBQ2xFLElBQUcxQixRQUFRNEMsU0FBUyxFQUFFO1FBQ25CLElBQUlqQixnQkFBZ0IvQyxXQUFXO1lBQzNCO1FBQ0o7UUFDQSxJQUFJK0MsZ0JBQWdCLE9BQU87WUFDdkJhO1lBQ0E7UUFDSjtRQUNBRDtJQUNKLEdBQ0EsbUVBQW1FO0lBQ25FLHVEQUF1RDtJQUN2RDtRQUFDWjtLQUFZO0lBQ2I7O0tBRUMsR0FDRCxNQUFNMkIsa0JBQWtCLENBQUMsR0FBR3RELFFBQVF1RCxXQUFXLEVBQUU7UUFDN0MsSUFBSXBDLDBCQUEwQjtZQUMxQkE7UUFDSjtJQUNKLEdBQUc7UUFBQ0E7S0FBeUI7SUFDN0I7O0tBRUMsR0FDRCxNQUFNcUMsZ0JBQWdCLENBQUMsR0FBR3hELFFBQVF1RCxXQUFXLEVBQUUsQ0FBQzNCO1FBQzNDLElBQUd2QixVQUFVUyxPQUFPLEVBQUUsT0FBT2MsTUFBTWEsUUFBUTtRQUM1QyxJQUFJdkIsd0JBQXdCO1lBQ3hCQSx1QkFBdUJVO1FBQzNCO0lBQ0osR0FBRztRQUFDVjtLQUF1QjtJQUMzQixTQUFTdUM7UUFDTCxNQUFNQyxNQUFNMUIsV0FBVzJCLE9BQU87UUFDOUIsSUFBSSxDQUFDRCxLQUFLO1lBQ047UUFDSjtRQUNBQSxJQUFJRSxTQUFTLENBQUNDLEdBQUcsQ0FBQztJQUN0QjtJQUNBLFNBQVNDO1FBQ0wsTUFBTUosTUFBTTFCLFdBQVcyQixPQUFPO1FBQzlCLElBQUksQ0FBQ0QsS0FBSztZQUNOO1FBQ0o7UUFDQUEsSUFBSUUsU0FBUyxDQUFDRyxNQUFNLENBQUM7SUFDekI7SUFDQSxNQUFNQyxXQUFXLENBQUMsR0FBR2hFLFFBQVFpRSxPQUFPLEVBQUUsSUFBTTdDLEtBQUs4QyxXQUFXLENBQUM7WUFBRTFDO1lBQU8yQyxVQUFVNUM7UUFBTyxJQUFJO1FBQUNIO1FBQU1HO1FBQVFDO0tBQU07SUFDaEgsU0FBUzRDO1FBQ0wsSUFBSSxDQUFDaEQsUUFBUSxDQUFDTyxhQUFhO1lBQ3ZCO1FBQ0o7UUFDQSxNQUFNLEVBQUVnQyxTQUFTVSxLQUFLLEVBQUUsR0FBR3ZDO1FBQzNCLElBQUksQ0FBQ3VDLE9BQU87WUFDUjtRQUNKO1FBQ0FBLE1BQU1DLFNBQVMsR0FBRztRQUNsQixNQUFNQyxvQkFBb0JuRCxLQUFLb0QsaUJBQWlCLENBQUM7WUFBRUMsc0JBQXNCO1FBQUs7UUFDOUUsTUFBTUMsYUFBYTtZQUNmQyxXQUFXTjtZQUNYRTtZQUNBUDtRQUNKO1FBQ0EsTUFBTWxCLGNBQWN4QyxXQUFXUSxPQUFPLENBQUNzRCxlQUFlLENBQUNNO1FBQ3ZELE1BQU0xQixjQUFjRjtRQUNwQkEsWUFBWUcsT0FBTyxDQUNkQyxJQUFJLENBQUM7WUFDTixNQUFNUSxNQUFNdEIsU0FBU3dDLGFBQWEsQ0FBQztZQUNuQ2xCLElBQUltQixTQUFTLEdBQUc7WUFDaEJSLE1BQU1TLE1BQU0sQ0FBQ3BCO1lBQ2IxQixXQUFXMkIsT0FBTyxHQUFHRDtZQUNyQixNQUFNcUIsZ0JBQWdCVixNQUFNVyxnQkFBZ0IsQ0FBQztZQUM3QyxJQUFJakUsb0JBQW9CO2dCQUNwQixJQUFJa0UsUUFBUTtnQkFDWnRELFlBQVl1RCxLQUFLLENBQUNDLE9BQU8sQ0FBQyxDQUFDeEUsTUFBTXlFO29CQUM3QixJQUFJLENBQUMxRSxXQUFXQyxPQUFPO3dCQUNuQjtvQkFDSjtvQkFDQSxNQUFNMEUsUUFBUU4sYUFBYSxDQUFDRSxNQUFNO29CQUNsQyxJQUFJLENBQUNJLE9BQU87d0JBQ1I7b0JBQ0o7b0JBQ0EsTUFBTUMsVUFBVXZFLG1CQUFtQnpDLE9BQU9pSCxNQUFNLENBQUM7d0JBQUVsRTt3QkFDL0NDO3dCQUNBOEQ7b0JBQVUsR0FBR3pFO29CQUNqQjBFLE1BQU1mLFNBQVMsR0FBR2dCO29CQUNsQkwsU0FBU3RFLEtBQUs2RSxHQUFHLElBQUk3RSxLQUFLOEUsTUFBTSxHQUFHLElBQUk7Z0JBQzNDO1lBQ0o7WUFDQSxpQ0FBaUM7WUFDakNuQztRQUNKLEdBQ0tGLEtBQUssQ0FBQ0k7UUFDWCxPQUFPLElBQU0sQ0FBQyxHQUFHL0MsV0FBVzRDLGlCQUFpQixFQUFFTDtJQUNuRDtJQUNDLElBQUdoRCxRQUFRMEYsZUFBZSxFQUFFdEIsaUJBQWlCO1FBQzFDckQ7UUFDQXlDO1FBQ0FGO1FBQ0FsQztRQUNBQztRQUNBQztRQUNBSztRQUNBcUM7S0FDSDtJQUNELE9BQ0EsbUVBQW1FO0lBQ25FaEUsUUFBUWMsT0FBTyxDQUFDOEQsYUFBYSxDQUFDLE9BQU87UUFBRUMsV0FBVyxDQUFDLEdBQUcxRSxPQUFPVyxPQUFPLEVBQUUsZ0NBQWdDO1FBQWNnRCxXQUFXQTtRQUFXTCxhQUFhQTtRQUFha0MsS0FBSzdEO0lBQWE7QUFDMUw7S0FoS1NsQjtBQWlLVGIsa0JBQWUsR0FBR2EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXBkZi9kaXN0L2Nqcy9QYWdlL1RleHRMYXllci5qcz83YmM3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuJ3VzZSBjbGllbnQnO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCByZWFjdF8xID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJyZWFjdFwiKSk7XG5jb25zdCBtYWtlX2NhbmNlbGxhYmxlX3Byb21pc2VfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwibWFrZS1jYW5jZWxsYWJsZS1wcm9taXNlXCIpKTtcbmNvbnN0IGNsc3hfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiY2xzeFwiKSk7XG5jb25zdCB0aW55X2ludmFyaWFudF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJ0aW55LWludmFyaWFudFwiKSk7XG5jb25zdCB3YXJuaW5nXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIndhcm5pbmdcIikpO1xuY29uc3QgcGRmanNfanNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vcGRmanMuanNcIikpO1xuY29uc3QgdXNlUGFnZUNvbnRleHRfanNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vc2hhcmVkL2hvb2tzL3VzZVBhZ2VDb250ZXh0LmpzXCIpKTtcbmNvbnN0IHVzZVJlc29sdmVyX2pzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL3NoYXJlZC9ob29rcy91c2VSZXNvbHZlci5qc1wiKSk7XG5jb25zdCB1dGlsc19qc18xID0gcmVxdWlyZShcIi4uL3NoYXJlZC91dGlscy5qc1wiKTtcbmZ1bmN0aW9uIGlzVGV4dEl0ZW0oaXRlbSkge1xuICAgIHJldHVybiAnc3RyJyBpbiBpdGVtO1xufVxuZnVuY3Rpb24gVGV4dExheWVyKCkge1xuICAgIGNvbnN0IHBhZ2VDb250ZXh0ID0gKDAsIHVzZVBhZ2VDb250ZXh0X2pzXzEuZGVmYXVsdCkoKTtcbiAgICAoMCwgdGlueV9pbnZhcmlhbnRfMS5kZWZhdWx0KShwYWdlQ29udGV4dCwgJ1VuYWJsZSB0byBmaW5kIFBhZ2UgY29udGV4dC4nKTtcbiAgICBjb25zdCB7IGN1c3RvbVRleHRSZW5kZXJlciwgb25HZXRUZXh0RXJyb3IsIG9uR2V0VGV4dFN1Y2Nlc3MsIG9uUmVuZGVyVGV4dExheWVyRXJyb3IsIG9uUmVuZGVyVGV4dExheWVyU3VjY2VzcywgcGFnZSwgcGFnZUluZGV4LCBwYWdlTnVtYmVyLCByb3RhdGUsIHNjYWxlLCB9ID0gcGFnZUNvbnRleHQ7XG4gICAgKDAsIHRpbnlfaW52YXJpYW50XzEuZGVmYXVsdCkocGFnZSwgJ0F0dGVtcHRlZCB0byBsb2FkIHBhZ2UgdGV4dCBjb250ZW50LCBidXQgbm8gcGFnZSB3YXMgc3BlY2lmaWVkLicpO1xuICAgIGNvbnN0IFt0ZXh0Q29udGVudFN0YXRlLCB0ZXh0Q29udGVudERpc3BhdGNoXSA9ICgwLCB1c2VSZXNvbHZlcl9qc18xLmRlZmF1bHQpKCk7XG4gICAgY29uc3QgeyB2YWx1ZTogdGV4dENvbnRlbnQsIGVycm9yOiB0ZXh0Q29udGVudEVycm9yIH0gPSB0ZXh0Q29udGVudFN0YXRlO1xuICAgIGNvbnN0IGxheWVyRWxlbWVudCA9ICgwLCByZWFjdF8xLnVzZVJlZikobnVsbCk7XG4gICAgY29uc3QgZW5kRWxlbWVudCA9ICgwLCByZWFjdF8xLnVzZVJlZikoKTtcbiAgICAoMCwgd2FybmluZ18xLmRlZmF1bHQpKHBhcnNlSW50KHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGRvY3VtZW50LmJvZHkpLmdldFByb3BlcnR5VmFsdWUoJy0tcmVhY3QtcGRmLXRleHQtbGF5ZXInKSwgMTApID09PSAxLCAnVGV4dExheWVyIHN0eWxlcyBub3QgZm91bmQuIFJlYWQgbW9yZTogaHR0cHM6Ly9naXRodWIuY29tL3dvanRla21hai9yZWFjdC1wZGYjc3VwcG9ydC1mb3ItdGV4dC1sYXllcicpO1xuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuIGEgcGFnZSB0ZXh0IGNvbnRlbnQgaXMgcmVhZCBzdWNjZXNzZnVsbHlcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvbkxvYWRTdWNjZXNzKCkge1xuICAgICAgICBpZiAoIXRleHRDb250ZW50KSB7XG4gICAgICAgICAgICAvLyBJbXBvc3NpYmxlLCBidXQgVHlwZVNjcmlwdCBkb2Vzbid0IGtub3cgdGhhdFxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvbkdldFRleHRTdWNjZXNzKSB7XG4gICAgICAgICAgICBvbkdldFRleHRTdWNjZXNzKHRleHRDb250ZW50KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbiBhIHBhZ2UgdGV4dCBjb250ZW50IGZhaWxlZCB0byByZWFkIHN1Y2Nlc3NmdWxseVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG9uTG9hZEVycm9yKCkge1xuICAgICAgICBpZiAoIXRleHRDb250ZW50RXJyb3IpIHtcbiAgICAgICAgICAgIC8vIEltcG9zc2libGUsIGJ1dCBUeXBlU2NyaXB0IGRvZXNuJ3Qga25vdyB0aGF0XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgKDAsIHdhcm5pbmdfMS5kZWZhdWx0KShmYWxzZSwgdGV4dENvbnRlbnRFcnJvci50b1N0cmluZygpKTtcbiAgICAgICAgaWYgKG9uR2V0VGV4dEVycm9yKSB7XG4gICAgICAgICAgICBvbkdldFRleHRFcnJvcih0ZXh0Q29udGVudEVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiByZXNldFRleHRDb250ZW50KCkge1xuICAgICAgICB0ZXh0Q29udGVudERpc3BhdGNoKHsgdHlwZTogJ1JFU0VUJyB9KTtcbiAgICB9XG4gICAgKDAsIHJlYWN0XzEudXNlRWZmZWN0KShyZXNldFRleHRDb250ZW50LCBbcGFnZSwgdGV4dENvbnRlbnREaXNwYXRjaF0pO1xuICAgIGZ1bmN0aW9uIGxvYWRUZXh0Q29udGVudCgpIHtcbiAgICAgICAgaWYgKCFwYWdlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2FuY2VsbGFibGUgPSAoMCwgbWFrZV9jYW5jZWxsYWJsZV9wcm9taXNlXzEuZGVmYXVsdCkocGFnZS5nZXRUZXh0Q29udGVudCgpKTtcbiAgICAgICAgY29uc3QgcnVubmluZ1Rhc2sgPSBjYW5jZWxsYWJsZTtcbiAgICAgICAgY2FuY2VsbGFibGUucHJvbWlzZVxuICAgICAgICAgICAgLnRoZW4oKG5leHRUZXh0Q29udGVudCkgPT4ge1xuICAgICAgICAgICAgdGV4dENvbnRlbnREaXNwYXRjaCh7IHR5cGU6ICdSRVNPTFZFJywgdmFsdWU6IG5leHRUZXh0Q29udGVudCB9KTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgICAgIHRleHRDb250ZW50RGlzcGF0Y2goeyB0eXBlOiAnUkVKRUNUJywgZXJyb3IgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gKCkgPT4gKDAsIHV0aWxzX2pzXzEuY2FuY2VsUnVubmluZ1Rhc2spKHJ1bm5pbmdUYXNrKTtcbiAgICB9XG4gICAgKDAsIHJlYWN0XzEudXNlRWZmZWN0KShsb2FkVGV4dENvbnRlbnQsIFtwYWdlLCB0ZXh0Q29udGVudERpc3BhdGNoXSk7XG4gICAgKDAsIHJlYWN0XzEudXNlRWZmZWN0KSgoKSA9PiB7XG4gICAgICAgIGlmICh0ZXh0Q29udGVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRleHRDb250ZW50ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgb25Mb2FkRXJyb3IoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBvbkxvYWRTdWNjZXNzKCk7XG4gICAgfSwgXG4gICAgLy8gT21taXR0ZWQgY2FsbGJhY2tzIHNvIHRoZXkgYXJlIG5vdCBjYWxsZWQgZXZlcnkgdGltZSB0aGV5IGNoYW5nZVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgICBbdGV4dENvbnRlbnRdKTtcbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbiBhIHRleHQgbGF5ZXIgaXMgcmVuZGVyZWQgc3VjY2Vzc2Z1bGx5XG4gICAgICovXG4gICAgY29uc3Qgb25SZW5kZXJTdWNjZXNzID0gKDAsIHJlYWN0XzEudXNlQ2FsbGJhY2spKCgpID0+IHtcbiAgICAgICAgaWYgKG9uUmVuZGVyVGV4dExheWVyU3VjY2Vzcykge1xuICAgICAgICAgICAgb25SZW5kZXJUZXh0TGF5ZXJTdWNjZXNzKCk7XG4gICAgICAgIH1cbiAgICB9LCBbb25SZW5kZXJUZXh0TGF5ZXJTdWNjZXNzXSk7XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW4gYSB0ZXh0IGxheWVyIGZhaWxlZCB0byByZW5kZXIgc3VjY2Vzc2Z1bGx5XG4gICAgICovXG4gICAgY29uc3Qgb25SZW5kZXJFcnJvciA9ICgwLCByZWFjdF8xLnVzZUNhbGxiYWNrKSgoZXJyb3IpID0+IHtcbiAgICAgICAgKDAsIHdhcm5pbmdfMS5kZWZhdWx0KShmYWxzZSwgZXJyb3IudG9TdHJpbmcoKSk7XG4gICAgICAgIGlmIChvblJlbmRlclRleHRMYXllckVycm9yKSB7XG4gICAgICAgICAgICBvblJlbmRlclRleHRMYXllckVycm9yKGVycm9yKTtcbiAgICAgICAgfVxuICAgIH0sIFtvblJlbmRlclRleHRMYXllckVycm9yXSk7XG4gICAgZnVuY3Rpb24gb25Nb3VzZURvd24oKSB7XG4gICAgICAgIGNvbnN0IGVuZCA9IGVuZEVsZW1lbnQuY3VycmVudDtcbiAgICAgICAgaWYgKCFlbmQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBlbmQuY2xhc3NMaXN0LmFkZCgnYWN0aXZlJyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uTW91c2VVcCgpIHtcbiAgICAgICAgY29uc3QgZW5kID0gZW5kRWxlbWVudC5jdXJyZW50O1xuICAgICAgICBpZiAoIWVuZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGVuZC5jbGFzc0xpc3QucmVtb3ZlKCdhY3RpdmUnKTtcbiAgICB9XG4gICAgY29uc3Qgdmlld3BvcnQgPSAoMCwgcmVhY3RfMS51c2VNZW1vKSgoKSA9PiBwYWdlLmdldFZpZXdwb3J0KHsgc2NhbGUsIHJvdGF0aW9uOiByb3RhdGUgfSksIFtwYWdlLCByb3RhdGUsIHNjYWxlXSk7XG4gICAgZnVuY3Rpb24gcmVuZGVyVGV4dExheWVyKCkge1xuICAgICAgICBpZiAoIXBhZ2UgfHwgIXRleHRDb250ZW50KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBjdXJyZW50OiBsYXllciB9ID0gbGF5ZXJFbGVtZW50O1xuICAgICAgICBpZiAoIWxheWVyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGF5ZXIuaW5uZXJIVE1MID0gJyc7XG4gICAgICAgIGNvbnN0IHRleHRDb250ZW50U291cmNlID0gcGFnZS5zdHJlYW1UZXh0Q29udGVudCh7IGluY2x1ZGVNYXJrZWRDb250ZW50OiB0cnVlIH0pO1xuICAgICAgICBjb25zdCBwYXJhbWV0ZXJzID0ge1xuICAgICAgICAgICAgY29udGFpbmVyOiBsYXllcixcbiAgICAgICAgICAgIHRleHRDb250ZW50U291cmNlLFxuICAgICAgICAgICAgdmlld3BvcnQsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGNhbmNlbGxhYmxlID0gcGRmanNfanNfMS5kZWZhdWx0LnJlbmRlclRleHRMYXllcihwYXJhbWV0ZXJzKTtcbiAgICAgICAgY29uc3QgcnVubmluZ1Rhc2sgPSBjYW5jZWxsYWJsZTtcbiAgICAgICAgY2FuY2VsbGFibGUucHJvbWlzZVxuICAgICAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZW5kID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICBlbmQuY2xhc3NOYW1lID0gJ2VuZE9mQ29udGVudCc7XG4gICAgICAgICAgICBsYXllci5hcHBlbmQoZW5kKTtcbiAgICAgICAgICAgIGVuZEVsZW1lbnQuY3VycmVudCA9IGVuZDtcbiAgICAgICAgICAgIGNvbnN0IGxheWVyQ2hpbGRyZW4gPSBsYXllci5xdWVyeVNlbGVjdG9yQWxsKCdbcm9sZT1cInByZXNlbnRhdGlvblwiXScpO1xuICAgICAgICAgICAgaWYgKGN1c3RvbVRleHRSZW5kZXJlcikge1xuICAgICAgICAgICAgICAgIGxldCBpbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgdGV4dENvbnRlbnQuaXRlbXMuZm9yRWFjaCgoaXRlbSwgaXRlbUluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNUZXh0SXRlbShpdGVtKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkID0gbGF5ZXJDaGlsZHJlbltpbmRleF07XG4gICAgICAgICAgICAgICAgICAgIGlmICghY2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb250ZW50ID0gY3VzdG9tVGV4dFJlbmRlcmVyKE9iamVjdC5hc3NpZ24oeyBwYWdlSW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYWdlTnVtYmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbUluZGV4IH0sIGl0ZW0pKTtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQuaW5uZXJIVE1MID0gY29udGVudDtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggKz0gaXRlbS5zdHIgJiYgaXRlbS5oYXNFT0wgPyAyIDogMTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEludGVudGlvbmFsIGltbWVkaWF0ZSBjYWxsYmFja1xuICAgICAgICAgICAgb25SZW5kZXJTdWNjZXNzKCk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2gob25SZW5kZXJFcnJvcik7XG4gICAgICAgIHJldHVybiAoKSA9PiAoMCwgdXRpbHNfanNfMS5jYW5jZWxSdW5uaW5nVGFzaykocnVubmluZ1Rhc2spO1xuICAgIH1cbiAgICAoMCwgcmVhY3RfMS51c2VMYXlvdXRFZmZlY3QpKHJlbmRlclRleHRMYXllciwgW1xuICAgICAgICBjdXN0b21UZXh0UmVuZGVyZXIsXG4gICAgICAgIG9uUmVuZGVyRXJyb3IsXG4gICAgICAgIG9uUmVuZGVyU3VjY2VzcyxcbiAgICAgICAgcGFnZSxcbiAgICAgICAgcGFnZUluZGV4LFxuICAgICAgICBwYWdlTnVtYmVyLFxuICAgICAgICB0ZXh0Q29udGVudCxcbiAgICAgICAgdmlld3BvcnQsXG4gICAgXSk7XG4gICAgcmV0dXJuIChcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUganN4LWExMXkvbm8tc3RhdGljLWVsZW1lbnQtaW50ZXJhY3Rpb25zXG4gICAgcmVhY3RfMS5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6ICgwLCBjbHN4XzEuZGVmYXVsdCkoJ3JlYWN0LXBkZl9fUGFnZV9fdGV4dENvbnRlbnQnLCAndGV4dExheWVyJyksIG9uTW91c2VVcDogb25Nb3VzZVVwLCBvbk1vdXNlRG93bjogb25Nb3VzZURvd24sIHJlZjogbGF5ZXJFbGVtZW50IH0pKTtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IFRleHRMYXllcjtcbiJdLCJuYW1lcyI6WyJfX2NyZWF0ZUJpbmRpbmciLCJPYmplY3QiLCJjcmVhdGUiLCJvIiwibSIsImsiLCJrMiIsInVuZGVmaW5lZCIsImRlc2MiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJfX2VzTW9kdWxlIiwid3JpdGFibGUiLCJjb25maWd1cmFibGUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiZGVmaW5lUHJvcGVydHkiLCJfX3NldE1vZHVsZURlZmF1bHQiLCJ2IiwidmFsdWUiLCJfX2ltcG9ydFN0YXIiLCJtb2QiLCJyZXN1bHQiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJfX2ltcG9ydERlZmF1bHQiLCJleHBvcnRzIiwicmVhY3RfMSIsInJlcXVpcmUiLCJtYWtlX2NhbmNlbGxhYmxlX3Byb21pc2VfMSIsImNsc3hfMSIsInRpbnlfaW52YXJpYW50XzEiLCJ3YXJuaW5nXzEiLCJwZGZqc19qc18xIiwidXNlUGFnZUNvbnRleHRfanNfMSIsInVzZVJlc29sdmVyX2pzXzEiLCJ1dGlsc19qc18xIiwiaXNUZXh0SXRlbSIsIml0ZW0iLCJUZXh0TGF5ZXIiLCJwYWdlQ29udGV4dCIsImRlZmF1bHQiLCJjdXN0b21UZXh0UmVuZGVyZXIiLCJvbkdldFRleHRFcnJvciIsIm9uR2V0VGV4dFN1Y2Nlc3MiLCJvblJlbmRlclRleHRMYXllckVycm9yIiwib25SZW5kZXJUZXh0TGF5ZXJTdWNjZXNzIiwicGFnZSIsInBhZ2VJbmRleCIsInBhZ2VOdW1iZXIiLCJyb3RhdGUiLCJzY2FsZSIsInRleHRDb250ZW50U3RhdGUiLCJ0ZXh0Q29udGVudERpc3BhdGNoIiwidGV4dENvbnRlbnQiLCJlcnJvciIsInRleHRDb250ZW50RXJyb3IiLCJsYXllckVsZW1lbnQiLCJ1c2VSZWYiLCJlbmRFbGVtZW50IiwicGFyc2VJbnQiLCJ3aW5kb3ciLCJnZXRDb21wdXRlZFN0eWxlIiwiZG9jdW1lbnQiLCJib2R5IiwiZ2V0UHJvcGVydHlWYWx1ZSIsIm9uTG9hZFN1Y2Nlc3MiLCJvbkxvYWRFcnJvciIsInRvU3RyaW5nIiwicmVzZXRUZXh0Q29udGVudCIsInR5cGUiLCJ1c2VFZmZlY3QiLCJsb2FkVGV4dENvbnRlbnQiLCJjYW5jZWxsYWJsZSIsImdldFRleHRDb250ZW50IiwicnVubmluZ1Rhc2siLCJwcm9taXNlIiwidGhlbiIsIm5leHRUZXh0Q29udGVudCIsImNhdGNoIiwiY2FuY2VsUnVubmluZ1Rhc2siLCJvblJlbmRlclN1Y2Nlc3MiLCJ1c2VDYWxsYmFjayIsIm9uUmVuZGVyRXJyb3IiLCJvbk1vdXNlRG93biIsImVuZCIsImN1cnJlbnQiLCJjbGFzc0xpc3QiLCJhZGQiLCJvbk1vdXNlVXAiLCJyZW1vdmUiLCJ2aWV3cG9ydCIsInVzZU1lbW8iLCJnZXRWaWV3cG9ydCIsInJvdGF0aW9uIiwicmVuZGVyVGV4dExheWVyIiwibGF5ZXIiLCJpbm5lckhUTUwiLCJ0ZXh0Q29udGVudFNvdXJjZSIsInN0cmVhbVRleHRDb250ZW50IiwiaW5jbHVkZU1hcmtlZENvbnRlbnQiLCJwYXJhbWV0ZXJzIiwiY29udGFpbmVyIiwiY3JlYXRlRWxlbWVudCIsImNsYXNzTmFtZSIsImFwcGVuZCIsImxheWVyQ2hpbGRyZW4iLCJxdWVyeVNlbGVjdG9yQWxsIiwiaW5kZXgiLCJpdGVtcyIsImZvckVhY2giLCJpdGVtSW5kZXgiLCJjaGlsZCIsImNvbnRlbnQiLCJhc3NpZ24iLCJzdHIiLCJoYXNFT0wiLCJ1c2VMYXlvdXRFZmZlY3QiLCJyZWYiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-pdf/dist/cjs/Page/TextLayer.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-pdf/dist/cjs/PageContext.js":
/*!********************************************************!*\
  !*** ./node_modules/react-pdf/dist/cjs/PageContext.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/* __next_internal_client_entry_do_not_use__  cjs */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nconst react_1 = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\nexports[\"default\"] = (0, react_1.createContext)(null);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1wZGYvZGlzdC9janMvUGFnZUNvbnRleHQuanMiLCJtYXBwaW5ncyI6InFEQUFhO0FBRWJBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdELE1BQU1DLFVBQVVDLG1CQUFPQSxDQUFDLG1GQUFPO0FBQy9CSCxrQkFBZSxHQUFHLENBQUMsR0FBR0UsUUFBUUcsYUFBYSxFQUFFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFjdC1wZGYvZGlzdC9janMvUGFnZUNvbnRleHQuanM/YmY0MCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbid1c2UgY2xpZW50Jztcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHJlYWN0XzEgPSByZXF1aXJlKFwicmVhY3RcIik7XG5leHBvcnRzLmRlZmF1bHQgPSAoMCwgcmVhY3RfMS5jcmVhdGVDb250ZXh0KShudWxsKTtcbiJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsInJlYWN0XzEiLCJyZXF1aXJlIiwiZGVmYXVsdCIsImNyZWF0ZUNvbnRleHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-pdf/dist/cjs/PageContext.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-pdf/dist/cjs/PasswordResponses.js":
/*!**************************************************************!*\
  !*** ./node_modules/react-pdf/dist/cjs/PasswordResponses.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n// As defined in https://github.com/mozilla/pdf.js/blob/d9fac3459609a807be6506fb3441b5da4b154d14/src/shared/util.js#L371-L374\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst PasswordResponses = {\n    NEED_PASSWORD: 1,\n    INCORRECT_PASSWORD: 2,\n};\nexports[\"default\"] = PasswordResponses;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1wZGYvZGlzdC9janMvUGFzc3dvcmRSZXNwb25zZXMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFlIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFjdC1wZGYvZGlzdC9janMvUGFzc3dvcmRSZXNwb25zZXMuanM/YTNkZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vIEFzIGRlZmluZWQgaW4gaHR0cHM6Ly9naXRodWIuY29tL21vemlsbGEvcGRmLmpzL2Jsb2IvZDlmYWMzNDU5NjA5YTgwN2JlNjUwNmZiMzQ0MWI1ZGE0YjE1NGQxNC9zcmMvc2hhcmVkL3V0aWwuanMjTDM3MS1MMzc0XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBQYXNzd29yZFJlc3BvbnNlcyA9IHtcbiAgICBORUVEX1BBU1NXT1JEOiAxLFxuICAgIElOQ09SUkVDVF9QQVNTV09SRDogMixcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBQYXNzd29yZFJlc3BvbnNlcztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-pdf/dist/cjs/PasswordResponses.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-pdf/dist/cjs/Ref.js":
/*!************************************************!*\
  !*** ./node_modules/react-pdf/dist/cjs/Ref.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nclass Ref {\n    constructor({ num, gen }) {\n        this.num = num;\n        this.gen = gen;\n    }\n    toString() {\n        let str = `${this.num}R`;\n        if (this.gen !== 0) {\n            str += this.gen;\n        }\n        return str;\n    }\n}\nexports[\"default\"] = Ref;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1wZGYvZGlzdC9janMvUmVmLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdEO0FBQ0Esa0JBQWtCLFVBQVU7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsU0FBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBZSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVhY3QtcGRmL2Rpc3QvY2pzL1JlZi5qcz8wNjQ1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY2xhc3MgUmVmIHtcbiAgICBjb25zdHJ1Y3Rvcih7IG51bSwgZ2VuIH0pIHtcbiAgICAgICAgdGhpcy5udW0gPSBudW07XG4gICAgICAgIHRoaXMuZ2VuID0gZ2VuO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgbGV0IHN0ciA9IGAke3RoaXMubnVtfVJgO1xuICAgICAgICBpZiAodGhpcy5nZW4gIT09IDApIHtcbiAgICAgICAgICAgIHN0ciArPSB0aGlzLmdlbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyO1xuICAgIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IFJlZjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-pdf/dist/cjs/Ref.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-pdf/dist/cjs/StructTree.js":
/*!*******************************************************!*\
  !*** ./node_modules/react-pdf/dist/cjs/StructTree.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst react_1 = __importStar(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"));\nconst make_cancellable_promise_1 = __importDefault(__webpack_require__(/*! make-cancellable-promise */ \"(app-pages-browser)/./node_modules/make-cancellable-promise/dist/cjs/index.js\"));\nconst tiny_invariant_1 = __importDefault(__webpack_require__(/*! tiny-invariant */ \"(app-pages-browser)/./node_modules/tiny-invariant/dist/tiny-invariant.cjs.js\"));\nconst warning_1 = __importDefault(__webpack_require__(/*! warning */ \"(app-pages-browser)/./node_modules/warning/warning.js\"));\nconst StructTreeItem_js_1 = __importDefault(__webpack_require__(/*! ./StructTreeItem.js */ \"(app-pages-browser)/./node_modules/react-pdf/dist/cjs/StructTreeItem.js\"));\nconst usePageContext_js_1 = __importDefault(__webpack_require__(/*! ./shared/hooks/usePageContext.js */ \"(app-pages-browser)/./node_modules/react-pdf/dist/cjs/shared/hooks/usePageContext.js\"));\nconst useResolver_js_1 = __importDefault(__webpack_require__(/*! ./shared/hooks/useResolver.js */ \"(app-pages-browser)/./node_modules/react-pdf/dist/cjs/shared/hooks/useResolver.js\"));\nconst utils_js_1 = __webpack_require__(/*! ./shared/utils.js */ \"(app-pages-browser)/./node_modules/react-pdf/dist/cjs/shared/utils.js\");\nfunction StructTree() {\n    const pageContext = (0, usePageContext_js_1.default)();\n    (0, tiny_invariant_1.default)(pageContext, 'Unable to find Page context.');\n    const { onGetStructTreeError: onGetStructTreeErrorProps, onGetStructTreeSuccess: onGetStructTreeSuccessProps, } = pageContext;\n    const [structTreeState, structTreeDispatch] = (0, useResolver_js_1.default)();\n    const { value: structTree, error: structTreeError } = structTreeState;\n    const { customTextRenderer, page } = pageContext;\n    function onLoadSuccess() {\n        if (!structTree) {\n            // Impossible, but TypeScript doesn't know that\n            return;\n        }\n        if (onGetStructTreeSuccessProps) {\n            onGetStructTreeSuccessProps(structTree);\n        }\n    }\n    function onLoadError() {\n        if (!structTreeError) {\n            // Impossible, but TypeScript doesn't know that\n            return;\n        }\n        (0, warning_1.default)(false, structTreeError.toString());\n        if (onGetStructTreeErrorProps) {\n            onGetStructTreeErrorProps(structTreeError);\n        }\n    }\n    function resetAnnotations() {\n        structTreeDispatch({ type: 'RESET' });\n    }\n    (0, react_1.useEffect)(resetAnnotations, [structTreeDispatch, page]);\n    function loadStructTree() {\n        if (customTextRenderer) {\n            // TODO: Document why this is necessary\n            return;\n        }\n        if (!page) {\n            return;\n        }\n        const cancellable = (0, make_cancellable_promise_1.default)(page.getStructTree());\n        const runningTask = cancellable;\n        cancellable.promise\n            .then((nextStructTree) => {\n            structTreeDispatch({ type: 'RESOLVE', value: nextStructTree });\n        })\n            .catch((error) => {\n            structTreeDispatch({ type: 'REJECT', error });\n        });\n        return () => (0, utils_js_1.cancelRunningTask)(runningTask);\n    }\n    (0, react_1.useEffect)(loadStructTree, [customTextRenderer, page, structTreeDispatch]);\n    (0, react_1.useEffect)(() => {\n        if (structTree === undefined) {\n            return;\n        }\n        if (structTree === false) {\n            onLoadError();\n            return;\n        }\n        onLoadSuccess();\n    }, \n    // Ommitted callbacks so they are not called every time they change\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [structTree]);\n    if (!structTree) {\n        return null;\n    }\n    return react_1.default.createElement(StructTreeItem_js_1.default, { className: \"react-pdf__Page__structTree structTree\", node: structTree });\n}\nexports[\"default\"] = StructTree;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1wZGYvZGlzdC9janMvU3RydWN0VHJlZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsMENBQTBDLDRCQUE0QjtBQUN0RSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCw2QkFBNkIsbUJBQU8sQ0FBQyxtRkFBTztBQUM1QyxtREFBbUQsbUJBQU8sQ0FBQywrR0FBMEI7QUFDckYseUNBQXlDLG1CQUFPLENBQUMsb0dBQWdCO0FBQ2pFLGtDQUFrQyxtQkFBTyxDQUFDLHNFQUFTO0FBQ25ELDRDQUE0QyxtQkFBTyxDQUFDLG9HQUFxQjtBQUN6RSw0Q0FBNEMsbUJBQU8sQ0FBQyw4SEFBa0M7QUFDdEYseUNBQXlDLG1CQUFPLENBQUMsd0hBQStCO0FBQ2hGLG1CQUFtQixtQkFBTyxDQUFDLGdHQUFtQjtBQUM5QztBQUNBO0FBQ0E7QUFDQSxZQUFZLHdHQUF3RztBQUNwSDtBQUNBLFlBQVksNENBQTRDO0FBQ3hELFlBQVksMkJBQTJCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsZUFBZTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLHdDQUF3QztBQUN6RSxTQUFTO0FBQ1Q7QUFDQSxpQ0FBaUMsdUJBQXVCO0FBQ3hELFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFLHVFQUF1RTtBQUMvSTtBQUNBLGtCQUFlIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFjdC1wZGYvZGlzdC9janMvU3RydWN0VHJlZS5qcz81YWY4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCByZWFjdF8xID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJyZWFjdFwiKSk7XG5jb25zdCBtYWtlX2NhbmNlbGxhYmxlX3Byb21pc2VfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwibWFrZS1jYW5jZWxsYWJsZS1wcm9taXNlXCIpKTtcbmNvbnN0IHRpbnlfaW52YXJpYW50XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcInRpbnktaW52YXJpYW50XCIpKTtcbmNvbnN0IHdhcm5pbmdfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwid2FybmluZ1wiKSk7XG5jb25zdCBTdHJ1Y3RUcmVlSXRlbV9qc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL1N0cnVjdFRyZWVJdGVtLmpzXCIpKTtcbmNvbnN0IHVzZVBhZ2VDb250ZXh0X2pzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vc2hhcmVkL2hvb2tzL3VzZVBhZ2VDb250ZXh0LmpzXCIpKTtcbmNvbnN0IHVzZVJlc29sdmVyX2pzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vc2hhcmVkL2hvb2tzL3VzZVJlc29sdmVyLmpzXCIpKTtcbmNvbnN0IHV0aWxzX2pzXzEgPSByZXF1aXJlKFwiLi9zaGFyZWQvdXRpbHMuanNcIik7XG5mdW5jdGlvbiBTdHJ1Y3RUcmVlKCkge1xuICAgIGNvbnN0IHBhZ2VDb250ZXh0ID0gKDAsIHVzZVBhZ2VDb250ZXh0X2pzXzEuZGVmYXVsdCkoKTtcbiAgICAoMCwgdGlueV9pbnZhcmlhbnRfMS5kZWZhdWx0KShwYWdlQ29udGV4dCwgJ1VuYWJsZSB0byBmaW5kIFBhZ2UgY29udGV4dC4nKTtcbiAgICBjb25zdCB7IG9uR2V0U3RydWN0VHJlZUVycm9yOiBvbkdldFN0cnVjdFRyZWVFcnJvclByb3BzLCBvbkdldFN0cnVjdFRyZWVTdWNjZXNzOiBvbkdldFN0cnVjdFRyZWVTdWNjZXNzUHJvcHMsIH0gPSBwYWdlQ29udGV4dDtcbiAgICBjb25zdCBbc3RydWN0VHJlZVN0YXRlLCBzdHJ1Y3RUcmVlRGlzcGF0Y2hdID0gKDAsIHVzZVJlc29sdmVyX2pzXzEuZGVmYXVsdCkoKTtcbiAgICBjb25zdCB7IHZhbHVlOiBzdHJ1Y3RUcmVlLCBlcnJvcjogc3RydWN0VHJlZUVycm9yIH0gPSBzdHJ1Y3RUcmVlU3RhdGU7XG4gICAgY29uc3QgeyBjdXN0b21UZXh0UmVuZGVyZXIsIHBhZ2UgfSA9IHBhZ2VDb250ZXh0O1xuICAgIGZ1bmN0aW9uIG9uTG9hZFN1Y2Nlc3MoKSB7XG4gICAgICAgIGlmICghc3RydWN0VHJlZSkge1xuICAgICAgICAgICAgLy8gSW1wb3NzaWJsZSwgYnV0IFR5cGVTY3JpcHQgZG9lc24ndCBrbm93IHRoYXRcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAob25HZXRTdHJ1Y3RUcmVlU3VjY2Vzc1Byb3BzKSB7XG4gICAgICAgICAgICBvbkdldFN0cnVjdFRyZWVTdWNjZXNzUHJvcHMoc3RydWN0VHJlZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gb25Mb2FkRXJyb3IoKSB7XG4gICAgICAgIGlmICghc3RydWN0VHJlZUVycm9yKSB7XG4gICAgICAgICAgICAvLyBJbXBvc3NpYmxlLCBidXQgVHlwZVNjcmlwdCBkb2Vzbid0IGtub3cgdGhhdFxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgICgwLCB3YXJuaW5nXzEuZGVmYXVsdCkoZmFsc2UsIHN0cnVjdFRyZWVFcnJvci50b1N0cmluZygpKTtcbiAgICAgICAgaWYgKG9uR2V0U3RydWN0VHJlZUVycm9yUHJvcHMpIHtcbiAgICAgICAgICAgIG9uR2V0U3RydWN0VHJlZUVycm9yUHJvcHMoc3RydWN0VHJlZUVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiByZXNldEFubm90YXRpb25zKCkge1xuICAgICAgICBzdHJ1Y3RUcmVlRGlzcGF0Y2goeyB0eXBlOiAnUkVTRVQnIH0pO1xuICAgIH1cbiAgICAoMCwgcmVhY3RfMS51c2VFZmZlY3QpKHJlc2V0QW5ub3RhdGlvbnMsIFtzdHJ1Y3RUcmVlRGlzcGF0Y2gsIHBhZ2VdKTtcbiAgICBmdW5jdGlvbiBsb2FkU3RydWN0VHJlZSgpIHtcbiAgICAgICAgaWYgKGN1c3RvbVRleHRSZW5kZXJlcikge1xuICAgICAgICAgICAgLy8gVE9ETzogRG9jdW1lbnQgd2h5IHRoaXMgaXMgbmVjZXNzYXJ5XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwYWdlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2FuY2VsbGFibGUgPSAoMCwgbWFrZV9jYW5jZWxsYWJsZV9wcm9taXNlXzEuZGVmYXVsdCkocGFnZS5nZXRTdHJ1Y3RUcmVlKCkpO1xuICAgICAgICBjb25zdCBydW5uaW5nVGFzayA9IGNhbmNlbGxhYmxlO1xuICAgICAgICBjYW5jZWxsYWJsZS5wcm9taXNlXG4gICAgICAgICAgICAudGhlbigobmV4dFN0cnVjdFRyZWUpID0+IHtcbiAgICAgICAgICAgIHN0cnVjdFRyZWVEaXNwYXRjaCh7IHR5cGU6ICdSRVNPTFZFJywgdmFsdWU6IG5leHRTdHJ1Y3RUcmVlIH0pO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICAgICAgc3RydWN0VHJlZURpc3BhdGNoKHsgdHlwZTogJ1JFSkVDVCcsIGVycm9yIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuICgpID0+ICgwLCB1dGlsc19qc18xLmNhbmNlbFJ1bm5pbmdUYXNrKShydW5uaW5nVGFzayk7XG4gICAgfVxuICAgICgwLCByZWFjdF8xLnVzZUVmZmVjdCkobG9hZFN0cnVjdFRyZWUsIFtjdXN0b21UZXh0UmVuZGVyZXIsIHBhZ2UsIHN0cnVjdFRyZWVEaXNwYXRjaF0pO1xuICAgICgwLCByZWFjdF8xLnVzZUVmZmVjdCkoKCkgPT4ge1xuICAgICAgICBpZiAoc3RydWN0VHJlZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0cnVjdFRyZWUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBvbkxvYWRFcnJvcigpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG9uTG9hZFN1Y2Nlc3MoKTtcbiAgICB9LCBcbiAgICAvLyBPbW1pdHRlZCBjYWxsYmFja3Mgc28gdGhleSBhcmUgbm90IGNhbGxlZCBldmVyeSB0aW1lIHRoZXkgY2hhbmdlXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICAgIFtzdHJ1Y3RUcmVlXSk7XG4gICAgaWYgKCFzdHJ1Y3RUcmVlKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gcmVhY3RfMS5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoU3RydWN0VHJlZUl0ZW1fanNfMS5kZWZhdWx0LCB7IGNsYXNzTmFtZTogXCJyZWFjdC1wZGZfX1BhZ2VfX3N0cnVjdFRyZWUgc3RydWN0VHJlZVwiLCBub2RlOiBzdHJ1Y3RUcmVlIH0pO1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gU3RydWN0VHJlZTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-pdf/dist/cjs/StructTree.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-pdf/dist/cjs/StructTreeItem.js":
/*!***********************************************************!*\
  !*** ./node_modules/react-pdf/dist/cjs/StructTreeItem.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst react_1 = __importStar(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"));\nconst structTreeUtils_js_1 = __webpack_require__(/*! ./shared/structTreeUtils.js */ \"(app-pages-browser)/./node_modules/react-pdf/dist/cjs/shared/structTreeUtils.js\");\nfunction StructTreeItem({ className, node }) {\n    const attributes = (0, react_1.useMemo)(() => (0, structTreeUtils_js_1.getAttributes)(node), [node]);\n    const children = (0, react_1.useMemo)(() => {\n        if (!(0, structTreeUtils_js_1.isStructTreeNode)(node)) {\n            return null;\n        }\n        if ((0, structTreeUtils_js_1.isStructTreeNodeWithOnlyContentChild)(node)) {\n            return null;\n        }\n        return node.children.map((child, index) => {\n            return (\n            // eslint-disable-next-line react/no-array-index-key\n            react_1.default.createElement(StructTreeItem, { key: index, node: child }));\n        });\n    }, [node]);\n    return (react_1.default.createElement(\"span\", Object.assign({ className: className }, attributes), children));\n}\nexports[\"default\"] = StructTreeItem;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1wZGYvZGlzdC9janMvU3RydWN0VHJlZUl0ZW0uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDBDQUEwQyw0QkFBNEI7QUFDdEUsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDZCQUE2QixtQkFBTyxDQUFDLG1GQUFPO0FBQzVDLDZCQUE2QixtQkFBTyxDQUFDLG9IQUE2QjtBQUNsRSwwQkFBMEIsaUJBQWlCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQseUJBQXlCO0FBQ3JGLFNBQVM7QUFDVCxLQUFLO0FBQ0wsa0VBQWtFLHNCQUFzQjtBQUN4RjtBQUNBLGtCQUFlIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFjdC1wZGYvZGlzdC9janMvU3RydWN0VHJlZUl0ZW0uanM/NzcyMSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgcmVhY3RfMSA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwicmVhY3RcIikpO1xuY29uc3Qgc3RydWN0VHJlZVV0aWxzX2pzXzEgPSByZXF1aXJlKFwiLi9zaGFyZWQvc3RydWN0VHJlZVV0aWxzLmpzXCIpO1xuZnVuY3Rpb24gU3RydWN0VHJlZUl0ZW0oeyBjbGFzc05hbWUsIG5vZGUgfSkge1xuICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSAoMCwgcmVhY3RfMS51c2VNZW1vKSgoKSA9PiAoMCwgc3RydWN0VHJlZVV0aWxzX2pzXzEuZ2V0QXR0cmlidXRlcykobm9kZSksIFtub2RlXSk7XG4gICAgY29uc3QgY2hpbGRyZW4gPSAoMCwgcmVhY3RfMS51c2VNZW1vKSgoKSA9PiB7XG4gICAgICAgIGlmICghKDAsIHN0cnVjdFRyZWVVdGlsc19qc18xLmlzU3RydWN0VHJlZU5vZGUpKG5vZGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKDAsIHN0cnVjdFRyZWVVdGlsc19qc18xLmlzU3RydWN0VHJlZU5vZGVXaXRoT25seUNvbnRlbnRDaGlsZCkobm9kZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub2RlLmNoaWxkcmVuLm1hcCgoY2hpbGQsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0L25vLWFycmF5LWluZGV4LWtleVxuICAgICAgICAgICAgcmVhY3RfMS5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoU3RydWN0VHJlZUl0ZW0sIHsga2V5OiBpbmRleCwgbm9kZTogY2hpbGQgfSkpO1xuICAgICAgICB9KTtcbiAgICB9LCBbbm9kZV0pO1xuICAgIHJldHVybiAocmVhY3RfMS5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIE9iamVjdC5hc3NpZ24oeyBjbGFzc05hbWU6IGNsYXNzTmFtZSB9LCBhdHRyaWJ1dGVzKSwgY2hpbGRyZW4pKTtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IFN0cnVjdFRyZWVJdGVtO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-pdf/dist/cjs/StructTreeItem.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-pdf/dist/cjs/Thumbnail.js":
/*!******************************************************!*\
  !*** ./node_modules/react-pdf/dist/cjs/Thumbnail.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/* __next_internal_client_entry_do_not_use__  cjs */ \nvar __rest = (void 0) && (void 0).__rest || function(s, e) {\n    var t = {};\n    for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++){\n        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n    }\n    return t;\n};\nvar __importDefault = (void 0) && (void 0).__importDefault || function(mod) {\n    return mod && mod.__esModule ? mod : {\n        \"default\": mod\n    };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nconst react_1 = __importDefault(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"));\nconst clsx_1 = __importDefault(__webpack_require__(/*! clsx */ \"(app-pages-browser)/./node_modules/clsx/dist/clsx.js\"));\nconst tiny_invariant_1 = __importDefault(__webpack_require__(/*! tiny-invariant */ \"(app-pages-browser)/./node_modules/tiny-invariant/dist/tiny-invariant.cjs.js\"));\nconst Page_js_1 = __importDefault(__webpack_require__(/*! ./Page.js */ \"(app-pages-browser)/./node_modules/react-pdf/dist/cjs/Page.js\"));\nconst utils_js_1 = __webpack_require__(/*! ./shared/utils.js */ \"(app-pages-browser)/./node_modules/react-pdf/dist/cjs/shared/utils.js\");\nconst useDocumentContext_js_1 = __importDefault(__webpack_require__(/*! ./shared/hooks/useDocumentContext.js */ \"(app-pages-browser)/./node_modules/react-pdf/dist/cjs/shared/hooks/useDocumentContext.js\"));\n/**\n * Displays a thumbnail of a page. Does not render the annotation layer or the text layer. Does not register itself as a link target, so the user will not be scrolled to a Thumbnail component when clicked on an internal link (e.g. in Table of Contents). When clicked, attempts to navigate to the page clicked (similarly to a link in Outline).\n *\n * Should be placed inside `<Document />`. Alternatively, it can have `pdf` prop passed, which can be obtained from `<Document />`'s `onLoadSuccess` callback function.\n */ const Thumbnail = function Thumbnail(props) {\n    const documentContext = (0, useDocumentContext_js_1.default)();\n    const mergedProps = Object.assign(Object.assign({}, documentContext), props);\n    const { className, linkService, onItemClick, pageIndex: pageIndexProps, pageNumber: pageNumberProps, pdf } = mergedProps;\n    (0, tiny_invariant_1.default)(pdf, \"Attempted to load a thumbnail, but no document was specified. Wrap <Thumbnail /> in a <Document /> or pass explicit `pdf` prop.\");\n    const pageIndex = (0, utils_js_1.isProvided)(pageNumberProps) ? pageNumberProps - 1 : pageIndexProps !== null && pageIndexProps !== void 0 ? pageIndexProps : null;\n    const pageNumber = pageNumberProps !== null && pageNumberProps !== void 0 ? pageNumberProps : (0, utils_js_1.isProvided)(pageIndexProps) ? pageIndexProps + 1 : null;\n    function onClick(event) {\n        event.preventDefault();\n        if (!(0, utils_js_1.isProvided)(pageIndex) || !pageNumber) {\n            return;\n        }\n        (0, tiny_invariant_1.default)(onItemClick || linkService, \"Either onItemClick callback or linkService must be defined in order to navigate to an outline item.\");\n        if (onItemClick) {\n            onItemClick({\n                pageIndex,\n                pageNumber\n            });\n        } else if (linkService) {\n            linkService.goToPage(pageNumber);\n        }\n    }\n    const { className: classNameProps, onItemClick: onItemClickProps } = props, pageProps = __rest(props, [\n        \"className\",\n        \"onItemClick\"\n    ]);\n    return /* eslint-disable-next-line jsx-a11y/anchor-is-valid */ react_1.default.createElement(\"a\", {\n        className: (0, clsx_1.default)(\"react-pdf__Thumbnail\", className),\n        href: pageNumber ? \"#\" : undefined,\n        onClick: onClick\n    }, react_1.default.createElement(Page_js_1.default, Object.assign({}, pageProps, {\n        _className: \"react-pdf__Thumbnail__page\",\n        _enableRegisterUnregisterPage: false,\n        renderAnnotationLayer: false,\n        renderTextLayer: false\n    })));\n};\n_c = Thumbnail;\nexports[\"default\"] = Thumbnail;\nvar _c;\n$RefreshReg$(_c, \"Thumbnail\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1wZGYvZGlzdC9janMvVGh1bWJuYWlsLmpzIiwibWFwcGluZ3MiOiJxREFBYTtBQUViLElBQUlBLFNBQVMsQ0FBQyxNQUFHLEtBQUssT0FBRyxFQUFFQSxNQUFNLElBQUssU0FBVUMsQ0FBQyxFQUFFQyxDQUFDO0lBQ2hELElBQUlDLElBQUksQ0FBQztJQUNULElBQUssSUFBSUMsS0FBS0gsRUFBRyxJQUFJSSxPQUFPQyxTQUFTLENBQUNDLGNBQWMsQ0FBQ0MsSUFBSSxDQUFDUCxHQUFHRyxNQUFNRixFQUFFTyxPQUFPLENBQUNMLEtBQUssR0FDOUVELENBQUMsQ0FBQ0MsRUFBRSxHQUFHSCxDQUFDLENBQUNHLEVBQUU7SUFDZixJQUFJSCxLQUFLLFFBQVEsT0FBT0ksT0FBT0sscUJBQXFCLEtBQUssWUFDckQsSUFBSyxJQUFJQyxJQUFJLEdBQUdQLElBQUlDLE9BQU9LLHFCQUFxQixDQUFDVCxJQUFJVSxJQUFJUCxFQUFFUSxNQUFNLEVBQUVELElBQUs7UUFDcEUsSUFBSVQsRUFBRU8sT0FBTyxDQUFDTCxDQUFDLENBQUNPLEVBQUUsSUFBSSxLQUFLTixPQUFPQyxTQUFTLENBQUNPLG9CQUFvQixDQUFDTCxJQUFJLENBQUNQLEdBQUdHLENBQUMsQ0FBQ08sRUFBRSxHQUN6RVIsQ0FBQyxDQUFDQyxDQUFDLENBQUNPLEVBQUUsQ0FBQyxHQUFHVixDQUFDLENBQUNHLENBQUMsQ0FBQ08sRUFBRSxDQUFDO0lBQ3pCO0lBQ0osT0FBT1I7QUFDWDtBQUNBLElBQUlXLGtCQUFrQixDQUFDLE1BQUcsS0FBSyxPQUFHLEVBQUVBLGVBQWUsSUFBSyxTQUFVQyxHQUFHO0lBQ2pFLE9BQU8sT0FBUUEsSUFBSUMsVUFBVSxHQUFJRCxNQUFNO1FBQUUsV0FBV0E7SUFBSTtBQUM1RDtBQUNBViw4Q0FBNkM7SUFBRWMsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3RCxNQUFNQyxVQUFVTixnQkFBZ0JPLG1CQUFPQSxDQUFDLG1GQUFPO0FBQy9DLE1BQU1DLFNBQVNSLGdCQUFnQk8sbUJBQU9BLENBQUMsa0VBQU07QUFDN0MsTUFBTUUsbUJBQW1CVCxnQkFBZ0JPLG1CQUFPQSxDQUFDLG9HQUFnQjtBQUNqRSxNQUFNRyxZQUFZVixnQkFBZ0JPLG1CQUFPQSxDQUFDLGdGQUFXO0FBQ3JELE1BQU1JLGFBQWFKLG1CQUFPQSxDQUFDLGdHQUFtQjtBQUM5QyxNQUFNSywwQkFBMEJaLGdCQUFnQk8sbUJBQU9BLENBQUMsc0lBQXNDO0FBQzlGOzs7O0NBSUMsR0FDRCxNQUFNTSxZQUFZLFNBQVNBLFVBQVVDLEtBQUs7SUFDdEMsTUFBTUMsa0JBQWtCLENBQUMsR0FBR0gsd0JBQXdCSSxPQUFPO0lBQzNELE1BQU1DLGNBQWMxQixPQUFPMkIsTUFBTSxDQUFDM0IsT0FBTzJCLE1BQU0sQ0FBQyxDQUFDLEdBQUdILGtCQUFrQkQ7SUFDdEUsTUFBTSxFQUFFSyxTQUFTLEVBQUVDLFdBQVcsRUFBRUMsV0FBVyxFQUFFQyxXQUFXQyxjQUFjLEVBQUVDLFlBQVlDLGVBQWUsRUFBRUMsR0FBRyxFQUFHLEdBQUdUO0lBQzdHLElBQUdSLGlCQUFpQk8sT0FBTyxFQUFFVSxLQUFLO0lBQ25DLE1BQU1KLFlBQVksQ0FBQyxHQUFHWCxXQUFXZ0IsVUFBVSxFQUFFRixtQkFBbUJBLGtCQUFrQixJQUFJRixtQkFBbUIsUUFBUUEsbUJBQW1CLEtBQUssSUFBSUEsaUJBQWlCO0lBQzlKLE1BQU1DLGFBQWFDLG9CQUFvQixRQUFRQSxvQkFBb0IsS0FBSyxJQUFJQSxrQkFBbUIsQ0FBQyxHQUFHZCxXQUFXZ0IsVUFBVSxFQUFFSixrQkFBa0JBLGlCQUFpQixJQUFJO0lBQ2pLLFNBQVNLLFFBQVFDLEtBQUs7UUFDbEJBLE1BQU1DLGNBQWM7UUFDcEIsSUFBSSxDQUFDLENBQUMsR0FBR25CLFdBQVdnQixVQUFVLEVBQUVMLGNBQWMsQ0FBQ0UsWUFBWTtZQUN2RDtRQUNKO1FBQ0MsSUFBR2YsaUJBQWlCTyxPQUFPLEVBQUVLLGVBQWVELGFBQWE7UUFDMUQsSUFBSUMsYUFBYTtZQUNiQSxZQUFZO2dCQUNSQztnQkFDQUU7WUFDSjtRQUNKLE9BQ0ssSUFBSUosYUFBYTtZQUNsQkEsWUFBWVcsUUFBUSxDQUFDUDtRQUN6QjtJQUNKO0lBQ0EsTUFBTSxFQUFFTCxXQUFXYSxjQUFjLEVBQUVYLGFBQWFZLGdCQUFnQixFQUFFLEdBQUduQixPQUFPb0IsWUFBWWhELE9BQU80QixPQUFPO1FBQUM7UUFBYTtLQUFjO0lBQ2xJLE9BQ0EscURBQXFELEdBQ3JEUixRQUFRVSxPQUFPLENBQUNtQixhQUFhLENBQUMsS0FBSztRQUFFaEIsV0FBVyxDQUFDLEdBQUdYLE9BQU9RLE9BQU8sRUFBRSx3QkFBd0JHO1FBQVlpQixNQUFNWixhQUFhLE1BQU1hO1FBQVdULFNBQVNBO0lBQVEsR0FDekp0QixRQUFRVSxPQUFPLENBQUNtQixhQUFhLENBQUN6QixVQUFVTSxPQUFPLEVBQUV6QixPQUFPMkIsTUFBTSxDQUFDLENBQUMsR0FBR2dCLFdBQVc7UUFBRUksWUFBWTtRQUE4QkMsK0JBQStCO1FBQU9DLHVCQUF1QjtRQUFPQyxpQkFBaUI7SUFBTTtBQUM3TjtLQTVCTTVCO0FBNkJOVCxrQkFBZSxHQUFHUyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVhY3QtcGRmL2Rpc3QvY2pzL1RodW1ibmFpbC5qcz9jOTBmIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuJ3VzZSBjbGllbnQnO1xudmFyIF9fcmVzdCA9ICh0aGlzICYmIHRoaXMuX19yZXN0KSB8fCBmdW5jdGlvbiAocywgZSkge1xuICAgIHZhciB0ID0ge307XG4gICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApXG4gICAgICAgIHRbcF0gPSBzW3BdO1xuICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDAgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHBbaV0pKVxuICAgICAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xuICAgICAgICB9XG4gICAgcmV0dXJuIHQ7XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgcmVhY3RfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwicmVhY3RcIikpO1xuY29uc3QgY2xzeF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJjbHN4XCIpKTtcbmNvbnN0IHRpbnlfaW52YXJpYW50XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcInRpbnktaW52YXJpYW50XCIpKTtcbmNvbnN0IFBhZ2VfanNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9QYWdlLmpzXCIpKTtcbmNvbnN0IHV0aWxzX2pzXzEgPSByZXF1aXJlKFwiLi9zaGFyZWQvdXRpbHMuanNcIik7XG5jb25zdCB1c2VEb2N1bWVudENvbnRleHRfanNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9zaGFyZWQvaG9va3MvdXNlRG9jdW1lbnRDb250ZXh0LmpzXCIpKTtcbi8qKlxuICogRGlzcGxheXMgYSB0aHVtYm5haWwgb2YgYSBwYWdlLiBEb2VzIG5vdCByZW5kZXIgdGhlIGFubm90YXRpb24gbGF5ZXIgb3IgdGhlIHRleHQgbGF5ZXIuIERvZXMgbm90IHJlZ2lzdGVyIGl0c2VsZiBhcyBhIGxpbmsgdGFyZ2V0LCBzbyB0aGUgdXNlciB3aWxsIG5vdCBiZSBzY3JvbGxlZCB0byBhIFRodW1ibmFpbCBjb21wb25lbnQgd2hlbiBjbGlja2VkIG9uIGFuIGludGVybmFsIGxpbmsgKGUuZy4gaW4gVGFibGUgb2YgQ29udGVudHMpLiBXaGVuIGNsaWNrZWQsIGF0dGVtcHRzIHRvIG5hdmlnYXRlIHRvIHRoZSBwYWdlIGNsaWNrZWQgKHNpbWlsYXJseSB0byBhIGxpbmsgaW4gT3V0bGluZSkuXG4gKlxuICogU2hvdWxkIGJlIHBsYWNlZCBpbnNpZGUgYDxEb2N1bWVudCAvPmAuIEFsdGVybmF0aXZlbHksIGl0IGNhbiBoYXZlIGBwZGZgIHByb3AgcGFzc2VkLCB3aGljaCBjYW4gYmUgb2J0YWluZWQgZnJvbSBgPERvY3VtZW50IC8+YCdzIGBvbkxvYWRTdWNjZXNzYCBjYWxsYmFjayBmdW5jdGlvbi5cbiAqL1xuY29uc3QgVGh1bWJuYWlsID0gZnVuY3Rpb24gVGh1bWJuYWlsKHByb3BzKSB7XG4gICAgY29uc3QgZG9jdW1lbnRDb250ZXh0ID0gKDAsIHVzZURvY3VtZW50Q29udGV4dF9qc18xLmRlZmF1bHQpKCk7XG4gICAgY29uc3QgbWVyZ2VkUHJvcHMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGRvY3VtZW50Q29udGV4dCksIHByb3BzKTtcbiAgICBjb25zdCB7IGNsYXNzTmFtZSwgbGlua1NlcnZpY2UsIG9uSXRlbUNsaWNrLCBwYWdlSW5kZXg6IHBhZ2VJbmRleFByb3BzLCBwYWdlTnVtYmVyOiBwYWdlTnVtYmVyUHJvcHMsIHBkZiwgfSA9IG1lcmdlZFByb3BzO1xuICAgICgwLCB0aW55X2ludmFyaWFudF8xLmRlZmF1bHQpKHBkZiwgJ0F0dGVtcHRlZCB0byBsb2FkIGEgdGh1bWJuYWlsLCBidXQgbm8gZG9jdW1lbnQgd2FzIHNwZWNpZmllZC4gV3JhcCA8VGh1bWJuYWlsIC8+IGluIGEgPERvY3VtZW50IC8+IG9yIHBhc3MgZXhwbGljaXQgYHBkZmAgcHJvcC4nKTtcbiAgICBjb25zdCBwYWdlSW5kZXggPSAoMCwgdXRpbHNfanNfMS5pc1Byb3ZpZGVkKShwYWdlTnVtYmVyUHJvcHMpID8gcGFnZU51bWJlclByb3BzIC0gMSA6IHBhZ2VJbmRleFByb3BzICE9PSBudWxsICYmIHBhZ2VJbmRleFByb3BzICE9PSB2b2lkIDAgPyBwYWdlSW5kZXhQcm9wcyA6IG51bGw7XG4gICAgY29uc3QgcGFnZU51bWJlciA9IHBhZ2VOdW1iZXJQcm9wcyAhPT0gbnVsbCAmJiBwYWdlTnVtYmVyUHJvcHMgIT09IHZvaWQgMCA/IHBhZ2VOdW1iZXJQcm9wcyA6ICgoMCwgdXRpbHNfanNfMS5pc1Byb3ZpZGVkKShwYWdlSW5kZXhQcm9wcykgPyBwYWdlSW5kZXhQcm9wcyArIDEgOiBudWxsKTtcbiAgICBmdW5jdGlvbiBvbkNsaWNrKGV2ZW50KSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGlmICghKDAsIHV0aWxzX2pzXzEuaXNQcm92aWRlZCkocGFnZUluZGV4KSB8fCAhcGFnZU51bWJlcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgICgwLCB0aW55X2ludmFyaWFudF8xLmRlZmF1bHQpKG9uSXRlbUNsaWNrIHx8IGxpbmtTZXJ2aWNlLCAnRWl0aGVyIG9uSXRlbUNsaWNrIGNhbGxiYWNrIG9yIGxpbmtTZXJ2aWNlIG11c3QgYmUgZGVmaW5lZCBpbiBvcmRlciB0byBuYXZpZ2F0ZSB0byBhbiBvdXRsaW5lIGl0ZW0uJyk7XG4gICAgICAgIGlmIChvbkl0ZW1DbGljaykge1xuICAgICAgICAgICAgb25JdGVtQ2xpY2soe1xuICAgICAgICAgICAgICAgIHBhZ2VJbmRleCxcbiAgICAgICAgICAgICAgICBwYWdlTnVtYmVyLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobGlua1NlcnZpY2UpIHtcbiAgICAgICAgICAgIGxpbmtTZXJ2aWNlLmdvVG9QYWdlKHBhZ2VOdW1iZXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHsgY2xhc3NOYW1lOiBjbGFzc05hbWVQcm9wcywgb25JdGVtQ2xpY2s6IG9uSXRlbUNsaWNrUHJvcHMgfSA9IHByb3BzLCBwYWdlUHJvcHMgPSBfX3Jlc3QocHJvcHMsIFtcImNsYXNzTmFtZVwiLCBcIm9uSXRlbUNsaWNrXCJdKTtcbiAgICByZXR1cm4gKFxuICAgIC8qIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBqc3gtYTExeS9hbmNob3ItaXMtdmFsaWQgKi9cbiAgICByZWFjdF8xLmRlZmF1bHQuY3JlYXRlRWxlbWVudChcImFcIiwgeyBjbGFzc05hbWU6ICgwLCBjbHN4XzEuZGVmYXVsdCkoJ3JlYWN0LXBkZl9fVGh1bWJuYWlsJywgY2xhc3NOYW1lKSwgaHJlZjogcGFnZU51bWJlciA/ICcjJyA6IHVuZGVmaW5lZCwgb25DbGljazogb25DbGljayB9LFxuICAgICAgICByZWFjdF8xLmRlZmF1bHQuY3JlYXRlRWxlbWVudChQYWdlX2pzXzEuZGVmYXVsdCwgT2JqZWN0LmFzc2lnbih7fSwgcGFnZVByb3BzLCB7IF9jbGFzc05hbWU6IFwicmVhY3QtcGRmX19UaHVtYm5haWxfX3BhZ2VcIiwgX2VuYWJsZVJlZ2lzdGVyVW5yZWdpc3RlclBhZ2U6IGZhbHNlLCByZW5kZXJBbm5vdGF0aW9uTGF5ZXI6IGZhbHNlLCByZW5kZXJUZXh0TGF5ZXI6IGZhbHNlIH0pKSkpO1xufTtcbmV4cG9ydHMuZGVmYXVsdCA9IFRodW1ibmFpbDtcbiJdLCJuYW1lcyI6WyJfX3Jlc3QiLCJzIiwiZSIsInQiLCJwIiwiT2JqZWN0IiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiaW5kZXhPZiIsImdldE93blByb3BlcnR5U3ltYm9scyIsImkiLCJsZW5ndGgiLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsIl9faW1wb3J0RGVmYXVsdCIsIm1vZCIsIl9fZXNNb2R1bGUiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsInJlYWN0XzEiLCJyZXF1aXJlIiwiY2xzeF8xIiwidGlueV9pbnZhcmlhbnRfMSIsIlBhZ2VfanNfMSIsInV0aWxzX2pzXzEiLCJ1c2VEb2N1bWVudENvbnRleHRfanNfMSIsIlRodW1ibmFpbCIsInByb3BzIiwiZG9jdW1lbnRDb250ZXh0IiwiZGVmYXVsdCIsIm1lcmdlZFByb3BzIiwiYXNzaWduIiwiY2xhc3NOYW1lIiwibGlua1NlcnZpY2UiLCJvbkl0ZW1DbGljayIsInBhZ2VJbmRleCIsInBhZ2VJbmRleFByb3BzIiwicGFnZU51bWJlciIsInBhZ2VOdW1iZXJQcm9wcyIsInBkZiIsImlzUHJvdmlkZWQiLCJvbkNsaWNrIiwiZXZlbnQiLCJwcmV2ZW50RGVmYXVsdCIsImdvVG9QYWdlIiwiY2xhc3NOYW1lUHJvcHMiLCJvbkl0ZW1DbGlja1Byb3BzIiwicGFnZVByb3BzIiwiY3JlYXRlRWxlbWVudCIsImhyZWYiLCJ1bmRlZmluZWQiLCJfY2xhc3NOYW1lIiwiX2VuYWJsZVJlZ2lzdGVyVW5yZWdpc3RlclBhZ2UiLCJyZW5kZXJBbm5vdGF0aW9uTGF5ZXIiLCJyZW5kZXJUZXh0TGF5ZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-pdf/dist/cjs/Thumbnail.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-pdf/dist/cjs/index.js":
/*!**************************************************!*\
  !*** ./node_modules/react-pdf/dist/cjs/index.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.PasswordResponses = exports.usePageContext = exports.useOutlineContext = exports.useDocumentContext = exports.Thumbnail = exports.Page = exports.Outline = exports.Document = exports.pdfjs = void 0;\nconst pdfjs_js_1 = __importDefault(__webpack_require__(/*! ./pdfjs.js */ \"(app-pages-browser)/./node_modules/react-pdf/dist/cjs/pdfjs.js\"));\nexports.pdfjs = pdfjs_js_1.default;\nconst Document_js_1 = __importDefault(__webpack_require__(/*! ./Document.js */ \"(app-pages-browser)/./node_modules/react-pdf/dist/cjs/Document.js\"));\nexports.Document = Document_js_1.default;\nconst Outline_js_1 = __importDefault(__webpack_require__(/*! ./Outline.js */ \"(app-pages-browser)/./node_modules/react-pdf/dist/cjs/Outline.js\"));\nexports.Outline = Outline_js_1.default;\nconst Page_js_1 = __importDefault(__webpack_require__(/*! ./Page.js */ \"(app-pages-browser)/./node_modules/react-pdf/dist/cjs/Page.js\"));\nexports.Page = Page_js_1.default;\nconst Thumbnail_js_1 = __importDefault(__webpack_require__(/*! ./Thumbnail.js */ \"(app-pages-browser)/./node_modules/react-pdf/dist/cjs/Thumbnail.js\"));\nexports.Thumbnail = Thumbnail_js_1.default;\nconst useDocumentContext_js_1 = __importDefault(__webpack_require__(/*! ./shared/hooks/useDocumentContext.js */ \"(app-pages-browser)/./node_modules/react-pdf/dist/cjs/shared/hooks/useDocumentContext.js\"));\nexports.useDocumentContext = useDocumentContext_js_1.default;\nconst useOutlineContext_js_1 = __importDefault(__webpack_require__(/*! ./shared/hooks/useOutlineContext.js */ \"(app-pages-browser)/./node_modules/react-pdf/dist/cjs/shared/hooks/useOutlineContext.js\"));\nexports.useOutlineContext = useOutlineContext_js_1.default;\nconst usePageContext_js_1 = __importDefault(__webpack_require__(/*! ./shared/hooks/usePageContext.js */ \"(app-pages-browser)/./node_modules/react-pdf/dist/cjs/shared/hooks/usePageContext.js\"));\nexports.usePageContext = usePageContext_js_1.default;\nconst PasswordResponses_js_1 = __importDefault(__webpack_require__(/*! ./PasswordResponses.js */ \"(app-pages-browser)/./node_modules/react-pdf/dist/cjs/PasswordResponses.js\"));\nexports.PasswordResponses = PasswordResponses_js_1.default;\nconst utils_js_1 = __webpack_require__(/*! ./shared/utils.js */ \"(app-pages-browser)/./node_modules/react-pdf/dist/cjs/shared/utils.js\");\n(0, utils_js_1.displayWorkerWarning)();\npdfjs_js_1.default.GlobalWorkerOptions.workerSrc = 'pdf.worker.js';\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1wZGYvZGlzdC9janMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx5QkFBeUIsR0FBRyxzQkFBc0IsR0FBRyx5QkFBeUIsR0FBRywwQkFBMEIsR0FBRyxpQkFBaUIsR0FBRyxZQUFZLEdBQUcsZUFBZSxHQUFHLGdCQUFnQixHQUFHLGFBQWE7QUFDbk0sbUNBQW1DLG1CQUFPLENBQUMsa0ZBQVk7QUFDdkQsYUFBYTtBQUNiLHNDQUFzQyxtQkFBTyxDQUFDLHdGQUFlO0FBQzdELGdCQUFnQjtBQUNoQixxQ0FBcUMsbUJBQU8sQ0FBQyxzRkFBYztBQUMzRCxlQUFlO0FBQ2Ysa0NBQWtDLG1CQUFPLENBQUMsZ0ZBQVc7QUFDckQsWUFBWTtBQUNaLHVDQUF1QyxtQkFBTyxDQUFDLDBGQUFnQjtBQUMvRCxpQkFBaUI7QUFDakIsZ0RBQWdELG1CQUFPLENBQUMsc0lBQXNDO0FBQzlGLDBCQUEwQjtBQUMxQiwrQ0FBK0MsbUJBQU8sQ0FBQyxvSUFBcUM7QUFDNUYseUJBQXlCO0FBQ3pCLDRDQUE0QyxtQkFBTyxDQUFDLDhIQUFrQztBQUN0RixzQkFBc0I7QUFDdEIsK0NBQStDLG1CQUFPLENBQUMsMEdBQXdCO0FBQy9FLHlCQUF5QjtBQUN6QixtQkFBbUIsbUJBQU8sQ0FBQyxnR0FBbUI7QUFDOUM7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVhY3QtcGRmL2Rpc3QvY2pzL2luZGV4LmpzPzc2ODkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlBhc3N3b3JkUmVzcG9uc2VzID0gZXhwb3J0cy51c2VQYWdlQ29udGV4dCA9IGV4cG9ydHMudXNlT3V0bGluZUNvbnRleHQgPSBleHBvcnRzLnVzZURvY3VtZW50Q29udGV4dCA9IGV4cG9ydHMuVGh1bWJuYWlsID0gZXhwb3J0cy5QYWdlID0gZXhwb3J0cy5PdXRsaW5lID0gZXhwb3J0cy5Eb2N1bWVudCA9IGV4cG9ydHMucGRmanMgPSB2b2lkIDA7XG5jb25zdCBwZGZqc19qc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL3BkZmpzLmpzXCIpKTtcbmV4cG9ydHMucGRmanMgPSBwZGZqc19qc18xLmRlZmF1bHQ7XG5jb25zdCBEb2N1bWVudF9qc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL0RvY3VtZW50LmpzXCIpKTtcbmV4cG9ydHMuRG9jdW1lbnQgPSBEb2N1bWVudF9qc18xLmRlZmF1bHQ7XG5jb25zdCBPdXRsaW5lX2pzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vT3V0bGluZS5qc1wiKSk7XG5leHBvcnRzLk91dGxpbmUgPSBPdXRsaW5lX2pzXzEuZGVmYXVsdDtcbmNvbnN0IFBhZ2VfanNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9QYWdlLmpzXCIpKTtcbmV4cG9ydHMuUGFnZSA9IFBhZ2VfanNfMS5kZWZhdWx0O1xuY29uc3QgVGh1bWJuYWlsX2pzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vVGh1bWJuYWlsLmpzXCIpKTtcbmV4cG9ydHMuVGh1bWJuYWlsID0gVGh1bWJuYWlsX2pzXzEuZGVmYXVsdDtcbmNvbnN0IHVzZURvY3VtZW50Q29udGV4dF9qc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL3NoYXJlZC9ob29rcy91c2VEb2N1bWVudENvbnRleHQuanNcIikpO1xuZXhwb3J0cy51c2VEb2N1bWVudENvbnRleHQgPSB1c2VEb2N1bWVudENvbnRleHRfanNfMS5kZWZhdWx0O1xuY29uc3QgdXNlT3V0bGluZUNvbnRleHRfanNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9zaGFyZWQvaG9va3MvdXNlT3V0bGluZUNvbnRleHQuanNcIikpO1xuZXhwb3J0cy51c2VPdXRsaW5lQ29udGV4dCA9IHVzZU91dGxpbmVDb250ZXh0X2pzXzEuZGVmYXVsdDtcbmNvbnN0IHVzZVBhZ2VDb250ZXh0X2pzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vc2hhcmVkL2hvb2tzL3VzZVBhZ2VDb250ZXh0LmpzXCIpKTtcbmV4cG9ydHMudXNlUGFnZUNvbnRleHQgPSB1c2VQYWdlQ29udGV4dF9qc18xLmRlZmF1bHQ7XG5jb25zdCBQYXNzd29yZFJlc3BvbnNlc19qc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL1Bhc3N3b3JkUmVzcG9uc2VzLmpzXCIpKTtcbmV4cG9ydHMuUGFzc3dvcmRSZXNwb25zZXMgPSBQYXNzd29yZFJlc3BvbnNlc19qc18xLmRlZmF1bHQ7XG5jb25zdCB1dGlsc19qc18xID0gcmVxdWlyZShcIi4vc2hhcmVkL3V0aWxzLmpzXCIpO1xuKDAsIHV0aWxzX2pzXzEuZGlzcGxheVdvcmtlcldhcm5pbmcpKCk7XG5wZGZqc19qc18xLmRlZmF1bHQuR2xvYmFsV29ya2VyT3B0aW9ucy53b3JrZXJTcmMgPSAncGRmLndvcmtlci5qcyc7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-pdf/dist/cjs/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-pdf/dist/cjs/pdfjs.js":
/*!**************************************************!*\
  !*** ./node_modules/react-pdf/dist/cjs/pdfjs.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst pdfjsModule = __importStar(__webpack_require__(/*! pdfjs-dist */ \"(app-pages-browser)/./node_modules/react-pdf/node_modules/pdfjs-dist/build/pdf.js\"));\nconst pdfjs = ('default' in pdfjsModule ? pdfjsModule['default'] : pdfjsModule);\nexports[\"default\"] = pdfjs;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1wZGYvZGlzdC9janMvcGRmanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDBDQUEwQyw0QkFBNEI7QUFDdEUsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGlDQUFpQyxtQkFBTyxDQUFDLHFHQUFZO0FBQ3JEO0FBQ0Esa0JBQWUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXBkZi9kaXN0L2Nqcy9wZGZqcy5qcz84ZTMyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBwZGZqc01vZHVsZSA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwicGRmanMtZGlzdFwiKSk7XG5jb25zdCBwZGZqcyA9ICgnZGVmYXVsdCcgaW4gcGRmanNNb2R1bGUgPyBwZGZqc01vZHVsZVsnZGVmYXVsdCddIDogcGRmanNNb2R1bGUpO1xuZXhwb3J0cy5kZWZhdWx0ID0gcGRmanM7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-pdf/dist/cjs/pdfjs.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-pdf/dist/cjs/shared/constants.js":
/*!*************************************************************!*\
  !*** ./node_modules/react-pdf/dist/cjs/shared/constants.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n// From pdfjs-dist/lib/web/struct_tree_layer_builder.js\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.HEADING_PATTERN = exports.PDF_ROLE_TO_HTML_ROLE = void 0;\nexports.PDF_ROLE_TO_HTML_ROLE = {\n    // Document level structure types\n    Document: null, // There's a \"document\" role, but it doesn't make sense here.\n    DocumentFragment: null,\n    // Grouping level structure types\n    Part: 'group',\n    Sect: 'group', // XXX: There's a \"section\" role, but it's abstract.\n    Div: 'group',\n    Aside: 'note',\n    NonStruct: 'none',\n    // Block level structure types\n    P: null,\n    // H<n>,\n    H: 'heading',\n    Title: null,\n    FENote: 'note',\n    // Sub-block level structure type\n    Sub: 'group',\n    // General inline level structure types\n    Lbl: null,\n    Span: null,\n    Em: null,\n    Strong: null,\n    Link: 'link',\n    Annot: 'note',\n    Form: 'form',\n    // Ruby and Warichu structure types\n    Ruby: null,\n    RB: null,\n    RT: null,\n    RP: null,\n    Warichu: null,\n    WT: null,\n    WP: null,\n    // List standard structure types\n    L: 'list',\n    LI: 'listitem',\n    LBody: null,\n    // Table standard structure types\n    Table: 'table',\n    TR: 'row',\n    TH: 'columnheader',\n    TD: 'cell',\n    THead: 'columnheader',\n    TBody: null,\n    TFoot: null,\n    // Standard structure type Caption\n    Caption: null,\n    // Standard structure type Figure\n    Figure: 'figure',\n    // Standard structure type Formula\n    Formula: null,\n    // standard structure type Artifact\n    Artifact: null,\n};\nexports.HEADING_PATTERN = /^H(\\d+)$/;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1wZGYvZGlzdC9janMvc2hhcmVkL2NvbnN0YW50cy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHVCQUF1QixHQUFHLDZCQUE2QjtBQUN2RCw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFjdC1wZGYvZGlzdC9janMvc2hhcmVkL2NvbnN0YW50cy5qcz83OTNiIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLy8gRnJvbSBwZGZqcy1kaXN0L2xpYi93ZWIvc3RydWN0X3RyZWVfbGF5ZXJfYnVpbGRlci5qc1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5IRUFESU5HX1BBVFRFUk4gPSBleHBvcnRzLlBERl9ST0xFX1RPX0hUTUxfUk9MRSA9IHZvaWQgMDtcbmV4cG9ydHMuUERGX1JPTEVfVE9fSFRNTF9ST0xFID0ge1xuICAgIC8vIERvY3VtZW50IGxldmVsIHN0cnVjdHVyZSB0eXBlc1xuICAgIERvY3VtZW50OiBudWxsLCAvLyBUaGVyZSdzIGEgXCJkb2N1bWVudFwiIHJvbGUsIGJ1dCBpdCBkb2Vzbid0IG1ha2Ugc2Vuc2UgaGVyZS5cbiAgICBEb2N1bWVudEZyYWdtZW50OiBudWxsLFxuICAgIC8vIEdyb3VwaW5nIGxldmVsIHN0cnVjdHVyZSB0eXBlc1xuICAgIFBhcnQ6ICdncm91cCcsXG4gICAgU2VjdDogJ2dyb3VwJywgLy8gWFhYOiBUaGVyZSdzIGEgXCJzZWN0aW9uXCIgcm9sZSwgYnV0IGl0J3MgYWJzdHJhY3QuXG4gICAgRGl2OiAnZ3JvdXAnLFxuICAgIEFzaWRlOiAnbm90ZScsXG4gICAgTm9uU3RydWN0OiAnbm9uZScsXG4gICAgLy8gQmxvY2sgbGV2ZWwgc3RydWN0dXJlIHR5cGVzXG4gICAgUDogbnVsbCxcbiAgICAvLyBIPG4+LFxuICAgIEg6ICdoZWFkaW5nJyxcbiAgICBUaXRsZTogbnVsbCxcbiAgICBGRU5vdGU6ICdub3RlJyxcbiAgICAvLyBTdWItYmxvY2sgbGV2ZWwgc3RydWN0dXJlIHR5cGVcbiAgICBTdWI6ICdncm91cCcsXG4gICAgLy8gR2VuZXJhbCBpbmxpbmUgbGV2ZWwgc3RydWN0dXJlIHR5cGVzXG4gICAgTGJsOiBudWxsLFxuICAgIFNwYW46IG51bGwsXG4gICAgRW06IG51bGwsXG4gICAgU3Ryb25nOiBudWxsLFxuICAgIExpbms6ICdsaW5rJyxcbiAgICBBbm5vdDogJ25vdGUnLFxuICAgIEZvcm06ICdmb3JtJyxcbiAgICAvLyBSdWJ5IGFuZCBXYXJpY2h1IHN0cnVjdHVyZSB0eXBlc1xuICAgIFJ1Ynk6IG51bGwsXG4gICAgUkI6IG51bGwsXG4gICAgUlQ6IG51bGwsXG4gICAgUlA6IG51bGwsXG4gICAgV2FyaWNodTogbnVsbCxcbiAgICBXVDogbnVsbCxcbiAgICBXUDogbnVsbCxcbiAgICAvLyBMaXN0IHN0YW5kYXJkIHN0cnVjdHVyZSB0eXBlc1xuICAgIEw6ICdsaXN0JyxcbiAgICBMSTogJ2xpc3RpdGVtJyxcbiAgICBMQm9keTogbnVsbCxcbiAgICAvLyBUYWJsZSBzdGFuZGFyZCBzdHJ1Y3R1cmUgdHlwZXNcbiAgICBUYWJsZTogJ3RhYmxlJyxcbiAgICBUUjogJ3JvdycsXG4gICAgVEg6ICdjb2x1bW5oZWFkZXInLFxuICAgIFREOiAnY2VsbCcsXG4gICAgVEhlYWQ6ICdjb2x1bW5oZWFkZXInLFxuICAgIFRCb2R5OiBudWxsLFxuICAgIFRGb290OiBudWxsLFxuICAgIC8vIFN0YW5kYXJkIHN0cnVjdHVyZSB0eXBlIENhcHRpb25cbiAgICBDYXB0aW9uOiBudWxsLFxuICAgIC8vIFN0YW5kYXJkIHN0cnVjdHVyZSB0eXBlIEZpZ3VyZVxuICAgIEZpZ3VyZTogJ2ZpZ3VyZScsXG4gICAgLy8gU3RhbmRhcmQgc3RydWN0dXJlIHR5cGUgRm9ybXVsYVxuICAgIEZvcm11bGE6IG51bGwsXG4gICAgLy8gc3RhbmRhcmQgc3RydWN0dXJlIHR5cGUgQXJ0aWZhY3RcbiAgICBBcnRpZmFjdDogbnVsbCxcbn07XG5leHBvcnRzLkhFQURJTkdfUEFUVEVSTiA9IC9eSChcXGQrKSQvO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-pdf/dist/cjs/shared/constants.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-pdf/dist/cjs/shared/hooks/useCachedValue.js":
/*!************************************************************************!*\
  !*** ./node_modules/react-pdf/dist/cjs/shared/hooks/useCachedValue.js ***!
  \************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/* __next_internal_client_entry_do_not_use__  cjs */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nconst react_1 = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\nconst utils_js_1 = __webpack_require__(/*! ../utils.js */ \"(app-pages-browser)/./node_modules/react-pdf/dist/cjs/shared/utils.js\");\nfunction useCachedValue(getter) {\n    const ref = (0, react_1.useRef)();\n    const currentValue = ref.current;\n    if ((0, utils_js_1.isDefined)(currentValue)) {\n        return ()=>currentValue;\n    }\n    return ()=>{\n        const value = getter();\n        ref.current = value;\n        return value;\n    };\n}\nexports[\"default\"] = useCachedValue;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1wZGYvZGlzdC9janMvc2hhcmVkL2hvb2tzL3VzZUNhY2hlZFZhbHVlLmpzIiwibWFwcGluZ3MiOiJxREFBYTtBQUViQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3RCxNQUFNQyxVQUFVQyxtQkFBT0EsQ0FBQyxtRkFBTztBQUMvQixNQUFNQyxhQUFhRCxtQkFBT0EsQ0FBQywwRkFBYTtBQUN4QyxTQUFTRSxlQUFlQyxNQUFNO0lBQzFCLE1BQU1DLE1BQU0sQ0FBQyxHQUFHTCxRQUFRTSxNQUFNO0lBQzlCLE1BQU1DLGVBQWVGLElBQUlHLE9BQU87SUFDaEMsSUFBSSxDQUFDLEdBQUdOLFdBQVdPLFNBQVMsRUFBRUYsZUFBZTtRQUN6QyxPQUFPLElBQU1BO0lBQ2pCO0lBQ0EsT0FBTztRQUNILE1BQU1SLFFBQVFLO1FBQ2RDLElBQUlHLE9BQU8sR0FBR1Q7UUFDZCxPQUFPQTtJQUNYO0FBQ0o7QUFDQUQsa0JBQWUsR0FBR0siLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXBkZi9kaXN0L2Nqcy9zaGFyZWQvaG9va3MvdXNlQ2FjaGVkVmFsdWUuanM/ZjM0YyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbid1c2UgY2xpZW50Jztcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHJlYWN0XzEgPSByZXF1aXJlKFwicmVhY3RcIik7XG5jb25zdCB1dGlsc19qc18xID0gcmVxdWlyZShcIi4uL3V0aWxzLmpzXCIpO1xuZnVuY3Rpb24gdXNlQ2FjaGVkVmFsdWUoZ2V0dGVyKSB7XG4gICAgY29uc3QgcmVmID0gKDAsIHJlYWN0XzEudXNlUmVmKSgpO1xuICAgIGNvbnN0IGN1cnJlbnRWYWx1ZSA9IHJlZi5jdXJyZW50O1xuICAgIGlmICgoMCwgdXRpbHNfanNfMS5pc0RlZmluZWQpKGN1cnJlbnRWYWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuICgpID0+IGN1cnJlbnRWYWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBnZXR0ZXIoKTtcbiAgICAgICAgcmVmLmN1cnJlbnQgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG59XG5leHBvcnRzLmRlZmF1bHQgPSB1c2VDYWNoZWRWYWx1ZTtcbiJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsInJlYWN0XzEiLCJyZXF1aXJlIiwidXRpbHNfanNfMSIsInVzZUNhY2hlZFZhbHVlIiwiZ2V0dGVyIiwicmVmIiwidXNlUmVmIiwiY3VycmVudFZhbHVlIiwiY3VycmVudCIsImlzRGVmaW5lZCIsImRlZmF1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-pdf/dist/cjs/shared/hooks/useCachedValue.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-pdf/dist/cjs/shared/hooks/useDocumentContext.js":
/*!****************************************************************************!*\
  !*** ./node_modules/react-pdf/dist/cjs/shared/hooks/useDocumentContext.js ***!
  \****************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst react_1 = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\nconst DocumentContext_js_1 = __importDefault(__webpack_require__(/*! ../../DocumentContext.js */ \"(app-pages-browser)/./node_modules/react-pdf/dist/cjs/DocumentContext.js\"));\nfunction useDocumentContext() {\n    return (0, react_1.useContext)(DocumentContext_js_1.default);\n}\nexports[\"default\"] = useDocumentContext;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1wZGYvZGlzdC9janMvc2hhcmVkL2hvb2tzL3VzZURvY3VtZW50Q29udGV4dC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGdCQUFnQixtQkFBTyxDQUFDLG1GQUFPO0FBQy9CLDZDQUE2QyxtQkFBTyxDQUFDLDBHQUEwQjtBQUMvRTtBQUNBO0FBQ0E7QUFDQSxrQkFBZSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVhY3QtcGRmL2Rpc3QvY2pzL3NoYXJlZC9ob29rcy91c2VEb2N1bWVudENvbnRleHQuanM/YmFjYyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHJlYWN0XzEgPSByZXF1aXJlKFwicmVhY3RcIik7XG5jb25zdCBEb2N1bWVudENvbnRleHRfanNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vLi4vRG9jdW1lbnRDb250ZXh0LmpzXCIpKTtcbmZ1bmN0aW9uIHVzZURvY3VtZW50Q29udGV4dCgpIHtcbiAgICByZXR1cm4gKDAsIHJlYWN0XzEudXNlQ29udGV4dCkoRG9jdW1lbnRDb250ZXh0X2pzXzEuZGVmYXVsdCk7XG59XG5leHBvcnRzLmRlZmF1bHQgPSB1c2VEb2N1bWVudENvbnRleHQ7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-pdf/dist/cjs/shared/hooks/useDocumentContext.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-pdf/dist/cjs/shared/hooks/useOutlineContext.js":
/*!***************************************************************************!*\
  !*** ./node_modules/react-pdf/dist/cjs/shared/hooks/useOutlineContext.js ***!
  \***************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst react_1 = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\nconst OutlineContext_js_1 = __importDefault(__webpack_require__(/*! ../../OutlineContext.js */ \"(app-pages-browser)/./node_modules/react-pdf/dist/cjs/OutlineContext.js\"));\nfunction useOutlineContext() {\n    return (0, react_1.useContext)(OutlineContext_js_1.default);\n}\nexports[\"default\"] = useOutlineContext;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1wZGYvZGlzdC9janMvc2hhcmVkL2hvb2tzL3VzZU91dGxpbmVDb250ZXh0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZ0JBQWdCLG1CQUFPLENBQUMsbUZBQU87QUFDL0IsNENBQTRDLG1CQUFPLENBQUMsd0dBQXlCO0FBQzdFO0FBQ0E7QUFDQTtBQUNBLGtCQUFlIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFjdC1wZGYvZGlzdC9janMvc2hhcmVkL2hvb2tzL3VzZU91dGxpbmVDb250ZXh0LmpzP2QwMDAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCByZWFjdF8xID0gcmVxdWlyZShcInJlYWN0XCIpO1xuY29uc3QgT3V0bGluZUNvbnRleHRfanNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vLi4vT3V0bGluZUNvbnRleHQuanNcIikpO1xuZnVuY3Rpb24gdXNlT3V0bGluZUNvbnRleHQoKSB7XG4gICAgcmV0dXJuICgwLCByZWFjdF8xLnVzZUNvbnRleHQpKE91dGxpbmVDb250ZXh0X2pzXzEuZGVmYXVsdCk7XG59XG5leHBvcnRzLmRlZmF1bHQgPSB1c2VPdXRsaW5lQ29udGV4dDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-pdf/dist/cjs/shared/hooks/useOutlineContext.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-pdf/dist/cjs/shared/hooks/usePageContext.js":
/*!************************************************************************!*\
  !*** ./node_modules/react-pdf/dist/cjs/shared/hooks/usePageContext.js ***!
  \************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst react_1 = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\nconst PageContext_js_1 = __importDefault(__webpack_require__(/*! ../../PageContext.js */ \"(app-pages-browser)/./node_modules/react-pdf/dist/cjs/PageContext.js\"));\nfunction usePageContext() {\n    return (0, react_1.useContext)(PageContext_js_1.default);\n}\nexports[\"default\"] = usePageContext;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1wZGYvZGlzdC9janMvc2hhcmVkL2hvb2tzL3VzZVBhZ2VDb250ZXh0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZ0JBQWdCLG1CQUFPLENBQUMsbUZBQU87QUFDL0IseUNBQXlDLG1CQUFPLENBQUMsa0dBQXNCO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBLGtCQUFlIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFjdC1wZGYvZGlzdC9janMvc2hhcmVkL2hvb2tzL3VzZVBhZ2VDb250ZXh0LmpzPzZiYjkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCByZWFjdF8xID0gcmVxdWlyZShcInJlYWN0XCIpO1xuY29uc3QgUGFnZUNvbnRleHRfanNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vLi4vUGFnZUNvbnRleHQuanNcIikpO1xuZnVuY3Rpb24gdXNlUGFnZUNvbnRleHQoKSB7XG4gICAgcmV0dXJuICgwLCByZWFjdF8xLnVzZUNvbnRleHQpKFBhZ2VDb250ZXh0X2pzXzEuZGVmYXVsdCk7XG59XG5leHBvcnRzLmRlZmF1bHQgPSB1c2VQYWdlQ29udGV4dDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-pdf/dist/cjs/shared/hooks/usePageContext.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-pdf/dist/cjs/shared/hooks/useResolver.js":
/*!*********************************************************************!*\
  !*** ./node_modules/react-pdf/dist/cjs/shared/hooks/useResolver.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst react_1 = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\nfunction reducer(state, action) {\n    switch (action.type) {\n        case 'RESOLVE':\n            return { value: action.value, error: undefined };\n        case 'REJECT':\n            return { value: false, error: action.error };\n        case 'RESET':\n            return { value: undefined, error: undefined };\n        default:\n            return state;\n    }\n}\nfunction useResolver() {\n    return (0, react_1.useReducer)((reducer), { value: undefined, error: undefined });\n}\nexports[\"default\"] = useResolver;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1wZGYvZGlzdC9janMvc2hhcmVkL2hvb2tzL3VzZVJlc29sdmVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGdCQUFnQixtQkFBTyxDQUFDLG1GQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELG9DQUFvQztBQUNwRjtBQUNBLGtCQUFlIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFjdC1wZGYvZGlzdC9janMvc2hhcmVkL2hvb2tzL3VzZVJlc29sdmVyLmpzPzQxZDEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCByZWFjdF8xID0gcmVxdWlyZShcInJlYWN0XCIpO1xuZnVuY3Rpb24gcmVkdWNlcihzdGF0ZSwgYWN0aW9uKSB7XG4gICAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgICAgICBjYXNlICdSRVNPTFZFJzpcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBhY3Rpb24udmFsdWUsIGVycm9yOiB1bmRlZmluZWQgfTtcbiAgICAgICAgY2FzZSAnUkVKRUNUJzpcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBmYWxzZSwgZXJyb3I6IGFjdGlvbi5lcnJvciB9O1xuICAgICAgICBjYXNlICdSRVNFVCc6XG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBlcnJvcjogdW5kZWZpbmVkIH07XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgfVxufVxuZnVuY3Rpb24gdXNlUmVzb2x2ZXIoKSB7XG4gICAgcmV0dXJuICgwLCByZWFjdF8xLnVzZVJlZHVjZXIpKChyZWR1Y2VyKSwgeyB2YWx1ZTogdW5kZWZpbmVkLCBlcnJvcjogdW5kZWZpbmVkIH0pO1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gdXNlUmVzb2x2ZXI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-pdf/dist/cjs/shared/hooks/useResolver.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-pdf/dist/cjs/shared/propTypes.js":
/*!*************************************************************!*\
  !*** ./node_modules/react-pdf/dist/cjs/shared/propTypes.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isRotate = exports.isRenderMode = exports.isRef = exports.isPdf = exports.isPageNumber = exports.isPageIndex = exports.isPage = exports.isLinkTarget = exports.isLinkService = exports.isFile = exports.isClassName = exports.eventProps = void 0;\nconst prop_types_1 = __importDefault(__webpack_require__(/*! prop-types */ \"(app-pages-browser)/./node_modules/prop-types/index.js\"));\nconst make_event_props_1 = __webpack_require__(/*! make-event-props */ \"(app-pages-browser)/./node_modules/make-event-props/dist/cjs/index.js\");\nconst pdfjs_js_1 = __importDefault(__webpack_require__(/*! ../pdfjs.js */ \"(app-pages-browser)/./node_modules/react-pdf/dist/cjs/pdfjs.js\"));\nconst utils_js_1 = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/react-pdf/dist/cjs/shared/utils.js\");\nconst LinkService_js_1 = __importDefault(__webpack_require__(/*! ../LinkService.js */ \"(app-pages-browser)/./node_modules/react-pdf/dist/cjs/LinkService.js\"));\nconst { PDFDataRangeTransport } = pdfjs_js_1.default;\nexports.eventProps = (() => {\n    const result = {};\n    make_event_props_1.allEvents.forEach((eventName) => {\n        result[eventName] = prop_types_1.default.func;\n    });\n    return result;\n})();\nconst isTypedArray = prop_types_1.default.oneOfType([\n    prop_types_1.default.instanceOf(Int8Array),\n    prop_types_1.default.instanceOf(Uint8Array),\n    prop_types_1.default.instanceOf(Uint8ClampedArray),\n    prop_types_1.default.instanceOf(Int16Array),\n    prop_types_1.default.instanceOf(Uint16Array),\n    prop_types_1.default.instanceOf(Int32Array),\n    prop_types_1.default.instanceOf(Uint32Array),\n    prop_types_1.default.instanceOf(Float32Array),\n    prop_types_1.default.instanceOf(Float64Array),\n]);\nconst fileTypes = [\n    prop_types_1.default.string,\n    prop_types_1.default.instanceOf(ArrayBuffer),\n    prop_types_1.default.shape({\n        data: prop_types_1.default.oneOfType([\n            prop_types_1.default.string,\n            prop_types_1.default.instanceOf(ArrayBuffer),\n            prop_types_1.default.arrayOf(prop_types_1.default.number.isRequired),\n            isTypedArray,\n        ]).isRequired,\n    }),\n    prop_types_1.default.shape({\n        range: prop_types_1.default.instanceOf(PDFDataRangeTransport).isRequired,\n    }),\n    prop_types_1.default.shape({\n        url: prop_types_1.default.string.isRequired,\n    }),\n];\nif (typeof Blob !== 'undefined') {\n    fileTypes.push(prop_types_1.default.instanceOf(Blob));\n}\nexports.isClassName = prop_types_1.default.oneOfType([\n    prop_types_1.default.string,\n    prop_types_1.default.arrayOf(prop_types_1.default.string),\n]);\nexports.isFile = prop_types_1.default.oneOfType(fileTypes);\nexports.isLinkService = prop_types_1.default.instanceOf(LinkService_js_1.default);\nexports.isLinkTarget = prop_types_1.default.oneOf(['_self', '_blank', '_parent', '_top']);\nexports.isPage = prop_types_1.default.shape({\n    commonObjs: prop_types_1.default.shape({}).isRequired,\n    getAnnotations: prop_types_1.default.func.isRequired,\n    getTextContent: prop_types_1.default.func.isRequired,\n    getViewport: prop_types_1.default.func.isRequired,\n    render: prop_types_1.default.func.isRequired,\n});\nconst isPageIndex = function isPageIndex(props, propName, componentName) {\n    const { [propName]: pageIndex, pageNumber, pdf } = props;\n    if (!(0, utils_js_1.isDefined)(pdf)) {\n        return null;\n    }\n    if ((0, utils_js_1.isDefined)(pageIndex)) {\n        if (typeof pageIndex !== 'number') {\n            return new Error(`\\`${propName}\\` of type \\`${typeof pageIndex}\\` supplied to \\`${componentName}\\`, expected \\`number\\`.`);\n        }\n        if (pageIndex < 0) {\n            return new Error(`Expected \\`${propName}\\` to be greater or equal to 0.`);\n        }\n        const { numPages } = pdf;\n        if (pageIndex + 1 > numPages) {\n            return new Error(`Expected \\`${propName}\\` to be less or equal to ${numPages - 1}.`);\n        }\n    }\n    else if (!(0, utils_js_1.isDefined)(pageNumber)) {\n        return new Error(`\\`${propName}\\` not supplied. Either pageIndex or pageNumber must be supplied to \\`${componentName}\\`.`);\n    }\n    // Everything is fine\n    return null;\n};\nexports.isPageIndex = isPageIndex;\nconst isPageNumber = function isPageNumber(props, propName, componentName) {\n    const { [propName]: pageNumber, pageIndex, pdf } = props;\n    if (!(0, utils_js_1.isDefined)(pdf)) {\n        return null;\n    }\n    if ((0, utils_js_1.isDefined)(pageNumber)) {\n        if (typeof pageNumber !== 'number') {\n            return new Error(`\\`${propName}\\` of type \\`${typeof pageNumber}\\` supplied to \\`${componentName}\\`, expected \\`number\\`.`);\n        }\n        if (pageNumber < 1) {\n            return new Error(`Expected \\`${propName}\\` to be greater or equal to 1.`);\n        }\n        const { numPages } = pdf;\n        if (pageNumber > numPages) {\n            return new Error(`Expected \\`${propName}\\` to be less or equal to ${numPages}.`);\n        }\n    }\n    else if (!(0, utils_js_1.isDefined)(pageIndex)) {\n        return new Error(`\\`${propName}\\` not supplied. Either pageIndex or pageNumber must be supplied to \\`${componentName}\\`.`);\n    }\n    // Everything is fine\n    return null;\n};\nexports.isPageNumber = isPageNumber;\nexports.isPdf = prop_types_1.default.oneOfType([\n    // Ideally, this would be `PropTypes.instanceOf(PDFDocumentProxy)`, but it can't be imported.\n    prop_types_1.default.any,\n    prop_types_1.default.oneOf([false]),\n]);\nexports.isRef = prop_types_1.default.oneOfType([\n    prop_types_1.default.func,\n    prop_types_1.default.exact({\n        current: prop_types_1.default.any,\n    }),\n]);\nexports.isRenderMode = prop_types_1.default.oneOf(['canvas', 'custom', 'none', 'svg']);\nexports.isRotate = prop_types_1.default.oneOf([0, 90, 180, 270]);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1wZGYvZGlzdC9janMvc2hhcmVkL3Byb3BUeXBlcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGdCQUFnQixHQUFHLG9CQUFvQixHQUFHLGFBQWEsR0FBRyxhQUFhLEdBQUcsb0JBQW9CLEdBQUcsbUJBQW1CLEdBQUcsY0FBYyxHQUFHLG9CQUFvQixHQUFHLHFCQUFxQixHQUFHLGNBQWMsR0FBRyxtQkFBbUIsR0FBRyxrQkFBa0I7QUFDaFAscUNBQXFDLG1CQUFPLENBQUMsMEVBQVk7QUFDekQsMkJBQTJCLG1CQUFPLENBQUMsK0ZBQWtCO0FBQ3JELG1DQUFtQyxtQkFBTyxDQUFDLG1GQUFhO0FBQ3hELG1CQUFtQixtQkFBTyxDQUFDLHlGQUFZO0FBQ3ZDLHlDQUF5QyxtQkFBTyxDQUFDLCtGQUFtQjtBQUNwRSxRQUFRLHdCQUF3QjtBQUNoQyxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLHFCQUFxQjtBQUNyQixvQkFBb0I7QUFDcEIsY0FBYztBQUNkLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLFlBQVkseUNBQXlDO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsU0FBUyxlQUFlLGlCQUFpQixtQkFBbUIsY0FBYztBQUM1RztBQUNBO0FBQ0EsMkNBQTJDLFNBQVM7QUFDcEQ7QUFDQSxnQkFBZ0IsV0FBVztBQUMzQjtBQUNBLDJDQUEyQyxTQUFTLDRCQUE0QixhQUFhO0FBQzdGO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixTQUFTLHdFQUF3RSxjQUFjO0FBQzdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0EsWUFBWSx5Q0FBeUM7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxTQUFTLGVBQWUsa0JBQWtCLG1CQUFtQixjQUFjO0FBQzdHO0FBQ0E7QUFDQSwyQ0FBMkMsU0FBUztBQUNwRDtBQUNBLGdCQUFnQixXQUFXO0FBQzNCO0FBQ0EsMkNBQTJDLFNBQVMsNEJBQTRCLFNBQVM7QUFDekY7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLFNBQVMsd0VBQXdFLGNBQWM7QUFDN0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLG9CQUFvQjtBQUNwQixnQkFBZ0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXBkZi9kaXN0L2Nqcy9zaGFyZWQvcHJvcFR5cGVzLmpzPzcxYWEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmlzUm90YXRlID0gZXhwb3J0cy5pc1JlbmRlck1vZGUgPSBleHBvcnRzLmlzUmVmID0gZXhwb3J0cy5pc1BkZiA9IGV4cG9ydHMuaXNQYWdlTnVtYmVyID0gZXhwb3J0cy5pc1BhZ2VJbmRleCA9IGV4cG9ydHMuaXNQYWdlID0gZXhwb3J0cy5pc0xpbmtUYXJnZXQgPSBleHBvcnRzLmlzTGlua1NlcnZpY2UgPSBleHBvcnRzLmlzRmlsZSA9IGV4cG9ydHMuaXNDbGFzc05hbWUgPSBleHBvcnRzLmV2ZW50UHJvcHMgPSB2b2lkIDA7XG5jb25zdCBwcm9wX3R5cGVzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcInByb3AtdHlwZXNcIikpO1xuY29uc3QgbWFrZV9ldmVudF9wcm9wc18xID0gcmVxdWlyZShcIm1ha2UtZXZlbnQtcHJvcHNcIik7XG5jb25zdCBwZGZqc19qc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9wZGZqcy5qc1wiKSk7XG5jb25zdCB1dGlsc19qc18xID0gcmVxdWlyZShcIi4vdXRpbHMuanNcIik7XG5jb25zdCBMaW5rU2VydmljZV9qc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9MaW5rU2VydmljZS5qc1wiKSk7XG5jb25zdCB7IFBERkRhdGFSYW5nZVRyYW5zcG9ydCB9ID0gcGRmanNfanNfMS5kZWZhdWx0O1xuZXhwb3J0cy5ldmVudFByb3BzID0gKCgpID0+IHtcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICBtYWtlX2V2ZW50X3Byb3BzXzEuYWxsRXZlbnRzLmZvckVhY2goKGV2ZW50TmFtZSkgPT4ge1xuICAgICAgICByZXN1bHRbZXZlbnROYW1lXSA9IHByb3BfdHlwZXNfMS5kZWZhdWx0LmZ1bmM7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn0pKCk7XG5jb25zdCBpc1R5cGVkQXJyYXkgPSBwcm9wX3R5cGVzXzEuZGVmYXVsdC5vbmVPZlR5cGUoW1xuICAgIHByb3BfdHlwZXNfMS5kZWZhdWx0Lmluc3RhbmNlT2YoSW50OEFycmF5KSxcbiAgICBwcm9wX3R5cGVzXzEuZGVmYXVsdC5pbnN0YW5jZU9mKFVpbnQ4QXJyYXkpLFxuICAgIHByb3BfdHlwZXNfMS5kZWZhdWx0Lmluc3RhbmNlT2YoVWludDhDbGFtcGVkQXJyYXkpLFxuICAgIHByb3BfdHlwZXNfMS5kZWZhdWx0Lmluc3RhbmNlT2YoSW50MTZBcnJheSksXG4gICAgcHJvcF90eXBlc18xLmRlZmF1bHQuaW5zdGFuY2VPZihVaW50MTZBcnJheSksXG4gICAgcHJvcF90eXBlc18xLmRlZmF1bHQuaW5zdGFuY2VPZihJbnQzMkFycmF5KSxcbiAgICBwcm9wX3R5cGVzXzEuZGVmYXVsdC5pbnN0YW5jZU9mKFVpbnQzMkFycmF5KSxcbiAgICBwcm9wX3R5cGVzXzEuZGVmYXVsdC5pbnN0YW5jZU9mKEZsb2F0MzJBcnJheSksXG4gICAgcHJvcF90eXBlc18xLmRlZmF1bHQuaW5zdGFuY2VPZihGbG9hdDY0QXJyYXkpLFxuXSk7XG5jb25zdCBmaWxlVHlwZXMgPSBbXG4gICAgcHJvcF90eXBlc18xLmRlZmF1bHQuc3RyaW5nLFxuICAgIHByb3BfdHlwZXNfMS5kZWZhdWx0Lmluc3RhbmNlT2YoQXJyYXlCdWZmZXIpLFxuICAgIHByb3BfdHlwZXNfMS5kZWZhdWx0LnNoYXBlKHtcbiAgICAgICAgZGF0YTogcHJvcF90eXBlc18xLmRlZmF1bHQub25lT2ZUeXBlKFtcbiAgICAgICAgICAgIHByb3BfdHlwZXNfMS5kZWZhdWx0LnN0cmluZyxcbiAgICAgICAgICAgIHByb3BfdHlwZXNfMS5kZWZhdWx0Lmluc3RhbmNlT2YoQXJyYXlCdWZmZXIpLFxuICAgICAgICAgICAgcHJvcF90eXBlc18xLmRlZmF1bHQuYXJyYXlPZihwcm9wX3R5cGVzXzEuZGVmYXVsdC5udW1iZXIuaXNSZXF1aXJlZCksXG4gICAgICAgICAgICBpc1R5cGVkQXJyYXksXG4gICAgICAgIF0pLmlzUmVxdWlyZWQsXG4gICAgfSksXG4gICAgcHJvcF90eXBlc18xLmRlZmF1bHQuc2hhcGUoe1xuICAgICAgICByYW5nZTogcHJvcF90eXBlc18xLmRlZmF1bHQuaW5zdGFuY2VPZihQREZEYXRhUmFuZ2VUcmFuc3BvcnQpLmlzUmVxdWlyZWQsXG4gICAgfSksXG4gICAgcHJvcF90eXBlc18xLmRlZmF1bHQuc2hhcGUoe1xuICAgICAgICB1cmw6IHByb3BfdHlwZXNfMS5kZWZhdWx0LnN0cmluZy5pc1JlcXVpcmVkLFxuICAgIH0pLFxuXTtcbmlmICh0eXBlb2YgQmxvYiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBmaWxlVHlwZXMucHVzaChwcm9wX3R5cGVzXzEuZGVmYXVsdC5pbnN0YW5jZU9mKEJsb2IpKTtcbn1cbmV4cG9ydHMuaXNDbGFzc05hbWUgPSBwcm9wX3R5cGVzXzEuZGVmYXVsdC5vbmVPZlR5cGUoW1xuICAgIHByb3BfdHlwZXNfMS5kZWZhdWx0LnN0cmluZyxcbiAgICBwcm9wX3R5cGVzXzEuZGVmYXVsdC5hcnJheU9mKHByb3BfdHlwZXNfMS5kZWZhdWx0LnN0cmluZyksXG5dKTtcbmV4cG9ydHMuaXNGaWxlID0gcHJvcF90eXBlc18xLmRlZmF1bHQub25lT2ZUeXBlKGZpbGVUeXBlcyk7XG5leHBvcnRzLmlzTGlua1NlcnZpY2UgPSBwcm9wX3R5cGVzXzEuZGVmYXVsdC5pbnN0YW5jZU9mKExpbmtTZXJ2aWNlX2pzXzEuZGVmYXVsdCk7XG5leHBvcnRzLmlzTGlua1RhcmdldCA9IHByb3BfdHlwZXNfMS5kZWZhdWx0Lm9uZU9mKFsnX3NlbGYnLCAnX2JsYW5rJywgJ19wYXJlbnQnLCAnX3RvcCddKTtcbmV4cG9ydHMuaXNQYWdlID0gcHJvcF90eXBlc18xLmRlZmF1bHQuc2hhcGUoe1xuICAgIGNvbW1vbk9ianM6IHByb3BfdHlwZXNfMS5kZWZhdWx0LnNoYXBlKHt9KS5pc1JlcXVpcmVkLFxuICAgIGdldEFubm90YXRpb25zOiBwcm9wX3R5cGVzXzEuZGVmYXVsdC5mdW5jLmlzUmVxdWlyZWQsXG4gICAgZ2V0VGV4dENvbnRlbnQ6IHByb3BfdHlwZXNfMS5kZWZhdWx0LmZ1bmMuaXNSZXF1aXJlZCxcbiAgICBnZXRWaWV3cG9ydDogcHJvcF90eXBlc18xLmRlZmF1bHQuZnVuYy5pc1JlcXVpcmVkLFxuICAgIHJlbmRlcjogcHJvcF90eXBlc18xLmRlZmF1bHQuZnVuYy5pc1JlcXVpcmVkLFxufSk7XG5jb25zdCBpc1BhZ2VJbmRleCA9IGZ1bmN0aW9uIGlzUGFnZUluZGV4KHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSkge1xuICAgIGNvbnN0IHsgW3Byb3BOYW1lXTogcGFnZUluZGV4LCBwYWdlTnVtYmVyLCBwZGYgfSA9IHByb3BzO1xuICAgIGlmICghKDAsIHV0aWxzX2pzXzEuaXNEZWZpbmVkKShwZGYpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoKDAsIHV0aWxzX2pzXzEuaXNEZWZpbmVkKShwYWdlSW5kZXgpKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcGFnZUluZGV4ICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBFcnJvcihgXFxgJHtwcm9wTmFtZX1cXGAgb2YgdHlwZSBcXGAke3R5cGVvZiBwYWdlSW5kZXh9XFxgIHN1cHBsaWVkIHRvIFxcYCR7Y29tcG9uZW50TmFtZX1cXGAsIGV4cGVjdGVkIFxcYG51bWJlclxcYC5gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFnZUluZGV4IDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBFcnJvcihgRXhwZWN0ZWQgXFxgJHtwcm9wTmFtZX1cXGAgdG8gYmUgZ3JlYXRlciBvciBlcXVhbCB0byAwLmApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgbnVtUGFnZXMgfSA9IHBkZjtcbiAgICAgICAgaWYgKHBhZ2VJbmRleCArIDEgPiBudW1QYWdlcykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBFcnJvcihgRXhwZWN0ZWQgXFxgJHtwcm9wTmFtZX1cXGAgdG8gYmUgbGVzcyBvciBlcXVhbCB0byAke251bVBhZ2VzIC0gMX0uYCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoISgwLCB1dGlsc19qc18xLmlzRGVmaW5lZCkocGFnZU51bWJlcikpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBFcnJvcihgXFxgJHtwcm9wTmFtZX1cXGAgbm90IHN1cHBsaWVkLiBFaXRoZXIgcGFnZUluZGV4IG9yIHBhZ2VOdW1iZXIgbXVzdCBiZSBzdXBwbGllZCB0byBcXGAke2NvbXBvbmVudE5hbWV9XFxgLmApO1xuICAgIH1cbiAgICAvLyBFdmVyeXRoaW5nIGlzIGZpbmVcbiAgICByZXR1cm4gbnVsbDtcbn07XG5leHBvcnRzLmlzUGFnZUluZGV4ID0gaXNQYWdlSW5kZXg7XG5jb25zdCBpc1BhZ2VOdW1iZXIgPSBmdW5jdGlvbiBpc1BhZ2VOdW1iZXIocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lKSB7XG4gICAgY29uc3QgeyBbcHJvcE5hbWVdOiBwYWdlTnVtYmVyLCBwYWdlSW5kZXgsIHBkZiB9ID0gcHJvcHM7XG4gICAgaWYgKCEoMCwgdXRpbHNfanNfMS5pc0RlZmluZWQpKHBkZikpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmICgoMCwgdXRpbHNfanNfMS5pc0RlZmluZWQpKHBhZ2VOdW1iZXIpKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcGFnZU51bWJlciAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRXJyb3IoYFxcYCR7cHJvcE5hbWV9XFxgIG9mIHR5cGUgXFxgJHt0eXBlb2YgcGFnZU51bWJlcn1cXGAgc3VwcGxpZWQgdG8gXFxgJHtjb21wb25lbnROYW1lfVxcYCwgZXhwZWN0ZWQgXFxgbnVtYmVyXFxgLmApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYWdlTnVtYmVyIDwgMSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBFcnJvcihgRXhwZWN0ZWQgXFxgJHtwcm9wTmFtZX1cXGAgdG8gYmUgZ3JlYXRlciBvciBlcXVhbCB0byAxLmApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgbnVtUGFnZXMgfSA9IHBkZjtcbiAgICAgICAgaWYgKHBhZ2VOdW1iZXIgPiBudW1QYWdlcykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBFcnJvcihgRXhwZWN0ZWQgXFxgJHtwcm9wTmFtZX1cXGAgdG8gYmUgbGVzcyBvciBlcXVhbCB0byAke251bVBhZ2VzfS5gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICghKDAsIHV0aWxzX2pzXzEuaXNEZWZpbmVkKShwYWdlSW5kZXgpKSB7XG4gICAgICAgIHJldHVybiBuZXcgRXJyb3IoYFxcYCR7cHJvcE5hbWV9XFxgIG5vdCBzdXBwbGllZC4gRWl0aGVyIHBhZ2VJbmRleCBvciBwYWdlTnVtYmVyIG11c3QgYmUgc3VwcGxpZWQgdG8gXFxgJHtjb21wb25lbnROYW1lfVxcYC5gKTtcbiAgICB9XG4gICAgLy8gRXZlcnl0aGluZyBpcyBmaW5lXG4gICAgcmV0dXJuIG51bGw7XG59O1xuZXhwb3J0cy5pc1BhZ2VOdW1iZXIgPSBpc1BhZ2VOdW1iZXI7XG5leHBvcnRzLmlzUGRmID0gcHJvcF90eXBlc18xLmRlZmF1bHQub25lT2ZUeXBlKFtcbiAgICAvLyBJZGVhbGx5LCB0aGlzIHdvdWxkIGJlIGBQcm9wVHlwZXMuaW5zdGFuY2VPZihQREZEb2N1bWVudFByb3h5KWAsIGJ1dCBpdCBjYW4ndCBiZSBpbXBvcnRlZC5cbiAgICBwcm9wX3R5cGVzXzEuZGVmYXVsdC5hbnksXG4gICAgcHJvcF90eXBlc18xLmRlZmF1bHQub25lT2YoW2ZhbHNlXSksXG5dKTtcbmV4cG9ydHMuaXNSZWYgPSBwcm9wX3R5cGVzXzEuZGVmYXVsdC5vbmVPZlR5cGUoW1xuICAgIHByb3BfdHlwZXNfMS5kZWZhdWx0LmZ1bmMsXG4gICAgcHJvcF90eXBlc18xLmRlZmF1bHQuZXhhY3Qoe1xuICAgICAgICBjdXJyZW50OiBwcm9wX3R5cGVzXzEuZGVmYXVsdC5hbnksXG4gICAgfSksXG5dKTtcbmV4cG9ydHMuaXNSZW5kZXJNb2RlID0gcHJvcF90eXBlc18xLmRlZmF1bHQub25lT2YoWydjYW52YXMnLCAnY3VzdG9tJywgJ25vbmUnLCAnc3ZnJ10pO1xuZXhwb3J0cy5pc1JvdGF0ZSA9IHByb3BfdHlwZXNfMS5kZWZhdWx0Lm9uZU9mKFswLCA5MCwgMTgwLCAyNzBdKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-pdf/dist/cjs/shared/propTypes.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-pdf/dist/cjs/shared/structTreeUtils.js":
/*!*******************************************************************!*\
  !*** ./node_modules/react-pdf/dist/cjs/shared/structTreeUtils.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getAttributes = exports.getBaseAttributes = exports.getRoleAttributes = exports.isStructTreeNodeWithOnlyContentChild = exports.isStructTreeNode = exports.isPdfRole = void 0;\nconst constants_js_1 = __webpack_require__(/*! ./constants.js */ \"(app-pages-browser)/./node_modules/react-pdf/dist/cjs/shared/constants.js\");\nfunction isPdfRole(role) {\n    return role in constants_js_1.PDF_ROLE_TO_HTML_ROLE;\n}\nexports.isPdfRole = isPdfRole;\nfunction isStructTreeNode(node) {\n    return 'children' in node;\n}\nexports.isStructTreeNode = isStructTreeNode;\nfunction isStructTreeNodeWithOnlyContentChild(node) {\n    if (!isStructTreeNode(node)) {\n        return false;\n    }\n    return node.children.length === 1 && 0 in node.children && 'id' in node.children[0];\n}\nexports.isStructTreeNodeWithOnlyContentChild = isStructTreeNodeWithOnlyContentChild;\nfunction getRoleAttributes(node) {\n    const attributes = {};\n    if (isStructTreeNode(node)) {\n        const { role } = node;\n        const matches = role.match(constants_js_1.HEADING_PATTERN);\n        if (matches) {\n            attributes.role = 'heading';\n            attributes['aria-level'] = Number(matches[1]);\n        }\n        else if (isPdfRole(role)) {\n            const htmlRole = constants_js_1.PDF_ROLE_TO_HTML_ROLE[role];\n            if (htmlRole) {\n                attributes.role = htmlRole;\n            }\n        }\n    }\n    return attributes;\n}\nexports.getRoleAttributes = getRoleAttributes;\nfunction getBaseAttributes(node) {\n    const attributes = {};\n    if (isStructTreeNode(node)) {\n        if (node.alt !== undefined) {\n            attributes['aria-label'] = node.alt;\n        }\n        if (node.lang !== undefined) {\n            attributes.lang = node.lang;\n        }\n        if (isStructTreeNodeWithOnlyContentChild(node)) {\n            const [child] = node.children;\n            if (child) {\n                const childAttributes = getBaseAttributes(child);\n                return Object.assign(Object.assign({}, attributes), childAttributes);\n            }\n        }\n    }\n    else {\n        if ('id' in node) {\n            attributes['aria-owns'] = node.id;\n        }\n    }\n    return attributes;\n}\nexports.getBaseAttributes = getBaseAttributes;\nfunction getAttributes(node) {\n    if (!node) {\n        return null;\n    }\n    return Object.assign(Object.assign({}, getRoleAttributes(node)), getBaseAttributes(node));\n}\nexports.getAttributes = getAttributes;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1wZGYvZGlzdC9janMvc2hhcmVkL3N0cnVjdFRyZWVVdGlscy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxxQkFBcUIsR0FBRyx5QkFBeUIsR0FBRyx5QkFBeUIsR0FBRyw0Q0FBNEMsR0FBRyx3QkFBd0IsR0FBRyxpQkFBaUI7QUFDM0ssdUJBQXVCLG1CQUFPLENBQUMsaUdBQWdCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQSxxQkFBcUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXBkZi9kaXN0L2Nqcy9zaGFyZWQvc3RydWN0VHJlZVV0aWxzLmpzPzc2Y2YiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdldEF0dHJpYnV0ZXMgPSBleHBvcnRzLmdldEJhc2VBdHRyaWJ1dGVzID0gZXhwb3J0cy5nZXRSb2xlQXR0cmlidXRlcyA9IGV4cG9ydHMuaXNTdHJ1Y3RUcmVlTm9kZVdpdGhPbmx5Q29udGVudENoaWxkID0gZXhwb3J0cy5pc1N0cnVjdFRyZWVOb2RlID0gZXhwb3J0cy5pc1BkZlJvbGUgPSB2b2lkIDA7XG5jb25zdCBjb25zdGFudHNfanNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50cy5qc1wiKTtcbmZ1bmN0aW9uIGlzUGRmUm9sZShyb2xlKSB7XG4gICAgcmV0dXJuIHJvbGUgaW4gY29uc3RhbnRzX2pzXzEuUERGX1JPTEVfVE9fSFRNTF9ST0xFO1xufVxuZXhwb3J0cy5pc1BkZlJvbGUgPSBpc1BkZlJvbGU7XG5mdW5jdGlvbiBpc1N0cnVjdFRyZWVOb2RlKG5vZGUpIHtcbiAgICByZXR1cm4gJ2NoaWxkcmVuJyBpbiBub2RlO1xufVxuZXhwb3J0cy5pc1N0cnVjdFRyZWVOb2RlID0gaXNTdHJ1Y3RUcmVlTm9kZTtcbmZ1bmN0aW9uIGlzU3RydWN0VHJlZU5vZGVXaXRoT25seUNvbnRlbnRDaGlsZChub2RlKSB7XG4gICAgaWYgKCFpc1N0cnVjdFRyZWVOb2RlKG5vZGUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGUuY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmIDAgaW4gbm9kZS5jaGlsZHJlbiAmJiAnaWQnIGluIG5vZGUuY2hpbGRyZW5bMF07XG59XG5leHBvcnRzLmlzU3RydWN0VHJlZU5vZGVXaXRoT25seUNvbnRlbnRDaGlsZCA9IGlzU3RydWN0VHJlZU5vZGVXaXRoT25seUNvbnRlbnRDaGlsZDtcbmZ1bmN0aW9uIGdldFJvbGVBdHRyaWJ1dGVzKG5vZGUpIHtcbiAgICBjb25zdCBhdHRyaWJ1dGVzID0ge307XG4gICAgaWYgKGlzU3RydWN0VHJlZU5vZGUobm9kZSkpIHtcbiAgICAgICAgY29uc3QgeyByb2xlIH0gPSBub2RlO1xuICAgICAgICBjb25zdCBtYXRjaGVzID0gcm9sZS5tYXRjaChjb25zdGFudHNfanNfMS5IRUFESU5HX1BBVFRFUk4pO1xuICAgICAgICBpZiAobWF0Y2hlcykge1xuICAgICAgICAgICAgYXR0cmlidXRlcy5yb2xlID0gJ2hlYWRpbmcnO1xuICAgICAgICAgICAgYXR0cmlidXRlc1snYXJpYS1sZXZlbCddID0gTnVtYmVyKG1hdGNoZXNbMV0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzUGRmUm9sZShyb2xlKSkge1xuICAgICAgICAgICAgY29uc3QgaHRtbFJvbGUgPSBjb25zdGFudHNfanNfMS5QREZfUk9MRV9UT19IVE1MX1JPTEVbcm9sZV07XG4gICAgICAgICAgICBpZiAoaHRtbFJvbGUpIHtcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzLnJvbGUgPSBodG1sUm9sZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXR0cmlidXRlcztcbn1cbmV4cG9ydHMuZ2V0Um9sZUF0dHJpYnV0ZXMgPSBnZXRSb2xlQXR0cmlidXRlcztcbmZ1bmN0aW9uIGdldEJhc2VBdHRyaWJ1dGVzKG5vZGUpIHtcbiAgICBjb25zdCBhdHRyaWJ1dGVzID0ge307XG4gICAgaWYgKGlzU3RydWN0VHJlZU5vZGUobm9kZSkpIHtcbiAgICAgICAgaWYgKG5vZGUuYWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGF0dHJpYnV0ZXNbJ2FyaWEtbGFiZWwnXSA9IG5vZGUuYWx0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlLmxhbmcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgYXR0cmlidXRlcy5sYW5nID0gbm9kZS5sYW5nO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1N0cnVjdFRyZWVOb2RlV2l0aE9ubHlDb250ZW50Q2hpbGQobm9kZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IFtjaGlsZF0gPSBub2RlLmNoaWxkcmVuO1xuICAgICAgICAgICAgaWYgKGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2hpbGRBdHRyaWJ1dGVzID0gZ2V0QmFzZUF0dHJpYnV0ZXMoY2hpbGQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGF0dHJpYnV0ZXMpLCBjaGlsZEF0dHJpYnV0ZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAoJ2lkJyBpbiBub2RlKSB7XG4gICAgICAgICAgICBhdHRyaWJ1dGVzWydhcmlhLW93bnMnXSA9IG5vZGUuaWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGF0dHJpYnV0ZXM7XG59XG5leHBvcnRzLmdldEJhc2VBdHRyaWJ1dGVzID0gZ2V0QmFzZUF0dHJpYnV0ZXM7XG5mdW5jdGlvbiBnZXRBdHRyaWJ1dGVzKG5vZGUpIHtcbiAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGdldFJvbGVBdHRyaWJ1dGVzKG5vZGUpKSwgZ2V0QmFzZUF0dHJpYnV0ZXMobm9kZSkpO1xufVxuZXhwb3J0cy5nZXRBdHRyaWJ1dGVzID0gZ2V0QXR0cmlidXRlcztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-pdf/dist/cjs/shared/structTreeUtils.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-pdf/dist/cjs/shared/utils.js":
/*!*********************************************************!*\
  !*** ./node_modules/react-pdf/dist/cjs/shared/utils.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.loadFromFile = exports.isCancelException = exports.makePageCallback = exports.cancelRunningTask = exports.displayWorkerWarning = exports.displayCORSWarning = exports.getDevicePixelRatio = exports.dataURItoByteString = exports.isDataURI = exports.isBlob = exports.isArrayBuffer = exports.isString = exports.isProvided = exports.isDefined = exports.isLocalFileSystem = exports.isBrowser = void 0;\nconst tiny_invariant_1 = __importDefault(__webpack_require__(/*! tiny-invariant */ \"(app-pages-browser)/./node_modules/tiny-invariant/dist/tiny-invariant.cjs.js\"));\nconst warning_1 = __importDefault(__webpack_require__(/*! warning */ \"(app-pages-browser)/./node_modules/warning/warning.js\"));\n/**\n * Checks if we're running in a browser environment.\n */\nexports.isBrowser = typeof document !== 'undefined';\n/**\n * Checks whether we're running from a local file system.\n */\nexports.isLocalFileSystem = exports.isBrowser && window.location.protocol === 'file:';\n/**\n * Checks whether a variable is defined.\n *\n * @param {*} variable Variable to check\n */\nfunction isDefined(variable) {\n    return typeof variable !== 'undefined';\n}\nexports.isDefined = isDefined;\n/**\n * Checks whether a variable is defined and not null.\n *\n * @param {*} variable Variable to check\n */\nfunction isProvided(variable) {\n    return isDefined(variable) && variable !== null;\n}\nexports.isProvided = isProvided;\n/**\n * Checks whether a variable provided is a string.\n *\n * @param {*} variable Variable to check\n */\nfunction isString(variable) {\n    return typeof variable === 'string';\n}\nexports.isString = isString;\n/**\n * Checks whether a variable provided is an ArrayBuffer.\n *\n * @param {*} variable Variable to check\n */\nfunction isArrayBuffer(variable) {\n    return variable instanceof ArrayBuffer;\n}\nexports.isArrayBuffer = isArrayBuffer;\n/**\n * Checks whether a variable provided is a Blob.\n *\n * @param {*} variable Variable to check\n */\nfunction isBlob(variable) {\n    (0, tiny_invariant_1.default)(exports.isBrowser, 'isBlob can only be used in a browser environment');\n    return variable instanceof Blob;\n}\nexports.isBlob = isBlob;\n/**\n * Checks whether a variable provided is a data URI.\n *\n * @param {*} variable String to check\n */\nfunction isDataURI(variable) {\n    return isString(variable) && /^data:/.test(variable);\n}\nexports.isDataURI = isDataURI;\nfunction dataURItoByteString(dataURI) {\n    (0, tiny_invariant_1.default)(isDataURI(dataURI), 'Invalid data URI.');\n    const [headersString = '', dataString = ''] = dataURI.split(',');\n    const headers = headersString.split(';');\n    if (headers.indexOf('base64') !== -1) {\n        return atob(dataString);\n    }\n    return unescape(dataString);\n}\nexports.dataURItoByteString = dataURItoByteString;\nfunction getDevicePixelRatio() {\n    return (exports.isBrowser && window.devicePixelRatio) || 1;\n}\nexports.getDevicePixelRatio = getDevicePixelRatio;\nconst allowFileAccessFromFilesTip = 'On Chromium based browsers, you can use --allow-file-access-from-files flag for debugging purposes.';\nfunction displayCORSWarning() {\n    (0, warning_1.default)(!exports.isLocalFileSystem, `Loading PDF as base64 strings/URLs may not work on protocols other than HTTP/HTTPS. ${allowFileAccessFromFilesTip}`);\n}\nexports.displayCORSWarning = displayCORSWarning;\nfunction displayWorkerWarning() {\n    (0, warning_1.default)(!exports.isLocalFileSystem, `Loading PDF.js worker may not work on protocols other than HTTP/HTTPS. ${allowFileAccessFromFilesTip}`);\n}\nexports.displayWorkerWarning = displayWorkerWarning;\nfunction cancelRunningTask(runningTask) {\n    if (runningTask && runningTask.cancel)\n        runningTask.cancel();\n}\nexports.cancelRunningTask = cancelRunningTask;\nfunction makePageCallback(page, scale) {\n    Object.defineProperty(page, 'width', {\n        get() {\n            return this.view[2] * scale;\n        },\n        configurable: true,\n    });\n    Object.defineProperty(page, 'height', {\n        get() {\n            return this.view[3] * scale;\n        },\n        configurable: true,\n    });\n    Object.defineProperty(page, 'originalWidth', {\n        get() {\n            return this.view[2];\n        },\n        configurable: true,\n    });\n    Object.defineProperty(page, 'originalHeight', {\n        get() {\n            return this.view[3];\n        },\n        configurable: true,\n    });\n    return page;\n}\nexports.makePageCallback = makePageCallback;\nfunction isCancelException(error) {\n    return error.name === 'RenderingCancelledException';\n}\nexports.isCancelException = isCancelException;\nfunction loadFromFile(file) {\n    return new Promise((resolve, reject) => {\n        const reader = new FileReader();\n        reader.onload = () => {\n            if (!reader.result) {\n                return reject(new Error('Error while reading a file.'));\n            }\n            resolve(reader.result);\n        };\n        reader.onerror = (event) => {\n            if (!event.target) {\n                return reject(new Error('Error while reading a file.'));\n            }\n            const { error } = event.target;\n            if (!error) {\n                return reject(new Error('Error while reading a file.'));\n            }\n            switch (error.code) {\n                case error.NOT_FOUND_ERR:\n                    return reject(new Error('Error while reading a file: File not found.'));\n                case error.SECURITY_ERR:\n                    return reject(new Error('Error while reading a file: Security error.'));\n                case error.ABORT_ERR:\n                    return reject(new Error('Error while reading a file: Aborted.'));\n                default:\n                    return reject(new Error('Error while reading a file.'));\n            }\n        };\n        reader.readAsArrayBuffer(file);\n    });\n}\nexports.loadFromFile = loadFromFile;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1wZGYvZGlzdC9janMvc2hhcmVkL3V0aWxzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsb0JBQW9CLEdBQUcseUJBQXlCLEdBQUcsd0JBQXdCLEdBQUcseUJBQXlCLEdBQUcsNEJBQTRCLEdBQUcsMEJBQTBCLEdBQUcsMkJBQTJCLEdBQUcsMkJBQTJCLEdBQUcsaUJBQWlCLEdBQUcsY0FBYyxHQUFHLHFCQUFxQixHQUFHLGdCQUFnQixHQUFHLGtCQUFrQixHQUFHLGlCQUFpQixHQUFHLHlCQUF5QixHQUFHLGlCQUFpQjtBQUN4WSx5Q0FBeUMsbUJBQU8sQ0FBQyxvR0FBZ0I7QUFDakUsa0NBQWtDLG1CQUFPLENBQUMsc0VBQVM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0EsOElBQThJLDRCQUE0QjtBQUMxSztBQUNBLDBCQUEwQjtBQUMxQjtBQUNBLGlJQUFpSSw0QkFBNEI7QUFDN0o7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxvQkFBb0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXBkZi9kaXN0L2Nqcy9zaGFyZWQvdXRpbHMuanM/YjMzMyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMubG9hZEZyb21GaWxlID0gZXhwb3J0cy5pc0NhbmNlbEV4Y2VwdGlvbiA9IGV4cG9ydHMubWFrZVBhZ2VDYWxsYmFjayA9IGV4cG9ydHMuY2FuY2VsUnVubmluZ1Rhc2sgPSBleHBvcnRzLmRpc3BsYXlXb3JrZXJXYXJuaW5nID0gZXhwb3J0cy5kaXNwbGF5Q09SU1dhcm5pbmcgPSBleHBvcnRzLmdldERldmljZVBpeGVsUmF0aW8gPSBleHBvcnRzLmRhdGFVUkl0b0J5dGVTdHJpbmcgPSBleHBvcnRzLmlzRGF0YVVSSSA9IGV4cG9ydHMuaXNCbG9iID0gZXhwb3J0cy5pc0FycmF5QnVmZmVyID0gZXhwb3J0cy5pc1N0cmluZyA9IGV4cG9ydHMuaXNQcm92aWRlZCA9IGV4cG9ydHMuaXNEZWZpbmVkID0gZXhwb3J0cy5pc0xvY2FsRmlsZVN5c3RlbSA9IGV4cG9ydHMuaXNCcm93c2VyID0gdm9pZCAwO1xuY29uc3QgdGlueV9pbnZhcmlhbnRfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwidGlueS1pbnZhcmlhbnRcIikpO1xuY29uc3Qgd2FybmluZ18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJ3YXJuaW5nXCIpKTtcbi8qKlxuICogQ2hlY2tzIGlmIHdlJ3JlIHJ1bm5pbmcgaW4gYSBicm93c2VyIGVudmlyb25tZW50LlxuICovXG5leHBvcnRzLmlzQnJvd3NlciA9IHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCc7XG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIHdlJ3JlIHJ1bm5pbmcgZnJvbSBhIGxvY2FsIGZpbGUgc3lzdGVtLlxuICovXG5leHBvcnRzLmlzTG9jYWxGaWxlU3lzdGVtID0gZXhwb3J0cy5pc0Jyb3dzZXIgJiYgd2luZG93LmxvY2F0aW9uLnByb3RvY29sID09PSAnZmlsZTonO1xuLyoqXG4gKiBDaGVja3Mgd2hldGhlciBhIHZhcmlhYmxlIGlzIGRlZmluZWQuXG4gKlxuICogQHBhcmFtIHsqfSB2YXJpYWJsZSBWYXJpYWJsZSB0byBjaGVja1xuICovXG5mdW5jdGlvbiBpc0RlZmluZWQodmFyaWFibGUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhcmlhYmxlICE9PSAndW5kZWZpbmVkJztcbn1cbmV4cG9ydHMuaXNEZWZpbmVkID0gaXNEZWZpbmVkO1xuLyoqXG4gKiBDaGVja3Mgd2hldGhlciBhIHZhcmlhYmxlIGlzIGRlZmluZWQgYW5kIG5vdCBudWxsLlxuICpcbiAqIEBwYXJhbSB7Kn0gdmFyaWFibGUgVmFyaWFibGUgdG8gY2hlY2tcbiAqL1xuZnVuY3Rpb24gaXNQcm92aWRlZCh2YXJpYWJsZSkge1xuICAgIHJldHVybiBpc0RlZmluZWQodmFyaWFibGUpICYmIHZhcmlhYmxlICE9PSBudWxsO1xufVxuZXhwb3J0cy5pc1Byb3ZpZGVkID0gaXNQcm92aWRlZDtcbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgYSB2YXJpYWJsZSBwcm92aWRlZCBpcyBhIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0geyp9IHZhcmlhYmxlIFZhcmlhYmxlIHRvIGNoZWNrXG4gKi9cbmZ1bmN0aW9uIGlzU3RyaW5nKHZhcmlhYmxlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YXJpYWJsZSA9PT0gJ3N0cmluZyc7XG59XG5leHBvcnRzLmlzU3RyaW5nID0gaXNTdHJpbmc7XG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIGEgdmFyaWFibGUgcHJvdmlkZWQgaXMgYW4gQXJyYXlCdWZmZXIuXG4gKlxuICogQHBhcmFtIHsqfSB2YXJpYWJsZSBWYXJpYWJsZSB0byBjaGVja1xuICovXG5mdW5jdGlvbiBpc0FycmF5QnVmZmVyKHZhcmlhYmxlKSB7XG4gICAgcmV0dXJuIHZhcmlhYmxlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXI7XG59XG5leHBvcnRzLmlzQXJyYXlCdWZmZXIgPSBpc0FycmF5QnVmZmVyO1xuLyoqXG4gKiBDaGVja3Mgd2hldGhlciBhIHZhcmlhYmxlIHByb3ZpZGVkIGlzIGEgQmxvYi5cbiAqXG4gKiBAcGFyYW0geyp9IHZhcmlhYmxlIFZhcmlhYmxlIHRvIGNoZWNrXG4gKi9cbmZ1bmN0aW9uIGlzQmxvYih2YXJpYWJsZSkge1xuICAgICgwLCB0aW55X2ludmFyaWFudF8xLmRlZmF1bHQpKGV4cG9ydHMuaXNCcm93c2VyLCAnaXNCbG9iIGNhbiBvbmx5IGJlIHVzZWQgaW4gYSBicm93c2VyIGVudmlyb25tZW50Jyk7XG4gICAgcmV0dXJuIHZhcmlhYmxlIGluc3RhbmNlb2YgQmxvYjtcbn1cbmV4cG9ydHMuaXNCbG9iID0gaXNCbG9iO1xuLyoqXG4gKiBDaGVja3Mgd2hldGhlciBhIHZhcmlhYmxlIHByb3ZpZGVkIGlzIGEgZGF0YSBVUkkuXG4gKlxuICogQHBhcmFtIHsqfSB2YXJpYWJsZSBTdHJpbmcgdG8gY2hlY2tcbiAqL1xuZnVuY3Rpb24gaXNEYXRhVVJJKHZhcmlhYmxlKSB7XG4gICAgcmV0dXJuIGlzU3RyaW5nKHZhcmlhYmxlKSAmJiAvXmRhdGE6Ly50ZXN0KHZhcmlhYmxlKTtcbn1cbmV4cG9ydHMuaXNEYXRhVVJJID0gaXNEYXRhVVJJO1xuZnVuY3Rpb24gZGF0YVVSSXRvQnl0ZVN0cmluZyhkYXRhVVJJKSB7XG4gICAgKDAsIHRpbnlfaW52YXJpYW50XzEuZGVmYXVsdCkoaXNEYXRhVVJJKGRhdGFVUkkpLCAnSW52YWxpZCBkYXRhIFVSSS4nKTtcbiAgICBjb25zdCBbaGVhZGVyc1N0cmluZyA9ICcnLCBkYXRhU3RyaW5nID0gJyddID0gZGF0YVVSSS5zcGxpdCgnLCcpO1xuICAgIGNvbnN0IGhlYWRlcnMgPSBoZWFkZXJzU3RyaW5nLnNwbGl0KCc7Jyk7XG4gICAgaWYgKGhlYWRlcnMuaW5kZXhPZignYmFzZTY0JykgIT09IC0xKSB7XG4gICAgICAgIHJldHVybiBhdG9iKGRhdGFTdHJpbmcpO1xuICAgIH1cbiAgICByZXR1cm4gdW5lc2NhcGUoZGF0YVN0cmluZyk7XG59XG5leHBvcnRzLmRhdGFVUkl0b0J5dGVTdHJpbmcgPSBkYXRhVVJJdG9CeXRlU3RyaW5nO1xuZnVuY3Rpb24gZ2V0RGV2aWNlUGl4ZWxSYXRpbygpIHtcbiAgICByZXR1cm4gKGV4cG9ydHMuaXNCcm93c2VyICYmIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvKSB8fCAxO1xufVxuZXhwb3J0cy5nZXREZXZpY2VQaXhlbFJhdGlvID0gZ2V0RGV2aWNlUGl4ZWxSYXRpbztcbmNvbnN0IGFsbG93RmlsZUFjY2Vzc0Zyb21GaWxlc1RpcCA9ICdPbiBDaHJvbWl1bSBiYXNlZCBicm93c2VycywgeW91IGNhbiB1c2UgLS1hbGxvdy1maWxlLWFjY2Vzcy1mcm9tLWZpbGVzIGZsYWcgZm9yIGRlYnVnZ2luZyBwdXJwb3Nlcy4nO1xuZnVuY3Rpb24gZGlzcGxheUNPUlNXYXJuaW5nKCkge1xuICAgICgwLCB3YXJuaW5nXzEuZGVmYXVsdCkoIWV4cG9ydHMuaXNMb2NhbEZpbGVTeXN0ZW0sIGBMb2FkaW5nIFBERiBhcyBiYXNlNjQgc3RyaW5ncy9VUkxzIG1heSBub3Qgd29yayBvbiBwcm90b2NvbHMgb3RoZXIgdGhhbiBIVFRQL0hUVFBTLiAke2FsbG93RmlsZUFjY2Vzc0Zyb21GaWxlc1RpcH1gKTtcbn1cbmV4cG9ydHMuZGlzcGxheUNPUlNXYXJuaW5nID0gZGlzcGxheUNPUlNXYXJuaW5nO1xuZnVuY3Rpb24gZGlzcGxheVdvcmtlcldhcm5pbmcoKSB7XG4gICAgKDAsIHdhcm5pbmdfMS5kZWZhdWx0KSghZXhwb3J0cy5pc0xvY2FsRmlsZVN5c3RlbSwgYExvYWRpbmcgUERGLmpzIHdvcmtlciBtYXkgbm90IHdvcmsgb24gcHJvdG9jb2xzIG90aGVyIHRoYW4gSFRUUC9IVFRQUy4gJHthbGxvd0ZpbGVBY2Nlc3NGcm9tRmlsZXNUaXB9YCk7XG59XG5leHBvcnRzLmRpc3BsYXlXb3JrZXJXYXJuaW5nID0gZGlzcGxheVdvcmtlcldhcm5pbmc7XG5mdW5jdGlvbiBjYW5jZWxSdW5uaW5nVGFzayhydW5uaW5nVGFzaykge1xuICAgIGlmIChydW5uaW5nVGFzayAmJiBydW5uaW5nVGFzay5jYW5jZWwpXG4gICAgICAgIHJ1bm5pbmdUYXNrLmNhbmNlbCgpO1xufVxuZXhwb3J0cy5jYW5jZWxSdW5uaW5nVGFzayA9IGNhbmNlbFJ1bm5pbmdUYXNrO1xuZnVuY3Rpb24gbWFrZVBhZ2VDYWxsYmFjayhwYWdlLCBzY2FsZSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwYWdlLCAnd2lkdGgnLCB7XG4gICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZpZXdbMl0gKiBzY2FsZTtcbiAgICAgICAgfSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwYWdlLCAnaGVpZ2h0Jywge1xuICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52aWV3WzNdICogc2NhbGU7XG4gICAgICAgIH0sXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocGFnZSwgJ29yaWdpbmFsV2lkdGgnLCB7XG4gICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZpZXdbMl07XG4gICAgICAgIH0sXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocGFnZSwgJ29yaWdpbmFsSGVpZ2h0Jywge1xuICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52aWV3WzNdO1xuICAgICAgICB9LFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgfSk7XG4gICAgcmV0dXJuIHBhZ2U7XG59XG5leHBvcnRzLm1ha2VQYWdlQ2FsbGJhY2sgPSBtYWtlUGFnZUNhbGxiYWNrO1xuZnVuY3Rpb24gaXNDYW5jZWxFeGNlcHRpb24oZXJyb3IpIHtcbiAgICByZXR1cm4gZXJyb3IubmFtZSA9PT0gJ1JlbmRlcmluZ0NhbmNlbGxlZEV4Y2VwdGlvbic7XG59XG5leHBvcnRzLmlzQ2FuY2VsRXhjZXB0aW9uID0gaXNDYW5jZWxFeGNlcHRpb247XG5mdW5jdGlvbiBsb2FkRnJvbUZpbGUoZmlsZSkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgICAgIHJlYWRlci5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXJlYWRlci5yZXN1bHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBFcnJvcignRXJyb3Igd2hpbGUgcmVhZGluZyBhIGZpbGUuJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzb2x2ZShyZWFkZXIucmVzdWx0KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmVhZGVyLm9uZXJyb3IgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGlmICghZXZlbnQudGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgRXJyb3IoJ0Vycm9yIHdoaWxlIHJlYWRpbmcgYSBmaWxlLicpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgZXJyb3IgfSA9IGV2ZW50LnRhcmdldDtcbiAgICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBFcnJvcignRXJyb3Igd2hpbGUgcmVhZGluZyBhIGZpbGUuJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3dpdGNoIChlcnJvci5jb2RlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBlcnJvci5OT1RfRk9VTkRfRVJSOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBFcnJvcignRXJyb3Igd2hpbGUgcmVhZGluZyBhIGZpbGU6IEZpbGUgbm90IGZvdW5kLicpKTtcbiAgICAgICAgICAgICAgICBjYXNlIGVycm9yLlNFQ1VSSVRZX0VSUjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgRXJyb3IoJ0Vycm9yIHdoaWxlIHJlYWRpbmcgYSBmaWxlOiBTZWN1cml0eSBlcnJvci4nKSk7XG4gICAgICAgICAgICAgICAgY2FzZSBlcnJvci5BQk9SVF9FUlI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QobmV3IEVycm9yKCdFcnJvciB3aGlsZSByZWFkaW5nIGEgZmlsZTogQWJvcnRlZC4nKSk7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgRXJyb3IoJ0Vycm9yIHdoaWxlIHJlYWRpbmcgYSBmaWxlLicpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmVhZGVyLnJlYWRBc0FycmF5QnVmZmVyKGZpbGUpO1xuICAgIH0pO1xufVxuZXhwb3J0cy5sb2FkRnJvbUZpbGUgPSBsb2FkRnJvbUZpbGU7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-pdf/dist/cjs/shared/utils.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@reduxjs/toolkit/dist/redux-toolkit.modern.mjs":
/*!*********************************************************************!*\
  !*** ./node_modules/@reduxjs/toolkit/dist/redux-toolkit.modern.mjs ***!
  \*********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ReducerType: function() { return /* binding */ ReducerType; },\n/* harmony export */   SHOULD_AUTOBATCH: function() { return /* binding */ SHOULD_AUTOBATCH; },\n/* harmony export */   TaskAbortError: function() { return /* binding */ TaskAbortError; },\n/* harmony export */   Tuple: function() { return /* binding */ Tuple; },\n/* harmony export */   __DO_NOT_USE__ActionTypes: function() { return /* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.__DO_NOT_USE__ActionTypes; },\n/* harmony export */   addListener: function() { return /* binding */ addListener; },\n/* harmony export */   applyMiddleware: function() { return /* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.applyMiddleware; },\n/* harmony export */   asyncThunkCreator: function() { return /* binding */ asyncThunkCreator; },\n/* harmony export */   autoBatchEnhancer: function() { return /* binding */ autoBatchEnhancer; },\n/* harmony export */   bindActionCreators: function() { return /* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.bindActionCreators; },\n/* harmony export */   buildCreateSlice: function() { return /* binding */ buildCreateSlice; },\n/* harmony export */   clearAllListeners: function() { return /* binding */ clearAllListeners; },\n/* harmony export */   combineReducers: function() { return /* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.combineReducers; },\n/* harmony export */   combineSlices: function() { return /* binding */ combineSlices; },\n/* harmony export */   compose: function() { return /* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.compose; },\n/* harmony export */   configureStore: function() { return /* binding */ configureStore; },\n/* harmony export */   createAction: function() { return /* binding */ createAction; },\n/* harmony export */   createActionCreatorInvariantMiddleware: function() { return /* binding */ createActionCreatorInvariantMiddleware; },\n/* harmony export */   createAsyncThunk: function() { return /* binding */ createAsyncThunk; },\n/* harmony export */   createDraftSafeSelector: function() { return /* binding */ createDraftSafeSelector; },\n/* harmony export */   createDraftSafeSelectorCreator: function() { return /* binding */ createDraftSafeSelectorCreator; },\n/* harmony export */   createDynamicMiddleware: function() { return /* binding */ createDynamicMiddleware; },\n/* harmony export */   createEntityAdapter: function() { return /* binding */ createEntityAdapter; },\n/* harmony export */   createImmutableStateInvariantMiddleware: function() { return /* binding */ createImmutableStateInvariantMiddleware; },\n/* harmony export */   createListenerMiddleware: function() { return /* binding */ createListenerMiddleware; },\n/* harmony export */   createNextState: function() { return /* reexport safe */ immer__WEBPACK_IMPORTED_MODULE_2__.produce; },\n/* harmony export */   createReducer: function() { return /* binding */ createReducer; },\n/* harmony export */   createSelector: function() { return /* reexport safe */ reselect__WEBPACK_IMPORTED_MODULE_1__.createSelector; },\n/* harmony export */   createSelectorCreator: function() { return /* reexport safe */ reselect__WEBPACK_IMPORTED_MODULE_1__.createSelectorCreator; },\n/* harmony export */   createSerializableStateInvariantMiddleware: function() { return /* binding */ createSerializableStateInvariantMiddleware; },\n/* harmony export */   createSlice: function() { return /* binding */ createSlice; },\n/* harmony export */   createStore: function() { return /* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.createStore; },\n/* harmony export */   current: function() { return /* reexport safe */ immer__WEBPACK_IMPORTED_MODULE_2__.current; },\n/* harmony export */   findNonSerializableValue: function() { return /* binding */ findNonSerializableValue; },\n/* harmony export */   formatProdErrorMessage: function() { return /* binding */ formatProdErrorMessage; },\n/* harmony export */   freeze: function() { return /* reexport safe */ immer__WEBPACK_IMPORTED_MODULE_2__.freeze; },\n/* harmony export */   isAction: function() { return /* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.isAction; },\n/* harmony export */   isActionCreator: function() { return /* binding */ isActionCreator; },\n/* harmony export */   isAllOf: function() { return /* binding */ isAllOf; },\n/* harmony export */   isAnyOf: function() { return /* binding */ isAnyOf; },\n/* harmony export */   isAsyncThunkAction: function() { return /* binding */ isAsyncThunkAction; },\n/* harmony export */   isDraft: function() { return /* reexport safe */ immer__WEBPACK_IMPORTED_MODULE_2__.isDraft; },\n/* harmony export */   isFluxStandardAction: function() { return /* binding */ isFSA; },\n/* harmony export */   isFulfilled: function() { return /* binding */ isFulfilled; },\n/* harmony export */   isImmutableDefault: function() { return /* binding */ isImmutableDefault; },\n/* harmony export */   isPending: function() { return /* binding */ isPending; },\n/* harmony export */   isPlain: function() { return /* binding */ isPlain; },\n/* harmony export */   isPlainObject: function() { return /* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.isPlainObject; },\n/* harmony export */   isRejected: function() { return /* binding */ isRejected; },\n/* harmony export */   isRejectedWithValue: function() { return /* binding */ isRejectedWithValue; },\n/* harmony export */   legacy_createStore: function() { return /* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.legacy_createStore; },\n/* harmony export */   lruMemoize: function() { return /* reexport safe */ reselect__WEBPACK_IMPORTED_MODULE_1__.lruMemoize; },\n/* harmony export */   miniSerializeError: function() { return /* binding */ miniSerializeError; },\n/* harmony export */   nanoid: function() { return /* binding */ nanoid; },\n/* harmony export */   original: function() { return /* reexport safe */ immer__WEBPACK_IMPORTED_MODULE_2__.original; },\n/* harmony export */   prepareAutoBatched: function() { return /* binding */ prepareAutoBatched; },\n/* harmony export */   removeListener: function() { return /* binding */ removeListener; },\n/* harmony export */   unwrapResult: function() { return /* binding */ unwrapResult; },\n/* harmony export */   weakMapMemoize: function() { return /* reexport safe */ reselect__WEBPACK_IMPORTED_MODULE_1__.weakMapMemoize; }\n/* harmony export */ });\n/* harmony import */ var redux__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! redux */ \"(app-pages-browser)/./node_modules/redux/dist/redux.mjs\");\n/* harmony import */ var immer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! immer */ \"(app-pages-browser)/./node_modules/immer/dist/immer.mjs\");\n/* harmony import */ var reselect__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! reselect */ \"(app-pages-browser)/./node_modules/reselect/dist/reselect.mjs\");\n/* harmony import */ var redux_thunk__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! redux-thunk */ \"(app-pages-browser)/./node_modules/redux-thunk/dist/redux-thunk.mjs\");\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n// src/index.ts\n\n\n\n\n// src/createDraftSafeSelector.ts\n\n\nvar createDraftSafeSelectorCreator = (...args) => {\n  const createSelector2 = (0,reselect__WEBPACK_IMPORTED_MODULE_1__.createSelectorCreator)(...args);\n  const createDraftSafeSelector2 = Object.assign((...args2) => {\n    const selector = createSelector2(...args2);\n    const wrappedSelector = (value, ...rest) => selector((0,immer__WEBPACK_IMPORTED_MODULE_2__.isDraft)(value) ? (0,immer__WEBPACK_IMPORTED_MODULE_2__.current)(value) : value, ...rest);\n    Object.assign(wrappedSelector, selector);\n    return wrappedSelector;\n  }, {\n    withTypes: () => createDraftSafeSelector2\n  });\n  return createDraftSafeSelector2;\n};\nvar createDraftSafeSelector = createDraftSafeSelectorCreator(reselect__WEBPACK_IMPORTED_MODULE_1__.weakMapMemoize);\n\n// src/configureStore.ts\n\n\n// src/devtoolsExtension.ts\n\nvar composeWithDevTools = typeof window !== \"undefined\" && window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ : function() {\n  if (arguments.length === 0)\n    return void 0;\n  if (typeof arguments[0] === \"object\")\n    return redux__WEBPACK_IMPORTED_MODULE_0__.compose;\n  return redux__WEBPACK_IMPORTED_MODULE_0__.compose.apply(null, arguments);\n};\nvar devToolsEnhancer = typeof window !== \"undefined\" && window.__REDUX_DEVTOOLS_EXTENSION__ ? window.__REDUX_DEVTOOLS_EXTENSION__ : function() {\n  return function(noop3) {\n    return noop3;\n  };\n};\n\n// src/getDefaultMiddleware.ts\n\n\n// src/createAction.ts\n\n\n// src/tsHelpers.ts\nvar hasMatchFunction = (v) => {\n  return v && typeof v.match === \"function\";\n};\n\n// src/createAction.ts\nfunction createAction(type, prepareAction) {\n  function actionCreator(...args) {\n    if (prepareAction) {\n      let prepared = prepareAction(...args);\n      if (!prepared) {\n        throw new Error( false ? 0 : \"prepareAction did not return an object\");\n      }\n      return {\n        type,\n        payload: prepared.payload,\n        ...\"meta\" in prepared && {\n          meta: prepared.meta\n        },\n        ...\"error\" in prepared && {\n          error: prepared.error\n        }\n      };\n    }\n    return {\n      type,\n      payload: args[0]\n    };\n  }\n  actionCreator.toString = () => `${type}`;\n  actionCreator.type = type;\n  actionCreator.match = (action) => (0,redux__WEBPACK_IMPORTED_MODULE_0__.isAction)(action) && action.type === type;\n  return actionCreator;\n}\nfunction isActionCreator(action) {\n  return typeof action === \"function\" && \"type\" in action && // hasMatchFunction only wants Matchers but I don't see the point in rewriting it\n  hasMatchFunction(action);\n}\nfunction isFSA(action) {\n  return (0,redux__WEBPACK_IMPORTED_MODULE_0__.isAction)(action) && Object.keys(action).every(isValidKey);\n}\nfunction isValidKey(key) {\n  return [\"type\", \"payload\", \"error\", \"meta\"].indexOf(key) > -1;\n}\n\n// src/actionCreatorInvariantMiddleware.ts\nfunction getMessage(type) {\n  const splitType = type ? `${type}`.split(\"/\") : [];\n  const actionName = splitType[splitType.length - 1] || \"actionCreator\";\n  return `Detected an action creator with type \"${type || \"unknown\"}\" being dispatched. \nMake sure you're calling the action creator before dispatching, i.e. \\`dispatch(${actionName}())\\` instead of \\`dispatch(${actionName})\\`. This is necessary even if the action has no payload.`;\n}\nfunction createActionCreatorInvariantMiddleware(options = {}) {\n  if (false) {}\n  const {\n    isActionCreator: isActionCreator2 = isActionCreator\n  } = options;\n  return () => (next) => (action) => {\n    if (isActionCreator2(action)) {\n      console.warn(getMessage(action.type));\n    }\n    return next(action);\n  };\n}\n\n// src/utils.ts\n\nfunction getTimeMeasureUtils(maxDelay, fnName) {\n  let elapsed = 0;\n  return {\n    measureTime(fn) {\n      const started = Date.now();\n      try {\n        return fn();\n      } finally {\n        const finished = Date.now();\n        elapsed += finished - started;\n      }\n    },\n    warnIfExceeded() {\n      if (elapsed > maxDelay) {\n        console.warn(`${fnName} took ${elapsed}ms, which is more than the warning threshold of ${maxDelay}ms. \nIf your state or actions are very large, you may want to disable the middleware as it might cause too much of a slowdown in development mode. See https://redux-toolkit.js.org/api/getDefaultMiddleware for instructions.\nIt is disabled in production builds, so you don't need to worry about that.`);\n      }\n    }\n  };\n}\nfunction find(iterable, comparator) {\n  for (const entry of iterable) {\n    if (comparator(entry)) {\n      return entry;\n    }\n  }\n  return void 0;\n}\nvar Tuple = class _Tuple extends Array {\n  constructor(...items) {\n    super(...items);\n    Object.setPrototypeOf(this, _Tuple.prototype);\n  }\n  static get [Symbol.species]() {\n    return _Tuple;\n  }\n  concat(...arr) {\n    return super.concat.apply(this, arr);\n  }\n  prepend(...arr) {\n    if (arr.length === 1 && Array.isArray(arr[0])) {\n      return new _Tuple(...arr[0].concat(this));\n    }\n    return new _Tuple(...arr.concat(this));\n  }\n};\nfunction freezeDraftable(val) {\n  return (0,immer__WEBPACK_IMPORTED_MODULE_2__.isDraftable)(val) ? (0,immer__WEBPACK_IMPORTED_MODULE_2__.produce)(val, () => {\n  }) : val;\n}\nfunction emplace(map, key, handler) {\n  if (map.has(key)) {\n    let value = map.get(key);\n    if (handler.update) {\n      value = handler.update(value, key, map);\n      map.set(key, value);\n    }\n    return value;\n  }\n  if (!handler.insert)\n    throw new Error( false ? 0 : \"No insert provided for key not already in map\");\n  const inserted = handler.insert(key, map);\n  map.set(key, inserted);\n  return inserted;\n}\n\n// src/immutableStateInvariantMiddleware.ts\nfunction isImmutableDefault(value) {\n  return typeof value !== \"object\" || value == null || Object.isFrozen(value);\n}\nfunction trackForMutations(isImmutable, ignorePaths, obj) {\n  const trackedProperties = trackProperties(isImmutable, ignorePaths, obj);\n  return {\n    detectMutations() {\n      return detectMutations(isImmutable, ignorePaths, trackedProperties, obj);\n    }\n  };\n}\nfunction trackProperties(isImmutable, ignorePaths = [], obj, path = \"\", checkedObjects = /* @__PURE__ */ new Set()) {\n  const tracked = {\n    value: obj\n  };\n  if (!isImmutable(obj) && !checkedObjects.has(obj)) {\n    checkedObjects.add(obj);\n    tracked.children = {};\n    for (const key in obj) {\n      const childPath = path ? path + \".\" + key : key;\n      if (ignorePaths.length && ignorePaths.indexOf(childPath) !== -1) {\n        continue;\n      }\n      tracked.children[key] = trackProperties(isImmutable, ignorePaths, obj[key], childPath);\n    }\n  }\n  return tracked;\n}\nfunction detectMutations(isImmutable, ignoredPaths = [], trackedProperty, obj, sameParentRef = false, path = \"\") {\n  const prevObj = trackedProperty ? trackedProperty.value : void 0;\n  const sameRef = prevObj === obj;\n  if (sameParentRef && !sameRef && !Number.isNaN(obj)) {\n    return {\n      wasMutated: true,\n      path\n    };\n  }\n  if (isImmutable(prevObj) || isImmutable(obj)) {\n    return {\n      wasMutated: false\n    };\n  }\n  const keysToDetect = {};\n  for (let key in trackedProperty.children) {\n    keysToDetect[key] = true;\n  }\n  for (let key in obj) {\n    keysToDetect[key] = true;\n  }\n  const hasIgnoredPaths = ignoredPaths.length > 0;\n  for (let key in keysToDetect) {\n    const nestedPath = path ? path + \".\" + key : key;\n    if (hasIgnoredPaths) {\n      const hasMatches = ignoredPaths.some((ignored) => {\n        if (ignored instanceof RegExp) {\n          return ignored.test(nestedPath);\n        }\n        return nestedPath === ignored;\n      });\n      if (hasMatches) {\n        continue;\n      }\n    }\n    const result = detectMutations(isImmutable, ignoredPaths, trackedProperty.children[key], obj[key], sameRef, nestedPath);\n    if (result.wasMutated) {\n      return result;\n    }\n  }\n  return {\n    wasMutated: false\n  };\n}\nfunction createImmutableStateInvariantMiddleware(options = {}) {\n  if (false) {} else {\n    let stringify2 = function(obj, serializer, indent, decycler) {\n      return JSON.stringify(obj, getSerialize2(serializer, decycler), indent);\n    }, getSerialize2 = function(serializer, decycler) {\n      let stack = [], keys = [];\n      if (!decycler)\n        decycler = function(_, value) {\n          if (stack[0] === value)\n            return \"[Circular ~]\";\n          return \"[Circular ~.\" + keys.slice(0, stack.indexOf(value)).join(\".\") + \"]\";\n        };\n      return function(key, value) {\n        if (stack.length > 0) {\n          var thisPos = stack.indexOf(this);\n          ~thisPos ? stack.splice(thisPos + 1) : stack.push(this);\n          ~thisPos ? keys.splice(thisPos, Infinity, key) : keys.push(key);\n          if (~stack.indexOf(value))\n            value = decycler.call(this, key, value);\n        } else\n          stack.push(value);\n        return serializer == null ? value : serializer.call(this, key, value);\n      };\n    };\n    var stringify = stringify2, getSerialize = getSerialize2;\n    let {\n      isImmutable = isImmutableDefault,\n      ignoredPaths,\n      warnAfter = 32\n    } = options;\n    const track = trackForMutations.bind(null, isImmutable, ignoredPaths);\n    return ({\n      getState\n    }) => {\n      let state = getState();\n      let tracker = track(state);\n      let result;\n      return (next) => (action) => {\n        const measureUtils = getTimeMeasureUtils(warnAfter, \"ImmutableStateInvariantMiddleware\");\n        measureUtils.measureTime(() => {\n          state = getState();\n          result = tracker.detectMutations();\n          tracker = track(state);\n          if (result.wasMutated) {\n            throw new Error( false ? 0 : `A state mutation was detected between dispatches, in the path '${result.path || \"\"}'.  This may cause incorrect behavior. (https://redux.js.org/style-guide/style-guide#do-not-mutate-state)`);\n          }\n        });\n        const dispatchedAction = next(action);\n        measureUtils.measureTime(() => {\n          state = getState();\n          result = tracker.detectMutations();\n          tracker = track(state);\n          if (result.wasMutated) {\n            throw new Error( false ? 0 : `A state mutation was detected inside a dispatch, in the path: ${result.path || \"\"}. Take a look at the reducer(s) handling the action ${stringify2(action)}. (https://redux.js.org/style-guide/style-guide#do-not-mutate-state)`);\n          }\n        });\n        measureUtils.warnIfExceeded();\n        return dispatchedAction;\n      };\n    };\n  }\n}\n\n// src/serializableStateInvariantMiddleware.ts\n\nfunction isPlain(val) {\n  const type = typeof val;\n  return val == null || type === \"string\" || type === \"boolean\" || type === \"number\" || Array.isArray(val) || (0,redux__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(val);\n}\nfunction findNonSerializableValue(value, path = \"\", isSerializable = isPlain, getEntries, ignoredPaths = [], cache) {\n  let foundNestedSerializable;\n  if (!isSerializable(value)) {\n    return {\n      keyPath: path || \"<root>\",\n      value\n    };\n  }\n  if (typeof value !== \"object\" || value === null) {\n    return false;\n  }\n  if (cache?.has(value))\n    return false;\n  const entries = getEntries != null ? getEntries(value) : Object.entries(value);\n  const hasIgnoredPaths = ignoredPaths.length > 0;\n  for (const [key, nestedValue] of entries) {\n    const nestedPath = path ? path + \".\" + key : key;\n    if (hasIgnoredPaths) {\n      const hasMatches = ignoredPaths.some((ignored) => {\n        if (ignored instanceof RegExp) {\n          return ignored.test(nestedPath);\n        }\n        return nestedPath === ignored;\n      });\n      if (hasMatches) {\n        continue;\n      }\n    }\n    if (!isSerializable(nestedValue)) {\n      return {\n        keyPath: nestedPath,\n        value: nestedValue\n      };\n    }\n    if (typeof nestedValue === \"object\") {\n      foundNestedSerializable = findNonSerializableValue(nestedValue, nestedPath, isSerializable, getEntries, ignoredPaths, cache);\n      if (foundNestedSerializable) {\n        return foundNestedSerializable;\n      }\n    }\n  }\n  if (cache && isNestedFrozen(value))\n    cache.add(value);\n  return false;\n}\nfunction isNestedFrozen(value) {\n  if (!Object.isFrozen(value))\n    return false;\n  for (const nestedValue of Object.values(value)) {\n    if (typeof nestedValue !== \"object\" || nestedValue === null)\n      continue;\n    if (!isNestedFrozen(nestedValue))\n      return false;\n  }\n  return true;\n}\nfunction createSerializableStateInvariantMiddleware(options = {}) {\n  if (false) {} else {\n    const {\n      isSerializable = isPlain,\n      getEntries,\n      ignoredActions = [],\n      ignoredActionPaths = [\"meta.arg\", \"meta.baseQueryMeta\"],\n      ignoredPaths = [],\n      warnAfter = 32,\n      ignoreState = false,\n      ignoreActions = false,\n      disableCache = false\n    } = options;\n    const cache = !disableCache && WeakSet ? /* @__PURE__ */ new WeakSet() : void 0;\n    return (storeAPI) => (next) => (action) => {\n      if (!(0,redux__WEBPACK_IMPORTED_MODULE_0__.isAction)(action)) {\n        return next(action);\n      }\n      const result = next(action);\n      const measureUtils = getTimeMeasureUtils(warnAfter, \"SerializableStateInvariantMiddleware\");\n      if (!ignoreActions && !(ignoredActions.length && ignoredActions.indexOf(action.type) !== -1)) {\n        measureUtils.measureTime(() => {\n          const foundActionNonSerializableValue = findNonSerializableValue(action, \"\", isSerializable, getEntries, ignoredActionPaths, cache);\n          if (foundActionNonSerializableValue) {\n            const {\n              keyPath,\n              value\n            } = foundActionNonSerializableValue;\n            console.error(`A non-serializable value was detected in an action, in the path: \\`${keyPath}\\`. Value:`, value, \"\\nTake a look at the logic that dispatched this action: \", action, \"\\n(See https://redux.js.org/faq/actions#why-should-type-be-a-string-or-at-least-serializable-why-should-my-action-types-be-constants)\", \"\\n(To allow non-serializable values see: https://redux-toolkit.js.org/usage/usage-guide#working-with-non-serializable-data)\");\n          }\n        });\n      }\n      if (!ignoreState) {\n        measureUtils.measureTime(() => {\n          const state = storeAPI.getState();\n          const foundStateNonSerializableValue = findNonSerializableValue(state, \"\", isSerializable, getEntries, ignoredPaths, cache);\n          if (foundStateNonSerializableValue) {\n            const {\n              keyPath,\n              value\n            } = foundStateNonSerializableValue;\n            console.error(`A non-serializable value was detected in the state, in the path: \\`${keyPath}\\`. Value:`, value, `\nTake a look at the reducer(s) handling this action type: ${action.type}.\n(See https://redux.js.org/faq/organizing-state#can-i-put-functions-promises-or-other-non-serializable-items-in-my-store-state)`);\n          }\n        });\n        measureUtils.warnIfExceeded();\n      }\n      return result;\n    };\n  }\n}\n\n// src/getDefaultMiddleware.ts\nfunction isBoolean(x) {\n  return typeof x === \"boolean\";\n}\nvar buildGetDefaultMiddleware = () => function getDefaultMiddleware(options) {\n  const {\n    thunk = true,\n    immutableCheck = true,\n    serializableCheck = true,\n    actionCreatorCheck = true\n  } = options ?? {};\n  let middlewareArray = new Tuple();\n  if (thunk) {\n    if (isBoolean(thunk)) {\n      middlewareArray.push(redux_thunk__WEBPACK_IMPORTED_MODULE_3__.thunk);\n    } else {\n      middlewareArray.push((0,redux_thunk__WEBPACK_IMPORTED_MODULE_3__.withExtraArgument)(thunk.extraArgument));\n    }\n  }\n  if (true) {\n    if (immutableCheck) {\n      let immutableOptions = {};\n      if (!isBoolean(immutableCheck)) {\n        immutableOptions = immutableCheck;\n      }\n      middlewareArray.unshift(createImmutableStateInvariantMiddleware(immutableOptions));\n    }\n    if (serializableCheck) {\n      let serializableOptions = {};\n      if (!isBoolean(serializableCheck)) {\n        serializableOptions = serializableCheck;\n      }\n      middlewareArray.push(createSerializableStateInvariantMiddleware(serializableOptions));\n    }\n    if (actionCreatorCheck) {\n      let actionCreatorOptions = {};\n      if (!isBoolean(actionCreatorCheck)) {\n        actionCreatorOptions = actionCreatorCheck;\n      }\n      middlewareArray.unshift(createActionCreatorInvariantMiddleware(actionCreatorOptions));\n    }\n  }\n  return middlewareArray;\n};\n\n// src/autoBatchEnhancer.ts\nvar SHOULD_AUTOBATCH = \"RTK_autoBatch\";\nvar prepareAutoBatched = () => (payload) => ({\n  payload,\n  meta: {\n    [SHOULD_AUTOBATCH]: true\n  }\n});\nvar createQueueWithTimer = (timeout) => {\n  return (notify) => {\n    setTimeout(notify, timeout);\n  };\n};\nvar rAF = typeof window !== \"undefined\" && window.requestAnimationFrame ? window.requestAnimationFrame : createQueueWithTimer(10);\nvar autoBatchEnhancer = (options = {\n  type: \"raf\"\n}) => (next) => (...args) => {\n  const store = next(...args);\n  let notifying = true;\n  let shouldNotifyAtEndOfTick = false;\n  let notificationQueued = false;\n  const listeners = /* @__PURE__ */ new Set();\n  const queueCallback = options.type === \"tick\" ? queueMicrotask : options.type === \"raf\" ? rAF : options.type === \"callback\" ? options.queueNotification : createQueueWithTimer(options.timeout);\n  const notifyListeners = () => {\n    notificationQueued = false;\n    if (shouldNotifyAtEndOfTick) {\n      shouldNotifyAtEndOfTick = false;\n      listeners.forEach((l) => l());\n    }\n  };\n  return Object.assign({}, store, {\n    // Override the base `store.subscribe` method to keep original listeners\n    // from running if we're delaying notifications\n    subscribe(listener2) {\n      const wrappedListener = () => notifying && listener2();\n      const unsubscribe = store.subscribe(wrappedListener);\n      listeners.add(listener2);\n      return () => {\n        unsubscribe();\n        listeners.delete(listener2);\n      };\n    },\n    // Override the base `store.dispatch` method so that we can check actions\n    // for the `shouldAutoBatch` flag and determine if batching is active\n    dispatch(action) {\n      try {\n        notifying = !action?.meta?.[SHOULD_AUTOBATCH];\n        shouldNotifyAtEndOfTick = !notifying;\n        if (shouldNotifyAtEndOfTick) {\n          if (!notificationQueued) {\n            notificationQueued = true;\n            queueCallback(notifyListeners);\n          }\n        }\n        return store.dispatch(action);\n      } finally {\n        notifying = true;\n      }\n    }\n  });\n};\n\n// src/getDefaultEnhancers.ts\nvar buildGetDefaultEnhancers = (middlewareEnhancer) => function getDefaultEnhancers(options) {\n  const {\n    autoBatch = true\n  } = options ?? {};\n  let enhancerArray = new Tuple(middlewareEnhancer);\n  if (autoBatch) {\n    enhancerArray.push(autoBatchEnhancer(typeof autoBatch === \"object\" ? autoBatch : void 0));\n  }\n  return enhancerArray;\n};\n\n// src/configureStore.ts\nvar IS_PRODUCTION = \"development\" === \"production\";\nfunction configureStore(options) {\n  const getDefaultMiddleware = buildGetDefaultMiddleware();\n  const {\n    reducer = void 0,\n    middleware,\n    devTools = true,\n    preloadedState = void 0,\n    enhancers = void 0\n  } = options || {};\n  let rootReducer;\n  if (typeof reducer === \"function\") {\n    rootReducer = reducer;\n  } else if ((0,redux__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(reducer)) {\n    rootReducer = (0,redux__WEBPACK_IMPORTED_MODULE_0__.combineReducers)(reducer);\n  } else {\n    throw new Error( false ? 0 : \"`reducer` is a required argument, and must be a function or an object of functions that can be passed to combineReducers\");\n  }\n  if (!IS_PRODUCTION && middleware && typeof middleware !== \"function\") {\n    throw new Error( false ? 0 : \"`middleware` field must be a callback\");\n  }\n  let finalMiddleware;\n  if (typeof middleware === \"function\") {\n    finalMiddleware = middleware(getDefaultMiddleware);\n    if (!IS_PRODUCTION && !Array.isArray(finalMiddleware)) {\n      throw new Error( false ? 0 : \"when using a middleware builder function, an array of middleware must be returned\");\n    }\n  } else {\n    finalMiddleware = getDefaultMiddleware();\n  }\n  if (!IS_PRODUCTION && finalMiddleware.some((item) => typeof item !== \"function\")) {\n    throw new Error( false ? 0 : \"each middleware provided to configureStore must be a function\");\n  }\n  let finalCompose = redux__WEBPACK_IMPORTED_MODULE_0__.compose;\n  if (devTools) {\n    finalCompose = composeWithDevTools({\n      // Enable capture of stack traces for dispatched Redux actions\n      trace: !IS_PRODUCTION,\n      ...typeof devTools === \"object\" && devTools\n    });\n  }\n  const middlewareEnhancer = (0,redux__WEBPACK_IMPORTED_MODULE_0__.applyMiddleware)(...finalMiddleware);\n  const getDefaultEnhancers = buildGetDefaultEnhancers(middlewareEnhancer);\n  if (!IS_PRODUCTION && enhancers && typeof enhancers !== \"function\") {\n    throw new Error( false ? 0 : \"`enhancers` field must be a callback\");\n  }\n  let storeEnhancers = typeof enhancers === \"function\" ? enhancers(getDefaultEnhancers) : getDefaultEnhancers();\n  if (!IS_PRODUCTION && !Array.isArray(storeEnhancers)) {\n    throw new Error( false ? 0 : \"`enhancers` callback must return an array\");\n  }\n  if (!IS_PRODUCTION && storeEnhancers.some((item) => typeof item !== \"function\")) {\n    throw new Error( false ? 0 : \"each enhancer provided to configureStore must be a function\");\n  }\n  if (!IS_PRODUCTION && finalMiddleware.length && !storeEnhancers.includes(middlewareEnhancer)) {\n    console.error(\"middlewares were provided, but middleware enhancer was not included in final enhancers - make sure to call `getDefaultEnhancers`\");\n  }\n  const composedEnhancer = finalCompose(...storeEnhancers);\n  return (0,redux__WEBPACK_IMPORTED_MODULE_0__.createStore)(rootReducer, preloadedState, composedEnhancer);\n}\n\n// src/createReducer.ts\n\n\n// src/mapBuilders.ts\nfunction executeReducerBuilderCallback(builderCallback) {\n  const actionsMap = {};\n  const actionMatchers = [];\n  let defaultCaseReducer;\n  const builder = {\n    addCase(typeOrActionCreator, reducer) {\n      if (true) {\n        if (actionMatchers.length > 0) {\n          throw new Error( false ? 0 : \"`builder.addCase` should only be called before calling `builder.addMatcher`\");\n        }\n        if (defaultCaseReducer) {\n          throw new Error( false ? 0 : \"`builder.addCase` should only be called before calling `builder.addDefaultCase`\");\n        }\n      }\n      const type = typeof typeOrActionCreator === \"string\" ? typeOrActionCreator : typeOrActionCreator.type;\n      if (!type) {\n        throw new Error( false ? 0 : \"`builder.addCase` cannot be called with an empty action type\");\n      }\n      if (type in actionsMap) {\n        throw new Error( false ? 0 : `\\`builder.addCase\\` cannot be called with two reducers for the same action type '${type}'`);\n      }\n      actionsMap[type] = reducer;\n      return builder;\n    },\n    addMatcher(matcher, reducer) {\n      if (true) {\n        if (defaultCaseReducer) {\n          throw new Error( false ? 0 : \"`builder.addMatcher` should only be called before calling `builder.addDefaultCase`\");\n        }\n      }\n      actionMatchers.push({\n        matcher,\n        reducer\n      });\n      return builder;\n    },\n    addDefaultCase(reducer) {\n      if (true) {\n        if (defaultCaseReducer) {\n          throw new Error( false ? 0 : \"`builder.addDefaultCase` can only be called once\");\n        }\n      }\n      defaultCaseReducer = reducer;\n      return builder;\n    }\n  };\n  builderCallback(builder);\n  return [actionsMap, actionMatchers, defaultCaseReducer];\n}\n\n// src/createReducer.ts\nfunction isStateFunction(x) {\n  return typeof x === \"function\";\n}\nfunction createReducer(initialState, mapOrBuilderCallback) {\n  if (true) {\n    if (typeof mapOrBuilderCallback === \"object\") {\n      throw new Error( false ? 0 : \"The object notation for `createReducer` has been removed. Please use the 'builder callback' notation instead: https://redux-toolkit.js.org/api/createReducer\");\n    }\n  }\n  let [actionsMap, finalActionMatchers, finalDefaultCaseReducer] = executeReducerBuilderCallback(mapOrBuilderCallback);\n  let getInitialState;\n  if (isStateFunction(initialState)) {\n    getInitialState = () => freezeDraftable(initialState());\n  } else {\n    const frozenInitialState = freezeDraftable(initialState);\n    getInitialState = () => frozenInitialState;\n  }\n  function reducer(state = getInitialState(), action) {\n    let caseReducers = [actionsMap[action.type], ...finalActionMatchers.filter(({\n      matcher\n    }) => matcher(action)).map(({\n      reducer: reducer2\n    }) => reducer2)];\n    if (caseReducers.filter((cr) => !!cr).length === 0) {\n      caseReducers = [finalDefaultCaseReducer];\n    }\n    return caseReducers.reduce((previousState, caseReducer) => {\n      if (caseReducer) {\n        if ((0,immer__WEBPACK_IMPORTED_MODULE_2__.isDraft)(previousState)) {\n          const draft = previousState;\n          const result = caseReducer(draft, action);\n          if (result === void 0) {\n            return previousState;\n          }\n          return result;\n        } else if (!(0,immer__WEBPACK_IMPORTED_MODULE_2__.isDraftable)(previousState)) {\n          const result = caseReducer(previousState, action);\n          if (result === void 0) {\n            if (previousState === null) {\n              return previousState;\n            }\n            throw new Error( false ? 0 : \"A case reducer on a non-draftable value must not return undefined\");\n          }\n          return result;\n        } else {\n          return (0,immer__WEBPACK_IMPORTED_MODULE_2__.produce)(previousState, (draft) => {\n            return caseReducer(draft, action);\n          });\n        }\n      }\n      return previousState;\n    }, state);\n  }\n  reducer.getInitialState = getInitialState;\n  return reducer;\n}\n\n// src/nanoid.ts\nvar urlAlphabet = \"ModuleSymbhasOwnPr-0123456789ABCDEFGHNRVfgctiUvz_KqYTJkLxpZXIjQW\";\nvar nanoid = (size = 21) => {\n  let id = \"\";\n  let i = size;\n  while (i--) {\n    id += urlAlphabet[Math.random() * 64 | 0];\n  }\n  return id;\n};\n\n// src/matchers.ts\nvar matches = (matcher, action) => {\n  if (hasMatchFunction(matcher)) {\n    return matcher.match(action);\n  } else {\n    return matcher(action);\n  }\n};\nfunction isAnyOf(...matchers) {\n  return (action) => {\n    return matchers.some((matcher) => matches(matcher, action));\n  };\n}\nfunction isAllOf(...matchers) {\n  return (action) => {\n    return matchers.every((matcher) => matches(matcher, action));\n  };\n}\nfunction hasExpectedRequestMetadata(action, validStatus) {\n  if (!action || !action.meta)\n    return false;\n  const hasValidRequestId = typeof action.meta.requestId === \"string\";\n  const hasValidRequestStatus = validStatus.indexOf(action.meta.requestStatus) > -1;\n  return hasValidRequestId && hasValidRequestStatus;\n}\nfunction isAsyncThunkArray(a) {\n  return typeof a[0] === \"function\" && \"pending\" in a[0] && \"fulfilled\" in a[0] && \"rejected\" in a[0];\n}\nfunction isPending(...asyncThunks) {\n  if (asyncThunks.length === 0) {\n    return (action) => hasExpectedRequestMetadata(action, [\"pending\"]);\n  }\n  if (!isAsyncThunkArray(asyncThunks)) {\n    return isPending()(asyncThunks[0]);\n  }\n  return (action) => {\n    const matchers = asyncThunks.map((asyncThunk) => asyncThunk.pending);\n    const combinedMatcher = isAnyOf(...matchers);\n    return combinedMatcher(action);\n  };\n}\nfunction isRejected(...asyncThunks) {\n  if (asyncThunks.length === 0) {\n    return (action) => hasExpectedRequestMetadata(action, [\"rejected\"]);\n  }\n  if (!isAsyncThunkArray(asyncThunks)) {\n    return isRejected()(asyncThunks[0]);\n  }\n  return (action) => {\n    const matchers = asyncThunks.map((asyncThunk) => asyncThunk.rejected);\n    const combinedMatcher = isAnyOf(...matchers);\n    return combinedMatcher(action);\n  };\n}\nfunction isRejectedWithValue(...asyncThunks) {\n  const hasFlag = (action) => {\n    return action && action.meta && action.meta.rejectedWithValue;\n  };\n  if (asyncThunks.length === 0) {\n    return (action) => {\n      const combinedMatcher = isAllOf(isRejected(...asyncThunks), hasFlag);\n      return combinedMatcher(action);\n    };\n  }\n  if (!isAsyncThunkArray(asyncThunks)) {\n    return isRejectedWithValue()(asyncThunks[0]);\n  }\n  return (action) => {\n    const combinedMatcher = isAllOf(isRejected(...asyncThunks), hasFlag);\n    return combinedMatcher(action);\n  };\n}\nfunction isFulfilled(...asyncThunks) {\n  if (asyncThunks.length === 0) {\n    return (action) => hasExpectedRequestMetadata(action, [\"fulfilled\"]);\n  }\n  if (!isAsyncThunkArray(asyncThunks)) {\n    return isFulfilled()(asyncThunks[0]);\n  }\n  return (action) => {\n    const matchers = asyncThunks.map((asyncThunk) => asyncThunk.fulfilled);\n    const combinedMatcher = isAnyOf(...matchers);\n    return combinedMatcher(action);\n  };\n}\nfunction isAsyncThunkAction(...asyncThunks) {\n  if (asyncThunks.length === 0) {\n    return (action) => hasExpectedRequestMetadata(action, [\"pending\", \"fulfilled\", \"rejected\"]);\n  }\n  if (!isAsyncThunkArray(asyncThunks)) {\n    return isAsyncThunkAction()(asyncThunks[0]);\n  }\n  return (action) => {\n    const matchers = [];\n    for (const asyncThunk of asyncThunks) {\n      matchers.push(asyncThunk.pending, asyncThunk.rejected, asyncThunk.fulfilled);\n    }\n    const combinedMatcher = isAnyOf(...matchers);\n    return combinedMatcher(action);\n  };\n}\n\n// src/createAsyncThunk.ts\nvar commonProperties = [\"name\", \"message\", \"stack\", \"code\"];\nvar RejectWithValue = class {\n  constructor(payload, meta) {\n    this.payload = payload;\n    this.meta = meta;\n  }\n  /*\n  type-only property to distinguish between RejectWithValue and FulfillWithMeta\n  does not exist at runtime\n  */\n  _type;\n};\nvar FulfillWithMeta = class {\n  constructor(payload, meta) {\n    this.payload = payload;\n    this.meta = meta;\n  }\n  /*\n  type-only property to distinguish between RejectWithValue and FulfillWithMeta\n  does not exist at runtime\n  */\n  _type;\n};\nvar miniSerializeError = (value) => {\n  if (typeof value === \"object\" && value !== null) {\n    const simpleError = {};\n    for (const property of commonProperties) {\n      if (typeof value[property] === \"string\") {\n        simpleError[property] = value[property];\n      }\n    }\n    return simpleError;\n  }\n  return {\n    message: String(value)\n  };\n};\nvar createAsyncThunk = /* @__PURE__ */ (() => {\n  function createAsyncThunk2(typePrefix, payloadCreator, options) {\n    const fulfilled = createAction(typePrefix + \"/fulfilled\", (payload, requestId, arg, meta) => ({\n      payload,\n      meta: {\n        ...meta || {},\n        arg,\n        requestId,\n        requestStatus: \"fulfilled\"\n      }\n    }));\n    const pending = createAction(typePrefix + \"/pending\", (requestId, arg, meta) => ({\n      payload: void 0,\n      meta: {\n        ...meta || {},\n        arg,\n        requestId,\n        requestStatus: \"pending\"\n      }\n    }));\n    const rejected = createAction(typePrefix + \"/rejected\", (error, requestId, arg, payload, meta) => ({\n      payload,\n      error: (options && options.serializeError || miniSerializeError)(error || \"Rejected\"),\n      meta: {\n        ...meta || {},\n        arg,\n        requestId,\n        rejectedWithValue: !!payload,\n        requestStatus: \"rejected\",\n        aborted: error?.name === \"AbortError\",\n        condition: error?.name === \"ConditionError\"\n      }\n    }));\n    function actionCreator(arg) {\n      return (dispatch, getState, extra) => {\n        const requestId = options?.idGenerator ? options.idGenerator(arg) : nanoid();\n        const abortController = new AbortController();\n        let abortHandler;\n        let abortReason;\n        function abort(reason) {\n          abortReason = reason;\n          abortController.abort();\n        }\n        const promise = async function() {\n          let finalAction;\n          try {\n            let conditionResult = options?.condition?.(arg, {\n              getState,\n              extra\n            });\n            if (isThenable(conditionResult)) {\n              conditionResult = await conditionResult;\n            }\n            if (conditionResult === false || abortController.signal.aborted) {\n              throw {\n                name: \"ConditionError\",\n                message: \"Aborted due to condition callback returning false.\"\n              };\n            }\n            const abortedPromise = new Promise((_, reject) => {\n              abortHandler = () => {\n                reject({\n                  name: \"AbortError\",\n                  message: abortReason || \"Aborted\"\n                });\n              };\n              abortController.signal.addEventListener(\"abort\", abortHandler);\n            });\n            dispatch(pending(requestId, arg, options?.getPendingMeta?.({\n              requestId,\n              arg\n            }, {\n              getState,\n              extra\n            })));\n            finalAction = await Promise.race([abortedPromise, Promise.resolve(payloadCreator(arg, {\n              dispatch,\n              getState,\n              extra,\n              requestId,\n              signal: abortController.signal,\n              abort,\n              rejectWithValue: (value, meta) => {\n                return new RejectWithValue(value, meta);\n              },\n              fulfillWithValue: (value, meta) => {\n                return new FulfillWithMeta(value, meta);\n              }\n            })).then((result) => {\n              if (result instanceof RejectWithValue) {\n                throw result;\n              }\n              if (result instanceof FulfillWithMeta) {\n                return fulfilled(result.payload, requestId, arg, result.meta);\n              }\n              return fulfilled(result, requestId, arg);\n            })]);\n          } catch (err) {\n            finalAction = err instanceof RejectWithValue ? rejected(null, requestId, arg, err.payload, err.meta) : rejected(err, requestId, arg);\n          } finally {\n            if (abortHandler) {\n              abortController.signal.removeEventListener(\"abort\", abortHandler);\n            }\n          }\n          const skipDispatch = options && !options.dispatchConditionRejection && rejected.match(finalAction) && finalAction.meta.condition;\n          if (!skipDispatch) {\n            dispatch(finalAction);\n          }\n          return finalAction;\n        }();\n        return Object.assign(promise, {\n          abort,\n          requestId,\n          arg,\n          unwrap() {\n            return promise.then(unwrapResult);\n          }\n        });\n      };\n    }\n    return Object.assign(actionCreator, {\n      pending,\n      rejected,\n      fulfilled,\n      settled: isAnyOf(rejected, fulfilled),\n      typePrefix\n    });\n  }\n  createAsyncThunk2.withTypes = () => createAsyncThunk2;\n  return createAsyncThunk2;\n})();\nfunction unwrapResult(action) {\n  if (action.meta && action.meta.rejectedWithValue) {\n    throw action.payload;\n  }\n  if (action.error) {\n    throw action.error;\n  }\n  return action.payload;\n}\nfunction isThenable(value) {\n  return value !== null && typeof value === \"object\" && typeof value.then === \"function\";\n}\n\n// src/createSlice.ts\nvar asyncThunkSymbol = /* @__PURE__ */ Symbol.for(\"rtk-slice-createasyncthunk\");\nvar asyncThunkCreator = {\n  [asyncThunkSymbol]: createAsyncThunk\n};\nvar ReducerType = /* @__PURE__ */ ((ReducerType2) => {\n  ReducerType2[\"reducer\"] = \"reducer\";\n  ReducerType2[\"reducerWithPrepare\"] = \"reducerWithPrepare\";\n  ReducerType2[\"asyncThunk\"] = \"asyncThunk\";\n  return ReducerType2;\n})(ReducerType || {});\nfunction getType(slice, actionKey) {\n  return `${slice}/${actionKey}`;\n}\nfunction buildCreateSlice({\n  creators\n} = {}) {\n  const cAT = creators?.asyncThunk?.[asyncThunkSymbol];\n  return function createSlice2(options) {\n    const {\n      name,\n      reducerPath = name\n    } = options;\n    if (!name) {\n      throw new Error( false ? 0 : \"`name` is a required option for createSlice\");\n    }\n    if (typeof process !== \"undefined\" && \"development\" === \"development\") {\n      if (options.initialState === void 0) {\n        console.error(\"You must provide an `initialState` value that is not `undefined`. You may have misspelled `initialState`\");\n      }\n    }\n    const reducers = (typeof options.reducers === \"function\" ? options.reducers(buildReducerCreators()) : options.reducers) || {};\n    const reducerNames = Object.keys(reducers);\n    const context = {\n      sliceCaseReducersByName: {},\n      sliceCaseReducersByType: {},\n      actionCreators: {},\n      sliceMatchers: []\n    };\n    const contextMethods = {\n      addCase(typeOrActionCreator, reducer2) {\n        const type = typeof typeOrActionCreator === \"string\" ? typeOrActionCreator : typeOrActionCreator.type;\n        if (!type) {\n          throw new Error( false ? 0 : \"`context.addCase` cannot be called with an empty action type\");\n        }\n        if (type in context.sliceCaseReducersByType) {\n          throw new Error( false ? 0 : \"`context.addCase` cannot be called with two reducers for the same action type: \" + type);\n        }\n        context.sliceCaseReducersByType[type] = reducer2;\n        return contextMethods;\n      },\n      addMatcher(matcher, reducer2) {\n        context.sliceMatchers.push({\n          matcher,\n          reducer: reducer2\n        });\n        return contextMethods;\n      },\n      exposeAction(name2, actionCreator) {\n        context.actionCreators[name2] = actionCreator;\n        return contextMethods;\n      },\n      exposeCaseReducer(name2, reducer2) {\n        context.sliceCaseReducersByName[name2] = reducer2;\n        return contextMethods;\n      }\n    };\n    reducerNames.forEach((reducerName) => {\n      const reducerDefinition = reducers[reducerName];\n      const reducerDetails = {\n        reducerName,\n        type: getType(name, reducerName),\n        createNotation: typeof options.reducers === \"function\"\n      };\n      if (isAsyncThunkSliceReducerDefinition(reducerDefinition)) {\n        handleThunkCaseReducerDefinition(reducerDetails, reducerDefinition, contextMethods, cAT);\n      } else {\n        handleNormalReducerDefinition(reducerDetails, reducerDefinition, contextMethods);\n      }\n    });\n    function buildReducer() {\n      if (true) {\n        if (typeof options.extraReducers === \"object\") {\n          throw new Error( false ? 0 : \"The object notation for `createSlice.extraReducers` has been removed. Please use the 'builder callback' notation instead: https://redux-toolkit.js.org/api/createSlice\");\n        }\n      }\n      const [extraReducers = {}, actionMatchers = [], defaultCaseReducer = void 0] = typeof options.extraReducers === \"function\" ? executeReducerBuilderCallback(options.extraReducers) : [options.extraReducers];\n      const finalCaseReducers = {\n        ...extraReducers,\n        ...context.sliceCaseReducersByType\n      };\n      return createReducer(options.initialState, (builder) => {\n        for (let key in finalCaseReducers) {\n          builder.addCase(key, finalCaseReducers[key]);\n        }\n        for (let sM of context.sliceMatchers) {\n          builder.addMatcher(sM.matcher, sM.reducer);\n        }\n        for (let m of actionMatchers) {\n          builder.addMatcher(m.matcher, m.reducer);\n        }\n        if (defaultCaseReducer) {\n          builder.addDefaultCase(defaultCaseReducer);\n        }\n      });\n    }\n    const selectSelf = (state) => state;\n    const injectedSelectorCache = /* @__PURE__ */ new Map();\n    let _reducer;\n    function reducer(state, action) {\n      if (!_reducer)\n        _reducer = buildReducer();\n      return _reducer(state, action);\n    }\n    function getInitialState() {\n      if (!_reducer)\n        _reducer = buildReducer();\n      return _reducer.getInitialState();\n    }\n    function makeSelectorProps(reducerPath2, injected = false) {\n      function selectSlice(state) {\n        let sliceState = state[reducerPath2];\n        if (typeof sliceState === \"undefined\") {\n          if (injected) {\n            sliceState = getInitialState();\n          } else if (true) {\n            throw new Error( false ? 0 : \"selectSlice returned undefined for an uninjected slice reducer\");\n          }\n        }\n        return sliceState;\n      }\n      function getSelectors(selectState = selectSelf) {\n        const selectorCache = emplace(injectedSelectorCache, injected, {\n          insert: () => /* @__PURE__ */ new WeakMap()\n        });\n        return emplace(selectorCache, selectState, {\n          insert: () => {\n            const map = {};\n            for (const [name2, selector] of Object.entries(options.selectors ?? {})) {\n              map[name2] = wrapSelector(selector, selectState, getInitialState, injected);\n            }\n            return map;\n          }\n        });\n      }\n      return {\n        reducerPath: reducerPath2,\n        getSelectors,\n        get selectors() {\n          return getSelectors(selectSlice);\n        },\n        selectSlice\n      };\n    }\n    const slice = {\n      name,\n      reducer,\n      actions: context.actionCreators,\n      caseReducers: context.sliceCaseReducersByName,\n      getInitialState,\n      ...makeSelectorProps(reducerPath),\n      injectInto(injectable, {\n        reducerPath: pathOpt,\n        ...config\n      } = {}) {\n        const newReducerPath = pathOpt ?? reducerPath;\n        injectable.inject({\n          reducerPath: newReducerPath,\n          reducer\n        }, config);\n        return {\n          ...slice,\n          ...makeSelectorProps(newReducerPath, true)\n        };\n      }\n    };\n    return slice;\n  };\n}\nfunction wrapSelector(selector, selectState, getInitialState, injected) {\n  function wrapper(rootState, ...args) {\n    let sliceState = selectState(rootState);\n    if (typeof sliceState === \"undefined\") {\n      if (injected) {\n        sliceState = getInitialState();\n      } else if (true) {\n        throw new Error( false ? 0 : \"selectState returned undefined for an uninjected slice reducer\");\n      }\n    }\n    return selector(sliceState, ...args);\n  }\n  wrapper.unwrapped = selector;\n  return wrapper;\n}\nvar createSlice = /* @__PURE__ */ buildCreateSlice();\nfunction buildReducerCreators() {\n  function asyncThunk(payloadCreator, config) {\n    return {\n      _reducerDefinitionType: \"asyncThunk\" /* asyncThunk */,\n      payloadCreator,\n      ...config\n    };\n  }\n  asyncThunk.withTypes = () => asyncThunk;\n  return {\n    reducer(caseReducer) {\n      return Object.assign({\n        // hack so the wrapping function has the same name as the original\n        // we need to create a wrapper so the `reducerDefinitionType` is not assigned to the original\n        [caseReducer.name](...args) {\n          return caseReducer(...args);\n        }\n      }[caseReducer.name], {\n        _reducerDefinitionType: \"reducer\" /* reducer */\n      });\n    },\n    preparedReducer(prepare, reducer) {\n      return {\n        _reducerDefinitionType: \"reducerWithPrepare\" /* reducerWithPrepare */,\n        prepare,\n        reducer\n      };\n    },\n    asyncThunk\n  };\n}\nfunction handleNormalReducerDefinition({\n  type,\n  reducerName,\n  createNotation\n}, maybeReducerWithPrepare, context) {\n  let caseReducer;\n  let prepareCallback;\n  if (\"reducer\" in maybeReducerWithPrepare) {\n    if (createNotation && !isCaseReducerWithPrepareDefinition(maybeReducerWithPrepare)) {\n      throw new Error( false ? 0 : \"Please use the `create.preparedReducer` notation for prepared action creators with the `create` notation.\");\n    }\n    caseReducer = maybeReducerWithPrepare.reducer;\n    prepareCallback = maybeReducerWithPrepare.prepare;\n  } else {\n    caseReducer = maybeReducerWithPrepare;\n  }\n  context.addCase(type, caseReducer).exposeCaseReducer(reducerName, caseReducer).exposeAction(reducerName, prepareCallback ? createAction(type, prepareCallback) : createAction(type));\n}\nfunction isAsyncThunkSliceReducerDefinition(reducerDefinition) {\n  return reducerDefinition._reducerDefinitionType === \"asyncThunk\" /* asyncThunk */;\n}\nfunction isCaseReducerWithPrepareDefinition(reducerDefinition) {\n  return reducerDefinition._reducerDefinitionType === \"reducerWithPrepare\" /* reducerWithPrepare */;\n}\nfunction handleThunkCaseReducerDefinition({\n  type,\n  reducerName\n}, reducerDefinition, context, cAT) {\n  if (!cAT) {\n    throw new Error( false ? 0 : \"Cannot use `create.asyncThunk` in the built-in `createSlice`. Use `buildCreateSlice({ creators: { asyncThunk: asyncThunkCreator } })` to create a customised version of `createSlice`.\");\n  }\n  const {\n    payloadCreator,\n    fulfilled,\n    pending,\n    rejected,\n    settled,\n    options\n  } = reducerDefinition;\n  const thunk = cAT(type, payloadCreator, options);\n  context.exposeAction(reducerName, thunk);\n  if (fulfilled) {\n    context.addCase(thunk.fulfilled, fulfilled);\n  }\n  if (pending) {\n    context.addCase(thunk.pending, pending);\n  }\n  if (rejected) {\n    context.addCase(thunk.rejected, rejected);\n  }\n  if (settled) {\n    context.addMatcher(thunk.settled, settled);\n  }\n  context.exposeCaseReducer(reducerName, {\n    fulfilled: fulfilled || noop,\n    pending: pending || noop,\n    rejected: rejected || noop,\n    settled: settled || noop\n  });\n}\nfunction noop() {\n}\n\n// src/entities/entity_state.ts\nfunction getInitialEntityState() {\n  return {\n    ids: [],\n    entities: {}\n  };\n}\nfunction createInitialStateFactory(stateAdapter) {\n  function getInitialState(additionalState = {}, entities) {\n    const state = Object.assign(getInitialEntityState(), additionalState);\n    return entities ? stateAdapter.setAll(state, entities) : state;\n  }\n  return {\n    getInitialState\n  };\n}\n\n// src/entities/state_selectors.ts\nfunction createSelectorsFactory() {\n  function getSelectors(selectState, options = {}) {\n    const {\n      createSelector: createSelector2 = createDraftSafeSelector\n    } = options;\n    const selectIds = (state) => state.ids;\n    const selectEntities = (state) => state.entities;\n    const selectAll = createSelector2(selectIds, selectEntities, (ids, entities) => ids.map((id) => entities[id]));\n    const selectId = (_, id) => id;\n    const selectById = (entities, id) => entities[id];\n    const selectTotal = createSelector2(selectIds, (ids) => ids.length);\n    if (!selectState) {\n      return {\n        selectIds,\n        selectEntities,\n        selectAll,\n        selectTotal,\n        selectById: createSelector2(selectEntities, selectId, selectById)\n      };\n    }\n    const selectGlobalizedEntities = createSelector2(selectState, selectEntities);\n    return {\n      selectIds: createSelector2(selectState, selectIds),\n      selectEntities: selectGlobalizedEntities,\n      selectAll: createSelector2(selectState, selectAll),\n      selectTotal: createSelector2(selectState, selectTotal),\n      selectById: createSelector2(selectGlobalizedEntities, selectId, selectById)\n    };\n  }\n  return {\n    getSelectors\n  };\n}\n\n// src/entities/state_adapter.ts\n\nvar isDraftTyped = immer__WEBPACK_IMPORTED_MODULE_2__.isDraft;\nfunction createSingleArgumentStateOperator(mutator) {\n  const operator = createStateOperator((_, state) => mutator(state));\n  return function operation(state) {\n    return operator(state, void 0);\n  };\n}\nfunction createStateOperator(mutator) {\n  return function operation(state, arg) {\n    function isPayloadActionArgument(arg2) {\n      return isFSA(arg2);\n    }\n    const runMutator = (draft) => {\n      if (isPayloadActionArgument(arg)) {\n        mutator(arg.payload, draft);\n      } else {\n        mutator(arg, draft);\n      }\n    };\n    if (isDraftTyped(state)) {\n      runMutator(state);\n      return state;\n    }\n    return (0,immer__WEBPACK_IMPORTED_MODULE_2__.produce)(state, runMutator);\n  };\n}\n\n// src/entities/utils.ts\nfunction selectIdValue(entity, selectId) {\n  const key = selectId(entity);\n  if ( true && key === void 0) {\n    console.warn(\"The entity passed to the `selectId` implementation returned undefined.\", \"You should probably provide your own `selectId` implementation.\", \"The entity that was passed:\", entity, \"The `selectId` implementation:\", selectId.toString());\n  }\n  return key;\n}\nfunction ensureEntitiesArray(entities) {\n  if (!Array.isArray(entities)) {\n    entities = Object.values(entities);\n  }\n  return entities;\n}\nfunction splitAddedUpdatedEntities(newEntities, selectId, state) {\n  newEntities = ensureEntitiesArray(newEntities);\n  const added = [];\n  const updated = [];\n  for (const entity of newEntities) {\n    const id = selectIdValue(entity, selectId);\n    if (id in state.entities) {\n      updated.push({\n        id,\n        changes: entity\n      });\n    } else {\n      added.push(entity);\n    }\n  }\n  return [added, updated];\n}\n\n// src/entities/unsorted_state_adapter.ts\nfunction createUnsortedStateAdapter(selectId) {\n  function addOneMutably(entity, state) {\n    const key = selectIdValue(entity, selectId);\n    if (key in state.entities) {\n      return;\n    }\n    state.ids.push(key);\n    state.entities[key] = entity;\n  }\n  function addManyMutably(newEntities, state) {\n    newEntities = ensureEntitiesArray(newEntities);\n    for (const entity of newEntities) {\n      addOneMutably(entity, state);\n    }\n  }\n  function setOneMutably(entity, state) {\n    const key = selectIdValue(entity, selectId);\n    if (!(key in state.entities)) {\n      state.ids.push(key);\n    }\n    ;\n    state.entities[key] = entity;\n  }\n  function setManyMutably(newEntities, state) {\n    newEntities = ensureEntitiesArray(newEntities);\n    for (const entity of newEntities) {\n      setOneMutably(entity, state);\n    }\n  }\n  function setAllMutably(newEntities, state) {\n    newEntities = ensureEntitiesArray(newEntities);\n    state.ids = [];\n    state.entities = {};\n    addManyMutably(newEntities, state);\n  }\n  function removeOneMutably(key, state) {\n    return removeManyMutably([key], state);\n  }\n  function removeManyMutably(keys, state) {\n    let didMutate = false;\n    keys.forEach((key) => {\n      if (key in state.entities) {\n        delete state.entities[key];\n        didMutate = true;\n      }\n    });\n    if (didMutate) {\n      state.ids = state.ids.filter((id) => id in state.entities);\n    }\n  }\n  function removeAllMutably(state) {\n    Object.assign(state, {\n      ids: [],\n      entities: {}\n    });\n  }\n  function takeNewKey(keys, update, state) {\n    const original3 = state.entities[update.id];\n    if (original3 === void 0) {\n      return false;\n    }\n    const updated = Object.assign({}, original3, update.changes);\n    const newKey = selectIdValue(updated, selectId);\n    const hasNewKey = newKey !== update.id;\n    if (hasNewKey) {\n      keys[update.id] = newKey;\n      delete state.entities[update.id];\n    }\n    ;\n    state.entities[newKey] = updated;\n    return hasNewKey;\n  }\n  function updateOneMutably(update, state) {\n    return updateManyMutably([update], state);\n  }\n  function updateManyMutably(updates, state) {\n    const newKeys = {};\n    const updatesPerEntity = {};\n    updates.forEach((update) => {\n      if (update.id in state.entities) {\n        updatesPerEntity[update.id] = {\n          id: update.id,\n          // Spreads ignore falsy values, so this works even if there isn't\n          // an existing update already at this key\n          changes: {\n            ...updatesPerEntity[update.id] ? updatesPerEntity[update.id].changes : null,\n            ...update.changes\n          }\n        };\n      }\n    });\n    updates = Object.values(updatesPerEntity);\n    const didMutateEntities = updates.length > 0;\n    if (didMutateEntities) {\n      const didMutateIds = updates.filter((update) => takeNewKey(newKeys, update, state)).length > 0;\n      if (didMutateIds) {\n        state.ids = Object.values(state.entities).map((e) => selectIdValue(e, selectId));\n      }\n    }\n  }\n  function upsertOneMutably(entity, state) {\n    return upsertManyMutably([entity], state);\n  }\n  function upsertManyMutably(newEntities, state) {\n    const [added, updated] = splitAddedUpdatedEntities(newEntities, selectId, state);\n    updateManyMutably(updated, state);\n    addManyMutably(added, state);\n  }\n  return {\n    removeAll: createSingleArgumentStateOperator(removeAllMutably),\n    addOne: createStateOperator(addOneMutably),\n    addMany: createStateOperator(addManyMutably),\n    setOne: createStateOperator(setOneMutably),\n    setMany: createStateOperator(setManyMutably),\n    setAll: createStateOperator(setAllMutably),\n    updateOne: createStateOperator(updateOneMutably),\n    updateMany: createStateOperator(updateManyMutably),\n    upsertOne: createStateOperator(upsertOneMutably),\n    upsertMany: createStateOperator(upsertManyMutably),\n    removeOne: createStateOperator(removeOneMutably),\n    removeMany: createStateOperator(removeManyMutably)\n  };\n}\n\n// src/entities/sorted_state_adapter.ts\nfunction createSortedStateAdapter(selectId, sort) {\n  const {\n    removeOne,\n    removeMany,\n    removeAll\n  } = createUnsortedStateAdapter(selectId);\n  function addOneMutably(entity, state) {\n    return addManyMutably([entity], state);\n  }\n  function addManyMutably(newEntities, state) {\n    newEntities = ensureEntitiesArray(newEntities);\n    const models = newEntities.filter((model) => !(selectIdValue(model, selectId) in state.entities));\n    if (models.length !== 0) {\n      merge(models, state);\n    }\n  }\n  function setOneMutably(entity, state) {\n    return setManyMutably([entity], state);\n  }\n  function setManyMutably(newEntities, state) {\n    newEntities = ensureEntitiesArray(newEntities);\n    if (newEntities.length !== 0) {\n      merge(newEntities, state);\n    }\n  }\n  function setAllMutably(newEntities, state) {\n    newEntities = ensureEntitiesArray(newEntities);\n    state.entities = {};\n    state.ids = [];\n    addManyMutably(newEntities, state);\n  }\n  function updateOneMutably(update, state) {\n    return updateManyMutably([update], state);\n  }\n  function updateManyMutably(updates, state) {\n    let appliedUpdates = false;\n    for (let update of updates) {\n      const entity = state.entities[update.id];\n      if (!entity) {\n        continue;\n      }\n      appliedUpdates = true;\n      Object.assign(entity, update.changes);\n      const newId = selectId(entity);\n      if (update.id !== newId) {\n        delete state.entities[update.id];\n        state.entities[newId] = entity;\n      }\n    }\n    if (appliedUpdates) {\n      resortEntities(state);\n    }\n  }\n  function upsertOneMutably(entity, state) {\n    return upsertManyMutably([entity], state);\n  }\n  function upsertManyMutably(newEntities, state) {\n    const [added, updated] = splitAddedUpdatedEntities(newEntities, selectId, state);\n    updateManyMutably(updated, state);\n    addManyMutably(added, state);\n  }\n  function areArraysEqual(a, b) {\n    if (a.length !== b.length) {\n      return false;\n    }\n    for (let i = 0; i < a.length && i < b.length; i++) {\n      if (a[i] === b[i]) {\n        continue;\n      }\n      return false;\n    }\n    return true;\n  }\n  function merge(models, state) {\n    models.forEach((model) => {\n      ;\n      state.entities[selectId(model)] = model;\n    });\n    resortEntities(state);\n  }\n  function resortEntities(state) {\n    const allEntities = Object.values(state.entities);\n    allEntities.sort(sort);\n    const newSortedIds = allEntities.map(selectId);\n    const {\n      ids\n    } = state;\n    if (!areArraysEqual(ids, newSortedIds)) {\n      state.ids = newSortedIds;\n    }\n  }\n  return {\n    removeOne,\n    removeMany,\n    removeAll,\n    addOne: createStateOperator(addOneMutably),\n    updateOne: createStateOperator(updateOneMutably),\n    upsertOne: createStateOperator(upsertOneMutably),\n    setOne: createStateOperator(setOneMutably),\n    setMany: createStateOperator(setManyMutably),\n    setAll: createStateOperator(setAllMutably),\n    addMany: createStateOperator(addManyMutably),\n    updateMany: createStateOperator(updateManyMutably),\n    upsertMany: createStateOperator(upsertManyMutably)\n  };\n}\n\n// src/entities/create_adapter.ts\nfunction createEntityAdapter(options = {}) {\n  const {\n    selectId,\n    sortComparer\n  } = {\n    sortComparer: false,\n    selectId: (instance) => instance.id,\n    ...options\n  };\n  const stateAdapter = sortComparer ? createSortedStateAdapter(selectId, sortComparer) : createUnsortedStateAdapter(selectId);\n  const stateFactory = createInitialStateFactory(stateAdapter);\n  const selectorsFactory = createSelectorsFactory();\n  return {\n    selectId,\n    sortComparer,\n    ...stateFactory,\n    ...selectorsFactory,\n    ...stateAdapter\n  };\n}\n\n// src/listenerMiddleware/index.ts\n\n\n// src/listenerMiddleware/exceptions.ts\nvar task = \"task\";\nvar listener = \"listener\";\nvar completed = \"completed\";\nvar cancelled = \"cancelled\";\nvar taskCancelled = `task-${cancelled}`;\nvar taskCompleted = `task-${completed}`;\nvar listenerCancelled = `${listener}-${cancelled}`;\nvar listenerCompleted = `${listener}-${completed}`;\nvar TaskAbortError = class {\n  constructor(code) {\n    this.code = code;\n    this.message = `${task} ${cancelled} (reason: ${code})`;\n  }\n  name = \"TaskAbortError\";\n  message;\n};\n\n// src/listenerMiddleware/utils.ts\nvar assertFunction = (func, expected) => {\n  if (typeof func !== \"function\") {\n    throw new Error( false ? 0 : `${expected} is not a function`);\n  }\n};\nvar noop2 = () => {\n};\nvar catchRejection = (promise, onError = noop2) => {\n  promise.catch(onError);\n  return promise;\n};\nvar addAbortSignalListener = (abortSignal, callback) => {\n  abortSignal.addEventListener(\"abort\", callback, {\n    once: true\n  });\n  return () => abortSignal.removeEventListener(\"abort\", callback);\n};\nvar abortControllerWithReason = (abortController, reason) => {\n  const signal = abortController.signal;\n  if (signal.aborted) {\n    return;\n  }\n  if (!(\"reason\" in signal)) {\n    Object.defineProperty(signal, \"reason\", {\n      enumerable: true,\n      value: reason,\n      configurable: true,\n      writable: true\n    });\n  }\n  ;\n  abortController.abort(reason);\n};\n\n// src/listenerMiddleware/task.ts\nvar validateActive = (signal) => {\n  if (signal.aborted) {\n    const {\n      reason\n    } = signal;\n    throw new TaskAbortError(reason);\n  }\n};\nfunction raceWithSignal(signal, promise) {\n  let cleanup = noop2;\n  return new Promise((resolve, reject) => {\n    const notifyRejection = () => reject(new TaskAbortError(signal.reason));\n    if (signal.aborted) {\n      notifyRejection();\n      return;\n    }\n    cleanup = addAbortSignalListener(signal, notifyRejection);\n    promise.finally(() => cleanup()).then(resolve, reject);\n  }).finally(() => {\n    cleanup = noop2;\n  });\n}\nvar runTask = async (task2, cleanUp) => {\n  try {\n    await Promise.resolve();\n    const value = await task2();\n    return {\n      status: \"ok\",\n      value\n    };\n  } catch (error) {\n    return {\n      status: error instanceof TaskAbortError ? \"cancelled\" : \"rejected\",\n      error\n    };\n  } finally {\n    cleanUp?.();\n  }\n};\nvar createPause = (signal) => {\n  return (promise) => {\n    return catchRejection(raceWithSignal(signal, promise).then((output) => {\n      validateActive(signal);\n      return output;\n    }));\n  };\n};\nvar createDelay = (signal) => {\n  const pause = createPause(signal);\n  return (timeoutMs) => {\n    return pause(new Promise((resolve) => setTimeout(resolve, timeoutMs)));\n  };\n};\n\n// src/listenerMiddleware/index.ts\nvar {\n  assign\n} = Object;\nvar INTERNAL_NIL_TOKEN = {};\nvar alm = \"listenerMiddleware\";\nvar createFork = (parentAbortSignal, parentBlockingPromises) => {\n  const linkControllers = (controller) => addAbortSignalListener(parentAbortSignal, () => abortControllerWithReason(controller, parentAbortSignal.reason));\n  return (taskExecutor, opts) => {\n    assertFunction(taskExecutor, \"taskExecutor\");\n    const childAbortController = new AbortController();\n    linkControllers(childAbortController);\n    const result = runTask(async () => {\n      validateActive(parentAbortSignal);\n      validateActive(childAbortController.signal);\n      const result2 = await taskExecutor({\n        pause: createPause(childAbortController.signal),\n        delay: createDelay(childAbortController.signal),\n        signal: childAbortController.signal\n      });\n      validateActive(childAbortController.signal);\n      return result2;\n    }, () => abortControllerWithReason(childAbortController, taskCompleted));\n    if (opts?.autoJoin) {\n      parentBlockingPromises.push(result.catch(noop2));\n    }\n    return {\n      result: createPause(parentAbortSignal)(result),\n      cancel() {\n        abortControllerWithReason(childAbortController, taskCancelled);\n      }\n    };\n  };\n};\nvar createTakePattern = (startListening, signal) => {\n  const take = async (predicate, timeout) => {\n    validateActive(signal);\n    let unsubscribe = () => {\n    };\n    const tuplePromise = new Promise((resolve, reject) => {\n      let stopListening = startListening({\n        predicate,\n        effect: (action, listenerApi) => {\n          listenerApi.unsubscribe();\n          resolve([action, listenerApi.getState(), listenerApi.getOriginalState()]);\n        }\n      });\n      unsubscribe = () => {\n        stopListening();\n        reject();\n      };\n    });\n    const promises = [tuplePromise];\n    if (timeout != null) {\n      promises.push(new Promise((resolve) => setTimeout(resolve, timeout, null)));\n    }\n    try {\n      const output = await raceWithSignal(signal, Promise.race(promises));\n      validateActive(signal);\n      return output;\n    } finally {\n      unsubscribe();\n    }\n  };\n  return (predicate, timeout) => catchRejection(take(predicate, timeout));\n};\nvar getListenerEntryPropsFrom = (options) => {\n  let {\n    type,\n    actionCreator,\n    matcher,\n    predicate,\n    effect\n  } = options;\n  if (type) {\n    predicate = createAction(type).match;\n  } else if (actionCreator) {\n    type = actionCreator.type;\n    predicate = actionCreator.match;\n  } else if (matcher) {\n    predicate = matcher;\n  } else if (predicate) {\n  } else {\n    throw new Error( false ? 0 : \"Creating or removing a listener requires one of the known fields for matching an action\");\n  }\n  assertFunction(effect, \"options.listener\");\n  return {\n    predicate,\n    type,\n    effect\n  };\n};\nvar createListenerEntry = Object.assign((options) => {\n  const {\n    type,\n    predicate,\n    effect\n  } = getListenerEntryPropsFrom(options);\n  const id = nanoid();\n  const entry = {\n    id,\n    effect,\n    type,\n    predicate,\n    pending: /* @__PURE__ */ new Set(),\n    unsubscribe: () => {\n      throw new Error( false ? 0 : \"Unsubscribe not initialized\");\n    }\n  };\n  return entry;\n}, {\n  withTypes: () => createListenerEntry\n});\nvar cancelActiveListeners = (entry) => {\n  entry.pending.forEach((controller) => {\n    abortControllerWithReason(controller, listenerCancelled);\n  });\n};\nvar createClearListenerMiddleware = (listenerMap) => {\n  return () => {\n    listenerMap.forEach(cancelActiveListeners);\n    listenerMap.clear();\n  };\n};\nvar safelyNotifyError = (errorHandler, errorToNotify, errorInfo) => {\n  try {\n    errorHandler(errorToNotify, errorInfo);\n  } catch (errorHandlerError) {\n    setTimeout(() => {\n      throw errorHandlerError;\n    }, 0);\n  }\n};\nvar addListener = Object.assign(createAction(`${alm}/add`), {\n  withTypes: () => addListener\n});\nvar clearAllListeners = createAction(`${alm}/removeAll`);\nvar removeListener = Object.assign(createAction(`${alm}/remove`), {\n  withTypes: () => removeListener\n});\nvar defaultErrorHandler = (...args) => {\n  console.error(`${alm}/error`, ...args);\n};\nvar createListenerMiddleware = (middlewareOptions = {}) => {\n  const listenerMap = /* @__PURE__ */ new Map();\n  const {\n    extra,\n    onError = defaultErrorHandler\n  } = middlewareOptions;\n  assertFunction(onError, \"onError\");\n  const insertEntry = (entry) => {\n    entry.unsubscribe = () => listenerMap.delete(entry.id);\n    listenerMap.set(entry.id, entry);\n    return (cancelOptions) => {\n      entry.unsubscribe();\n      if (cancelOptions?.cancelActive) {\n        cancelActiveListeners(entry);\n      }\n    };\n  };\n  const startListening = (options) => {\n    let entry = find(Array.from(listenerMap.values()), (existingEntry) => existingEntry.effect === options.effect);\n    if (!entry) {\n      entry = createListenerEntry(options);\n    }\n    return insertEntry(entry);\n  };\n  Object.assign(startListening, {\n    withTypes: () => startListening\n  });\n  const stopListening = (options) => {\n    const {\n      type,\n      effect,\n      predicate\n    } = getListenerEntryPropsFrom(options);\n    const entry = find(Array.from(listenerMap.values()), (entry2) => {\n      const matchPredicateOrType = typeof type === \"string\" ? entry2.type === type : entry2.predicate === predicate;\n      return matchPredicateOrType && entry2.effect === effect;\n    });\n    if (entry) {\n      entry.unsubscribe();\n      if (options.cancelActive) {\n        cancelActiveListeners(entry);\n      }\n    }\n    return !!entry;\n  };\n  Object.assign(stopListening, {\n    withTypes: () => stopListening\n  });\n  const notifyListener = async (entry, action, api, getOriginalState) => {\n    const internalTaskController = new AbortController();\n    const take = createTakePattern(startListening, internalTaskController.signal);\n    const autoJoinPromises = [];\n    try {\n      entry.pending.add(internalTaskController);\n      await Promise.resolve(entry.effect(\n        action,\n        // Use assign() rather than ... to avoid extra helper functions added to bundle\n        assign({}, api, {\n          getOriginalState,\n          condition: (predicate, timeout) => take(predicate, timeout).then(Boolean),\n          take,\n          delay: createDelay(internalTaskController.signal),\n          pause: createPause(internalTaskController.signal),\n          extra,\n          signal: internalTaskController.signal,\n          fork: createFork(internalTaskController.signal, autoJoinPromises),\n          unsubscribe: entry.unsubscribe,\n          subscribe: () => {\n            listenerMap.set(entry.id, entry);\n          },\n          cancelActiveListeners: () => {\n            entry.pending.forEach((controller, _, set) => {\n              if (controller !== internalTaskController) {\n                abortControllerWithReason(controller, listenerCancelled);\n                set.delete(controller);\n              }\n            });\n          },\n          cancel: () => {\n            abortControllerWithReason(internalTaskController, listenerCancelled);\n            entry.pending.delete(internalTaskController);\n          },\n          throwIfCancelled: () => {\n            validateActive(internalTaskController.signal);\n          }\n        })\n      ));\n    } catch (listenerError) {\n      if (!(listenerError instanceof TaskAbortError)) {\n        safelyNotifyError(onError, listenerError, {\n          raisedBy: \"effect\"\n        });\n      }\n    } finally {\n      await Promise.all(autoJoinPromises);\n      abortControllerWithReason(internalTaskController, listenerCompleted);\n      entry.pending.delete(internalTaskController);\n    }\n  };\n  const clearListenerMiddleware = createClearListenerMiddleware(listenerMap);\n  const middleware = (api) => (next) => (action) => {\n    if (!(0,redux__WEBPACK_IMPORTED_MODULE_0__.isAction)(action)) {\n      return next(action);\n    }\n    if (addListener.match(action)) {\n      return startListening(action.payload);\n    }\n    if (clearAllListeners.match(action)) {\n      clearListenerMiddleware();\n      return;\n    }\n    if (removeListener.match(action)) {\n      return stopListening(action.payload);\n    }\n    let originalState = api.getState();\n    const getOriginalState = () => {\n      if (originalState === INTERNAL_NIL_TOKEN) {\n        throw new Error( false ? 0 : `${alm}: getOriginalState can only be called synchronously`);\n      }\n      return originalState;\n    };\n    let result;\n    try {\n      result = next(action);\n      if (listenerMap.size > 0) {\n        const currentState = api.getState();\n        const listenerEntries = Array.from(listenerMap.values());\n        for (const entry of listenerEntries) {\n          let runListener = false;\n          try {\n            runListener = entry.predicate(action, currentState, originalState);\n          } catch (predicateError) {\n            runListener = false;\n            safelyNotifyError(onError, predicateError, {\n              raisedBy: \"predicate\"\n            });\n          }\n          if (!runListener) {\n            continue;\n          }\n          notifyListener(entry, action, api, getOriginalState);\n        }\n      }\n    } finally {\n      originalState = INTERNAL_NIL_TOKEN;\n    }\n    return result;\n  };\n  return {\n    middleware,\n    startListening,\n    stopListening,\n    clearListeners: clearListenerMiddleware\n  };\n};\n\n// src/dynamicMiddleware/index.ts\n\nvar createMiddlewareEntry = (middleware) => ({\n  id: nanoid(),\n  middleware,\n  applied: /* @__PURE__ */ new Map()\n});\nvar matchInstance = (instanceId) => (action) => action?.meta?.instanceId === instanceId;\nvar createDynamicMiddleware = () => {\n  const instanceId = nanoid();\n  const middlewareMap = /* @__PURE__ */ new Map();\n  const withMiddleware = Object.assign(createAction(\"dynamicMiddleware/add\", (...middlewares) => ({\n    payload: middlewares,\n    meta: {\n      instanceId\n    }\n  })), {\n    withTypes: () => withMiddleware\n  });\n  const addMiddleware = Object.assign(function addMiddleware2(...middlewares) {\n    middlewares.forEach((middleware2) => {\n      let entry = find(Array.from(middlewareMap.values()), (entry2) => entry2.middleware === middleware2);\n      if (!entry) {\n        entry = createMiddlewareEntry(middleware2);\n      }\n      middlewareMap.set(entry.id, entry);\n    });\n  }, {\n    withTypes: () => addMiddleware\n  });\n  const getFinalMiddleware = (api) => {\n    const appliedMiddleware = Array.from(middlewareMap.values()).map((entry) => emplace(entry.applied, api, {\n      insert: () => entry.middleware(api)\n    }));\n    return (0,redux__WEBPACK_IMPORTED_MODULE_0__.compose)(...appliedMiddleware);\n  };\n  const isWithMiddleware = isAllOf(withMiddleware, matchInstance(instanceId));\n  const middleware = (api) => (next) => (action) => {\n    if (isWithMiddleware(action)) {\n      addMiddleware(...action.payload);\n      return api.dispatch;\n    }\n    return getFinalMiddleware(api)(next)(action);\n  };\n  return {\n    middleware,\n    addMiddleware,\n    withMiddleware,\n    instanceId\n  };\n};\n\n// src/combineSlices.ts\n\nvar isSliceLike = (maybeSliceLike) => \"reducerPath\" in maybeSliceLike && typeof maybeSliceLike.reducerPath === \"string\";\nvar getReducers = (slices) => slices.flatMap((sliceOrMap) => isSliceLike(sliceOrMap) ? [[sliceOrMap.reducerPath, sliceOrMap.reducer]] : Object.entries(sliceOrMap));\nvar ORIGINAL_STATE = Symbol.for(\"rtk-state-proxy-original\");\nvar isStateProxy = (value) => !!value && !!value[ORIGINAL_STATE];\nvar stateProxyMap = /* @__PURE__ */ new WeakMap();\nvar createStateProxy = (state, reducerMap) => emplace(stateProxyMap, state, {\n  insert: () => new Proxy(state, {\n    get: (target, prop, receiver) => {\n      if (prop === ORIGINAL_STATE)\n        return target;\n      const result = Reflect.get(target, prop, receiver);\n      if (typeof result === \"undefined\") {\n        const reducer = reducerMap[prop.toString()];\n        if (reducer) {\n          const reducerResult = reducer(void 0, {\n            type: nanoid()\n          });\n          if (typeof reducerResult === \"undefined\") {\n            throw new Error( false ? 0 : `The slice reducer for key \"${prop.toString()}\" returned undefined when called for selector(). If the state passed to the reducer is undefined, you must explicitly return the initial state. The initial state may not be undefined. If you don't want to set a value for this reducer, you can use null instead of undefined.`);\n          }\n          return reducerResult;\n        }\n      }\n      return result;\n    }\n  })\n});\nvar original = (state) => {\n  if (!isStateProxy(state)) {\n    throw new Error( false ? 0 : \"original must be used on state Proxy\");\n  }\n  return state[ORIGINAL_STATE];\n};\nvar noopReducer = (state = {}) => state;\nfunction combineSlices(...slices) {\n  const reducerMap = Object.fromEntries(getReducers(slices));\n  const getReducer = () => Object.keys(reducerMap).length ? (0,redux__WEBPACK_IMPORTED_MODULE_0__.combineReducers)(reducerMap) : noopReducer;\n  let reducer = getReducer();\n  function combinedReducer(state, action) {\n    return reducer(state, action);\n  }\n  combinedReducer.withLazyLoadedSlices = () => combinedReducer;\n  const inject = (slice, config = {}) => {\n    const {\n      reducerPath,\n      reducer: reducerToInject\n    } = slice;\n    const currentReducer = reducerMap[reducerPath];\n    if (!config.overrideExisting && currentReducer && currentReducer !== reducerToInject) {\n      if (typeof process !== \"undefined\" && \"development\" === \"development\") {\n        console.error(`called \\`inject\\` to override already-existing reducer ${reducerPath} without specifying \\`overrideExisting: true\\``);\n      }\n      return combinedReducer;\n    }\n    reducerMap[reducerPath] = reducerToInject;\n    reducer = getReducer();\n    return combinedReducer;\n  };\n  const selector = Object.assign(function makeSelector(selectorFn, selectState) {\n    return function selector2(state, ...args) {\n      return selectorFn(createStateProxy(selectState ? selectState(state, ...args) : state, reducerMap), ...args);\n    };\n  }, {\n    original\n  });\n  return Object.assign(combinedReducer, {\n    inject,\n    selector\n  });\n}\n\n// src/formatProdErrorMessage.ts\nfunction formatProdErrorMessage(code) {\n  return `Minified Redux Toolkit error #${code}; visit https://redux-toolkit.js.org/Errors?code=${code} for the full message or use the non-minified dev environment for full errors. `;\n}\n\n//# sourceMappingURL=redux-toolkit.modern.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcmVkdXhqcy90b29sa2l0L2Rpc3QvcmVkdXgtdG9vbGtpdC5tb2Rlcm4ubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNzQjtBQUNtRjtBQUNpQzs7QUFFMUk7QUFDeUM7QUFDd0I7QUFDakU7QUFDQSwwQkFBMEIsK0RBQXFCO0FBQy9DO0FBQ0E7QUFDQSx5REFBeUQsOENBQU8sVUFBVSw4Q0FBTztBQUNqRjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSw2REFBNkQsb0RBQWM7O0FBRTNFO0FBQzRIOztBQUU1SDtBQUNnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsMENBQU87QUFDbEIsU0FBUywwQ0FBTztBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDMEU7O0FBRTFFO0FBQ2lDOztBQUVqQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsTUFBcUMsR0FBRyxDQUF5QjtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsS0FBSztBQUN6QztBQUNBLG9DQUFvQywrQ0FBUTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsK0NBQVE7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDhCQUE4QixLQUFLO0FBQ25DO0FBQ0Esa0RBQWtELGtCQUFrQjtBQUNwRSxrRkFBa0YsV0FBVyw4QkFBOEIsV0FBVztBQUN0STtBQUNBLDREQUE0RDtBQUM1RCxNQUFNLEtBQXFDLEVBQUUsRUFFMUM7QUFDSDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ2dFO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0Esd0JBQXdCLFFBQVEsT0FBTyxRQUFRLGtEQUFrRCxTQUFTO0FBQzFHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsa0RBQVcsUUFBUSw4Q0FBZTtBQUMzQyxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixNQUFxQyxHQUFHLENBQTBCO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0QsTUFBTSxLQUFxQyxFQUFFLEVBRTFDLENBQUM7QUFDSjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixNQUFxQyxHQUFHLENBQTBCLHFFQUFxRSxrQkFBa0I7QUFDckw7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLE1BQXFDLEdBQUcsQ0FBMEIsb0VBQW9FLGtCQUFrQixzREFBc0QsbUJBQW1CO0FBQzdQO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUM2RDtBQUM3RDtBQUNBO0FBQ0EsOEdBQThHLG9EQUFhO0FBQzNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFO0FBQ2hFLE1BQU0sS0FBcUMsRUFBRSxFQUUxQyxDQUFDO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFdBQVcsK0NBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxnR0FBZ0csUUFBUTtBQUN4RztBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsZ0dBQWdHLFFBQVE7QUFDeEcsMkRBQTJELFlBQVk7QUFDdkU7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDhDQUFlO0FBQzFDLE1BQU07QUFDTiwyQkFBMkIsOERBQWlCO0FBQzVDO0FBQ0E7QUFDQSxNQUFNLElBQXFDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsYUFBb0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJLFNBQVMsb0RBQWM7QUFDM0Isa0JBQWtCLHNEQUFlO0FBQ2pDLElBQUk7QUFDSixvQkFBb0IsTUFBcUMsR0FBRyxDQUF5QjtBQUNyRjtBQUNBO0FBQ0Esb0JBQW9CLE1BQXFDLEdBQUcsQ0FBeUI7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixNQUFxQyxHQUFHLENBQXlCO0FBQ3ZGO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixNQUFxQyxHQUFHLENBQXlCO0FBQ3JGO0FBQ0EscUJBQXFCLDBDQUFRO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSw2QkFBNkIsc0RBQWU7QUFDNUM7QUFDQTtBQUNBLG9CQUFvQixNQUFxQyxHQUFHLENBQXlCO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixNQUFxQyxHQUFHLENBQXlCO0FBQ3JGO0FBQ0E7QUFDQSxvQkFBb0IsTUFBcUMsR0FBRyxDQUF5QjtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxrREFBVztBQUNwQjs7QUFFQTtBQUNzRzs7QUFFdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLElBQXFDO0FBQy9DO0FBQ0EsMEJBQTBCLE1BQXFDLEdBQUcsQ0FBMEI7QUFDNUY7QUFDQTtBQUNBLDBCQUEwQixNQUFxQyxHQUFHLENBQTBCO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLE1BQXFDLEdBQUcsQ0FBMEI7QUFDMUY7QUFDQTtBQUNBLHdCQUF3QixNQUFxQyxHQUFHLENBQTBCLHVGQUF1RixLQUFLO0FBQ3RMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLFVBQVUsSUFBcUM7QUFDL0M7QUFDQSwwQkFBMEIsTUFBcUMsR0FBRyxDQUEwQjtBQUM1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0EsVUFBVSxJQUFxQztBQUMvQztBQUNBLDBCQUEwQixNQUFxQyxHQUFHLENBQTBCO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxJQUFxQztBQUMzQztBQUNBLHNCQUFzQixNQUFxQyxHQUFHLENBQXlCO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksOENBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxVQUFVLGtEQUFZO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsTUFBcUMsR0FBRyxDQUF5QjtBQUM3RjtBQUNBO0FBQ0EsVUFBVTtBQUNWLGlCQUFpQiw4Q0FBZ0I7QUFDakM7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLG1CQUFtQjtBQUNwQjtBQUNBLFlBQVksTUFBTSxHQUFHLFVBQVU7QUFDL0I7QUFDQTtBQUNBO0FBQ0EsRUFBRSxJQUFJO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLHNCQUFzQixNQUFxQyxHQUFHLENBQTBCO0FBQ3hGO0FBQ0EsZUFBZSxPQUFPLG9CQUFvQixhQUFvQjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQyxpQ0FBaUM7QUFDakMsd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixNQUFxQyxHQUFHLENBQTBCO0FBQzVGO0FBQ0E7QUFDQSwwQkFBMEIsTUFBcUMsR0FBRyxDQUEwQjtBQUM1RjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLFVBQVUsSUFBcUM7QUFDL0M7QUFDQSwwQkFBMEIsTUFBcUMsR0FBRyxDQUEwQjtBQUM1RjtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksU0FBUyxJQUFxQztBQUMxRCw0QkFBNEIsTUFBcUMsR0FBRyxDQUEwQjtBQUM5RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxrRkFBa0Y7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxJQUFJO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxTQUFTLElBQXFDO0FBQ3RELHdCQUF3QixNQUFxQyxHQUFHLENBQTBCO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsTUFBcUMsR0FBRyxDQUEwQjtBQUN4RjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxvQkFBb0IsTUFBcUMsR0FBRyxDQUEwQiwwRkFBMEYsWUFBWSxpQ0FBaUM7QUFDN047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDeUU7QUFDekUsbUJBQW1CLDBDQUFRO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDhDQUFnQjtBQUMzQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sS0FBcUM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDhCQUE4QjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUM4Qzs7QUFFOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixVQUFVO0FBQ3RDLDRCQUE0QixVQUFVO0FBQ3RDLDJCQUEyQixTQUFTLEdBQUcsVUFBVTtBQUNqRCwyQkFBMkIsU0FBUyxHQUFHLFVBQVU7QUFDakQ7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLE1BQU0sRUFBRSxXQUFXLFdBQVcsS0FBSztBQUN6RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsTUFBcUMsR0FBRyxDQUEwQixNQUFNLFVBQVU7QUFDdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKLElBQUk7QUFDSixvQkFBb0IsTUFBcUMsR0FBRyxDQUEwQjtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLE1BQXFDLEdBQUcsQ0FBMEI7QUFDeEY7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxnREFBZ0QsSUFBSTtBQUNwRDtBQUNBLENBQUM7QUFDRCx3Q0FBd0MsSUFBSTtBQUM1QyxtREFBbUQsSUFBSTtBQUN2RDtBQUNBLENBQUM7QUFDRDtBQUNBLG1CQUFtQixJQUFJO0FBQ3ZCO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsK0NBQVM7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLE1BQXFDLEdBQUcsQ0FBMEIsTUFBTSxJQUFJO0FBQ3BHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQzRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLFdBQVcsOENBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDNEQ7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSw0QkFBNEIsTUFBcUMsR0FBRyxDQUEwQixpQ0FBaUMsZ0JBQWdCO0FBQy9JO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBLG9CQUFvQixNQUFxQyxHQUFHLENBQTBCO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsNERBQTRELHNEQUFnQjtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsaUJBQWlCLE9BQU8sb0JBQW9CLGFBQW9CO0FBQ2hFLGdGQUFnRixhQUFhO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSwwQ0FBMEMsT0FBTyxpREFBaUQsTUFBTTtBQUN4RztBQW9ERTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AcmVkdXhqcy90b29sa2l0L2Rpc3QvcmVkdXgtdG9vbGtpdC5tb2Rlcm4ubWpzPzczNWUiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL2luZGV4LnRzXG5leHBvcnQgKiBmcm9tIFwicmVkdXhcIjtcbmltcG9ydCB7IHByb2R1Y2UsIGN1cnJlbnQgYXMgY3VycmVudDIsIGZyZWV6ZSwgb3JpZ2luYWwgYXMgb3JpZ2luYWwyLCBpc0RyYWZ0IGFzIGlzRHJhZnQ0IH0gZnJvbSBcImltbWVyXCI7XG5pbXBvcnQgeyBjcmVhdGVTZWxlY3RvciwgY3JlYXRlU2VsZWN0b3JDcmVhdG9yIGFzIGNyZWF0ZVNlbGVjdG9yQ3JlYXRvcjIsIGxydU1lbW9pemUsIHdlYWtNYXBNZW1vaXplIGFzIHdlYWtNYXBNZW1vaXplMiB9IGZyb20gXCJyZXNlbGVjdFwiO1xuXG4vLyBzcmMvY3JlYXRlRHJhZnRTYWZlU2VsZWN0b3IudHNcbmltcG9ydCB7IGN1cnJlbnQsIGlzRHJhZnQgfSBmcm9tIFwiaW1tZXJcIjtcbmltcG9ydCB7IGNyZWF0ZVNlbGVjdG9yQ3JlYXRvciwgd2Vha01hcE1lbW9pemUgfSBmcm9tIFwicmVzZWxlY3RcIjtcbnZhciBjcmVhdGVEcmFmdFNhZmVTZWxlY3RvckNyZWF0b3IgPSAoLi4uYXJncykgPT4ge1xuICBjb25zdCBjcmVhdGVTZWxlY3RvcjIgPSBjcmVhdGVTZWxlY3RvckNyZWF0b3IoLi4uYXJncyk7XG4gIGNvbnN0IGNyZWF0ZURyYWZ0U2FmZVNlbGVjdG9yMiA9IE9iamVjdC5hc3NpZ24oKC4uLmFyZ3MyKSA9PiB7XG4gICAgY29uc3Qgc2VsZWN0b3IgPSBjcmVhdGVTZWxlY3RvcjIoLi4uYXJnczIpO1xuICAgIGNvbnN0IHdyYXBwZWRTZWxlY3RvciA9ICh2YWx1ZSwgLi4ucmVzdCkgPT4gc2VsZWN0b3IoaXNEcmFmdCh2YWx1ZSkgPyBjdXJyZW50KHZhbHVlKSA6IHZhbHVlLCAuLi5yZXN0KTtcbiAgICBPYmplY3QuYXNzaWduKHdyYXBwZWRTZWxlY3Rvciwgc2VsZWN0b3IpO1xuICAgIHJldHVybiB3cmFwcGVkU2VsZWN0b3I7XG4gIH0sIHtcbiAgICB3aXRoVHlwZXM6ICgpID0+IGNyZWF0ZURyYWZ0U2FmZVNlbGVjdG9yMlxuICB9KTtcbiAgcmV0dXJuIGNyZWF0ZURyYWZ0U2FmZVNlbGVjdG9yMjtcbn07XG52YXIgY3JlYXRlRHJhZnRTYWZlU2VsZWN0b3IgPSBjcmVhdGVEcmFmdFNhZmVTZWxlY3RvckNyZWF0b3Iod2Vha01hcE1lbW9pemUpO1xuXG4vLyBzcmMvY29uZmlndXJlU3RvcmUudHNcbmltcG9ydCB7IGFwcGx5TWlkZGxld2FyZSwgY3JlYXRlU3RvcmUsIGNvbXBvc2UgYXMgY29tcG9zZTIsIGNvbWJpbmVSZWR1Y2VycywgaXNQbGFpbk9iamVjdCBhcyBpc1BsYWluT2JqZWN0MiB9IGZyb20gXCJyZWR1eFwiO1xuXG4vLyBzcmMvZGV2dG9vbHNFeHRlbnNpb24udHNcbmltcG9ydCB7IGNvbXBvc2UgfSBmcm9tIFwicmVkdXhcIjtcbnZhciBjb21wb3NlV2l0aERldlRvb2xzID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cuX19SRURVWF9ERVZUT09MU19FWFRFTlNJT05fQ09NUE9TRV9fID8gd2luZG93Ll9fUkVEVVhfREVWVE9PTFNfRVhURU5TSU9OX0NPTVBPU0VfXyA6IGZ1bmN0aW9uKCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMClcbiAgICByZXR1cm4gdm9pZCAwO1xuICBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gXCJvYmplY3RcIilcbiAgICByZXR1cm4gY29tcG9zZTtcbiAgcmV0dXJuIGNvbXBvc2UuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG52YXIgZGV2VG9vbHNFbmhhbmNlciA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93Ll9fUkVEVVhfREVWVE9PTFNfRVhURU5TSU9OX18gPyB3aW5kb3cuX19SRURVWF9ERVZUT09MU19FWFRFTlNJT05fXyA6IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gZnVuY3Rpb24obm9vcDMpIHtcbiAgICByZXR1cm4gbm9vcDM7XG4gIH07XG59O1xuXG4vLyBzcmMvZ2V0RGVmYXVsdE1pZGRsZXdhcmUudHNcbmltcG9ydCB7IHRodW5rIGFzIHRodW5rTWlkZGxld2FyZSwgd2l0aEV4dHJhQXJndW1lbnQgfSBmcm9tIFwicmVkdXgtdGh1bmtcIjtcblxuLy8gc3JjL2NyZWF0ZUFjdGlvbi50c1xuaW1wb3J0IHsgaXNBY3Rpb24gfSBmcm9tIFwicmVkdXhcIjtcblxuLy8gc3JjL3RzSGVscGVycy50c1xudmFyIGhhc01hdGNoRnVuY3Rpb24gPSAodikgPT4ge1xuICByZXR1cm4gdiAmJiB0eXBlb2Ygdi5tYXRjaCA9PT0gXCJmdW5jdGlvblwiO1xufTtcblxuLy8gc3JjL2NyZWF0ZUFjdGlvbi50c1xuZnVuY3Rpb24gY3JlYXRlQWN0aW9uKHR5cGUsIHByZXBhcmVBY3Rpb24pIHtcbiAgZnVuY3Rpb24gYWN0aW9uQ3JlYXRvciguLi5hcmdzKSB7XG4gICAgaWYgKHByZXBhcmVBY3Rpb24pIHtcbiAgICAgIGxldCBwcmVwYXJlZCA9IHByZXBhcmVBY3Rpb24oLi4uYXJncyk7XG4gICAgICBpZiAoIXByZXBhcmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDApIDogXCJwcmVwYXJlQWN0aW9uIGRpZCBub3QgcmV0dXJuIGFuIG9iamVjdFwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGUsXG4gICAgICAgIHBheWxvYWQ6IHByZXBhcmVkLnBheWxvYWQsXG4gICAgICAgIC4uLlwibWV0YVwiIGluIHByZXBhcmVkICYmIHtcbiAgICAgICAgICBtZXRhOiBwcmVwYXJlZC5tZXRhXG4gICAgICAgIH0sXG4gICAgICAgIC4uLlwiZXJyb3JcIiBpbiBwcmVwYXJlZCAmJiB7XG4gICAgICAgICAgZXJyb3I6IHByZXBhcmVkLmVycm9yXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlLFxuICAgICAgcGF5bG9hZDogYXJnc1swXVxuICAgIH07XG4gIH1cbiAgYWN0aW9uQ3JlYXRvci50b1N0cmluZyA9ICgpID0+IGAke3R5cGV9YDtcbiAgYWN0aW9uQ3JlYXRvci50eXBlID0gdHlwZTtcbiAgYWN0aW9uQ3JlYXRvci5tYXRjaCA9IChhY3Rpb24pID0+IGlzQWN0aW9uKGFjdGlvbikgJiYgYWN0aW9uLnR5cGUgPT09IHR5cGU7XG4gIHJldHVybiBhY3Rpb25DcmVhdG9yO1xufVxuZnVuY3Rpb24gaXNBY3Rpb25DcmVhdG9yKGFjdGlvbikge1xuICByZXR1cm4gdHlwZW9mIGFjdGlvbiA9PT0gXCJmdW5jdGlvblwiICYmIFwidHlwZVwiIGluIGFjdGlvbiAmJiAvLyBoYXNNYXRjaEZ1bmN0aW9uIG9ubHkgd2FudHMgTWF0Y2hlcnMgYnV0IEkgZG9uJ3Qgc2VlIHRoZSBwb2ludCBpbiByZXdyaXRpbmcgaXRcbiAgaGFzTWF0Y2hGdW5jdGlvbihhY3Rpb24pO1xufVxuZnVuY3Rpb24gaXNGU0EoYWN0aW9uKSB7XG4gIHJldHVybiBpc0FjdGlvbihhY3Rpb24pICYmIE9iamVjdC5rZXlzKGFjdGlvbikuZXZlcnkoaXNWYWxpZEtleSk7XG59XG5mdW5jdGlvbiBpc1ZhbGlkS2V5KGtleSkge1xuICByZXR1cm4gW1widHlwZVwiLCBcInBheWxvYWRcIiwgXCJlcnJvclwiLCBcIm1ldGFcIl0uaW5kZXhPZihrZXkpID4gLTE7XG59XG5cbi8vIHNyYy9hY3Rpb25DcmVhdG9ySW52YXJpYW50TWlkZGxld2FyZS50c1xuZnVuY3Rpb24gZ2V0TWVzc2FnZSh0eXBlKSB7XG4gIGNvbnN0IHNwbGl0VHlwZSA9IHR5cGUgPyBgJHt0eXBlfWAuc3BsaXQoXCIvXCIpIDogW107XG4gIGNvbnN0IGFjdGlvbk5hbWUgPSBzcGxpdFR5cGVbc3BsaXRUeXBlLmxlbmd0aCAtIDFdIHx8IFwiYWN0aW9uQ3JlYXRvclwiO1xuICByZXR1cm4gYERldGVjdGVkIGFuIGFjdGlvbiBjcmVhdG9yIHdpdGggdHlwZSBcIiR7dHlwZSB8fCBcInVua25vd25cIn1cIiBiZWluZyBkaXNwYXRjaGVkLiBcbk1ha2Ugc3VyZSB5b3UncmUgY2FsbGluZyB0aGUgYWN0aW9uIGNyZWF0b3IgYmVmb3JlIGRpc3BhdGNoaW5nLCBpLmUuIFxcYGRpc3BhdGNoKCR7YWN0aW9uTmFtZX0oKSlcXGAgaW5zdGVhZCBvZiBcXGBkaXNwYXRjaCgke2FjdGlvbk5hbWV9KVxcYC4gVGhpcyBpcyBuZWNlc3NhcnkgZXZlbiBpZiB0aGUgYWN0aW9uIGhhcyBubyBwYXlsb2FkLmA7XG59XG5mdW5jdGlvbiBjcmVhdGVBY3Rpb25DcmVhdG9ySW52YXJpYW50TWlkZGxld2FyZShvcHRpb25zID0ge30pIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIikge1xuICAgIHJldHVybiAoKSA9PiAobmV4dCkgPT4gKGFjdGlvbikgPT4gbmV4dChhY3Rpb24pO1xuICB9XG4gIGNvbnN0IHtcbiAgICBpc0FjdGlvbkNyZWF0b3I6IGlzQWN0aW9uQ3JlYXRvcjIgPSBpc0FjdGlvbkNyZWF0b3JcbiAgfSA9IG9wdGlvbnM7XG4gIHJldHVybiAoKSA9PiAobmV4dCkgPT4gKGFjdGlvbikgPT4ge1xuICAgIGlmIChpc0FjdGlvbkNyZWF0b3IyKGFjdGlvbikpIHtcbiAgICAgIGNvbnNvbGUud2FybihnZXRNZXNzYWdlKGFjdGlvbi50eXBlKSk7XG4gICAgfVxuICAgIHJldHVybiBuZXh0KGFjdGlvbik7XG4gIH07XG59XG5cbi8vIHNyYy91dGlscy50c1xuaW1wb3J0IHsgcHJvZHVjZSBhcyBjcmVhdGVOZXh0U3RhdGUsIGlzRHJhZnRhYmxlIH0gZnJvbSBcImltbWVyXCI7XG5mdW5jdGlvbiBnZXRUaW1lTWVhc3VyZVV0aWxzKG1heERlbGF5LCBmbk5hbWUpIHtcbiAgbGV0IGVsYXBzZWQgPSAwO1xuICByZXR1cm4ge1xuICAgIG1lYXN1cmVUaW1lKGZuKSB7XG4gICAgICBjb25zdCBzdGFydGVkID0gRGF0ZS5ub3coKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBmbigpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgY29uc3QgZmluaXNoZWQgPSBEYXRlLm5vdygpO1xuICAgICAgICBlbGFwc2VkICs9IGZpbmlzaGVkIC0gc3RhcnRlZDtcbiAgICAgIH1cbiAgICB9LFxuICAgIHdhcm5JZkV4Y2VlZGVkKCkge1xuICAgICAgaWYgKGVsYXBzZWQgPiBtYXhEZWxheSkge1xuICAgICAgICBjb25zb2xlLndhcm4oYCR7Zm5OYW1lfSB0b29rICR7ZWxhcHNlZH1tcywgd2hpY2ggaXMgbW9yZSB0aGFuIHRoZSB3YXJuaW5nIHRocmVzaG9sZCBvZiAke21heERlbGF5fW1zLiBcbklmIHlvdXIgc3RhdGUgb3IgYWN0aW9ucyBhcmUgdmVyeSBsYXJnZSwgeW91IG1heSB3YW50IHRvIGRpc2FibGUgdGhlIG1pZGRsZXdhcmUgYXMgaXQgbWlnaHQgY2F1c2UgdG9vIG11Y2ggb2YgYSBzbG93ZG93biBpbiBkZXZlbG9wbWVudCBtb2RlLiBTZWUgaHR0cHM6Ly9yZWR1eC10b29sa2l0LmpzLm9yZy9hcGkvZ2V0RGVmYXVsdE1pZGRsZXdhcmUgZm9yIGluc3RydWN0aW9ucy5cbkl0IGlzIGRpc2FibGVkIGluIHByb2R1Y3Rpb24gYnVpbGRzLCBzbyB5b3UgZG9uJ3QgbmVlZCB0byB3b3JyeSBhYm91dCB0aGF0LmApO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGZpbmQoaXRlcmFibGUsIGNvbXBhcmF0b3IpIHtcbiAgZm9yIChjb25zdCBlbnRyeSBvZiBpdGVyYWJsZSkge1xuICAgIGlmIChjb21wYXJhdG9yKGVudHJ5KSkge1xuICAgICAgcmV0dXJuIGVudHJ5O1xuICAgIH1cbiAgfVxuICByZXR1cm4gdm9pZCAwO1xufVxudmFyIFR1cGxlID0gY2xhc3MgX1R1cGxlIGV4dGVuZHMgQXJyYXkge1xuICBjb25zdHJ1Y3RvciguLi5pdGVtcykge1xuICAgIHN1cGVyKC4uLml0ZW1zKTtcbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgX1R1cGxlLnByb3RvdHlwZSk7XG4gIH1cbiAgc3RhdGljIGdldCBbU3ltYm9sLnNwZWNpZXNdKCkge1xuICAgIHJldHVybiBfVHVwbGU7XG4gIH1cbiAgY29uY2F0KC4uLmFycikge1xuICAgIHJldHVybiBzdXBlci5jb25jYXQuYXBwbHkodGhpcywgYXJyKTtcbiAgfVxuICBwcmVwZW5kKC4uLmFycikge1xuICAgIGlmIChhcnIubGVuZ3RoID09PSAxICYmIEFycmF5LmlzQXJyYXkoYXJyWzBdKSkge1xuICAgICAgcmV0dXJuIG5ldyBfVHVwbGUoLi4uYXJyWzBdLmNvbmNhdCh0aGlzKSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgX1R1cGxlKC4uLmFyci5jb25jYXQodGhpcykpO1xuICB9XG59O1xuZnVuY3Rpb24gZnJlZXplRHJhZnRhYmxlKHZhbCkge1xuICByZXR1cm4gaXNEcmFmdGFibGUodmFsKSA/IGNyZWF0ZU5leHRTdGF0ZSh2YWwsICgpID0+IHtcbiAgfSkgOiB2YWw7XG59XG5mdW5jdGlvbiBlbXBsYWNlKG1hcCwga2V5LCBoYW5kbGVyKSB7XG4gIGlmIChtYXAuaGFzKGtleSkpIHtcbiAgICBsZXQgdmFsdWUgPSBtYXAuZ2V0KGtleSk7XG4gICAgaWYgKGhhbmRsZXIudXBkYXRlKSB7XG4gICAgICB2YWx1ZSA9IGhhbmRsZXIudXBkYXRlKHZhbHVlLCBrZXksIG1hcCk7XG4gICAgICBtYXAuc2V0KGtleSwgdmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKCFoYW5kbGVyLmluc2VydClcbiAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgxMCkgOiBcIk5vIGluc2VydCBwcm92aWRlZCBmb3Iga2V5IG5vdCBhbHJlYWR5IGluIG1hcFwiKTtcbiAgY29uc3QgaW5zZXJ0ZWQgPSBoYW5kbGVyLmluc2VydChrZXksIG1hcCk7XG4gIG1hcC5zZXQoa2V5LCBpbnNlcnRlZCk7XG4gIHJldHVybiBpbnNlcnRlZDtcbn1cblxuLy8gc3JjL2ltbXV0YWJsZVN0YXRlSW52YXJpYW50TWlkZGxld2FyZS50c1xuZnVuY3Rpb24gaXNJbW11dGFibGVEZWZhdWx0KHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgfHwgdmFsdWUgPT0gbnVsbCB8fCBPYmplY3QuaXNGcm96ZW4odmFsdWUpO1xufVxuZnVuY3Rpb24gdHJhY2tGb3JNdXRhdGlvbnMoaXNJbW11dGFibGUsIGlnbm9yZVBhdGhzLCBvYmopIHtcbiAgY29uc3QgdHJhY2tlZFByb3BlcnRpZXMgPSB0cmFja1Byb3BlcnRpZXMoaXNJbW11dGFibGUsIGlnbm9yZVBhdGhzLCBvYmopO1xuICByZXR1cm4ge1xuICAgIGRldGVjdE11dGF0aW9ucygpIHtcbiAgICAgIHJldHVybiBkZXRlY3RNdXRhdGlvbnMoaXNJbW11dGFibGUsIGlnbm9yZVBhdGhzLCB0cmFja2VkUHJvcGVydGllcywgb2JqKTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiB0cmFja1Byb3BlcnRpZXMoaXNJbW11dGFibGUsIGlnbm9yZVBhdGhzID0gW10sIG9iaiwgcGF0aCA9IFwiXCIsIGNoZWNrZWRPYmplY3RzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSkge1xuICBjb25zdCB0cmFja2VkID0ge1xuICAgIHZhbHVlOiBvYmpcbiAgfTtcbiAgaWYgKCFpc0ltbXV0YWJsZShvYmopICYmICFjaGVja2VkT2JqZWN0cy5oYXMob2JqKSkge1xuICAgIGNoZWNrZWRPYmplY3RzLmFkZChvYmopO1xuICAgIHRyYWNrZWQuY2hpbGRyZW4gPSB7fTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBvYmopIHtcbiAgICAgIGNvbnN0IGNoaWxkUGF0aCA9IHBhdGggPyBwYXRoICsgXCIuXCIgKyBrZXkgOiBrZXk7XG4gICAgICBpZiAoaWdub3JlUGF0aHMubGVuZ3RoICYmIGlnbm9yZVBhdGhzLmluZGV4T2YoY2hpbGRQYXRoKSAhPT0gLTEpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB0cmFja2VkLmNoaWxkcmVuW2tleV0gPSB0cmFja1Byb3BlcnRpZXMoaXNJbW11dGFibGUsIGlnbm9yZVBhdGhzLCBvYmpba2V5XSwgY2hpbGRQYXRoKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRyYWNrZWQ7XG59XG5mdW5jdGlvbiBkZXRlY3RNdXRhdGlvbnMoaXNJbW11dGFibGUsIGlnbm9yZWRQYXRocyA9IFtdLCB0cmFja2VkUHJvcGVydHksIG9iaiwgc2FtZVBhcmVudFJlZiA9IGZhbHNlLCBwYXRoID0gXCJcIikge1xuICBjb25zdCBwcmV2T2JqID0gdHJhY2tlZFByb3BlcnR5ID8gdHJhY2tlZFByb3BlcnR5LnZhbHVlIDogdm9pZCAwO1xuICBjb25zdCBzYW1lUmVmID0gcHJldk9iaiA9PT0gb2JqO1xuICBpZiAoc2FtZVBhcmVudFJlZiAmJiAhc2FtZVJlZiAmJiAhTnVtYmVyLmlzTmFOKG9iaikpIHtcbiAgICByZXR1cm4ge1xuICAgICAgd2FzTXV0YXRlZDogdHJ1ZSxcbiAgICAgIHBhdGhcbiAgICB9O1xuICB9XG4gIGlmIChpc0ltbXV0YWJsZShwcmV2T2JqKSB8fCBpc0ltbXV0YWJsZShvYmopKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHdhc011dGF0ZWQ6IGZhbHNlXG4gICAgfTtcbiAgfVxuICBjb25zdCBrZXlzVG9EZXRlY3QgPSB7fTtcbiAgZm9yIChsZXQga2V5IGluIHRyYWNrZWRQcm9wZXJ0eS5jaGlsZHJlbikge1xuICAgIGtleXNUb0RldGVjdFtrZXldID0gdHJ1ZTtcbiAgfVxuICBmb3IgKGxldCBrZXkgaW4gb2JqKSB7XG4gICAga2V5c1RvRGV0ZWN0W2tleV0gPSB0cnVlO1xuICB9XG4gIGNvbnN0IGhhc0lnbm9yZWRQYXRocyA9IGlnbm9yZWRQYXRocy5sZW5ndGggPiAwO1xuICBmb3IgKGxldCBrZXkgaW4ga2V5c1RvRGV0ZWN0KSB7XG4gICAgY29uc3QgbmVzdGVkUGF0aCA9IHBhdGggPyBwYXRoICsgXCIuXCIgKyBrZXkgOiBrZXk7XG4gICAgaWYgKGhhc0lnbm9yZWRQYXRocykge1xuICAgICAgY29uc3QgaGFzTWF0Y2hlcyA9IGlnbm9yZWRQYXRocy5zb21lKChpZ25vcmVkKSA9PiB7XG4gICAgICAgIGlmIChpZ25vcmVkIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgICAgcmV0dXJuIGlnbm9yZWQudGVzdChuZXN0ZWRQYXRoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmVzdGVkUGF0aCA9PT0gaWdub3JlZDtcbiAgICAgIH0pO1xuICAgICAgaWYgKGhhc01hdGNoZXMpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IGRldGVjdE11dGF0aW9ucyhpc0ltbXV0YWJsZSwgaWdub3JlZFBhdGhzLCB0cmFja2VkUHJvcGVydHkuY2hpbGRyZW5ba2V5XSwgb2JqW2tleV0sIHNhbWVSZWYsIG5lc3RlZFBhdGgpO1xuICAgIGlmIChyZXN1bHQud2FzTXV0YXRlZCkge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB3YXNNdXRhdGVkOiBmYWxzZVxuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlSW1tdXRhYmxlU3RhdGVJbnZhcmlhbnRNaWRkbGV3YXJlKG9wdGlvbnMgPSB7fSkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgcmV0dXJuICgpID0+IChuZXh0KSA9PiAoYWN0aW9uKSA9PiBuZXh0KGFjdGlvbik7XG4gIH0gZWxzZSB7XG4gICAgbGV0IHN0cmluZ2lmeTIgPSBmdW5jdGlvbihvYmosIHNlcmlhbGl6ZXIsIGluZGVudCwgZGVjeWNsZXIpIHtcbiAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShvYmosIGdldFNlcmlhbGl6ZTIoc2VyaWFsaXplciwgZGVjeWNsZXIpLCBpbmRlbnQpO1xuICAgIH0sIGdldFNlcmlhbGl6ZTIgPSBmdW5jdGlvbihzZXJpYWxpemVyLCBkZWN5Y2xlcikge1xuICAgICAgbGV0IHN0YWNrID0gW10sIGtleXMgPSBbXTtcbiAgICAgIGlmICghZGVjeWNsZXIpXG4gICAgICAgIGRlY3ljbGVyID0gZnVuY3Rpb24oXywgdmFsdWUpIHtcbiAgICAgICAgICBpZiAoc3RhY2tbMF0gPT09IHZhbHVlKVxuICAgICAgICAgICAgcmV0dXJuIFwiW0NpcmN1bGFyIH5dXCI7XG4gICAgICAgICAgcmV0dXJuIFwiW0NpcmN1bGFyIH4uXCIgKyBrZXlzLnNsaWNlKDAsIHN0YWNrLmluZGV4T2YodmFsdWUpKS5qb2luKFwiLlwiKSArIFwiXVwiO1xuICAgICAgICB9O1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB2YXIgdGhpc1BvcyA9IHN0YWNrLmluZGV4T2YodGhpcyk7XG4gICAgICAgICAgfnRoaXNQb3MgPyBzdGFjay5zcGxpY2UodGhpc1BvcyArIDEpIDogc3RhY2sucHVzaCh0aGlzKTtcbiAgICAgICAgICB+dGhpc1BvcyA/IGtleXMuc3BsaWNlKHRoaXNQb3MsIEluZmluaXR5LCBrZXkpIDoga2V5cy5wdXNoKGtleSk7XG4gICAgICAgICAgaWYgKH5zdGFjay5pbmRleE9mKHZhbHVlKSlcbiAgICAgICAgICAgIHZhbHVlID0gZGVjeWNsZXIuY2FsbCh0aGlzLCBrZXksIHZhbHVlKTtcbiAgICAgICAgfSBlbHNlXG4gICAgICAgICAgc3RhY2sucHVzaCh2YWx1ZSk7XG4gICAgICAgIHJldHVybiBzZXJpYWxpemVyID09IG51bGwgPyB2YWx1ZSA6IHNlcmlhbGl6ZXIuY2FsbCh0aGlzLCBrZXksIHZhbHVlKTtcbiAgICAgIH07XG4gICAgfTtcbiAgICB2YXIgc3RyaW5naWZ5ID0gc3RyaW5naWZ5MiwgZ2V0U2VyaWFsaXplID0gZ2V0U2VyaWFsaXplMjtcbiAgICBsZXQge1xuICAgICAgaXNJbW11dGFibGUgPSBpc0ltbXV0YWJsZURlZmF1bHQsXG4gICAgICBpZ25vcmVkUGF0aHMsXG4gICAgICB3YXJuQWZ0ZXIgPSAzMlxuICAgIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IHRyYWNrID0gdHJhY2tGb3JNdXRhdGlvbnMuYmluZChudWxsLCBpc0ltbXV0YWJsZSwgaWdub3JlZFBhdGhzKTtcbiAgICByZXR1cm4gKHtcbiAgICAgIGdldFN0YXRlXG4gICAgfSkgPT4ge1xuICAgICAgbGV0IHN0YXRlID0gZ2V0U3RhdGUoKTtcbiAgICAgIGxldCB0cmFja2VyID0gdHJhY2soc3RhdGUpO1xuICAgICAgbGV0IHJlc3VsdDtcbiAgICAgIHJldHVybiAobmV4dCkgPT4gKGFjdGlvbikgPT4ge1xuICAgICAgICBjb25zdCBtZWFzdXJlVXRpbHMgPSBnZXRUaW1lTWVhc3VyZVV0aWxzKHdhcm5BZnRlciwgXCJJbW11dGFibGVTdGF0ZUludmFyaWFudE1pZGRsZXdhcmVcIik7XG4gICAgICAgIG1lYXN1cmVVdGlscy5tZWFzdXJlVGltZSgoKSA9PiB7XG4gICAgICAgICAgc3RhdGUgPSBnZXRTdGF0ZSgpO1xuICAgICAgICAgIHJlc3VsdCA9IHRyYWNrZXIuZGV0ZWN0TXV0YXRpb25zKCk7XG4gICAgICAgICAgdHJhY2tlciA9IHRyYWNrKHN0YXRlKTtcbiAgICAgICAgICBpZiAocmVzdWx0Lndhc011dGF0ZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDE5KSA6IGBBIHN0YXRlIG11dGF0aW9uIHdhcyBkZXRlY3RlZCBiZXR3ZWVuIGRpc3BhdGNoZXMsIGluIHRoZSBwYXRoICcke3Jlc3VsdC5wYXRoIHx8IFwiXCJ9Jy4gIFRoaXMgbWF5IGNhdXNlIGluY29ycmVjdCBiZWhhdmlvci4gKGh0dHBzOi8vcmVkdXguanMub3JnL3N0eWxlLWd1aWRlL3N0eWxlLWd1aWRlI2RvLW5vdC1tdXRhdGUtc3RhdGUpYCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgZGlzcGF0Y2hlZEFjdGlvbiA9IG5leHQoYWN0aW9uKTtcbiAgICAgICAgbWVhc3VyZVV0aWxzLm1lYXN1cmVUaW1lKCgpID0+IHtcbiAgICAgICAgICBzdGF0ZSA9IGdldFN0YXRlKCk7XG4gICAgICAgICAgcmVzdWx0ID0gdHJhY2tlci5kZXRlY3RNdXRhdGlvbnMoKTtcbiAgICAgICAgICB0cmFja2VyID0gdHJhY2soc3RhdGUpO1xuICAgICAgICAgIGlmIChyZXN1bHQud2FzTXV0YXRlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMjApIDogYEEgc3RhdGUgbXV0YXRpb24gd2FzIGRldGVjdGVkIGluc2lkZSBhIGRpc3BhdGNoLCBpbiB0aGUgcGF0aDogJHtyZXN1bHQucGF0aCB8fCBcIlwifS4gVGFrZSBhIGxvb2sgYXQgdGhlIHJlZHVjZXIocykgaGFuZGxpbmcgdGhlIGFjdGlvbiAke3N0cmluZ2lmeTIoYWN0aW9uKX0uIChodHRwczovL3JlZHV4LmpzLm9yZy9zdHlsZS1ndWlkZS9zdHlsZS1ndWlkZSNkby1ub3QtbXV0YXRlLXN0YXRlKWApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIG1lYXN1cmVVdGlscy53YXJuSWZFeGNlZWRlZCgpO1xuICAgICAgICByZXR1cm4gZGlzcGF0Y2hlZEFjdGlvbjtcbiAgICAgIH07XG4gICAgfTtcbiAgfVxufVxuXG4vLyBzcmMvc2VyaWFsaXphYmxlU3RhdGVJbnZhcmlhbnRNaWRkbGV3YXJlLnRzXG5pbXBvcnQgeyBpc0FjdGlvbiBhcyBpc0FjdGlvbjIsIGlzUGxhaW5PYmplY3QgfSBmcm9tIFwicmVkdXhcIjtcbmZ1bmN0aW9uIGlzUGxhaW4odmFsKSB7XG4gIGNvbnN0IHR5cGUgPSB0eXBlb2YgdmFsO1xuICByZXR1cm4gdmFsID09IG51bGwgfHwgdHlwZSA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlID09PSBcImJvb2xlYW5cIiB8fCB0eXBlID09PSBcIm51bWJlclwiIHx8IEFycmF5LmlzQXJyYXkodmFsKSB8fCBpc1BsYWluT2JqZWN0KHZhbCk7XG59XG5mdW5jdGlvbiBmaW5kTm9uU2VyaWFsaXphYmxlVmFsdWUodmFsdWUsIHBhdGggPSBcIlwiLCBpc1NlcmlhbGl6YWJsZSA9IGlzUGxhaW4sIGdldEVudHJpZXMsIGlnbm9yZWRQYXRocyA9IFtdLCBjYWNoZSkge1xuICBsZXQgZm91bmROZXN0ZWRTZXJpYWxpemFibGU7XG4gIGlmICghaXNTZXJpYWxpemFibGUodmFsdWUpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGtleVBhdGg6IHBhdGggfHwgXCI8cm9vdD5cIixcbiAgICAgIHZhbHVlXG4gICAgfTtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiIHx8IHZhbHVlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChjYWNoZT8uaGFzKHZhbHVlKSlcbiAgICByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IGVudHJpZXMgPSBnZXRFbnRyaWVzICE9IG51bGwgPyBnZXRFbnRyaWVzKHZhbHVlKSA6IE9iamVjdC5lbnRyaWVzKHZhbHVlKTtcbiAgY29uc3QgaGFzSWdub3JlZFBhdGhzID0gaWdub3JlZFBhdGhzLmxlbmd0aCA+IDA7XG4gIGZvciAoY29uc3QgW2tleSwgbmVzdGVkVmFsdWVdIG9mIGVudHJpZXMpIHtcbiAgICBjb25zdCBuZXN0ZWRQYXRoID0gcGF0aCA/IHBhdGggKyBcIi5cIiArIGtleSA6IGtleTtcbiAgICBpZiAoaGFzSWdub3JlZFBhdGhzKSB7XG4gICAgICBjb25zdCBoYXNNYXRjaGVzID0gaWdub3JlZFBhdGhzLnNvbWUoKGlnbm9yZWQpID0+IHtcbiAgICAgICAgaWYgKGlnbm9yZWQgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgICByZXR1cm4gaWdub3JlZC50ZXN0KG5lc3RlZFBhdGgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXN0ZWRQYXRoID09PSBpZ25vcmVkO1xuICAgICAgfSk7XG4gICAgICBpZiAoaGFzTWF0Y2hlcykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFpc1NlcmlhbGl6YWJsZShuZXN0ZWRWYWx1ZSkpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGtleVBhdGg6IG5lc3RlZFBhdGgsXG4gICAgICAgIHZhbHVlOiBuZXN0ZWRWYWx1ZVxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBuZXN0ZWRWYWx1ZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgZm91bmROZXN0ZWRTZXJpYWxpemFibGUgPSBmaW5kTm9uU2VyaWFsaXphYmxlVmFsdWUobmVzdGVkVmFsdWUsIG5lc3RlZFBhdGgsIGlzU2VyaWFsaXphYmxlLCBnZXRFbnRyaWVzLCBpZ25vcmVkUGF0aHMsIGNhY2hlKTtcbiAgICAgIGlmIChmb3VuZE5lc3RlZFNlcmlhbGl6YWJsZSkge1xuICAgICAgICByZXR1cm4gZm91bmROZXN0ZWRTZXJpYWxpemFibGU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChjYWNoZSAmJiBpc05lc3RlZEZyb3plbih2YWx1ZSkpXG4gICAgY2FjaGUuYWRkKHZhbHVlKTtcbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gaXNOZXN0ZWRGcm96ZW4odmFsdWUpIHtcbiAgaWYgKCFPYmplY3QuaXNGcm96ZW4odmFsdWUpKVxuICAgIHJldHVybiBmYWxzZTtcbiAgZm9yIChjb25zdCBuZXN0ZWRWYWx1ZSBvZiBPYmplY3QudmFsdWVzKHZhbHVlKSkge1xuICAgIGlmICh0eXBlb2YgbmVzdGVkVmFsdWUgIT09IFwib2JqZWN0XCIgfHwgbmVzdGVkVmFsdWUgPT09IG51bGwpXG4gICAgICBjb250aW51ZTtcbiAgICBpZiAoIWlzTmVzdGVkRnJvemVuKG5lc3RlZFZhbHVlKSlcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVNlcmlhbGl6YWJsZVN0YXRlSW52YXJpYW50TWlkZGxld2FyZShvcHRpb25zID0ge30pIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIikge1xuICAgIHJldHVybiAoKSA9PiAobmV4dCkgPT4gKGFjdGlvbikgPT4gbmV4dChhY3Rpb24pO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IHtcbiAgICAgIGlzU2VyaWFsaXphYmxlID0gaXNQbGFpbixcbiAgICAgIGdldEVudHJpZXMsXG4gICAgICBpZ25vcmVkQWN0aW9ucyA9IFtdLFxuICAgICAgaWdub3JlZEFjdGlvblBhdGhzID0gW1wibWV0YS5hcmdcIiwgXCJtZXRhLmJhc2VRdWVyeU1ldGFcIl0sXG4gICAgICBpZ25vcmVkUGF0aHMgPSBbXSxcbiAgICAgIHdhcm5BZnRlciA9IDMyLFxuICAgICAgaWdub3JlU3RhdGUgPSBmYWxzZSxcbiAgICAgIGlnbm9yZUFjdGlvbnMgPSBmYWxzZSxcbiAgICAgIGRpc2FibGVDYWNoZSA9IGZhbHNlXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgY2FjaGUgPSAhZGlzYWJsZUNhY2hlICYmIFdlYWtTZXQgPyAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtTZXQoKSA6IHZvaWQgMDtcbiAgICByZXR1cm4gKHN0b3JlQVBJKSA9PiAobmV4dCkgPT4gKGFjdGlvbikgPT4ge1xuICAgICAgaWYgKCFpc0FjdGlvbjIoYWN0aW9uKSkge1xuICAgICAgICByZXR1cm4gbmV4dChhY3Rpb24pO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVzdWx0ID0gbmV4dChhY3Rpb24pO1xuICAgICAgY29uc3QgbWVhc3VyZVV0aWxzID0gZ2V0VGltZU1lYXN1cmVVdGlscyh3YXJuQWZ0ZXIsIFwiU2VyaWFsaXphYmxlU3RhdGVJbnZhcmlhbnRNaWRkbGV3YXJlXCIpO1xuICAgICAgaWYgKCFpZ25vcmVBY3Rpb25zICYmICEoaWdub3JlZEFjdGlvbnMubGVuZ3RoICYmIGlnbm9yZWRBY3Rpb25zLmluZGV4T2YoYWN0aW9uLnR5cGUpICE9PSAtMSkpIHtcbiAgICAgICAgbWVhc3VyZVV0aWxzLm1lYXN1cmVUaW1lKCgpID0+IHtcbiAgICAgICAgICBjb25zdCBmb3VuZEFjdGlvbk5vblNlcmlhbGl6YWJsZVZhbHVlID0gZmluZE5vblNlcmlhbGl6YWJsZVZhbHVlKGFjdGlvbiwgXCJcIiwgaXNTZXJpYWxpemFibGUsIGdldEVudHJpZXMsIGlnbm9yZWRBY3Rpb25QYXRocywgY2FjaGUpO1xuICAgICAgICAgIGlmIChmb3VuZEFjdGlvbk5vblNlcmlhbGl6YWJsZVZhbHVlKSB7XG4gICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgIGtleVBhdGgsXG4gICAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgICB9ID0gZm91bmRBY3Rpb25Ob25TZXJpYWxpemFibGVWYWx1ZTtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEEgbm9uLXNlcmlhbGl6YWJsZSB2YWx1ZSB3YXMgZGV0ZWN0ZWQgaW4gYW4gYWN0aW9uLCBpbiB0aGUgcGF0aDogXFxgJHtrZXlQYXRofVxcYC4gVmFsdWU6YCwgdmFsdWUsIFwiXFxuVGFrZSBhIGxvb2sgYXQgdGhlIGxvZ2ljIHRoYXQgZGlzcGF0Y2hlZCB0aGlzIGFjdGlvbjogXCIsIGFjdGlvbiwgXCJcXG4oU2VlIGh0dHBzOi8vcmVkdXguanMub3JnL2ZhcS9hY3Rpb25zI3doeS1zaG91bGQtdHlwZS1iZS1hLXN0cmluZy1vci1hdC1sZWFzdC1zZXJpYWxpemFibGUtd2h5LXNob3VsZC1teS1hY3Rpb24tdHlwZXMtYmUtY29uc3RhbnRzKVwiLCBcIlxcbihUbyBhbGxvdyBub24tc2VyaWFsaXphYmxlIHZhbHVlcyBzZWU6IGh0dHBzOi8vcmVkdXgtdG9vbGtpdC5qcy5vcmcvdXNhZ2UvdXNhZ2UtZ3VpZGUjd29ya2luZy13aXRoLW5vbi1zZXJpYWxpemFibGUtZGF0YSlcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmICghaWdub3JlU3RhdGUpIHtcbiAgICAgICAgbWVhc3VyZVV0aWxzLm1lYXN1cmVUaW1lKCgpID0+IHtcbiAgICAgICAgICBjb25zdCBzdGF0ZSA9IHN0b3JlQVBJLmdldFN0YXRlKCk7XG4gICAgICAgICAgY29uc3QgZm91bmRTdGF0ZU5vblNlcmlhbGl6YWJsZVZhbHVlID0gZmluZE5vblNlcmlhbGl6YWJsZVZhbHVlKHN0YXRlLCBcIlwiLCBpc1NlcmlhbGl6YWJsZSwgZ2V0RW50cmllcywgaWdub3JlZFBhdGhzLCBjYWNoZSk7XG4gICAgICAgICAgaWYgKGZvdW5kU3RhdGVOb25TZXJpYWxpemFibGVWYWx1ZSkge1xuICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICBrZXlQYXRoLFxuICAgICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgfSA9IGZvdW5kU3RhdGVOb25TZXJpYWxpemFibGVWYWx1ZTtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEEgbm9uLXNlcmlhbGl6YWJsZSB2YWx1ZSB3YXMgZGV0ZWN0ZWQgaW4gdGhlIHN0YXRlLCBpbiB0aGUgcGF0aDogXFxgJHtrZXlQYXRofVxcYC4gVmFsdWU6YCwgdmFsdWUsIGBcblRha2UgYSBsb29rIGF0IHRoZSByZWR1Y2VyKHMpIGhhbmRsaW5nIHRoaXMgYWN0aW9uIHR5cGU6ICR7YWN0aW9uLnR5cGV9LlxuKFNlZSBodHRwczovL3JlZHV4LmpzLm9yZy9mYXEvb3JnYW5pemluZy1zdGF0ZSNjYW4taS1wdXQtZnVuY3Rpb25zLXByb21pc2VzLW9yLW90aGVyLW5vbi1zZXJpYWxpemFibGUtaXRlbXMtaW4tbXktc3RvcmUtc3RhdGUpYCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgbWVhc3VyZVV0aWxzLndhcm5JZkV4Y2VlZGVkKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gIH1cbn1cblxuLy8gc3JjL2dldERlZmF1bHRNaWRkbGV3YXJlLnRzXG5mdW5jdGlvbiBpc0Jvb2xlYW4oeCkge1xuICByZXR1cm4gdHlwZW9mIHggPT09IFwiYm9vbGVhblwiO1xufVxudmFyIGJ1aWxkR2V0RGVmYXVsdE1pZGRsZXdhcmUgPSAoKSA9PiBmdW5jdGlvbiBnZXREZWZhdWx0TWlkZGxld2FyZShvcHRpb25zKSB7XG4gIGNvbnN0IHtcbiAgICB0aHVuayA9IHRydWUsXG4gICAgaW1tdXRhYmxlQ2hlY2sgPSB0cnVlLFxuICAgIHNlcmlhbGl6YWJsZUNoZWNrID0gdHJ1ZSxcbiAgICBhY3Rpb25DcmVhdG9yQ2hlY2sgPSB0cnVlXG4gIH0gPSBvcHRpb25zID8/IHt9O1xuICBsZXQgbWlkZGxld2FyZUFycmF5ID0gbmV3IFR1cGxlKCk7XG4gIGlmICh0aHVuaykge1xuICAgIGlmIChpc0Jvb2xlYW4odGh1bmspKSB7XG4gICAgICBtaWRkbGV3YXJlQXJyYXkucHVzaCh0aHVua01pZGRsZXdhcmUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBtaWRkbGV3YXJlQXJyYXkucHVzaCh3aXRoRXh0cmFBcmd1bWVudCh0aHVuay5leHRyYUFyZ3VtZW50KSk7XG4gICAgfVxuICB9XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBpZiAoaW1tdXRhYmxlQ2hlY2spIHtcbiAgICAgIGxldCBpbW11dGFibGVPcHRpb25zID0ge307XG4gICAgICBpZiAoIWlzQm9vbGVhbihpbW11dGFibGVDaGVjaykpIHtcbiAgICAgICAgaW1tdXRhYmxlT3B0aW9ucyA9IGltbXV0YWJsZUNoZWNrO1xuICAgICAgfVxuICAgICAgbWlkZGxld2FyZUFycmF5LnVuc2hpZnQoY3JlYXRlSW1tdXRhYmxlU3RhdGVJbnZhcmlhbnRNaWRkbGV3YXJlKGltbXV0YWJsZU9wdGlvbnMpKTtcbiAgICB9XG4gICAgaWYgKHNlcmlhbGl6YWJsZUNoZWNrKSB7XG4gICAgICBsZXQgc2VyaWFsaXphYmxlT3B0aW9ucyA9IHt9O1xuICAgICAgaWYgKCFpc0Jvb2xlYW4oc2VyaWFsaXphYmxlQ2hlY2spKSB7XG4gICAgICAgIHNlcmlhbGl6YWJsZU9wdGlvbnMgPSBzZXJpYWxpemFibGVDaGVjaztcbiAgICAgIH1cbiAgICAgIG1pZGRsZXdhcmVBcnJheS5wdXNoKGNyZWF0ZVNlcmlhbGl6YWJsZVN0YXRlSW52YXJpYW50TWlkZGxld2FyZShzZXJpYWxpemFibGVPcHRpb25zKSk7XG4gICAgfVxuICAgIGlmIChhY3Rpb25DcmVhdG9yQ2hlY2spIHtcbiAgICAgIGxldCBhY3Rpb25DcmVhdG9yT3B0aW9ucyA9IHt9O1xuICAgICAgaWYgKCFpc0Jvb2xlYW4oYWN0aW9uQ3JlYXRvckNoZWNrKSkge1xuICAgICAgICBhY3Rpb25DcmVhdG9yT3B0aW9ucyA9IGFjdGlvbkNyZWF0b3JDaGVjaztcbiAgICAgIH1cbiAgICAgIG1pZGRsZXdhcmVBcnJheS51bnNoaWZ0KGNyZWF0ZUFjdGlvbkNyZWF0b3JJbnZhcmlhbnRNaWRkbGV3YXJlKGFjdGlvbkNyZWF0b3JPcHRpb25zKSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBtaWRkbGV3YXJlQXJyYXk7XG59O1xuXG4vLyBzcmMvYXV0b0JhdGNoRW5oYW5jZXIudHNcbnZhciBTSE9VTERfQVVUT0JBVENIID0gXCJSVEtfYXV0b0JhdGNoXCI7XG52YXIgcHJlcGFyZUF1dG9CYXRjaGVkID0gKCkgPT4gKHBheWxvYWQpID0+ICh7XG4gIHBheWxvYWQsXG4gIG1ldGE6IHtcbiAgICBbU0hPVUxEX0FVVE9CQVRDSF06IHRydWVcbiAgfVxufSk7XG52YXIgY3JlYXRlUXVldWVXaXRoVGltZXIgPSAodGltZW91dCkgPT4ge1xuICByZXR1cm4gKG5vdGlmeSkgPT4ge1xuICAgIHNldFRpbWVvdXQobm90aWZ5LCB0aW1lb3V0KTtcbiAgfTtcbn07XG52YXIgckFGID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lID8gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSA6IGNyZWF0ZVF1ZXVlV2l0aFRpbWVyKDEwKTtcbnZhciBhdXRvQmF0Y2hFbmhhbmNlciA9IChvcHRpb25zID0ge1xuICB0eXBlOiBcInJhZlwiXG59KSA9PiAobmV4dCkgPT4gKC4uLmFyZ3MpID0+IHtcbiAgY29uc3Qgc3RvcmUgPSBuZXh0KC4uLmFyZ3MpO1xuICBsZXQgbm90aWZ5aW5nID0gdHJ1ZTtcbiAgbGV0IHNob3VsZE5vdGlmeUF0RW5kT2ZUaWNrID0gZmFsc2U7XG4gIGxldCBub3RpZmljYXRpb25RdWV1ZWQgPSBmYWxzZTtcbiAgY29uc3QgbGlzdGVuZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgY29uc3QgcXVldWVDYWxsYmFjayA9IG9wdGlvbnMudHlwZSA9PT0gXCJ0aWNrXCIgPyBxdWV1ZU1pY3JvdGFzayA6IG9wdGlvbnMudHlwZSA9PT0gXCJyYWZcIiA/IHJBRiA6IG9wdGlvbnMudHlwZSA9PT0gXCJjYWxsYmFja1wiID8gb3B0aW9ucy5xdWV1ZU5vdGlmaWNhdGlvbiA6IGNyZWF0ZVF1ZXVlV2l0aFRpbWVyKG9wdGlvbnMudGltZW91dCk7XG4gIGNvbnN0IG5vdGlmeUxpc3RlbmVycyA9ICgpID0+IHtcbiAgICBub3RpZmljYXRpb25RdWV1ZWQgPSBmYWxzZTtcbiAgICBpZiAoc2hvdWxkTm90aWZ5QXRFbmRPZlRpY2spIHtcbiAgICAgIHNob3VsZE5vdGlmeUF0RW5kT2ZUaWNrID0gZmFsc2U7XG4gICAgICBsaXN0ZW5lcnMuZm9yRWFjaCgobCkgPT4gbCgpKTtcbiAgICB9XG4gIH07XG4gIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBzdG9yZSwge1xuICAgIC8vIE92ZXJyaWRlIHRoZSBiYXNlIGBzdG9yZS5zdWJzY3JpYmVgIG1ldGhvZCB0byBrZWVwIG9yaWdpbmFsIGxpc3RlbmVyc1xuICAgIC8vIGZyb20gcnVubmluZyBpZiB3ZSdyZSBkZWxheWluZyBub3RpZmljYXRpb25zXG4gICAgc3Vic2NyaWJlKGxpc3RlbmVyMikge1xuICAgICAgY29uc3Qgd3JhcHBlZExpc3RlbmVyID0gKCkgPT4gbm90aWZ5aW5nICYmIGxpc3RlbmVyMigpO1xuICAgICAgY29uc3QgdW5zdWJzY3JpYmUgPSBzdG9yZS5zdWJzY3JpYmUod3JhcHBlZExpc3RlbmVyKTtcbiAgICAgIGxpc3RlbmVycy5hZGQobGlzdGVuZXIyKTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIHVuc3Vic2NyaWJlKCk7XG4gICAgICAgIGxpc3RlbmVycy5kZWxldGUobGlzdGVuZXIyKTtcbiAgICAgIH07XG4gICAgfSxcbiAgICAvLyBPdmVycmlkZSB0aGUgYmFzZSBgc3RvcmUuZGlzcGF0Y2hgIG1ldGhvZCBzbyB0aGF0IHdlIGNhbiBjaGVjayBhY3Rpb25zXG4gICAgLy8gZm9yIHRoZSBgc2hvdWxkQXV0b0JhdGNoYCBmbGFnIGFuZCBkZXRlcm1pbmUgaWYgYmF0Y2hpbmcgaXMgYWN0aXZlXG4gICAgZGlzcGF0Y2goYWN0aW9uKSB7XG4gICAgICB0cnkge1xuICAgICAgICBub3RpZnlpbmcgPSAhYWN0aW9uPy5tZXRhPy5bU0hPVUxEX0FVVE9CQVRDSF07XG4gICAgICAgIHNob3VsZE5vdGlmeUF0RW5kT2ZUaWNrID0gIW5vdGlmeWluZztcbiAgICAgICAgaWYgKHNob3VsZE5vdGlmeUF0RW5kT2ZUaWNrKSB7XG4gICAgICAgICAgaWYgKCFub3RpZmljYXRpb25RdWV1ZWQpIHtcbiAgICAgICAgICAgIG5vdGlmaWNhdGlvblF1ZXVlZCA9IHRydWU7XG4gICAgICAgICAgICBxdWV1ZUNhbGxiYWNrKG5vdGlmeUxpc3RlbmVycyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdG9yZS5kaXNwYXRjaChhY3Rpb24pO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgbm90aWZ5aW5nID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufTtcblxuLy8gc3JjL2dldERlZmF1bHRFbmhhbmNlcnMudHNcbnZhciBidWlsZEdldERlZmF1bHRFbmhhbmNlcnMgPSAobWlkZGxld2FyZUVuaGFuY2VyKSA9PiBmdW5jdGlvbiBnZXREZWZhdWx0RW5oYW5jZXJzKG9wdGlvbnMpIHtcbiAgY29uc3Qge1xuICAgIGF1dG9CYXRjaCA9IHRydWVcbiAgfSA9IG9wdGlvbnMgPz8ge307XG4gIGxldCBlbmhhbmNlckFycmF5ID0gbmV3IFR1cGxlKG1pZGRsZXdhcmVFbmhhbmNlcik7XG4gIGlmIChhdXRvQmF0Y2gpIHtcbiAgICBlbmhhbmNlckFycmF5LnB1c2goYXV0b0JhdGNoRW5oYW5jZXIodHlwZW9mIGF1dG9CYXRjaCA9PT0gXCJvYmplY3RcIiA/IGF1dG9CYXRjaCA6IHZvaWQgMCkpO1xuICB9XG4gIHJldHVybiBlbmhhbmNlckFycmF5O1xufTtcblxuLy8gc3JjL2NvbmZpZ3VyZVN0b3JlLnRzXG52YXIgSVNfUFJPRFVDVElPTiA9IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIjtcbmZ1bmN0aW9uIGNvbmZpZ3VyZVN0b3JlKG9wdGlvbnMpIHtcbiAgY29uc3QgZ2V0RGVmYXVsdE1pZGRsZXdhcmUgPSBidWlsZEdldERlZmF1bHRNaWRkbGV3YXJlKCk7XG4gIGNvbnN0IHtcbiAgICByZWR1Y2VyID0gdm9pZCAwLFxuICAgIG1pZGRsZXdhcmUsXG4gICAgZGV2VG9vbHMgPSB0cnVlLFxuICAgIHByZWxvYWRlZFN0YXRlID0gdm9pZCAwLFxuICAgIGVuaGFuY2VycyA9IHZvaWQgMFxuICB9ID0gb3B0aW9ucyB8fCB7fTtcbiAgbGV0IHJvb3RSZWR1Y2VyO1xuICBpZiAodHlwZW9mIHJlZHVjZXIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHJvb3RSZWR1Y2VyID0gcmVkdWNlcjtcbiAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0MihyZWR1Y2VyKSkge1xuICAgIHJvb3RSZWR1Y2VyID0gY29tYmluZVJlZHVjZXJzKHJlZHVjZXIpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDEpIDogXCJgcmVkdWNlcmAgaXMgYSByZXF1aXJlZCBhcmd1bWVudCwgYW5kIG11c3QgYmUgYSBmdW5jdGlvbiBvciBhbiBvYmplY3Qgb2YgZnVuY3Rpb25zIHRoYXQgY2FuIGJlIHBhc3NlZCB0byBjb21iaW5lUmVkdWNlcnNcIik7XG4gIH1cbiAgaWYgKCFJU19QUk9EVUNUSU9OICYmIG1pZGRsZXdhcmUgJiYgdHlwZW9mIG1pZGRsZXdhcmUgIT09IFwiZnVuY3Rpb25cIikge1xuICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDIpIDogXCJgbWlkZGxld2FyZWAgZmllbGQgbXVzdCBiZSBhIGNhbGxiYWNrXCIpO1xuICB9XG4gIGxldCBmaW5hbE1pZGRsZXdhcmU7XG4gIGlmICh0eXBlb2YgbWlkZGxld2FyZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZmluYWxNaWRkbGV3YXJlID0gbWlkZGxld2FyZShnZXREZWZhdWx0TWlkZGxld2FyZSk7XG4gICAgaWYgKCFJU19QUk9EVUNUSU9OICYmICFBcnJheS5pc0FycmF5KGZpbmFsTWlkZGxld2FyZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDMpIDogXCJ3aGVuIHVzaW5nIGEgbWlkZGxld2FyZSBidWlsZGVyIGZ1bmN0aW9uLCBhbiBhcnJheSBvZiBtaWRkbGV3YXJlIG11c3QgYmUgcmV0dXJuZWRcIik7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZpbmFsTWlkZGxld2FyZSA9IGdldERlZmF1bHRNaWRkbGV3YXJlKCk7XG4gIH1cbiAgaWYgKCFJU19QUk9EVUNUSU9OICYmIGZpbmFsTWlkZGxld2FyZS5zb21lKChpdGVtKSA9PiB0eXBlb2YgaXRlbSAhPT0gXCJmdW5jdGlvblwiKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDQpIDogXCJlYWNoIG1pZGRsZXdhcmUgcHJvdmlkZWQgdG8gY29uZmlndXJlU3RvcmUgbXVzdCBiZSBhIGZ1bmN0aW9uXCIpO1xuICB9XG4gIGxldCBmaW5hbENvbXBvc2UgPSBjb21wb3NlMjtcbiAgaWYgKGRldlRvb2xzKSB7XG4gICAgZmluYWxDb21wb3NlID0gY29tcG9zZVdpdGhEZXZUb29scyh7XG4gICAgICAvLyBFbmFibGUgY2FwdHVyZSBvZiBzdGFjayB0cmFjZXMgZm9yIGRpc3BhdGNoZWQgUmVkdXggYWN0aW9uc1xuICAgICAgdHJhY2U6ICFJU19QUk9EVUNUSU9OLFxuICAgICAgLi4udHlwZW9mIGRldlRvb2xzID09PSBcIm9iamVjdFwiICYmIGRldlRvb2xzXG4gICAgfSk7XG4gIH1cbiAgY29uc3QgbWlkZGxld2FyZUVuaGFuY2VyID0gYXBwbHlNaWRkbGV3YXJlKC4uLmZpbmFsTWlkZGxld2FyZSk7XG4gIGNvbnN0IGdldERlZmF1bHRFbmhhbmNlcnMgPSBidWlsZEdldERlZmF1bHRFbmhhbmNlcnMobWlkZGxld2FyZUVuaGFuY2VyKTtcbiAgaWYgKCFJU19QUk9EVUNUSU9OICYmIGVuaGFuY2VycyAmJiB0eXBlb2YgZW5oYW5jZXJzICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSg1KSA6IFwiYGVuaGFuY2Vyc2AgZmllbGQgbXVzdCBiZSBhIGNhbGxiYWNrXCIpO1xuICB9XG4gIGxldCBzdG9yZUVuaGFuY2VycyA9IHR5cGVvZiBlbmhhbmNlcnMgPT09IFwiZnVuY3Rpb25cIiA/IGVuaGFuY2VycyhnZXREZWZhdWx0RW5oYW5jZXJzKSA6IGdldERlZmF1bHRFbmhhbmNlcnMoKTtcbiAgaWYgKCFJU19QUk9EVUNUSU9OICYmICFBcnJheS5pc0FycmF5KHN0b3JlRW5oYW5jZXJzKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDYpIDogXCJgZW5oYW5jZXJzYCBjYWxsYmFjayBtdXN0IHJldHVybiBhbiBhcnJheVwiKTtcbiAgfVxuICBpZiAoIUlTX1BST0RVQ1RJT04gJiYgc3RvcmVFbmhhbmNlcnMuc29tZSgoaXRlbSkgPT4gdHlwZW9mIGl0ZW0gIT09IFwiZnVuY3Rpb25cIikpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSg3KSA6IFwiZWFjaCBlbmhhbmNlciBwcm92aWRlZCB0byBjb25maWd1cmVTdG9yZSBtdXN0IGJlIGEgZnVuY3Rpb25cIik7XG4gIH1cbiAgaWYgKCFJU19QUk9EVUNUSU9OICYmIGZpbmFsTWlkZGxld2FyZS5sZW5ndGggJiYgIXN0b3JlRW5oYW5jZXJzLmluY2x1ZGVzKG1pZGRsZXdhcmVFbmhhbmNlcikpIHtcbiAgICBjb25zb2xlLmVycm9yKFwibWlkZGxld2FyZXMgd2VyZSBwcm92aWRlZCwgYnV0IG1pZGRsZXdhcmUgZW5oYW5jZXIgd2FzIG5vdCBpbmNsdWRlZCBpbiBmaW5hbCBlbmhhbmNlcnMgLSBtYWtlIHN1cmUgdG8gY2FsbCBgZ2V0RGVmYXVsdEVuaGFuY2Vyc2BcIik7XG4gIH1cbiAgY29uc3QgY29tcG9zZWRFbmhhbmNlciA9IGZpbmFsQ29tcG9zZSguLi5zdG9yZUVuaGFuY2Vycyk7XG4gIHJldHVybiBjcmVhdGVTdG9yZShyb290UmVkdWNlciwgcHJlbG9hZGVkU3RhdGUsIGNvbXBvc2VkRW5oYW5jZXIpO1xufVxuXG4vLyBzcmMvY3JlYXRlUmVkdWNlci50c1xuaW1wb3J0IHsgcHJvZHVjZSBhcyBjcmVhdGVOZXh0U3RhdGUyLCBpc0RyYWZ0IGFzIGlzRHJhZnQyLCBpc0RyYWZ0YWJsZSBhcyBpc0RyYWZ0YWJsZTIgfSBmcm9tIFwiaW1tZXJcIjtcblxuLy8gc3JjL21hcEJ1aWxkZXJzLnRzXG5mdW5jdGlvbiBleGVjdXRlUmVkdWNlckJ1aWxkZXJDYWxsYmFjayhidWlsZGVyQ2FsbGJhY2spIHtcbiAgY29uc3QgYWN0aW9uc01hcCA9IHt9O1xuICBjb25zdCBhY3Rpb25NYXRjaGVycyA9IFtdO1xuICBsZXQgZGVmYXVsdENhc2VSZWR1Y2VyO1xuICBjb25zdCBidWlsZGVyID0ge1xuICAgIGFkZENhc2UodHlwZU9yQWN0aW9uQ3JlYXRvciwgcmVkdWNlcikge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICBpZiAoYWN0aW9uTWF0Y2hlcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDI2KSA6IFwiYGJ1aWxkZXIuYWRkQ2FzZWAgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIGJlZm9yZSBjYWxsaW5nIGBidWlsZGVyLmFkZE1hdGNoZXJgXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkZWZhdWx0Q2FzZVJlZHVjZXIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgyNykgOiBcImBidWlsZGVyLmFkZENhc2VgIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBiZWZvcmUgY2FsbGluZyBgYnVpbGRlci5hZGREZWZhdWx0Q2FzZWBcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IHR5cGUgPSB0eXBlb2YgdHlwZU9yQWN0aW9uQ3JlYXRvciA9PT0gXCJzdHJpbmdcIiA/IHR5cGVPckFjdGlvbkNyZWF0b3IgOiB0eXBlT3JBY3Rpb25DcmVhdG9yLnR5cGU7XG4gICAgICBpZiAoIXR5cGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMjgpIDogXCJgYnVpbGRlci5hZGRDYXNlYCBjYW5ub3QgYmUgY2FsbGVkIHdpdGggYW4gZW1wdHkgYWN0aW9uIHR5cGVcIik7XG4gICAgICB9XG4gICAgICBpZiAodHlwZSBpbiBhY3Rpb25zTWFwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDI5KSA6IGBcXGBidWlsZGVyLmFkZENhc2VcXGAgY2Fubm90IGJlIGNhbGxlZCB3aXRoIHR3byByZWR1Y2VycyBmb3IgdGhlIHNhbWUgYWN0aW9uIHR5cGUgJyR7dHlwZX0nYCk7XG4gICAgICB9XG4gICAgICBhY3Rpb25zTWFwW3R5cGVdID0gcmVkdWNlcjtcbiAgICAgIHJldHVybiBidWlsZGVyO1xuICAgIH0sXG4gICAgYWRkTWF0Y2hlcihtYXRjaGVyLCByZWR1Y2VyKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgIGlmIChkZWZhdWx0Q2FzZVJlZHVjZXIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgzMCkgOiBcImBidWlsZGVyLmFkZE1hdGNoZXJgIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBiZWZvcmUgY2FsbGluZyBgYnVpbGRlci5hZGREZWZhdWx0Q2FzZWBcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGFjdGlvbk1hdGNoZXJzLnB1c2goe1xuICAgICAgICBtYXRjaGVyLFxuICAgICAgICByZWR1Y2VyXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBidWlsZGVyO1xuICAgIH0sXG4gICAgYWRkRGVmYXVsdENhc2UocmVkdWNlcikge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICBpZiAoZGVmYXVsdENhc2VSZWR1Y2VyKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMzEpIDogXCJgYnVpbGRlci5hZGREZWZhdWx0Q2FzZWAgY2FuIG9ubHkgYmUgY2FsbGVkIG9uY2VcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGRlZmF1bHRDYXNlUmVkdWNlciA9IHJlZHVjZXI7XG4gICAgICByZXR1cm4gYnVpbGRlcjtcbiAgICB9XG4gIH07XG4gIGJ1aWxkZXJDYWxsYmFjayhidWlsZGVyKTtcbiAgcmV0dXJuIFthY3Rpb25zTWFwLCBhY3Rpb25NYXRjaGVycywgZGVmYXVsdENhc2VSZWR1Y2VyXTtcbn1cblxuLy8gc3JjL2NyZWF0ZVJlZHVjZXIudHNcbmZ1bmN0aW9uIGlzU3RhdGVGdW5jdGlvbih4KSB7XG4gIHJldHVybiB0eXBlb2YgeCA9PT0gXCJmdW5jdGlvblwiO1xufVxuZnVuY3Rpb24gY3JlYXRlUmVkdWNlcihpbml0aWFsU3RhdGUsIG1hcE9yQnVpbGRlckNhbGxiYWNrKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBpZiAodHlwZW9mIG1hcE9yQnVpbGRlckNhbGxiYWNrID09PSBcIm9iamVjdFwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSg4KSA6IFwiVGhlIG9iamVjdCBub3RhdGlvbiBmb3IgYGNyZWF0ZVJlZHVjZXJgIGhhcyBiZWVuIHJlbW92ZWQuIFBsZWFzZSB1c2UgdGhlICdidWlsZGVyIGNhbGxiYWNrJyBub3RhdGlvbiBpbnN0ZWFkOiBodHRwczovL3JlZHV4LXRvb2xraXQuanMub3JnL2FwaS9jcmVhdGVSZWR1Y2VyXCIpO1xuICAgIH1cbiAgfVxuICBsZXQgW2FjdGlvbnNNYXAsIGZpbmFsQWN0aW9uTWF0Y2hlcnMsIGZpbmFsRGVmYXVsdENhc2VSZWR1Y2VyXSA9IGV4ZWN1dGVSZWR1Y2VyQnVpbGRlckNhbGxiYWNrKG1hcE9yQnVpbGRlckNhbGxiYWNrKTtcbiAgbGV0IGdldEluaXRpYWxTdGF0ZTtcbiAgaWYgKGlzU3RhdGVGdW5jdGlvbihpbml0aWFsU3RhdGUpKSB7XG4gICAgZ2V0SW5pdGlhbFN0YXRlID0gKCkgPT4gZnJlZXplRHJhZnRhYmxlKGluaXRpYWxTdGF0ZSgpKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBmcm96ZW5Jbml0aWFsU3RhdGUgPSBmcmVlemVEcmFmdGFibGUoaW5pdGlhbFN0YXRlKTtcbiAgICBnZXRJbml0aWFsU3RhdGUgPSAoKSA9PiBmcm96ZW5Jbml0aWFsU3RhdGU7XG4gIH1cbiAgZnVuY3Rpb24gcmVkdWNlcihzdGF0ZSA9IGdldEluaXRpYWxTdGF0ZSgpLCBhY3Rpb24pIHtcbiAgICBsZXQgY2FzZVJlZHVjZXJzID0gW2FjdGlvbnNNYXBbYWN0aW9uLnR5cGVdLCAuLi5maW5hbEFjdGlvbk1hdGNoZXJzLmZpbHRlcigoe1xuICAgICAgbWF0Y2hlclxuICAgIH0pID0+IG1hdGNoZXIoYWN0aW9uKSkubWFwKCh7XG4gICAgICByZWR1Y2VyOiByZWR1Y2VyMlxuICAgIH0pID0+IHJlZHVjZXIyKV07XG4gICAgaWYgKGNhc2VSZWR1Y2Vycy5maWx0ZXIoKGNyKSA9PiAhIWNyKS5sZW5ndGggPT09IDApIHtcbiAgICAgIGNhc2VSZWR1Y2VycyA9IFtmaW5hbERlZmF1bHRDYXNlUmVkdWNlcl07XG4gICAgfVxuICAgIHJldHVybiBjYXNlUmVkdWNlcnMucmVkdWNlKChwcmV2aW91c1N0YXRlLCBjYXNlUmVkdWNlcikgPT4ge1xuICAgICAgaWYgKGNhc2VSZWR1Y2VyKSB7XG4gICAgICAgIGlmIChpc0RyYWZ0MihwcmV2aW91c1N0YXRlKSkge1xuICAgICAgICAgIGNvbnN0IGRyYWZ0ID0gcHJldmlvdXNTdGF0ZTtcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBjYXNlUmVkdWNlcihkcmFmdCwgYWN0aW9uKTtcbiAgICAgICAgICBpZiAocmVzdWx0ID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHJldHVybiBwcmV2aW91c1N0YXRlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9IGVsc2UgaWYgKCFpc0RyYWZ0YWJsZTIocHJldmlvdXNTdGF0ZSkpIHtcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBjYXNlUmVkdWNlcihwcmV2aW91c1N0YXRlLCBhY3Rpb24pO1xuICAgICAgICAgIGlmIChyZXN1bHQgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgaWYgKHByZXZpb3VzU3RhdGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHByZXZpb3VzU3RhdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSg5KSA6IFwiQSBjYXNlIHJlZHVjZXIgb24gYSBub24tZHJhZnRhYmxlIHZhbHVlIG11c3Qgbm90IHJldHVybiB1bmRlZmluZWRcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZU5leHRTdGF0ZTIocHJldmlvdXNTdGF0ZSwgKGRyYWZ0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gY2FzZVJlZHVjZXIoZHJhZnQsIGFjdGlvbik7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBwcmV2aW91c1N0YXRlO1xuICAgIH0sIHN0YXRlKTtcbiAgfVxuICByZWR1Y2VyLmdldEluaXRpYWxTdGF0ZSA9IGdldEluaXRpYWxTdGF0ZTtcbiAgcmV0dXJuIHJlZHVjZXI7XG59XG5cbi8vIHNyYy9uYW5vaWQudHNcbnZhciB1cmxBbHBoYWJldCA9IFwiTW9kdWxlU3ltYmhhc093blByLTAxMjM0NTY3ODlBQkNERUZHSE5SVmZnY3RpVXZ6X0txWVRKa0x4cFpYSWpRV1wiO1xudmFyIG5hbm9pZCA9IChzaXplID0gMjEpID0+IHtcbiAgbGV0IGlkID0gXCJcIjtcbiAgbGV0IGkgPSBzaXplO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgaWQgKz0gdXJsQWxwaGFiZXRbTWF0aC5yYW5kb20oKSAqIDY0IHwgMF07XG4gIH1cbiAgcmV0dXJuIGlkO1xufTtcblxuLy8gc3JjL21hdGNoZXJzLnRzXG52YXIgbWF0Y2hlcyA9IChtYXRjaGVyLCBhY3Rpb24pID0+IHtcbiAgaWYgKGhhc01hdGNoRnVuY3Rpb24obWF0Y2hlcikpIHtcbiAgICByZXR1cm4gbWF0Y2hlci5tYXRjaChhY3Rpb24pO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBtYXRjaGVyKGFjdGlvbik7XG4gIH1cbn07XG5mdW5jdGlvbiBpc0FueU9mKC4uLm1hdGNoZXJzKSB7XG4gIHJldHVybiAoYWN0aW9uKSA9PiB7XG4gICAgcmV0dXJuIG1hdGNoZXJzLnNvbWUoKG1hdGNoZXIpID0+IG1hdGNoZXMobWF0Y2hlciwgYWN0aW9uKSk7XG4gIH07XG59XG5mdW5jdGlvbiBpc0FsbE9mKC4uLm1hdGNoZXJzKSB7XG4gIHJldHVybiAoYWN0aW9uKSA9PiB7XG4gICAgcmV0dXJuIG1hdGNoZXJzLmV2ZXJ5KChtYXRjaGVyKSA9PiBtYXRjaGVzKG1hdGNoZXIsIGFjdGlvbikpO1xuICB9O1xufVxuZnVuY3Rpb24gaGFzRXhwZWN0ZWRSZXF1ZXN0TWV0YWRhdGEoYWN0aW9uLCB2YWxpZFN0YXR1cykge1xuICBpZiAoIWFjdGlvbiB8fCAhYWN0aW9uLm1ldGEpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBoYXNWYWxpZFJlcXVlc3RJZCA9IHR5cGVvZiBhY3Rpb24ubWV0YS5yZXF1ZXN0SWQgPT09IFwic3RyaW5nXCI7XG4gIGNvbnN0IGhhc1ZhbGlkUmVxdWVzdFN0YXR1cyA9IHZhbGlkU3RhdHVzLmluZGV4T2YoYWN0aW9uLm1ldGEucmVxdWVzdFN0YXR1cykgPiAtMTtcbiAgcmV0dXJuIGhhc1ZhbGlkUmVxdWVzdElkICYmIGhhc1ZhbGlkUmVxdWVzdFN0YXR1cztcbn1cbmZ1bmN0aW9uIGlzQXN5bmNUaHVua0FycmF5KGEpIHtcbiAgcmV0dXJuIHR5cGVvZiBhWzBdID09PSBcImZ1bmN0aW9uXCIgJiYgXCJwZW5kaW5nXCIgaW4gYVswXSAmJiBcImZ1bGZpbGxlZFwiIGluIGFbMF0gJiYgXCJyZWplY3RlZFwiIGluIGFbMF07XG59XG5mdW5jdGlvbiBpc1BlbmRpbmcoLi4uYXN5bmNUaHVua3MpIHtcbiAgaWYgKGFzeW5jVGh1bmtzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiAoYWN0aW9uKSA9PiBoYXNFeHBlY3RlZFJlcXVlc3RNZXRhZGF0YShhY3Rpb24sIFtcInBlbmRpbmdcIl0pO1xuICB9XG4gIGlmICghaXNBc3luY1RodW5rQXJyYXkoYXN5bmNUaHVua3MpKSB7XG4gICAgcmV0dXJuIGlzUGVuZGluZygpKGFzeW5jVGh1bmtzWzBdKTtcbiAgfVxuICByZXR1cm4gKGFjdGlvbikgPT4ge1xuICAgIGNvbnN0IG1hdGNoZXJzID0gYXN5bmNUaHVua3MubWFwKChhc3luY1RodW5rKSA9PiBhc3luY1RodW5rLnBlbmRpbmcpO1xuICAgIGNvbnN0IGNvbWJpbmVkTWF0Y2hlciA9IGlzQW55T2YoLi4ubWF0Y2hlcnMpO1xuICAgIHJldHVybiBjb21iaW5lZE1hdGNoZXIoYWN0aW9uKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGlzUmVqZWN0ZWQoLi4uYXN5bmNUaHVua3MpIHtcbiAgaWYgKGFzeW5jVGh1bmtzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiAoYWN0aW9uKSA9PiBoYXNFeHBlY3RlZFJlcXVlc3RNZXRhZGF0YShhY3Rpb24sIFtcInJlamVjdGVkXCJdKTtcbiAgfVxuICBpZiAoIWlzQXN5bmNUaHVua0FycmF5KGFzeW5jVGh1bmtzKSkge1xuICAgIHJldHVybiBpc1JlamVjdGVkKCkoYXN5bmNUaHVua3NbMF0pO1xuICB9XG4gIHJldHVybiAoYWN0aW9uKSA9PiB7XG4gICAgY29uc3QgbWF0Y2hlcnMgPSBhc3luY1RodW5rcy5tYXAoKGFzeW5jVGh1bmspID0+IGFzeW5jVGh1bmsucmVqZWN0ZWQpO1xuICAgIGNvbnN0IGNvbWJpbmVkTWF0Y2hlciA9IGlzQW55T2YoLi4ubWF0Y2hlcnMpO1xuICAgIHJldHVybiBjb21iaW5lZE1hdGNoZXIoYWN0aW9uKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGlzUmVqZWN0ZWRXaXRoVmFsdWUoLi4uYXN5bmNUaHVua3MpIHtcbiAgY29uc3QgaGFzRmxhZyA9IChhY3Rpb24pID0+IHtcbiAgICByZXR1cm4gYWN0aW9uICYmIGFjdGlvbi5tZXRhICYmIGFjdGlvbi5tZXRhLnJlamVjdGVkV2l0aFZhbHVlO1xuICB9O1xuICBpZiAoYXN5bmNUaHVua3MubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIChhY3Rpb24pID0+IHtcbiAgICAgIGNvbnN0IGNvbWJpbmVkTWF0Y2hlciA9IGlzQWxsT2YoaXNSZWplY3RlZCguLi5hc3luY1RodW5rcyksIGhhc0ZsYWcpO1xuICAgICAgcmV0dXJuIGNvbWJpbmVkTWF0Y2hlcihhY3Rpb24pO1xuICAgIH07XG4gIH1cbiAgaWYgKCFpc0FzeW5jVGh1bmtBcnJheShhc3luY1RodW5rcykpIHtcbiAgICByZXR1cm4gaXNSZWplY3RlZFdpdGhWYWx1ZSgpKGFzeW5jVGh1bmtzWzBdKTtcbiAgfVxuICByZXR1cm4gKGFjdGlvbikgPT4ge1xuICAgIGNvbnN0IGNvbWJpbmVkTWF0Y2hlciA9IGlzQWxsT2YoaXNSZWplY3RlZCguLi5hc3luY1RodW5rcyksIGhhc0ZsYWcpO1xuICAgIHJldHVybiBjb21iaW5lZE1hdGNoZXIoYWN0aW9uKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGlzRnVsZmlsbGVkKC4uLmFzeW5jVGh1bmtzKSB7XG4gIGlmIChhc3luY1RodW5rcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gKGFjdGlvbikgPT4gaGFzRXhwZWN0ZWRSZXF1ZXN0TWV0YWRhdGEoYWN0aW9uLCBbXCJmdWxmaWxsZWRcIl0pO1xuICB9XG4gIGlmICghaXNBc3luY1RodW5rQXJyYXkoYXN5bmNUaHVua3MpKSB7XG4gICAgcmV0dXJuIGlzRnVsZmlsbGVkKCkoYXN5bmNUaHVua3NbMF0pO1xuICB9XG4gIHJldHVybiAoYWN0aW9uKSA9PiB7XG4gICAgY29uc3QgbWF0Y2hlcnMgPSBhc3luY1RodW5rcy5tYXAoKGFzeW5jVGh1bmspID0+IGFzeW5jVGh1bmsuZnVsZmlsbGVkKTtcbiAgICBjb25zdCBjb21iaW5lZE1hdGNoZXIgPSBpc0FueU9mKC4uLm1hdGNoZXJzKTtcbiAgICByZXR1cm4gY29tYmluZWRNYXRjaGVyKGFjdGlvbik7XG4gIH07XG59XG5mdW5jdGlvbiBpc0FzeW5jVGh1bmtBY3Rpb24oLi4uYXN5bmNUaHVua3MpIHtcbiAgaWYgKGFzeW5jVGh1bmtzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiAoYWN0aW9uKSA9PiBoYXNFeHBlY3RlZFJlcXVlc3RNZXRhZGF0YShhY3Rpb24sIFtcInBlbmRpbmdcIiwgXCJmdWxmaWxsZWRcIiwgXCJyZWplY3RlZFwiXSk7XG4gIH1cbiAgaWYgKCFpc0FzeW5jVGh1bmtBcnJheShhc3luY1RodW5rcykpIHtcbiAgICByZXR1cm4gaXNBc3luY1RodW5rQWN0aW9uKCkoYXN5bmNUaHVua3NbMF0pO1xuICB9XG4gIHJldHVybiAoYWN0aW9uKSA9PiB7XG4gICAgY29uc3QgbWF0Y2hlcnMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGFzeW5jVGh1bmsgb2YgYXN5bmNUaHVua3MpIHtcbiAgICAgIG1hdGNoZXJzLnB1c2goYXN5bmNUaHVuay5wZW5kaW5nLCBhc3luY1RodW5rLnJlamVjdGVkLCBhc3luY1RodW5rLmZ1bGZpbGxlZCk7XG4gICAgfVxuICAgIGNvbnN0IGNvbWJpbmVkTWF0Y2hlciA9IGlzQW55T2YoLi4ubWF0Y2hlcnMpO1xuICAgIHJldHVybiBjb21iaW5lZE1hdGNoZXIoYWN0aW9uKTtcbiAgfTtcbn1cblxuLy8gc3JjL2NyZWF0ZUFzeW5jVGh1bmsudHNcbnZhciBjb21tb25Qcm9wZXJ0aWVzID0gW1wibmFtZVwiLCBcIm1lc3NhZ2VcIiwgXCJzdGFja1wiLCBcImNvZGVcIl07XG52YXIgUmVqZWN0V2l0aFZhbHVlID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihwYXlsb2FkLCBtZXRhKSB7XG4gICAgdGhpcy5wYXlsb2FkID0gcGF5bG9hZDtcbiAgICB0aGlzLm1ldGEgPSBtZXRhO1xuICB9XG4gIC8qXG4gIHR5cGUtb25seSBwcm9wZXJ0eSB0byBkaXN0aW5ndWlzaCBiZXR3ZWVuIFJlamVjdFdpdGhWYWx1ZSBhbmQgRnVsZmlsbFdpdGhNZXRhXG4gIGRvZXMgbm90IGV4aXN0IGF0IHJ1bnRpbWVcbiAgKi9cbiAgX3R5cGU7XG59O1xudmFyIEZ1bGZpbGxXaXRoTWV0YSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IocGF5bG9hZCwgbWV0YSkge1xuICAgIHRoaXMucGF5bG9hZCA9IHBheWxvYWQ7XG4gICAgdGhpcy5tZXRhID0gbWV0YTtcbiAgfVxuICAvKlxuICB0eXBlLW9ubHkgcHJvcGVydHkgdG8gZGlzdGluZ3Vpc2ggYmV0d2VlbiBSZWplY3RXaXRoVmFsdWUgYW5kIEZ1bGZpbGxXaXRoTWV0YVxuICBkb2VzIG5vdCBleGlzdCBhdCBydW50aW1lXG4gICovXG4gIF90eXBlO1xufTtcbnZhciBtaW5pU2VyaWFsaXplRXJyb3IgPSAodmFsdWUpID0+IHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiB2YWx1ZSAhPT0gbnVsbCkge1xuICAgIGNvbnN0IHNpbXBsZUVycm9yID0ge307XG4gICAgZm9yIChjb25zdCBwcm9wZXJ0eSBvZiBjb21tb25Qcm9wZXJ0aWVzKSB7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlW3Byb3BlcnR5XSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBzaW1wbGVFcnJvcltwcm9wZXJ0eV0gPSB2YWx1ZVtwcm9wZXJ0eV07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzaW1wbGVFcnJvcjtcbiAgfVxuICByZXR1cm4ge1xuICAgIG1lc3NhZ2U6IFN0cmluZyh2YWx1ZSlcbiAgfTtcbn07XG52YXIgY3JlYXRlQXN5bmNUaHVuayA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4ge1xuICBmdW5jdGlvbiBjcmVhdGVBc3luY1RodW5rMih0eXBlUHJlZml4LCBwYXlsb2FkQ3JlYXRvciwgb3B0aW9ucykge1xuICAgIGNvbnN0IGZ1bGZpbGxlZCA9IGNyZWF0ZUFjdGlvbih0eXBlUHJlZml4ICsgXCIvZnVsZmlsbGVkXCIsIChwYXlsb2FkLCByZXF1ZXN0SWQsIGFyZywgbWV0YSkgPT4gKHtcbiAgICAgIHBheWxvYWQsXG4gICAgICBtZXRhOiB7XG4gICAgICAgIC4uLm1ldGEgfHwge30sXG4gICAgICAgIGFyZyxcbiAgICAgICAgcmVxdWVzdElkLFxuICAgICAgICByZXF1ZXN0U3RhdHVzOiBcImZ1bGZpbGxlZFwiXG4gICAgICB9XG4gICAgfSkpO1xuICAgIGNvbnN0IHBlbmRpbmcgPSBjcmVhdGVBY3Rpb24odHlwZVByZWZpeCArIFwiL3BlbmRpbmdcIiwgKHJlcXVlc3RJZCwgYXJnLCBtZXRhKSA9PiAoe1xuICAgICAgcGF5bG9hZDogdm9pZCAwLFxuICAgICAgbWV0YToge1xuICAgICAgICAuLi5tZXRhIHx8IHt9LFxuICAgICAgICBhcmcsXG4gICAgICAgIHJlcXVlc3RJZCxcbiAgICAgICAgcmVxdWVzdFN0YXR1czogXCJwZW5kaW5nXCJcbiAgICAgIH1cbiAgICB9KSk7XG4gICAgY29uc3QgcmVqZWN0ZWQgPSBjcmVhdGVBY3Rpb24odHlwZVByZWZpeCArIFwiL3JlamVjdGVkXCIsIChlcnJvciwgcmVxdWVzdElkLCBhcmcsIHBheWxvYWQsIG1ldGEpID0+ICh7XG4gICAgICBwYXlsb2FkLFxuICAgICAgZXJyb3I6IChvcHRpb25zICYmIG9wdGlvbnMuc2VyaWFsaXplRXJyb3IgfHwgbWluaVNlcmlhbGl6ZUVycm9yKShlcnJvciB8fCBcIlJlamVjdGVkXCIpLFxuICAgICAgbWV0YToge1xuICAgICAgICAuLi5tZXRhIHx8IHt9LFxuICAgICAgICBhcmcsXG4gICAgICAgIHJlcXVlc3RJZCxcbiAgICAgICAgcmVqZWN0ZWRXaXRoVmFsdWU6ICEhcGF5bG9hZCxcbiAgICAgICAgcmVxdWVzdFN0YXR1czogXCJyZWplY3RlZFwiLFxuICAgICAgICBhYm9ydGVkOiBlcnJvcj8ubmFtZSA9PT0gXCJBYm9ydEVycm9yXCIsXG4gICAgICAgIGNvbmRpdGlvbjogZXJyb3I/Lm5hbWUgPT09IFwiQ29uZGl0aW9uRXJyb3JcIlxuICAgICAgfVxuICAgIH0pKTtcbiAgICBmdW5jdGlvbiBhY3Rpb25DcmVhdG9yKGFyZykge1xuICAgICAgcmV0dXJuIChkaXNwYXRjaCwgZ2V0U3RhdGUsIGV4dHJhKSA9PiB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3RJZCA9IG9wdGlvbnM/LmlkR2VuZXJhdG9yID8gb3B0aW9ucy5pZEdlbmVyYXRvcihhcmcpIDogbmFub2lkKCk7XG4gICAgICAgIGNvbnN0IGFib3J0Q29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICAgICAgbGV0IGFib3J0SGFuZGxlcjtcbiAgICAgICAgbGV0IGFib3J0UmVhc29uO1xuICAgICAgICBmdW5jdGlvbiBhYm9ydChyZWFzb24pIHtcbiAgICAgICAgICBhYm9ydFJlYXNvbiA9IHJlYXNvbjtcbiAgICAgICAgICBhYm9ydENvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcm9taXNlID0gYXN5bmMgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgbGV0IGZpbmFsQWN0aW9uO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsZXQgY29uZGl0aW9uUmVzdWx0ID0gb3B0aW9ucz8uY29uZGl0aW9uPy4oYXJnLCB7XG4gICAgICAgICAgICAgIGdldFN0YXRlLFxuICAgICAgICAgICAgICBleHRyYVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoaXNUaGVuYWJsZShjb25kaXRpb25SZXN1bHQpKSB7XG4gICAgICAgICAgICAgIGNvbmRpdGlvblJlc3VsdCA9IGF3YWl0IGNvbmRpdGlvblJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb25kaXRpb25SZXN1bHQgPT09IGZhbHNlIHx8IGFib3J0Q29udHJvbGxlci5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgICAgICAgICB0aHJvdyB7XG4gICAgICAgICAgICAgICAgbmFtZTogXCJDb25kaXRpb25FcnJvclwiLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IFwiQWJvcnRlZCBkdWUgdG8gY29uZGl0aW9uIGNhbGxiYWNrIHJldHVybmluZyBmYWxzZS5cIlxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYWJvcnRlZFByb21pc2UgPSBuZXcgUHJvbWlzZSgoXywgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgIGFib3J0SGFuZGxlciA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICByZWplY3Qoe1xuICAgICAgICAgICAgICAgICAgbmFtZTogXCJBYm9ydEVycm9yXCIsXG4gICAgICAgICAgICAgICAgICBtZXNzYWdlOiBhYm9ydFJlYXNvbiB8fCBcIkFib3J0ZWRcIlxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBhYm9ydENvbnRyb2xsZXIuc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBhYm9ydEhhbmRsZXIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBkaXNwYXRjaChwZW5kaW5nKHJlcXVlc3RJZCwgYXJnLCBvcHRpb25zPy5nZXRQZW5kaW5nTWV0YT8uKHtcbiAgICAgICAgICAgICAgcmVxdWVzdElkLFxuICAgICAgICAgICAgICBhcmdcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgZ2V0U3RhdGUsXG4gICAgICAgICAgICAgIGV4dHJhXG4gICAgICAgICAgICB9KSkpO1xuICAgICAgICAgICAgZmluYWxBY3Rpb24gPSBhd2FpdCBQcm9taXNlLnJhY2UoW2Fib3J0ZWRQcm9taXNlLCBQcm9taXNlLnJlc29sdmUocGF5bG9hZENyZWF0b3IoYXJnLCB7XG4gICAgICAgICAgICAgIGRpc3BhdGNoLFxuICAgICAgICAgICAgICBnZXRTdGF0ZSxcbiAgICAgICAgICAgICAgZXh0cmEsXG4gICAgICAgICAgICAgIHJlcXVlc3RJZCxcbiAgICAgICAgICAgICAgc2lnbmFsOiBhYm9ydENvbnRyb2xsZXIuc2lnbmFsLFxuICAgICAgICAgICAgICBhYm9ydCxcbiAgICAgICAgICAgICAgcmVqZWN0V2l0aFZhbHVlOiAodmFsdWUsIG1ldGEpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFJlamVjdFdpdGhWYWx1ZSh2YWx1ZSwgbWV0YSk7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGZ1bGZpbGxXaXRoVmFsdWU6ICh2YWx1ZSwgbWV0YSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRnVsZmlsbFdpdGhNZXRhKHZhbHVlLCBtZXRhKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkpLnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgUmVqZWN0V2l0aFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgcmVzdWx0O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBGdWxmaWxsV2l0aE1ldGEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVsZmlsbGVkKHJlc3VsdC5wYXlsb2FkLCByZXF1ZXN0SWQsIGFyZywgcmVzdWx0Lm1ldGEpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBmdWxmaWxsZWQocmVzdWx0LCByZXF1ZXN0SWQsIGFyZyk7XG4gICAgICAgICAgICB9KV0pO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgZmluYWxBY3Rpb24gPSBlcnIgaW5zdGFuY2VvZiBSZWplY3RXaXRoVmFsdWUgPyByZWplY3RlZChudWxsLCByZXF1ZXN0SWQsIGFyZywgZXJyLnBheWxvYWQsIGVyci5tZXRhKSA6IHJlamVjdGVkKGVyciwgcmVxdWVzdElkLCBhcmcpO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBpZiAoYWJvcnRIYW5kbGVyKSB7XG4gICAgICAgICAgICAgIGFib3J0Q29udHJvbGxlci5zaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIGFib3J0SGFuZGxlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHNraXBEaXNwYXRjaCA9IG9wdGlvbnMgJiYgIW9wdGlvbnMuZGlzcGF0Y2hDb25kaXRpb25SZWplY3Rpb24gJiYgcmVqZWN0ZWQubWF0Y2goZmluYWxBY3Rpb24pICYmIGZpbmFsQWN0aW9uLm1ldGEuY29uZGl0aW9uO1xuICAgICAgICAgIGlmICghc2tpcERpc3BhdGNoKSB7XG4gICAgICAgICAgICBkaXNwYXRjaChmaW5hbEFjdGlvbik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBmaW5hbEFjdGlvbjtcbiAgICAgICAgfSgpO1xuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihwcm9taXNlLCB7XG4gICAgICAgICAgYWJvcnQsXG4gICAgICAgICAgcmVxdWVzdElkLFxuICAgICAgICAgIGFyZyxcbiAgICAgICAgICB1bndyYXAoKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZS50aGVuKHVud3JhcFJlc3VsdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBPYmplY3QuYXNzaWduKGFjdGlvbkNyZWF0b3IsIHtcbiAgICAgIHBlbmRpbmcsXG4gICAgICByZWplY3RlZCxcbiAgICAgIGZ1bGZpbGxlZCxcbiAgICAgIHNldHRsZWQ6IGlzQW55T2YocmVqZWN0ZWQsIGZ1bGZpbGxlZCksXG4gICAgICB0eXBlUHJlZml4XG4gICAgfSk7XG4gIH1cbiAgY3JlYXRlQXN5bmNUaHVuazIud2l0aFR5cGVzID0gKCkgPT4gY3JlYXRlQXN5bmNUaHVuazI7XG4gIHJldHVybiBjcmVhdGVBc3luY1RodW5rMjtcbn0pKCk7XG5mdW5jdGlvbiB1bndyYXBSZXN1bHQoYWN0aW9uKSB7XG4gIGlmIChhY3Rpb24ubWV0YSAmJiBhY3Rpb24ubWV0YS5yZWplY3RlZFdpdGhWYWx1ZSkge1xuICAgIHRocm93IGFjdGlvbi5wYXlsb2FkO1xuICB9XG4gIGlmIChhY3Rpb24uZXJyb3IpIHtcbiAgICB0aHJvdyBhY3Rpb24uZXJyb3I7XG4gIH1cbiAgcmV0dXJuIGFjdGlvbi5wYXlsb2FkO1xufVxuZnVuY3Rpb24gaXNUaGVuYWJsZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT09IG51bGwgJiYgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiB2YWx1ZS50aGVuID09PSBcImZ1bmN0aW9uXCI7XG59XG5cbi8vIHNyYy9jcmVhdGVTbGljZS50c1xudmFyIGFzeW5jVGh1bmtTeW1ib2wgPSAvKiBAX19QVVJFX18gKi8gU3ltYm9sLmZvcihcInJ0ay1zbGljZS1jcmVhdGVhc3luY3RodW5rXCIpO1xudmFyIGFzeW5jVGh1bmtDcmVhdG9yID0ge1xuICBbYXN5bmNUaHVua1N5bWJvbF06IGNyZWF0ZUFzeW5jVGh1bmtcbn07XG52YXIgUmVkdWNlclR5cGUgPSAvKiBAX19QVVJFX18gKi8gKChSZWR1Y2VyVHlwZTIpID0+IHtcbiAgUmVkdWNlclR5cGUyW1wicmVkdWNlclwiXSA9IFwicmVkdWNlclwiO1xuICBSZWR1Y2VyVHlwZTJbXCJyZWR1Y2VyV2l0aFByZXBhcmVcIl0gPSBcInJlZHVjZXJXaXRoUHJlcGFyZVwiO1xuICBSZWR1Y2VyVHlwZTJbXCJhc3luY1RodW5rXCJdID0gXCJhc3luY1RodW5rXCI7XG4gIHJldHVybiBSZWR1Y2VyVHlwZTI7XG59KShSZWR1Y2VyVHlwZSB8fCB7fSk7XG5mdW5jdGlvbiBnZXRUeXBlKHNsaWNlLCBhY3Rpb25LZXkpIHtcbiAgcmV0dXJuIGAke3NsaWNlfS8ke2FjdGlvbktleX1gO1xufVxuZnVuY3Rpb24gYnVpbGRDcmVhdGVTbGljZSh7XG4gIGNyZWF0b3JzXG59ID0ge30pIHtcbiAgY29uc3QgY0FUID0gY3JlYXRvcnM/LmFzeW5jVGh1bms/Llthc3luY1RodW5rU3ltYm9sXTtcbiAgcmV0dXJuIGZ1bmN0aW9uIGNyZWF0ZVNsaWNlMihvcHRpb25zKSB7XG4gICAgY29uc3Qge1xuICAgICAgbmFtZSxcbiAgICAgIHJlZHVjZXJQYXRoID0gbmFtZVxuICAgIH0gPSBvcHRpb25zO1xuICAgIGlmICghbmFtZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMTEpIDogXCJgbmFtZWAgaXMgYSByZXF1aXJlZCBvcHRpb24gZm9yIGNyZWF0ZVNsaWNlXCIpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHByb2Nlc3MgIT09IFwidW5kZWZpbmVkXCIgJiYgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwiZGV2ZWxvcG1lbnRcIikge1xuICAgICAgaWYgKG9wdGlvbnMuaW5pdGlhbFN0YXRlID09PSB2b2lkIDApIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIllvdSBtdXN0IHByb3ZpZGUgYW4gYGluaXRpYWxTdGF0ZWAgdmFsdWUgdGhhdCBpcyBub3QgYHVuZGVmaW5lZGAuIFlvdSBtYXkgaGF2ZSBtaXNzcGVsbGVkIGBpbml0aWFsU3RhdGVgXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCByZWR1Y2VycyA9ICh0eXBlb2Ygb3B0aW9ucy5yZWR1Y2VycyA9PT0gXCJmdW5jdGlvblwiID8gb3B0aW9ucy5yZWR1Y2VycyhidWlsZFJlZHVjZXJDcmVhdG9ycygpKSA6IG9wdGlvbnMucmVkdWNlcnMpIHx8IHt9O1xuICAgIGNvbnN0IHJlZHVjZXJOYW1lcyA9IE9iamVjdC5rZXlzKHJlZHVjZXJzKTtcbiAgICBjb25zdCBjb250ZXh0ID0ge1xuICAgICAgc2xpY2VDYXNlUmVkdWNlcnNCeU5hbWU6IHt9LFxuICAgICAgc2xpY2VDYXNlUmVkdWNlcnNCeVR5cGU6IHt9LFxuICAgICAgYWN0aW9uQ3JlYXRvcnM6IHt9LFxuICAgICAgc2xpY2VNYXRjaGVyczogW11cbiAgICB9O1xuICAgIGNvbnN0IGNvbnRleHRNZXRob2RzID0ge1xuICAgICAgYWRkQ2FzZSh0eXBlT3JBY3Rpb25DcmVhdG9yLCByZWR1Y2VyMikge1xuICAgICAgICBjb25zdCB0eXBlID0gdHlwZW9mIHR5cGVPckFjdGlvbkNyZWF0b3IgPT09IFwic3RyaW5nXCIgPyB0eXBlT3JBY3Rpb25DcmVhdG9yIDogdHlwZU9yQWN0aW9uQ3JlYXRvci50eXBlO1xuICAgICAgICBpZiAoIXR5cGUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgxMikgOiBcImBjb250ZXh0LmFkZENhc2VgIGNhbm5vdCBiZSBjYWxsZWQgd2l0aCBhbiBlbXB0eSBhY3Rpb24gdHlwZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSBpbiBjb250ZXh0LnNsaWNlQ2FzZVJlZHVjZXJzQnlUeXBlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMTMpIDogXCJgY29udGV4dC5hZGRDYXNlYCBjYW5ub3QgYmUgY2FsbGVkIHdpdGggdHdvIHJlZHVjZXJzIGZvciB0aGUgc2FtZSBhY3Rpb24gdHlwZTogXCIgKyB0eXBlKTtcbiAgICAgICAgfVxuICAgICAgICBjb250ZXh0LnNsaWNlQ2FzZVJlZHVjZXJzQnlUeXBlW3R5cGVdID0gcmVkdWNlcjI7XG4gICAgICAgIHJldHVybiBjb250ZXh0TWV0aG9kcztcbiAgICAgIH0sXG4gICAgICBhZGRNYXRjaGVyKG1hdGNoZXIsIHJlZHVjZXIyKSB7XG4gICAgICAgIGNvbnRleHQuc2xpY2VNYXRjaGVycy5wdXNoKHtcbiAgICAgICAgICBtYXRjaGVyLFxuICAgICAgICAgIHJlZHVjZXI6IHJlZHVjZXIyXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gY29udGV4dE1ldGhvZHM7XG4gICAgICB9LFxuICAgICAgZXhwb3NlQWN0aW9uKG5hbWUyLCBhY3Rpb25DcmVhdG9yKSB7XG4gICAgICAgIGNvbnRleHQuYWN0aW9uQ3JlYXRvcnNbbmFtZTJdID0gYWN0aW9uQ3JlYXRvcjtcbiAgICAgICAgcmV0dXJuIGNvbnRleHRNZXRob2RzO1xuICAgICAgfSxcbiAgICAgIGV4cG9zZUNhc2VSZWR1Y2VyKG5hbWUyLCByZWR1Y2VyMikge1xuICAgICAgICBjb250ZXh0LnNsaWNlQ2FzZVJlZHVjZXJzQnlOYW1lW25hbWUyXSA9IHJlZHVjZXIyO1xuICAgICAgICByZXR1cm4gY29udGV4dE1ldGhvZHM7XG4gICAgICB9XG4gICAgfTtcbiAgICByZWR1Y2VyTmFtZXMuZm9yRWFjaCgocmVkdWNlck5hbWUpID0+IHtcbiAgICAgIGNvbnN0IHJlZHVjZXJEZWZpbml0aW9uID0gcmVkdWNlcnNbcmVkdWNlck5hbWVdO1xuICAgICAgY29uc3QgcmVkdWNlckRldGFpbHMgPSB7XG4gICAgICAgIHJlZHVjZXJOYW1lLFxuICAgICAgICB0eXBlOiBnZXRUeXBlKG5hbWUsIHJlZHVjZXJOYW1lKSxcbiAgICAgICAgY3JlYXRlTm90YXRpb246IHR5cGVvZiBvcHRpb25zLnJlZHVjZXJzID09PSBcImZ1bmN0aW9uXCJcbiAgICAgIH07XG4gICAgICBpZiAoaXNBc3luY1RodW5rU2xpY2VSZWR1Y2VyRGVmaW5pdGlvbihyZWR1Y2VyRGVmaW5pdGlvbikpIHtcbiAgICAgICAgaGFuZGxlVGh1bmtDYXNlUmVkdWNlckRlZmluaXRpb24ocmVkdWNlckRldGFpbHMsIHJlZHVjZXJEZWZpbml0aW9uLCBjb250ZXh0TWV0aG9kcywgY0FUKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGhhbmRsZU5vcm1hbFJlZHVjZXJEZWZpbml0aW9uKHJlZHVjZXJEZXRhaWxzLCByZWR1Y2VyRGVmaW5pdGlvbiwgY29udGV4dE1ldGhvZHMpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGZ1bmN0aW9uIGJ1aWxkUmVkdWNlcigpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmV4dHJhUmVkdWNlcnMgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgxNCkgOiBcIlRoZSBvYmplY3Qgbm90YXRpb24gZm9yIGBjcmVhdGVTbGljZS5leHRyYVJlZHVjZXJzYCBoYXMgYmVlbiByZW1vdmVkLiBQbGVhc2UgdXNlIHRoZSAnYnVpbGRlciBjYWxsYmFjaycgbm90YXRpb24gaW5zdGVhZDogaHR0cHM6Ly9yZWR1eC10b29sa2l0LmpzLm9yZy9hcGkvY3JlYXRlU2xpY2VcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IFtleHRyYVJlZHVjZXJzID0ge30sIGFjdGlvbk1hdGNoZXJzID0gW10sIGRlZmF1bHRDYXNlUmVkdWNlciA9IHZvaWQgMF0gPSB0eXBlb2Ygb3B0aW9ucy5leHRyYVJlZHVjZXJzID09PSBcImZ1bmN0aW9uXCIgPyBleGVjdXRlUmVkdWNlckJ1aWxkZXJDYWxsYmFjayhvcHRpb25zLmV4dHJhUmVkdWNlcnMpIDogW29wdGlvbnMuZXh0cmFSZWR1Y2Vyc107XG4gICAgICBjb25zdCBmaW5hbENhc2VSZWR1Y2VycyA9IHtcbiAgICAgICAgLi4uZXh0cmFSZWR1Y2VycyxcbiAgICAgICAgLi4uY29udGV4dC5zbGljZUNhc2VSZWR1Y2Vyc0J5VHlwZVxuICAgICAgfTtcbiAgICAgIHJldHVybiBjcmVhdGVSZWR1Y2VyKG9wdGlvbnMuaW5pdGlhbFN0YXRlLCAoYnVpbGRlcikgPT4ge1xuICAgICAgICBmb3IgKGxldCBrZXkgaW4gZmluYWxDYXNlUmVkdWNlcnMpIHtcbiAgICAgICAgICBidWlsZGVyLmFkZENhc2Uoa2V5LCBmaW5hbENhc2VSZWR1Y2Vyc1trZXldKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBzTSBvZiBjb250ZXh0LnNsaWNlTWF0Y2hlcnMpIHtcbiAgICAgICAgICBidWlsZGVyLmFkZE1hdGNoZXIoc00ubWF0Y2hlciwgc00ucmVkdWNlcik7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgbSBvZiBhY3Rpb25NYXRjaGVycykge1xuICAgICAgICAgIGJ1aWxkZXIuYWRkTWF0Y2hlcihtLm1hdGNoZXIsIG0ucmVkdWNlcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlZmF1bHRDYXNlUmVkdWNlcikge1xuICAgICAgICAgIGJ1aWxkZXIuYWRkRGVmYXVsdENhc2UoZGVmYXVsdENhc2VSZWR1Y2VyKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IHNlbGVjdFNlbGYgPSAoc3RhdGUpID0+IHN0YXRlO1xuICAgIGNvbnN0IGluamVjdGVkU2VsZWN0b3JDYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgbGV0IF9yZWR1Y2VyO1xuICAgIGZ1bmN0aW9uIHJlZHVjZXIoc3RhdGUsIGFjdGlvbikge1xuICAgICAgaWYgKCFfcmVkdWNlcilcbiAgICAgICAgX3JlZHVjZXIgPSBidWlsZFJlZHVjZXIoKTtcbiAgICAgIHJldHVybiBfcmVkdWNlcihzdGF0ZSwgYWN0aW9uKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0SW5pdGlhbFN0YXRlKCkge1xuICAgICAgaWYgKCFfcmVkdWNlcilcbiAgICAgICAgX3JlZHVjZXIgPSBidWlsZFJlZHVjZXIoKTtcbiAgICAgIHJldHVybiBfcmVkdWNlci5nZXRJbml0aWFsU3RhdGUoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbWFrZVNlbGVjdG9yUHJvcHMocmVkdWNlclBhdGgyLCBpbmplY3RlZCA9IGZhbHNlKSB7XG4gICAgICBmdW5jdGlvbiBzZWxlY3RTbGljZShzdGF0ZSkge1xuICAgICAgICBsZXQgc2xpY2VTdGF0ZSA9IHN0YXRlW3JlZHVjZXJQYXRoMl07XG4gICAgICAgIGlmICh0eXBlb2Ygc2xpY2VTdGF0ZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgIGlmIChpbmplY3RlZCkge1xuICAgICAgICAgICAgc2xpY2VTdGF0ZSA9IGdldEluaXRpYWxTdGF0ZSgpO1xuICAgICAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgxNSkgOiBcInNlbGVjdFNsaWNlIHJldHVybmVkIHVuZGVmaW5lZCBmb3IgYW4gdW5pbmplY3RlZCBzbGljZSByZWR1Y2VyXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2xpY2VTdGF0ZTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGdldFNlbGVjdG9ycyhzZWxlY3RTdGF0ZSA9IHNlbGVjdFNlbGYpIHtcbiAgICAgICAgY29uc3Qgc2VsZWN0b3JDYWNoZSA9IGVtcGxhY2UoaW5qZWN0ZWRTZWxlY3RvckNhY2hlLCBpbmplY3RlZCwge1xuICAgICAgICAgIGluc2VydDogKCkgPT4gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKClcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBlbXBsYWNlKHNlbGVjdG9yQ2FjaGUsIHNlbGVjdFN0YXRlLCB7XG4gICAgICAgICAgaW5zZXJ0OiAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBtYXAgPSB7fTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW25hbWUyLCBzZWxlY3Rvcl0gb2YgT2JqZWN0LmVudHJpZXMob3B0aW9ucy5zZWxlY3RvcnMgPz8ge30pKSB7XG4gICAgICAgICAgICAgIG1hcFtuYW1lMl0gPSB3cmFwU2VsZWN0b3Ioc2VsZWN0b3IsIHNlbGVjdFN0YXRlLCBnZXRJbml0aWFsU3RhdGUsIGluamVjdGVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtYXA7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlZHVjZXJQYXRoOiByZWR1Y2VyUGF0aDIsXG4gICAgICAgIGdldFNlbGVjdG9ycyxcbiAgICAgICAgZ2V0IHNlbGVjdG9ycygpIHtcbiAgICAgICAgICByZXR1cm4gZ2V0U2VsZWN0b3JzKHNlbGVjdFNsaWNlKTtcbiAgICAgICAgfSxcbiAgICAgICAgc2VsZWN0U2xpY2VcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHNsaWNlID0ge1xuICAgICAgbmFtZSxcbiAgICAgIHJlZHVjZXIsXG4gICAgICBhY3Rpb25zOiBjb250ZXh0LmFjdGlvbkNyZWF0b3JzLFxuICAgICAgY2FzZVJlZHVjZXJzOiBjb250ZXh0LnNsaWNlQ2FzZVJlZHVjZXJzQnlOYW1lLFxuICAgICAgZ2V0SW5pdGlhbFN0YXRlLFxuICAgICAgLi4ubWFrZVNlbGVjdG9yUHJvcHMocmVkdWNlclBhdGgpLFxuICAgICAgaW5qZWN0SW50byhpbmplY3RhYmxlLCB7XG4gICAgICAgIHJlZHVjZXJQYXRoOiBwYXRoT3B0LFxuICAgICAgICAuLi5jb25maWdcbiAgICAgIH0gPSB7fSkge1xuICAgICAgICBjb25zdCBuZXdSZWR1Y2VyUGF0aCA9IHBhdGhPcHQgPz8gcmVkdWNlclBhdGg7XG4gICAgICAgIGluamVjdGFibGUuaW5qZWN0KHtcbiAgICAgICAgICByZWR1Y2VyUGF0aDogbmV3UmVkdWNlclBhdGgsXG4gICAgICAgICAgcmVkdWNlclxuICAgICAgICB9LCBjb25maWcpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIC4uLnNsaWNlLFxuICAgICAgICAgIC4uLm1ha2VTZWxlY3RvclByb3BzKG5ld1JlZHVjZXJQYXRoLCB0cnVlKVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIHNsaWNlO1xuICB9O1xufVxuZnVuY3Rpb24gd3JhcFNlbGVjdG9yKHNlbGVjdG9yLCBzZWxlY3RTdGF0ZSwgZ2V0SW5pdGlhbFN0YXRlLCBpbmplY3RlZCkge1xuICBmdW5jdGlvbiB3cmFwcGVyKHJvb3RTdGF0ZSwgLi4uYXJncykge1xuICAgIGxldCBzbGljZVN0YXRlID0gc2VsZWN0U3RhdGUocm9vdFN0YXRlKTtcbiAgICBpZiAodHlwZW9mIHNsaWNlU3RhdGUgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGlmIChpbmplY3RlZCkge1xuICAgICAgICBzbGljZVN0YXRlID0gZ2V0SW5pdGlhbFN0YXRlKCk7XG4gICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgxNikgOiBcInNlbGVjdFN0YXRlIHJldHVybmVkIHVuZGVmaW5lZCBmb3IgYW4gdW5pbmplY3RlZCBzbGljZSByZWR1Y2VyXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2VsZWN0b3Ioc2xpY2VTdGF0ZSwgLi4uYXJncyk7XG4gIH1cbiAgd3JhcHBlci51bndyYXBwZWQgPSBzZWxlY3RvcjtcbiAgcmV0dXJuIHdyYXBwZXI7XG59XG52YXIgY3JlYXRlU2xpY2UgPSAvKiBAX19QVVJFX18gKi8gYnVpbGRDcmVhdGVTbGljZSgpO1xuZnVuY3Rpb24gYnVpbGRSZWR1Y2VyQ3JlYXRvcnMoKSB7XG4gIGZ1bmN0aW9uIGFzeW5jVGh1bmsocGF5bG9hZENyZWF0b3IsIGNvbmZpZykge1xuICAgIHJldHVybiB7XG4gICAgICBfcmVkdWNlckRlZmluaXRpb25UeXBlOiBcImFzeW5jVGh1bmtcIiAvKiBhc3luY1RodW5rICovLFxuICAgICAgcGF5bG9hZENyZWF0b3IsXG4gICAgICAuLi5jb25maWdcbiAgICB9O1xuICB9XG4gIGFzeW5jVGh1bmsud2l0aFR5cGVzID0gKCkgPT4gYXN5bmNUaHVuaztcbiAgcmV0dXJuIHtcbiAgICByZWR1Y2VyKGNhc2VSZWR1Y2VyKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgIC8vIGhhY2sgc28gdGhlIHdyYXBwaW5nIGZ1bmN0aW9uIGhhcyB0aGUgc2FtZSBuYW1lIGFzIHRoZSBvcmlnaW5hbFxuICAgICAgICAvLyB3ZSBuZWVkIHRvIGNyZWF0ZSBhIHdyYXBwZXIgc28gdGhlIGByZWR1Y2VyRGVmaW5pdGlvblR5cGVgIGlzIG5vdCBhc3NpZ25lZCB0byB0aGUgb3JpZ2luYWxcbiAgICAgICAgW2Nhc2VSZWR1Y2VyLm5hbWVdKC4uLmFyZ3MpIHtcbiAgICAgICAgICByZXR1cm4gY2FzZVJlZHVjZXIoLi4uYXJncyk7XG4gICAgICAgIH1cbiAgICAgIH1bY2FzZVJlZHVjZXIubmFtZV0sIHtcbiAgICAgICAgX3JlZHVjZXJEZWZpbml0aW9uVHlwZTogXCJyZWR1Y2VyXCIgLyogcmVkdWNlciAqL1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBwcmVwYXJlZFJlZHVjZXIocHJlcGFyZSwgcmVkdWNlcikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgX3JlZHVjZXJEZWZpbml0aW9uVHlwZTogXCJyZWR1Y2VyV2l0aFByZXBhcmVcIiAvKiByZWR1Y2VyV2l0aFByZXBhcmUgKi8sXG4gICAgICAgIHByZXBhcmUsXG4gICAgICAgIHJlZHVjZXJcbiAgICAgIH07XG4gICAgfSxcbiAgICBhc3luY1RodW5rXG4gIH07XG59XG5mdW5jdGlvbiBoYW5kbGVOb3JtYWxSZWR1Y2VyRGVmaW5pdGlvbih7XG4gIHR5cGUsXG4gIHJlZHVjZXJOYW1lLFxuICBjcmVhdGVOb3RhdGlvblxufSwgbWF5YmVSZWR1Y2VyV2l0aFByZXBhcmUsIGNvbnRleHQpIHtcbiAgbGV0IGNhc2VSZWR1Y2VyO1xuICBsZXQgcHJlcGFyZUNhbGxiYWNrO1xuICBpZiAoXCJyZWR1Y2VyXCIgaW4gbWF5YmVSZWR1Y2VyV2l0aFByZXBhcmUpIHtcbiAgICBpZiAoY3JlYXRlTm90YXRpb24gJiYgIWlzQ2FzZVJlZHVjZXJXaXRoUHJlcGFyZURlZmluaXRpb24obWF5YmVSZWR1Y2VyV2l0aFByZXBhcmUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgxNykgOiBcIlBsZWFzZSB1c2UgdGhlIGBjcmVhdGUucHJlcGFyZWRSZWR1Y2VyYCBub3RhdGlvbiBmb3IgcHJlcGFyZWQgYWN0aW9uIGNyZWF0b3JzIHdpdGggdGhlIGBjcmVhdGVgIG5vdGF0aW9uLlwiKTtcbiAgICB9XG4gICAgY2FzZVJlZHVjZXIgPSBtYXliZVJlZHVjZXJXaXRoUHJlcGFyZS5yZWR1Y2VyO1xuICAgIHByZXBhcmVDYWxsYmFjayA9IG1heWJlUmVkdWNlcldpdGhQcmVwYXJlLnByZXBhcmU7XG4gIH0gZWxzZSB7XG4gICAgY2FzZVJlZHVjZXIgPSBtYXliZVJlZHVjZXJXaXRoUHJlcGFyZTtcbiAgfVxuICBjb250ZXh0LmFkZENhc2UodHlwZSwgY2FzZVJlZHVjZXIpLmV4cG9zZUNhc2VSZWR1Y2VyKHJlZHVjZXJOYW1lLCBjYXNlUmVkdWNlcikuZXhwb3NlQWN0aW9uKHJlZHVjZXJOYW1lLCBwcmVwYXJlQ2FsbGJhY2sgPyBjcmVhdGVBY3Rpb24odHlwZSwgcHJlcGFyZUNhbGxiYWNrKSA6IGNyZWF0ZUFjdGlvbih0eXBlKSk7XG59XG5mdW5jdGlvbiBpc0FzeW5jVGh1bmtTbGljZVJlZHVjZXJEZWZpbml0aW9uKHJlZHVjZXJEZWZpbml0aW9uKSB7XG4gIHJldHVybiByZWR1Y2VyRGVmaW5pdGlvbi5fcmVkdWNlckRlZmluaXRpb25UeXBlID09PSBcImFzeW5jVGh1bmtcIiAvKiBhc3luY1RodW5rICovO1xufVxuZnVuY3Rpb24gaXNDYXNlUmVkdWNlcldpdGhQcmVwYXJlRGVmaW5pdGlvbihyZWR1Y2VyRGVmaW5pdGlvbikge1xuICByZXR1cm4gcmVkdWNlckRlZmluaXRpb24uX3JlZHVjZXJEZWZpbml0aW9uVHlwZSA9PT0gXCJyZWR1Y2VyV2l0aFByZXBhcmVcIiAvKiByZWR1Y2VyV2l0aFByZXBhcmUgKi87XG59XG5mdW5jdGlvbiBoYW5kbGVUaHVua0Nhc2VSZWR1Y2VyRGVmaW5pdGlvbih7XG4gIHR5cGUsXG4gIHJlZHVjZXJOYW1lXG59LCByZWR1Y2VyRGVmaW5pdGlvbiwgY29udGV4dCwgY0FUKSB7XG4gIGlmICghY0FUKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMTgpIDogXCJDYW5ub3QgdXNlIGBjcmVhdGUuYXN5bmNUaHVua2AgaW4gdGhlIGJ1aWx0LWluIGBjcmVhdGVTbGljZWAuIFVzZSBgYnVpbGRDcmVhdGVTbGljZSh7IGNyZWF0b3JzOiB7IGFzeW5jVGh1bms6IGFzeW5jVGh1bmtDcmVhdG9yIH0gfSlgIHRvIGNyZWF0ZSBhIGN1c3RvbWlzZWQgdmVyc2lvbiBvZiBgY3JlYXRlU2xpY2VgLlwiKTtcbiAgfVxuICBjb25zdCB7XG4gICAgcGF5bG9hZENyZWF0b3IsXG4gICAgZnVsZmlsbGVkLFxuICAgIHBlbmRpbmcsXG4gICAgcmVqZWN0ZWQsXG4gICAgc2V0dGxlZCxcbiAgICBvcHRpb25zXG4gIH0gPSByZWR1Y2VyRGVmaW5pdGlvbjtcbiAgY29uc3QgdGh1bmsgPSBjQVQodHlwZSwgcGF5bG9hZENyZWF0b3IsIG9wdGlvbnMpO1xuICBjb250ZXh0LmV4cG9zZUFjdGlvbihyZWR1Y2VyTmFtZSwgdGh1bmspO1xuICBpZiAoZnVsZmlsbGVkKSB7XG4gICAgY29udGV4dC5hZGRDYXNlKHRodW5rLmZ1bGZpbGxlZCwgZnVsZmlsbGVkKTtcbiAgfVxuICBpZiAocGVuZGluZykge1xuICAgIGNvbnRleHQuYWRkQ2FzZSh0aHVuay5wZW5kaW5nLCBwZW5kaW5nKTtcbiAgfVxuICBpZiAocmVqZWN0ZWQpIHtcbiAgICBjb250ZXh0LmFkZENhc2UodGh1bmsucmVqZWN0ZWQsIHJlamVjdGVkKTtcbiAgfVxuICBpZiAoc2V0dGxlZCkge1xuICAgIGNvbnRleHQuYWRkTWF0Y2hlcih0aHVuay5zZXR0bGVkLCBzZXR0bGVkKTtcbiAgfVxuICBjb250ZXh0LmV4cG9zZUNhc2VSZWR1Y2VyKHJlZHVjZXJOYW1lLCB7XG4gICAgZnVsZmlsbGVkOiBmdWxmaWxsZWQgfHwgbm9vcCxcbiAgICBwZW5kaW5nOiBwZW5kaW5nIHx8IG5vb3AsXG4gICAgcmVqZWN0ZWQ6IHJlamVjdGVkIHx8IG5vb3AsXG4gICAgc2V0dGxlZDogc2V0dGxlZCB8fCBub29wXG4gIH0pO1xufVxuZnVuY3Rpb24gbm9vcCgpIHtcbn1cblxuLy8gc3JjL2VudGl0aWVzL2VudGl0eV9zdGF0ZS50c1xuZnVuY3Rpb24gZ2V0SW5pdGlhbEVudGl0eVN0YXRlKCkge1xuICByZXR1cm4ge1xuICAgIGlkczogW10sXG4gICAgZW50aXRpZXM6IHt9XG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVJbml0aWFsU3RhdGVGYWN0b3J5KHN0YXRlQWRhcHRlcikge1xuICBmdW5jdGlvbiBnZXRJbml0aWFsU3RhdGUoYWRkaXRpb25hbFN0YXRlID0ge30sIGVudGl0aWVzKSB7XG4gICAgY29uc3Qgc3RhdGUgPSBPYmplY3QuYXNzaWduKGdldEluaXRpYWxFbnRpdHlTdGF0ZSgpLCBhZGRpdGlvbmFsU3RhdGUpO1xuICAgIHJldHVybiBlbnRpdGllcyA/IHN0YXRlQWRhcHRlci5zZXRBbGwoc3RhdGUsIGVudGl0aWVzKSA6IHN0YXRlO1xuICB9XG4gIHJldHVybiB7XG4gICAgZ2V0SW5pdGlhbFN0YXRlXG4gIH07XG59XG5cbi8vIHNyYy9lbnRpdGllcy9zdGF0ZV9zZWxlY3RvcnMudHNcbmZ1bmN0aW9uIGNyZWF0ZVNlbGVjdG9yc0ZhY3RvcnkoKSB7XG4gIGZ1bmN0aW9uIGdldFNlbGVjdG9ycyhzZWxlY3RTdGF0ZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3Qge1xuICAgICAgY3JlYXRlU2VsZWN0b3I6IGNyZWF0ZVNlbGVjdG9yMiA9IGNyZWF0ZURyYWZ0U2FmZVNlbGVjdG9yXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgY29uc3Qgc2VsZWN0SWRzID0gKHN0YXRlKSA9PiBzdGF0ZS5pZHM7XG4gICAgY29uc3Qgc2VsZWN0RW50aXRpZXMgPSAoc3RhdGUpID0+IHN0YXRlLmVudGl0aWVzO1xuICAgIGNvbnN0IHNlbGVjdEFsbCA9IGNyZWF0ZVNlbGVjdG9yMihzZWxlY3RJZHMsIHNlbGVjdEVudGl0aWVzLCAoaWRzLCBlbnRpdGllcykgPT4gaWRzLm1hcCgoaWQpID0+IGVudGl0aWVzW2lkXSkpO1xuICAgIGNvbnN0IHNlbGVjdElkID0gKF8sIGlkKSA9PiBpZDtcbiAgICBjb25zdCBzZWxlY3RCeUlkID0gKGVudGl0aWVzLCBpZCkgPT4gZW50aXRpZXNbaWRdO1xuICAgIGNvbnN0IHNlbGVjdFRvdGFsID0gY3JlYXRlU2VsZWN0b3IyKHNlbGVjdElkcywgKGlkcykgPT4gaWRzLmxlbmd0aCk7XG4gICAgaWYgKCFzZWxlY3RTdGF0ZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc2VsZWN0SWRzLFxuICAgICAgICBzZWxlY3RFbnRpdGllcyxcbiAgICAgICAgc2VsZWN0QWxsLFxuICAgICAgICBzZWxlY3RUb3RhbCxcbiAgICAgICAgc2VsZWN0QnlJZDogY3JlYXRlU2VsZWN0b3IyKHNlbGVjdEVudGl0aWVzLCBzZWxlY3RJZCwgc2VsZWN0QnlJZClcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHNlbGVjdEdsb2JhbGl6ZWRFbnRpdGllcyA9IGNyZWF0ZVNlbGVjdG9yMihzZWxlY3RTdGF0ZSwgc2VsZWN0RW50aXRpZXMpO1xuICAgIHJldHVybiB7XG4gICAgICBzZWxlY3RJZHM6IGNyZWF0ZVNlbGVjdG9yMihzZWxlY3RTdGF0ZSwgc2VsZWN0SWRzKSxcbiAgICAgIHNlbGVjdEVudGl0aWVzOiBzZWxlY3RHbG9iYWxpemVkRW50aXRpZXMsXG4gICAgICBzZWxlY3RBbGw6IGNyZWF0ZVNlbGVjdG9yMihzZWxlY3RTdGF0ZSwgc2VsZWN0QWxsKSxcbiAgICAgIHNlbGVjdFRvdGFsOiBjcmVhdGVTZWxlY3RvcjIoc2VsZWN0U3RhdGUsIHNlbGVjdFRvdGFsKSxcbiAgICAgIHNlbGVjdEJ5SWQ6IGNyZWF0ZVNlbGVjdG9yMihzZWxlY3RHbG9iYWxpemVkRW50aXRpZXMsIHNlbGVjdElkLCBzZWxlY3RCeUlkKVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBnZXRTZWxlY3RvcnNcbiAgfTtcbn1cblxuLy8gc3JjL2VudGl0aWVzL3N0YXRlX2FkYXB0ZXIudHNcbmltcG9ydCB7IHByb2R1Y2UgYXMgY3JlYXRlTmV4dFN0YXRlMywgaXNEcmFmdCBhcyBpc0RyYWZ0MyB9IGZyb20gXCJpbW1lclwiO1xudmFyIGlzRHJhZnRUeXBlZCA9IGlzRHJhZnQzO1xuZnVuY3Rpb24gY3JlYXRlU2luZ2xlQXJndW1lbnRTdGF0ZU9wZXJhdG9yKG11dGF0b3IpIHtcbiAgY29uc3Qgb3BlcmF0b3IgPSBjcmVhdGVTdGF0ZU9wZXJhdG9yKChfLCBzdGF0ZSkgPT4gbXV0YXRvcihzdGF0ZSkpO1xuICByZXR1cm4gZnVuY3Rpb24gb3BlcmF0aW9uKHN0YXRlKSB7XG4gICAgcmV0dXJuIG9wZXJhdG9yKHN0YXRlLCB2b2lkIDApO1xuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlU3RhdGVPcGVyYXRvcihtdXRhdG9yKSB7XG4gIHJldHVybiBmdW5jdGlvbiBvcGVyYXRpb24oc3RhdGUsIGFyZykge1xuICAgIGZ1bmN0aW9uIGlzUGF5bG9hZEFjdGlvbkFyZ3VtZW50KGFyZzIpIHtcbiAgICAgIHJldHVybiBpc0ZTQShhcmcyKTtcbiAgICB9XG4gICAgY29uc3QgcnVuTXV0YXRvciA9IChkcmFmdCkgPT4ge1xuICAgICAgaWYgKGlzUGF5bG9hZEFjdGlvbkFyZ3VtZW50KGFyZykpIHtcbiAgICAgICAgbXV0YXRvcihhcmcucGF5bG9hZCwgZHJhZnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbXV0YXRvcihhcmcsIGRyYWZ0KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGlmIChpc0RyYWZ0VHlwZWQoc3RhdGUpKSB7XG4gICAgICBydW5NdXRhdG9yKHN0YXRlKTtcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZU5leHRTdGF0ZTMoc3RhdGUsIHJ1bk11dGF0b3IpO1xuICB9O1xufVxuXG4vLyBzcmMvZW50aXRpZXMvdXRpbHMudHNcbmZ1bmN0aW9uIHNlbGVjdElkVmFsdWUoZW50aXR5LCBzZWxlY3RJZCkge1xuICBjb25zdCBrZXkgPSBzZWxlY3RJZChlbnRpdHkpO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIGtleSA9PT0gdm9pZCAwKSB7XG4gICAgY29uc29sZS53YXJuKFwiVGhlIGVudGl0eSBwYXNzZWQgdG8gdGhlIGBzZWxlY3RJZGAgaW1wbGVtZW50YXRpb24gcmV0dXJuZWQgdW5kZWZpbmVkLlwiLCBcIllvdSBzaG91bGQgcHJvYmFibHkgcHJvdmlkZSB5b3VyIG93biBgc2VsZWN0SWRgIGltcGxlbWVudGF0aW9uLlwiLCBcIlRoZSBlbnRpdHkgdGhhdCB3YXMgcGFzc2VkOlwiLCBlbnRpdHksIFwiVGhlIGBzZWxlY3RJZGAgaW1wbGVtZW50YXRpb246XCIsIHNlbGVjdElkLnRvU3RyaW5nKCkpO1xuICB9XG4gIHJldHVybiBrZXk7XG59XG5mdW5jdGlvbiBlbnN1cmVFbnRpdGllc0FycmF5KGVudGl0aWVzKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShlbnRpdGllcykpIHtcbiAgICBlbnRpdGllcyA9IE9iamVjdC52YWx1ZXMoZW50aXRpZXMpO1xuICB9XG4gIHJldHVybiBlbnRpdGllcztcbn1cbmZ1bmN0aW9uIHNwbGl0QWRkZWRVcGRhdGVkRW50aXRpZXMobmV3RW50aXRpZXMsIHNlbGVjdElkLCBzdGF0ZSkge1xuICBuZXdFbnRpdGllcyA9IGVuc3VyZUVudGl0aWVzQXJyYXkobmV3RW50aXRpZXMpO1xuICBjb25zdCBhZGRlZCA9IFtdO1xuICBjb25zdCB1cGRhdGVkID0gW107XG4gIGZvciAoY29uc3QgZW50aXR5IG9mIG5ld0VudGl0aWVzKSB7XG4gICAgY29uc3QgaWQgPSBzZWxlY3RJZFZhbHVlKGVudGl0eSwgc2VsZWN0SWQpO1xuICAgIGlmIChpZCBpbiBzdGF0ZS5lbnRpdGllcykge1xuICAgICAgdXBkYXRlZC5wdXNoKHtcbiAgICAgICAgaWQsXG4gICAgICAgIGNoYW5nZXM6IGVudGl0eVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFkZGVkLnB1c2goZW50aXR5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFthZGRlZCwgdXBkYXRlZF07XG59XG5cbi8vIHNyYy9lbnRpdGllcy91bnNvcnRlZF9zdGF0ZV9hZGFwdGVyLnRzXG5mdW5jdGlvbiBjcmVhdGVVbnNvcnRlZFN0YXRlQWRhcHRlcihzZWxlY3RJZCkge1xuICBmdW5jdGlvbiBhZGRPbmVNdXRhYmx5KGVudGl0eSwgc3RhdGUpIHtcbiAgICBjb25zdCBrZXkgPSBzZWxlY3RJZFZhbHVlKGVudGl0eSwgc2VsZWN0SWQpO1xuICAgIGlmIChrZXkgaW4gc3RhdGUuZW50aXRpZXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3RhdGUuaWRzLnB1c2goa2V5KTtcbiAgICBzdGF0ZS5lbnRpdGllc1trZXldID0gZW50aXR5O1xuICB9XG4gIGZ1bmN0aW9uIGFkZE1hbnlNdXRhYmx5KG5ld0VudGl0aWVzLCBzdGF0ZSkge1xuICAgIG5ld0VudGl0aWVzID0gZW5zdXJlRW50aXRpZXNBcnJheShuZXdFbnRpdGllcyk7XG4gICAgZm9yIChjb25zdCBlbnRpdHkgb2YgbmV3RW50aXRpZXMpIHtcbiAgICAgIGFkZE9uZU11dGFibHkoZW50aXR5LCBzdGF0ZSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHNldE9uZU11dGFibHkoZW50aXR5LCBzdGF0ZSkge1xuICAgIGNvbnN0IGtleSA9IHNlbGVjdElkVmFsdWUoZW50aXR5LCBzZWxlY3RJZCk7XG4gICAgaWYgKCEoa2V5IGluIHN0YXRlLmVudGl0aWVzKSkge1xuICAgICAgc3RhdGUuaWRzLnB1c2goa2V5KTtcbiAgICB9XG4gICAgO1xuICAgIHN0YXRlLmVudGl0aWVzW2tleV0gPSBlbnRpdHk7XG4gIH1cbiAgZnVuY3Rpb24gc2V0TWFueU11dGFibHkobmV3RW50aXRpZXMsIHN0YXRlKSB7XG4gICAgbmV3RW50aXRpZXMgPSBlbnN1cmVFbnRpdGllc0FycmF5KG5ld0VudGl0aWVzKTtcbiAgICBmb3IgKGNvbnN0IGVudGl0eSBvZiBuZXdFbnRpdGllcykge1xuICAgICAgc2V0T25lTXV0YWJseShlbnRpdHksIHN0YXRlKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gc2V0QWxsTXV0YWJseShuZXdFbnRpdGllcywgc3RhdGUpIHtcbiAgICBuZXdFbnRpdGllcyA9IGVuc3VyZUVudGl0aWVzQXJyYXkobmV3RW50aXRpZXMpO1xuICAgIHN0YXRlLmlkcyA9IFtdO1xuICAgIHN0YXRlLmVudGl0aWVzID0ge307XG4gICAgYWRkTWFueU11dGFibHkobmV3RW50aXRpZXMsIHN0YXRlKTtcbiAgfVxuICBmdW5jdGlvbiByZW1vdmVPbmVNdXRhYmx5KGtleSwgc3RhdGUpIHtcbiAgICByZXR1cm4gcmVtb3ZlTWFueU11dGFibHkoW2tleV0sIHN0YXRlKTtcbiAgfVxuICBmdW5jdGlvbiByZW1vdmVNYW55TXV0YWJseShrZXlzLCBzdGF0ZSkge1xuICAgIGxldCBkaWRNdXRhdGUgPSBmYWxzZTtcbiAgICBrZXlzLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgaWYgKGtleSBpbiBzdGF0ZS5lbnRpdGllcykge1xuICAgICAgICBkZWxldGUgc3RhdGUuZW50aXRpZXNba2V5XTtcbiAgICAgICAgZGlkTXV0YXRlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoZGlkTXV0YXRlKSB7XG4gICAgICBzdGF0ZS5pZHMgPSBzdGF0ZS5pZHMuZmlsdGVyKChpZCkgPT4gaWQgaW4gc3RhdGUuZW50aXRpZXMpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiByZW1vdmVBbGxNdXRhYmx5KHN0YXRlKSB7XG4gICAgT2JqZWN0LmFzc2lnbihzdGF0ZSwge1xuICAgICAgaWRzOiBbXSxcbiAgICAgIGVudGl0aWVzOiB7fVxuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIHRha2VOZXdLZXkoa2V5cywgdXBkYXRlLCBzdGF0ZSkge1xuICAgIGNvbnN0IG9yaWdpbmFsMyA9IHN0YXRlLmVudGl0aWVzW3VwZGF0ZS5pZF07XG4gICAgaWYgKG9yaWdpbmFsMyA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHVwZGF0ZWQgPSBPYmplY3QuYXNzaWduKHt9LCBvcmlnaW5hbDMsIHVwZGF0ZS5jaGFuZ2VzKTtcbiAgICBjb25zdCBuZXdLZXkgPSBzZWxlY3RJZFZhbHVlKHVwZGF0ZWQsIHNlbGVjdElkKTtcbiAgICBjb25zdCBoYXNOZXdLZXkgPSBuZXdLZXkgIT09IHVwZGF0ZS5pZDtcbiAgICBpZiAoaGFzTmV3S2V5KSB7XG4gICAgICBrZXlzW3VwZGF0ZS5pZF0gPSBuZXdLZXk7XG4gICAgICBkZWxldGUgc3RhdGUuZW50aXRpZXNbdXBkYXRlLmlkXTtcbiAgICB9XG4gICAgO1xuICAgIHN0YXRlLmVudGl0aWVzW25ld0tleV0gPSB1cGRhdGVkO1xuICAgIHJldHVybiBoYXNOZXdLZXk7XG4gIH1cbiAgZnVuY3Rpb24gdXBkYXRlT25lTXV0YWJseSh1cGRhdGUsIHN0YXRlKSB7XG4gICAgcmV0dXJuIHVwZGF0ZU1hbnlNdXRhYmx5KFt1cGRhdGVdLCBzdGF0ZSk7XG4gIH1cbiAgZnVuY3Rpb24gdXBkYXRlTWFueU11dGFibHkodXBkYXRlcywgc3RhdGUpIHtcbiAgICBjb25zdCBuZXdLZXlzID0ge307XG4gICAgY29uc3QgdXBkYXRlc1BlckVudGl0eSA9IHt9O1xuICAgIHVwZGF0ZXMuZm9yRWFjaCgodXBkYXRlKSA9PiB7XG4gICAgICBpZiAodXBkYXRlLmlkIGluIHN0YXRlLmVudGl0aWVzKSB7XG4gICAgICAgIHVwZGF0ZXNQZXJFbnRpdHlbdXBkYXRlLmlkXSA9IHtcbiAgICAgICAgICBpZDogdXBkYXRlLmlkLFxuICAgICAgICAgIC8vIFNwcmVhZHMgaWdub3JlIGZhbHN5IHZhbHVlcywgc28gdGhpcyB3b3JrcyBldmVuIGlmIHRoZXJlIGlzbid0XG4gICAgICAgICAgLy8gYW4gZXhpc3RpbmcgdXBkYXRlIGFscmVhZHkgYXQgdGhpcyBrZXlcbiAgICAgICAgICBjaGFuZ2VzOiB7XG4gICAgICAgICAgICAuLi51cGRhdGVzUGVyRW50aXR5W3VwZGF0ZS5pZF0gPyB1cGRhdGVzUGVyRW50aXR5W3VwZGF0ZS5pZF0uY2hhbmdlcyA6IG51bGwsXG4gICAgICAgICAgICAuLi51cGRhdGUuY2hhbmdlc1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB1cGRhdGVzID0gT2JqZWN0LnZhbHVlcyh1cGRhdGVzUGVyRW50aXR5KTtcbiAgICBjb25zdCBkaWRNdXRhdGVFbnRpdGllcyA9IHVwZGF0ZXMubGVuZ3RoID4gMDtcbiAgICBpZiAoZGlkTXV0YXRlRW50aXRpZXMpIHtcbiAgICAgIGNvbnN0IGRpZE11dGF0ZUlkcyA9IHVwZGF0ZXMuZmlsdGVyKCh1cGRhdGUpID0+IHRha2VOZXdLZXkobmV3S2V5cywgdXBkYXRlLCBzdGF0ZSkpLmxlbmd0aCA+IDA7XG4gICAgICBpZiAoZGlkTXV0YXRlSWRzKSB7XG4gICAgICAgIHN0YXRlLmlkcyA9IE9iamVjdC52YWx1ZXMoc3RhdGUuZW50aXRpZXMpLm1hcCgoZSkgPT4gc2VsZWN0SWRWYWx1ZShlLCBzZWxlY3RJZCkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmdW5jdGlvbiB1cHNlcnRPbmVNdXRhYmx5KGVudGl0eSwgc3RhdGUpIHtcbiAgICByZXR1cm4gdXBzZXJ0TWFueU11dGFibHkoW2VudGl0eV0sIHN0YXRlKTtcbiAgfVxuICBmdW5jdGlvbiB1cHNlcnRNYW55TXV0YWJseShuZXdFbnRpdGllcywgc3RhdGUpIHtcbiAgICBjb25zdCBbYWRkZWQsIHVwZGF0ZWRdID0gc3BsaXRBZGRlZFVwZGF0ZWRFbnRpdGllcyhuZXdFbnRpdGllcywgc2VsZWN0SWQsIHN0YXRlKTtcbiAgICB1cGRhdGVNYW55TXV0YWJseSh1cGRhdGVkLCBzdGF0ZSk7XG4gICAgYWRkTWFueU11dGFibHkoYWRkZWQsIHN0YXRlKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHJlbW92ZUFsbDogY3JlYXRlU2luZ2xlQXJndW1lbnRTdGF0ZU9wZXJhdG9yKHJlbW92ZUFsbE11dGFibHkpLFxuICAgIGFkZE9uZTogY3JlYXRlU3RhdGVPcGVyYXRvcihhZGRPbmVNdXRhYmx5KSxcbiAgICBhZGRNYW55OiBjcmVhdGVTdGF0ZU9wZXJhdG9yKGFkZE1hbnlNdXRhYmx5KSxcbiAgICBzZXRPbmU6IGNyZWF0ZVN0YXRlT3BlcmF0b3Ioc2V0T25lTXV0YWJseSksXG4gICAgc2V0TWFueTogY3JlYXRlU3RhdGVPcGVyYXRvcihzZXRNYW55TXV0YWJseSksXG4gICAgc2V0QWxsOiBjcmVhdGVTdGF0ZU9wZXJhdG9yKHNldEFsbE11dGFibHkpLFxuICAgIHVwZGF0ZU9uZTogY3JlYXRlU3RhdGVPcGVyYXRvcih1cGRhdGVPbmVNdXRhYmx5KSxcbiAgICB1cGRhdGVNYW55OiBjcmVhdGVTdGF0ZU9wZXJhdG9yKHVwZGF0ZU1hbnlNdXRhYmx5KSxcbiAgICB1cHNlcnRPbmU6IGNyZWF0ZVN0YXRlT3BlcmF0b3IodXBzZXJ0T25lTXV0YWJseSksXG4gICAgdXBzZXJ0TWFueTogY3JlYXRlU3RhdGVPcGVyYXRvcih1cHNlcnRNYW55TXV0YWJseSksXG4gICAgcmVtb3ZlT25lOiBjcmVhdGVTdGF0ZU9wZXJhdG9yKHJlbW92ZU9uZU11dGFibHkpLFxuICAgIHJlbW92ZU1hbnk6IGNyZWF0ZVN0YXRlT3BlcmF0b3IocmVtb3ZlTWFueU11dGFibHkpXG4gIH07XG59XG5cbi8vIHNyYy9lbnRpdGllcy9zb3J0ZWRfc3RhdGVfYWRhcHRlci50c1xuZnVuY3Rpb24gY3JlYXRlU29ydGVkU3RhdGVBZGFwdGVyKHNlbGVjdElkLCBzb3J0KSB7XG4gIGNvbnN0IHtcbiAgICByZW1vdmVPbmUsXG4gICAgcmVtb3ZlTWFueSxcbiAgICByZW1vdmVBbGxcbiAgfSA9IGNyZWF0ZVVuc29ydGVkU3RhdGVBZGFwdGVyKHNlbGVjdElkKTtcbiAgZnVuY3Rpb24gYWRkT25lTXV0YWJseShlbnRpdHksIHN0YXRlKSB7XG4gICAgcmV0dXJuIGFkZE1hbnlNdXRhYmx5KFtlbnRpdHldLCBzdGF0ZSk7XG4gIH1cbiAgZnVuY3Rpb24gYWRkTWFueU11dGFibHkobmV3RW50aXRpZXMsIHN0YXRlKSB7XG4gICAgbmV3RW50aXRpZXMgPSBlbnN1cmVFbnRpdGllc0FycmF5KG5ld0VudGl0aWVzKTtcbiAgICBjb25zdCBtb2RlbHMgPSBuZXdFbnRpdGllcy5maWx0ZXIoKG1vZGVsKSA9PiAhKHNlbGVjdElkVmFsdWUobW9kZWwsIHNlbGVjdElkKSBpbiBzdGF0ZS5lbnRpdGllcykpO1xuICAgIGlmIChtb2RlbHMubGVuZ3RoICE9PSAwKSB7XG4gICAgICBtZXJnZShtb2RlbHMsIHN0YXRlKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gc2V0T25lTXV0YWJseShlbnRpdHksIHN0YXRlKSB7XG4gICAgcmV0dXJuIHNldE1hbnlNdXRhYmx5KFtlbnRpdHldLCBzdGF0ZSk7XG4gIH1cbiAgZnVuY3Rpb24gc2V0TWFueU11dGFibHkobmV3RW50aXRpZXMsIHN0YXRlKSB7XG4gICAgbmV3RW50aXRpZXMgPSBlbnN1cmVFbnRpdGllc0FycmF5KG5ld0VudGl0aWVzKTtcbiAgICBpZiAobmV3RW50aXRpZXMubGVuZ3RoICE9PSAwKSB7XG4gICAgICBtZXJnZShuZXdFbnRpdGllcywgc3RhdGUpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBzZXRBbGxNdXRhYmx5KG5ld0VudGl0aWVzLCBzdGF0ZSkge1xuICAgIG5ld0VudGl0aWVzID0gZW5zdXJlRW50aXRpZXNBcnJheShuZXdFbnRpdGllcyk7XG4gICAgc3RhdGUuZW50aXRpZXMgPSB7fTtcbiAgICBzdGF0ZS5pZHMgPSBbXTtcbiAgICBhZGRNYW55TXV0YWJseShuZXdFbnRpdGllcywgc3RhdGUpO1xuICB9XG4gIGZ1bmN0aW9uIHVwZGF0ZU9uZU11dGFibHkodXBkYXRlLCBzdGF0ZSkge1xuICAgIHJldHVybiB1cGRhdGVNYW55TXV0YWJseShbdXBkYXRlXSwgc3RhdGUpO1xuICB9XG4gIGZ1bmN0aW9uIHVwZGF0ZU1hbnlNdXRhYmx5KHVwZGF0ZXMsIHN0YXRlKSB7XG4gICAgbGV0IGFwcGxpZWRVcGRhdGVzID0gZmFsc2U7XG4gICAgZm9yIChsZXQgdXBkYXRlIG9mIHVwZGF0ZXMpIHtcbiAgICAgIGNvbnN0IGVudGl0eSA9IHN0YXRlLmVudGl0aWVzW3VwZGF0ZS5pZF07XG4gICAgICBpZiAoIWVudGl0eSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGFwcGxpZWRVcGRhdGVzID0gdHJ1ZTtcbiAgICAgIE9iamVjdC5hc3NpZ24oZW50aXR5LCB1cGRhdGUuY2hhbmdlcyk7XG4gICAgICBjb25zdCBuZXdJZCA9IHNlbGVjdElkKGVudGl0eSk7XG4gICAgICBpZiAodXBkYXRlLmlkICE9PSBuZXdJZCkge1xuICAgICAgICBkZWxldGUgc3RhdGUuZW50aXRpZXNbdXBkYXRlLmlkXTtcbiAgICAgICAgc3RhdGUuZW50aXRpZXNbbmV3SWRdID0gZW50aXR5O1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoYXBwbGllZFVwZGF0ZXMpIHtcbiAgICAgIHJlc29ydEVudGl0aWVzKHN0YXRlKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gdXBzZXJ0T25lTXV0YWJseShlbnRpdHksIHN0YXRlKSB7XG4gICAgcmV0dXJuIHVwc2VydE1hbnlNdXRhYmx5KFtlbnRpdHldLCBzdGF0ZSk7XG4gIH1cbiAgZnVuY3Rpb24gdXBzZXJ0TWFueU11dGFibHkobmV3RW50aXRpZXMsIHN0YXRlKSB7XG4gICAgY29uc3QgW2FkZGVkLCB1cGRhdGVkXSA9IHNwbGl0QWRkZWRVcGRhdGVkRW50aXRpZXMobmV3RW50aXRpZXMsIHNlbGVjdElkLCBzdGF0ZSk7XG4gICAgdXBkYXRlTWFueU11dGFibHkodXBkYXRlZCwgc3RhdGUpO1xuICAgIGFkZE1hbnlNdXRhYmx5KGFkZGVkLCBzdGF0ZSk7XG4gIH1cbiAgZnVuY3Rpb24gYXJlQXJyYXlzRXF1YWwoYSwgYikge1xuICAgIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aCAmJiBpIDwgYi5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGFbaV0gPT09IGJbaV0pIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGZ1bmN0aW9uIG1lcmdlKG1vZGVscywgc3RhdGUpIHtcbiAgICBtb2RlbHMuZm9yRWFjaCgobW9kZWwpID0+IHtcbiAgICAgIDtcbiAgICAgIHN0YXRlLmVudGl0aWVzW3NlbGVjdElkKG1vZGVsKV0gPSBtb2RlbDtcbiAgICB9KTtcbiAgICByZXNvcnRFbnRpdGllcyhzdGF0ZSk7XG4gIH1cbiAgZnVuY3Rpb24gcmVzb3J0RW50aXRpZXMoc3RhdGUpIHtcbiAgICBjb25zdCBhbGxFbnRpdGllcyA9IE9iamVjdC52YWx1ZXMoc3RhdGUuZW50aXRpZXMpO1xuICAgIGFsbEVudGl0aWVzLnNvcnQoc29ydCk7XG4gICAgY29uc3QgbmV3U29ydGVkSWRzID0gYWxsRW50aXRpZXMubWFwKHNlbGVjdElkKTtcbiAgICBjb25zdCB7XG4gICAgICBpZHNcbiAgICB9ID0gc3RhdGU7XG4gICAgaWYgKCFhcmVBcnJheXNFcXVhbChpZHMsIG5ld1NvcnRlZElkcykpIHtcbiAgICAgIHN0YXRlLmlkcyA9IG5ld1NvcnRlZElkcztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICByZW1vdmVPbmUsXG4gICAgcmVtb3ZlTWFueSxcbiAgICByZW1vdmVBbGwsXG4gICAgYWRkT25lOiBjcmVhdGVTdGF0ZU9wZXJhdG9yKGFkZE9uZU11dGFibHkpLFxuICAgIHVwZGF0ZU9uZTogY3JlYXRlU3RhdGVPcGVyYXRvcih1cGRhdGVPbmVNdXRhYmx5KSxcbiAgICB1cHNlcnRPbmU6IGNyZWF0ZVN0YXRlT3BlcmF0b3IodXBzZXJ0T25lTXV0YWJseSksXG4gICAgc2V0T25lOiBjcmVhdGVTdGF0ZU9wZXJhdG9yKHNldE9uZU11dGFibHkpLFxuICAgIHNldE1hbnk6IGNyZWF0ZVN0YXRlT3BlcmF0b3Ioc2V0TWFueU11dGFibHkpLFxuICAgIHNldEFsbDogY3JlYXRlU3RhdGVPcGVyYXRvcihzZXRBbGxNdXRhYmx5KSxcbiAgICBhZGRNYW55OiBjcmVhdGVTdGF0ZU9wZXJhdG9yKGFkZE1hbnlNdXRhYmx5KSxcbiAgICB1cGRhdGVNYW55OiBjcmVhdGVTdGF0ZU9wZXJhdG9yKHVwZGF0ZU1hbnlNdXRhYmx5KSxcbiAgICB1cHNlcnRNYW55OiBjcmVhdGVTdGF0ZU9wZXJhdG9yKHVwc2VydE1hbnlNdXRhYmx5KVxuICB9O1xufVxuXG4vLyBzcmMvZW50aXRpZXMvY3JlYXRlX2FkYXB0ZXIudHNcbmZ1bmN0aW9uIGNyZWF0ZUVudGl0eUFkYXB0ZXIob3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHtcbiAgICBzZWxlY3RJZCxcbiAgICBzb3J0Q29tcGFyZXJcbiAgfSA9IHtcbiAgICBzb3J0Q29tcGFyZXI6IGZhbHNlLFxuICAgIHNlbGVjdElkOiAoaW5zdGFuY2UpID0+IGluc3RhbmNlLmlkLFxuICAgIC4uLm9wdGlvbnNcbiAgfTtcbiAgY29uc3Qgc3RhdGVBZGFwdGVyID0gc29ydENvbXBhcmVyID8gY3JlYXRlU29ydGVkU3RhdGVBZGFwdGVyKHNlbGVjdElkLCBzb3J0Q29tcGFyZXIpIDogY3JlYXRlVW5zb3J0ZWRTdGF0ZUFkYXB0ZXIoc2VsZWN0SWQpO1xuICBjb25zdCBzdGF0ZUZhY3RvcnkgPSBjcmVhdGVJbml0aWFsU3RhdGVGYWN0b3J5KHN0YXRlQWRhcHRlcik7XG4gIGNvbnN0IHNlbGVjdG9yc0ZhY3RvcnkgPSBjcmVhdGVTZWxlY3RvcnNGYWN0b3J5KCk7XG4gIHJldHVybiB7XG4gICAgc2VsZWN0SWQsXG4gICAgc29ydENvbXBhcmVyLFxuICAgIC4uLnN0YXRlRmFjdG9yeSxcbiAgICAuLi5zZWxlY3RvcnNGYWN0b3J5LFxuICAgIC4uLnN0YXRlQWRhcHRlclxuICB9O1xufVxuXG4vLyBzcmMvbGlzdGVuZXJNaWRkbGV3YXJlL2luZGV4LnRzXG5pbXBvcnQgeyBpc0FjdGlvbiBhcyBpc0FjdGlvbjMgfSBmcm9tIFwicmVkdXhcIjtcblxuLy8gc3JjL2xpc3RlbmVyTWlkZGxld2FyZS9leGNlcHRpb25zLnRzXG52YXIgdGFzayA9IFwidGFza1wiO1xudmFyIGxpc3RlbmVyID0gXCJsaXN0ZW5lclwiO1xudmFyIGNvbXBsZXRlZCA9IFwiY29tcGxldGVkXCI7XG52YXIgY2FuY2VsbGVkID0gXCJjYW5jZWxsZWRcIjtcbnZhciB0YXNrQ2FuY2VsbGVkID0gYHRhc2stJHtjYW5jZWxsZWR9YDtcbnZhciB0YXNrQ29tcGxldGVkID0gYHRhc2stJHtjb21wbGV0ZWR9YDtcbnZhciBsaXN0ZW5lckNhbmNlbGxlZCA9IGAke2xpc3RlbmVyfS0ke2NhbmNlbGxlZH1gO1xudmFyIGxpc3RlbmVyQ29tcGxldGVkID0gYCR7bGlzdGVuZXJ9LSR7Y29tcGxldGVkfWA7XG52YXIgVGFza0Fib3J0RXJyb3IgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGNvZGUpIHtcbiAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICAgIHRoaXMubWVzc2FnZSA9IGAke3Rhc2t9ICR7Y2FuY2VsbGVkfSAocmVhc29uOiAke2NvZGV9KWA7XG4gIH1cbiAgbmFtZSA9IFwiVGFza0Fib3J0RXJyb3JcIjtcbiAgbWVzc2FnZTtcbn07XG5cbi8vIHNyYy9saXN0ZW5lck1pZGRsZXdhcmUvdXRpbHMudHNcbnZhciBhc3NlcnRGdW5jdGlvbiA9IChmdW5jLCBleHBlY3RlZCkgPT4ge1xuICBpZiAodHlwZW9mIGZ1bmMgIT09IFwiZnVuY3Rpb25cIikge1xuICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDMyKSA6IGAke2V4cGVjdGVkfSBpcyBub3QgYSBmdW5jdGlvbmApO1xuICB9XG59O1xudmFyIG5vb3AyID0gKCkgPT4ge1xufTtcbnZhciBjYXRjaFJlamVjdGlvbiA9IChwcm9taXNlLCBvbkVycm9yID0gbm9vcDIpID0+IHtcbiAgcHJvbWlzZS5jYXRjaChvbkVycm9yKTtcbiAgcmV0dXJuIHByb21pc2U7XG59O1xudmFyIGFkZEFib3J0U2lnbmFsTGlzdGVuZXIgPSAoYWJvcnRTaWduYWwsIGNhbGxiYWNrKSA9PiB7XG4gIGFib3J0U2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBjYWxsYmFjaywge1xuICAgIG9uY2U6IHRydWVcbiAgfSk7XG4gIHJldHVybiAoKSA9PiBhYm9ydFNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgY2FsbGJhY2spO1xufTtcbnZhciBhYm9ydENvbnRyb2xsZXJXaXRoUmVhc29uID0gKGFib3J0Q29udHJvbGxlciwgcmVhc29uKSA9PiB7XG4gIGNvbnN0IHNpZ25hbCA9IGFib3J0Q29udHJvbGxlci5zaWduYWw7XG4gIGlmIChzaWduYWwuYWJvcnRlZCkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoIShcInJlYXNvblwiIGluIHNpZ25hbCkpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc2lnbmFsLCBcInJlYXNvblwiLCB7XG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IHJlYXNvbixcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgO1xuICBhYm9ydENvbnRyb2xsZXIuYWJvcnQocmVhc29uKTtcbn07XG5cbi8vIHNyYy9saXN0ZW5lck1pZGRsZXdhcmUvdGFzay50c1xudmFyIHZhbGlkYXRlQWN0aXZlID0gKHNpZ25hbCkgPT4ge1xuICBpZiAoc2lnbmFsLmFib3J0ZWQpIHtcbiAgICBjb25zdCB7XG4gICAgICByZWFzb25cbiAgICB9ID0gc2lnbmFsO1xuICAgIHRocm93IG5ldyBUYXNrQWJvcnRFcnJvcihyZWFzb24pO1xuICB9XG59O1xuZnVuY3Rpb24gcmFjZVdpdGhTaWduYWwoc2lnbmFsLCBwcm9taXNlKSB7XG4gIGxldCBjbGVhbnVwID0gbm9vcDI7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgY29uc3Qgbm90aWZ5UmVqZWN0aW9uID0gKCkgPT4gcmVqZWN0KG5ldyBUYXNrQWJvcnRFcnJvcihzaWduYWwucmVhc29uKSk7XG4gICAgaWYgKHNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICBub3RpZnlSZWplY3Rpb24oKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY2xlYW51cCA9IGFkZEFib3J0U2lnbmFsTGlzdGVuZXIoc2lnbmFsLCBub3RpZnlSZWplY3Rpb24pO1xuICAgIHByb21pc2UuZmluYWxseSgoKSA9PiBjbGVhbnVwKCkpLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgfSkuZmluYWxseSgoKSA9PiB7XG4gICAgY2xlYW51cCA9IG5vb3AyO1xuICB9KTtcbn1cbnZhciBydW5UYXNrID0gYXN5bmMgKHRhc2syLCBjbGVhblVwKSA9PiB7XG4gIHRyeSB7XG4gICAgYXdhaXQgUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgY29uc3QgdmFsdWUgPSBhd2FpdCB0YXNrMigpO1xuICAgIHJldHVybiB7XG4gICAgICBzdGF0dXM6IFwib2tcIixcbiAgICAgIHZhbHVlXG4gICAgfTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3RhdHVzOiBlcnJvciBpbnN0YW5jZW9mIFRhc2tBYm9ydEVycm9yID8gXCJjYW5jZWxsZWRcIiA6IFwicmVqZWN0ZWRcIixcbiAgICAgIGVycm9yXG4gICAgfTtcbiAgfSBmaW5hbGx5IHtcbiAgICBjbGVhblVwPy4oKTtcbiAgfVxufTtcbnZhciBjcmVhdGVQYXVzZSA9IChzaWduYWwpID0+IHtcbiAgcmV0dXJuIChwcm9taXNlKSA9PiB7XG4gICAgcmV0dXJuIGNhdGNoUmVqZWN0aW9uKHJhY2VXaXRoU2lnbmFsKHNpZ25hbCwgcHJvbWlzZSkudGhlbigob3V0cHV0KSA9PiB7XG4gICAgICB2YWxpZGF0ZUFjdGl2ZShzaWduYWwpO1xuICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9KSk7XG4gIH07XG59O1xudmFyIGNyZWF0ZURlbGF5ID0gKHNpZ25hbCkgPT4ge1xuICBjb25zdCBwYXVzZSA9IGNyZWF0ZVBhdXNlKHNpZ25hbCk7XG4gIHJldHVybiAodGltZW91dE1zKSA9PiB7XG4gICAgcmV0dXJuIHBhdXNlKG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIHRpbWVvdXRNcykpKTtcbiAgfTtcbn07XG5cbi8vIHNyYy9saXN0ZW5lck1pZGRsZXdhcmUvaW5kZXgudHNcbnZhciB7XG4gIGFzc2lnblxufSA9IE9iamVjdDtcbnZhciBJTlRFUk5BTF9OSUxfVE9LRU4gPSB7fTtcbnZhciBhbG0gPSBcImxpc3RlbmVyTWlkZGxld2FyZVwiO1xudmFyIGNyZWF0ZUZvcmsgPSAocGFyZW50QWJvcnRTaWduYWwsIHBhcmVudEJsb2NraW5nUHJvbWlzZXMpID0+IHtcbiAgY29uc3QgbGlua0NvbnRyb2xsZXJzID0gKGNvbnRyb2xsZXIpID0+IGFkZEFib3J0U2lnbmFsTGlzdGVuZXIocGFyZW50QWJvcnRTaWduYWwsICgpID0+IGFib3J0Q29udHJvbGxlcldpdGhSZWFzb24oY29udHJvbGxlciwgcGFyZW50QWJvcnRTaWduYWwucmVhc29uKSk7XG4gIHJldHVybiAodGFza0V4ZWN1dG9yLCBvcHRzKSA9PiB7XG4gICAgYXNzZXJ0RnVuY3Rpb24odGFza0V4ZWN1dG9yLCBcInRhc2tFeGVjdXRvclwiKTtcbiAgICBjb25zdCBjaGlsZEFib3J0Q29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICBsaW5rQ29udHJvbGxlcnMoY2hpbGRBYm9ydENvbnRyb2xsZXIpO1xuICAgIGNvbnN0IHJlc3VsdCA9IHJ1blRhc2soYXN5bmMgKCkgPT4ge1xuICAgICAgdmFsaWRhdGVBY3RpdmUocGFyZW50QWJvcnRTaWduYWwpO1xuICAgICAgdmFsaWRhdGVBY3RpdmUoY2hpbGRBYm9ydENvbnRyb2xsZXIuc2lnbmFsKTtcbiAgICAgIGNvbnN0IHJlc3VsdDIgPSBhd2FpdCB0YXNrRXhlY3V0b3Ioe1xuICAgICAgICBwYXVzZTogY3JlYXRlUGF1c2UoY2hpbGRBYm9ydENvbnRyb2xsZXIuc2lnbmFsKSxcbiAgICAgICAgZGVsYXk6IGNyZWF0ZURlbGF5KGNoaWxkQWJvcnRDb250cm9sbGVyLnNpZ25hbCksXG4gICAgICAgIHNpZ25hbDogY2hpbGRBYm9ydENvbnRyb2xsZXIuc2lnbmFsXG4gICAgICB9KTtcbiAgICAgIHZhbGlkYXRlQWN0aXZlKGNoaWxkQWJvcnRDb250cm9sbGVyLnNpZ25hbCk7XG4gICAgICByZXR1cm4gcmVzdWx0MjtcbiAgICB9LCAoKSA9PiBhYm9ydENvbnRyb2xsZXJXaXRoUmVhc29uKGNoaWxkQWJvcnRDb250cm9sbGVyLCB0YXNrQ29tcGxldGVkKSk7XG4gICAgaWYgKG9wdHM/LmF1dG9Kb2luKSB7XG4gICAgICBwYXJlbnRCbG9ja2luZ1Byb21pc2VzLnB1c2gocmVzdWx0LmNhdGNoKG5vb3AyKSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICByZXN1bHQ6IGNyZWF0ZVBhdXNlKHBhcmVudEFib3J0U2lnbmFsKShyZXN1bHQpLFxuICAgICAgY2FuY2VsKCkge1xuICAgICAgICBhYm9ydENvbnRyb2xsZXJXaXRoUmVhc29uKGNoaWxkQWJvcnRDb250cm9sbGVyLCB0YXNrQ2FuY2VsbGVkKTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xufTtcbnZhciBjcmVhdGVUYWtlUGF0dGVybiA9IChzdGFydExpc3RlbmluZywgc2lnbmFsKSA9PiB7XG4gIGNvbnN0IHRha2UgPSBhc3luYyAocHJlZGljYXRlLCB0aW1lb3V0KSA9PiB7XG4gICAgdmFsaWRhdGVBY3RpdmUoc2lnbmFsKTtcbiAgICBsZXQgdW5zdWJzY3JpYmUgPSAoKSA9PiB7XG4gICAgfTtcbiAgICBjb25zdCB0dXBsZVByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBsZXQgc3RvcExpc3RlbmluZyA9IHN0YXJ0TGlzdGVuaW5nKHtcbiAgICAgICAgcHJlZGljYXRlLFxuICAgICAgICBlZmZlY3Q6IChhY3Rpb24sIGxpc3RlbmVyQXBpKSA9PiB7XG4gICAgICAgICAgbGlzdGVuZXJBcGkudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICByZXNvbHZlKFthY3Rpb24sIGxpc3RlbmVyQXBpLmdldFN0YXRlKCksIGxpc3RlbmVyQXBpLmdldE9yaWdpbmFsU3RhdGUoKV0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHVuc3Vic2NyaWJlID0gKCkgPT4ge1xuICAgICAgICBzdG9wTGlzdGVuaW5nKCk7XG4gICAgICAgIHJlamVjdCgpO1xuICAgICAgfTtcbiAgICB9KTtcbiAgICBjb25zdCBwcm9taXNlcyA9IFt0dXBsZVByb21pc2VdO1xuICAgIGlmICh0aW1lb3V0ICE9IG51bGwpIHtcbiAgICAgIHByb21pc2VzLnB1c2gobmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgdGltZW91dCwgbnVsbCkpKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IG91dHB1dCA9IGF3YWl0IHJhY2VXaXRoU2lnbmFsKHNpZ25hbCwgUHJvbWlzZS5yYWNlKHByb21pc2VzKSk7XG4gICAgICB2YWxpZGF0ZUFjdGl2ZShzaWduYWwpO1xuICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdW5zdWJzY3JpYmUoKTtcbiAgICB9XG4gIH07XG4gIHJldHVybiAocHJlZGljYXRlLCB0aW1lb3V0KSA9PiBjYXRjaFJlamVjdGlvbih0YWtlKHByZWRpY2F0ZSwgdGltZW91dCkpO1xufTtcbnZhciBnZXRMaXN0ZW5lckVudHJ5UHJvcHNGcm9tID0gKG9wdGlvbnMpID0+IHtcbiAgbGV0IHtcbiAgICB0eXBlLFxuICAgIGFjdGlvbkNyZWF0b3IsXG4gICAgbWF0Y2hlcixcbiAgICBwcmVkaWNhdGUsXG4gICAgZWZmZWN0XG4gIH0gPSBvcHRpb25zO1xuICBpZiAodHlwZSkge1xuICAgIHByZWRpY2F0ZSA9IGNyZWF0ZUFjdGlvbih0eXBlKS5tYXRjaDtcbiAgfSBlbHNlIGlmIChhY3Rpb25DcmVhdG9yKSB7XG4gICAgdHlwZSA9IGFjdGlvbkNyZWF0b3IudHlwZTtcbiAgICBwcmVkaWNhdGUgPSBhY3Rpb25DcmVhdG9yLm1hdGNoO1xuICB9IGVsc2UgaWYgKG1hdGNoZXIpIHtcbiAgICBwcmVkaWNhdGUgPSBtYXRjaGVyO1xuICB9IGVsc2UgaWYgKHByZWRpY2F0ZSkge1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDIxKSA6IFwiQ3JlYXRpbmcgb3IgcmVtb3ZpbmcgYSBsaXN0ZW5lciByZXF1aXJlcyBvbmUgb2YgdGhlIGtub3duIGZpZWxkcyBmb3IgbWF0Y2hpbmcgYW4gYWN0aW9uXCIpO1xuICB9XG4gIGFzc2VydEZ1bmN0aW9uKGVmZmVjdCwgXCJvcHRpb25zLmxpc3RlbmVyXCIpO1xuICByZXR1cm4ge1xuICAgIHByZWRpY2F0ZSxcbiAgICB0eXBlLFxuICAgIGVmZmVjdFxuICB9O1xufTtcbnZhciBjcmVhdGVMaXN0ZW5lckVudHJ5ID0gT2JqZWN0LmFzc2lnbigob3B0aW9ucykgPT4ge1xuICBjb25zdCB7XG4gICAgdHlwZSxcbiAgICBwcmVkaWNhdGUsXG4gICAgZWZmZWN0XG4gIH0gPSBnZXRMaXN0ZW5lckVudHJ5UHJvcHNGcm9tKG9wdGlvbnMpO1xuICBjb25zdCBpZCA9IG5hbm9pZCgpO1xuICBjb25zdCBlbnRyeSA9IHtcbiAgICBpZCxcbiAgICBlZmZlY3QsXG4gICAgdHlwZSxcbiAgICBwcmVkaWNhdGUsXG4gICAgcGVuZGluZzogLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSxcbiAgICB1bnN1YnNjcmliZTogKCkgPT4ge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMjIpIDogXCJVbnN1YnNjcmliZSBub3QgaW5pdGlhbGl6ZWRcIik7XG4gICAgfVxuICB9O1xuICByZXR1cm4gZW50cnk7XG59LCB7XG4gIHdpdGhUeXBlczogKCkgPT4gY3JlYXRlTGlzdGVuZXJFbnRyeVxufSk7XG52YXIgY2FuY2VsQWN0aXZlTGlzdGVuZXJzID0gKGVudHJ5KSA9PiB7XG4gIGVudHJ5LnBlbmRpbmcuZm9yRWFjaCgoY29udHJvbGxlcikgPT4ge1xuICAgIGFib3J0Q29udHJvbGxlcldpdGhSZWFzb24oY29udHJvbGxlciwgbGlzdGVuZXJDYW5jZWxsZWQpO1xuICB9KTtcbn07XG52YXIgY3JlYXRlQ2xlYXJMaXN0ZW5lck1pZGRsZXdhcmUgPSAobGlzdGVuZXJNYXApID0+IHtcbiAgcmV0dXJuICgpID0+IHtcbiAgICBsaXN0ZW5lck1hcC5mb3JFYWNoKGNhbmNlbEFjdGl2ZUxpc3RlbmVycyk7XG4gICAgbGlzdGVuZXJNYXAuY2xlYXIoKTtcbiAgfTtcbn07XG52YXIgc2FmZWx5Tm90aWZ5RXJyb3IgPSAoZXJyb3JIYW5kbGVyLCBlcnJvclRvTm90aWZ5LCBlcnJvckluZm8pID0+IHtcbiAgdHJ5IHtcbiAgICBlcnJvckhhbmRsZXIoZXJyb3JUb05vdGlmeSwgZXJyb3JJbmZvKTtcbiAgfSBjYXRjaCAoZXJyb3JIYW5kbGVyRXJyb3IpIHtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRocm93IGVycm9ySGFuZGxlckVycm9yO1xuICAgIH0sIDApO1xuICB9XG59O1xudmFyIGFkZExpc3RlbmVyID0gT2JqZWN0LmFzc2lnbihjcmVhdGVBY3Rpb24oYCR7YWxtfS9hZGRgKSwge1xuICB3aXRoVHlwZXM6ICgpID0+IGFkZExpc3RlbmVyXG59KTtcbnZhciBjbGVhckFsbExpc3RlbmVycyA9IGNyZWF0ZUFjdGlvbihgJHthbG19L3JlbW92ZUFsbGApO1xudmFyIHJlbW92ZUxpc3RlbmVyID0gT2JqZWN0LmFzc2lnbihjcmVhdGVBY3Rpb24oYCR7YWxtfS9yZW1vdmVgKSwge1xuICB3aXRoVHlwZXM6ICgpID0+IHJlbW92ZUxpc3RlbmVyXG59KTtcbnZhciBkZWZhdWx0RXJyb3JIYW5kbGVyID0gKC4uLmFyZ3MpID0+IHtcbiAgY29uc29sZS5lcnJvcihgJHthbG19L2Vycm9yYCwgLi4uYXJncyk7XG59O1xudmFyIGNyZWF0ZUxpc3RlbmVyTWlkZGxld2FyZSA9IChtaWRkbGV3YXJlT3B0aW9ucyA9IHt9KSA9PiB7XG4gIGNvbnN0IGxpc3RlbmVyTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgY29uc3Qge1xuICAgIGV4dHJhLFxuICAgIG9uRXJyb3IgPSBkZWZhdWx0RXJyb3JIYW5kbGVyXG4gIH0gPSBtaWRkbGV3YXJlT3B0aW9ucztcbiAgYXNzZXJ0RnVuY3Rpb24ob25FcnJvciwgXCJvbkVycm9yXCIpO1xuICBjb25zdCBpbnNlcnRFbnRyeSA9IChlbnRyeSkgPT4ge1xuICAgIGVudHJ5LnVuc3Vic2NyaWJlID0gKCkgPT4gbGlzdGVuZXJNYXAuZGVsZXRlKGVudHJ5LmlkKTtcbiAgICBsaXN0ZW5lck1hcC5zZXQoZW50cnkuaWQsIGVudHJ5KTtcbiAgICByZXR1cm4gKGNhbmNlbE9wdGlvbnMpID0+IHtcbiAgICAgIGVudHJ5LnVuc3Vic2NyaWJlKCk7XG4gICAgICBpZiAoY2FuY2VsT3B0aW9ucz8uY2FuY2VsQWN0aXZlKSB7XG4gICAgICAgIGNhbmNlbEFjdGl2ZUxpc3RlbmVycyhlbnRyeSk7XG4gICAgICB9XG4gICAgfTtcbiAgfTtcbiAgY29uc3Qgc3RhcnRMaXN0ZW5pbmcgPSAob3B0aW9ucykgPT4ge1xuICAgIGxldCBlbnRyeSA9IGZpbmQoQXJyYXkuZnJvbShsaXN0ZW5lck1hcC52YWx1ZXMoKSksIChleGlzdGluZ0VudHJ5KSA9PiBleGlzdGluZ0VudHJ5LmVmZmVjdCA9PT0gb3B0aW9ucy5lZmZlY3QpO1xuICAgIGlmICghZW50cnkpIHtcbiAgICAgIGVudHJ5ID0gY3JlYXRlTGlzdGVuZXJFbnRyeShvcHRpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIGluc2VydEVudHJ5KGVudHJ5KTtcbiAgfTtcbiAgT2JqZWN0LmFzc2lnbihzdGFydExpc3RlbmluZywge1xuICAgIHdpdGhUeXBlczogKCkgPT4gc3RhcnRMaXN0ZW5pbmdcbiAgfSk7XG4gIGNvbnN0IHN0b3BMaXN0ZW5pbmcgPSAob3B0aW9ucykgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIHR5cGUsXG4gICAgICBlZmZlY3QsXG4gICAgICBwcmVkaWNhdGVcbiAgICB9ID0gZ2V0TGlzdGVuZXJFbnRyeVByb3BzRnJvbShvcHRpb25zKTtcbiAgICBjb25zdCBlbnRyeSA9IGZpbmQoQXJyYXkuZnJvbShsaXN0ZW5lck1hcC52YWx1ZXMoKSksIChlbnRyeTIpID0+IHtcbiAgICAgIGNvbnN0IG1hdGNoUHJlZGljYXRlT3JUeXBlID0gdHlwZW9mIHR5cGUgPT09IFwic3RyaW5nXCIgPyBlbnRyeTIudHlwZSA9PT0gdHlwZSA6IGVudHJ5Mi5wcmVkaWNhdGUgPT09IHByZWRpY2F0ZTtcbiAgICAgIHJldHVybiBtYXRjaFByZWRpY2F0ZU9yVHlwZSAmJiBlbnRyeTIuZWZmZWN0ID09PSBlZmZlY3Q7XG4gICAgfSk7XG4gICAgaWYgKGVudHJ5KSB7XG4gICAgICBlbnRyeS51bnN1YnNjcmliZSgpO1xuICAgICAgaWYgKG9wdGlvbnMuY2FuY2VsQWN0aXZlKSB7XG4gICAgICAgIGNhbmNlbEFjdGl2ZUxpc3RlbmVycyhlbnRyeSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAhIWVudHJ5O1xuICB9O1xuICBPYmplY3QuYXNzaWduKHN0b3BMaXN0ZW5pbmcsIHtcbiAgICB3aXRoVHlwZXM6ICgpID0+IHN0b3BMaXN0ZW5pbmdcbiAgfSk7XG4gIGNvbnN0IG5vdGlmeUxpc3RlbmVyID0gYXN5bmMgKGVudHJ5LCBhY3Rpb24sIGFwaSwgZ2V0T3JpZ2luYWxTdGF0ZSkgPT4ge1xuICAgIGNvbnN0IGludGVybmFsVGFza0NvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgY29uc3QgdGFrZSA9IGNyZWF0ZVRha2VQYXR0ZXJuKHN0YXJ0TGlzdGVuaW5nLCBpbnRlcm5hbFRhc2tDb250cm9sbGVyLnNpZ25hbCk7XG4gICAgY29uc3QgYXV0b0pvaW5Qcm9taXNlcyA9IFtdO1xuICAgIHRyeSB7XG4gICAgICBlbnRyeS5wZW5kaW5nLmFkZChpbnRlcm5hbFRhc2tDb250cm9sbGVyKTtcbiAgICAgIGF3YWl0IFByb21pc2UucmVzb2x2ZShlbnRyeS5lZmZlY3QoXG4gICAgICAgIGFjdGlvbixcbiAgICAgICAgLy8gVXNlIGFzc2lnbigpIHJhdGhlciB0aGFuIC4uLiB0byBhdm9pZCBleHRyYSBoZWxwZXIgZnVuY3Rpb25zIGFkZGVkIHRvIGJ1bmRsZVxuICAgICAgICBhc3NpZ24oe30sIGFwaSwge1xuICAgICAgICAgIGdldE9yaWdpbmFsU3RhdGUsXG4gICAgICAgICAgY29uZGl0aW9uOiAocHJlZGljYXRlLCB0aW1lb3V0KSA9PiB0YWtlKHByZWRpY2F0ZSwgdGltZW91dCkudGhlbihCb29sZWFuKSxcbiAgICAgICAgICB0YWtlLFxuICAgICAgICAgIGRlbGF5OiBjcmVhdGVEZWxheShpbnRlcm5hbFRhc2tDb250cm9sbGVyLnNpZ25hbCksXG4gICAgICAgICAgcGF1c2U6IGNyZWF0ZVBhdXNlKGludGVybmFsVGFza0NvbnRyb2xsZXIuc2lnbmFsKSxcbiAgICAgICAgICBleHRyYSxcbiAgICAgICAgICBzaWduYWw6IGludGVybmFsVGFza0NvbnRyb2xsZXIuc2lnbmFsLFxuICAgICAgICAgIGZvcms6IGNyZWF0ZUZvcmsoaW50ZXJuYWxUYXNrQ29udHJvbGxlci5zaWduYWwsIGF1dG9Kb2luUHJvbWlzZXMpLFxuICAgICAgICAgIHVuc3Vic2NyaWJlOiBlbnRyeS51bnN1YnNjcmliZSxcbiAgICAgICAgICBzdWJzY3JpYmU6ICgpID0+IHtcbiAgICAgICAgICAgIGxpc3RlbmVyTWFwLnNldChlbnRyeS5pZCwgZW50cnkpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgY2FuY2VsQWN0aXZlTGlzdGVuZXJzOiAoKSA9PiB7XG4gICAgICAgICAgICBlbnRyeS5wZW5kaW5nLmZvckVhY2goKGNvbnRyb2xsZXIsIF8sIHNldCkgPT4ge1xuICAgICAgICAgICAgICBpZiAoY29udHJvbGxlciAhPT0gaW50ZXJuYWxUYXNrQ29udHJvbGxlcikge1xuICAgICAgICAgICAgICAgIGFib3J0Q29udHJvbGxlcldpdGhSZWFzb24oY29udHJvbGxlciwgbGlzdGVuZXJDYW5jZWxsZWQpO1xuICAgICAgICAgICAgICAgIHNldC5kZWxldGUoY29udHJvbGxlcik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgY2FuY2VsOiAoKSA9PiB7XG4gICAgICAgICAgICBhYm9ydENvbnRyb2xsZXJXaXRoUmVhc29uKGludGVybmFsVGFza0NvbnRyb2xsZXIsIGxpc3RlbmVyQ2FuY2VsbGVkKTtcbiAgICAgICAgICAgIGVudHJ5LnBlbmRpbmcuZGVsZXRlKGludGVybmFsVGFza0NvbnRyb2xsZXIpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgdGhyb3dJZkNhbmNlbGxlZDogKCkgPT4ge1xuICAgICAgICAgICAgdmFsaWRhdGVBY3RpdmUoaW50ZXJuYWxUYXNrQ29udHJvbGxlci5zaWduYWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICkpO1xuICAgIH0gY2F0Y2ggKGxpc3RlbmVyRXJyb3IpIHtcbiAgICAgIGlmICghKGxpc3RlbmVyRXJyb3IgaW5zdGFuY2VvZiBUYXNrQWJvcnRFcnJvcikpIHtcbiAgICAgICAgc2FmZWx5Tm90aWZ5RXJyb3Iob25FcnJvciwgbGlzdGVuZXJFcnJvciwge1xuICAgICAgICAgIHJhaXNlZEJ5OiBcImVmZmVjdFwiXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICBhd2FpdCBQcm9taXNlLmFsbChhdXRvSm9pblByb21pc2VzKTtcbiAgICAgIGFib3J0Q29udHJvbGxlcldpdGhSZWFzb24oaW50ZXJuYWxUYXNrQ29udHJvbGxlciwgbGlzdGVuZXJDb21wbGV0ZWQpO1xuICAgICAgZW50cnkucGVuZGluZy5kZWxldGUoaW50ZXJuYWxUYXNrQ29udHJvbGxlcik7XG4gICAgfVxuICB9O1xuICBjb25zdCBjbGVhckxpc3RlbmVyTWlkZGxld2FyZSA9IGNyZWF0ZUNsZWFyTGlzdGVuZXJNaWRkbGV3YXJlKGxpc3RlbmVyTWFwKTtcbiAgY29uc3QgbWlkZGxld2FyZSA9IChhcGkpID0+IChuZXh0KSA9PiAoYWN0aW9uKSA9PiB7XG4gICAgaWYgKCFpc0FjdGlvbjMoYWN0aW9uKSkge1xuICAgICAgcmV0dXJuIG5leHQoYWN0aW9uKTtcbiAgICB9XG4gICAgaWYgKGFkZExpc3RlbmVyLm1hdGNoKGFjdGlvbikpIHtcbiAgICAgIHJldHVybiBzdGFydExpc3RlbmluZyhhY3Rpb24ucGF5bG9hZCk7XG4gICAgfVxuICAgIGlmIChjbGVhckFsbExpc3RlbmVycy5tYXRjaChhY3Rpb24pKSB7XG4gICAgICBjbGVhckxpc3RlbmVyTWlkZGxld2FyZSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAocmVtb3ZlTGlzdGVuZXIubWF0Y2goYWN0aW9uKSkge1xuICAgICAgcmV0dXJuIHN0b3BMaXN0ZW5pbmcoYWN0aW9uLnBheWxvYWQpO1xuICAgIH1cbiAgICBsZXQgb3JpZ2luYWxTdGF0ZSA9IGFwaS5nZXRTdGF0ZSgpO1xuICAgIGNvbnN0IGdldE9yaWdpbmFsU3RhdGUgPSAoKSA9PiB7XG4gICAgICBpZiAob3JpZ2luYWxTdGF0ZSA9PT0gSU5URVJOQUxfTklMX1RPS0VOKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDIzKSA6IGAke2FsbX06IGdldE9yaWdpbmFsU3RhdGUgY2FuIG9ubHkgYmUgY2FsbGVkIHN5bmNocm9ub3VzbHlgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvcmlnaW5hbFN0YXRlO1xuICAgIH07XG4gICAgbGV0IHJlc3VsdDtcbiAgICB0cnkge1xuICAgICAgcmVzdWx0ID0gbmV4dChhY3Rpb24pO1xuICAgICAgaWYgKGxpc3RlbmVyTWFwLnNpemUgPiAwKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRTdGF0ZSA9IGFwaS5nZXRTdGF0ZSgpO1xuICAgICAgICBjb25zdCBsaXN0ZW5lckVudHJpZXMgPSBBcnJheS5mcm9tKGxpc3RlbmVyTWFwLnZhbHVlcygpKTtcbiAgICAgICAgZm9yIChjb25zdCBlbnRyeSBvZiBsaXN0ZW5lckVudHJpZXMpIHtcbiAgICAgICAgICBsZXQgcnVuTGlzdGVuZXIgPSBmYWxzZTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcnVuTGlzdGVuZXIgPSBlbnRyeS5wcmVkaWNhdGUoYWN0aW9uLCBjdXJyZW50U3RhdGUsIG9yaWdpbmFsU3RhdGUpO1xuICAgICAgICAgIH0gY2F0Y2ggKHByZWRpY2F0ZUVycm9yKSB7XG4gICAgICAgICAgICBydW5MaXN0ZW5lciA9IGZhbHNlO1xuICAgICAgICAgICAgc2FmZWx5Tm90aWZ5RXJyb3Iob25FcnJvciwgcHJlZGljYXRlRXJyb3IsIHtcbiAgICAgICAgICAgICAgcmFpc2VkQnk6IFwicHJlZGljYXRlXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXJ1bkxpc3RlbmVyKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbm90aWZ5TGlzdGVuZXIoZW50cnksIGFjdGlvbiwgYXBpLCBnZXRPcmlnaW5hbFN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICBvcmlnaW5hbFN0YXRlID0gSU5URVJOQUxfTklMX1RPS0VOO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICByZXR1cm4ge1xuICAgIG1pZGRsZXdhcmUsXG4gICAgc3RhcnRMaXN0ZW5pbmcsXG4gICAgc3RvcExpc3RlbmluZyxcbiAgICBjbGVhckxpc3RlbmVyczogY2xlYXJMaXN0ZW5lck1pZGRsZXdhcmVcbiAgfTtcbn07XG5cbi8vIHNyYy9keW5hbWljTWlkZGxld2FyZS9pbmRleC50c1xuaW1wb3J0IHsgY29tcG9zZSBhcyBjb21wb3NlMyB9IGZyb20gXCJyZWR1eFwiO1xudmFyIGNyZWF0ZU1pZGRsZXdhcmVFbnRyeSA9IChtaWRkbGV3YXJlKSA9PiAoe1xuICBpZDogbmFub2lkKCksXG4gIG1pZGRsZXdhcmUsXG4gIGFwcGxpZWQ6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKClcbn0pO1xudmFyIG1hdGNoSW5zdGFuY2UgPSAoaW5zdGFuY2VJZCkgPT4gKGFjdGlvbikgPT4gYWN0aW9uPy5tZXRhPy5pbnN0YW5jZUlkID09PSBpbnN0YW5jZUlkO1xudmFyIGNyZWF0ZUR5bmFtaWNNaWRkbGV3YXJlID0gKCkgPT4ge1xuICBjb25zdCBpbnN0YW5jZUlkID0gbmFub2lkKCk7XG4gIGNvbnN0IG1pZGRsZXdhcmVNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBjb25zdCB3aXRoTWlkZGxld2FyZSA9IE9iamVjdC5hc3NpZ24oY3JlYXRlQWN0aW9uKFwiZHluYW1pY01pZGRsZXdhcmUvYWRkXCIsICguLi5taWRkbGV3YXJlcykgPT4gKHtcbiAgICBwYXlsb2FkOiBtaWRkbGV3YXJlcyxcbiAgICBtZXRhOiB7XG4gICAgICBpbnN0YW5jZUlkXG4gICAgfVxuICB9KSksIHtcbiAgICB3aXRoVHlwZXM6ICgpID0+IHdpdGhNaWRkbGV3YXJlXG4gIH0pO1xuICBjb25zdCBhZGRNaWRkbGV3YXJlID0gT2JqZWN0LmFzc2lnbihmdW5jdGlvbiBhZGRNaWRkbGV3YXJlMiguLi5taWRkbGV3YXJlcykge1xuICAgIG1pZGRsZXdhcmVzLmZvckVhY2goKG1pZGRsZXdhcmUyKSA9PiB7XG4gICAgICBsZXQgZW50cnkgPSBmaW5kKEFycmF5LmZyb20obWlkZGxld2FyZU1hcC52YWx1ZXMoKSksIChlbnRyeTIpID0+IGVudHJ5Mi5taWRkbGV3YXJlID09PSBtaWRkbGV3YXJlMik7XG4gICAgICBpZiAoIWVudHJ5KSB7XG4gICAgICAgIGVudHJ5ID0gY3JlYXRlTWlkZGxld2FyZUVudHJ5KG1pZGRsZXdhcmUyKTtcbiAgICAgIH1cbiAgICAgIG1pZGRsZXdhcmVNYXAuc2V0KGVudHJ5LmlkLCBlbnRyeSk7XG4gICAgfSk7XG4gIH0sIHtcbiAgICB3aXRoVHlwZXM6ICgpID0+IGFkZE1pZGRsZXdhcmVcbiAgfSk7XG4gIGNvbnN0IGdldEZpbmFsTWlkZGxld2FyZSA9IChhcGkpID0+IHtcbiAgICBjb25zdCBhcHBsaWVkTWlkZGxld2FyZSA9IEFycmF5LmZyb20obWlkZGxld2FyZU1hcC52YWx1ZXMoKSkubWFwKChlbnRyeSkgPT4gZW1wbGFjZShlbnRyeS5hcHBsaWVkLCBhcGksIHtcbiAgICAgIGluc2VydDogKCkgPT4gZW50cnkubWlkZGxld2FyZShhcGkpXG4gICAgfSkpO1xuICAgIHJldHVybiBjb21wb3NlMyguLi5hcHBsaWVkTWlkZGxld2FyZSk7XG4gIH07XG4gIGNvbnN0IGlzV2l0aE1pZGRsZXdhcmUgPSBpc0FsbE9mKHdpdGhNaWRkbGV3YXJlLCBtYXRjaEluc3RhbmNlKGluc3RhbmNlSWQpKTtcbiAgY29uc3QgbWlkZGxld2FyZSA9IChhcGkpID0+IChuZXh0KSA9PiAoYWN0aW9uKSA9PiB7XG4gICAgaWYgKGlzV2l0aE1pZGRsZXdhcmUoYWN0aW9uKSkge1xuICAgICAgYWRkTWlkZGxld2FyZSguLi5hY3Rpb24ucGF5bG9hZCk7XG4gICAgICByZXR1cm4gYXBpLmRpc3BhdGNoO1xuICAgIH1cbiAgICByZXR1cm4gZ2V0RmluYWxNaWRkbGV3YXJlKGFwaSkobmV4dCkoYWN0aW9uKTtcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBtaWRkbGV3YXJlLFxuICAgIGFkZE1pZGRsZXdhcmUsXG4gICAgd2l0aE1pZGRsZXdhcmUsXG4gICAgaW5zdGFuY2VJZFxuICB9O1xufTtcblxuLy8gc3JjL2NvbWJpbmVTbGljZXMudHNcbmltcG9ydCB7IGNvbWJpbmVSZWR1Y2VycyBhcyBjb21iaW5lUmVkdWNlcnMyIH0gZnJvbSBcInJlZHV4XCI7XG52YXIgaXNTbGljZUxpa2UgPSAobWF5YmVTbGljZUxpa2UpID0+IFwicmVkdWNlclBhdGhcIiBpbiBtYXliZVNsaWNlTGlrZSAmJiB0eXBlb2YgbWF5YmVTbGljZUxpa2UucmVkdWNlclBhdGggPT09IFwic3RyaW5nXCI7XG52YXIgZ2V0UmVkdWNlcnMgPSAoc2xpY2VzKSA9PiBzbGljZXMuZmxhdE1hcCgoc2xpY2VPck1hcCkgPT4gaXNTbGljZUxpa2Uoc2xpY2VPck1hcCkgPyBbW3NsaWNlT3JNYXAucmVkdWNlclBhdGgsIHNsaWNlT3JNYXAucmVkdWNlcl1dIDogT2JqZWN0LmVudHJpZXMoc2xpY2VPck1hcCkpO1xudmFyIE9SSUdJTkFMX1NUQVRFID0gU3ltYm9sLmZvcihcInJ0ay1zdGF0ZS1wcm94eS1vcmlnaW5hbFwiKTtcbnZhciBpc1N0YXRlUHJveHkgPSAodmFsdWUpID0+ICEhdmFsdWUgJiYgISF2YWx1ZVtPUklHSU5BTF9TVEFURV07XG52YXIgc3RhdGVQcm94eU1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xudmFyIGNyZWF0ZVN0YXRlUHJveHkgPSAoc3RhdGUsIHJlZHVjZXJNYXApID0+IGVtcGxhY2Uoc3RhdGVQcm94eU1hcCwgc3RhdGUsIHtcbiAgaW5zZXJ0OiAoKSA9PiBuZXcgUHJveHkoc3RhdGUsIHtcbiAgICBnZXQ6ICh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKSA9PiB7XG4gICAgICBpZiAocHJvcCA9PT0gT1JJR0lOQUxfU1RBVEUpXG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgICBjb25zdCByZXN1bHQgPSBSZWZsZWN0LmdldCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKTtcbiAgICAgIGlmICh0eXBlb2YgcmVzdWx0ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIGNvbnN0IHJlZHVjZXIgPSByZWR1Y2VyTWFwW3Byb3AudG9TdHJpbmcoKV07XG4gICAgICAgIGlmIChyZWR1Y2VyKSB7XG4gICAgICAgICAgY29uc3QgcmVkdWNlclJlc3VsdCA9IHJlZHVjZXIodm9pZCAwLCB7XG4gICAgICAgICAgICB0eXBlOiBuYW5vaWQoKVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmICh0eXBlb2YgcmVkdWNlclJlc3VsdCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMjQpIDogYFRoZSBzbGljZSByZWR1Y2VyIGZvciBrZXkgXCIke3Byb3AudG9TdHJpbmcoKX1cIiByZXR1cm5lZCB1bmRlZmluZWQgd2hlbiBjYWxsZWQgZm9yIHNlbGVjdG9yKCkuIElmIHRoZSBzdGF0ZSBwYXNzZWQgdG8gdGhlIHJlZHVjZXIgaXMgdW5kZWZpbmVkLCB5b3UgbXVzdCBleHBsaWNpdGx5IHJldHVybiB0aGUgaW5pdGlhbCBzdGF0ZS4gVGhlIGluaXRpYWwgc3RhdGUgbWF5IG5vdCBiZSB1bmRlZmluZWQuIElmIHlvdSBkb24ndCB3YW50IHRvIHNldCBhIHZhbHVlIGZvciB0aGlzIHJlZHVjZXIsIHlvdSBjYW4gdXNlIG51bGwgaW5zdGVhZCBvZiB1bmRlZmluZWQuYCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZWR1Y2VyUmVzdWx0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfSlcbn0pO1xudmFyIG9yaWdpbmFsID0gKHN0YXRlKSA9PiB7XG4gIGlmICghaXNTdGF0ZVByb3h5KHN0YXRlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDI1KSA6IFwib3JpZ2luYWwgbXVzdCBiZSB1c2VkIG9uIHN0YXRlIFByb3h5XCIpO1xuICB9XG4gIHJldHVybiBzdGF0ZVtPUklHSU5BTF9TVEFURV07XG59O1xudmFyIG5vb3BSZWR1Y2VyID0gKHN0YXRlID0ge30pID0+IHN0YXRlO1xuZnVuY3Rpb24gY29tYmluZVNsaWNlcyguLi5zbGljZXMpIHtcbiAgY29uc3QgcmVkdWNlck1hcCA9IE9iamVjdC5mcm9tRW50cmllcyhnZXRSZWR1Y2VycyhzbGljZXMpKTtcbiAgY29uc3QgZ2V0UmVkdWNlciA9ICgpID0+IE9iamVjdC5rZXlzKHJlZHVjZXJNYXApLmxlbmd0aCA/IGNvbWJpbmVSZWR1Y2VyczIocmVkdWNlck1hcCkgOiBub29wUmVkdWNlcjtcbiAgbGV0IHJlZHVjZXIgPSBnZXRSZWR1Y2VyKCk7XG4gIGZ1bmN0aW9uIGNvbWJpbmVkUmVkdWNlcihzdGF0ZSwgYWN0aW9uKSB7XG4gICAgcmV0dXJuIHJlZHVjZXIoc3RhdGUsIGFjdGlvbik7XG4gIH1cbiAgY29tYmluZWRSZWR1Y2VyLndpdGhMYXp5TG9hZGVkU2xpY2VzID0gKCkgPT4gY29tYmluZWRSZWR1Y2VyO1xuICBjb25zdCBpbmplY3QgPSAoc2xpY2UsIGNvbmZpZyA9IHt9KSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgcmVkdWNlclBhdGgsXG4gICAgICByZWR1Y2VyOiByZWR1Y2VyVG9JbmplY3RcbiAgICB9ID0gc2xpY2U7XG4gICAgY29uc3QgY3VycmVudFJlZHVjZXIgPSByZWR1Y2VyTWFwW3JlZHVjZXJQYXRoXTtcbiAgICBpZiAoIWNvbmZpZy5vdmVycmlkZUV4aXN0aW5nICYmIGN1cnJlbnRSZWR1Y2VyICYmIGN1cnJlbnRSZWR1Y2VyICE9PSByZWR1Y2VyVG9JbmplY3QpIHtcbiAgICAgIGlmICh0eXBlb2YgcHJvY2VzcyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJkZXZlbG9wbWVudFwiKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYGNhbGxlZCBcXGBpbmplY3RcXGAgdG8gb3ZlcnJpZGUgYWxyZWFkeS1leGlzdGluZyByZWR1Y2VyICR7cmVkdWNlclBhdGh9IHdpdGhvdXQgc3BlY2lmeWluZyBcXGBvdmVycmlkZUV4aXN0aW5nOiB0cnVlXFxgYCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29tYmluZWRSZWR1Y2VyO1xuICAgIH1cbiAgICByZWR1Y2VyTWFwW3JlZHVjZXJQYXRoXSA9IHJlZHVjZXJUb0luamVjdDtcbiAgICByZWR1Y2VyID0gZ2V0UmVkdWNlcigpO1xuICAgIHJldHVybiBjb21iaW5lZFJlZHVjZXI7XG4gIH07XG4gIGNvbnN0IHNlbGVjdG9yID0gT2JqZWN0LmFzc2lnbihmdW5jdGlvbiBtYWtlU2VsZWN0b3Ioc2VsZWN0b3JGbiwgc2VsZWN0U3RhdGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gc2VsZWN0b3IyKHN0YXRlLCAuLi5hcmdzKSB7XG4gICAgICByZXR1cm4gc2VsZWN0b3JGbihjcmVhdGVTdGF0ZVByb3h5KHNlbGVjdFN0YXRlID8gc2VsZWN0U3RhdGUoc3RhdGUsIC4uLmFyZ3MpIDogc3RhdGUsIHJlZHVjZXJNYXApLCAuLi5hcmdzKTtcbiAgICB9O1xuICB9LCB7XG4gICAgb3JpZ2luYWxcbiAgfSk7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKGNvbWJpbmVkUmVkdWNlciwge1xuICAgIGluamVjdCxcbiAgICBzZWxlY3RvclxuICB9KTtcbn1cblxuLy8gc3JjL2Zvcm1hdFByb2RFcnJvck1lc3NhZ2UudHNcbmZ1bmN0aW9uIGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoY29kZSkge1xuICByZXR1cm4gYE1pbmlmaWVkIFJlZHV4IFRvb2xraXQgZXJyb3IgIyR7Y29kZX07IHZpc2l0IGh0dHBzOi8vcmVkdXgtdG9vbGtpdC5qcy5vcmcvRXJyb3JzP2NvZGU9JHtjb2RlfSBmb3IgdGhlIGZ1bGwgbWVzc2FnZSBvciB1c2UgdGhlIG5vbi1taW5pZmllZCBkZXYgZW52aXJvbm1lbnQgZm9yIGZ1bGwgZXJyb3JzLiBgO1xufVxuZXhwb3J0IHtcbiAgUmVkdWNlclR5cGUsXG4gIFNIT1VMRF9BVVRPQkFUQ0gsXG4gIFRhc2tBYm9ydEVycm9yLFxuICBUdXBsZSxcbiAgYWRkTGlzdGVuZXIsXG4gIGFzeW5jVGh1bmtDcmVhdG9yLFxuICBhdXRvQmF0Y2hFbmhhbmNlcixcbiAgYnVpbGRDcmVhdGVTbGljZSxcbiAgY2xlYXJBbGxMaXN0ZW5lcnMsXG4gIGNvbWJpbmVTbGljZXMsXG4gIGNvbmZpZ3VyZVN0b3JlLFxuICBjcmVhdGVBY3Rpb24sXG4gIGNyZWF0ZUFjdGlvbkNyZWF0b3JJbnZhcmlhbnRNaWRkbGV3YXJlLFxuICBjcmVhdGVBc3luY1RodW5rLFxuICBjcmVhdGVEcmFmdFNhZmVTZWxlY3RvcixcbiAgY3JlYXRlRHJhZnRTYWZlU2VsZWN0b3JDcmVhdG9yLFxuICBjcmVhdGVEeW5hbWljTWlkZGxld2FyZSxcbiAgY3JlYXRlRW50aXR5QWRhcHRlcixcbiAgY3JlYXRlSW1tdXRhYmxlU3RhdGVJbnZhcmlhbnRNaWRkbGV3YXJlLFxuICBjcmVhdGVMaXN0ZW5lck1pZGRsZXdhcmUsXG4gIHByb2R1Y2UgYXMgY3JlYXRlTmV4dFN0YXRlLFxuICBjcmVhdGVSZWR1Y2VyLFxuICBjcmVhdGVTZWxlY3RvcixcbiAgY3JlYXRlU2VsZWN0b3JDcmVhdG9yMiBhcyBjcmVhdGVTZWxlY3RvckNyZWF0b3IsXG4gIGNyZWF0ZVNlcmlhbGl6YWJsZVN0YXRlSW52YXJpYW50TWlkZGxld2FyZSxcbiAgY3JlYXRlU2xpY2UsXG4gIGN1cnJlbnQyIGFzIGN1cnJlbnQsXG4gIGZpbmROb25TZXJpYWxpemFibGVWYWx1ZSxcbiAgZm9ybWF0UHJvZEVycm9yTWVzc2FnZSxcbiAgZnJlZXplLFxuICBpc0FjdGlvbkNyZWF0b3IsXG4gIGlzQWxsT2YsXG4gIGlzQW55T2YsXG4gIGlzQXN5bmNUaHVua0FjdGlvbixcbiAgaXNEcmFmdDQgYXMgaXNEcmFmdCxcbiAgaXNGU0EgYXMgaXNGbHV4U3RhbmRhcmRBY3Rpb24sXG4gIGlzRnVsZmlsbGVkLFxuICBpc0ltbXV0YWJsZURlZmF1bHQsXG4gIGlzUGVuZGluZyxcbiAgaXNQbGFpbixcbiAgaXNSZWplY3RlZCxcbiAgaXNSZWplY3RlZFdpdGhWYWx1ZSxcbiAgbHJ1TWVtb2l6ZSxcbiAgbWluaVNlcmlhbGl6ZUVycm9yLFxuICBuYW5vaWQsXG4gIG9yaWdpbmFsMiBhcyBvcmlnaW5hbCxcbiAgcHJlcGFyZUF1dG9CYXRjaGVkLFxuICByZW1vdmVMaXN0ZW5lcixcbiAgdW53cmFwUmVzdWx0LFxuICB3ZWFrTWFwTWVtb2l6ZTIgYXMgd2Vha01hcE1lbW9pemVcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZWR1eC10b29sa2l0Lm1vZGVybi5tanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@reduxjs/toolkit/dist/redux-toolkit.modern.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/immer/dist/immer.mjs":
/*!*******************************************!*\
  !*** ./node_modules/immer/dist/immer.mjs ***!
  \*******************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Immer: function() { return /* binding */ Immer2; },\n/* harmony export */   applyPatches: function() { return /* binding */ applyPatches; },\n/* harmony export */   castDraft: function() { return /* binding */ castDraft; },\n/* harmony export */   castImmutable: function() { return /* binding */ castImmutable; },\n/* harmony export */   createDraft: function() { return /* binding */ createDraft; },\n/* harmony export */   current: function() { return /* binding */ current; },\n/* harmony export */   enableMapSet: function() { return /* binding */ enableMapSet; },\n/* harmony export */   enablePatches: function() { return /* binding */ enablePatches; },\n/* harmony export */   finishDraft: function() { return /* binding */ finishDraft; },\n/* harmony export */   freeze: function() { return /* binding */ freeze; },\n/* harmony export */   immerable: function() { return /* binding */ DRAFTABLE; },\n/* harmony export */   isDraft: function() { return /* binding */ isDraft; },\n/* harmony export */   isDraftable: function() { return /* binding */ isDraftable; },\n/* harmony export */   nothing: function() { return /* binding */ NOTHING; },\n/* harmony export */   original: function() { return /* binding */ original; },\n/* harmony export */   produce: function() { return /* binding */ produce; },\n/* harmony export */   produceWithPatches: function() { return /* binding */ produceWithPatches; },\n/* harmony export */   setAutoFreeze: function() { return /* binding */ setAutoFreeze; },\n/* harmony export */   setUseStrictShallowCopy: function() { return /* binding */ setUseStrictShallowCopy; }\n/* harmony export */ });\n// src/utils/env.ts\nvar NOTHING = Symbol.for(\"immer-nothing\");\nvar DRAFTABLE = Symbol.for(\"immer-draftable\");\nvar DRAFT_STATE = Symbol.for(\"immer-state\");\n\n// src/utils/errors.ts\nvar errors =  true ? [\n  // All error codes, starting by 0:\n  function(plugin) {\n    return `The plugin for '${plugin}' has not been loaded into Immer. To enable the plugin, import and call \\`enable${plugin}()\\` when initializing your application.`;\n  },\n  function(thing) {\n    return `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${thing}'`;\n  },\n  \"This object has been frozen and should not be mutated\",\n  function(data) {\n    return \"Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? \" + data;\n  },\n  \"An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.\",\n  \"Immer forbids circular references\",\n  \"The first or second argument to `produce` must be a function\",\n  \"The third argument to `produce` must be a function or undefined\",\n  \"First argument to `createDraft` must be a plain object, an array, or an immerable object\",\n  \"First argument to `finishDraft` must be a draft returned by `createDraft`\",\n  function(thing) {\n    return `'current' expects a draft, got: ${thing}`;\n  },\n  \"Object.defineProperty() cannot be used on an Immer draft\",\n  \"Object.setPrototypeOf() cannot be used on an Immer draft\",\n  \"Immer only supports deleting array indices\",\n  \"Immer only supports setting array indices and the 'length' property\",\n  function(thing) {\n    return `'original' expects a draft, got: ${thing}`;\n  }\n  // Note: if more errors are added, the errorOffset in Patches.ts should be increased\n  // See Patches.ts for additional errors\n] : 0;\nfunction die(error, ...args) {\n  if (true) {\n    const e = errors[error];\n    const msg = typeof e === \"function\" ? e.apply(null, args) : e;\n    throw new Error(`[Immer] ${msg}`);\n  }\n  throw new Error(\n    `[Immer] minified error nr: ${error}. Full error at: https://bit.ly/3cXEKWf`\n  );\n}\n\n// src/utils/common.ts\nvar getPrototypeOf = Object.getPrototypeOf;\nfunction isDraft(value) {\n  return !!value && !!value[DRAFT_STATE];\n}\nfunction isDraftable(value) {\n  if (!value)\n    return false;\n  return isPlainObject(value) || Array.isArray(value) || !!value[DRAFTABLE] || !!value.constructor?.[DRAFTABLE] || isMap(value) || isSet(value);\n}\nvar objectCtorString = Object.prototype.constructor.toString();\nfunction isPlainObject(value) {\n  if (!value || typeof value !== \"object\")\n    return false;\n  const proto = getPrototypeOf(value);\n  if (proto === null) {\n    return true;\n  }\n  const Ctor = Object.hasOwnProperty.call(proto, \"constructor\") && proto.constructor;\n  if (Ctor === Object)\n    return true;\n  return typeof Ctor == \"function\" && Function.toString.call(Ctor) === objectCtorString;\n}\nfunction original(value) {\n  if (!isDraft(value))\n    die(15, value);\n  return value[DRAFT_STATE].base_;\n}\nfunction each(obj, iter) {\n  if (getArchtype(obj) === 0 /* Object */) {\n    Reflect.ownKeys(obj).forEach((key) => {\n      iter(key, obj[key], obj);\n    });\n  } else {\n    obj.forEach((entry, index) => iter(index, entry, obj));\n  }\n}\nfunction getArchtype(thing) {\n  const state = thing[DRAFT_STATE];\n  return state ? state.type_ : Array.isArray(thing) ? 1 /* Array */ : isMap(thing) ? 2 /* Map */ : isSet(thing) ? 3 /* Set */ : 0 /* Object */;\n}\nfunction has(thing, prop) {\n  return getArchtype(thing) === 2 /* Map */ ? thing.has(prop) : Object.prototype.hasOwnProperty.call(thing, prop);\n}\nfunction get(thing, prop) {\n  return getArchtype(thing) === 2 /* Map */ ? thing.get(prop) : thing[prop];\n}\nfunction set(thing, propOrOldValue, value) {\n  const t = getArchtype(thing);\n  if (t === 2 /* Map */)\n    thing.set(propOrOldValue, value);\n  else if (t === 3 /* Set */) {\n    thing.add(value);\n  } else\n    thing[propOrOldValue] = value;\n}\nfunction is(x, y) {\n  if (x === y) {\n    return x !== 0 || 1 / x === 1 / y;\n  } else {\n    return x !== x && y !== y;\n  }\n}\nfunction isMap(target) {\n  return target instanceof Map;\n}\nfunction isSet(target) {\n  return target instanceof Set;\n}\nfunction latest(state) {\n  return state.copy_ || state.base_;\n}\nfunction shallowCopy(base, strict) {\n  if (isMap(base)) {\n    return new Map(base);\n  }\n  if (isSet(base)) {\n    return new Set(base);\n  }\n  if (Array.isArray(base))\n    return Array.prototype.slice.call(base);\n  const isPlain = isPlainObject(base);\n  if (strict === true || strict === \"class_only\" && !isPlain) {\n    const descriptors = Object.getOwnPropertyDescriptors(base);\n    delete descriptors[DRAFT_STATE];\n    let keys = Reflect.ownKeys(descriptors);\n    for (let i = 0; i < keys.length; i++) {\n      const key = keys[i];\n      const desc = descriptors[key];\n      if (desc.writable === false) {\n        desc.writable = true;\n        desc.configurable = true;\n      }\n      if (desc.get || desc.set)\n        descriptors[key] = {\n          configurable: true,\n          writable: true,\n          // could live with !!desc.set as well here...\n          enumerable: desc.enumerable,\n          value: base[key]\n        };\n    }\n    return Object.create(getPrototypeOf(base), descriptors);\n  } else {\n    const proto = getPrototypeOf(base);\n    if (proto !== null && isPlain) {\n      return { ...base };\n    }\n    const obj = Object.create(proto);\n    return Object.assign(obj, base);\n  }\n}\nfunction freeze(obj, deep = false) {\n  if (isFrozen(obj) || isDraft(obj) || !isDraftable(obj))\n    return obj;\n  if (getArchtype(obj) > 1) {\n    obj.set = obj.add = obj.clear = obj.delete = dontMutateFrozenCollections;\n  }\n  Object.freeze(obj);\n  if (deep)\n    Object.entries(obj).forEach(([key, value]) => freeze(value, true));\n  return obj;\n}\nfunction dontMutateFrozenCollections() {\n  die(2);\n}\nfunction isFrozen(obj) {\n  return Object.isFrozen(obj);\n}\n\n// src/utils/plugins.ts\nvar plugins = {};\nfunction getPlugin(pluginKey) {\n  const plugin = plugins[pluginKey];\n  if (!plugin) {\n    die(0, pluginKey);\n  }\n  return plugin;\n}\nfunction loadPlugin(pluginKey, implementation) {\n  if (!plugins[pluginKey])\n    plugins[pluginKey] = implementation;\n}\n\n// src/core/scope.ts\nvar currentScope;\nfunction getCurrentScope() {\n  return currentScope;\n}\nfunction createScope(parent_, immer_) {\n  return {\n    drafts_: [],\n    parent_,\n    immer_,\n    // Whenever the modified draft contains a draft from another scope, we\n    // need to prevent auto-freezing so the unowned draft can be finalized.\n    canAutoFreeze_: true,\n    unfinalizedDrafts_: 0\n  };\n}\nfunction usePatchesInScope(scope, patchListener) {\n  if (patchListener) {\n    getPlugin(\"Patches\");\n    scope.patches_ = [];\n    scope.inversePatches_ = [];\n    scope.patchListener_ = patchListener;\n  }\n}\nfunction revokeScope(scope) {\n  leaveScope(scope);\n  scope.drafts_.forEach(revokeDraft);\n  scope.drafts_ = null;\n}\nfunction leaveScope(scope) {\n  if (scope === currentScope) {\n    currentScope = scope.parent_;\n  }\n}\nfunction enterScope(immer2) {\n  return currentScope = createScope(currentScope, immer2);\n}\nfunction revokeDraft(draft) {\n  const state = draft[DRAFT_STATE];\n  if (state.type_ === 0 /* Object */ || state.type_ === 1 /* Array */)\n    state.revoke_();\n  else\n    state.revoked_ = true;\n}\n\n// src/core/finalize.ts\nfunction processResult(result, scope) {\n  scope.unfinalizedDrafts_ = scope.drafts_.length;\n  const baseDraft = scope.drafts_[0];\n  const isReplaced = result !== void 0 && result !== baseDraft;\n  if (isReplaced) {\n    if (baseDraft[DRAFT_STATE].modified_) {\n      revokeScope(scope);\n      die(4);\n    }\n    if (isDraftable(result)) {\n      result = finalize(scope, result);\n      if (!scope.parent_)\n        maybeFreeze(scope, result);\n    }\n    if (scope.patches_) {\n      getPlugin(\"Patches\").generateReplacementPatches_(\n        baseDraft[DRAFT_STATE].base_,\n        result,\n        scope.patches_,\n        scope.inversePatches_\n      );\n    }\n  } else {\n    result = finalize(scope, baseDraft, []);\n  }\n  revokeScope(scope);\n  if (scope.patches_) {\n    scope.patchListener_(scope.patches_, scope.inversePatches_);\n  }\n  return result !== NOTHING ? result : void 0;\n}\nfunction finalize(rootScope, value, path) {\n  if (isFrozen(value))\n    return value;\n  const state = value[DRAFT_STATE];\n  if (!state) {\n    each(\n      value,\n      (key, childValue) => finalizeProperty(rootScope, state, value, key, childValue, path)\n    );\n    return value;\n  }\n  if (state.scope_ !== rootScope)\n    return value;\n  if (!state.modified_) {\n    maybeFreeze(rootScope, state.base_, true);\n    return state.base_;\n  }\n  if (!state.finalized_) {\n    state.finalized_ = true;\n    state.scope_.unfinalizedDrafts_--;\n    const result = state.copy_;\n    let resultEach = result;\n    let isSet2 = false;\n    if (state.type_ === 3 /* Set */) {\n      resultEach = new Set(result);\n      result.clear();\n      isSet2 = true;\n    }\n    each(\n      resultEach,\n      (key, childValue) => finalizeProperty(rootScope, state, result, key, childValue, path, isSet2)\n    );\n    maybeFreeze(rootScope, result, false);\n    if (path && rootScope.patches_) {\n      getPlugin(\"Patches\").generatePatches_(\n        state,\n        path,\n        rootScope.patches_,\n        rootScope.inversePatches_\n      );\n    }\n  }\n  return state.copy_;\n}\nfunction finalizeProperty(rootScope, parentState, targetObject, prop, childValue, rootPath, targetIsSet) {\n  if ( true && childValue === targetObject)\n    die(5);\n  if (isDraft(childValue)) {\n    const path = rootPath && parentState && parentState.type_ !== 3 /* Set */ && // Set objects are atomic since they have no keys.\n    !has(parentState.assigned_, prop) ? rootPath.concat(prop) : void 0;\n    const res = finalize(rootScope, childValue, path);\n    set(targetObject, prop, res);\n    if (isDraft(res)) {\n      rootScope.canAutoFreeze_ = false;\n    } else\n      return;\n  } else if (targetIsSet) {\n    targetObject.add(childValue);\n  }\n  if (isDraftable(childValue) && !isFrozen(childValue)) {\n    if (!rootScope.immer_.autoFreeze_ && rootScope.unfinalizedDrafts_ < 1) {\n      return;\n    }\n    finalize(rootScope, childValue);\n    if ((!parentState || !parentState.scope_.parent_) && typeof prop !== \"symbol\" && Object.prototype.propertyIsEnumerable.call(targetObject, prop))\n      maybeFreeze(rootScope, childValue);\n  }\n}\nfunction maybeFreeze(scope, value, deep = false) {\n  if (!scope.parent_ && scope.immer_.autoFreeze_ && scope.canAutoFreeze_) {\n    freeze(value, deep);\n  }\n}\n\n// src/core/proxy.ts\nfunction createProxyProxy(base, parent) {\n  const isArray = Array.isArray(base);\n  const state = {\n    type_: isArray ? 1 /* Array */ : 0 /* Object */,\n    // Track which produce call this is associated with.\n    scope_: parent ? parent.scope_ : getCurrentScope(),\n    // True for both shallow and deep changes.\n    modified_: false,\n    // Used during finalization.\n    finalized_: false,\n    // Track which properties have been assigned (true) or deleted (false).\n    assigned_: {},\n    // The parent draft state.\n    parent_: parent,\n    // The base state.\n    base_: base,\n    // The base proxy.\n    draft_: null,\n    // set below\n    // The base copy with any updated values.\n    copy_: null,\n    // Called by the `produce` function.\n    revoke_: null,\n    isManual_: false\n  };\n  let target = state;\n  let traps = objectTraps;\n  if (isArray) {\n    target = [state];\n    traps = arrayTraps;\n  }\n  const { revoke, proxy } = Proxy.revocable(target, traps);\n  state.draft_ = proxy;\n  state.revoke_ = revoke;\n  return proxy;\n}\nvar objectTraps = {\n  get(state, prop) {\n    if (prop === DRAFT_STATE)\n      return state;\n    const source = latest(state);\n    if (!has(source, prop)) {\n      return readPropFromProto(state, source, prop);\n    }\n    const value = source[prop];\n    if (state.finalized_ || !isDraftable(value)) {\n      return value;\n    }\n    if (value === peek(state.base_, prop)) {\n      prepareCopy(state);\n      return state.copy_[prop] = createProxy(value, state);\n    }\n    return value;\n  },\n  has(state, prop) {\n    return prop in latest(state);\n  },\n  ownKeys(state) {\n    return Reflect.ownKeys(latest(state));\n  },\n  set(state, prop, value) {\n    const desc = getDescriptorFromProto(latest(state), prop);\n    if (desc?.set) {\n      desc.set.call(state.draft_, value);\n      return true;\n    }\n    if (!state.modified_) {\n      const current2 = peek(latest(state), prop);\n      const currentState = current2?.[DRAFT_STATE];\n      if (currentState && currentState.base_ === value) {\n        state.copy_[prop] = value;\n        state.assigned_[prop] = false;\n        return true;\n      }\n      if (is(value, current2) && (value !== void 0 || has(state.base_, prop)))\n        return true;\n      prepareCopy(state);\n      markChanged(state);\n    }\n    if (state.copy_[prop] === value && // special case: handle new props with value 'undefined'\n    (value !== void 0 || prop in state.copy_) || // special case: NaN\n    Number.isNaN(value) && Number.isNaN(state.copy_[prop]))\n      return true;\n    state.copy_[prop] = value;\n    state.assigned_[prop] = true;\n    return true;\n  },\n  deleteProperty(state, prop) {\n    if (peek(state.base_, prop) !== void 0 || prop in state.base_) {\n      state.assigned_[prop] = false;\n      prepareCopy(state);\n      markChanged(state);\n    } else {\n      delete state.assigned_[prop];\n    }\n    if (state.copy_) {\n      delete state.copy_[prop];\n    }\n    return true;\n  },\n  // Note: We never coerce `desc.value` into an Immer draft, because we can't make\n  // the same guarantee in ES5 mode.\n  getOwnPropertyDescriptor(state, prop) {\n    const owner = latest(state);\n    const desc = Reflect.getOwnPropertyDescriptor(owner, prop);\n    if (!desc)\n      return desc;\n    return {\n      writable: true,\n      configurable: state.type_ !== 1 /* Array */ || prop !== \"length\",\n      enumerable: desc.enumerable,\n      value: owner[prop]\n    };\n  },\n  defineProperty() {\n    die(11);\n  },\n  getPrototypeOf(state) {\n    return getPrototypeOf(state.base_);\n  },\n  setPrototypeOf() {\n    die(12);\n  }\n};\nvar arrayTraps = {};\neach(objectTraps, (key, fn) => {\n  arrayTraps[key] = function() {\n    arguments[0] = arguments[0][0];\n    return fn.apply(this, arguments);\n  };\n});\narrayTraps.deleteProperty = function(state, prop) {\n  if ( true && isNaN(parseInt(prop)))\n    die(13);\n  return arrayTraps.set.call(this, state, prop, void 0);\n};\narrayTraps.set = function(state, prop, value) {\n  if ( true && prop !== \"length\" && isNaN(parseInt(prop)))\n    die(14);\n  return objectTraps.set.call(this, state[0], prop, value, state[0]);\n};\nfunction peek(draft, prop) {\n  const state = draft[DRAFT_STATE];\n  const source = state ? latest(state) : draft;\n  return source[prop];\n}\nfunction readPropFromProto(state, source, prop) {\n  const desc = getDescriptorFromProto(source, prop);\n  return desc ? `value` in desc ? desc.value : (\n    // This is a very special case, if the prop is a getter defined by the\n    // prototype, we should invoke it with the draft as context!\n    desc.get?.call(state.draft_)\n  ) : void 0;\n}\nfunction getDescriptorFromProto(source, prop) {\n  if (!(prop in source))\n    return void 0;\n  let proto = getPrototypeOf(source);\n  while (proto) {\n    const desc = Object.getOwnPropertyDescriptor(proto, prop);\n    if (desc)\n      return desc;\n    proto = getPrototypeOf(proto);\n  }\n  return void 0;\n}\nfunction markChanged(state) {\n  if (!state.modified_) {\n    state.modified_ = true;\n    if (state.parent_) {\n      markChanged(state.parent_);\n    }\n  }\n}\nfunction prepareCopy(state) {\n  if (!state.copy_) {\n    state.copy_ = shallowCopy(\n      state.base_,\n      state.scope_.immer_.useStrictShallowCopy_\n    );\n  }\n}\n\n// src/core/immerClass.ts\nvar Immer2 = class {\n  constructor(config) {\n    this.autoFreeze_ = true;\n    this.useStrictShallowCopy_ = false;\n    /**\n     * The `produce` function takes a value and a \"recipe function\" (whose\n     * return value often depends on the base state). The recipe function is\n     * free to mutate its first argument however it wants. All mutations are\n     * only ever applied to a __copy__ of the base state.\n     *\n     * Pass only a function to create a \"curried producer\" which relieves you\n     * from passing the recipe function every time.\n     *\n     * Only plain objects and arrays are made mutable. All other objects are\n     * considered uncopyable.\n     *\n     * Note: This function is __bound__ to its `Immer` instance.\n     *\n     * @param {any} base - the initial state\n     * @param {Function} recipe - function that receives a proxy of the base state as first argument and which can be freely modified\n     * @param {Function} patchListener - optional function that will be called with all the patches produced here\n     * @returns {any} a new state, or the initial state if nothing was modified\n     */\n    this.produce = (base, recipe, patchListener) => {\n      if (typeof base === \"function\" && typeof recipe !== \"function\") {\n        const defaultBase = recipe;\n        recipe = base;\n        const self = this;\n        return function curriedProduce(base2 = defaultBase, ...args) {\n          return self.produce(base2, (draft) => recipe.call(this, draft, ...args));\n        };\n      }\n      if (typeof recipe !== \"function\")\n        die(6);\n      if (patchListener !== void 0 && typeof patchListener !== \"function\")\n        die(7);\n      let result;\n      if (isDraftable(base)) {\n        const scope = enterScope(this);\n        const proxy = createProxy(base, void 0);\n        let hasError = true;\n        try {\n          result = recipe(proxy);\n          hasError = false;\n        } finally {\n          if (hasError)\n            revokeScope(scope);\n          else\n            leaveScope(scope);\n        }\n        usePatchesInScope(scope, patchListener);\n        return processResult(result, scope);\n      } else if (!base || typeof base !== \"object\") {\n        result = recipe(base);\n        if (result === void 0)\n          result = base;\n        if (result === NOTHING)\n          result = void 0;\n        if (this.autoFreeze_)\n          freeze(result, true);\n        if (patchListener) {\n          const p = [];\n          const ip = [];\n          getPlugin(\"Patches\").generateReplacementPatches_(base, result, p, ip);\n          patchListener(p, ip);\n        }\n        return result;\n      } else\n        die(1, base);\n    };\n    this.produceWithPatches = (base, recipe) => {\n      if (typeof base === \"function\") {\n        return (state, ...args) => this.produceWithPatches(state, (draft) => base(draft, ...args));\n      }\n      let patches, inversePatches;\n      const result = this.produce(base, recipe, (p, ip) => {\n        patches = p;\n        inversePatches = ip;\n      });\n      return [result, patches, inversePatches];\n    };\n    if (typeof config?.autoFreeze === \"boolean\")\n      this.setAutoFreeze(config.autoFreeze);\n    if (typeof config?.useStrictShallowCopy === \"boolean\")\n      this.setUseStrictShallowCopy(config.useStrictShallowCopy);\n  }\n  createDraft(base) {\n    if (!isDraftable(base))\n      die(8);\n    if (isDraft(base))\n      base = current(base);\n    const scope = enterScope(this);\n    const proxy = createProxy(base, void 0);\n    proxy[DRAFT_STATE].isManual_ = true;\n    leaveScope(scope);\n    return proxy;\n  }\n  finishDraft(draft, patchListener) {\n    const state = draft && draft[DRAFT_STATE];\n    if (!state || !state.isManual_)\n      die(9);\n    const { scope_: scope } = state;\n    usePatchesInScope(scope, patchListener);\n    return processResult(void 0, scope);\n  }\n  /**\n   * Pass true to automatically freeze all copies created by Immer.\n   *\n   * By default, auto-freezing is enabled.\n   */\n  setAutoFreeze(value) {\n    this.autoFreeze_ = value;\n  }\n  /**\n   * Pass true to enable strict shallow copy.\n   *\n   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.\n   */\n  setUseStrictShallowCopy(value) {\n    this.useStrictShallowCopy_ = value;\n  }\n  applyPatches(base, patches) {\n    let i;\n    for (i = patches.length - 1; i >= 0; i--) {\n      const patch = patches[i];\n      if (patch.path.length === 0 && patch.op === \"replace\") {\n        base = patch.value;\n        break;\n      }\n    }\n    if (i > -1) {\n      patches = patches.slice(i + 1);\n    }\n    const applyPatchesImpl = getPlugin(\"Patches\").applyPatches_;\n    if (isDraft(base)) {\n      return applyPatchesImpl(base, patches);\n    }\n    return this.produce(\n      base,\n      (draft) => applyPatchesImpl(draft, patches)\n    );\n  }\n};\nfunction createProxy(value, parent) {\n  const draft = isMap(value) ? getPlugin(\"MapSet\").proxyMap_(value, parent) : isSet(value) ? getPlugin(\"MapSet\").proxySet_(value, parent) : createProxyProxy(value, parent);\n  const scope = parent ? parent.scope_ : getCurrentScope();\n  scope.drafts_.push(draft);\n  return draft;\n}\n\n// src/core/current.ts\nfunction current(value) {\n  if (!isDraft(value))\n    die(10, value);\n  return currentImpl(value);\n}\nfunction currentImpl(value) {\n  if (!isDraftable(value) || isFrozen(value))\n    return value;\n  const state = value[DRAFT_STATE];\n  let copy;\n  if (state) {\n    if (!state.modified_)\n      return state.base_;\n    state.finalized_ = true;\n    copy = shallowCopy(value, state.scope_.immer_.useStrictShallowCopy_);\n  } else {\n    copy = shallowCopy(value, true);\n  }\n  each(copy, (key, childValue) => {\n    set(copy, key, currentImpl(childValue));\n  });\n  if (state) {\n    state.finalized_ = false;\n  }\n  return copy;\n}\n\n// src/plugins/patches.ts\nfunction enablePatches() {\n  const errorOffset = 16;\n  if (true) {\n    errors.push(\n      'Sets cannot have \"replace\" patches.',\n      function(op) {\n        return \"Unsupported patch operation: \" + op;\n      },\n      function(path) {\n        return \"Cannot apply patch, path doesn't resolve: \" + path;\n      },\n      \"Patching reserved attributes like __proto__, prototype and constructor is not allowed\"\n    );\n  }\n  const REPLACE = \"replace\";\n  const ADD = \"add\";\n  const REMOVE = \"remove\";\n  function generatePatches_(state, basePath, patches, inversePatches) {\n    switch (state.type_) {\n      case 0 /* Object */:\n      case 2 /* Map */:\n        return generatePatchesFromAssigned(\n          state,\n          basePath,\n          patches,\n          inversePatches\n        );\n      case 1 /* Array */:\n        return generateArrayPatches(state, basePath, patches, inversePatches);\n      case 3 /* Set */:\n        return generateSetPatches(\n          state,\n          basePath,\n          patches,\n          inversePatches\n        );\n    }\n  }\n  function generateArrayPatches(state, basePath, patches, inversePatches) {\n    let { base_, assigned_ } = state;\n    let copy_ = state.copy_;\n    if (copy_.length < base_.length) {\n      ;\n      [base_, copy_] = [copy_, base_];\n      [patches, inversePatches] = [inversePatches, patches];\n    }\n    for (let i = 0; i < base_.length; i++) {\n      if (assigned_[i] && copy_[i] !== base_[i]) {\n        const path = basePath.concat([i]);\n        patches.push({\n          op: REPLACE,\n          path,\n          // Need to maybe clone it, as it can in fact be the original value\n          // due to the base/copy inversion at the start of this function\n          value: clonePatchValueIfNeeded(copy_[i])\n        });\n        inversePatches.push({\n          op: REPLACE,\n          path,\n          value: clonePatchValueIfNeeded(base_[i])\n        });\n      }\n    }\n    for (let i = base_.length; i < copy_.length; i++) {\n      const path = basePath.concat([i]);\n      patches.push({\n        op: ADD,\n        path,\n        // Need to maybe clone it, as it can in fact be the original value\n        // due to the base/copy inversion at the start of this function\n        value: clonePatchValueIfNeeded(copy_[i])\n      });\n    }\n    for (let i = copy_.length - 1; base_.length <= i; --i) {\n      const path = basePath.concat([i]);\n      inversePatches.push({\n        op: REMOVE,\n        path\n      });\n    }\n  }\n  function generatePatchesFromAssigned(state, basePath, patches, inversePatches) {\n    const { base_, copy_ } = state;\n    each(state.assigned_, (key, assignedValue) => {\n      const origValue = get(base_, key);\n      const value = get(copy_, key);\n      const op = !assignedValue ? REMOVE : has(base_, key) ? REPLACE : ADD;\n      if (origValue === value && op === REPLACE)\n        return;\n      const path = basePath.concat(key);\n      patches.push(op === REMOVE ? { op, path } : { op, path, value });\n      inversePatches.push(\n        op === ADD ? { op: REMOVE, path } : op === REMOVE ? { op: ADD, path, value: clonePatchValueIfNeeded(origValue) } : { op: REPLACE, path, value: clonePatchValueIfNeeded(origValue) }\n      );\n    });\n  }\n  function generateSetPatches(state, basePath, patches, inversePatches) {\n    let { base_, copy_ } = state;\n    let i = 0;\n    base_.forEach((value) => {\n      if (!copy_.has(value)) {\n        const path = basePath.concat([i]);\n        patches.push({\n          op: REMOVE,\n          path,\n          value\n        });\n        inversePatches.unshift({\n          op: ADD,\n          path,\n          value\n        });\n      }\n      i++;\n    });\n    i = 0;\n    copy_.forEach((value) => {\n      if (!base_.has(value)) {\n        const path = basePath.concat([i]);\n        patches.push({\n          op: ADD,\n          path,\n          value\n        });\n        inversePatches.unshift({\n          op: REMOVE,\n          path,\n          value\n        });\n      }\n      i++;\n    });\n  }\n  function generateReplacementPatches_(baseValue, replacement, patches, inversePatches) {\n    patches.push({\n      op: REPLACE,\n      path: [],\n      value: replacement === NOTHING ? void 0 : replacement\n    });\n    inversePatches.push({\n      op: REPLACE,\n      path: [],\n      value: baseValue\n    });\n  }\n  function applyPatches_(draft, patches) {\n    patches.forEach((patch) => {\n      const { path, op } = patch;\n      let base = draft;\n      for (let i = 0; i < path.length - 1; i++) {\n        const parentType = getArchtype(base);\n        let p = path[i];\n        if (typeof p !== \"string\" && typeof p !== \"number\") {\n          p = \"\" + p;\n        }\n        if ((parentType === 0 /* Object */ || parentType === 1 /* Array */) && (p === \"__proto__\" || p === \"constructor\"))\n          die(errorOffset + 3);\n        if (typeof base === \"function\" && p === \"prototype\")\n          die(errorOffset + 3);\n        base = get(base, p);\n        if (typeof base !== \"object\")\n          die(errorOffset + 2, path.join(\"/\"));\n      }\n      const type = getArchtype(base);\n      const value = deepClonePatchValue(patch.value);\n      const key = path[path.length - 1];\n      switch (op) {\n        case REPLACE:\n          switch (type) {\n            case 2 /* Map */:\n              return base.set(key, value);\n            case 3 /* Set */:\n              die(errorOffset);\n            default:\n              return base[key] = value;\n          }\n        case ADD:\n          switch (type) {\n            case 1 /* Array */:\n              return key === \"-\" ? base.push(value) : base.splice(key, 0, value);\n            case 2 /* Map */:\n              return base.set(key, value);\n            case 3 /* Set */:\n              return base.add(value);\n            default:\n              return base[key] = value;\n          }\n        case REMOVE:\n          switch (type) {\n            case 1 /* Array */:\n              return base.splice(key, 1);\n            case 2 /* Map */:\n              return base.delete(key);\n            case 3 /* Set */:\n              return base.delete(patch.value);\n            default:\n              return delete base[key];\n          }\n        default:\n          die(errorOffset + 1, op);\n      }\n    });\n    return draft;\n  }\n  function deepClonePatchValue(obj) {\n    if (!isDraftable(obj))\n      return obj;\n    if (Array.isArray(obj))\n      return obj.map(deepClonePatchValue);\n    if (isMap(obj))\n      return new Map(\n        Array.from(obj.entries()).map(([k, v]) => [k, deepClonePatchValue(v)])\n      );\n    if (isSet(obj))\n      return new Set(Array.from(obj).map(deepClonePatchValue));\n    const cloned = Object.create(getPrototypeOf(obj));\n    for (const key in obj)\n      cloned[key] = deepClonePatchValue(obj[key]);\n    if (has(obj, DRAFTABLE))\n      cloned[DRAFTABLE] = obj[DRAFTABLE];\n    return cloned;\n  }\n  function clonePatchValueIfNeeded(obj) {\n    if (isDraft(obj)) {\n      return deepClonePatchValue(obj);\n    } else\n      return obj;\n  }\n  loadPlugin(\"Patches\", {\n    applyPatches_,\n    generatePatches_,\n    generateReplacementPatches_\n  });\n}\n\n// src/plugins/mapset.ts\nfunction enableMapSet() {\n  class DraftMap extends Map {\n    constructor(target, parent) {\n      super();\n      this[DRAFT_STATE] = {\n        type_: 2 /* Map */,\n        parent_: parent,\n        scope_: parent ? parent.scope_ : getCurrentScope(),\n        modified_: false,\n        finalized_: false,\n        copy_: void 0,\n        assigned_: void 0,\n        base_: target,\n        draft_: this,\n        isManual_: false,\n        revoked_: false\n      };\n    }\n    get size() {\n      return latest(this[DRAFT_STATE]).size;\n    }\n    has(key) {\n      return latest(this[DRAFT_STATE]).has(key);\n    }\n    set(key, value) {\n      const state = this[DRAFT_STATE];\n      assertUnrevoked(state);\n      if (!latest(state).has(key) || latest(state).get(key) !== value) {\n        prepareMapCopy(state);\n        markChanged(state);\n        state.assigned_.set(key, true);\n        state.copy_.set(key, value);\n        state.assigned_.set(key, true);\n      }\n      return this;\n    }\n    delete(key) {\n      if (!this.has(key)) {\n        return false;\n      }\n      const state = this[DRAFT_STATE];\n      assertUnrevoked(state);\n      prepareMapCopy(state);\n      markChanged(state);\n      if (state.base_.has(key)) {\n        state.assigned_.set(key, false);\n      } else {\n        state.assigned_.delete(key);\n      }\n      state.copy_.delete(key);\n      return true;\n    }\n    clear() {\n      const state = this[DRAFT_STATE];\n      assertUnrevoked(state);\n      if (latest(state).size) {\n        prepareMapCopy(state);\n        markChanged(state);\n        state.assigned_ = /* @__PURE__ */ new Map();\n        each(state.base_, (key) => {\n          state.assigned_.set(key, false);\n        });\n        state.copy_.clear();\n      }\n    }\n    forEach(cb, thisArg) {\n      const state = this[DRAFT_STATE];\n      latest(state).forEach((_value, key, _map) => {\n        cb.call(thisArg, this.get(key), key, this);\n      });\n    }\n    get(key) {\n      const state = this[DRAFT_STATE];\n      assertUnrevoked(state);\n      const value = latest(state).get(key);\n      if (state.finalized_ || !isDraftable(value)) {\n        return value;\n      }\n      if (value !== state.base_.get(key)) {\n        return value;\n      }\n      const draft = createProxy(value, state);\n      prepareMapCopy(state);\n      state.copy_.set(key, draft);\n      return draft;\n    }\n    keys() {\n      return latest(this[DRAFT_STATE]).keys();\n    }\n    values() {\n      const iterator = this.keys();\n      return {\n        [Symbol.iterator]: () => this.values(),\n        next: () => {\n          const r = iterator.next();\n          if (r.done)\n            return r;\n          const value = this.get(r.value);\n          return {\n            done: false,\n            value\n          };\n        }\n      };\n    }\n    entries() {\n      const iterator = this.keys();\n      return {\n        [Symbol.iterator]: () => this.entries(),\n        next: () => {\n          const r = iterator.next();\n          if (r.done)\n            return r;\n          const value = this.get(r.value);\n          return {\n            done: false,\n            value: [r.value, value]\n          };\n        }\n      };\n    }\n    [(DRAFT_STATE, Symbol.iterator)]() {\n      return this.entries();\n    }\n  }\n  function proxyMap_(target, parent) {\n    return new DraftMap(target, parent);\n  }\n  function prepareMapCopy(state) {\n    if (!state.copy_) {\n      state.assigned_ = /* @__PURE__ */ new Map();\n      state.copy_ = new Map(state.base_);\n    }\n  }\n  class DraftSet extends Set {\n    constructor(target, parent) {\n      super();\n      this[DRAFT_STATE] = {\n        type_: 3 /* Set */,\n        parent_: parent,\n        scope_: parent ? parent.scope_ : getCurrentScope(),\n        modified_: false,\n        finalized_: false,\n        copy_: void 0,\n        base_: target,\n        draft_: this,\n        drafts_: /* @__PURE__ */ new Map(),\n        revoked_: false,\n        isManual_: false\n      };\n    }\n    get size() {\n      return latest(this[DRAFT_STATE]).size;\n    }\n    has(value) {\n      const state = this[DRAFT_STATE];\n      assertUnrevoked(state);\n      if (!state.copy_) {\n        return state.base_.has(value);\n      }\n      if (state.copy_.has(value))\n        return true;\n      if (state.drafts_.has(value) && state.copy_.has(state.drafts_.get(value)))\n        return true;\n      return false;\n    }\n    add(value) {\n      const state = this[DRAFT_STATE];\n      assertUnrevoked(state);\n      if (!this.has(value)) {\n        prepareSetCopy(state);\n        markChanged(state);\n        state.copy_.add(value);\n      }\n      return this;\n    }\n    delete(value) {\n      if (!this.has(value)) {\n        return false;\n      }\n      const state = this[DRAFT_STATE];\n      assertUnrevoked(state);\n      prepareSetCopy(state);\n      markChanged(state);\n      return state.copy_.delete(value) || (state.drafts_.has(value) ? state.copy_.delete(state.drafts_.get(value)) : (\n        /* istanbul ignore next */\n        false\n      ));\n    }\n    clear() {\n      const state = this[DRAFT_STATE];\n      assertUnrevoked(state);\n      if (latest(state).size) {\n        prepareSetCopy(state);\n        markChanged(state);\n        state.copy_.clear();\n      }\n    }\n    values() {\n      const state = this[DRAFT_STATE];\n      assertUnrevoked(state);\n      prepareSetCopy(state);\n      return state.copy_.values();\n    }\n    entries() {\n      const state = this[DRAFT_STATE];\n      assertUnrevoked(state);\n      prepareSetCopy(state);\n      return state.copy_.entries();\n    }\n    keys() {\n      return this.values();\n    }\n    [(DRAFT_STATE, Symbol.iterator)]() {\n      return this.values();\n    }\n    forEach(cb, thisArg) {\n      const iterator = this.values();\n      let result = iterator.next();\n      while (!result.done) {\n        cb.call(thisArg, result.value, result.value, this);\n        result = iterator.next();\n      }\n    }\n  }\n  function proxySet_(target, parent) {\n    return new DraftSet(target, parent);\n  }\n  function prepareSetCopy(state) {\n    if (!state.copy_) {\n      state.copy_ = /* @__PURE__ */ new Set();\n      state.base_.forEach((value) => {\n        if (isDraftable(value)) {\n          const draft = createProxy(value, state);\n          state.drafts_.set(value, draft);\n          state.copy_.add(draft);\n        } else {\n          state.copy_.add(value);\n        }\n      });\n    }\n  }\n  function assertUnrevoked(state) {\n    if (state.revoked_)\n      die(3, JSON.stringify(latest(state)));\n  }\n  loadPlugin(\"MapSet\", { proxyMap_, proxySet_ });\n}\n\n// src/immer.ts\nvar immer = new Immer2();\nvar produce = immer.produce;\nvar produceWithPatches = immer.produceWithPatches.bind(\n  immer\n);\nvar setAutoFreeze = immer.setAutoFreeze.bind(immer);\nvar setUseStrictShallowCopy = immer.setUseStrictShallowCopy.bind(immer);\nvar applyPatches = immer.applyPatches.bind(immer);\nvar createDraft = immer.createDraft.bind(immer);\nvar finishDraft = immer.finishDraft.bind(immer);\nfunction castDraft(value) {\n  return value;\n}\nfunction castImmutable(value) {\n  return value;\n}\n\n//# sourceMappingURL=immer.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9pbW1lci9kaXN0L2ltbWVyLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLEtBQXFDO0FBQ2xEO0FBQ0E7QUFDQSw4QkFBOEIsT0FBTyxrRkFBa0YsT0FBTztBQUM5SCxHQUFHO0FBQ0g7QUFDQSxpS0FBaUssTUFBTTtBQUN2SyxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLE1BQU07QUFDcEQsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsTUFBTTtBQUNyRDtBQUNBO0FBQ0E7QUFDQSxJQUFJLENBQUU7QUFDTjtBQUNBLE1BQU0sSUFBcUM7QUFDM0M7QUFDQTtBQUNBLCtCQUErQixJQUFJO0FBQ25DO0FBQ0E7QUFDQSxrQ0FBa0MsTUFBTTtBQUN4QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sS0FBcUM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGdCQUFnQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsTUFBTSxLQUFxQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sS0FBcUM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsS0FBSztBQUNwQixlQUFlLFVBQVU7QUFDekIsZUFBZSxVQUFVO0FBQ3pCLGlCQUFpQixLQUFLO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdCQUFnQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsUUFBUTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sSUFBcUM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsbUJBQW1CO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsK0JBQStCLGtCQUFrQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLG1DQUFtQyxtQkFBbUI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsWUFBWSxlQUFlO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLFdBQVcsSUFBSSxpQkFBaUI7QUFDckU7QUFDQSx1QkFBdUIsbUJBQW1CLG9CQUFvQiwyREFBMkQsSUFBSTtBQUM3SDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsVUFBVSxlQUFlO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGNBQWMsV0FBVztBQUN6QjtBQUNBLHNCQUFzQixxQkFBcUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixzQkFBc0I7QUFDL0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXFCRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9pbW1lci9kaXN0L2ltbWVyLm1qcz83MWY3Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy91dGlscy9lbnYudHNcbnZhciBOT1RISU5HID0gU3ltYm9sLmZvcihcImltbWVyLW5vdGhpbmdcIik7XG52YXIgRFJBRlRBQkxFID0gU3ltYm9sLmZvcihcImltbWVyLWRyYWZ0YWJsZVwiKTtcbnZhciBEUkFGVF9TVEFURSA9IFN5bWJvbC5mb3IoXCJpbW1lci1zdGF0ZVwiKTtcblxuLy8gc3JjL3V0aWxzL2Vycm9ycy50c1xudmFyIGVycm9ycyA9IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFtcbiAgLy8gQWxsIGVycm9yIGNvZGVzLCBzdGFydGluZyBieSAwOlxuICBmdW5jdGlvbihwbHVnaW4pIHtcbiAgICByZXR1cm4gYFRoZSBwbHVnaW4gZm9yICcke3BsdWdpbn0nIGhhcyBub3QgYmVlbiBsb2FkZWQgaW50byBJbW1lci4gVG8gZW5hYmxlIHRoZSBwbHVnaW4sIGltcG9ydCBhbmQgY2FsbCBcXGBlbmFibGUke3BsdWdpbn0oKVxcYCB3aGVuIGluaXRpYWxpemluZyB5b3VyIGFwcGxpY2F0aW9uLmA7XG4gIH0sXG4gIGZ1bmN0aW9uKHRoaW5nKSB7XG4gICAgcmV0dXJuIGBwcm9kdWNlIGNhbiBvbmx5IGJlIGNhbGxlZCBvbiB0aGluZ3MgdGhhdCBhcmUgZHJhZnRhYmxlOiBwbGFpbiBvYmplY3RzLCBhcnJheXMsIE1hcCwgU2V0IG9yIGNsYXNzZXMgdGhhdCBhcmUgbWFya2VkIHdpdGggJ1tpbW1lcmFibGVdOiB0cnVlJy4gR290ICcke3RoaW5nfSdgO1xuICB9LFxuICBcIlRoaXMgb2JqZWN0IGhhcyBiZWVuIGZyb3plbiBhbmQgc2hvdWxkIG5vdCBiZSBtdXRhdGVkXCIsXG4gIGZ1bmN0aW9uKGRhdGEpIHtcbiAgICByZXR1cm4gXCJDYW5ub3QgdXNlIGEgcHJveHkgdGhhdCBoYXMgYmVlbiByZXZva2VkLiBEaWQgeW91IHBhc3MgYW4gb2JqZWN0IGZyb20gaW5zaWRlIGFuIGltbWVyIGZ1bmN0aW9uIHRvIGFuIGFzeW5jIHByb2Nlc3M/IFwiICsgZGF0YTtcbiAgfSxcbiAgXCJBbiBpbW1lciBwcm9kdWNlciByZXR1cm5lZCBhIG5ldyB2YWx1ZSAqYW5kKiBtb2RpZmllZCBpdHMgZHJhZnQuIEVpdGhlciByZXR1cm4gYSBuZXcgdmFsdWUgKm9yKiBtb2RpZnkgdGhlIGRyYWZ0LlwiLFxuICBcIkltbWVyIGZvcmJpZHMgY2lyY3VsYXIgcmVmZXJlbmNlc1wiLFxuICBcIlRoZSBmaXJzdCBvciBzZWNvbmQgYXJndW1lbnQgdG8gYHByb2R1Y2VgIG11c3QgYmUgYSBmdW5jdGlvblwiLFxuICBcIlRoZSB0aGlyZCBhcmd1bWVudCB0byBgcHJvZHVjZWAgbXVzdCBiZSBhIGZ1bmN0aW9uIG9yIHVuZGVmaW5lZFwiLFxuICBcIkZpcnN0IGFyZ3VtZW50IHRvIGBjcmVhdGVEcmFmdGAgbXVzdCBiZSBhIHBsYWluIG9iamVjdCwgYW4gYXJyYXksIG9yIGFuIGltbWVyYWJsZSBvYmplY3RcIixcbiAgXCJGaXJzdCBhcmd1bWVudCB0byBgZmluaXNoRHJhZnRgIG11c3QgYmUgYSBkcmFmdCByZXR1cm5lZCBieSBgY3JlYXRlRHJhZnRgXCIsXG4gIGZ1bmN0aW9uKHRoaW5nKSB7XG4gICAgcmV0dXJuIGAnY3VycmVudCcgZXhwZWN0cyBhIGRyYWZ0LCBnb3Q6ICR7dGhpbmd9YDtcbiAgfSxcbiAgXCJPYmplY3QuZGVmaW5lUHJvcGVydHkoKSBjYW5ub3QgYmUgdXNlZCBvbiBhbiBJbW1lciBkcmFmdFwiLFxuICBcIk9iamVjdC5zZXRQcm90b3R5cGVPZigpIGNhbm5vdCBiZSB1c2VkIG9uIGFuIEltbWVyIGRyYWZ0XCIsXG4gIFwiSW1tZXIgb25seSBzdXBwb3J0cyBkZWxldGluZyBhcnJheSBpbmRpY2VzXCIsXG4gIFwiSW1tZXIgb25seSBzdXBwb3J0cyBzZXR0aW5nIGFycmF5IGluZGljZXMgYW5kIHRoZSAnbGVuZ3RoJyBwcm9wZXJ0eVwiLFxuICBmdW5jdGlvbih0aGluZykge1xuICAgIHJldHVybiBgJ29yaWdpbmFsJyBleHBlY3RzIGEgZHJhZnQsIGdvdDogJHt0aGluZ31gO1xuICB9XG4gIC8vIE5vdGU6IGlmIG1vcmUgZXJyb3JzIGFyZSBhZGRlZCwgdGhlIGVycm9yT2Zmc2V0IGluIFBhdGNoZXMudHMgc2hvdWxkIGJlIGluY3JlYXNlZFxuICAvLyBTZWUgUGF0Y2hlcy50cyBmb3IgYWRkaXRpb25hbCBlcnJvcnNcbl0gOiBbXTtcbmZ1bmN0aW9uIGRpZShlcnJvciwgLi4uYXJncykge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgY29uc3QgZSA9IGVycm9yc1tlcnJvcl07XG4gICAgY29uc3QgbXNnID0gdHlwZW9mIGUgPT09IFwiZnVuY3Rpb25cIiA/IGUuYXBwbHkobnVsbCwgYXJncykgOiBlO1xuICAgIHRocm93IG5ldyBFcnJvcihgW0ltbWVyXSAke21zZ31gKTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgYFtJbW1lcl0gbWluaWZpZWQgZXJyb3IgbnI6ICR7ZXJyb3J9LiBGdWxsIGVycm9yIGF0OiBodHRwczovL2JpdC5seS8zY1hFS1dmYFxuICApO1xufVxuXG4vLyBzcmMvdXRpbHMvY29tbW9uLnRzXG52YXIgZ2V0UHJvdG90eXBlT2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG5mdW5jdGlvbiBpc0RyYWZ0KHZhbHVlKSB7XG4gIHJldHVybiAhIXZhbHVlICYmICEhdmFsdWVbRFJBRlRfU1RBVEVdO1xufVxuZnVuY3Rpb24gaXNEcmFmdGFibGUodmFsdWUpIHtcbiAgaWYgKCF2YWx1ZSlcbiAgICByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBpc1BsYWluT2JqZWN0KHZhbHVlKSB8fCBBcnJheS5pc0FycmF5KHZhbHVlKSB8fCAhIXZhbHVlW0RSQUZUQUJMRV0gfHwgISF2YWx1ZS5jb25zdHJ1Y3Rvcj8uW0RSQUZUQUJMRV0gfHwgaXNNYXAodmFsdWUpIHx8IGlzU2V0KHZhbHVlKTtcbn1cbnZhciBvYmplY3RDdG9yU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS5jb25zdHJ1Y3Rvci50b1N0cmluZygpO1xuZnVuY3Rpb24gaXNQbGFpbk9iamVjdCh2YWx1ZSkge1xuICBpZiAoIXZhbHVlIHx8IHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIilcbiAgICByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IHByb3RvID0gZ2V0UHJvdG90eXBlT2YodmFsdWUpO1xuICBpZiAocHJvdG8gPT09IG51bGwpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBjb25zdCBDdG9yID0gT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwocHJvdG8sIFwiY29uc3RydWN0b3JcIikgJiYgcHJvdG8uY29uc3RydWN0b3I7XG4gIGlmIChDdG9yID09PSBPYmplY3QpXG4gICAgcmV0dXJuIHRydWU7XG4gIHJldHVybiB0eXBlb2YgQ3RvciA9PSBcImZ1bmN0aW9uXCIgJiYgRnVuY3Rpb24udG9TdHJpbmcuY2FsbChDdG9yKSA9PT0gb2JqZWN0Q3RvclN0cmluZztcbn1cbmZ1bmN0aW9uIG9yaWdpbmFsKHZhbHVlKSB7XG4gIGlmICghaXNEcmFmdCh2YWx1ZSkpXG4gICAgZGllKDE1LCB2YWx1ZSk7XG4gIHJldHVybiB2YWx1ZVtEUkFGVF9TVEFURV0uYmFzZV87XG59XG5mdW5jdGlvbiBlYWNoKG9iaiwgaXRlcikge1xuICBpZiAoZ2V0QXJjaHR5cGUob2JqKSA9PT0gMCAvKiBPYmplY3QgKi8pIHtcbiAgICBSZWZsZWN0Lm93bktleXMob2JqKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgIGl0ZXIoa2V5LCBvYmpba2V5XSwgb2JqKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmouZm9yRWFjaCgoZW50cnksIGluZGV4KSA9PiBpdGVyKGluZGV4LCBlbnRyeSwgb2JqKSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldEFyY2h0eXBlKHRoaW5nKSB7XG4gIGNvbnN0IHN0YXRlID0gdGhpbmdbRFJBRlRfU1RBVEVdO1xuICByZXR1cm4gc3RhdGUgPyBzdGF0ZS50eXBlXyA6IEFycmF5LmlzQXJyYXkodGhpbmcpID8gMSAvKiBBcnJheSAqLyA6IGlzTWFwKHRoaW5nKSA/IDIgLyogTWFwICovIDogaXNTZXQodGhpbmcpID8gMyAvKiBTZXQgKi8gOiAwIC8qIE9iamVjdCAqLztcbn1cbmZ1bmN0aW9uIGhhcyh0aGluZywgcHJvcCkge1xuICByZXR1cm4gZ2V0QXJjaHR5cGUodGhpbmcpID09PSAyIC8qIE1hcCAqLyA/IHRoaW5nLmhhcyhwcm9wKSA6IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGluZywgcHJvcCk7XG59XG5mdW5jdGlvbiBnZXQodGhpbmcsIHByb3ApIHtcbiAgcmV0dXJuIGdldEFyY2h0eXBlKHRoaW5nKSA9PT0gMiAvKiBNYXAgKi8gPyB0aGluZy5nZXQocHJvcCkgOiB0aGluZ1twcm9wXTtcbn1cbmZ1bmN0aW9uIHNldCh0aGluZywgcHJvcE9yT2xkVmFsdWUsIHZhbHVlKSB7XG4gIGNvbnN0IHQgPSBnZXRBcmNodHlwZSh0aGluZyk7XG4gIGlmICh0ID09PSAyIC8qIE1hcCAqLylcbiAgICB0aGluZy5zZXQocHJvcE9yT2xkVmFsdWUsIHZhbHVlKTtcbiAgZWxzZSBpZiAodCA9PT0gMyAvKiBTZXQgKi8pIHtcbiAgICB0aGluZy5hZGQodmFsdWUpO1xuICB9IGVsc2VcbiAgICB0aGluZ1twcm9wT3JPbGRWYWx1ZV0gPSB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGlzKHgsIHkpIHtcbiAgaWYgKHggPT09IHkpIHtcbiAgICByZXR1cm4geCAhPT0gMCB8fCAxIC8geCA9PT0gMSAvIHk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHggIT09IHggJiYgeSAhPT0geTtcbiAgfVxufVxuZnVuY3Rpb24gaXNNYXAodGFyZ2V0KSB7XG4gIHJldHVybiB0YXJnZXQgaW5zdGFuY2VvZiBNYXA7XG59XG5mdW5jdGlvbiBpc1NldCh0YXJnZXQpIHtcbiAgcmV0dXJuIHRhcmdldCBpbnN0YW5jZW9mIFNldDtcbn1cbmZ1bmN0aW9uIGxhdGVzdChzdGF0ZSkge1xuICByZXR1cm4gc3RhdGUuY29weV8gfHwgc3RhdGUuYmFzZV87XG59XG5mdW5jdGlvbiBzaGFsbG93Q29weShiYXNlLCBzdHJpY3QpIHtcbiAgaWYgKGlzTWFwKGJhc2UpKSB7XG4gICAgcmV0dXJuIG5ldyBNYXAoYmFzZSk7XG4gIH1cbiAgaWYgKGlzU2V0KGJhc2UpKSB7XG4gICAgcmV0dXJuIG5ldyBTZXQoYmFzZSk7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkoYmFzZSkpXG4gICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGJhc2UpO1xuICBjb25zdCBpc1BsYWluID0gaXNQbGFpbk9iamVjdChiYXNlKTtcbiAgaWYgKHN0cmljdCA9PT0gdHJ1ZSB8fCBzdHJpY3QgPT09IFwiY2xhc3Nfb25seVwiICYmICFpc1BsYWluKSB7XG4gICAgY29uc3QgZGVzY3JpcHRvcnMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhiYXNlKTtcbiAgICBkZWxldGUgZGVzY3JpcHRvcnNbRFJBRlRfU1RBVEVdO1xuICAgIGxldCBrZXlzID0gUmVmbGVjdC5vd25LZXlzKGRlc2NyaXB0b3JzKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGtleSA9IGtleXNbaV07XG4gICAgICBjb25zdCBkZXNjID0gZGVzY3JpcHRvcnNba2V5XTtcbiAgICAgIGlmIChkZXNjLndyaXRhYmxlID09PSBmYWxzZSkge1xuICAgICAgICBkZXNjLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgICAgZGVzYy5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGRlc2MuZ2V0IHx8IGRlc2Muc2V0KVxuICAgICAgICBkZXNjcmlwdG9yc1trZXldID0ge1xuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAvLyBjb3VsZCBsaXZlIHdpdGggISFkZXNjLnNldCBhcyB3ZWxsIGhlcmUuLi5cbiAgICAgICAgICBlbnVtZXJhYmxlOiBkZXNjLmVudW1lcmFibGUsXG4gICAgICAgICAgdmFsdWU6IGJhc2Vba2V5XVxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LmNyZWF0ZShnZXRQcm90b3R5cGVPZihiYXNlKSwgZGVzY3JpcHRvcnMpO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IHByb3RvID0gZ2V0UHJvdG90eXBlT2YoYmFzZSk7XG4gICAgaWYgKHByb3RvICE9PSBudWxsICYmIGlzUGxhaW4pIHtcbiAgICAgIHJldHVybiB7IC4uLmJhc2UgfTtcbiAgICB9XG4gICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShwcm90byk7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24ob2JqLCBiYXNlKTtcbiAgfVxufVxuZnVuY3Rpb24gZnJlZXplKG9iaiwgZGVlcCA9IGZhbHNlKSB7XG4gIGlmIChpc0Zyb3plbihvYmopIHx8IGlzRHJhZnQob2JqKSB8fCAhaXNEcmFmdGFibGUob2JqKSlcbiAgICByZXR1cm4gb2JqO1xuICBpZiAoZ2V0QXJjaHR5cGUob2JqKSA+IDEpIHtcbiAgICBvYmouc2V0ID0gb2JqLmFkZCA9IG9iai5jbGVhciA9IG9iai5kZWxldGUgPSBkb250TXV0YXRlRnJvemVuQ29sbGVjdGlvbnM7XG4gIH1cbiAgT2JqZWN0LmZyZWV6ZShvYmopO1xuICBpZiAoZGVlcClcbiAgICBPYmplY3QuZW50cmllcyhvYmopLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4gZnJlZXplKHZhbHVlLCB0cnVlKSk7XG4gIHJldHVybiBvYmo7XG59XG5mdW5jdGlvbiBkb250TXV0YXRlRnJvemVuQ29sbGVjdGlvbnMoKSB7XG4gIGRpZSgyKTtcbn1cbmZ1bmN0aW9uIGlzRnJvemVuKG9iaikge1xuICByZXR1cm4gT2JqZWN0LmlzRnJvemVuKG9iaik7XG59XG5cbi8vIHNyYy91dGlscy9wbHVnaW5zLnRzXG52YXIgcGx1Z2lucyA9IHt9O1xuZnVuY3Rpb24gZ2V0UGx1Z2luKHBsdWdpbktleSkge1xuICBjb25zdCBwbHVnaW4gPSBwbHVnaW5zW3BsdWdpbktleV07XG4gIGlmICghcGx1Z2luKSB7XG4gICAgZGllKDAsIHBsdWdpbktleSk7XG4gIH1cbiAgcmV0dXJuIHBsdWdpbjtcbn1cbmZ1bmN0aW9uIGxvYWRQbHVnaW4ocGx1Z2luS2V5LCBpbXBsZW1lbnRhdGlvbikge1xuICBpZiAoIXBsdWdpbnNbcGx1Z2luS2V5XSlcbiAgICBwbHVnaW5zW3BsdWdpbktleV0gPSBpbXBsZW1lbnRhdGlvbjtcbn1cblxuLy8gc3JjL2NvcmUvc2NvcGUudHNcbnZhciBjdXJyZW50U2NvcGU7XG5mdW5jdGlvbiBnZXRDdXJyZW50U2NvcGUoKSB7XG4gIHJldHVybiBjdXJyZW50U2NvcGU7XG59XG5mdW5jdGlvbiBjcmVhdGVTY29wZShwYXJlbnRfLCBpbW1lcl8pIHtcbiAgcmV0dXJuIHtcbiAgICBkcmFmdHNfOiBbXSxcbiAgICBwYXJlbnRfLFxuICAgIGltbWVyXyxcbiAgICAvLyBXaGVuZXZlciB0aGUgbW9kaWZpZWQgZHJhZnQgY29udGFpbnMgYSBkcmFmdCBmcm9tIGFub3RoZXIgc2NvcGUsIHdlXG4gICAgLy8gbmVlZCB0byBwcmV2ZW50IGF1dG8tZnJlZXppbmcgc28gdGhlIHVub3duZWQgZHJhZnQgY2FuIGJlIGZpbmFsaXplZC5cbiAgICBjYW5BdXRvRnJlZXplXzogdHJ1ZSxcbiAgICB1bmZpbmFsaXplZERyYWZ0c186IDBcbiAgfTtcbn1cbmZ1bmN0aW9uIHVzZVBhdGNoZXNJblNjb3BlKHNjb3BlLCBwYXRjaExpc3RlbmVyKSB7XG4gIGlmIChwYXRjaExpc3RlbmVyKSB7XG4gICAgZ2V0UGx1Z2luKFwiUGF0Y2hlc1wiKTtcbiAgICBzY29wZS5wYXRjaGVzXyA9IFtdO1xuICAgIHNjb3BlLmludmVyc2VQYXRjaGVzXyA9IFtdO1xuICAgIHNjb3BlLnBhdGNoTGlzdGVuZXJfID0gcGF0Y2hMaXN0ZW5lcjtcbiAgfVxufVxuZnVuY3Rpb24gcmV2b2tlU2NvcGUoc2NvcGUpIHtcbiAgbGVhdmVTY29wZShzY29wZSk7XG4gIHNjb3BlLmRyYWZ0c18uZm9yRWFjaChyZXZva2VEcmFmdCk7XG4gIHNjb3BlLmRyYWZ0c18gPSBudWxsO1xufVxuZnVuY3Rpb24gbGVhdmVTY29wZShzY29wZSkge1xuICBpZiAoc2NvcGUgPT09IGN1cnJlbnRTY29wZSkge1xuICAgIGN1cnJlbnRTY29wZSA9IHNjb3BlLnBhcmVudF87XG4gIH1cbn1cbmZ1bmN0aW9uIGVudGVyU2NvcGUoaW1tZXIyKSB7XG4gIHJldHVybiBjdXJyZW50U2NvcGUgPSBjcmVhdGVTY29wZShjdXJyZW50U2NvcGUsIGltbWVyMik7XG59XG5mdW5jdGlvbiByZXZva2VEcmFmdChkcmFmdCkge1xuICBjb25zdCBzdGF0ZSA9IGRyYWZ0W0RSQUZUX1NUQVRFXTtcbiAgaWYgKHN0YXRlLnR5cGVfID09PSAwIC8qIE9iamVjdCAqLyB8fCBzdGF0ZS50eXBlXyA9PT0gMSAvKiBBcnJheSAqLylcbiAgICBzdGF0ZS5yZXZva2VfKCk7XG4gIGVsc2VcbiAgICBzdGF0ZS5yZXZva2VkXyA9IHRydWU7XG59XG5cbi8vIHNyYy9jb3JlL2ZpbmFsaXplLnRzXG5mdW5jdGlvbiBwcm9jZXNzUmVzdWx0KHJlc3VsdCwgc2NvcGUpIHtcbiAgc2NvcGUudW5maW5hbGl6ZWREcmFmdHNfID0gc2NvcGUuZHJhZnRzXy5sZW5ndGg7XG4gIGNvbnN0IGJhc2VEcmFmdCA9IHNjb3BlLmRyYWZ0c19bMF07XG4gIGNvbnN0IGlzUmVwbGFjZWQgPSByZXN1bHQgIT09IHZvaWQgMCAmJiByZXN1bHQgIT09IGJhc2VEcmFmdDtcbiAgaWYgKGlzUmVwbGFjZWQpIHtcbiAgICBpZiAoYmFzZURyYWZ0W0RSQUZUX1NUQVRFXS5tb2RpZmllZF8pIHtcbiAgICAgIHJldm9rZVNjb3BlKHNjb3BlKTtcbiAgICAgIGRpZSg0KTtcbiAgICB9XG4gICAgaWYgKGlzRHJhZnRhYmxlKHJlc3VsdCkpIHtcbiAgICAgIHJlc3VsdCA9IGZpbmFsaXplKHNjb3BlLCByZXN1bHQpO1xuICAgICAgaWYgKCFzY29wZS5wYXJlbnRfKVxuICAgICAgICBtYXliZUZyZWV6ZShzY29wZSwgcmVzdWx0KTtcbiAgICB9XG4gICAgaWYgKHNjb3BlLnBhdGNoZXNfKSB7XG4gICAgICBnZXRQbHVnaW4oXCJQYXRjaGVzXCIpLmdlbmVyYXRlUmVwbGFjZW1lbnRQYXRjaGVzXyhcbiAgICAgICAgYmFzZURyYWZ0W0RSQUZUX1NUQVRFXS5iYXNlXyxcbiAgICAgICAgcmVzdWx0LFxuICAgICAgICBzY29wZS5wYXRjaGVzXyxcbiAgICAgICAgc2NvcGUuaW52ZXJzZVBhdGNoZXNfXG4gICAgICApO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXN1bHQgPSBmaW5hbGl6ZShzY29wZSwgYmFzZURyYWZ0LCBbXSk7XG4gIH1cbiAgcmV2b2tlU2NvcGUoc2NvcGUpO1xuICBpZiAoc2NvcGUucGF0Y2hlc18pIHtcbiAgICBzY29wZS5wYXRjaExpc3RlbmVyXyhzY29wZS5wYXRjaGVzXywgc2NvcGUuaW52ZXJzZVBhdGNoZXNfKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0ICE9PSBOT1RISU5HID8gcmVzdWx0IDogdm9pZCAwO1xufVxuZnVuY3Rpb24gZmluYWxpemUocm9vdFNjb3BlLCB2YWx1ZSwgcGF0aCkge1xuICBpZiAoaXNGcm96ZW4odmFsdWUpKVxuICAgIHJldHVybiB2YWx1ZTtcbiAgY29uc3Qgc3RhdGUgPSB2YWx1ZVtEUkFGVF9TVEFURV07XG4gIGlmICghc3RhdGUpIHtcbiAgICBlYWNoKFxuICAgICAgdmFsdWUsXG4gICAgICAoa2V5LCBjaGlsZFZhbHVlKSA9PiBmaW5hbGl6ZVByb3BlcnR5KHJvb3RTY29wZSwgc3RhdGUsIHZhbHVlLCBrZXksIGNoaWxkVmFsdWUsIHBhdGgpXG4gICAgKTtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKHN0YXRlLnNjb3BlXyAhPT0gcm9vdFNjb3BlKVxuICAgIHJldHVybiB2YWx1ZTtcbiAgaWYgKCFzdGF0ZS5tb2RpZmllZF8pIHtcbiAgICBtYXliZUZyZWV6ZShyb290U2NvcGUsIHN0YXRlLmJhc2VfLCB0cnVlKTtcbiAgICByZXR1cm4gc3RhdGUuYmFzZV87XG4gIH1cbiAgaWYgKCFzdGF0ZS5maW5hbGl6ZWRfKSB7XG4gICAgc3RhdGUuZmluYWxpemVkXyA9IHRydWU7XG4gICAgc3RhdGUuc2NvcGVfLnVuZmluYWxpemVkRHJhZnRzXy0tO1xuICAgIGNvbnN0IHJlc3VsdCA9IHN0YXRlLmNvcHlfO1xuICAgIGxldCByZXN1bHRFYWNoID0gcmVzdWx0O1xuICAgIGxldCBpc1NldDIgPSBmYWxzZTtcbiAgICBpZiAoc3RhdGUudHlwZV8gPT09IDMgLyogU2V0ICovKSB7XG4gICAgICByZXN1bHRFYWNoID0gbmV3IFNldChyZXN1bHQpO1xuICAgICAgcmVzdWx0LmNsZWFyKCk7XG4gICAgICBpc1NldDIgPSB0cnVlO1xuICAgIH1cbiAgICBlYWNoKFxuICAgICAgcmVzdWx0RWFjaCxcbiAgICAgIChrZXksIGNoaWxkVmFsdWUpID0+IGZpbmFsaXplUHJvcGVydHkocm9vdFNjb3BlLCBzdGF0ZSwgcmVzdWx0LCBrZXksIGNoaWxkVmFsdWUsIHBhdGgsIGlzU2V0MilcbiAgICApO1xuICAgIG1heWJlRnJlZXplKHJvb3RTY29wZSwgcmVzdWx0LCBmYWxzZSk7XG4gICAgaWYgKHBhdGggJiYgcm9vdFNjb3BlLnBhdGNoZXNfKSB7XG4gICAgICBnZXRQbHVnaW4oXCJQYXRjaGVzXCIpLmdlbmVyYXRlUGF0Y2hlc18oXG4gICAgICAgIHN0YXRlLFxuICAgICAgICBwYXRoLFxuICAgICAgICByb290U2NvcGUucGF0Y2hlc18sXG4gICAgICAgIHJvb3RTY29wZS5pbnZlcnNlUGF0Y2hlc19cbiAgICAgICk7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdGF0ZS5jb3B5Xztcbn1cbmZ1bmN0aW9uIGZpbmFsaXplUHJvcGVydHkocm9vdFNjb3BlLCBwYXJlbnRTdGF0ZSwgdGFyZ2V0T2JqZWN0LCBwcm9wLCBjaGlsZFZhbHVlLCByb290UGF0aCwgdGFyZ2V0SXNTZXQpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBjaGlsZFZhbHVlID09PSB0YXJnZXRPYmplY3QpXG4gICAgZGllKDUpO1xuICBpZiAoaXNEcmFmdChjaGlsZFZhbHVlKSkge1xuICAgIGNvbnN0IHBhdGggPSByb290UGF0aCAmJiBwYXJlbnRTdGF0ZSAmJiBwYXJlbnRTdGF0ZS50eXBlXyAhPT0gMyAvKiBTZXQgKi8gJiYgLy8gU2V0IG9iamVjdHMgYXJlIGF0b21pYyBzaW5jZSB0aGV5IGhhdmUgbm8ga2V5cy5cbiAgICAhaGFzKHBhcmVudFN0YXRlLmFzc2lnbmVkXywgcHJvcCkgPyByb290UGF0aC5jb25jYXQocHJvcCkgOiB2b2lkIDA7XG4gICAgY29uc3QgcmVzID0gZmluYWxpemUocm9vdFNjb3BlLCBjaGlsZFZhbHVlLCBwYXRoKTtcbiAgICBzZXQodGFyZ2V0T2JqZWN0LCBwcm9wLCByZXMpO1xuICAgIGlmIChpc0RyYWZ0KHJlcykpIHtcbiAgICAgIHJvb3RTY29wZS5jYW5BdXRvRnJlZXplXyA9IGZhbHNlO1xuICAgIH0gZWxzZVxuICAgICAgcmV0dXJuO1xuICB9IGVsc2UgaWYgKHRhcmdldElzU2V0KSB7XG4gICAgdGFyZ2V0T2JqZWN0LmFkZChjaGlsZFZhbHVlKTtcbiAgfVxuICBpZiAoaXNEcmFmdGFibGUoY2hpbGRWYWx1ZSkgJiYgIWlzRnJvemVuKGNoaWxkVmFsdWUpKSB7XG4gICAgaWYgKCFyb290U2NvcGUuaW1tZXJfLmF1dG9GcmVlemVfICYmIHJvb3RTY29wZS51bmZpbmFsaXplZERyYWZ0c18gPCAxKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZpbmFsaXplKHJvb3RTY29wZSwgY2hpbGRWYWx1ZSk7XG4gICAgaWYgKCghcGFyZW50U3RhdGUgfHwgIXBhcmVudFN0YXRlLnNjb3BlXy5wYXJlbnRfKSAmJiB0eXBlb2YgcHJvcCAhPT0gXCJzeW1ib2xcIiAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwodGFyZ2V0T2JqZWN0LCBwcm9wKSlcbiAgICAgIG1heWJlRnJlZXplKHJvb3RTY29wZSwgY2hpbGRWYWx1ZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIG1heWJlRnJlZXplKHNjb3BlLCB2YWx1ZSwgZGVlcCA9IGZhbHNlKSB7XG4gIGlmICghc2NvcGUucGFyZW50XyAmJiBzY29wZS5pbW1lcl8uYXV0b0ZyZWV6ZV8gJiYgc2NvcGUuY2FuQXV0b0ZyZWV6ZV8pIHtcbiAgICBmcmVlemUodmFsdWUsIGRlZXApO1xuICB9XG59XG5cbi8vIHNyYy9jb3JlL3Byb3h5LnRzXG5mdW5jdGlvbiBjcmVhdGVQcm94eVByb3h5KGJhc2UsIHBhcmVudCkge1xuICBjb25zdCBpc0FycmF5ID0gQXJyYXkuaXNBcnJheShiYXNlKTtcbiAgY29uc3Qgc3RhdGUgPSB7XG4gICAgdHlwZV86IGlzQXJyYXkgPyAxIC8qIEFycmF5ICovIDogMCAvKiBPYmplY3QgKi8sXG4gICAgLy8gVHJhY2sgd2hpY2ggcHJvZHVjZSBjYWxsIHRoaXMgaXMgYXNzb2NpYXRlZCB3aXRoLlxuICAgIHNjb3BlXzogcGFyZW50ID8gcGFyZW50LnNjb3BlXyA6IGdldEN1cnJlbnRTY29wZSgpLFxuICAgIC8vIFRydWUgZm9yIGJvdGggc2hhbGxvdyBhbmQgZGVlcCBjaGFuZ2VzLlxuICAgIG1vZGlmaWVkXzogZmFsc2UsXG4gICAgLy8gVXNlZCBkdXJpbmcgZmluYWxpemF0aW9uLlxuICAgIGZpbmFsaXplZF86IGZhbHNlLFxuICAgIC8vIFRyYWNrIHdoaWNoIHByb3BlcnRpZXMgaGF2ZSBiZWVuIGFzc2lnbmVkICh0cnVlKSBvciBkZWxldGVkIChmYWxzZSkuXG4gICAgYXNzaWduZWRfOiB7fSxcbiAgICAvLyBUaGUgcGFyZW50IGRyYWZ0IHN0YXRlLlxuICAgIHBhcmVudF86IHBhcmVudCxcbiAgICAvLyBUaGUgYmFzZSBzdGF0ZS5cbiAgICBiYXNlXzogYmFzZSxcbiAgICAvLyBUaGUgYmFzZSBwcm94eS5cbiAgICBkcmFmdF86IG51bGwsXG4gICAgLy8gc2V0IGJlbG93XG4gICAgLy8gVGhlIGJhc2UgY29weSB3aXRoIGFueSB1cGRhdGVkIHZhbHVlcy5cbiAgICBjb3B5XzogbnVsbCxcbiAgICAvLyBDYWxsZWQgYnkgdGhlIGBwcm9kdWNlYCBmdW5jdGlvbi5cbiAgICByZXZva2VfOiBudWxsLFxuICAgIGlzTWFudWFsXzogZmFsc2VcbiAgfTtcbiAgbGV0IHRhcmdldCA9IHN0YXRlO1xuICBsZXQgdHJhcHMgPSBvYmplY3RUcmFwcztcbiAgaWYgKGlzQXJyYXkpIHtcbiAgICB0YXJnZXQgPSBbc3RhdGVdO1xuICAgIHRyYXBzID0gYXJyYXlUcmFwcztcbiAgfVxuICBjb25zdCB7IHJldm9rZSwgcHJveHkgfSA9IFByb3h5LnJldm9jYWJsZSh0YXJnZXQsIHRyYXBzKTtcbiAgc3RhdGUuZHJhZnRfID0gcHJveHk7XG4gIHN0YXRlLnJldm9rZV8gPSByZXZva2U7XG4gIHJldHVybiBwcm94eTtcbn1cbnZhciBvYmplY3RUcmFwcyA9IHtcbiAgZ2V0KHN0YXRlLCBwcm9wKSB7XG4gICAgaWYgKHByb3AgPT09IERSQUZUX1NUQVRFKVxuICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIGNvbnN0IHNvdXJjZSA9IGxhdGVzdChzdGF0ZSk7XG4gICAgaWYgKCFoYXMoc291cmNlLCBwcm9wKSkge1xuICAgICAgcmV0dXJuIHJlYWRQcm9wRnJvbVByb3RvKHN0YXRlLCBzb3VyY2UsIHByb3ApO1xuICAgIH1cbiAgICBjb25zdCB2YWx1ZSA9IHNvdXJjZVtwcm9wXTtcbiAgICBpZiAoc3RhdGUuZmluYWxpemVkXyB8fCAhaXNEcmFmdGFibGUodmFsdWUpKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGlmICh2YWx1ZSA9PT0gcGVlayhzdGF0ZS5iYXNlXywgcHJvcCkpIHtcbiAgICAgIHByZXBhcmVDb3B5KHN0YXRlKTtcbiAgICAgIHJldHVybiBzdGF0ZS5jb3B5X1twcm9wXSA9IGNyZWF0ZVByb3h5KHZhbHVlLCBzdGF0ZSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfSxcbiAgaGFzKHN0YXRlLCBwcm9wKSB7XG4gICAgcmV0dXJuIHByb3AgaW4gbGF0ZXN0KHN0YXRlKTtcbiAgfSxcbiAgb3duS2V5cyhzdGF0ZSkge1xuICAgIHJldHVybiBSZWZsZWN0Lm93bktleXMobGF0ZXN0KHN0YXRlKSk7XG4gIH0sXG4gIHNldChzdGF0ZSwgcHJvcCwgdmFsdWUpIHtcbiAgICBjb25zdCBkZXNjID0gZ2V0RGVzY3JpcHRvckZyb21Qcm90byhsYXRlc3Qoc3RhdGUpLCBwcm9wKTtcbiAgICBpZiAoZGVzYz8uc2V0KSB7XG4gICAgICBkZXNjLnNldC5jYWxsKHN0YXRlLmRyYWZ0XywgdmFsdWUpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICghc3RhdGUubW9kaWZpZWRfKSB7XG4gICAgICBjb25zdCBjdXJyZW50MiA9IHBlZWsobGF0ZXN0KHN0YXRlKSwgcHJvcCk7XG4gICAgICBjb25zdCBjdXJyZW50U3RhdGUgPSBjdXJyZW50Mj8uW0RSQUZUX1NUQVRFXTtcbiAgICAgIGlmIChjdXJyZW50U3RhdGUgJiYgY3VycmVudFN0YXRlLmJhc2VfID09PSB2YWx1ZSkge1xuICAgICAgICBzdGF0ZS5jb3B5X1twcm9wXSA9IHZhbHVlO1xuICAgICAgICBzdGF0ZS5hc3NpZ25lZF9bcHJvcF0gPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoaXModmFsdWUsIGN1cnJlbnQyKSAmJiAodmFsdWUgIT09IHZvaWQgMCB8fCBoYXMoc3RhdGUuYmFzZV8sIHByb3ApKSlcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICBwcmVwYXJlQ29weShzdGF0ZSk7XG4gICAgICBtYXJrQ2hhbmdlZChzdGF0ZSk7XG4gICAgfVxuICAgIGlmIChzdGF0ZS5jb3B5X1twcm9wXSA9PT0gdmFsdWUgJiYgLy8gc3BlY2lhbCBjYXNlOiBoYW5kbGUgbmV3IHByb3BzIHdpdGggdmFsdWUgJ3VuZGVmaW5lZCdcbiAgICAodmFsdWUgIT09IHZvaWQgMCB8fCBwcm9wIGluIHN0YXRlLmNvcHlfKSB8fCAvLyBzcGVjaWFsIGNhc2U6IE5hTlxuICAgIE51bWJlci5pc05hTih2YWx1ZSkgJiYgTnVtYmVyLmlzTmFOKHN0YXRlLmNvcHlfW3Byb3BdKSlcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIHN0YXRlLmNvcHlfW3Byb3BdID0gdmFsdWU7XG4gICAgc3RhdGUuYXNzaWduZWRfW3Byb3BdID0gdHJ1ZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcbiAgZGVsZXRlUHJvcGVydHkoc3RhdGUsIHByb3ApIHtcbiAgICBpZiAocGVlayhzdGF0ZS5iYXNlXywgcHJvcCkgIT09IHZvaWQgMCB8fCBwcm9wIGluIHN0YXRlLmJhc2VfKSB7XG4gICAgICBzdGF0ZS5hc3NpZ25lZF9bcHJvcF0gPSBmYWxzZTtcbiAgICAgIHByZXBhcmVDb3B5KHN0YXRlKTtcbiAgICAgIG1hcmtDaGFuZ2VkKHN0YXRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIHN0YXRlLmFzc2lnbmVkX1twcm9wXTtcbiAgICB9XG4gICAgaWYgKHN0YXRlLmNvcHlfKSB7XG4gICAgICBkZWxldGUgc3RhdGUuY29weV9bcHJvcF07XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9LFxuICAvLyBOb3RlOiBXZSBuZXZlciBjb2VyY2UgYGRlc2MudmFsdWVgIGludG8gYW4gSW1tZXIgZHJhZnQsIGJlY2F1c2Ugd2UgY2FuJ3QgbWFrZVxuICAvLyB0aGUgc2FtZSBndWFyYW50ZWUgaW4gRVM1IG1vZGUuXG4gIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihzdGF0ZSwgcHJvcCkge1xuICAgIGNvbnN0IG93bmVyID0gbGF0ZXN0KHN0YXRlKTtcbiAgICBjb25zdCBkZXNjID0gUmVmbGVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob3duZXIsIHByb3ApO1xuICAgIGlmICghZGVzYylcbiAgICAgIHJldHVybiBkZXNjO1xuICAgIHJldHVybiB7XG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogc3RhdGUudHlwZV8gIT09IDEgLyogQXJyYXkgKi8gfHwgcHJvcCAhPT0gXCJsZW5ndGhcIixcbiAgICAgIGVudW1lcmFibGU6IGRlc2MuZW51bWVyYWJsZSxcbiAgICAgIHZhbHVlOiBvd25lcltwcm9wXVxuICAgIH07XG4gIH0sXG4gIGRlZmluZVByb3BlcnR5KCkge1xuICAgIGRpZSgxMSk7XG4gIH0sXG4gIGdldFByb3RvdHlwZU9mKHN0YXRlKSB7XG4gICAgcmV0dXJuIGdldFByb3RvdHlwZU9mKHN0YXRlLmJhc2VfKTtcbiAgfSxcbiAgc2V0UHJvdG90eXBlT2YoKSB7XG4gICAgZGllKDEyKTtcbiAgfVxufTtcbnZhciBhcnJheVRyYXBzID0ge307XG5lYWNoKG9iamVjdFRyYXBzLCAoa2V5LCBmbikgPT4ge1xuICBhcnJheVRyYXBzW2tleV0gPSBmdW5jdGlvbigpIHtcbiAgICBhcmd1bWVudHNbMF0gPSBhcmd1bWVudHNbMF1bMF07XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG59KTtcbmFycmF5VHJhcHMuZGVsZXRlUHJvcGVydHkgPSBmdW5jdGlvbihzdGF0ZSwgcHJvcCkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIGlzTmFOKHBhcnNlSW50KHByb3ApKSlcbiAgICBkaWUoMTMpO1xuICByZXR1cm4gYXJyYXlUcmFwcy5zZXQuY2FsbCh0aGlzLCBzdGF0ZSwgcHJvcCwgdm9pZCAwKTtcbn07XG5hcnJheVRyYXBzLnNldCA9IGZ1bmN0aW9uKHN0YXRlLCBwcm9wLCB2YWx1ZSkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIHByb3AgIT09IFwibGVuZ3RoXCIgJiYgaXNOYU4ocGFyc2VJbnQocHJvcCkpKVxuICAgIGRpZSgxNCk7XG4gIHJldHVybiBvYmplY3RUcmFwcy5zZXQuY2FsbCh0aGlzLCBzdGF0ZVswXSwgcHJvcCwgdmFsdWUsIHN0YXRlWzBdKTtcbn07XG5mdW5jdGlvbiBwZWVrKGRyYWZ0LCBwcm9wKSB7XG4gIGNvbnN0IHN0YXRlID0gZHJhZnRbRFJBRlRfU1RBVEVdO1xuICBjb25zdCBzb3VyY2UgPSBzdGF0ZSA/IGxhdGVzdChzdGF0ZSkgOiBkcmFmdDtcbiAgcmV0dXJuIHNvdXJjZVtwcm9wXTtcbn1cbmZ1bmN0aW9uIHJlYWRQcm9wRnJvbVByb3RvKHN0YXRlLCBzb3VyY2UsIHByb3ApIHtcbiAgY29uc3QgZGVzYyA9IGdldERlc2NyaXB0b3JGcm9tUHJvdG8oc291cmNlLCBwcm9wKTtcbiAgcmV0dXJuIGRlc2MgPyBgdmFsdWVgIGluIGRlc2MgPyBkZXNjLnZhbHVlIDogKFxuICAgIC8vIFRoaXMgaXMgYSB2ZXJ5IHNwZWNpYWwgY2FzZSwgaWYgdGhlIHByb3AgaXMgYSBnZXR0ZXIgZGVmaW5lZCBieSB0aGVcbiAgICAvLyBwcm90b3R5cGUsIHdlIHNob3VsZCBpbnZva2UgaXQgd2l0aCB0aGUgZHJhZnQgYXMgY29udGV4dCFcbiAgICBkZXNjLmdldD8uY2FsbChzdGF0ZS5kcmFmdF8pXG4gICkgOiB2b2lkIDA7XG59XG5mdW5jdGlvbiBnZXREZXNjcmlwdG9yRnJvbVByb3RvKHNvdXJjZSwgcHJvcCkge1xuICBpZiAoIShwcm9wIGluIHNvdXJjZSkpXG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgbGV0IHByb3RvID0gZ2V0UHJvdG90eXBlT2Yoc291cmNlKTtcbiAgd2hpbGUgKHByb3RvKSB7XG4gICAgY29uc3QgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IocHJvdG8sIHByb3ApO1xuICAgIGlmIChkZXNjKVxuICAgICAgcmV0dXJuIGRlc2M7XG4gICAgcHJvdG8gPSBnZXRQcm90b3R5cGVPZihwcm90byk7XG4gIH1cbiAgcmV0dXJuIHZvaWQgMDtcbn1cbmZ1bmN0aW9uIG1hcmtDaGFuZ2VkKHN0YXRlKSB7XG4gIGlmICghc3RhdGUubW9kaWZpZWRfKSB7XG4gICAgc3RhdGUubW9kaWZpZWRfID0gdHJ1ZTtcbiAgICBpZiAoc3RhdGUucGFyZW50Xykge1xuICAgICAgbWFya0NoYW5nZWQoc3RhdGUucGFyZW50Xyk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBwcmVwYXJlQ29weShzdGF0ZSkge1xuICBpZiAoIXN0YXRlLmNvcHlfKSB7XG4gICAgc3RhdGUuY29weV8gPSBzaGFsbG93Q29weShcbiAgICAgIHN0YXRlLmJhc2VfLFxuICAgICAgc3RhdGUuc2NvcGVfLmltbWVyXy51c2VTdHJpY3RTaGFsbG93Q29weV9cbiAgICApO1xuICB9XG59XG5cbi8vIHNyYy9jb3JlL2ltbWVyQ2xhc3MudHNcbnZhciBJbW1lcjIgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgIHRoaXMuYXV0b0ZyZWV6ZV8gPSB0cnVlO1xuICAgIHRoaXMudXNlU3RyaWN0U2hhbGxvd0NvcHlfID0gZmFsc2U7XG4gICAgLyoqXG4gICAgICogVGhlIGBwcm9kdWNlYCBmdW5jdGlvbiB0YWtlcyBhIHZhbHVlIGFuZCBhIFwicmVjaXBlIGZ1bmN0aW9uXCIgKHdob3NlXG4gICAgICogcmV0dXJuIHZhbHVlIG9mdGVuIGRlcGVuZHMgb24gdGhlIGJhc2Ugc3RhdGUpLiBUaGUgcmVjaXBlIGZ1bmN0aW9uIGlzXG4gICAgICogZnJlZSB0byBtdXRhdGUgaXRzIGZpcnN0IGFyZ3VtZW50IGhvd2V2ZXIgaXQgd2FudHMuIEFsbCBtdXRhdGlvbnMgYXJlXG4gICAgICogb25seSBldmVyIGFwcGxpZWQgdG8gYSBfX2NvcHlfXyBvZiB0aGUgYmFzZSBzdGF0ZS5cbiAgICAgKlxuICAgICAqIFBhc3Mgb25seSBhIGZ1bmN0aW9uIHRvIGNyZWF0ZSBhIFwiY3VycmllZCBwcm9kdWNlclwiIHdoaWNoIHJlbGlldmVzIHlvdVxuICAgICAqIGZyb20gcGFzc2luZyB0aGUgcmVjaXBlIGZ1bmN0aW9uIGV2ZXJ5IHRpbWUuXG4gICAgICpcbiAgICAgKiBPbmx5IHBsYWluIG9iamVjdHMgYW5kIGFycmF5cyBhcmUgbWFkZSBtdXRhYmxlLiBBbGwgb3RoZXIgb2JqZWN0cyBhcmVcbiAgICAgKiBjb25zaWRlcmVkIHVuY29weWFibGUuXG4gICAgICpcbiAgICAgKiBOb3RlOiBUaGlzIGZ1bmN0aW9uIGlzIF9fYm91bmRfXyB0byBpdHMgYEltbWVyYCBpbnN0YW5jZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7YW55fSBiYXNlIC0gdGhlIGluaXRpYWwgc3RhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSByZWNpcGUgLSBmdW5jdGlvbiB0aGF0IHJlY2VpdmVzIGEgcHJveHkgb2YgdGhlIGJhc2Ugc3RhdGUgYXMgZmlyc3QgYXJndW1lbnQgYW5kIHdoaWNoIGNhbiBiZSBmcmVlbHkgbW9kaWZpZWRcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwYXRjaExpc3RlbmVyIC0gb3B0aW9uYWwgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGNhbGxlZCB3aXRoIGFsbCB0aGUgcGF0Y2hlcyBwcm9kdWNlZCBoZXJlXG4gICAgICogQHJldHVybnMge2FueX0gYSBuZXcgc3RhdGUsIG9yIHRoZSBpbml0aWFsIHN0YXRlIGlmIG5vdGhpbmcgd2FzIG1vZGlmaWVkXG4gICAgICovXG4gICAgdGhpcy5wcm9kdWNlID0gKGJhc2UsIHJlY2lwZSwgcGF0Y2hMaXN0ZW5lcikgPT4ge1xuICAgICAgaWYgKHR5cGVvZiBiYXNlID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIHJlY2lwZSAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGNvbnN0IGRlZmF1bHRCYXNlID0gcmVjaXBlO1xuICAgICAgICByZWNpcGUgPSBiYXNlO1xuICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGN1cnJpZWRQcm9kdWNlKGJhc2UyID0gZGVmYXVsdEJhc2UsIC4uLmFyZ3MpIHtcbiAgICAgICAgICByZXR1cm4gc2VsZi5wcm9kdWNlKGJhc2UyLCAoZHJhZnQpID0+IHJlY2lwZS5jYWxsKHRoaXMsIGRyYWZ0LCAuLi5hcmdzKSk7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHJlY2lwZSAhPT0gXCJmdW5jdGlvblwiKVxuICAgICAgICBkaWUoNik7XG4gICAgICBpZiAocGF0Y2hMaXN0ZW5lciAhPT0gdm9pZCAwICYmIHR5cGVvZiBwYXRjaExpc3RlbmVyICE9PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgIGRpZSg3KTtcbiAgICAgIGxldCByZXN1bHQ7XG4gICAgICBpZiAoaXNEcmFmdGFibGUoYmFzZSkpIHtcbiAgICAgICAgY29uc3Qgc2NvcGUgPSBlbnRlclNjb3BlKHRoaXMpO1xuICAgICAgICBjb25zdCBwcm94eSA9IGNyZWF0ZVByb3h5KGJhc2UsIHZvaWQgMCk7XG4gICAgICAgIGxldCBoYXNFcnJvciA9IHRydWU7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmVzdWx0ID0gcmVjaXBlKHByb3h5KTtcbiAgICAgICAgICBoYXNFcnJvciA9IGZhbHNlO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGlmIChoYXNFcnJvcilcbiAgICAgICAgICAgIHJldm9rZVNjb3BlKHNjb3BlKTtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBsZWF2ZVNjb3BlKHNjb3BlKTtcbiAgICAgICAgfVxuICAgICAgICB1c2VQYXRjaGVzSW5TY29wZShzY29wZSwgcGF0Y2hMaXN0ZW5lcik7XG4gICAgICAgIHJldHVybiBwcm9jZXNzUmVzdWx0KHJlc3VsdCwgc2NvcGUpO1xuICAgICAgfSBlbHNlIGlmICghYmFzZSB8fCB0eXBlb2YgYmFzZSAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICByZXN1bHQgPSByZWNpcGUoYmFzZSk7XG4gICAgICAgIGlmIChyZXN1bHQgPT09IHZvaWQgMClcbiAgICAgICAgICByZXN1bHQgPSBiYXNlO1xuICAgICAgICBpZiAocmVzdWx0ID09PSBOT1RISU5HKVxuICAgICAgICAgIHJlc3VsdCA9IHZvaWQgMDtcbiAgICAgICAgaWYgKHRoaXMuYXV0b0ZyZWV6ZV8pXG4gICAgICAgICAgZnJlZXplKHJlc3VsdCwgdHJ1ZSk7XG4gICAgICAgIGlmIChwYXRjaExpc3RlbmVyKSB7XG4gICAgICAgICAgY29uc3QgcCA9IFtdO1xuICAgICAgICAgIGNvbnN0IGlwID0gW107XG4gICAgICAgICAgZ2V0UGx1Z2luKFwiUGF0Y2hlc1wiKS5nZW5lcmF0ZVJlcGxhY2VtZW50UGF0Y2hlc18oYmFzZSwgcmVzdWx0LCBwLCBpcCk7XG4gICAgICAgICAgcGF0Y2hMaXN0ZW5lcihwLCBpcCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0gZWxzZVxuICAgICAgICBkaWUoMSwgYmFzZSk7XG4gICAgfTtcbiAgICB0aGlzLnByb2R1Y2VXaXRoUGF0Y2hlcyA9IChiYXNlLCByZWNpcGUpID0+IHtcbiAgICAgIGlmICh0eXBlb2YgYmFzZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiAoc3RhdGUsIC4uLmFyZ3MpID0+IHRoaXMucHJvZHVjZVdpdGhQYXRjaGVzKHN0YXRlLCAoZHJhZnQpID0+IGJhc2UoZHJhZnQsIC4uLmFyZ3MpKTtcbiAgICAgIH1cbiAgICAgIGxldCBwYXRjaGVzLCBpbnZlcnNlUGF0Y2hlcztcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMucHJvZHVjZShiYXNlLCByZWNpcGUsIChwLCBpcCkgPT4ge1xuICAgICAgICBwYXRjaGVzID0gcDtcbiAgICAgICAgaW52ZXJzZVBhdGNoZXMgPSBpcDtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIFtyZXN1bHQsIHBhdGNoZXMsIGludmVyc2VQYXRjaGVzXTtcbiAgICB9O1xuICAgIGlmICh0eXBlb2YgY29uZmlnPy5hdXRvRnJlZXplID09PSBcImJvb2xlYW5cIilcbiAgICAgIHRoaXMuc2V0QXV0b0ZyZWV6ZShjb25maWcuYXV0b0ZyZWV6ZSk7XG4gICAgaWYgKHR5cGVvZiBjb25maWc/LnVzZVN0cmljdFNoYWxsb3dDb3B5ID09PSBcImJvb2xlYW5cIilcbiAgICAgIHRoaXMuc2V0VXNlU3RyaWN0U2hhbGxvd0NvcHkoY29uZmlnLnVzZVN0cmljdFNoYWxsb3dDb3B5KTtcbiAgfVxuICBjcmVhdGVEcmFmdChiYXNlKSB7XG4gICAgaWYgKCFpc0RyYWZ0YWJsZShiYXNlKSlcbiAgICAgIGRpZSg4KTtcbiAgICBpZiAoaXNEcmFmdChiYXNlKSlcbiAgICAgIGJhc2UgPSBjdXJyZW50KGJhc2UpO1xuICAgIGNvbnN0IHNjb3BlID0gZW50ZXJTY29wZSh0aGlzKTtcbiAgICBjb25zdCBwcm94eSA9IGNyZWF0ZVByb3h5KGJhc2UsIHZvaWQgMCk7XG4gICAgcHJveHlbRFJBRlRfU1RBVEVdLmlzTWFudWFsXyA9IHRydWU7XG4gICAgbGVhdmVTY29wZShzY29wZSk7XG4gICAgcmV0dXJuIHByb3h5O1xuICB9XG4gIGZpbmlzaERyYWZ0KGRyYWZ0LCBwYXRjaExpc3RlbmVyKSB7XG4gICAgY29uc3Qgc3RhdGUgPSBkcmFmdCAmJiBkcmFmdFtEUkFGVF9TVEFURV07XG4gICAgaWYgKCFzdGF0ZSB8fCAhc3RhdGUuaXNNYW51YWxfKVxuICAgICAgZGllKDkpO1xuICAgIGNvbnN0IHsgc2NvcGVfOiBzY29wZSB9ID0gc3RhdGU7XG4gICAgdXNlUGF0Y2hlc0luU2NvcGUoc2NvcGUsIHBhdGNoTGlzdGVuZXIpO1xuICAgIHJldHVybiBwcm9jZXNzUmVzdWx0KHZvaWQgMCwgc2NvcGUpO1xuICB9XG4gIC8qKlxuICAgKiBQYXNzIHRydWUgdG8gYXV0b21hdGljYWxseSBmcmVlemUgYWxsIGNvcGllcyBjcmVhdGVkIGJ5IEltbWVyLlxuICAgKlxuICAgKiBCeSBkZWZhdWx0LCBhdXRvLWZyZWV6aW5nIGlzIGVuYWJsZWQuXG4gICAqL1xuICBzZXRBdXRvRnJlZXplKHZhbHVlKSB7XG4gICAgdGhpcy5hdXRvRnJlZXplXyA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBQYXNzIHRydWUgdG8gZW5hYmxlIHN0cmljdCBzaGFsbG93IGNvcHkuXG4gICAqXG4gICAqIEJ5IGRlZmF1bHQsIGltbWVyIGRvZXMgbm90IGNvcHkgdGhlIG9iamVjdCBkZXNjcmlwdG9ycyBzdWNoIGFzIGdldHRlciwgc2V0dGVyIGFuZCBub24tZW51bXJhYmxlIHByb3BlcnRpZXMuXG4gICAqL1xuICBzZXRVc2VTdHJpY3RTaGFsbG93Q29weSh2YWx1ZSkge1xuICAgIHRoaXMudXNlU3RyaWN0U2hhbGxvd0NvcHlfID0gdmFsdWU7XG4gIH1cbiAgYXBwbHlQYXRjaGVzKGJhc2UsIHBhdGNoZXMpIHtcbiAgICBsZXQgaTtcbiAgICBmb3IgKGkgPSBwYXRjaGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBjb25zdCBwYXRjaCA9IHBhdGNoZXNbaV07XG4gICAgICBpZiAocGF0Y2gucGF0aC5sZW5ndGggPT09IDAgJiYgcGF0Y2gub3AgPT09IFwicmVwbGFjZVwiKSB7XG4gICAgICAgIGJhc2UgPSBwYXRjaC52YWx1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpID4gLTEpIHtcbiAgICAgIHBhdGNoZXMgPSBwYXRjaGVzLnNsaWNlKGkgKyAxKTtcbiAgICB9XG4gICAgY29uc3QgYXBwbHlQYXRjaGVzSW1wbCA9IGdldFBsdWdpbihcIlBhdGNoZXNcIikuYXBwbHlQYXRjaGVzXztcbiAgICBpZiAoaXNEcmFmdChiYXNlKSkge1xuICAgICAgcmV0dXJuIGFwcGx5UGF0Y2hlc0ltcGwoYmFzZSwgcGF0Y2hlcyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnByb2R1Y2UoXG4gICAgICBiYXNlLFxuICAgICAgKGRyYWZ0KSA9PiBhcHBseVBhdGNoZXNJbXBsKGRyYWZ0LCBwYXRjaGVzKVxuICAgICk7XG4gIH1cbn07XG5mdW5jdGlvbiBjcmVhdGVQcm94eSh2YWx1ZSwgcGFyZW50KSB7XG4gIGNvbnN0IGRyYWZ0ID0gaXNNYXAodmFsdWUpID8gZ2V0UGx1Z2luKFwiTWFwU2V0XCIpLnByb3h5TWFwXyh2YWx1ZSwgcGFyZW50KSA6IGlzU2V0KHZhbHVlKSA/IGdldFBsdWdpbihcIk1hcFNldFwiKS5wcm94eVNldF8odmFsdWUsIHBhcmVudCkgOiBjcmVhdGVQcm94eVByb3h5KHZhbHVlLCBwYXJlbnQpO1xuICBjb25zdCBzY29wZSA9IHBhcmVudCA/IHBhcmVudC5zY29wZV8gOiBnZXRDdXJyZW50U2NvcGUoKTtcbiAgc2NvcGUuZHJhZnRzXy5wdXNoKGRyYWZ0KTtcbiAgcmV0dXJuIGRyYWZ0O1xufVxuXG4vLyBzcmMvY29yZS9jdXJyZW50LnRzXG5mdW5jdGlvbiBjdXJyZW50KHZhbHVlKSB7XG4gIGlmICghaXNEcmFmdCh2YWx1ZSkpXG4gICAgZGllKDEwLCB2YWx1ZSk7XG4gIHJldHVybiBjdXJyZW50SW1wbCh2YWx1ZSk7XG59XG5mdW5jdGlvbiBjdXJyZW50SW1wbCh2YWx1ZSkge1xuICBpZiAoIWlzRHJhZnRhYmxlKHZhbHVlKSB8fCBpc0Zyb3plbih2YWx1ZSkpXG4gICAgcmV0dXJuIHZhbHVlO1xuICBjb25zdCBzdGF0ZSA9IHZhbHVlW0RSQUZUX1NUQVRFXTtcbiAgbGV0IGNvcHk7XG4gIGlmIChzdGF0ZSkge1xuICAgIGlmICghc3RhdGUubW9kaWZpZWRfKVxuICAgICAgcmV0dXJuIHN0YXRlLmJhc2VfO1xuICAgIHN0YXRlLmZpbmFsaXplZF8gPSB0cnVlO1xuICAgIGNvcHkgPSBzaGFsbG93Q29weSh2YWx1ZSwgc3RhdGUuc2NvcGVfLmltbWVyXy51c2VTdHJpY3RTaGFsbG93Q29weV8pO1xuICB9IGVsc2Uge1xuICAgIGNvcHkgPSBzaGFsbG93Q29weSh2YWx1ZSwgdHJ1ZSk7XG4gIH1cbiAgZWFjaChjb3B5LCAoa2V5LCBjaGlsZFZhbHVlKSA9PiB7XG4gICAgc2V0KGNvcHksIGtleSwgY3VycmVudEltcGwoY2hpbGRWYWx1ZSkpO1xuICB9KTtcbiAgaWYgKHN0YXRlKSB7XG4gICAgc3RhdGUuZmluYWxpemVkXyA9IGZhbHNlO1xuICB9XG4gIHJldHVybiBjb3B5O1xufVxuXG4vLyBzcmMvcGx1Z2lucy9wYXRjaGVzLnRzXG5mdW5jdGlvbiBlbmFibGVQYXRjaGVzKCkge1xuICBjb25zdCBlcnJvck9mZnNldCA9IDE2O1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgZXJyb3JzLnB1c2goXG4gICAgICAnU2V0cyBjYW5ub3QgaGF2ZSBcInJlcGxhY2VcIiBwYXRjaGVzLicsXG4gICAgICBmdW5jdGlvbihvcCkge1xuICAgICAgICByZXR1cm4gXCJVbnN1cHBvcnRlZCBwYXRjaCBvcGVyYXRpb246IFwiICsgb3A7XG4gICAgICB9LFxuICAgICAgZnVuY3Rpb24ocGF0aCkge1xuICAgICAgICByZXR1cm4gXCJDYW5ub3QgYXBwbHkgcGF0Y2gsIHBhdGggZG9lc24ndCByZXNvbHZlOiBcIiArIHBhdGg7XG4gICAgICB9LFxuICAgICAgXCJQYXRjaGluZyByZXNlcnZlZCBhdHRyaWJ1dGVzIGxpa2UgX19wcm90b19fLCBwcm90b3R5cGUgYW5kIGNvbnN0cnVjdG9yIGlzIG5vdCBhbGxvd2VkXCJcbiAgICApO1xuICB9XG4gIGNvbnN0IFJFUExBQ0UgPSBcInJlcGxhY2VcIjtcbiAgY29uc3QgQUREID0gXCJhZGRcIjtcbiAgY29uc3QgUkVNT1ZFID0gXCJyZW1vdmVcIjtcbiAgZnVuY3Rpb24gZ2VuZXJhdGVQYXRjaGVzXyhzdGF0ZSwgYmFzZVBhdGgsIHBhdGNoZXMsIGludmVyc2VQYXRjaGVzKSB7XG4gICAgc3dpdGNoIChzdGF0ZS50eXBlXykge1xuICAgICAgY2FzZSAwIC8qIE9iamVjdCAqLzpcbiAgICAgIGNhc2UgMiAvKiBNYXAgKi86XG4gICAgICAgIHJldHVybiBnZW5lcmF0ZVBhdGNoZXNGcm9tQXNzaWduZWQoXG4gICAgICAgICAgc3RhdGUsXG4gICAgICAgICAgYmFzZVBhdGgsXG4gICAgICAgICAgcGF0Y2hlcyxcbiAgICAgICAgICBpbnZlcnNlUGF0Y2hlc1xuICAgICAgICApO1xuICAgICAgY2FzZSAxIC8qIEFycmF5ICovOlxuICAgICAgICByZXR1cm4gZ2VuZXJhdGVBcnJheVBhdGNoZXMoc3RhdGUsIGJhc2VQYXRoLCBwYXRjaGVzLCBpbnZlcnNlUGF0Y2hlcyk7XG4gICAgICBjYXNlIDMgLyogU2V0ICovOlxuICAgICAgICByZXR1cm4gZ2VuZXJhdGVTZXRQYXRjaGVzKFxuICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgIGJhc2VQYXRoLFxuICAgICAgICAgIHBhdGNoZXMsXG4gICAgICAgICAgaW52ZXJzZVBhdGNoZXNcbiAgICAgICAgKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZ2VuZXJhdGVBcnJheVBhdGNoZXMoc3RhdGUsIGJhc2VQYXRoLCBwYXRjaGVzLCBpbnZlcnNlUGF0Y2hlcykge1xuICAgIGxldCB7IGJhc2VfLCBhc3NpZ25lZF8gfSA9IHN0YXRlO1xuICAgIGxldCBjb3B5XyA9IHN0YXRlLmNvcHlfO1xuICAgIGlmIChjb3B5Xy5sZW5ndGggPCBiYXNlXy5sZW5ndGgpIHtcbiAgICAgIDtcbiAgICAgIFtiYXNlXywgY29weV9dID0gW2NvcHlfLCBiYXNlX107XG4gICAgICBbcGF0Y2hlcywgaW52ZXJzZVBhdGNoZXNdID0gW2ludmVyc2VQYXRjaGVzLCBwYXRjaGVzXTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBiYXNlXy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGFzc2lnbmVkX1tpXSAmJiBjb3B5X1tpXSAhPT0gYmFzZV9baV0pIHtcbiAgICAgICAgY29uc3QgcGF0aCA9IGJhc2VQYXRoLmNvbmNhdChbaV0pO1xuICAgICAgICBwYXRjaGVzLnB1c2goe1xuICAgICAgICAgIG9wOiBSRVBMQUNFLFxuICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgLy8gTmVlZCB0byBtYXliZSBjbG9uZSBpdCwgYXMgaXQgY2FuIGluIGZhY3QgYmUgdGhlIG9yaWdpbmFsIHZhbHVlXG4gICAgICAgICAgLy8gZHVlIHRvIHRoZSBiYXNlL2NvcHkgaW52ZXJzaW9uIGF0IHRoZSBzdGFydCBvZiB0aGlzIGZ1bmN0aW9uXG4gICAgICAgICAgdmFsdWU6IGNsb25lUGF0Y2hWYWx1ZUlmTmVlZGVkKGNvcHlfW2ldKVxuICAgICAgICB9KTtcbiAgICAgICAgaW52ZXJzZVBhdGNoZXMucHVzaCh7XG4gICAgICAgICAgb3A6IFJFUExBQ0UsXG4gICAgICAgICAgcGF0aCxcbiAgICAgICAgICB2YWx1ZTogY2xvbmVQYXRjaFZhbHVlSWZOZWVkZWQoYmFzZV9baV0pXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGxldCBpID0gYmFzZV8ubGVuZ3RoOyBpIDwgY29weV8ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHBhdGggPSBiYXNlUGF0aC5jb25jYXQoW2ldKTtcbiAgICAgIHBhdGNoZXMucHVzaCh7XG4gICAgICAgIG9wOiBBREQsXG4gICAgICAgIHBhdGgsXG4gICAgICAgIC8vIE5lZWQgdG8gbWF5YmUgY2xvbmUgaXQsIGFzIGl0IGNhbiBpbiBmYWN0IGJlIHRoZSBvcmlnaW5hbCB2YWx1ZVxuICAgICAgICAvLyBkdWUgdG8gdGhlIGJhc2UvY29weSBpbnZlcnNpb24gYXQgdGhlIHN0YXJ0IG9mIHRoaXMgZnVuY3Rpb25cbiAgICAgICAgdmFsdWU6IGNsb25lUGF0Y2hWYWx1ZUlmTmVlZGVkKGNvcHlfW2ldKVxuICAgICAgfSk7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSBjb3B5Xy5sZW5ndGggLSAxOyBiYXNlXy5sZW5ndGggPD0gaTsgLS1pKSB7XG4gICAgICBjb25zdCBwYXRoID0gYmFzZVBhdGguY29uY2F0KFtpXSk7XG4gICAgICBpbnZlcnNlUGF0Y2hlcy5wdXNoKHtcbiAgICAgICAgb3A6IFJFTU9WRSxcbiAgICAgICAgcGF0aFxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGdlbmVyYXRlUGF0Y2hlc0Zyb21Bc3NpZ25lZChzdGF0ZSwgYmFzZVBhdGgsIHBhdGNoZXMsIGludmVyc2VQYXRjaGVzKSB7XG4gICAgY29uc3QgeyBiYXNlXywgY29weV8gfSA9IHN0YXRlO1xuICAgIGVhY2goc3RhdGUuYXNzaWduZWRfLCAoa2V5LCBhc3NpZ25lZFZhbHVlKSA9PiB7XG4gICAgICBjb25zdCBvcmlnVmFsdWUgPSBnZXQoYmFzZV8sIGtleSk7XG4gICAgICBjb25zdCB2YWx1ZSA9IGdldChjb3B5Xywga2V5KTtcbiAgICAgIGNvbnN0IG9wID0gIWFzc2lnbmVkVmFsdWUgPyBSRU1PVkUgOiBoYXMoYmFzZV8sIGtleSkgPyBSRVBMQUNFIDogQUREO1xuICAgICAgaWYgKG9yaWdWYWx1ZSA9PT0gdmFsdWUgJiYgb3AgPT09IFJFUExBQ0UpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGNvbnN0IHBhdGggPSBiYXNlUGF0aC5jb25jYXQoa2V5KTtcbiAgICAgIHBhdGNoZXMucHVzaChvcCA9PT0gUkVNT1ZFID8geyBvcCwgcGF0aCB9IDogeyBvcCwgcGF0aCwgdmFsdWUgfSk7XG4gICAgICBpbnZlcnNlUGF0Y2hlcy5wdXNoKFxuICAgICAgICBvcCA9PT0gQUREID8geyBvcDogUkVNT1ZFLCBwYXRoIH0gOiBvcCA9PT0gUkVNT1ZFID8geyBvcDogQURELCBwYXRoLCB2YWx1ZTogY2xvbmVQYXRjaFZhbHVlSWZOZWVkZWQob3JpZ1ZhbHVlKSB9IDogeyBvcDogUkVQTEFDRSwgcGF0aCwgdmFsdWU6IGNsb25lUGF0Y2hWYWx1ZUlmTmVlZGVkKG9yaWdWYWx1ZSkgfVxuICAgICAgKTtcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBnZW5lcmF0ZVNldFBhdGNoZXMoc3RhdGUsIGJhc2VQYXRoLCBwYXRjaGVzLCBpbnZlcnNlUGF0Y2hlcykge1xuICAgIGxldCB7IGJhc2VfLCBjb3B5XyB9ID0gc3RhdGU7XG4gICAgbGV0IGkgPSAwO1xuICAgIGJhc2VfLmZvckVhY2goKHZhbHVlKSA9PiB7XG4gICAgICBpZiAoIWNvcHlfLmhhcyh2YWx1ZSkpIHtcbiAgICAgICAgY29uc3QgcGF0aCA9IGJhc2VQYXRoLmNvbmNhdChbaV0pO1xuICAgICAgICBwYXRjaGVzLnB1c2goe1xuICAgICAgICAgIG9wOiBSRU1PVkUsXG4gICAgICAgICAgcGF0aCxcbiAgICAgICAgICB2YWx1ZVxuICAgICAgICB9KTtcbiAgICAgICAgaW52ZXJzZVBhdGNoZXMudW5zaGlmdCh7XG4gICAgICAgICAgb3A6IEFERCxcbiAgICAgICAgICBwYXRoLFxuICAgICAgICAgIHZhbHVlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaSsrO1xuICAgIH0pO1xuICAgIGkgPSAwO1xuICAgIGNvcHlfLmZvckVhY2goKHZhbHVlKSA9PiB7XG4gICAgICBpZiAoIWJhc2VfLmhhcyh2YWx1ZSkpIHtcbiAgICAgICAgY29uc3QgcGF0aCA9IGJhc2VQYXRoLmNvbmNhdChbaV0pO1xuICAgICAgICBwYXRjaGVzLnB1c2goe1xuICAgICAgICAgIG9wOiBBREQsXG4gICAgICAgICAgcGF0aCxcbiAgICAgICAgICB2YWx1ZVxuICAgICAgICB9KTtcbiAgICAgICAgaW52ZXJzZVBhdGNoZXMudW5zaGlmdCh7XG4gICAgICAgICAgb3A6IFJFTU9WRSxcbiAgICAgICAgICBwYXRoLFxuICAgICAgICAgIHZhbHVlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaSsrO1xuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIGdlbmVyYXRlUmVwbGFjZW1lbnRQYXRjaGVzXyhiYXNlVmFsdWUsIHJlcGxhY2VtZW50LCBwYXRjaGVzLCBpbnZlcnNlUGF0Y2hlcykge1xuICAgIHBhdGNoZXMucHVzaCh7XG4gICAgICBvcDogUkVQTEFDRSxcbiAgICAgIHBhdGg6IFtdLFxuICAgICAgdmFsdWU6IHJlcGxhY2VtZW50ID09PSBOT1RISU5HID8gdm9pZCAwIDogcmVwbGFjZW1lbnRcbiAgICB9KTtcbiAgICBpbnZlcnNlUGF0Y2hlcy5wdXNoKHtcbiAgICAgIG9wOiBSRVBMQUNFLFxuICAgICAgcGF0aDogW10sXG4gICAgICB2YWx1ZTogYmFzZVZhbHVlXG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gYXBwbHlQYXRjaGVzXyhkcmFmdCwgcGF0Y2hlcykge1xuICAgIHBhdGNoZXMuZm9yRWFjaCgocGF0Y2gpID0+IHtcbiAgICAgIGNvbnN0IHsgcGF0aCwgb3AgfSA9IHBhdGNoO1xuICAgICAgbGV0IGJhc2UgPSBkcmFmdDtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGF0aC5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgY29uc3QgcGFyZW50VHlwZSA9IGdldEFyY2h0eXBlKGJhc2UpO1xuICAgICAgICBsZXQgcCA9IHBhdGhbaV07XG4gICAgICAgIGlmICh0eXBlb2YgcCAhPT0gXCJzdHJpbmdcIiAmJiB0eXBlb2YgcCAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgIHAgPSBcIlwiICsgcDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKHBhcmVudFR5cGUgPT09IDAgLyogT2JqZWN0ICovIHx8IHBhcmVudFR5cGUgPT09IDEgLyogQXJyYXkgKi8pICYmIChwID09PSBcIl9fcHJvdG9fX1wiIHx8IHAgPT09IFwiY29uc3RydWN0b3JcIikpXG4gICAgICAgICAgZGllKGVycm9yT2Zmc2V0ICsgMyk7XG4gICAgICAgIGlmICh0eXBlb2YgYmFzZSA9PT0gXCJmdW5jdGlvblwiICYmIHAgPT09IFwicHJvdG90eXBlXCIpXG4gICAgICAgICAgZGllKGVycm9yT2Zmc2V0ICsgMyk7XG4gICAgICAgIGJhc2UgPSBnZXQoYmFzZSwgcCk7XG4gICAgICAgIGlmICh0eXBlb2YgYmFzZSAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgICBkaWUoZXJyb3JPZmZzZXQgKyAyLCBwYXRoLmpvaW4oXCIvXCIpKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHR5cGUgPSBnZXRBcmNodHlwZShiYXNlKTtcbiAgICAgIGNvbnN0IHZhbHVlID0gZGVlcENsb25lUGF0Y2hWYWx1ZShwYXRjaC52YWx1ZSk7XG4gICAgICBjb25zdCBrZXkgPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV07XG4gICAgICBzd2l0Y2ggKG9wKSB7XG4gICAgICAgIGNhc2UgUkVQTEFDRTpcbiAgICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgMiAvKiBNYXAgKi86XG4gICAgICAgICAgICAgIHJldHVybiBiYXNlLnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIGNhc2UgMyAvKiBTZXQgKi86XG4gICAgICAgICAgICAgIGRpZShlcnJvck9mZnNldCk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICByZXR1cm4gYmFzZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlIEFERDpcbiAgICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgMSAvKiBBcnJheSAqLzpcbiAgICAgICAgICAgICAgcmV0dXJuIGtleSA9PT0gXCItXCIgPyBiYXNlLnB1c2godmFsdWUpIDogYmFzZS5zcGxpY2Uoa2V5LCAwLCB2YWx1ZSk7XG4gICAgICAgICAgICBjYXNlIDIgLyogTWFwICovOlxuICAgICAgICAgICAgICByZXR1cm4gYmFzZS5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICBjYXNlIDMgLyogU2V0ICovOlxuICAgICAgICAgICAgICByZXR1cm4gYmFzZS5hZGQodmFsdWUpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgcmV0dXJuIGJhc2Vba2V5XSA9IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBSRU1PVkU6XG4gICAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICBjYXNlIDEgLyogQXJyYXkgKi86XG4gICAgICAgICAgICAgIHJldHVybiBiYXNlLnNwbGljZShrZXksIDEpO1xuICAgICAgICAgICAgY2FzZSAyIC8qIE1hcCAqLzpcbiAgICAgICAgICAgICAgcmV0dXJuIGJhc2UuZGVsZXRlKGtleSk7XG4gICAgICAgICAgICBjYXNlIDMgLyogU2V0ICovOlxuICAgICAgICAgICAgICByZXR1cm4gYmFzZS5kZWxldGUocGF0Y2gudmFsdWUpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgcmV0dXJuIGRlbGV0ZSBiYXNlW2tleV07XG4gICAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGRpZShlcnJvck9mZnNldCArIDEsIG9wKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gZHJhZnQ7XG4gIH1cbiAgZnVuY3Rpb24gZGVlcENsb25lUGF0Y2hWYWx1ZShvYmopIHtcbiAgICBpZiAoIWlzRHJhZnRhYmxlKG9iaikpXG4gICAgICByZXR1cm4gb2JqO1xuICAgIGlmIChBcnJheS5pc0FycmF5KG9iaikpXG4gICAgICByZXR1cm4gb2JqLm1hcChkZWVwQ2xvbmVQYXRjaFZhbHVlKTtcbiAgICBpZiAoaXNNYXAob2JqKSlcbiAgICAgIHJldHVybiBuZXcgTWFwKFxuICAgICAgICBBcnJheS5mcm9tKG9iai5lbnRyaWVzKCkpLm1hcCgoW2ssIHZdKSA9PiBbaywgZGVlcENsb25lUGF0Y2hWYWx1ZSh2KV0pXG4gICAgICApO1xuICAgIGlmIChpc1NldChvYmopKVxuICAgICAgcmV0dXJuIG5ldyBTZXQoQXJyYXkuZnJvbShvYmopLm1hcChkZWVwQ2xvbmVQYXRjaFZhbHVlKSk7XG4gICAgY29uc3QgY2xvbmVkID0gT2JqZWN0LmNyZWF0ZShnZXRQcm90b3R5cGVPZihvYmopKTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBvYmopXG4gICAgICBjbG9uZWRba2V5XSA9IGRlZXBDbG9uZVBhdGNoVmFsdWUob2JqW2tleV0pO1xuICAgIGlmIChoYXMob2JqLCBEUkFGVEFCTEUpKVxuICAgICAgY2xvbmVkW0RSQUZUQUJMRV0gPSBvYmpbRFJBRlRBQkxFXTtcbiAgICByZXR1cm4gY2xvbmVkO1xuICB9XG4gIGZ1bmN0aW9uIGNsb25lUGF0Y2hWYWx1ZUlmTmVlZGVkKG9iaikge1xuICAgIGlmIChpc0RyYWZ0KG9iaikpIHtcbiAgICAgIHJldHVybiBkZWVwQ2xvbmVQYXRjaFZhbHVlKG9iaik7XG4gICAgfSBlbHNlXG4gICAgICByZXR1cm4gb2JqO1xuICB9XG4gIGxvYWRQbHVnaW4oXCJQYXRjaGVzXCIsIHtcbiAgICBhcHBseVBhdGNoZXNfLFxuICAgIGdlbmVyYXRlUGF0Y2hlc18sXG4gICAgZ2VuZXJhdGVSZXBsYWNlbWVudFBhdGNoZXNfXG4gIH0pO1xufVxuXG4vLyBzcmMvcGx1Z2lucy9tYXBzZXQudHNcbmZ1bmN0aW9uIGVuYWJsZU1hcFNldCgpIHtcbiAgY2xhc3MgRHJhZnRNYXAgZXh0ZW5kcyBNYXAge1xuICAgIGNvbnN0cnVjdG9yKHRhcmdldCwgcGFyZW50KSB7XG4gICAgICBzdXBlcigpO1xuICAgICAgdGhpc1tEUkFGVF9TVEFURV0gPSB7XG4gICAgICAgIHR5cGVfOiAyIC8qIE1hcCAqLyxcbiAgICAgICAgcGFyZW50XzogcGFyZW50LFxuICAgICAgICBzY29wZV86IHBhcmVudCA/IHBhcmVudC5zY29wZV8gOiBnZXRDdXJyZW50U2NvcGUoKSxcbiAgICAgICAgbW9kaWZpZWRfOiBmYWxzZSxcbiAgICAgICAgZmluYWxpemVkXzogZmFsc2UsXG4gICAgICAgIGNvcHlfOiB2b2lkIDAsXG4gICAgICAgIGFzc2lnbmVkXzogdm9pZCAwLFxuICAgICAgICBiYXNlXzogdGFyZ2V0LFxuICAgICAgICBkcmFmdF86IHRoaXMsXG4gICAgICAgIGlzTWFudWFsXzogZmFsc2UsXG4gICAgICAgIHJldm9rZWRfOiBmYWxzZVxuICAgICAgfTtcbiAgICB9XG4gICAgZ2V0IHNpemUoKSB7XG4gICAgICByZXR1cm4gbGF0ZXN0KHRoaXNbRFJBRlRfU1RBVEVdKS5zaXplO1xuICAgIH1cbiAgICBoYXMoa2V5KSB7XG4gICAgICByZXR1cm4gbGF0ZXN0KHRoaXNbRFJBRlRfU1RBVEVdKS5oYXMoa2V5KTtcbiAgICB9XG4gICAgc2V0KGtleSwgdmFsdWUpIHtcbiAgICAgIGNvbnN0IHN0YXRlID0gdGhpc1tEUkFGVF9TVEFURV07XG4gICAgICBhc3NlcnRVbnJldm9rZWQoc3RhdGUpO1xuICAgICAgaWYgKCFsYXRlc3Qoc3RhdGUpLmhhcyhrZXkpIHx8IGxhdGVzdChzdGF0ZSkuZ2V0KGtleSkgIT09IHZhbHVlKSB7XG4gICAgICAgIHByZXBhcmVNYXBDb3B5KHN0YXRlKTtcbiAgICAgICAgbWFya0NoYW5nZWQoc3RhdGUpO1xuICAgICAgICBzdGF0ZS5hc3NpZ25lZF8uc2V0KGtleSwgdHJ1ZSk7XG4gICAgICAgIHN0YXRlLmNvcHlfLnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgc3RhdGUuYXNzaWduZWRfLnNldChrZXksIHRydWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGRlbGV0ZShrZXkpIHtcbiAgICAgIGlmICghdGhpcy5oYXMoa2V5KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBjb25zdCBzdGF0ZSA9IHRoaXNbRFJBRlRfU1RBVEVdO1xuICAgICAgYXNzZXJ0VW5yZXZva2VkKHN0YXRlKTtcbiAgICAgIHByZXBhcmVNYXBDb3B5KHN0YXRlKTtcbiAgICAgIG1hcmtDaGFuZ2VkKHN0YXRlKTtcbiAgICAgIGlmIChzdGF0ZS5iYXNlXy5oYXMoa2V5KSkge1xuICAgICAgICBzdGF0ZS5hc3NpZ25lZF8uc2V0KGtleSwgZmFsc2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUuYXNzaWduZWRfLmRlbGV0ZShrZXkpO1xuICAgICAgfVxuICAgICAgc3RhdGUuY29weV8uZGVsZXRlKGtleSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY2xlYXIoKSB7XG4gICAgICBjb25zdCBzdGF0ZSA9IHRoaXNbRFJBRlRfU1RBVEVdO1xuICAgICAgYXNzZXJ0VW5yZXZva2VkKHN0YXRlKTtcbiAgICAgIGlmIChsYXRlc3Qoc3RhdGUpLnNpemUpIHtcbiAgICAgICAgcHJlcGFyZU1hcENvcHkoc3RhdGUpO1xuICAgICAgICBtYXJrQ2hhbmdlZChzdGF0ZSk7XG4gICAgICAgIHN0YXRlLmFzc2lnbmVkXyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICAgIGVhY2goc3RhdGUuYmFzZV8sIChrZXkpID0+IHtcbiAgICAgICAgICBzdGF0ZS5hc3NpZ25lZF8uc2V0KGtleSwgZmFsc2UpO1xuICAgICAgICB9KTtcbiAgICAgICAgc3RhdGUuY29weV8uY2xlYXIoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yRWFjaChjYiwgdGhpc0FyZykge1xuICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzW0RSQUZUX1NUQVRFXTtcbiAgICAgIGxhdGVzdChzdGF0ZSkuZm9yRWFjaCgoX3ZhbHVlLCBrZXksIF9tYXApID0+IHtcbiAgICAgICAgY2IuY2FsbCh0aGlzQXJnLCB0aGlzLmdldChrZXkpLCBrZXksIHRoaXMpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGdldChrZXkpIHtcbiAgICAgIGNvbnN0IHN0YXRlID0gdGhpc1tEUkFGVF9TVEFURV07XG4gICAgICBhc3NlcnRVbnJldm9rZWQoc3RhdGUpO1xuICAgICAgY29uc3QgdmFsdWUgPSBsYXRlc3Qoc3RhdGUpLmdldChrZXkpO1xuICAgICAgaWYgKHN0YXRlLmZpbmFsaXplZF8gfHwgIWlzRHJhZnRhYmxlKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgICBpZiAodmFsdWUgIT09IHN0YXRlLmJhc2VfLmdldChrZXkpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGRyYWZ0ID0gY3JlYXRlUHJveHkodmFsdWUsIHN0YXRlKTtcbiAgICAgIHByZXBhcmVNYXBDb3B5KHN0YXRlKTtcbiAgICAgIHN0YXRlLmNvcHlfLnNldChrZXksIGRyYWZ0KTtcbiAgICAgIHJldHVybiBkcmFmdDtcbiAgICB9XG4gICAga2V5cygpIHtcbiAgICAgIHJldHVybiBsYXRlc3QodGhpc1tEUkFGVF9TVEFURV0pLmtleXMoKTtcbiAgICB9XG4gICAgdmFsdWVzKCkge1xuICAgICAgY29uc3QgaXRlcmF0b3IgPSB0aGlzLmtleXMoKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIFtTeW1ib2wuaXRlcmF0b3JdOiAoKSA9PiB0aGlzLnZhbHVlcygpLFxuICAgICAgICBuZXh0OiAoKSA9PiB7XG4gICAgICAgICAgY29uc3QgciA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgICBpZiAoci5kb25lKVxuICAgICAgICAgICAgcmV0dXJuIHI7XG4gICAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLmdldChyLnZhbHVlKTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZG9uZTogZmFsc2UsXG4gICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICAgIGVudHJpZXMoKSB7XG4gICAgICBjb25zdCBpdGVyYXRvciA9IHRoaXMua2V5cygpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgW1N5bWJvbC5pdGVyYXRvcl06ICgpID0+IHRoaXMuZW50cmllcygpLFxuICAgICAgICBuZXh0OiAoKSA9PiB7XG4gICAgICAgICAgY29uc3QgciA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgICBpZiAoci5kb25lKVxuICAgICAgICAgICAgcmV0dXJuIHI7XG4gICAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLmdldChyLnZhbHVlKTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZG9uZTogZmFsc2UsXG4gICAgICAgICAgICB2YWx1ZTogW3IudmFsdWUsIHZhbHVlXVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICAgIFsoRFJBRlRfU1RBVEUsIFN5bWJvbC5pdGVyYXRvcildKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZW50cmllcygpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBwcm94eU1hcF8odGFyZ2V0LCBwYXJlbnQpIHtcbiAgICByZXR1cm4gbmV3IERyYWZ0TWFwKHRhcmdldCwgcGFyZW50KTtcbiAgfVxuICBmdW5jdGlvbiBwcmVwYXJlTWFwQ29weShzdGF0ZSkge1xuICAgIGlmICghc3RhdGUuY29weV8pIHtcbiAgICAgIHN0YXRlLmFzc2lnbmVkXyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICBzdGF0ZS5jb3B5XyA9IG5ldyBNYXAoc3RhdGUuYmFzZV8pO1xuICAgIH1cbiAgfVxuICBjbGFzcyBEcmFmdFNldCBleHRlbmRzIFNldCB7XG4gICAgY29uc3RydWN0b3IodGFyZ2V0LCBwYXJlbnQpIHtcbiAgICAgIHN1cGVyKCk7XG4gICAgICB0aGlzW0RSQUZUX1NUQVRFXSA9IHtcbiAgICAgICAgdHlwZV86IDMgLyogU2V0ICovLFxuICAgICAgICBwYXJlbnRfOiBwYXJlbnQsXG4gICAgICAgIHNjb3BlXzogcGFyZW50ID8gcGFyZW50LnNjb3BlXyA6IGdldEN1cnJlbnRTY29wZSgpLFxuICAgICAgICBtb2RpZmllZF86IGZhbHNlLFxuICAgICAgICBmaW5hbGl6ZWRfOiBmYWxzZSxcbiAgICAgICAgY29weV86IHZvaWQgMCxcbiAgICAgICAgYmFzZV86IHRhcmdldCxcbiAgICAgICAgZHJhZnRfOiB0aGlzLFxuICAgICAgICBkcmFmdHNfOiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLFxuICAgICAgICByZXZva2VkXzogZmFsc2UsXG4gICAgICAgIGlzTWFudWFsXzogZmFsc2VcbiAgICAgIH07XG4gICAgfVxuICAgIGdldCBzaXplKCkge1xuICAgICAgcmV0dXJuIGxhdGVzdCh0aGlzW0RSQUZUX1NUQVRFXSkuc2l6ZTtcbiAgICB9XG4gICAgaGFzKHZhbHVlKSB7XG4gICAgICBjb25zdCBzdGF0ZSA9IHRoaXNbRFJBRlRfU1RBVEVdO1xuICAgICAgYXNzZXJ0VW5yZXZva2VkKHN0YXRlKTtcbiAgICAgIGlmICghc3RhdGUuY29weV8pIHtcbiAgICAgICAgcmV0dXJuIHN0YXRlLmJhc2VfLmhhcyh2YWx1ZSk7XG4gICAgICB9XG4gICAgICBpZiAoc3RhdGUuY29weV8uaGFzKHZhbHVlKSlcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICBpZiAoc3RhdGUuZHJhZnRzXy5oYXModmFsdWUpICYmIHN0YXRlLmNvcHlfLmhhcyhzdGF0ZS5kcmFmdHNfLmdldCh2YWx1ZSkpKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgYWRkKHZhbHVlKSB7XG4gICAgICBjb25zdCBzdGF0ZSA9IHRoaXNbRFJBRlRfU1RBVEVdO1xuICAgICAgYXNzZXJ0VW5yZXZva2VkKHN0YXRlKTtcbiAgICAgIGlmICghdGhpcy5oYXModmFsdWUpKSB7XG4gICAgICAgIHByZXBhcmVTZXRDb3B5KHN0YXRlKTtcbiAgICAgICAgbWFya0NoYW5nZWQoc3RhdGUpO1xuICAgICAgICBzdGF0ZS5jb3B5Xy5hZGQodmFsdWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGRlbGV0ZSh2YWx1ZSkge1xuICAgICAgaWYgKCF0aGlzLmhhcyh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzW0RSQUZUX1NUQVRFXTtcbiAgICAgIGFzc2VydFVucmV2b2tlZChzdGF0ZSk7XG4gICAgICBwcmVwYXJlU2V0Q29weShzdGF0ZSk7XG4gICAgICBtYXJrQ2hhbmdlZChzdGF0ZSk7XG4gICAgICByZXR1cm4gc3RhdGUuY29weV8uZGVsZXRlKHZhbHVlKSB8fCAoc3RhdGUuZHJhZnRzXy5oYXModmFsdWUpID8gc3RhdGUuY29weV8uZGVsZXRlKHN0YXRlLmRyYWZ0c18uZ2V0KHZhbHVlKSkgOiAoXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIGZhbHNlXG4gICAgICApKTtcbiAgICB9XG4gICAgY2xlYXIoKSB7XG4gICAgICBjb25zdCBzdGF0ZSA9IHRoaXNbRFJBRlRfU1RBVEVdO1xuICAgICAgYXNzZXJ0VW5yZXZva2VkKHN0YXRlKTtcbiAgICAgIGlmIChsYXRlc3Qoc3RhdGUpLnNpemUpIHtcbiAgICAgICAgcHJlcGFyZVNldENvcHkoc3RhdGUpO1xuICAgICAgICBtYXJrQ2hhbmdlZChzdGF0ZSk7XG4gICAgICAgIHN0YXRlLmNvcHlfLmNsZWFyKCk7XG4gICAgICB9XG4gICAgfVxuICAgIHZhbHVlcygpIHtcbiAgICAgIGNvbnN0IHN0YXRlID0gdGhpc1tEUkFGVF9TVEFURV07XG4gICAgICBhc3NlcnRVbnJldm9rZWQoc3RhdGUpO1xuICAgICAgcHJlcGFyZVNldENvcHkoc3RhdGUpO1xuICAgICAgcmV0dXJuIHN0YXRlLmNvcHlfLnZhbHVlcygpO1xuICAgIH1cbiAgICBlbnRyaWVzKCkge1xuICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzW0RSQUZUX1NUQVRFXTtcbiAgICAgIGFzc2VydFVucmV2b2tlZChzdGF0ZSk7XG4gICAgICBwcmVwYXJlU2V0Q29weShzdGF0ZSk7XG4gICAgICByZXR1cm4gc3RhdGUuY29weV8uZW50cmllcygpO1xuICAgIH1cbiAgICBrZXlzKCkge1xuICAgICAgcmV0dXJuIHRoaXMudmFsdWVzKCk7XG4gICAgfVxuICAgIFsoRFJBRlRfU1RBVEUsIFN5bWJvbC5pdGVyYXRvcildKCkge1xuICAgICAgcmV0dXJuIHRoaXMudmFsdWVzKCk7XG4gICAgfVxuICAgIGZvckVhY2goY2IsIHRoaXNBcmcpIHtcbiAgICAgIGNvbnN0IGl0ZXJhdG9yID0gdGhpcy52YWx1ZXMoKTtcbiAgICAgIGxldCByZXN1bHQgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICB3aGlsZSAoIXJlc3VsdC5kb25lKSB7XG4gICAgICAgIGNiLmNhbGwodGhpc0FyZywgcmVzdWx0LnZhbHVlLCByZXN1bHQudmFsdWUsIHRoaXMpO1xuICAgICAgICByZXN1bHQgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHByb3h5U2V0Xyh0YXJnZXQsIHBhcmVudCkge1xuICAgIHJldHVybiBuZXcgRHJhZnRTZXQodGFyZ2V0LCBwYXJlbnQpO1xuICB9XG4gIGZ1bmN0aW9uIHByZXBhcmVTZXRDb3B5KHN0YXRlKSB7XG4gICAgaWYgKCFzdGF0ZS5jb3B5Xykge1xuICAgICAgc3RhdGUuY29weV8gPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgICAgc3RhdGUuYmFzZV8uZm9yRWFjaCgodmFsdWUpID0+IHtcbiAgICAgICAgaWYgKGlzRHJhZnRhYmxlKHZhbHVlKSkge1xuICAgICAgICAgIGNvbnN0IGRyYWZ0ID0gY3JlYXRlUHJveHkodmFsdWUsIHN0YXRlKTtcbiAgICAgICAgICBzdGF0ZS5kcmFmdHNfLnNldCh2YWx1ZSwgZHJhZnQpO1xuICAgICAgICAgIHN0YXRlLmNvcHlfLmFkZChkcmFmdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RhdGUuY29weV8uYWRkKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGFzc2VydFVucmV2b2tlZChzdGF0ZSkge1xuICAgIGlmIChzdGF0ZS5yZXZva2VkXylcbiAgICAgIGRpZSgzLCBKU09OLnN0cmluZ2lmeShsYXRlc3Qoc3RhdGUpKSk7XG4gIH1cbiAgbG9hZFBsdWdpbihcIk1hcFNldFwiLCB7IHByb3h5TWFwXywgcHJveHlTZXRfIH0pO1xufVxuXG4vLyBzcmMvaW1tZXIudHNcbnZhciBpbW1lciA9IG5ldyBJbW1lcjIoKTtcbnZhciBwcm9kdWNlID0gaW1tZXIucHJvZHVjZTtcbnZhciBwcm9kdWNlV2l0aFBhdGNoZXMgPSBpbW1lci5wcm9kdWNlV2l0aFBhdGNoZXMuYmluZChcbiAgaW1tZXJcbik7XG52YXIgc2V0QXV0b0ZyZWV6ZSA9IGltbWVyLnNldEF1dG9GcmVlemUuYmluZChpbW1lcik7XG52YXIgc2V0VXNlU3RyaWN0U2hhbGxvd0NvcHkgPSBpbW1lci5zZXRVc2VTdHJpY3RTaGFsbG93Q29weS5iaW5kKGltbWVyKTtcbnZhciBhcHBseVBhdGNoZXMgPSBpbW1lci5hcHBseVBhdGNoZXMuYmluZChpbW1lcik7XG52YXIgY3JlYXRlRHJhZnQgPSBpbW1lci5jcmVhdGVEcmFmdC5iaW5kKGltbWVyKTtcbnZhciBmaW5pc2hEcmFmdCA9IGltbWVyLmZpbmlzaERyYWZ0LmJpbmQoaW1tZXIpO1xuZnVuY3Rpb24gY2FzdERyYWZ0KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGNhc3RJbW11dGFibGUodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlO1xufVxuZXhwb3J0IHtcbiAgSW1tZXIyIGFzIEltbWVyLFxuICBhcHBseVBhdGNoZXMsXG4gIGNhc3REcmFmdCxcbiAgY2FzdEltbXV0YWJsZSxcbiAgY3JlYXRlRHJhZnQsXG4gIGN1cnJlbnQsXG4gIGVuYWJsZU1hcFNldCxcbiAgZW5hYmxlUGF0Y2hlcyxcbiAgZmluaXNoRHJhZnQsXG4gIGZyZWV6ZSxcbiAgRFJBRlRBQkxFIGFzIGltbWVyYWJsZSxcbiAgaXNEcmFmdCxcbiAgaXNEcmFmdGFibGUsXG4gIE5PVEhJTkcgYXMgbm90aGluZyxcbiAgb3JpZ2luYWwsXG4gIHByb2R1Y2UsXG4gIHByb2R1Y2VXaXRoUGF0Y2hlcyxcbiAgc2V0QXV0b0ZyZWV6ZSxcbiAgc2V0VXNlU3RyaWN0U2hhbGxvd0NvcHlcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbW1lci5tanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/immer/dist/immer.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-redux/dist/react-redux.mjs":
/*!*******************************************************!*\
  !*** ./node_modules/react-redux/dist/react-redux.mjs ***!
  \*******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("var react__WEBPACK_IMPORTED_MODULE_0___namespace_cache;\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Provider: function() { return /* binding */ Provider_default; },\n/* harmony export */   ReactReduxContext: function() { return /* binding */ ReactReduxContext; },\n/* harmony export */   batch: function() { return /* binding */ batch; },\n/* harmony export */   connect: function() { return /* binding */ connect_default; },\n/* harmony export */   createDispatchHook: function() { return /* binding */ createDispatchHook; },\n/* harmony export */   createSelectorHook: function() { return /* binding */ createSelectorHook; },\n/* harmony export */   createStoreHook: function() { return /* binding */ createStoreHook; },\n/* harmony export */   shallowEqual: function() { return /* binding */ shallowEqual; },\n/* harmony export */   useDispatch: function() { return /* binding */ useDispatch; },\n/* harmony export */   useSelector: function() { return /* binding */ useSelector; },\n/* harmony export */   useStore: function() { return /* binding */ useStore; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var use_sync_external_store_with_selector_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! use-sync-external-store/with-selector.js */ \"(app-pages-browser)/./node_modules/use-sync-external-store/with-selector.js\");\n// src/index.ts\n\n\n\n// src/utils/react.ts\n\nvar React = (\n  // prettier-ignore\n  // @ts-ignore\n   true ? react__WEBPACK_IMPORTED_MODULE_0__ : /*#__PURE__*/ (react__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (react__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(react__WEBPACK_IMPORTED_MODULE_0__, 2)))\n);\n\n// src/components/Context.ts\nvar ContextKey = Symbol.for(`react-redux-context`);\nvar gT = typeof globalThis !== \"undefined\" ? globalThis : (\n  /* fall back to a per-module scope (pre-8.1 behaviour) if `globalThis` is not available */\n  {}\n);\nfunction getContext() {\n  if (!React.createContext)\n    return {};\n  const contextMap = gT[ContextKey] ?? (gT[ContextKey] = /* @__PURE__ */ new Map());\n  let realContext = contextMap.get(React.createContext);\n  if (!realContext) {\n    realContext = React.createContext(\n      null\n    );\n    if (true) {\n      realContext.displayName = \"ReactRedux\";\n    }\n    contextMap.set(React.createContext, realContext);\n  }\n  return realContext;\n}\nvar ReactReduxContext = /* @__PURE__ */ getContext();\n\n// src/utils/useSyncExternalStore.ts\nvar notInitialized = () => {\n  throw new Error(\"uSES not initialized!\");\n};\n\n// src/hooks/useReduxContext.ts\nfunction createReduxContextHook(context = ReactReduxContext) {\n  return function useReduxContext2() {\n    const contextValue = React.useContext(context);\n    if ( true && !contextValue) {\n      throw new Error(\n        \"could not find react-redux context value; please ensure the component is wrapped in a <Provider>\"\n      );\n    }\n    return contextValue;\n  };\n}\nvar useReduxContext = /* @__PURE__ */ createReduxContextHook();\n\n// src/hooks/useSelector.ts\nvar useSyncExternalStoreWithSelector = notInitialized;\nvar initializeUseSelector = (fn) => {\n  useSyncExternalStoreWithSelector = fn;\n};\nvar refEquality = (a, b) => a === b;\nfunction createSelectorHook(context = ReactReduxContext) {\n  const useReduxContext2 = context === ReactReduxContext ? useReduxContext : createReduxContextHook(context);\n  const useSelector2 = (selector, equalityFnOrOptions = {}) => {\n    const { equalityFn = refEquality, devModeChecks = {} } = typeof equalityFnOrOptions === \"function\" ? { equalityFn: equalityFnOrOptions } : equalityFnOrOptions;\n    if (true) {\n      if (!selector) {\n        throw new Error(`You must pass a selector to useSelector`);\n      }\n      if (typeof selector !== \"function\") {\n        throw new Error(`You must pass a function as a selector to useSelector`);\n      }\n      if (typeof equalityFn !== \"function\") {\n        throw new Error(\n          `You must pass a function as an equality function to useSelector`\n        );\n      }\n    }\n    const {\n      store,\n      subscription,\n      getServerState,\n      stabilityCheck,\n      identityFunctionCheck\n    } = useReduxContext2();\n    const firstRun = React.useRef(true);\n    const wrappedSelector = React.useCallback(\n      {\n        [selector.name](state) {\n          const selected = selector(state);\n          if (true) {\n            const {\n              identityFunctionCheck: finalIdentityFunctionCheck,\n              stabilityCheck: finalStabilityCheck\n            } = {\n              stabilityCheck,\n              identityFunctionCheck,\n              ...devModeChecks\n            };\n            if (finalStabilityCheck === \"always\" || finalStabilityCheck === \"once\" && firstRun.current) {\n              const toCompare = selector(state);\n              if (!equalityFn(selected, toCompare)) {\n                let stack = void 0;\n                try {\n                  throw new Error();\n                } catch (e) {\n                  ;\n                  ({ stack } = e);\n                }\n                console.warn(\n                  \"Selector \" + (selector.name || \"unknown\") + \" returned a different result when called with the same parameters. This can lead to unnecessary rerenders.\\nSelectors that return a new reference (such as an object or an array) should be memoized: https://redux.js.org/usage/deriving-data-selectors#optimizing-selectors-with-memoization\",\n                  {\n                    state,\n                    selected,\n                    selected2: toCompare,\n                    stack\n                  }\n                );\n              }\n            }\n            if (finalIdentityFunctionCheck === \"always\" || finalIdentityFunctionCheck === \"once\" && firstRun.current) {\n              if (selected === state) {\n                let stack = void 0;\n                try {\n                  throw new Error();\n                } catch (e) {\n                  ;\n                  ({ stack } = e);\n                }\n                console.warn(\n                  \"Selector \" + (selector.name || \"unknown\") + \" returned the root state when called. This can lead to unnecessary rerenders.\\nSelectors that return the entire state are almost certainly a mistake, as they will cause a rerender whenever *anything* in state changes.\",\n                  { stack }\n                );\n              }\n            }\n            if (firstRun.current)\n              firstRun.current = false;\n          }\n          return selected;\n        }\n      }[selector.name],\n      [selector, stabilityCheck, devModeChecks.stabilityCheck]\n    );\n    const selectedState = useSyncExternalStoreWithSelector(\n      subscription.addNestedSub,\n      store.getState,\n      getServerState || store.getState,\n      wrappedSelector,\n      equalityFn\n    );\n    React.useDebugValue(selectedState);\n    return selectedState;\n  };\n  Object.assign(useSelector2, {\n    withTypes: () => useSelector2\n  });\n  return useSelector2;\n}\nvar useSelector = /* @__PURE__ */ createSelectorHook();\n\n// src/utils/react-is.ts\nvar REACT_ELEMENT_TYPE = Symbol.for(\"react.element\");\nvar REACT_PORTAL_TYPE = Symbol.for(\"react.portal\");\nvar REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\");\nvar REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\");\nvar REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\");\nvar REACT_PROVIDER_TYPE = Symbol.for(\"react.provider\");\nvar REACT_CONTEXT_TYPE = Symbol.for(\"react.context\");\nvar REACT_SERVER_CONTEXT_TYPE = Symbol.for(\"react.server_context\");\nvar REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\");\nvar REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\");\nvar REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\");\nvar REACT_MEMO_TYPE = Symbol.for(\"react.memo\");\nvar REACT_LAZY_TYPE = Symbol.for(\"react.lazy\");\nvar REACT_OFFSCREEN_TYPE = Symbol.for(\"react.offscreen\");\nvar REACT_CLIENT_REFERENCE = Symbol.for(\"react.client.reference\");\nvar ForwardRef = REACT_FORWARD_REF_TYPE;\nvar Memo = REACT_MEMO_TYPE;\nfunction isValidElementType(type) {\n  if (typeof type === \"string\" || typeof type === \"function\") {\n    return true;\n  }\n  if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || type === REACT_OFFSCREEN_TYPE) {\n    return true;\n  }\n  if (typeof type === \"object\" && type !== null) {\n    if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object\n    // types supported by any Flight configuration anywhere since\n    // we don't know which Flight build this will end up being used\n    // with.\n    type.$$typeof === REACT_CLIENT_REFERENCE || type.getModuleId !== void 0) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction typeOf(object) {\n  if (typeof object === \"object\" && object !== null) {\n    const $$typeof = object.$$typeof;\n    switch ($$typeof) {\n      case REACT_ELEMENT_TYPE: {\n        const type = object.type;\n        switch (type) {\n          case REACT_FRAGMENT_TYPE:\n          case REACT_PROFILER_TYPE:\n          case REACT_STRICT_MODE_TYPE:\n          case REACT_SUSPENSE_TYPE:\n          case REACT_SUSPENSE_LIST_TYPE:\n            return type;\n          default: {\n            const $$typeofType = type && type.$$typeof;\n            switch ($$typeofType) {\n              case REACT_SERVER_CONTEXT_TYPE:\n              case REACT_CONTEXT_TYPE:\n              case REACT_FORWARD_REF_TYPE:\n              case REACT_LAZY_TYPE:\n              case REACT_MEMO_TYPE:\n              case REACT_PROVIDER_TYPE:\n                return $$typeofType;\n              default:\n                return $$typeof;\n            }\n          }\n        }\n      }\n      case REACT_PORTAL_TYPE: {\n        return $$typeof;\n      }\n    }\n  }\n  return void 0;\n}\nfunction isContextConsumer(object) {\n  return typeOf(object) === REACT_CONTEXT_TYPE;\n}\nfunction isMemo(object) {\n  return typeOf(object) === REACT_MEMO_TYPE;\n}\n\n// src/utils/warning.ts\nfunction warning(message) {\n  if (typeof console !== \"undefined\" && typeof console.error === \"function\") {\n    console.error(message);\n  }\n  try {\n    throw new Error(message);\n  } catch (e) {\n  }\n}\n\n// src/connect/verifySubselectors.ts\nfunction verify(selector, methodName) {\n  if (!selector) {\n    throw new Error(`Unexpected value for ${methodName} in connect.`);\n  } else if (methodName === \"mapStateToProps\" || methodName === \"mapDispatchToProps\") {\n    if (!Object.prototype.hasOwnProperty.call(selector, \"dependsOnOwnProps\")) {\n      warning(\n        `The selector for ${methodName} of connect did not specify a value for dependsOnOwnProps.`\n      );\n    }\n  }\n}\nfunction verifySubselectors(mapStateToProps, mapDispatchToProps, mergeProps) {\n  verify(mapStateToProps, \"mapStateToProps\");\n  verify(mapDispatchToProps, \"mapDispatchToProps\");\n  verify(mergeProps, \"mergeProps\");\n}\n\n// src/connect/selectorFactory.ts\nfunction pureFinalPropsSelectorFactory(mapStateToProps, mapDispatchToProps, mergeProps, dispatch, {\n  areStatesEqual,\n  areOwnPropsEqual,\n  areStatePropsEqual\n}) {\n  let hasRunAtLeastOnce = false;\n  let state;\n  let ownProps;\n  let stateProps;\n  let dispatchProps;\n  let mergedProps;\n  function handleFirstCall(firstState, firstOwnProps) {\n    state = firstState;\n    ownProps = firstOwnProps;\n    stateProps = mapStateToProps(state, ownProps);\n    dispatchProps = mapDispatchToProps(dispatch, ownProps);\n    mergedProps = mergeProps(stateProps, dispatchProps, ownProps);\n    hasRunAtLeastOnce = true;\n    return mergedProps;\n  }\n  function handleNewPropsAndNewState() {\n    stateProps = mapStateToProps(state, ownProps);\n    if (mapDispatchToProps.dependsOnOwnProps)\n      dispatchProps = mapDispatchToProps(dispatch, ownProps);\n    mergedProps = mergeProps(stateProps, dispatchProps, ownProps);\n    return mergedProps;\n  }\n  function handleNewProps() {\n    if (mapStateToProps.dependsOnOwnProps)\n      stateProps = mapStateToProps(state, ownProps);\n    if (mapDispatchToProps.dependsOnOwnProps)\n      dispatchProps = mapDispatchToProps(dispatch, ownProps);\n    mergedProps = mergeProps(stateProps, dispatchProps, ownProps);\n    return mergedProps;\n  }\n  function handleNewState() {\n    const nextStateProps = mapStateToProps(state, ownProps);\n    const statePropsChanged = !areStatePropsEqual(nextStateProps, stateProps);\n    stateProps = nextStateProps;\n    if (statePropsChanged)\n      mergedProps = mergeProps(stateProps, dispatchProps, ownProps);\n    return mergedProps;\n  }\n  function handleSubsequentCalls(nextState, nextOwnProps) {\n    const propsChanged = !areOwnPropsEqual(nextOwnProps, ownProps);\n    const stateChanged = !areStatesEqual(\n      nextState,\n      state,\n      nextOwnProps,\n      ownProps\n    );\n    state = nextState;\n    ownProps = nextOwnProps;\n    if (propsChanged && stateChanged)\n      return handleNewPropsAndNewState();\n    if (propsChanged)\n      return handleNewProps();\n    if (stateChanged)\n      return handleNewState();\n    return mergedProps;\n  }\n  return function pureFinalPropsSelector(nextState, nextOwnProps) {\n    return hasRunAtLeastOnce ? handleSubsequentCalls(nextState, nextOwnProps) : handleFirstCall(nextState, nextOwnProps);\n  };\n}\nfunction finalPropsSelectorFactory(dispatch, {\n  initMapStateToProps,\n  initMapDispatchToProps,\n  initMergeProps,\n  ...options\n}) {\n  const mapStateToProps = initMapStateToProps(dispatch, options);\n  const mapDispatchToProps = initMapDispatchToProps(dispatch, options);\n  const mergeProps = initMergeProps(dispatch, options);\n  if (true) {\n    verifySubselectors(mapStateToProps, mapDispatchToProps, mergeProps);\n  }\n  return pureFinalPropsSelectorFactory(mapStateToProps, mapDispatchToProps, mergeProps, dispatch, options);\n}\n\n// src/utils/bindActionCreators.ts\nfunction bindActionCreators(actionCreators, dispatch) {\n  const boundActionCreators = {};\n  for (const key in actionCreators) {\n    const actionCreator = actionCreators[key];\n    if (typeof actionCreator === \"function\") {\n      boundActionCreators[key] = (...args) => dispatch(actionCreator(...args));\n    }\n  }\n  return boundActionCreators;\n}\n\n// src/utils/isPlainObject.ts\nfunction isPlainObject(obj) {\n  if (typeof obj !== \"object\" || obj === null)\n    return false;\n  const proto = Object.getPrototypeOf(obj);\n  if (proto === null)\n    return true;\n  let baseProto = proto;\n  while (Object.getPrototypeOf(baseProto) !== null) {\n    baseProto = Object.getPrototypeOf(baseProto);\n  }\n  return proto === baseProto;\n}\n\n// src/utils/verifyPlainObject.ts\nfunction verifyPlainObject(value, displayName, methodName) {\n  if (!isPlainObject(value)) {\n    warning(\n      `${methodName}() in ${displayName} must return a plain object. Instead received ${value}.`\n    );\n  }\n}\n\n// src/connect/wrapMapToProps.ts\nfunction wrapMapToPropsConstant(getConstant) {\n  return function initConstantSelector(dispatch) {\n    const constant = getConstant(dispatch);\n    function constantSelector() {\n      return constant;\n    }\n    constantSelector.dependsOnOwnProps = false;\n    return constantSelector;\n  };\n}\nfunction getDependsOnOwnProps(mapToProps) {\n  return mapToProps.dependsOnOwnProps ? Boolean(mapToProps.dependsOnOwnProps) : mapToProps.length !== 1;\n}\nfunction wrapMapToPropsFunc(mapToProps, methodName) {\n  return function initProxySelector(dispatch, { displayName }) {\n    const proxy = function mapToPropsProxy(stateOrDispatch, ownProps) {\n      return proxy.dependsOnOwnProps ? proxy.mapToProps(stateOrDispatch, ownProps) : proxy.mapToProps(stateOrDispatch, void 0);\n    };\n    proxy.dependsOnOwnProps = true;\n    proxy.mapToProps = function detectFactoryAndVerify(stateOrDispatch, ownProps) {\n      proxy.mapToProps = mapToProps;\n      proxy.dependsOnOwnProps = getDependsOnOwnProps(mapToProps);\n      let props = proxy(stateOrDispatch, ownProps);\n      if (typeof props === \"function\") {\n        proxy.mapToProps = props;\n        proxy.dependsOnOwnProps = getDependsOnOwnProps(props);\n        props = proxy(stateOrDispatch, ownProps);\n      }\n      if (true)\n        verifyPlainObject(props, displayName, methodName);\n      return props;\n    };\n    return proxy;\n  };\n}\n\n// src/connect/invalidArgFactory.ts\nfunction createInvalidArgFactory(arg, name) {\n  return (dispatch, options) => {\n    throw new Error(\n      `Invalid value of type ${typeof arg} for ${name} argument when connecting component ${options.wrappedComponentName}.`\n    );\n  };\n}\n\n// src/connect/mapDispatchToProps.ts\nfunction mapDispatchToPropsFactory(mapDispatchToProps) {\n  return mapDispatchToProps && typeof mapDispatchToProps === \"object\" ? wrapMapToPropsConstant(\n    (dispatch) => (\n      // @ts-ignore\n      bindActionCreators(mapDispatchToProps, dispatch)\n    )\n  ) : !mapDispatchToProps ? wrapMapToPropsConstant((dispatch) => ({\n    dispatch\n  })) : typeof mapDispatchToProps === \"function\" ? (\n    // @ts-ignore\n    wrapMapToPropsFunc(mapDispatchToProps, \"mapDispatchToProps\")\n  ) : createInvalidArgFactory(mapDispatchToProps, \"mapDispatchToProps\");\n}\n\n// src/connect/mapStateToProps.ts\nfunction mapStateToPropsFactory(mapStateToProps) {\n  return !mapStateToProps ? wrapMapToPropsConstant(() => ({})) : typeof mapStateToProps === \"function\" ? (\n    // @ts-ignore\n    wrapMapToPropsFunc(mapStateToProps, \"mapStateToProps\")\n  ) : createInvalidArgFactory(mapStateToProps, \"mapStateToProps\");\n}\n\n// src/connect/mergeProps.ts\nfunction defaultMergeProps(stateProps, dispatchProps, ownProps) {\n  return { ...ownProps, ...stateProps, ...dispatchProps };\n}\nfunction wrapMergePropsFunc(mergeProps) {\n  return function initMergePropsProxy(dispatch, { displayName, areMergedPropsEqual }) {\n    let hasRunOnce = false;\n    let mergedProps;\n    return function mergePropsProxy(stateProps, dispatchProps, ownProps) {\n      const nextMergedProps = mergeProps(stateProps, dispatchProps, ownProps);\n      if (hasRunOnce) {\n        if (!areMergedPropsEqual(nextMergedProps, mergedProps))\n          mergedProps = nextMergedProps;\n      } else {\n        hasRunOnce = true;\n        mergedProps = nextMergedProps;\n        if (true)\n          verifyPlainObject(mergedProps, displayName, \"mergeProps\");\n      }\n      return mergedProps;\n    };\n  };\n}\nfunction mergePropsFactory(mergeProps) {\n  return !mergeProps ? () => defaultMergeProps : typeof mergeProps === \"function\" ? wrapMergePropsFunc(mergeProps) : createInvalidArgFactory(mergeProps, \"mergeProps\");\n}\n\n// src/utils/batch.ts\nfunction defaultNoopBatch(callback) {\n  callback();\n}\n\n// src/utils/Subscription.ts\nfunction createListenerCollection() {\n  let first = null;\n  let last = null;\n  return {\n    clear() {\n      first = null;\n      last = null;\n    },\n    notify() {\n      defaultNoopBatch(() => {\n        let listener = first;\n        while (listener) {\n          listener.callback();\n          listener = listener.next;\n        }\n      });\n    },\n    get() {\n      const listeners = [];\n      let listener = first;\n      while (listener) {\n        listeners.push(listener);\n        listener = listener.next;\n      }\n      return listeners;\n    },\n    subscribe(callback) {\n      let isSubscribed = true;\n      const listener = last = {\n        callback,\n        next: null,\n        prev: last\n      };\n      if (listener.prev) {\n        listener.prev.next = listener;\n      } else {\n        first = listener;\n      }\n      return function unsubscribe() {\n        if (!isSubscribed || first === null)\n          return;\n        isSubscribed = false;\n        if (listener.next) {\n          listener.next.prev = listener.prev;\n        } else {\n          last = listener.prev;\n        }\n        if (listener.prev) {\n          listener.prev.next = listener.next;\n        } else {\n          first = listener.next;\n        }\n      };\n    }\n  };\n}\nvar nullListeners = {\n  notify() {\n  },\n  get: () => []\n};\nfunction createSubscription(store, parentSub) {\n  let unsubscribe;\n  let listeners = nullListeners;\n  let subscriptionsAmount = 0;\n  let selfSubscribed = false;\n  function addNestedSub(listener) {\n    trySubscribe();\n    const cleanupListener = listeners.subscribe(listener);\n    let removed = false;\n    return () => {\n      if (!removed) {\n        removed = true;\n        cleanupListener();\n        tryUnsubscribe();\n      }\n    };\n  }\n  function notifyNestedSubs() {\n    listeners.notify();\n  }\n  function handleChangeWrapper() {\n    if (subscription.onStateChange) {\n      subscription.onStateChange();\n    }\n  }\n  function isSubscribed() {\n    return selfSubscribed;\n  }\n  function trySubscribe() {\n    subscriptionsAmount++;\n    if (!unsubscribe) {\n      unsubscribe = parentSub ? parentSub.addNestedSub(handleChangeWrapper) : store.subscribe(handleChangeWrapper);\n      listeners = createListenerCollection();\n    }\n  }\n  function tryUnsubscribe() {\n    subscriptionsAmount--;\n    if (unsubscribe && subscriptionsAmount === 0) {\n      unsubscribe();\n      unsubscribe = void 0;\n      listeners.clear();\n      listeners = nullListeners;\n    }\n  }\n  function trySubscribeSelf() {\n    if (!selfSubscribed) {\n      selfSubscribed = true;\n      trySubscribe();\n    }\n  }\n  function tryUnsubscribeSelf() {\n    if (selfSubscribed) {\n      selfSubscribed = false;\n      tryUnsubscribe();\n    }\n  }\n  const subscription = {\n    addNestedSub,\n    notifyNestedSubs,\n    handleChangeWrapper,\n    isSubscribed,\n    trySubscribe: trySubscribeSelf,\n    tryUnsubscribe: tryUnsubscribeSelf,\n    getListeners: () => listeners\n  };\n  return subscription;\n}\n\n// src/utils/useIsomorphicLayoutEffect.ts\nvar canUseDOM = !!(typeof window !== \"undefined\" && typeof window.document !== \"undefined\" && typeof window.document.createElement !== \"undefined\");\nvar isReactNative = typeof navigator !== \"undefined\" && navigator.product === \"ReactNative\";\nvar useIsomorphicLayoutEffect = canUseDOM || isReactNative ? React.useLayoutEffect : React.useEffect;\n\n// src/utils/shallowEqual.ts\nfunction is(x, y) {\n  if (x === y) {\n    return x !== 0 || y !== 0 || 1 / x === 1 / y;\n  } else {\n    return x !== x && y !== y;\n  }\n}\nfunction shallowEqual(objA, objB) {\n  if (is(objA, objB))\n    return true;\n  if (typeof objA !== \"object\" || objA === null || typeof objB !== \"object\" || objB === null) {\n    return false;\n  }\n  const keysA = Object.keys(objA);\n  const keysB = Object.keys(objB);\n  if (keysA.length !== keysB.length)\n    return false;\n  for (let i = 0; i < keysA.length; i++) {\n    if (!Object.prototype.hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {\n      return false;\n    }\n  }\n  return true;\n}\n\n// src/utils/hoistStatics.ts\nvar REACT_STATICS = {\n  childContextTypes: true,\n  contextType: true,\n  contextTypes: true,\n  defaultProps: true,\n  displayName: true,\n  getDefaultProps: true,\n  getDerivedStateFromError: true,\n  getDerivedStateFromProps: true,\n  mixins: true,\n  propTypes: true,\n  type: true\n};\nvar KNOWN_STATICS = {\n  name: true,\n  length: true,\n  prototype: true,\n  caller: true,\n  callee: true,\n  arguments: true,\n  arity: true\n};\nvar FORWARD_REF_STATICS = {\n  $$typeof: true,\n  render: true,\n  defaultProps: true,\n  displayName: true,\n  propTypes: true\n};\nvar MEMO_STATICS = {\n  $$typeof: true,\n  compare: true,\n  defaultProps: true,\n  displayName: true,\n  propTypes: true,\n  type: true\n};\nvar TYPE_STATICS = {\n  [ForwardRef]: FORWARD_REF_STATICS,\n  [Memo]: MEMO_STATICS\n};\nfunction getStatics(component) {\n  if (isMemo(component)) {\n    return MEMO_STATICS;\n  }\n  return TYPE_STATICS[component[\"$$typeof\"]] || REACT_STATICS;\n}\nvar defineProperty = Object.defineProperty;\nvar getOwnPropertyNames = Object.getOwnPropertyNames;\nvar getOwnPropertySymbols = Object.getOwnPropertySymbols;\nvar getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\nvar getPrototypeOf = Object.getPrototypeOf;\nvar objectPrototype = Object.prototype;\nfunction hoistNonReactStatics(targetComponent, sourceComponent) {\n  if (typeof sourceComponent !== \"string\") {\n    if (objectPrototype) {\n      const inheritedComponent = getPrototypeOf(sourceComponent);\n      if (inheritedComponent && inheritedComponent !== objectPrototype) {\n        hoistNonReactStatics(targetComponent, inheritedComponent);\n      }\n    }\n    let keys = getOwnPropertyNames(sourceComponent);\n    if (getOwnPropertySymbols) {\n      keys = keys.concat(getOwnPropertySymbols(sourceComponent));\n    }\n    const targetStatics = getStatics(targetComponent);\n    const sourceStatics = getStatics(sourceComponent);\n    for (let i = 0; i < keys.length; ++i) {\n      const key = keys[i];\n      if (!KNOWN_STATICS[key] && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {\n        const descriptor = getOwnPropertyDescriptor(sourceComponent, key);\n        try {\n          defineProperty(targetComponent, key, descriptor);\n        } catch (e) {\n        }\n      }\n    }\n  }\n  return targetComponent;\n}\n\n// src/components/connect.tsx\nvar useSyncExternalStore = notInitialized;\nvar initializeConnect = (fn) => {\n  useSyncExternalStore = fn;\n};\nvar NO_SUBSCRIPTION_ARRAY = [null, null];\nvar stringifyComponent = (Comp) => {\n  try {\n    return JSON.stringify(Comp);\n  } catch (err) {\n    return String(Comp);\n  }\n};\nfunction useIsomorphicLayoutEffectWithArgs(effectFunc, effectArgs, dependencies) {\n  useIsomorphicLayoutEffect(() => effectFunc(...effectArgs), dependencies);\n}\nfunction captureWrapperProps(lastWrapperProps, lastChildProps, renderIsScheduled, wrapperProps, childPropsFromStoreUpdate, notifyNestedSubs) {\n  lastWrapperProps.current = wrapperProps;\n  renderIsScheduled.current = false;\n  if (childPropsFromStoreUpdate.current) {\n    childPropsFromStoreUpdate.current = null;\n    notifyNestedSubs();\n  }\n}\nfunction subscribeUpdates(shouldHandleStateChanges, store, subscription, childPropsSelector, lastWrapperProps, lastChildProps, renderIsScheduled, isMounted, childPropsFromStoreUpdate, notifyNestedSubs, additionalSubscribeListener) {\n  if (!shouldHandleStateChanges)\n    return () => {\n    };\n  let didUnsubscribe = false;\n  let lastThrownError = null;\n  const checkForUpdates = () => {\n    if (didUnsubscribe || !isMounted.current) {\n      return;\n    }\n    const latestStoreState = store.getState();\n    let newChildProps, error;\n    try {\n      newChildProps = childPropsSelector(\n        latestStoreState,\n        lastWrapperProps.current\n      );\n    } catch (e) {\n      error = e;\n      lastThrownError = e;\n    }\n    if (!error) {\n      lastThrownError = null;\n    }\n    if (newChildProps === lastChildProps.current) {\n      if (!renderIsScheduled.current) {\n        notifyNestedSubs();\n      }\n    } else {\n      lastChildProps.current = newChildProps;\n      childPropsFromStoreUpdate.current = newChildProps;\n      renderIsScheduled.current = true;\n      additionalSubscribeListener();\n    }\n  };\n  subscription.onStateChange = checkForUpdates;\n  subscription.trySubscribe();\n  checkForUpdates();\n  const unsubscribeWrapper = () => {\n    didUnsubscribe = true;\n    subscription.tryUnsubscribe();\n    subscription.onStateChange = null;\n    if (lastThrownError) {\n      throw lastThrownError;\n    }\n  };\n  return unsubscribeWrapper;\n}\nfunction strictEqual(a, b) {\n  return a === b;\n}\nvar hasWarnedAboutDeprecatedPureOption = false;\nfunction connect(mapStateToProps, mapDispatchToProps, mergeProps, {\n  // The `pure` option has been removed, so TS doesn't like us destructuring this to check its existence.\n  // @ts-ignore\n  pure,\n  areStatesEqual = strictEqual,\n  areOwnPropsEqual = shallowEqual,\n  areStatePropsEqual = shallowEqual,\n  areMergedPropsEqual = shallowEqual,\n  // use React's forwardRef to expose a ref of the wrapped component\n  forwardRef = false,\n  // the context consumer to use\n  context = ReactReduxContext\n} = {}) {\n  if (true) {\n    if (pure !== void 0 && !hasWarnedAboutDeprecatedPureOption) {\n      hasWarnedAboutDeprecatedPureOption = true;\n      warning(\n        'The `pure` option has been removed. `connect` is now always a \"pure/memoized\" component'\n      );\n    }\n  }\n  const Context = context;\n  const initMapStateToProps = mapStateToPropsFactory(mapStateToProps);\n  const initMapDispatchToProps = mapDispatchToPropsFactory(mapDispatchToProps);\n  const initMergeProps = mergePropsFactory(mergeProps);\n  const shouldHandleStateChanges = Boolean(mapStateToProps);\n  const wrapWithConnect = (WrappedComponent) => {\n    if (true) {\n      const isValid = /* @__PURE__ */ isValidElementType(WrappedComponent);\n      if (!isValid)\n        throw new Error(\n          `You must pass a component to the function returned by connect. Instead received ${stringifyComponent(\n            WrappedComponent\n          )}`\n        );\n    }\n    const wrappedComponentName = WrappedComponent.displayName || WrappedComponent.name || \"Component\";\n    const displayName = `Connect(${wrappedComponentName})`;\n    const selectorFactoryOptions = {\n      shouldHandleStateChanges,\n      displayName,\n      wrappedComponentName,\n      WrappedComponent,\n      // @ts-ignore\n      initMapStateToProps,\n      // @ts-ignore\n      initMapDispatchToProps,\n      initMergeProps,\n      areStatesEqual,\n      areStatePropsEqual,\n      areOwnPropsEqual,\n      areMergedPropsEqual\n    };\n    function ConnectFunction(props) {\n      const [propsContext, reactReduxForwardedRef, wrapperProps] = React.useMemo(() => {\n        const { reactReduxForwardedRef: reactReduxForwardedRef2, ...wrapperProps2 } = props;\n        return [props.context, reactReduxForwardedRef2, wrapperProps2];\n      }, [props]);\n      const ContextToUse = React.useMemo(() => {\n        let ResultContext = Context;\n        if (propsContext?.Consumer) {\n          if (true) {\n            const isValid = /* @__PURE__ */ isContextConsumer(\n              // @ts-ignore\n              /* @__PURE__ */ React.createElement(propsContext.Consumer, null)\n            );\n            if (!isValid) {\n              throw new Error(\n                \"You must pass a valid React context consumer as `props.context`\"\n              );\n            }\n            ResultContext = propsContext;\n          }\n        }\n        return ResultContext;\n      }, [propsContext, Context]);\n      const contextValue = React.useContext(ContextToUse);\n      const didStoreComeFromProps = Boolean(props.store) && Boolean(props.store.getState) && Boolean(props.store.dispatch);\n      const didStoreComeFromContext = Boolean(contextValue) && Boolean(contextValue.store);\n      if ( true && !didStoreComeFromProps && !didStoreComeFromContext) {\n        throw new Error(\n          `Could not find \"store\" in the context of \"${displayName}\". Either wrap the root component in a <Provider>, or pass a custom React context provider to <Provider> and the corresponding React context consumer to ${displayName} in connect options.`\n        );\n      }\n      const store = didStoreComeFromProps ? props.store : contextValue.store;\n      const getServerState = didStoreComeFromContext ? contextValue.getServerState : store.getState;\n      const childPropsSelector = React.useMemo(() => {\n        return finalPropsSelectorFactory(store.dispatch, selectorFactoryOptions);\n      }, [store]);\n      const [subscription, notifyNestedSubs] = React.useMemo(() => {\n        if (!shouldHandleStateChanges)\n          return NO_SUBSCRIPTION_ARRAY;\n        const subscription2 = createSubscription(\n          store,\n          didStoreComeFromProps ? void 0 : contextValue.subscription\n        );\n        const notifyNestedSubs2 = subscription2.notifyNestedSubs.bind(subscription2);\n        return [subscription2, notifyNestedSubs2];\n      }, [store, didStoreComeFromProps, contextValue]);\n      const overriddenContextValue = React.useMemo(() => {\n        if (didStoreComeFromProps) {\n          return contextValue;\n        }\n        return {\n          ...contextValue,\n          subscription\n        };\n      }, [didStoreComeFromProps, contextValue, subscription]);\n      const lastChildProps = React.useRef();\n      const lastWrapperProps = React.useRef(wrapperProps);\n      const childPropsFromStoreUpdate = React.useRef();\n      const renderIsScheduled = React.useRef(false);\n      const isMounted = React.useRef(false);\n      const latestSubscriptionCallbackError = React.useRef();\n      useIsomorphicLayoutEffect(() => {\n        isMounted.current = true;\n        return () => {\n          isMounted.current = false;\n        };\n      }, []);\n      const actualChildPropsSelector = React.useMemo(() => {\n        const selector = () => {\n          if (childPropsFromStoreUpdate.current && wrapperProps === lastWrapperProps.current) {\n            return childPropsFromStoreUpdate.current;\n          }\n          return childPropsSelector(store.getState(), wrapperProps);\n        };\n        return selector;\n      }, [store, wrapperProps]);\n      const subscribeForReact = React.useMemo(() => {\n        const subscribe = (reactListener) => {\n          if (!subscription) {\n            return () => {\n            };\n          }\n          return subscribeUpdates(\n            shouldHandleStateChanges,\n            store,\n            subscription,\n            // @ts-ignore\n            childPropsSelector,\n            lastWrapperProps,\n            lastChildProps,\n            renderIsScheduled,\n            isMounted,\n            childPropsFromStoreUpdate,\n            notifyNestedSubs,\n            reactListener\n          );\n        };\n        return subscribe;\n      }, [subscription]);\n      useIsomorphicLayoutEffectWithArgs(captureWrapperProps, [\n        lastWrapperProps,\n        lastChildProps,\n        renderIsScheduled,\n        wrapperProps,\n        childPropsFromStoreUpdate,\n        notifyNestedSubs\n      ]);\n      let actualChildProps;\n      try {\n        actualChildProps = useSyncExternalStore(\n          // TODO We're passing through a big wrapper that does a bunch of extra side effects besides subscribing\n          subscribeForReact,\n          // TODO This is incredibly hacky. We've already processed the store update and calculated new child props,\n          // TODO and we're just passing that through so it triggers a re-render for us rather than relying on `uSES`.\n          actualChildPropsSelector,\n          getServerState ? () => childPropsSelector(getServerState(), wrapperProps) : actualChildPropsSelector\n        );\n      } catch (err) {\n        if (latestSubscriptionCallbackError.current) {\n          ;\n          err.message += `\nThe error may be correlated with this previous error:\n${latestSubscriptionCallbackError.current.stack}\n\n`;\n        }\n        throw err;\n      }\n      useIsomorphicLayoutEffect(() => {\n        latestSubscriptionCallbackError.current = void 0;\n        childPropsFromStoreUpdate.current = void 0;\n        lastChildProps.current = actualChildProps;\n      });\n      const renderedWrappedComponent = React.useMemo(() => {\n        return (\n          // @ts-ignore\n          /* @__PURE__ */ React.createElement(\n            WrappedComponent,\n            {\n              ...actualChildProps,\n              ref: reactReduxForwardedRef\n            }\n          )\n        );\n      }, [reactReduxForwardedRef, WrappedComponent, actualChildProps]);\n      const renderedChild = React.useMemo(() => {\n        if (shouldHandleStateChanges) {\n          return /* @__PURE__ */ React.createElement(ContextToUse.Provider, { value: overriddenContextValue }, renderedWrappedComponent);\n        }\n        return renderedWrappedComponent;\n      }, [ContextToUse, renderedWrappedComponent, overriddenContextValue]);\n      return renderedChild;\n    }\n    const _Connect = React.memo(ConnectFunction);\n    const Connect = _Connect;\n    Connect.WrappedComponent = WrappedComponent;\n    Connect.displayName = ConnectFunction.displayName = displayName;\n    if (forwardRef) {\n      const _forwarded = React.forwardRef(\n        function forwardConnectRef(props, ref) {\n          return /* @__PURE__ */ React.createElement(Connect, { ...props, reactReduxForwardedRef: ref });\n        }\n      );\n      const forwarded = _forwarded;\n      forwarded.displayName = displayName;\n      forwarded.WrappedComponent = WrappedComponent;\n      return /* @__PURE__ */ hoistNonReactStatics(forwarded, WrappedComponent);\n    }\n    return /* @__PURE__ */ hoistNonReactStatics(Connect, WrappedComponent);\n  };\n  return wrapWithConnect;\n}\nvar connect_default = connect;\n\n// src/components/Provider.tsx\nfunction Provider({\n  store,\n  context,\n  children,\n  serverState,\n  stabilityCheck = \"once\",\n  identityFunctionCheck = \"once\"\n}) {\n  const contextValue = React.useMemo(() => {\n    const subscription = createSubscription(store);\n    return {\n      store,\n      subscription,\n      getServerState: serverState ? () => serverState : void 0,\n      stabilityCheck,\n      identityFunctionCheck\n    };\n  }, [store, serverState, stabilityCheck, identityFunctionCheck]);\n  const previousState = React.useMemo(() => store.getState(), [store]);\n  useIsomorphicLayoutEffect(() => {\n    const { subscription } = contextValue;\n    subscription.onStateChange = subscription.notifyNestedSubs;\n    subscription.trySubscribe();\n    if (previousState !== store.getState()) {\n      subscription.notifyNestedSubs();\n    }\n    return () => {\n      subscription.tryUnsubscribe();\n      subscription.onStateChange = void 0;\n    };\n  }, [contextValue, previousState]);\n  const Context = context || ReactReduxContext;\n  return /* @__PURE__ */ React.createElement(Context.Provider, { value: contextValue }, children);\n}\nvar Provider_default = Provider;\n\n// src/hooks/useStore.ts\nfunction createStoreHook(context = ReactReduxContext) {\n  const useReduxContext2 = context === ReactReduxContext ? useReduxContext : (\n    // @ts-ignore\n    createReduxContextHook(context)\n  );\n  const useStore2 = () => {\n    const { store } = useReduxContext2();\n    return store;\n  };\n  Object.assign(useStore2, {\n    withTypes: () => useStore2\n  });\n  return useStore2;\n}\nvar useStore = /* @__PURE__ */ createStoreHook();\n\n// src/hooks/useDispatch.ts\nfunction createDispatchHook(context = ReactReduxContext) {\n  const useStore2 = context === ReactReduxContext ? useStore : createStoreHook(context);\n  const useDispatch2 = () => {\n    const store = useStore2();\n    return store.dispatch;\n  };\n  Object.assign(useDispatch2, {\n    withTypes: () => useDispatch2\n  });\n  return useDispatch2;\n}\nvar useDispatch = /* @__PURE__ */ createDispatchHook();\n\n// src/exports.ts\nvar batch = defaultNoopBatch;\n\n// src/index.ts\ninitializeUseSelector(use_sync_external_store_with_selector_js__WEBPACK_IMPORTED_MODULE_1__.useSyncExternalStoreWithSelector);\ninitializeConnect(react__WEBPACK_IMPORTED_MODULE_0__.useSyncExternalStore);\n\n//# sourceMappingURL=react-redux.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9kaXN0L3JlYWN0LXJlZHV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ2dDO0FBQ2lHOztBQUVqSTtBQUN1QztBQUN2QztBQUNBO0FBQ0E7QUFDQSxFQUFFLEtBQTBCLEdBQUcsa0NBQXdCLEdBQUcseUxBQWE7QUFDdkU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxJQUFxQztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsS0FBcUM7QUFDN0M7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQsWUFBWSwrQ0FBK0MsZ0RBQWdELGtDQUFrQztBQUM3SSxRQUFRLElBQXFDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxJQUFxQztBQUNuRDtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSxxQkFBcUIsUUFBUTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0EscUJBQXFCLFFBQVE7QUFDN0I7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFlBQVk7QUFDeEQsSUFBSTtBQUNKO0FBQ0E7QUFDQSw0QkFBNEIsWUFBWTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLE1BQU0sSUFBcUM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsV0FBVyxRQUFRLGFBQWEsK0NBQStDLE1BQU07QUFDOUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxhQUFhO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxJQUFxQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsWUFBWSxNQUFNLE1BQU0scUNBQXFDLDZCQUE2QjtBQUN6SDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0Esa0RBQWtELGtDQUFrQztBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsWUFBWSxJQUFxQztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxJQUFJO0FBQ04sTUFBTSxJQUFxQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsSUFBcUM7QUFDN0M7QUFDQTtBQUNBO0FBQ0EsNkZBQTZGO0FBQzdGO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxxQkFBcUI7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixvRUFBb0U7QUFDcEY7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsY0FBYyxJQUFxQztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxVQUFVLEtBQXFDO0FBQy9DO0FBQ0EsdURBQXVELFlBQVksMkpBQTJKLGFBQWE7QUFDM087QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsOEVBQThFLCtCQUErQjtBQUM3RztBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSx1Q0FBdUM7QUFDdkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxZQUFZLGVBQWU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsaUVBQWlFLHFCQUFxQjtBQUN0RjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0Isc0dBQWlDO0FBQ3ZELGtCQUFrQix1REFBMkI7QUFhM0M7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVkdXgvZGlzdC9yZWFjdC1yZWR1eC5tanM/YjRlNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvaW5kZXgudHNcbmltcG9ydCAqIGFzIFJlYWN0MiBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IHVzZVN5bmNFeHRlcm5hbFN0b3JlV2l0aFNlbGVjdG9yIGFzIHVzZVN5bmNFeHRlcm5hbFN0b3JlV2l0aFNlbGVjdG9yMiB9IGZyb20gXCJ1c2Utc3luYy1leHRlcm5hbC1zdG9yZS93aXRoLXNlbGVjdG9yLmpzXCI7XG5cbi8vIHNyYy91dGlscy9yZWFjdC50c1xuaW1wb3J0ICogYXMgUmVhY3RPcmlnaW5hbCBmcm9tIFwicmVhY3RcIjtcbnZhciBSZWFjdCA9IChcbiAgLy8gcHJldHRpZXItaWdub3JlXG4gIC8vIEB0cy1pZ25vcmVcbiAgXCJkZWZhdWx0XCIgaW4gUmVhY3RPcmlnaW5hbCA/IFJlYWN0T3JpZ2luYWxbXCJkZWZhdWx0XCJdIDogUmVhY3RPcmlnaW5hbFxuKTtcblxuLy8gc3JjL2NvbXBvbmVudHMvQ29udGV4dC50c1xudmFyIENvbnRleHRLZXkgPSBTeW1ib2wuZm9yKGByZWFjdC1yZWR1eC1jb250ZXh0YCk7XG52YXIgZ1QgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbFRoaXMgOiAoXG4gIC8qIGZhbGwgYmFjayB0byBhIHBlci1tb2R1bGUgc2NvcGUgKHByZS04LjEgYmVoYXZpb3VyKSBpZiBgZ2xvYmFsVGhpc2AgaXMgbm90IGF2YWlsYWJsZSAqL1xuICB7fVxuKTtcbmZ1bmN0aW9uIGdldENvbnRleHQoKSB7XG4gIGlmICghUmVhY3QuY3JlYXRlQ29udGV4dClcbiAgICByZXR1cm4ge307XG4gIGNvbnN0IGNvbnRleHRNYXAgPSBnVFtDb250ZXh0S2V5XSA/PyAoZ1RbQ29udGV4dEtleV0gPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpKTtcbiAgbGV0IHJlYWxDb250ZXh0ID0gY29udGV4dE1hcC5nZXQoUmVhY3QuY3JlYXRlQ29udGV4dCk7XG4gIGlmICghcmVhbENvbnRleHQpIHtcbiAgICByZWFsQ29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQoXG4gICAgICBudWxsXG4gICAgKTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICByZWFsQ29udGV4dC5kaXNwbGF5TmFtZSA9IFwiUmVhY3RSZWR1eFwiO1xuICAgIH1cbiAgICBjb250ZXh0TWFwLnNldChSZWFjdC5jcmVhdGVDb250ZXh0LCByZWFsQ29udGV4dCk7XG4gIH1cbiAgcmV0dXJuIHJlYWxDb250ZXh0O1xufVxudmFyIFJlYWN0UmVkdXhDb250ZXh0ID0gLyogQF9fUFVSRV9fICovIGdldENvbnRleHQoKTtcblxuLy8gc3JjL3V0aWxzL3VzZVN5bmNFeHRlcm5hbFN0b3JlLnRzXG52YXIgbm90SW5pdGlhbGl6ZWQgPSAoKSA9PiB7XG4gIHRocm93IG5ldyBFcnJvcihcInVTRVMgbm90IGluaXRpYWxpemVkIVwiKTtcbn07XG5cbi8vIHNyYy9ob29rcy91c2VSZWR1eENvbnRleHQudHNcbmZ1bmN0aW9uIGNyZWF0ZVJlZHV4Q29udGV4dEhvb2soY29udGV4dCA9IFJlYWN0UmVkdXhDb250ZXh0KSB7XG4gIHJldHVybiBmdW5jdGlvbiB1c2VSZWR1eENvbnRleHQyKCkge1xuICAgIGNvbnN0IGNvbnRleHRWYWx1ZSA9IFJlYWN0LnVzZUNvbnRleHQoY29udGV4dCk7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiAhY29udGV4dFZhbHVlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiY291bGQgbm90IGZpbmQgcmVhY3QtcmVkdXggY29udGV4dCB2YWx1ZTsgcGxlYXNlIGVuc3VyZSB0aGUgY29tcG9uZW50IGlzIHdyYXBwZWQgaW4gYSA8UHJvdmlkZXI+XCJcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBjb250ZXh0VmFsdWU7XG4gIH07XG59XG52YXIgdXNlUmVkdXhDb250ZXh0ID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZVJlZHV4Q29udGV4dEhvb2soKTtcblxuLy8gc3JjL2hvb2tzL3VzZVNlbGVjdG9yLnRzXG52YXIgdXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3IgPSBub3RJbml0aWFsaXplZDtcbnZhciBpbml0aWFsaXplVXNlU2VsZWN0b3IgPSAoZm4pID0+IHtcbiAgdXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3IgPSBmbjtcbn07XG52YXIgcmVmRXF1YWxpdHkgPSAoYSwgYikgPT4gYSA9PT0gYjtcbmZ1bmN0aW9uIGNyZWF0ZVNlbGVjdG9ySG9vayhjb250ZXh0ID0gUmVhY3RSZWR1eENvbnRleHQpIHtcbiAgY29uc3QgdXNlUmVkdXhDb250ZXh0MiA9IGNvbnRleHQgPT09IFJlYWN0UmVkdXhDb250ZXh0ID8gdXNlUmVkdXhDb250ZXh0IDogY3JlYXRlUmVkdXhDb250ZXh0SG9vayhjb250ZXh0KTtcbiAgY29uc3QgdXNlU2VsZWN0b3IyID0gKHNlbGVjdG9yLCBlcXVhbGl0eUZuT3JPcHRpb25zID0ge30pID0+IHtcbiAgICBjb25zdCB7IGVxdWFsaXR5Rm4gPSByZWZFcXVhbGl0eSwgZGV2TW9kZUNoZWNrcyA9IHt9IH0gPSB0eXBlb2YgZXF1YWxpdHlGbk9yT3B0aW9ucyA9PT0gXCJmdW5jdGlvblwiID8geyBlcXVhbGl0eUZuOiBlcXVhbGl0eUZuT3JPcHRpb25zIH0gOiBlcXVhbGl0eUZuT3JPcHRpb25zO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIGlmICghc2VsZWN0b3IpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBZb3UgbXVzdCBwYXNzIGEgc2VsZWN0b3IgdG8gdXNlU2VsZWN0b3JgKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2Ygc2VsZWN0b3IgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFlvdSBtdXN0IHBhc3MgYSBmdW5jdGlvbiBhcyBhIHNlbGVjdG9yIHRvIHVzZVNlbGVjdG9yYCk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGVxdWFsaXR5Rm4gIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYFlvdSBtdXN0IHBhc3MgYSBmdW5jdGlvbiBhcyBhbiBlcXVhbGl0eSBmdW5jdGlvbiB0byB1c2VTZWxlY3RvcmBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgc3RvcmUsXG4gICAgICBzdWJzY3JpcHRpb24sXG4gICAgICBnZXRTZXJ2ZXJTdGF0ZSxcbiAgICAgIHN0YWJpbGl0eUNoZWNrLFxuICAgICAgaWRlbnRpdHlGdW5jdGlvbkNoZWNrXG4gICAgfSA9IHVzZVJlZHV4Q29udGV4dDIoKTtcbiAgICBjb25zdCBmaXJzdFJ1biA9IFJlYWN0LnVzZVJlZih0cnVlKTtcbiAgICBjb25zdCB3cmFwcGVkU2VsZWN0b3IgPSBSZWFjdC51c2VDYWxsYmFjayhcbiAgICAgIHtcbiAgICAgICAgW3NlbGVjdG9yLm5hbWVdKHN0YXRlKSB7XG4gICAgICAgICAgY29uc3Qgc2VsZWN0ZWQgPSBzZWxlY3RvcihzdGF0ZSk7XG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICBpZGVudGl0eUZ1bmN0aW9uQ2hlY2s6IGZpbmFsSWRlbnRpdHlGdW5jdGlvbkNoZWNrLFxuICAgICAgICAgICAgICBzdGFiaWxpdHlDaGVjazogZmluYWxTdGFiaWxpdHlDaGVja1xuICAgICAgICAgICAgfSA9IHtcbiAgICAgICAgICAgICAgc3RhYmlsaXR5Q2hlY2ssXG4gICAgICAgICAgICAgIGlkZW50aXR5RnVuY3Rpb25DaGVjayxcbiAgICAgICAgICAgICAgLi4uZGV2TW9kZUNoZWNrc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChmaW5hbFN0YWJpbGl0eUNoZWNrID09PSBcImFsd2F5c1wiIHx8IGZpbmFsU3RhYmlsaXR5Q2hlY2sgPT09IFwib25jZVwiICYmIGZpcnN0UnVuLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgY29uc3QgdG9Db21wYXJlID0gc2VsZWN0b3Ioc3RhdGUpO1xuICAgICAgICAgICAgICBpZiAoIWVxdWFsaXR5Rm4oc2VsZWN0ZWQsIHRvQ29tcGFyZSkpIHtcbiAgICAgICAgICAgICAgICBsZXQgc3RhY2sgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICAgICh7IHN0YWNrIH0gPSBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgICAgICAgXCJTZWxlY3RvciBcIiArIChzZWxlY3Rvci5uYW1lIHx8IFwidW5rbm93blwiKSArIFwiIHJldHVybmVkIGEgZGlmZmVyZW50IHJlc3VsdCB3aGVuIGNhbGxlZCB3aXRoIHRoZSBzYW1lIHBhcmFtZXRlcnMuIFRoaXMgY2FuIGxlYWQgdG8gdW5uZWNlc3NhcnkgcmVyZW5kZXJzLlxcblNlbGVjdG9ycyB0aGF0IHJldHVybiBhIG5ldyByZWZlcmVuY2UgKHN1Y2ggYXMgYW4gb2JqZWN0IG9yIGFuIGFycmF5KSBzaG91bGQgYmUgbWVtb2l6ZWQ6IGh0dHBzOi8vcmVkdXguanMub3JnL3VzYWdlL2Rlcml2aW5nLWRhdGEtc2VsZWN0b3JzI29wdGltaXppbmctc2VsZWN0b3JzLXdpdGgtbWVtb2l6YXRpb25cIixcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUsXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkLFxuICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZDI6IHRvQ29tcGFyZSxcbiAgICAgICAgICAgICAgICAgICAgc3RhY2tcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZmluYWxJZGVudGl0eUZ1bmN0aW9uQ2hlY2sgPT09IFwiYWx3YXlzXCIgfHwgZmluYWxJZGVudGl0eUZ1bmN0aW9uQ2hlY2sgPT09IFwib25jZVwiICYmIGZpcnN0UnVuLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgaWYgKHNlbGVjdGVkID09PSBzdGF0ZSkge1xuICAgICAgICAgICAgICAgIGxldCBzdGFjayA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgICAgKHsgc3RhY2sgfSA9IGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAgICAgICBcIlNlbGVjdG9yIFwiICsgKHNlbGVjdG9yLm5hbWUgfHwgXCJ1bmtub3duXCIpICsgXCIgcmV0dXJuZWQgdGhlIHJvb3Qgc3RhdGUgd2hlbiBjYWxsZWQuIFRoaXMgY2FuIGxlYWQgdG8gdW5uZWNlc3NhcnkgcmVyZW5kZXJzLlxcblNlbGVjdG9ycyB0aGF0IHJldHVybiB0aGUgZW50aXJlIHN0YXRlIGFyZSBhbG1vc3QgY2VydGFpbmx5IGEgbWlzdGFrZSwgYXMgdGhleSB3aWxsIGNhdXNlIGEgcmVyZW5kZXIgd2hlbmV2ZXIgKmFueXRoaW5nKiBpbiBzdGF0ZSBjaGFuZ2VzLlwiLFxuICAgICAgICAgICAgICAgICAgeyBzdGFjayB9XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZpcnN0UnVuLmN1cnJlbnQpXG4gICAgICAgICAgICAgIGZpcnN0UnVuLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHNlbGVjdGVkO1xuICAgICAgICB9XG4gICAgICB9W3NlbGVjdG9yLm5hbWVdLFxuICAgICAgW3NlbGVjdG9yLCBzdGFiaWxpdHlDaGVjaywgZGV2TW9kZUNoZWNrcy5zdGFiaWxpdHlDaGVja11cbiAgICApO1xuICAgIGNvbnN0IHNlbGVjdGVkU3RhdGUgPSB1c2VTeW5jRXh0ZXJuYWxTdG9yZVdpdGhTZWxlY3RvcihcbiAgICAgIHN1YnNjcmlwdGlvbi5hZGROZXN0ZWRTdWIsXG4gICAgICBzdG9yZS5nZXRTdGF0ZSxcbiAgICAgIGdldFNlcnZlclN0YXRlIHx8IHN0b3JlLmdldFN0YXRlLFxuICAgICAgd3JhcHBlZFNlbGVjdG9yLFxuICAgICAgZXF1YWxpdHlGblxuICAgICk7XG4gICAgUmVhY3QudXNlRGVidWdWYWx1ZShzZWxlY3RlZFN0YXRlKTtcbiAgICByZXR1cm4gc2VsZWN0ZWRTdGF0ZTtcbiAgfTtcbiAgT2JqZWN0LmFzc2lnbih1c2VTZWxlY3RvcjIsIHtcbiAgICB3aXRoVHlwZXM6ICgpID0+IHVzZVNlbGVjdG9yMlxuICB9KTtcbiAgcmV0dXJuIHVzZVNlbGVjdG9yMjtcbn1cbnZhciB1c2VTZWxlY3RvciA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVTZWxlY3Rvckhvb2soKTtcblxuLy8gc3JjL3V0aWxzL3JlYWN0LWlzLnRzXG52YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmVsZW1lbnRcIik7XG52YXIgUkVBQ1RfUE9SVEFMX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QucG9ydGFsXCIpO1xudmFyIFJFQUNUX0ZSQUdNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuZnJhZ21lbnRcIik7XG52YXIgUkVBQ1RfU1RSSUNUX01PREVfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5zdHJpY3RfbW9kZVwiKTtcbnZhciBSRUFDVF9QUk9GSUxFUl9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnByb2ZpbGVyXCIpO1xudmFyIFJFQUNUX1BST1ZJREVSX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QucHJvdmlkZXJcIik7XG52YXIgUkVBQ1RfQ09OVEVYVF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmNvbnRleHRcIik7XG52YXIgUkVBQ1RfU0VSVkVSX0NPTlRFWFRfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5zZXJ2ZXJfY29udGV4dFwiKTtcbnZhciBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmZvcndhcmRfcmVmXCIpO1xudmFyIFJFQUNUX1NVU1BFTlNFX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3Quc3VzcGVuc2VcIik7XG52YXIgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnN1c3BlbnNlX2xpc3RcIik7XG52YXIgUkVBQ1RfTUVNT19UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0Lm1lbW9cIik7XG52YXIgUkVBQ1RfTEFaWV9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmxhenlcIik7XG52YXIgUkVBQ1RfT0ZGU0NSRUVOX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3Qub2Zmc2NyZWVuXCIpO1xudmFyIFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UgPSBTeW1ib2wuZm9yKFwicmVhY3QuY2xpZW50LnJlZmVyZW5jZVwiKTtcbnZhciBGb3J3YXJkUmVmID0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTtcbnZhciBNZW1vID0gUkVBQ1RfTUVNT19UWVBFO1xuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpIHtcbiAgaWYgKHR5cGVvZiB0eXBlID09PSBcInN0cmluZ1wiIHx8IHR5cGVvZiB0eXBlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAodHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9QUk9GSUxFUl9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfT0ZGU0NSRUVOX1RZUEUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAodHlwZW9mIHR5cGUgPT09IFwib2JqZWN0XCIgJiYgdHlwZSAhPT0gbnVsbCkge1xuICAgIGlmICh0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9MQVpZX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTUVNT19UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX1BST1ZJREVSX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgLy8gVGhpcyBuZWVkcyB0byBpbmNsdWRlIGFsbCBwb3NzaWJsZSBtb2R1bGUgcmVmZXJlbmNlIG9iamVjdFxuICAgIC8vIHR5cGVzIHN1cHBvcnRlZCBieSBhbnkgRmxpZ2h0IGNvbmZpZ3VyYXRpb24gYW55d2hlcmUgc2luY2VcbiAgICAvLyB3ZSBkb24ndCBrbm93IHdoaWNoIEZsaWdodCBidWlsZCB0aGlzIHdpbGwgZW5kIHVwIGJlaW5nIHVzZWRcbiAgICAvLyB3aXRoLlxuICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UgfHwgdHlwZS5nZXRNb2R1bGVJZCAhPT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gdHlwZU9mKG9iamVjdCkge1xuICBpZiAodHlwZW9mIG9iamVjdCA9PT0gXCJvYmplY3RcIiAmJiBvYmplY3QgIT09IG51bGwpIHtcbiAgICBjb25zdCAkJHR5cGVvZiA9IG9iamVjdC4kJHR5cGVvZjtcbiAgICBzd2l0Y2ggKCQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRToge1xuICAgICAgICBjb25zdCB0eXBlID0gb2JqZWN0LnR5cGU7XG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgIGNhc2UgUkVBQ1RfRlJBR01FTlRfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX1BST0ZJTEVSX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgICAgICAgIHJldHVybiB0eXBlO1xuICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgIGNvbnN0ICQkdHlwZW9mVHlwZSA9IHR5cGUgJiYgdHlwZS4kJHR5cGVvZjtcbiAgICAgICAgICAgIHN3aXRjaCAoJCR0eXBlb2ZUeXBlKSB7XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfU0VSVkVSX0NPTlRFWFRfVFlQRTpcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICAgICAgICBjYXNlIFJFQUNUX1BST1ZJREVSX1RZUEU6XG4gICAgICAgICAgICAgICAgcmV0dXJuICQkdHlwZW9mVHlwZTtcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gJCR0eXBlb2Y7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOiB7XG4gICAgICAgIHJldHVybiAkJHR5cGVvZjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZvaWQgMDtcbn1cbmZ1bmN0aW9uIGlzQ29udGV4dENvbnN1bWVyKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX0NPTlRFWFRfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzTWVtbyhvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9NRU1PX1RZUEU7XG59XG5cbi8vIHNyYy91dGlscy93YXJuaW5nLnRzXG5mdW5jdGlvbiB3YXJuaW5nKG1lc3NhZ2UpIHtcbiAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiBjb25zb2xlLmVycm9yID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xuICB9XG4gIHRyeSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICB9IGNhdGNoIChlKSB7XG4gIH1cbn1cblxuLy8gc3JjL2Nvbm5lY3QvdmVyaWZ5U3Vic2VsZWN0b3JzLnRzXG5mdW5jdGlvbiB2ZXJpZnkoc2VsZWN0b3IsIG1ldGhvZE5hbWUpIHtcbiAgaWYgKCFzZWxlY3Rvcikge1xuICAgIHRocm93IG5ldyBFcnJvcihgVW5leHBlY3RlZCB2YWx1ZSBmb3IgJHttZXRob2ROYW1lfSBpbiBjb25uZWN0LmApO1xuICB9IGVsc2UgaWYgKG1ldGhvZE5hbWUgPT09IFwibWFwU3RhdGVUb1Byb3BzXCIgfHwgbWV0aG9kTmFtZSA9PT0gXCJtYXBEaXNwYXRjaFRvUHJvcHNcIikge1xuICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNlbGVjdG9yLCBcImRlcGVuZHNPbk93blByb3BzXCIpKSB7XG4gICAgICB3YXJuaW5nKFxuICAgICAgICBgVGhlIHNlbGVjdG9yIGZvciAke21ldGhvZE5hbWV9IG9mIGNvbm5lY3QgZGlkIG5vdCBzcGVjaWZ5IGEgdmFsdWUgZm9yIGRlcGVuZHNPbk93blByb3BzLmBcbiAgICAgICk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiB2ZXJpZnlTdWJzZWxlY3RvcnMobWFwU3RhdGVUb1Byb3BzLCBtYXBEaXNwYXRjaFRvUHJvcHMsIG1lcmdlUHJvcHMpIHtcbiAgdmVyaWZ5KG1hcFN0YXRlVG9Qcm9wcywgXCJtYXBTdGF0ZVRvUHJvcHNcIik7XG4gIHZlcmlmeShtYXBEaXNwYXRjaFRvUHJvcHMsIFwibWFwRGlzcGF0Y2hUb1Byb3BzXCIpO1xuICB2ZXJpZnkobWVyZ2VQcm9wcywgXCJtZXJnZVByb3BzXCIpO1xufVxuXG4vLyBzcmMvY29ubmVjdC9zZWxlY3RvckZhY3RvcnkudHNcbmZ1bmN0aW9uIHB1cmVGaW5hbFByb3BzU2VsZWN0b3JGYWN0b3J5KG1hcFN0YXRlVG9Qcm9wcywgbWFwRGlzcGF0Y2hUb1Byb3BzLCBtZXJnZVByb3BzLCBkaXNwYXRjaCwge1xuICBhcmVTdGF0ZXNFcXVhbCxcbiAgYXJlT3duUHJvcHNFcXVhbCxcbiAgYXJlU3RhdGVQcm9wc0VxdWFsXG59KSB7XG4gIGxldCBoYXNSdW5BdExlYXN0T25jZSA9IGZhbHNlO1xuICBsZXQgc3RhdGU7XG4gIGxldCBvd25Qcm9wcztcbiAgbGV0IHN0YXRlUHJvcHM7XG4gIGxldCBkaXNwYXRjaFByb3BzO1xuICBsZXQgbWVyZ2VkUHJvcHM7XG4gIGZ1bmN0aW9uIGhhbmRsZUZpcnN0Q2FsbChmaXJzdFN0YXRlLCBmaXJzdE93blByb3BzKSB7XG4gICAgc3RhdGUgPSBmaXJzdFN0YXRlO1xuICAgIG93blByb3BzID0gZmlyc3RPd25Qcm9wcztcbiAgICBzdGF0ZVByb3BzID0gbWFwU3RhdGVUb1Byb3BzKHN0YXRlLCBvd25Qcm9wcyk7XG4gICAgZGlzcGF0Y2hQcm9wcyA9IG1hcERpc3BhdGNoVG9Qcm9wcyhkaXNwYXRjaCwgb3duUHJvcHMpO1xuICAgIG1lcmdlZFByb3BzID0gbWVyZ2VQcm9wcyhzdGF0ZVByb3BzLCBkaXNwYXRjaFByb3BzLCBvd25Qcm9wcyk7XG4gICAgaGFzUnVuQXRMZWFzdE9uY2UgPSB0cnVlO1xuICAgIHJldHVybiBtZXJnZWRQcm9wcztcbiAgfVxuICBmdW5jdGlvbiBoYW5kbGVOZXdQcm9wc0FuZE5ld1N0YXRlKCkge1xuICAgIHN0YXRlUHJvcHMgPSBtYXBTdGF0ZVRvUHJvcHMoc3RhdGUsIG93blByb3BzKTtcbiAgICBpZiAobWFwRGlzcGF0Y2hUb1Byb3BzLmRlcGVuZHNPbk93blByb3BzKVxuICAgICAgZGlzcGF0Y2hQcm9wcyA9IG1hcERpc3BhdGNoVG9Qcm9wcyhkaXNwYXRjaCwgb3duUHJvcHMpO1xuICAgIG1lcmdlZFByb3BzID0gbWVyZ2VQcm9wcyhzdGF0ZVByb3BzLCBkaXNwYXRjaFByb3BzLCBvd25Qcm9wcyk7XG4gICAgcmV0dXJuIG1lcmdlZFByb3BzO1xuICB9XG4gIGZ1bmN0aW9uIGhhbmRsZU5ld1Byb3BzKCkge1xuICAgIGlmIChtYXBTdGF0ZVRvUHJvcHMuZGVwZW5kc09uT3duUHJvcHMpXG4gICAgICBzdGF0ZVByb3BzID0gbWFwU3RhdGVUb1Byb3BzKHN0YXRlLCBvd25Qcm9wcyk7XG4gICAgaWYgKG1hcERpc3BhdGNoVG9Qcm9wcy5kZXBlbmRzT25Pd25Qcm9wcylcbiAgICAgIGRpc3BhdGNoUHJvcHMgPSBtYXBEaXNwYXRjaFRvUHJvcHMoZGlzcGF0Y2gsIG93blByb3BzKTtcbiAgICBtZXJnZWRQcm9wcyA9IG1lcmdlUHJvcHMoc3RhdGVQcm9wcywgZGlzcGF0Y2hQcm9wcywgb3duUHJvcHMpO1xuICAgIHJldHVybiBtZXJnZWRQcm9wcztcbiAgfVxuICBmdW5jdGlvbiBoYW5kbGVOZXdTdGF0ZSgpIHtcbiAgICBjb25zdCBuZXh0U3RhdGVQcm9wcyA9IG1hcFN0YXRlVG9Qcm9wcyhzdGF0ZSwgb3duUHJvcHMpO1xuICAgIGNvbnN0IHN0YXRlUHJvcHNDaGFuZ2VkID0gIWFyZVN0YXRlUHJvcHNFcXVhbChuZXh0U3RhdGVQcm9wcywgc3RhdGVQcm9wcyk7XG4gICAgc3RhdGVQcm9wcyA9IG5leHRTdGF0ZVByb3BzO1xuICAgIGlmIChzdGF0ZVByb3BzQ2hhbmdlZClcbiAgICAgIG1lcmdlZFByb3BzID0gbWVyZ2VQcm9wcyhzdGF0ZVByb3BzLCBkaXNwYXRjaFByb3BzLCBvd25Qcm9wcyk7XG4gICAgcmV0dXJuIG1lcmdlZFByb3BzO1xuICB9XG4gIGZ1bmN0aW9uIGhhbmRsZVN1YnNlcXVlbnRDYWxscyhuZXh0U3RhdGUsIG5leHRPd25Qcm9wcykge1xuICAgIGNvbnN0IHByb3BzQ2hhbmdlZCA9ICFhcmVPd25Qcm9wc0VxdWFsKG5leHRPd25Qcm9wcywgb3duUHJvcHMpO1xuICAgIGNvbnN0IHN0YXRlQ2hhbmdlZCA9ICFhcmVTdGF0ZXNFcXVhbChcbiAgICAgIG5leHRTdGF0ZSxcbiAgICAgIHN0YXRlLFxuICAgICAgbmV4dE93blByb3BzLFxuICAgICAgb3duUHJvcHNcbiAgICApO1xuICAgIHN0YXRlID0gbmV4dFN0YXRlO1xuICAgIG93blByb3BzID0gbmV4dE93blByb3BzO1xuICAgIGlmIChwcm9wc0NoYW5nZWQgJiYgc3RhdGVDaGFuZ2VkKVxuICAgICAgcmV0dXJuIGhhbmRsZU5ld1Byb3BzQW5kTmV3U3RhdGUoKTtcbiAgICBpZiAocHJvcHNDaGFuZ2VkKVxuICAgICAgcmV0dXJuIGhhbmRsZU5ld1Byb3BzKCk7XG4gICAgaWYgKHN0YXRlQ2hhbmdlZClcbiAgICAgIHJldHVybiBoYW5kbGVOZXdTdGF0ZSgpO1xuICAgIHJldHVybiBtZXJnZWRQcm9wcztcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24gcHVyZUZpbmFsUHJvcHNTZWxlY3RvcihuZXh0U3RhdGUsIG5leHRPd25Qcm9wcykge1xuICAgIHJldHVybiBoYXNSdW5BdExlYXN0T25jZSA/IGhhbmRsZVN1YnNlcXVlbnRDYWxscyhuZXh0U3RhdGUsIG5leHRPd25Qcm9wcykgOiBoYW5kbGVGaXJzdENhbGwobmV4dFN0YXRlLCBuZXh0T3duUHJvcHMpO1xuICB9O1xufVxuZnVuY3Rpb24gZmluYWxQcm9wc1NlbGVjdG9yRmFjdG9yeShkaXNwYXRjaCwge1xuICBpbml0TWFwU3RhdGVUb1Byb3BzLFxuICBpbml0TWFwRGlzcGF0Y2hUb1Byb3BzLFxuICBpbml0TWVyZ2VQcm9wcyxcbiAgLi4ub3B0aW9uc1xufSkge1xuICBjb25zdCBtYXBTdGF0ZVRvUHJvcHMgPSBpbml0TWFwU3RhdGVUb1Byb3BzKGRpc3BhdGNoLCBvcHRpb25zKTtcbiAgY29uc3QgbWFwRGlzcGF0Y2hUb1Byb3BzID0gaW5pdE1hcERpc3BhdGNoVG9Qcm9wcyhkaXNwYXRjaCwgb3B0aW9ucyk7XG4gIGNvbnN0IG1lcmdlUHJvcHMgPSBpbml0TWVyZ2VQcm9wcyhkaXNwYXRjaCwgb3B0aW9ucyk7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICB2ZXJpZnlTdWJzZWxlY3RvcnMobWFwU3RhdGVUb1Byb3BzLCBtYXBEaXNwYXRjaFRvUHJvcHMsIG1lcmdlUHJvcHMpO1xuICB9XG4gIHJldHVybiBwdXJlRmluYWxQcm9wc1NlbGVjdG9yRmFjdG9yeShtYXBTdGF0ZVRvUHJvcHMsIG1hcERpc3BhdGNoVG9Qcm9wcywgbWVyZ2VQcm9wcywgZGlzcGF0Y2gsIG9wdGlvbnMpO1xufVxuXG4vLyBzcmMvdXRpbHMvYmluZEFjdGlvbkNyZWF0b3JzLnRzXG5mdW5jdGlvbiBiaW5kQWN0aW9uQ3JlYXRvcnMoYWN0aW9uQ3JlYXRvcnMsIGRpc3BhdGNoKSB7XG4gIGNvbnN0IGJvdW5kQWN0aW9uQ3JlYXRvcnMgPSB7fTtcbiAgZm9yIChjb25zdCBrZXkgaW4gYWN0aW9uQ3JlYXRvcnMpIHtcbiAgICBjb25zdCBhY3Rpb25DcmVhdG9yID0gYWN0aW9uQ3JlYXRvcnNba2V5XTtcbiAgICBpZiAodHlwZW9mIGFjdGlvbkNyZWF0b3IgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgYm91bmRBY3Rpb25DcmVhdG9yc1trZXldID0gKC4uLmFyZ3MpID0+IGRpc3BhdGNoKGFjdGlvbkNyZWF0b3IoLi4uYXJncykpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYm91bmRBY3Rpb25DcmVhdG9ycztcbn1cblxuLy8gc3JjL3V0aWxzL2lzUGxhaW5PYmplY3QudHNcbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3Qob2JqKSB7XG4gIGlmICh0eXBlb2Ygb2JqICE9PSBcIm9iamVjdFwiIHx8IG9iaiA9PT0gbnVsbClcbiAgICByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iaik7XG4gIGlmIChwcm90byA9PT0gbnVsbClcbiAgICByZXR1cm4gdHJ1ZTtcbiAgbGV0IGJhc2VQcm90byA9IHByb3RvO1xuICB3aGlsZSAoT2JqZWN0LmdldFByb3RvdHlwZU9mKGJhc2VQcm90bykgIT09IG51bGwpIHtcbiAgICBiYXNlUHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoYmFzZVByb3RvKTtcbiAgfVxuICByZXR1cm4gcHJvdG8gPT09IGJhc2VQcm90bztcbn1cblxuLy8gc3JjL3V0aWxzL3ZlcmlmeVBsYWluT2JqZWN0LnRzXG5mdW5jdGlvbiB2ZXJpZnlQbGFpbk9iamVjdCh2YWx1ZSwgZGlzcGxheU5hbWUsIG1ldGhvZE5hbWUpIHtcbiAgaWYgKCFpc1BsYWluT2JqZWN0KHZhbHVlKSkge1xuICAgIHdhcm5pbmcoXG4gICAgICBgJHttZXRob2ROYW1lfSgpIGluICR7ZGlzcGxheU5hbWV9IG11c3QgcmV0dXJuIGEgcGxhaW4gb2JqZWN0LiBJbnN0ZWFkIHJlY2VpdmVkICR7dmFsdWV9LmBcbiAgICApO1xuICB9XG59XG5cbi8vIHNyYy9jb25uZWN0L3dyYXBNYXBUb1Byb3BzLnRzXG5mdW5jdGlvbiB3cmFwTWFwVG9Qcm9wc0NvbnN0YW50KGdldENvbnN0YW50KSB7XG4gIHJldHVybiBmdW5jdGlvbiBpbml0Q29uc3RhbnRTZWxlY3RvcihkaXNwYXRjaCkge1xuICAgIGNvbnN0IGNvbnN0YW50ID0gZ2V0Q29uc3RhbnQoZGlzcGF0Y2gpO1xuICAgIGZ1bmN0aW9uIGNvbnN0YW50U2VsZWN0b3IoKSB7XG4gICAgICByZXR1cm4gY29uc3RhbnQ7XG4gICAgfVxuICAgIGNvbnN0YW50U2VsZWN0b3IuZGVwZW5kc09uT3duUHJvcHMgPSBmYWxzZTtcbiAgICByZXR1cm4gY29uc3RhbnRTZWxlY3RvcjtcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldERlcGVuZHNPbk93blByb3BzKG1hcFRvUHJvcHMpIHtcbiAgcmV0dXJuIG1hcFRvUHJvcHMuZGVwZW5kc09uT3duUHJvcHMgPyBCb29sZWFuKG1hcFRvUHJvcHMuZGVwZW5kc09uT3duUHJvcHMpIDogbWFwVG9Qcm9wcy5sZW5ndGggIT09IDE7XG59XG5mdW5jdGlvbiB3cmFwTWFwVG9Qcm9wc0Z1bmMobWFwVG9Qcm9wcywgbWV0aG9kTmFtZSkge1xuICByZXR1cm4gZnVuY3Rpb24gaW5pdFByb3h5U2VsZWN0b3IoZGlzcGF0Y2gsIHsgZGlzcGxheU5hbWUgfSkge1xuICAgIGNvbnN0IHByb3h5ID0gZnVuY3Rpb24gbWFwVG9Qcm9wc1Byb3h5KHN0YXRlT3JEaXNwYXRjaCwgb3duUHJvcHMpIHtcbiAgICAgIHJldHVybiBwcm94eS5kZXBlbmRzT25Pd25Qcm9wcyA/IHByb3h5Lm1hcFRvUHJvcHMoc3RhdGVPckRpc3BhdGNoLCBvd25Qcm9wcykgOiBwcm94eS5tYXBUb1Byb3BzKHN0YXRlT3JEaXNwYXRjaCwgdm9pZCAwKTtcbiAgICB9O1xuICAgIHByb3h5LmRlcGVuZHNPbk93blByb3BzID0gdHJ1ZTtcbiAgICBwcm94eS5tYXBUb1Byb3BzID0gZnVuY3Rpb24gZGV0ZWN0RmFjdG9yeUFuZFZlcmlmeShzdGF0ZU9yRGlzcGF0Y2gsIG93blByb3BzKSB7XG4gICAgICBwcm94eS5tYXBUb1Byb3BzID0gbWFwVG9Qcm9wcztcbiAgICAgIHByb3h5LmRlcGVuZHNPbk93blByb3BzID0gZ2V0RGVwZW5kc09uT3duUHJvcHMobWFwVG9Qcm9wcyk7XG4gICAgICBsZXQgcHJvcHMgPSBwcm94eShzdGF0ZU9yRGlzcGF0Y2gsIG93blByb3BzKTtcbiAgICAgIGlmICh0eXBlb2YgcHJvcHMgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBwcm94eS5tYXBUb1Byb3BzID0gcHJvcHM7XG4gICAgICAgIHByb3h5LmRlcGVuZHNPbk93blByb3BzID0gZ2V0RGVwZW5kc09uT3duUHJvcHMocHJvcHMpO1xuICAgICAgICBwcm9wcyA9IHByb3h5KHN0YXRlT3JEaXNwYXRjaCwgb3duUHJvcHMpO1xuICAgICAgfVxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIilcbiAgICAgICAgdmVyaWZ5UGxhaW5PYmplY3QocHJvcHMsIGRpc3BsYXlOYW1lLCBtZXRob2ROYW1lKTtcbiAgICAgIHJldHVybiBwcm9wcztcbiAgICB9O1xuICAgIHJldHVybiBwcm94eTtcbiAgfTtcbn1cblxuLy8gc3JjL2Nvbm5lY3QvaW52YWxpZEFyZ0ZhY3RvcnkudHNcbmZ1bmN0aW9uIGNyZWF0ZUludmFsaWRBcmdGYWN0b3J5KGFyZywgbmFtZSkge1xuICByZXR1cm4gKGRpc3BhdGNoLCBvcHRpb25zKSA9PiB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYEludmFsaWQgdmFsdWUgb2YgdHlwZSAke3R5cGVvZiBhcmd9IGZvciAke25hbWV9IGFyZ3VtZW50IHdoZW4gY29ubmVjdGluZyBjb21wb25lbnQgJHtvcHRpb25zLndyYXBwZWRDb21wb25lbnROYW1lfS5gXG4gICAgKTtcbiAgfTtcbn1cblxuLy8gc3JjL2Nvbm5lY3QvbWFwRGlzcGF0Y2hUb1Byb3BzLnRzXG5mdW5jdGlvbiBtYXBEaXNwYXRjaFRvUHJvcHNGYWN0b3J5KG1hcERpc3BhdGNoVG9Qcm9wcykge1xuICByZXR1cm4gbWFwRGlzcGF0Y2hUb1Byb3BzICYmIHR5cGVvZiBtYXBEaXNwYXRjaFRvUHJvcHMgPT09IFwib2JqZWN0XCIgPyB3cmFwTWFwVG9Qcm9wc0NvbnN0YW50KFxuICAgIChkaXNwYXRjaCkgPT4gKFxuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgYmluZEFjdGlvbkNyZWF0b3JzKG1hcERpc3BhdGNoVG9Qcm9wcywgZGlzcGF0Y2gpXG4gICAgKVxuICApIDogIW1hcERpc3BhdGNoVG9Qcm9wcyA/IHdyYXBNYXBUb1Byb3BzQ29uc3RhbnQoKGRpc3BhdGNoKSA9PiAoe1xuICAgIGRpc3BhdGNoXG4gIH0pKSA6IHR5cGVvZiBtYXBEaXNwYXRjaFRvUHJvcHMgPT09IFwiZnVuY3Rpb25cIiA/IChcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgd3JhcE1hcFRvUHJvcHNGdW5jKG1hcERpc3BhdGNoVG9Qcm9wcywgXCJtYXBEaXNwYXRjaFRvUHJvcHNcIilcbiAgKSA6IGNyZWF0ZUludmFsaWRBcmdGYWN0b3J5KG1hcERpc3BhdGNoVG9Qcm9wcywgXCJtYXBEaXNwYXRjaFRvUHJvcHNcIik7XG59XG5cbi8vIHNyYy9jb25uZWN0L21hcFN0YXRlVG9Qcm9wcy50c1xuZnVuY3Rpb24gbWFwU3RhdGVUb1Byb3BzRmFjdG9yeShtYXBTdGF0ZVRvUHJvcHMpIHtcbiAgcmV0dXJuICFtYXBTdGF0ZVRvUHJvcHMgPyB3cmFwTWFwVG9Qcm9wc0NvbnN0YW50KCgpID0+ICh7fSkpIDogdHlwZW9mIG1hcFN0YXRlVG9Qcm9wcyA9PT0gXCJmdW5jdGlvblwiID8gKFxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICB3cmFwTWFwVG9Qcm9wc0Z1bmMobWFwU3RhdGVUb1Byb3BzLCBcIm1hcFN0YXRlVG9Qcm9wc1wiKVxuICApIDogY3JlYXRlSW52YWxpZEFyZ0ZhY3RvcnkobWFwU3RhdGVUb1Byb3BzLCBcIm1hcFN0YXRlVG9Qcm9wc1wiKTtcbn1cblxuLy8gc3JjL2Nvbm5lY3QvbWVyZ2VQcm9wcy50c1xuZnVuY3Rpb24gZGVmYXVsdE1lcmdlUHJvcHMoc3RhdGVQcm9wcywgZGlzcGF0Y2hQcm9wcywgb3duUHJvcHMpIHtcbiAgcmV0dXJuIHsgLi4ub3duUHJvcHMsIC4uLnN0YXRlUHJvcHMsIC4uLmRpc3BhdGNoUHJvcHMgfTtcbn1cbmZ1bmN0aW9uIHdyYXBNZXJnZVByb3BzRnVuYyhtZXJnZVByb3BzKSB7XG4gIHJldHVybiBmdW5jdGlvbiBpbml0TWVyZ2VQcm9wc1Byb3h5KGRpc3BhdGNoLCB7IGRpc3BsYXlOYW1lLCBhcmVNZXJnZWRQcm9wc0VxdWFsIH0pIHtcbiAgICBsZXQgaGFzUnVuT25jZSA9IGZhbHNlO1xuICAgIGxldCBtZXJnZWRQcm9wcztcbiAgICByZXR1cm4gZnVuY3Rpb24gbWVyZ2VQcm9wc1Byb3h5KHN0YXRlUHJvcHMsIGRpc3BhdGNoUHJvcHMsIG93blByb3BzKSB7XG4gICAgICBjb25zdCBuZXh0TWVyZ2VkUHJvcHMgPSBtZXJnZVByb3BzKHN0YXRlUHJvcHMsIGRpc3BhdGNoUHJvcHMsIG93blByb3BzKTtcbiAgICAgIGlmIChoYXNSdW5PbmNlKSB7XG4gICAgICAgIGlmICghYXJlTWVyZ2VkUHJvcHNFcXVhbChuZXh0TWVyZ2VkUHJvcHMsIG1lcmdlZFByb3BzKSlcbiAgICAgICAgICBtZXJnZWRQcm9wcyA9IG5leHRNZXJnZWRQcm9wcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGhhc1J1bk9uY2UgPSB0cnVlO1xuICAgICAgICBtZXJnZWRQcm9wcyA9IG5leHRNZXJnZWRQcm9wcztcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIilcbiAgICAgICAgICB2ZXJpZnlQbGFpbk9iamVjdChtZXJnZWRQcm9wcywgZGlzcGxheU5hbWUsIFwibWVyZ2VQcm9wc1wiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtZXJnZWRQcm9wcztcbiAgICB9O1xuICB9O1xufVxuZnVuY3Rpb24gbWVyZ2VQcm9wc0ZhY3RvcnkobWVyZ2VQcm9wcykge1xuICByZXR1cm4gIW1lcmdlUHJvcHMgPyAoKSA9PiBkZWZhdWx0TWVyZ2VQcm9wcyA6IHR5cGVvZiBtZXJnZVByb3BzID09PSBcImZ1bmN0aW9uXCIgPyB3cmFwTWVyZ2VQcm9wc0Z1bmMobWVyZ2VQcm9wcykgOiBjcmVhdGVJbnZhbGlkQXJnRmFjdG9yeShtZXJnZVByb3BzLCBcIm1lcmdlUHJvcHNcIik7XG59XG5cbi8vIHNyYy91dGlscy9iYXRjaC50c1xuZnVuY3Rpb24gZGVmYXVsdE5vb3BCYXRjaChjYWxsYmFjaykge1xuICBjYWxsYmFjaygpO1xufVxuXG4vLyBzcmMvdXRpbHMvU3Vic2NyaXB0aW9uLnRzXG5mdW5jdGlvbiBjcmVhdGVMaXN0ZW5lckNvbGxlY3Rpb24oKSB7XG4gIGxldCBmaXJzdCA9IG51bGw7XG4gIGxldCBsYXN0ID0gbnVsbDtcbiAgcmV0dXJuIHtcbiAgICBjbGVhcigpIHtcbiAgICAgIGZpcnN0ID0gbnVsbDtcbiAgICAgIGxhc3QgPSBudWxsO1xuICAgIH0sXG4gICAgbm90aWZ5KCkge1xuICAgICAgZGVmYXVsdE5vb3BCYXRjaCgoKSA9PiB7XG4gICAgICAgIGxldCBsaXN0ZW5lciA9IGZpcnN0O1xuICAgICAgICB3aGlsZSAobGlzdGVuZXIpIHtcbiAgICAgICAgICBsaXN0ZW5lci5jYWxsYmFjaygpO1xuICAgICAgICAgIGxpc3RlbmVyID0gbGlzdGVuZXIubmV4dDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSxcbiAgICBnZXQoKSB7XG4gICAgICBjb25zdCBsaXN0ZW5lcnMgPSBbXTtcbiAgICAgIGxldCBsaXN0ZW5lciA9IGZpcnN0O1xuICAgICAgd2hpbGUgKGxpc3RlbmVyKSB7XG4gICAgICAgIGxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICAgICAgbGlzdGVuZXIgPSBsaXN0ZW5lci5uZXh0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxpc3RlbmVycztcbiAgICB9LFxuICAgIHN1YnNjcmliZShjYWxsYmFjaykge1xuICAgICAgbGV0IGlzU3Vic2NyaWJlZCA9IHRydWU7XG4gICAgICBjb25zdCBsaXN0ZW5lciA9IGxhc3QgPSB7XG4gICAgICAgIGNhbGxiYWNrLFxuICAgICAgICBuZXh0OiBudWxsLFxuICAgICAgICBwcmV2OiBsYXN0XG4gICAgICB9O1xuICAgICAgaWYgKGxpc3RlbmVyLnByZXYpIHtcbiAgICAgICAgbGlzdGVuZXIucHJldi5uZXh0ID0gbGlzdGVuZXI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmaXJzdCA9IGxpc3RlbmVyO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIHVuc3Vic2NyaWJlKCkge1xuICAgICAgICBpZiAoIWlzU3Vic2NyaWJlZCB8fCBmaXJzdCA9PT0gbnVsbClcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlzU3Vic2NyaWJlZCA9IGZhbHNlO1xuICAgICAgICBpZiAobGlzdGVuZXIubmV4dCkge1xuICAgICAgICAgIGxpc3RlbmVyLm5leHQucHJldiA9IGxpc3RlbmVyLnByZXY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGFzdCA9IGxpc3RlbmVyLnByZXY7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxpc3RlbmVyLnByZXYpIHtcbiAgICAgICAgICBsaXN0ZW5lci5wcmV2Lm5leHQgPSBsaXN0ZW5lci5uZXh0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZpcnN0ID0gbGlzdGVuZXIubmV4dDtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH07XG59XG52YXIgbnVsbExpc3RlbmVycyA9IHtcbiAgbm90aWZ5KCkge1xuICB9LFxuICBnZXQ6ICgpID0+IFtdXG59O1xuZnVuY3Rpb24gY3JlYXRlU3Vic2NyaXB0aW9uKHN0b3JlLCBwYXJlbnRTdWIpIHtcbiAgbGV0IHVuc3Vic2NyaWJlO1xuICBsZXQgbGlzdGVuZXJzID0gbnVsbExpc3RlbmVycztcbiAgbGV0IHN1YnNjcmlwdGlvbnNBbW91bnQgPSAwO1xuICBsZXQgc2VsZlN1YnNjcmliZWQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gYWRkTmVzdGVkU3ViKGxpc3RlbmVyKSB7XG4gICAgdHJ5U3Vic2NyaWJlKCk7XG4gICAgY29uc3QgY2xlYW51cExpc3RlbmVyID0gbGlzdGVuZXJzLnN1YnNjcmliZShsaXN0ZW5lcik7XG4gICAgbGV0IHJlbW92ZWQgPSBmYWxzZTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgaWYgKCFyZW1vdmVkKSB7XG4gICAgICAgIHJlbW92ZWQgPSB0cnVlO1xuICAgICAgICBjbGVhbnVwTGlzdGVuZXIoKTtcbiAgICAgICAgdHJ5VW5zdWJzY3JpYmUoKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIG5vdGlmeU5lc3RlZFN1YnMoKSB7XG4gICAgbGlzdGVuZXJzLm5vdGlmeSgpO1xuICB9XG4gIGZ1bmN0aW9uIGhhbmRsZUNoYW5nZVdyYXBwZXIoKSB7XG4gICAgaWYgKHN1YnNjcmlwdGlvbi5vblN0YXRlQ2hhbmdlKSB7XG4gICAgICBzdWJzY3JpcHRpb24ub25TdGF0ZUNoYW5nZSgpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBpc1N1YnNjcmliZWQoKSB7XG4gICAgcmV0dXJuIHNlbGZTdWJzY3JpYmVkO1xuICB9XG4gIGZ1bmN0aW9uIHRyeVN1YnNjcmliZSgpIHtcbiAgICBzdWJzY3JpcHRpb25zQW1vdW50Kys7XG4gICAgaWYgKCF1bnN1YnNjcmliZSkge1xuICAgICAgdW5zdWJzY3JpYmUgPSBwYXJlbnRTdWIgPyBwYXJlbnRTdWIuYWRkTmVzdGVkU3ViKGhhbmRsZUNoYW5nZVdyYXBwZXIpIDogc3RvcmUuc3Vic2NyaWJlKGhhbmRsZUNoYW5nZVdyYXBwZXIpO1xuICAgICAgbGlzdGVuZXJzID0gY3JlYXRlTGlzdGVuZXJDb2xsZWN0aW9uKCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHRyeVVuc3Vic2NyaWJlKCkge1xuICAgIHN1YnNjcmlwdGlvbnNBbW91bnQtLTtcbiAgICBpZiAodW5zdWJzY3JpYmUgJiYgc3Vic2NyaXB0aW9uc0Ftb3VudCA9PT0gMCkge1xuICAgICAgdW5zdWJzY3JpYmUoKTtcbiAgICAgIHVuc3Vic2NyaWJlID0gdm9pZCAwO1xuICAgICAgbGlzdGVuZXJzLmNsZWFyKCk7XG4gICAgICBsaXN0ZW5lcnMgPSBudWxsTGlzdGVuZXJzO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiB0cnlTdWJzY3JpYmVTZWxmKCkge1xuICAgIGlmICghc2VsZlN1YnNjcmliZWQpIHtcbiAgICAgIHNlbGZTdWJzY3JpYmVkID0gdHJ1ZTtcbiAgICAgIHRyeVN1YnNjcmliZSgpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiB0cnlVbnN1YnNjcmliZVNlbGYoKSB7XG4gICAgaWYgKHNlbGZTdWJzY3JpYmVkKSB7XG4gICAgICBzZWxmU3Vic2NyaWJlZCA9IGZhbHNlO1xuICAgICAgdHJ5VW5zdWJzY3JpYmUoKTtcbiAgICB9XG4gIH1cbiAgY29uc3Qgc3Vic2NyaXB0aW9uID0ge1xuICAgIGFkZE5lc3RlZFN1YixcbiAgICBub3RpZnlOZXN0ZWRTdWJzLFxuICAgIGhhbmRsZUNoYW5nZVdyYXBwZXIsXG4gICAgaXNTdWJzY3JpYmVkLFxuICAgIHRyeVN1YnNjcmliZTogdHJ5U3Vic2NyaWJlU2VsZixcbiAgICB0cnlVbnN1YnNjcmliZTogdHJ5VW5zdWJzY3JpYmVTZWxmLFxuICAgIGdldExpc3RlbmVyczogKCkgPT4gbGlzdGVuZXJzXG4gIH07XG4gIHJldHVybiBzdWJzY3JpcHRpb247XG59XG5cbi8vIHNyYy91dGlscy91c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0LnRzXG52YXIgY2FuVXNlRE9NID0gISEodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2Ygd2luZG93LmRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCAhPT0gXCJ1bmRlZmluZWRcIik7XG52YXIgaXNSZWFjdE5hdGl2ZSA9IHR5cGVvZiBuYXZpZ2F0b3IgIT09IFwidW5kZWZpbmVkXCIgJiYgbmF2aWdhdG9yLnByb2R1Y3QgPT09IFwiUmVhY3ROYXRpdmVcIjtcbnZhciB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0ID0gY2FuVXNlRE9NIHx8IGlzUmVhY3ROYXRpdmUgPyBSZWFjdC51c2VMYXlvdXRFZmZlY3QgOiBSZWFjdC51c2VFZmZlY3Q7XG5cbi8vIHNyYy91dGlscy9zaGFsbG93RXF1YWwudHNcbmZ1bmN0aW9uIGlzKHgsIHkpIHtcbiAgaWYgKHggPT09IHkpIHtcbiAgICByZXR1cm4geCAhPT0gMCB8fCB5ICE9PSAwIHx8IDEgLyB4ID09PSAxIC8geTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4geCAhPT0geCAmJiB5ICE9PSB5O1xuICB9XG59XG5mdW5jdGlvbiBzaGFsbG93RXF1YWwob2JqQSwgb2JqQikge1xuICBpZiAoaXMob2JqQSwgb2JqQikpXG4gICAgcmV0dXJuIHRydWU7XG4gIGlmICh0eXBlb2Ygb2JqQSAhPT0gXCJvYmplY3RcIiB8fCBvYmpBID09PSBudWxsIHx8IHR5cGVvZiBvYmpCICE9PSBcIm9iamVjdFwiIHx8IG9iakIgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3Qga2V5c0EgPSBPYmplY3Qua2V5cyhvYmpBKTtcbiAgY29uc3Qga2V5c0IgPSBPYmplY3Qua2V5cyhvYmpCKTtcbiAgaWYgKGtleXNBLmxlbmd0aCAhPT0ga2V5c0IubGVuZ3RoKVxuICAgIHJldHVybiBmYWxzZTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzQS5sZW5ndGg7IGkrKykge1xuICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iakIsIGtleXNBW2ldKSB8fCAhaXMob2JqQVtrZXlzQVtpXV0sIG9iakJba2V5c0FbaV1dKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLy8gc3JjL3V0aWxzL2hvaXN0U3RhdGljcy50c1xudmFyIFJFQUNUX1NUQVRJQ1MgPSB7XG4gIGNoaWxkQ29udGV4dFR5cGVzOiB0cnVlLFxuICBjb250ZXh0VHlwZTogdHJ1ZSxcbiAgY29udGV4dFR5cGVzOiB0cnVlLFxuICBkZWZhdWx0UHJvcHM6IHRydWUsXG4gIGRpc3BsYXlOYW1lOiB0cnVlLFxuICBnZXREZWZhdWx0UHJvcHM6IHRydWUsXG4gIGdldERlcml2ZWRTdGF0ZUZyb21FcnJvcjogdHJ1ZSxcbiAgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzOiB0cnVlLFxuICBtaXhpbnM6IHRydWUsXG4gIHByb3BUeXBlczogdHJ1ZSxcbiAgdHlwZTogdHJ1ZVxufTtcbnZhciBLTk9XTl9TVEFUSUNTID0ge1xuICBuYW1lOiB0cnVlLFxuICBsZW5ndGg6IHRydWUsXG4gIHByb3RvdHlwZTogdHJ1ZSxcbiAgY2FsbGVyOiB0cnVlLFxuICBjYWxsZWU6IHRydWUsXG4gIGFyZ3VtZW50czogdHJ1ZSxcbiAgYXJpdHk6IHRydWVcbn07XG52YXIgRk9SV0FSRF9SRUZfU1RBVElDUyA9IHtcbiAgJCR0eXBlb2Y6IHRydWUsXG4gIHJlbmRlcjogdHJ1ZSxcbiAgZGVmYXVsdFByb3BzOiB0cnVlLFxuICBkaXNwbGF5TmFtZTogdHJ1ZSxcbiAgcHJvcFR5cGVzOiB0cnVlXG59O1xudmFyIE1FTU9fU1RBVElDUyA9IHtcbiAgJCR0eXBlb2Y6IHRydWUsXG4gIGNvbXBhcmU6IHRydWUsXG4gIGRlZmF1bHRQcm9wczogdHJ1ZSxcbiAgZGlzcGxheU5hbWU6IHRydWUsXG4gIHByb3BUeXBlczogdHJ1ZSxcbiAgdHlwZTogdHJ1ZVxufTtcbnZhciBUWVBFX1NUQVRJQ1MgPSB7XG4gIFtGb3J3YXJkUmVmXTogRk9SV0FSRF9SRUZfU1RBVElDUyxcbiAgW01lbW9dOiBNRU1PX1NUQVRJQ1Ncbn07XG5mdW5jdGlvbiBnZXRTdGF0aWNzKGNvbXBvbmVudCkge1xuICBpZiAoaXNNZW1vKGNvbXBvbmVudCkpIHtcbiAgICByZXR1cm4gTUVNT19TVEFUSUNTO1xuICB9XG4gIHJldHVybiBUWVBFX1NUQVRJQ1NbY29tcG9uZW50W1wiJCR0eXBlb2ZcIl1dIHx8IFJFQUNUX1NUQVRJQ1M7XG59XG52YXIgZGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgZ2V0T3duUHJvcGVydHlOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIGdldE93blByb3BlcnR5U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBnZXRQcm90b3R5cGVPZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbnZhciBvYmplY3RQcm90b3R5cGUgPSBPYmplY3QucHJvdG90eXBlO1xuZnVuY3Rpb24gaG9pc3ROb25SZWFjdFN0YXRpY3ModGFyZ2V0Q29tcG9uZW50LCBzb3VyY2VDb21wb25lbnQpIHtcbiAgaWYgKHR5cGVvZiBzb3VyY2VDb21wb25lbnQgIT09IFwic3RyaW5nXCIpIHtcbiAgICBpZiAob2JqZWN0UHJvdG90eXBlKSB7XG4gICAgICBjb25zdCBpbmhlcml0ZWRDb21wb25lbnQgPSBnZXRQcm90b3R5cGVPZihzb3VyY2VDb21wb25lbnQpO1xuICAgICAgaWYgKGluaGVyaXRlZENvbXBvbmVudCAmJiBpbmhlcml0ZWRDb21wb25lbnQgIT09IG9iamVjdFByb3RvdHlwZSkge1xuICAgICAgICBob2lzdE5vblJlYWN0U3RhdGljcyh0YXJnZXRDb21wb25lbnQsIGluaGVyaXRlZENvbXBvbmVudCk7XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBrZXlzID0gZ2V0T3duUHJvcGVydHlOYW1lcyhzb3VyY2VDb21wb25lbnQpO1xuICAgIGlmIChnZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICAgIGtleXMgPSBrZXlzLmNvbmNhdChnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlQ29tcG9uZW50KSk7XG4gICAgfVxuICAgIGNvbnN0IHRhcmdldFN0YXRpY3MgPSBnZXRTdGF0aWNzKHRhcmdldENvbXBvbmVudCk7XG4gICAgY29uc3Qgc291cmNlU3RhdGljcyA9IGdldFN0YXRpY3Moc291cmNlQ29tcG9uZW50KTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGNvbnN0IGtleSA9IGtleXNbaV07XG4gICAgICBpZiAoIUtOT1dOX1NUQVRJQ1Nba2V5XSAmJiAhKHNvdXJjZVN0YXRpY3MgJiYgc291cmNlU3RhdGljc1trZXldKSAmJiAhKHRhcmdldFN0YXRpY3MgJiYgdGFyZ2V0U3RhdGljc1trZXldKSkge1xuICAgICAgICBjb25zdCBkZXNjcmlwdG9yID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZUNvbXBvbmVudCwga2V5KTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBkZWZpbmVQcm9wZXJ0eSh0YXJnZXRDb21wb25lbnQsIGtleSwgZGVzY3JpcHRvcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdGFyZ2V0Q29tcG9uZW50O1xufVxuXG4vLyBzcmMvY29tcG9uZW50cy9jb25uZWN0LnRzeFxudmFyIHVzZVN5bmNFeHRlcm5hbFN0b3JlID0gbm90SW5pdGlhbGl6ZWQ7XG52YXIgaW5pdGlhbGl6ZUNvbm5lY3QgPSAoZm4pID0+IHtcbiAgdXNlU3luY0V4dGVybmFsU3RvcmUgPSBmbjtcbn07XG52YXIgTk9fU1VCU0NSSVBUSU9OX0FSUkFZID0gW251bGwsIG51bGxdO1xudmFyIHN0cmluZ2lmeUNvbXBvbmVudCA9IChDb21wKSA9PiB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KENvbXApO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gU3RyaW5nKENvbXApO1xuICB9XG59O1xuZnVuY3Rpb24gdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdFdpdGhBcmdzKGVmZmVjdEZ1bmMsIGVmZmVjdEFyZ3MsIGRlcGVuZGVuY2llcykge1xuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IGVmZmVjdEZ1bmMoLi4uZWZmZWN0QXJncyksIGRlcGVuZGVuY2llcyk7XG59XG5mdW5jdGlvbiBjYXB0dXJlV3JhcHBlclByb3BzKGxhc3RXcmFwcGVyUHJvcHMsIGxhc3RDaGlsZFByb3BzLCByZW5kZXJJc1NjaGVkdWxlZCwgd3JhcHBlclByb3BzLCBjaGlsZFByb3BzRnJvbVN0b3JlVXBkYXRlLCBub3RpZnlOZXN0ZWRTdWJzKSB7XG4gIGxhc3RXcmFwcGVyUHJvcHMuY3VycmVudCA9IHdyYXBwZXJQcm9wcztcbiAgcmVuZGVySXNTY2hlZHVsZWQuY3VycmVudCA9IGZhbHNlO1xuICBpZiAoY2hpbGRQcm9wc0Zyb21TdG9yZVVwZGF0ZS5jdXJyZW50KSB7XG4gICAgY2hpbGRQcm9wc0Zyb21TdG9yZVVwZGF0ZS5jdXJyZW50ID0gbnVsbDtcbiAgICBub3RpZnlOZXN0ZWRTdWJzKCk7XG4gIH1cbn1cbmZ1bmN0aW9uIHN1YnNjcmliZVVwZGF0ZXMoc2hvdWxkSGFuZGxlU3RhdGVDaGFuZ2VzLCBzdG9yZSwgc3Vic2NyaXB0aW9uLCBjaGlsZFByb3BzU2VsZWN0b3IsIGxhc3RXcmFwcGVyUHJvcHMsIGxhc3RDaGlsZFByb3BzLCByZW5kZXJJc1NjaGVkdWxlZCwgaXNNb3VudGVkLCBjaGlsZFByb3BzRnJvbVN0b3JlVXBkYXRlLCBub3RpZnlOZXN0ZWRTdWJzLCBhZGRpdGlvbmFsU3Vic2NyaWJlTGlzdGVuZXIpIHtcbiAgaWYgKCFzaG91bGRIYW5kbGVTdGF0ZUNoYW5nZXMpXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICB9O1xuICBsZXQgZGlkVW5zdWJzY3JpYmUgPSBmYWxzZTtcbiAgbGV0IGxhc3RUaHJvd25FcnJvciA9IG51bGw7XG4gIGNvbnN0IGNoZWNrRm9yVXBkYXRlcyA9ICgpID0+IHtcbiAgICBpZiAoZGlkVW5zdWJzY3JpYmUgfHwgIWlzTW91bnRlZC5jdXJyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGxhdGVzdFN0b3JlU3RhdGUgPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgIGxldCBuZXdDaGlsZFByb3BzLCBlcnJvcjtcbiAgICB0cnkge1xuICAgICAgbmV3Q2hpbGRQcm9wcyA9IGNoaWxkUHJvcHNTZWxlY3RvcihcbiAgICAgICAgbGF0ZXN0U3RvcmVTdGF0ZSxcbiAgICAgICAgbGFzdFdyYXBwZXJQcm9wcy5jdXJyZW50XG4gICAgICApO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGVycm9yID0gZTtcbiAgICAgIGxhc3RUaHJvd25FcnJvciA9IGU7XG4gICAgfVxuICAgIGlmICghZXJyb3IpIHtcbiAgICAgIGxhc3RUaHJvd25FcnJvciA9IG51bGw7XG4gICAgfVxuICAgIGlmIChuZXdDaGlsZFByb3BzID09PSBsYXN0Q2hpbGRQcm9wcy5jdXJyZW50KSB7XG4gICAgICBpZiAoIXJlbmRlcklzU2NoZWR1bGVkLmN1cnJlbnQpIHtcbiAgICAgICAgbm90aWZ5TmVzdGVkU3VicygpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsYXN0Q2hpbGRQcm9wcy5jdXJyZW50ID0gbmV3Q2hpbGRQcm9wcztcbiAgICAgIGNoaWxkUHJvcHNGcm9tU3RvcmVVcGRhdGUuY3VycmVudCA9IG5ld0NoaWxkUHJvcHM7XG4gICAgICByZW5kZXJJc1NjaGVkdWxlZC5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgIGFkZGl0aW9uYWxTdWJzY3JpYmVMaXN0ZW5lcigpO1xuICAgIH1cbiAgfTtcbiAgc3Vic2NyaXB0aW9uLm9uU3RhdGVDaGFuZ2UgPSBjaGVja0ZvclVwZGF0ZXM7XG4gIHN1YnNjcmlwdGlvbi50cnlTdWJzY3JpYmUoKTtcbiAgY2hlY2tGb3JVcGRhdGVzKCk7XG4gIGNvbnN0IHVuc3Vic2NyaWJlV3JhcHBlciA9ICgpID0+IHtcbiAgICBkaWRVbnN1YnNjcmliZSA9IHRydWU7XG4gICAgc3Vic2NyaXB0aW9uLnRyeVVuc3Vic2NyaWJlKCk7XG4gICAgc3Vic2NyaXB0aW9uLm9uU3RhdGVDaGFuZ2UgPSBudWxsO1xuICAgIGlmIChsYXN0VGhyb3duRXJyb3IpIHtcbiAgICAgIHRocm93IGxhc3RUaHJvd25FcnJvcjtcbiAgICB9XG4gIH07XG4gIHJldHVybiB1bnN1YnNjcmliZVdyYXBwZXI7XG59XG5mdW5jdGlvbiBzdHJpY3RFcXVhbChhLCBiKSB7XG4gIHJldHVybiBhID09PSBiO1xufVxudmFyIGhhc1dhcm5lZEFib3V0RGVwcmVjYXRlZFB1cmVPcHRpb24gPSBmYWxzZTtcbmZ1bmN0aW9uIGNvbm5lY3QobWFwU3RhdGVUb1Byb3BzLCBtYXBEaXNwYXRjaFRvUHJvcHMsIG1lcmdlUHJvcHMsIHtcbiAgLy8gVGhlIGBwdXJlYCBvcHRpb24gaGFzIGJlZW4gcmVtb3ZlZCwgc28gVFMgZG9lc24ndCBsaWtlIHVzIGRlc3RydWN0dXJpbmcgdGhpcyB0byBjaGVjayBpdHMgZXhpc3RlbmNlLlxuICAvLyBAdHMtaWdub3JlXG4gIHB1cmUsXG4gIGFyZVN0YXRlc0VxdWFsID0gc3RyaWN0RXF1YWwsXG4gIGFyZU93blByb3BzRXF1YWwgPSBzaGFsbG93RXF1YWwsXG4gIGFyZVN0YXRlUHJvcHNFcXVhbCA9IHNoYWxsb3dFcXVhbCxcbiAgYXJlTWVyZ2VkUHJvcHNFcXVhbCA9IHNoYWxsb3dFcXVhbCxcbiAgLy8gdXNlIFJlYWN0J3MgZm9yd2FyZFJlZiB0byBleHBvc2UgYSByZWYgb2YgdGhlIHdyYXBwZWQgY29tcG9uZW50XG4gIGZvcndhcmRSZWYgPSBmYWxzZSxcbiAgLy8gdGhlIGNvbnRleHQgY29uc3VtZXIgdG8gdXNlXG4gIGNvbnRleHQgPSBSZWFjdFJlZHV4Q29udGV4dFxufSA9IHt9KSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBpZiAocHVyZSAhPT0gdm9pZCAwICYmICFoYXNXYXJuZWRBYm91dERlcHJlY2F0ZWRQdXJlT3B0aW9uKSB7XG4gICAgICBoYXNXYXJuZWRBYm91dERlcHJlY2F0ZWRQdXJlT3B0aW9uID0gdHJ1ZTtcbiAgICAgIHdhcm5pbmcoXG4gICAgICAgICdUaGUgYHB1cmVgIG9wdGlvbiBoYXMgYmVlbiByZW1vdmVkLiBgY29ubmVjdGAgaXMgbm93IGFsd2F5cyBhIFwicHVyZS9tZW1vaXplZFwiIGNvbXBvbmVudCdcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIGNvbnN0IENvbnRleHQgPSBjb250ZXh0O1xuICBjb25zdCBpbml0TWFwU3RhdGVUb1Byb3BzID0gbWFwU3RhdGVUb1Byb3BzRmFjdG9yeShtYXBTdGF0ZVRvUHJvcHMpO1xuICBjb25zdCBpbml0TWFwRGlzcGF0Y2hUb1Byb3BzID0gbWFwRGlzcGF0Y2hUb1Byb3BzRmFjdG9yeShtYXBEaXNwYXRjaFRvUHJvcHMpO1xuICBjb25zdCBpbml0TWVyZ2VQcm9wcyA9IG1lcmdlUHJvcHNGYWN0b3J5KG1lcmdlUHJvcHMpO1xuICBjb25zdCBzaG91bGRIYW5kbGVTdGF0ZUNoYW5nZXMgPSBCb29sZWFuKG1hcFN0YXRlVG9Qcm9wcyk7XG4gIGNvbnN0IHdyYXBXaXRoQ29ubmVjdCA9IChXcmFwcGVkQ29tcG9uZW50KSA9PiB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgY29uc3QgaXNWYWxpZCA9IC8qIEBfX1BVUkVfXyAqLyBpc1ZhbGlkRWxlbWVudFR5cGUoV3JhcHBlZENvbXBvbmVudCk7XG4gICAgICBpZiAoIWlzVmFsaWQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgWW91IG11c3QgcGFzcyBhIGNvbXBvbmVudCB0byB0aGUgZnVuY3Rpb24gcmV0dXJuZWQgYnkgY29ubmVjdC4gSW5zdGVhZCByZWNlaXZlZCAke3N0cmluZ2lmeUNvbXBvbmVudChcbiAgICAgICAgICAgIFdyYXBwZWRDb21wb25lbnRcbiAgICAgICAgICApfWBcbiAgICAgICAgKTtcbiAgICB9XG4gICAgY29uc3Qgd3JhcHBlZENvbXBvbmVudE5hbWUgPSBXcmFwcGVkQ29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IFdyYXBwZWRDb21wb25lbnQubmFtZSB8fCBcIkNvbXBvbmVudFwiO1xuICAgIGNvbnN0IGRpc3BsYXlOYW1lID0gYENvbm5lY3QoJHt3cmFwcGVkQ29tcG9uZW50TmFtZX0pYDtcbiAgICBjb25zdCBzZWxlY3RvckZhY3RvcnlPcHRpb25zID0ge1xuICAgICAgc2hvdWxkSGFuZGxlU3RhdGVDaGFuZ2VzLFxuICAgICAgZGlzcGxheU5hbWUsXG4gICAgICB3cmFwcGVkQ29tcG9uZW50TmFtZSxcbiAgICAgIFdyYXBwZWRDb21wb25lbnQsXG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICBpbml0TWFwU3RhdGVUb1Byb3BzLFxuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgaW5pdE1hcERpc3BhdGNoVG9Qcm9wcyxcbiAgICAgIGluaXRNZXJnZVByb3BzLFxuICAgICAgYXJlU3RhdGVzRXF1YWwsXG4gICAgICBhcmVTdGF0ZVByb3BzRXF1YWwsXG4gICAgICBhcmVPd25Qcm9wc0VxdWFsLFxuICAgICAgYXJlTWVyZ2VkUHJvcHNFcXVhbFxuICAgIH07XG4gICAgZnVuY3Rpb24gQ29ubmVjdEZ1bmN0aW9uKHByb3BzKSB7XG4gICAgICBjb25zdCBbcHJvcHNDb250ZXh0LCByZWFjdFJlZHV4Rm9yd2FyZGVkUmVmLCB3cmFwcGVyUHJvcHNdID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgcmVhY3RSZWR1eEZvcndhcmRlZFJlZjogcmVhY3RSZWR1eEZvcndhcmRlZFJlZjIsIC4uLndyYXBwZXJQcm9wczIgfSA9IHByb3BzO1xuICAgICAgICByZXR1cm4gW3Byb3BzLmNvbnRleHQsIHJlYWN0UmVkdXhGb3J3YXJkZWRSZWYyLCB3cmFwcGVyUHJvcHMyXTtcbiAgICAgIH0sIFtwcm9wc10pO1xuICAgICAgY29uc3QgQ29udGV4dFRvVXNlID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgICAgIGxldCBSZXN1bHRDb250ZXh0ID0gQ29udGV4dDtcbiAgICAgICAgaWYgKHByb3BzQ29udGV4dD8uQ29uc3VtZXIpIHtcbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICBjb25zdCBpc1ZhbGlkID0gLyogQF9fUFVSRV9fICovIGlzQ29udGV4dENvbnN1bWVyKFxuICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVFbGVtZW50KHByb3BzQ29udGV4dC5Db25zdW1lciwgbnVsbClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAoIWlzVmFsaWQpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgIFwiWW91IG11c3QgcGFzcyBhIHZhbGlkIFJlYWN0IGNvbnRleHQgY29uc3VtZXIgYXMgYHByb3BzLmNvbnRleHRgXCJcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFJlc3VsdENvbnRleHQgPSBwcm9wc0NvbnRleHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBSZXN1bHRDb250ZXh0O1xuICAgICAgfSwgW3Byb3BzQ29udGV4dCwgQ29udGV4dF0pO1xuICAgICAgY29uc3QgY29udGV4dFZhbHVlID0gUmVhY3QudXNlQ29udGV4dChDb250ZXh0VG9Vc2UpO1xuICAgICAgY29uc3QgZGlkU3RvcmVDb21lRnJvbVByb3BzID0gQm9vbGVhbihwcm9wcy5zdG9yZSkgJiYgQm9vbGVhbihwcm9wcy5zdG9yZS5nZXRTdGF0ZSkgJiYgQm9vbGVhbihwcm9wcy5zdG9yZS5kaXNwYXRjaCk7XG4gICAgICBjb25zdCBkaWRTdG9yZUNvbWVGcm9tQ29udGV4dCA9IEJvb2xlYW4oY29udGV4dFZhbHVlKSAmJiBCb29sZWFuKGNvbnRleHRWYWx1ZS5zdG9yZSk7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmICFkaWRTdG9yZUNvbWVGcm9tUHJvcHMgJiYgIWRpZFN0b3JlQ29tZUZyb21Db250ZXh0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgQ291bGQgbm90IGZpbmQgXCJzdG9yZVwiIGluIHRoZSBjb250ZXh0IG9mIFwiJHtkaXNwbGF5TmFtZX1cIi4gRWl0aGVyIHdyYXAgdGhlIHJvb3QgY29tcG9uZW50IGluIGEgPFByb3ZpZGVyPiwgb3IgcGFzcyBhIGN1c3RvbSBSZWFjdCBjb250ZXh0IHByb3ZpZGVyIHRvIDxQcm92aWRlcj4gYW5kIHRoZSBjb3JyZXNwb25kaW5nIFJlYWN0IGNvbnRleHQgY29uc3VtZXIgdG8gJHtkaXNwbGF5TmFtZX0gaW4gY29ubmVjdCBvcHRpb25zLmBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHN0b3JlID0gZGlkU3RvcmVDb21lRnJvbVByb3BzID8gcHJvcHMuc3RvcmUgOiBjb250ZXh0VmFsdWUuc3RvcmU7XG4gICAgICBjb25zdCBnZXRTZXJ2ZXJTdGF0ZSA9IGRpZFN0b3JlQ29tZUZyb21Db250ZXh0ID8gY29udGV4dFZhbHVlLmdldFNlcnZlclN0YXRlIDogc3RvcmUuZ2V0U3RhdGU7XG4gICAgICBjb25zdCBjaGlsZFByb3BzU2VsZWN0b3IgPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICAgICAgcmV0dXJuIGZpbmFsUHJvcHNTZWxlY3RvckZhY3Rvcnkoc3RvcmUuZGlzcGF0Y2gsIHNlbGVjdG9yRmFjdG9yeU9wdGlvbnMpO1xuICAgICAgfSwgW3N0b3JlXSk7XG4gICAgICBjb25zdCBbc3Vic2NyaXB0aW9uLCBub3RpZnlOZXN0ZWRTdWJzXSA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgICAgICBpZiAoIXNob3VsZEhhbmRsZVN0YXRlQ2hhbmdlcylcbiAgICAgICAgICByZXR1cm4gTk9fU1VCU0NSSVBUSU9OX0FSUkFZO1xuICAgICAgICBjb25zdCBzdWJzY3JpcHRpb24yID0gY3JlYXRlU3Vic2NyaXB0aW9uKFxuICAgICAgICAgIHN0b3JlLFxuICAgICAgICAgIGRpZFN0b3JlQ29tZUZyb21Qcm9wcyA/IHZvaWQgMCA6IGNvbnRleHRWYWx1ZS5zdWJzY3JpcHRpb25cbiAgICAgICAgKTtcbiAgICAgICAgY29uc3Qgbm90aWZ5TmVzdGVkU3ViczIgPSBzdWJzY3JpcHRpb24yLm5vdGlmeU5lc3RlZFN1YnMuYmluZChzdWJzY3JpcHRpb24yKTtcbiAgICAgICAgcmV0dXJuIFtzdWJzY3JpcHRpb24yLCBub3RpZnlOZXN0ZWRTdWJzMl07XG4gICAgICB9LCBbc3RvcmUsIGRpZFN0b3JlQ29tZUZyb21Qcm9wcywgY29udGV4dFZhbHVlXSk7XG4gICAgICBjb25zdCBvdmVycmlkZGVuQ29udGV4dFZhbHVlID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgICAgIGlmIChkaWRTdG9yZUNvbWVGcm9tUHJvcHMpIHtcbiAgICAgICAgICByZXR1cm4gY29udGV4dFZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgLi4uY29udGV4dFZhbHVlLFxuICAgICAgICAgIHN1YnNjcmlwdGlvblxuICAgICAgICB9O1xuICAgICAgfSwgW2RpZFN0b3JlQ29tZUZyb21Qcm9wcywgY29udGV4dFZhbHVlLCBzdWJzY3JpcHRpb25dKTtcbiAgICAgIGNvbnN0IGxhc3RDaGlsZFByb3BzID0gUmVhY3QudXNlUmVmKCk7XG4gICAgICBjb25zdCBsYXN0V3JhcHBlclByb3BzID0gUmVhY3QudXNlUmVmKHdyYXBwZXJQcm9wcyk7XG4gICAgICBjb25zdCBjaGlsZFByb3BzRnJvbVN0b3JlVXBkYXRlID0gUmVhY3QudXNlUmVmKCk7XG4gICAgICBjb25zdCByZW5kZXJJc1NjaGVkdWxlZCA9IFJlYWN0LnVzZVJlZihmYWxzZSk7XG4gICAgICBjb25zdCBpc01vdW50ZWQgPSBSZWFjdC51c2VSZWYoZmFsc2UpO1xuICAgICAgY29uc3QgbGF0ZXN0U3Vic2NyaXB0aW9uQ2FsbGJhY2tFcnJvciA9IFJlYWN0LnVzZVJlZigpO1xuICAgICAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlzTW91bnRlZC5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICBpc01vdW50ZWQuY3VycmVudCA9IGZhbHNlO1xuICAgICAgICB9O1xuICAgICAgfSwgW10pO1xuICAgICAgY29uc3QgYWN0dWFsQ2hpbGRQcm9wc1NlbGVjdG9yID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgICAgIGNvbnN0IHNlbGVjdG9yID0gKCkgPT4ge1xuICAgICAgICAgIGlmIChjaGlsZFByb3BzRnJvbVN0b3JlVXBkYXRlLmN1cnJlbnQgJiYgd3JhcHBlclByb3BzID09PSBsYXN0V3JhcHBlclByb3BzLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBjaGlsZFByb3BzRnJvbVN0b3JlVXBkYXRlLmN1cnJlbnQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBjaGlsZFByb3BzU2VsZWN0b3Ioc3RvcmUuZ2V0U3RhdGUoKSwgd3JhcHBlclByb3BzKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHNlbGVjdG9yO1xuICAgICAgfSwgW3N0b3JlLCB3cmFwcGVyUHJvcHNdKTtcbiAgICAgIGNvbnN0IHN1YnNjcmliZUZvclJlYWN0ID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgICAgIGNvbnN0IHN1YnNjcmliZSA9IChyZWFjdExpc3RlbmVyKSA9PiB7XG4gICAgICAgICAgaWYgKCFzdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gc3Vic2NyaWJlVXBkYXRlcyhcbiAgICAgICAgICAgIHNob3VsZEhhbmRsZVN0YXRlQ2hhbmdlcyxcbiAgICAgICAgICAgIHN0b3JlLFxuICAgICAgICAgICAgc3Vic2NyaXB0aW9uLFxuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgY2hpbGRQcm9wc1NlbGVjdG9yLFxuICAgICAgICAgICAgbGFzdFdyYXBwZXJQcm9wcyxcbiAgICAgICAgICAgIGxhc3RDaGlsZFByb3BzLFxuICAgICAgICAgICAgcmVuZGVySXNTY2hlZHVsZWQsXG4gICAgICAgICAgICBpc01vdW50ZWQsXG4gICAgICAgICAgICBjaGlsZFByb3BzRnJvbVN0b3JlVXBkYXRlLFxuICAgICAgICAgICAgbm90aWZ5TmVzdGVkU3VicyxcbiAgICAgICAgICAgIHJlYWN0TGlzdGVuZXJcbiAgICAgICAgICApO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gc3Vic2NyaWJlO1xuICAgICAgfSwgW3N1YnNjcmlwdGlvbl0pO1xuICAgICAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdFdpdGhBcmdzKGNhcHR1cmVXcmFwcGVyUHJvcHMsIFtcbiAgICAgICAgbGFzdFdyYXBwZXJQcm9wcyxcbiAgICAgICAgbGFzdENoaWxkUHJvcHMsXG4gICAgICAgIHJlbmRlcklzU2NoZWR1bGVkLFxuICAgICAgICB3cmFwcGVyUHJvcHMsXG4gICAgICAgIGNoaWxkUHJvcHNGcm9tU3RvcmVVcGRhdGUsXG4gICAgICAgIG5vdGlmeU5lc3RlZFN1YnNcbiAgICAgIF0pO1xuICAgICAgbGV0IGFjdHVhbENoaWxkUHJvcHM7XG4gICAgICB0cnkge1xuICAgICAgICBhY3R1YWxDaGlsZFByb3BzID0gdXNlU3luY0V4dGVybmFsU3RvcmUoXG4gICAgICAgICAgLy8gVE9ETyBXZSdyZSBwYXNzaW5nIHRocm91Z2ggYSBiaWcgd3JhcHBlciB0aGF0IGRvZXMgYSBidW5jaCBvZiBleHRyYSBzaWRlIGVmZmVjdHMgYmVzaWRlcyBzdWJzY3JpYmluZ1xuICAgICAgICAgIHN1YnNjcmliZUZvclJlYWN0LFxuICAgICAgICAgIC8vIFRPRE8gVGhpcyBpcyBpbmNyZWRpYmx5IGhhY2t5LiBXZSd2ZSBhbHJlYWR5IHByb2Nlc3NlZCB0aGUgc3RvcmUgdXBkYXRlIGFuZCBjYWxjdWxhdGVkIG5ldyBjaGlsZCBwcm9wcyxcbiAgICAgICAgICAvLyBUT0RPIGFuZCB3ZSdyZSBqdXN0IHBhc3NpbmcgdGhhdCB0aHJvdWdoIHNvIGl0IHRyaWdnZXJzIGEgcmUtcmVuZGVyIGZvciB1cyByYXRoZXIgdGhhbiByZWx5aW5nIG9uIGB1U0VTYC5cbiAgICAgICAgICBhY3R1YWxDaGlsZFByb3BzU2VsZWN0b3IsXG4gICAgICAgICAgZ2V0U2VydmVyU3RhdGUgPyAoKSA9PiBjaGlsZFByb3BzU2VsZWN0b3IoZ2V0U2VydmVyU3RhdGUoKSwgd3JhcHBlclByb3BzKSA6IGFjdHVhbENoaWxkUHJvcHNTZWxlY3RvclxuICAgICAgICApO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGlmIChsYXRlc3RTdWJzY3JpcHRpb25DYWxsYmFja0Vycm9yLmN1cnJlbnQpIHtcbiAgICAgICAgICA7XG4gICAgICAgICAgZXJyLm1lc3NhZ2UgKz0gYFxuVGhlIGVycm9yIG1heSBiZSBjb3JyZWxhdGVkIHdpdGggdGhpcyBwcmV2aW91cyBlcnJvcjpcbiR7bGF0ZXN0U3Vic2NyaXB0aW9uQ2FsbGJhY2tFcnJvci5jdXJyZW50LnN0YWNrfVxuXG5gO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cbiAgICAgIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgICBsYXRlc3RTdWJzY3JpcHRpb25DYWxsYmFja0Vycm9yLmN1cnJlbnQgPSB2b2lkIDA7XG4gICAgICAgIGNoaWxkUHJvcHNGcm9tU3RvcmVVcGRhdGUuY3VycmVudCA9IHZvaWQgMDtcbiAgICAgICAgbGFzdENoaWxkUHJvcHMuY3VycmVudCA9IGFjdHVhbENoaWxkUHJvcHM7XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHJlbmRlcmVkV3JhcHBlZENvbXBvbmVudCA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgIFdyYXBwZWRDb21wb25lbnQsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIC4uLmFjdHVhbENoaWxkUHJvcHMsXG4gICAgICAgICAgICAgIHJlZjogcmVhY3RSZWR1eEZvcndhcmRlZFJlZlxuICAgICAgICAgICAgfVxuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgIH0sIFtyZWFjdFJlZHV4Rm9yd2FyZGVkUmVmLCBXcmFwcGVkQ29tcG9uZW50LCBhY3R1YWxDaGlsZFByb3BzXSk7XG4gICAgICBjb25zdCByZW5kZXJlZENoaWxkID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgICAgIGlmIChzaG91bGRIYW5kbGVTdGF0ZUNoYW5nZXMpIHtcbiAgICAgICAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ29udGV4dFRvVXNlLlByb3ZpZGVyLCB7IHZhbHVlOiBvdmVycmlkZGVuQ29udGV4dFZhbHVlIH0sIHJlbmRlcmVkV3JhcHBlZENvbXBvbmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlbmRlcmVkV3JhcHBlZENvbXBvbmVudDtcbiAgICAgIH0sIFtDb250ZXh0VG9Vc2UsIHJlbmRlcmVkV3JhcHBlZENvbXBvbmVudCwgb3ZlcnJpZGRlbkNvbnRleHRWYWx1ZV0pO1xuICAgICAgcmV0dXJuIHJlbmRlcmVkQ2hpbGQ7XG4gICAgfVxuICAgIGNvbnN0IF9Db25uZWN0ID0gUmVhY3QubWVtbyhDb25uZWN0RnVuY3Rpb24pO1xuICAgIGNvbnN0IENvbm5lY3QgPSBfQ29ubmVjdDtcbiAgICBDb25uZWN0LldyYXBwZWRDb21wb25lbnQgPSBXcmFwcGVkQ29tcG9uZW50O1xuICAgIENvbm5lY3QuZGlzcGxheU5hbWUgPSBDb25uZWN0RnVuY3Rpb24uZGlzcGxheU5hbWUgPSBkaXNwbGF5TmFtZTtcbiAgICBpZiAoZm9yd2FyZFJlZikge1xuICAgICAgY29uc3QgX2ZvcndhcmRlZCA9IFJlYWN0LmZvcndhcmRSZWYoXG4gICAgICAgIGZ1bmN0aW9uIGZvcndhcmRDb25uZWN0UmVmKHByb3BzLCByZWYpIHtcbiAgICAgICAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ29ubmVjdCwgeyAuLi5wcm9wcywgcmVhY3RSZWR1eEZvcndhcmRlZFJlZjogcmVmIH0pO1xuICAgICAgICB9XG4gICAgICApO1xuICAgICAgY29uc3QgZm9yd2FyZGVkID0gX2ZvcndhcmRlZDtcbiAgICAgIGZvcndhcmRlZC5kaXNwbGF5TmFtZSA9IGRpc3BsYXlOYW1lO1xuICAgICAgZm9yd2FyZGVkLldyYXBwZWRDb21wb25lbnQgPSBXcmFwcGVkQ29tcG9uZW50O1xuICAgICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBob2lzdE5vblJlYWN0U3RhdGljcyhmb3J3YXJkZWQsIFdyYXBwZWRDb21wb25lbnQpO1xuICAgIH1cbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGhvaXN0Tm9uUmVhY3RTdGF0aWNzKENvbm5lY3QsIFdyYXBwZWRDb21wb25lbnQpO1xuICB9O1xuICByZXR1cm4gd3JhcFdpdGhDb25uZWN0O1xufVxudmFyIGNvbm5lY3RfZGVmYXVsdCA9IGNvbm5lY3Q7XG5cbi8vIHNyYy9jb21wb25lbnRzL1Byb3ZpZGVyLnRzeFxuZnVuY3Rpb24gUHJvdmlkZXIoe1xuICBzdG9yZSxcbiAgY29udGV4dCxcbiAgY2hpbGRyZW4sXG4gIHNlcnZlclN0YXRlLFxuICBzdGFiaWxpdHlDaGVjayA9IFwib25jZVwiLFxuICBpZGVudGl0eUZ1bmN0aW9uQ2hlY2sgPSBcIm9uY2VcIlxufSkge1xuICBjb25zdCBjb250ZXh0VmFsdWUgPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICBjb25zdCBzdWJzY3JpcHRpb24gPSBjcmVhdGVTdWJzY3JpcHRpb24oc3RvcmUpO1xuICAgIHJldHVybiB7XG4gICAgICBzdG9yZSxcbiAgICAgIHN1YnNjcmlwdGlvbixcbiAgICAgIGdldFNlcnZlclN0YXRlOiBzZXJ2ZXJTdGF0ZSA/ICgpID0+IHNlcnZlclN0YXRlIDogdm9pZCAwLFxuICAgICAgc3RhYmlsaXR5Q2hlY2ssXG4gICAgICBpZGVudGl0eUZ1bmN0aW9uQ2hlY2tcbiAgICB9O1xuICB9LCBbc3RvcmUsIHNlcnZlclN0YXRlLCBzdGFiaWxpdHlDaGVjaywgaWRlbnRpdHlGdW5jdGlvbkNoZWNrXSk7XG4gIGNvbnN0IHByZXZpb3VzU3RhdGUgPSBSZWFjdC51c2VNZW1vKCgpID0+IHN0b3JlLmdldFN0YXRlKCksIFtzdG9yZV0pO1xuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCB7IHN1YnNjcmlwdGlvbiB9ID0gY29udGV4dFZhbHVlO1xuICAgIHN1YnNjcmlwdGlvbi5vblN0YXRlQ2hhbmdlID0gc3Vic2NyaXB0aW9uLm5vdGlmeU5lc3RlZFN1YnM7XG4gICAgc3Vic2NyaXB0aW9uLnRyeVN1YnNjcmliZSgpO1xuICAgIGlmIChwcmV2aW91c1N0YXRlICE9PSBzdG9yZS5nZXRTdGF0ZSgpKSB7XG4gICAgICBzdWJzY3JpcHRpb24ubm90aWZ5TmVzdGVkU3VicygpO1xuICAgIH1cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgc3Vic2NyaXB0aW9uLnRyeVVuc3Vic2NyaWJlKCk7XG4gICAgICBzdWJzY3JpcHRpb24ub25TdGF0ZUNoYW5nZSA9IHZvaWQgMDtcbiAgICB9O1xuICB9LCBbY29udGV4dFZhbHVlLCBwcmV2aW91c1N0YXRlXSk7XG4gIGNvbnN0IENvbnRleHQgPSBjb250ZXh0IHx8IFJlYWN0UmVkdXhDb250ZXh0O1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogY29udGV4dFZhbHVlIH0sIGNoaWxkcmVuKTtcbn1cbnZhciBQcm92aWRlcl9kZWZhdWx0ID0gUHJvdmlkZXI7XG5cbi8vIHNyYy9ob29rcy91c2VTdG9yZS50c1xuZnVuY3Rpb24gY3JlYXRlU3RvcmVIb29rKGNvbnRleHQgPSBSZWFjdFJlZHV4Q29udGV4dCkge1xuICBjb25zdCB1c2VSZWR1eENvbnRleHQyID0gY29udGV4dCA9PT0gUmVhY3RSZWR1eENvbnRleHQgPyB1c2VSZWR1eENvbnRleHQgOiAoXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGNyZWF0ZVJlZHV4Q29udGV4dEhvb2soY29udGV4dClcbiAgKTtcbiAgY29uc3QgdXNlU3RvcmUyID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgc3RvcmUgfSA9IHVzZVJlZHV4Q29udGV4dDIoKTtcbiAgICByZXR1cm4gc3RvcmU7XG4gIH07XG4gIE9iamVjdC5hc3NpZ24odXNlU3RvcmUyLCB7XG4gICAgd2l0aFR5cGVzOiAoKSA9PiB1c2VTdG9yZTJcbiAgfSk7XG4gIHJldHVybiB1c2VTdG9yZTI7XG59XG52YXIgdXNlU3RvcmUgPSAvKiBAX19QVVJFX18gKi8gY3JlYXRlU3RvcmVIb29rKCk7XG5cbi8vIHNyYy9ob29rcy91c2VEaXNwYXRjaC50c1xuZnVuY3Rpb24gY3JlYXRlRGlzcGF0Y2hIb29rKGNvbnRleHQgPSBSZWFjdFJlZHV4Q29udGV4dCkge1xuICBjb25zdCB1c2VTdG9yZTIgPSBjb250ZXh0ID09PSBSZWFjdFJlZHV4Q29udGV4dCA/IHVzZVN0b3JlIDogY3JlYXRlU3RvcmVIb29rKGNvbnRleHQpO1xuICBjb25zdCB1c2VEaXNwYXRjaDIgPSAoKSA9PiB7XG4gICAgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZTIoKTtcbiAgICByZXR1cm4gc3RvcmUuZGlzcGF0Y2g7XG4gIH07XG4gIE9iamVjdC5hc3NpZ24odXNlRGlzcGF0Y2gyLCB7XG4gICAgd2l0aFR5cGVzOiAoKSA9PiB1c2VEaXNwYXRjaDJcbiAgfSk7XG4gIHJldHVybiB1c2VEaXNwYXRjaDI7XG59XG52YXIgdXNlRGlzcGF0Y2ggPSAvKiBAX19QVVJFX18gKi8gY3JlYXRlRGlzcGF0Y2hIb29rKCk7XG5cbi8vIHNyYy9leHBvcnRzLnRzXG52YXIgYmF0Y2ggPSBkZWZhdWx0Tm9vcEJhdGNoO1xuXG4vLyBzcmMvaW5kZXgudHNcbmluaXRpYWxpemVVc2VTZWxlY3Rvcih1c2VTeW5jRXh0ZXJuYWxTdG9yZVdpdGhTZWxlY3RvcjIpO1xuaW5pdGlhbGl6ZUNvbm5lY3QoUmVhY3QyLnVzZVN5bmNFeHRlcm5hbFN0b3JlKTtcbmV4cG9ydCB7XG4gIFByb3ZpZGVyX2RlZmF1bHQgYXMgUHJvdmlkZXIsXG4gIFJlYWN0UmVkdXhDb250ZXh0LFxuICBiYXRjaCxcbiAgY29ubmVjdF9kZWZhdWx0IGFzIGNvbm5lY3QsXG4gIGNyZWF0ZURpc3BhdGNoSG9vayxcbiAgY3JlYXRlU2VsZWN0b3JIb29rLFxuICBjcmVhdGVTdG9yZUhvb2ssXG4gIHNoYWxsb3dFcXVhbCxcbiAgdXNlRGlzcGF0Y2gsXG4gIHVzZVNlbGVjdG9yLFxuICB1c2VTdG9yZVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlYWN0LXJlZHV4Lm1qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-redux/dist/react-redux.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/redux-thunk/dist/redux-thunk.mjs":
/*!*******************************************************!*\
  !*** ./node_modules/redux-thunk/dist/redux-thunk.mjs ***!
  \*******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   thunk: function() { return /* binding */ thunk; },\n/* harmony export */   withExtraArgument: function() { return /* binding */ withExtraArgument; }\n/* harmony export */ });\n// src/index.ts\nfunction createThunkMiddleware(extraArgument) {\n  const middleware = ({ dispatch, getState }) => (next) => (action) => {\n    if (typeof action === \"function\") {\n      return action(dispatch, getState, extraArgument);\n    }\n    return next(action);\n  };\n  return middleware;\n}\nvar thunk = createThunkMiddleware();\nvar withExtraArgument = createThunkMiddleware;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWR1eC10aHVuay9kaXN0L3JlZHV4LXRodW5rLm1qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDQSx3QkFBd0Isb0JBQW9CO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWR1eC10aHVuay9kaXN0L3JlZHV4LXRodW5rLm1qcz82OTgwIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9pbmRleC50c1xuZnVuY3Rpb24gY3JlYXRlVGh1bmtNaWRkbGV3YXJlKGV4dHJhQXJndW1lbnQpIHtcbiAgY29uc3QgbWlkZGxld2FyZSA9ICh7IGRpc3BhdGNoLCBnZXRTdGF0ZSB9KSA9PiAobmV4dCkgPT4gKGFjdGlvbikgPT4ge1xuICAgIGlmICh0eXBlb2YgYWN0aW9uID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHJldHVybiBhY3Rpb24oZGlzcGF0Y2gsIGdldFN0YXRlLCBleHRyYUFyZ3VtZW50KTtcbiAgICB9XG4gICAgcmV0dXJuIG5leHQoYWN0aW9uKTtcbiAgfTtcbiAgcmV0dXJuIG1pZGRsZXdhcmU7XG59XG52YXIgdGh1bmsgPSBjcmVhdGVUaHVua01pZGRsZXdhcmUoKTtcbnZhciB3aXRoRXh0cmFBcmd1bWVudCA9IGNyZWF0ZVRodW5rTWlkZGxld2FyZTtcbmV4cG9ydCB7XG4gIHRodW5rLFxuICB3aXRoRXh0cmFBcmd1bWVudFxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/redux-thunk/dist/redux-thunk.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/redux/dist/redux.mjs":
/*!*******************************************!*\
  !*** ./node_modules/redux/dist/redux.mjs ***!
  \*******************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   __DO_NOT_USE__ActionTypes: function() { return /* binding */ actionTypes_default; },\n/* harmony export */   applyMiddleware: function() { return /* binding */ applyMiddleware; },\n/* harmony export */   bindActionCreators: function() { return /* binding */ bindActionCreators; },\n/* harmony export */   combineReducers: function() { return /* binding */ combineReducers; },\n/* harmony export */   compose: function() { return /* binding */ compose; },\n/* harmony export */   createStore: function() { return /* binding */ createStore; },\n/* harmony export */   isAction: function() { return /* binding */ isAction; },\n/* harmony export */   isPlainObject: function() { return /* binding */ isPlainObject; },\n/* harmony export */   legacy_createStore: function() { return /* binding */ legacy_createStore; }\n/* harmony export */ });\n// src/utils/formatProdErrorMessage.ts\nfunction formatProdErrorMessage(code) {\n  return `Minified Redux error #${code}; visit https://redux.js.org/Errors?code=${code} for the full message or use the non-minified dev environment for full errors. `;\n}\n\n// src/utils/symbol-observable.ts\nvar $$observable = /* @__PURE__ */ (() => typeof Symbol === \"function\" && Symbol.observable || \"@@observable\")();\nvar symbol_observable_default = $$observable;\n\n// src/utils/actionTypes.ts\nvar randomString = () => Math.random().toString(36).substring(7).split(\"\").join(\".\");\nvar ActionTypes = {\n  INIT: `@@redux/INIT${/* @__PURE__ */ randomString()}`,\n  REPLACE: `@@redux/REPLACE${/* @__PURE__ */ randomString()}`,\n  PROBE_UNKNOWN_ACTION: () => `@@redux/PROBE_UNKNOWN_ACTION${randomString()}`\n};\nvar actionTypes_default = ActionTypes;\n\n// src/utils/isPlainObject.ts\nfunction isPlainObject(obj) {\n  if (typeof obj !== \"object\" || obj === null)\n    return false;\n  let proto = obj;\n  while (Object.getPrototypeOf(proto) !== null) {\n    proto = Object.getPrototypeOf(proto);\n  }\n  return Object.getPrototypeOf(obj) === proto || Object.getPrototypeOf(obj) === null;\n}\n\n// src/utils/kindOf.ts\nfunction miniKindOf(val) {\n  if (val === void 0)\n    return \"undefined\";\n  if (val === null)\n    return \"null\";\n  const type = typeof val;\n  switch (type) {\n    case \"boolean\":\n    case \"string\":\n    case \"number\":\n    case \"symbol\":\n    case \"function\": {\n      return type;\n    }\n  }\n  if (Array.isArray(val))\n    return \"array\";\n  if (isDate(val))\n    return \"date\";\n  if (isError(val))\n    return \"error\";\n  const constructorName = ctorName(val);\n  switch (constructorName) {\n    case \"Symbol\":\n    case \"Promise\":\n    case \"WeakMap\":\n    case \"WeakSet\":\n    case \"Map\":\n    case \"Set\":\n      return constructorName;\n  }\n  return Object.prototype.toString.call(val).slice(8, -1).toLowerCase().replace(/\\s/g, \"\");\n}\nfunction ctorName(val) {\n  return typeof val.constructor === \"function\" ? val.constructor.name : null;\n}\nfunction isError(val) {\n  return val instanceof Error || typeof val.message === \"string\" && val.constructor && typeof val.constructor.stackTraceLimit === \"number\";\n}\nfunction isDate(val) {\n  if (val instanceof Date)\n    return true;\n  return typeof val.toDateString === \"function\" && typeof val.getDate === \"function\" && typeof val.setDate === \"function\";\n}\nfunction kindOf(val) {\n  let typeOfVal = typeof val;\n  if (true) {\n    typeOfVal = miniKindOf(val);\n  }\n  return typeOfVal;\n}\n\n// src/createStore.ts\nfunction createStore(reducer, preloadedState, enhancer) {\n  if (typeof reducer !== \"function\") {\n    throw new Error( false ? 0 : `Expected the root reducer to be a function. Instead, received: '${kindOf(reducer)}'`);\n  }\n  if (typeof preloadedState === \"function\" && typeof enhancer === \"function\" || typeof enhancer === \"function\" && typeof arguments[3] === \"function\") {\n    throw new Error( false ? 0 : \"It looks like you are passing several store enhancers to createStore(). This is not supported. Instead, compose them together to a single function. See https://redux.js.org/tutorials/fundamentals/part-4-store#creating-a-store-with-enhancers for an example.\");\n  }\n  if (typeof preloadedState === \"function\" && typeof enhancer === \"undefined\") {\n    enhancer = preloadedState;\n    preloadedState = void 0;\n  }\n  if (typeof enhancer !== \"undefined\") {\n    if (typeof enhancer !== \"function\") {\n      throw new Error( false ? 0 : `Expected the enhancer to be a function. Instead, received: '${kindOf(enhancer)}'`);\n    }\n    return enhancer(createStore)(reducer, preloadedState);\n  }\n  let currentReducer = reducer;\n  let currentState = preloadedState;\n  let currentListeners = /* @__PURE__ */ new Map();\n  let nextListeners = currentListeners;\n  let listenerIdCounter = 0;\n  let isDispatching = false;\n  function ensureCanMutateNextListeners() {\n    if (nextListeners === currentListeners) {\n      nextListeners = /* @__PURE__ */ new Map();\n      currentListeners.forEach((listener, key) => {\n        nextListeners.set(key, listener);\n      });\n    }\n  }\n  function getState() {\n    if (isDispatching) {\n      throw new Error( false ? 0 : \"You may not call store.getState() while the reducer is executing. The reducer has already received the state as an argument. Pass it down from the top reducer instead of reading it from the store.\");\n    }\n    return currentState;\n  }\n  function subscribe(listener) {\n    if (typeof listener !== \"function\") {\n      throw new Error( false ? 0 : `Expected the listener to be a function. Instead, received: '${kindOf(listener)}'`);\n    }\n    if (isDispatching) {\n      throw new Error( false ? 0 : \"You may not call store.subscribe() while the reducer is executing. If you would like to be notified after the store has been updated, subscribe from a component and invoke store.getState() in the callback to access the latest state. See https://redux.js.org/api/store#subscribelistener for more details.\");\n    }\n    let isSubscribed = true;\n    ensureCanMutateNextListeners();\n    const listenerId = listenerIdCounter++;\n    nextListeners.set(listenerId, listener);\n    return function unsubscribe() {\n      if (!isSubscribed) {\n        return;\n      }\n      if (isDispatching) {\n        throw new Error( false ? 0 : \"You may not unsubscribe from a store listener while the reducer is executing. See https://redux.js.org/api/store#subscribelistener for more details.\");\n      }\n      isSubscribed = false;\n      ensureCanMutateNextListeners();\n      nextListeners.delete(listenerId);\n      currentListeners = null;\n    };\n  }\n  function dispatch(action) {\n    if (!isPlainObject(action)) {\n      throw new Error( false ? 0 : `Actions must be plain objects. Instead, the actual type was: '${kindOf(action)}'. You may need to add middleware to your store setup to handle dispatching other values, such as 'redux-thunk' to handle dispatching functions. See https://redux.js.org/tutorials/fundamentals/part-4-store#middleware and https://redux.js.org/tutorials/fundamentals/part-6-async-logic#using-the-redux-thunk-middleware for examples.`);\n    }\n    if (typeof action.type === \"undefined\") {\n      throw new Error( false ? 0 : 'Actions may not have an undefined \"type\" property. You may have misspelled an action type string constant.');\n    }\n    if (typeof action.type !== \"string\") {\n      throw new Error( false ? 0 : `Action \"type\" property must be a string. Instead, the actual type was: '${kindOf(action.type)}'. Value was: '${action.type}' (stringified)`);\n    }\n    if (isDispatching) {\n      throw new Error( false ? 0 : \"Reducers may not dispatch actions.\");\n    }\n    try {\n      isDispatching = true;\n      currentState = currentReducer(currentState, action);\n    } finally {\n      isDispatching = false;\n    }\n    const listeners = currentListeners = nextListeners;\n    listeners.forEach((listener) => {\n      listener();\n    });\n    return action;\n  }\n  function replaceReducer(nextReducer) {\n    if (typeof nextReducer !== \"function\") {\n      throw new Error( false ? 0 : `Expected the nextReducer to be a function. Instead, received: '${kindOf(nextReducer)}`);\n    }\n    currentReducer = nextReducer;\n    dispatch({\n      type: actionTypes_default.REPLACE\n    });\n  }\n  function observable() {\n    const outerSubscribe = subscribe;\n    return {\n      /**\n       * The minimal observable subscription method.\n       * @param observer Any object that can be used as an observer.\n       * The observer object should have a `next` method.\n       * @returns An object with an `unsubscribe` method that can\n       * be used to unsubscribe the observable from the store, and prevent further\n       * emission of values from the observable.\n       */\n      subscribe(observer) {\n        if (typeof observer !== \"object\" || observer === null) {\n          throw new Error( false ? 0 : `Expected the observer to be an object. Instead, received: '${kindOf(observer)}'`);\n        }\n        function observeState() {\n          const observerAsObserver = observer;\n          if (observerAsObserver.next) {\n            observerAsObserver.next(getState());\n          }\n        }\n        observeState();\n        const unsubscribe = outerSubscribe(observeState);\n        return {\n          unsubscribe\n        };\n      },\n      [symbol_observable_default]() {\n        return this;\n      }\n    };\n  }\n  dispatch({\n    type: actionTypes_default.INIT\n  });\n  const store = {\n    dispatch,\n    subscribe,\n    getState,\n    replaceReducer,\n    [symbol_observable_default]: observable\n  };\n  return store;\n}\nfunction legacy_createStore(reducer, preloadedState, enhancer) {\n  return createStore(reducer, preloadedState, enhancer);\n}\n\n// src/utils/warning.ts\nfunction warning(message) {\n  if (typeof console !== \"undefined\" && typeof console.error === \"function\") {\n    console.error(message);\n  }\n  try {\n    throw new Error(message);\n  } catch (e) {\n  }\n}\n\n// src/combineReducers.ts\nfunction getUnexpectedStateShapeWarningMessage(inputState, reducers, action, unexpectedKeyCache) {\n  const reducerKeys = Object.keys(reducers);\n  const argumentName = action && action.type === actionTypes_default.INIT ? \"preloadedState argument passed to createStore\" : \"previous state received by the reducer\";\n  if (reducerKeys.length === 0) {\n    return \"Store does not have a valid reducer. Make sure the argument passed to combineReducers is an object whose values are reducers.\";\n  }\n  if (!isPlainObject(inputState)) {\n    return `The ${argumentName} has unexpected type of \"${kindOf(inputState)}\". Expected argument to be an object with the following keys: \"${reducerKeys.join('\", \"')}\"`;\n  }\n  const unexpectedKeys = Object.keys(inputState).filter((key) => !reducers.hasOwnProperty(key) && !unexpectedKeyCache[key]);\n  unexpectedKeys.forEach((key) => {\n    unexpectedKeyCache[key] = true;\n  });\n  if (action && action.type === actionTypes_default.REPLACE)\n    return;\n  if (unexpectedKeys.length > 0) {\n    return `Unexpected ${unexpectedKeys.length > 1 ? \"keys\" : \"key\"} \"${unexpectedKeys.join('\", \"')}\" found in ${argumentName}. Expected to find one of the known reducer keys instead: \"${reducerKeys.join('\", \"')}\". Unexpected keys will be ignored.`;\n  }\n}\nfunction assertReducerShape(reducers) {\n  Object.keys(reducers).forEach((key) => {\n    const reducer = reducers[key];\n    const initialState = reducer(void 0, {\n      type: actionTypes_default.INIT\n    });\n    if (typeof initialState === \"undefined\") {\n      throw new Error( false ? 0 : `The slice reducer for key \"${key}\" returned undefined during initialization. If the state passed to the reducer is undefined, you must explicitly return the initial state. The initial state may not be undefined. If you don't want to set a value for this reducer, you can use null instead of undefined.`);\n    }\n    if (typeof reducer(void 0, {\n      type: actionTypes_default.PROBE_UNKNOWN_ACTION()\n    }) === \"undefined\") {\n      throw new Error( false ? 0 : `The slice reducer for key \"${key}\" returned undefined when probed with a random type. Don't try to handle '${actionTypes_default.INIT}' or other actions in \"redux/*\" namespace. They are considered private. Instead, you must return the current state for any unknown actions, unless it is undefined, in which case you must return the initial state, regardless of the action type. The initial state may not be undefined, but can be null.`);\n    }\n  });\n}\nfunction combineReducers(reducers) {\n  const reducerKeys = Object.keys(reducers);\n  const finalReducers = {};\n  for (let i = 0; i < reducerKeys.length; i++) {\n    const key = reducerKeys[i];\n    if (true) {\n      if (typeof reducers[key] === \"undefined\") {\n        warning(`No reducer provided for key \"${key}\"`);\n      }\n    }\n    if (typeof reducers[key] === \"function\") {\n      finalReducers[key] = reducers[key];\n    }\n  }\n  const finalReducerKeys = Object.keys(finalReducers);\n  let unexpectedKeyCache;\n  if (true) {\n    unexpectedKeyCache = {};\n  }\n  let shapeAssertionError;\n  try {\n    assertReducerShape(finalReducers);\n  } catch (e) {\n    shapeAssertionError = e;\n  }\n  return function combination(state = {}, action) {\n    if (shapeAssertionError) {\n      throw shapeAssertionError;\n    }\n    if (true) {\n      const warningMessage = getUnexpectedStateShapeWarningMessage(state, finalReducers, action, unexpectedKeyCache);\n      if (warningMessage) {\n        warning(warningMessage);\n      }\n    }\n    let hasChanged = false;\n    const nextState = {};\n    for (let i = 0; i < finalReducerKeys.length; i++) {\n      const key = finalReducerKeys[i];\n      const reducer = finalReducers[key];\n      const previousStateForKey = state[key];\n      const nextStateForKey = reducer(previousStateForKey, action);\n      if (typeof nextStateForKey === \"undefined\") {\n        const actionType = action && action.type;\n        throw new Error( false ? 0 : `When called with an action of type ${actionType ? `\"${String(actionType)}\"` : \"(unknown type)\"}, the slice reducer for key \"${key}\" returned undefined. To ignore an action, you must explicitly return the previous state. If you want this reducer to hold no value, you can return null instead of undefined.`);\n      }\n      nextState[key] = nextStateForKey;\n      hasChanged = hasChanged || nextStateForKey !== previousStateForKey;\n    }\n    hasChanged = hasChanged || finalReducerKeys.length !== Object.keys(state).length;\n    return hasChanged ? nextState : state;\n  };\n}\n\n// src/bindActionCreators.ts\nfunction bindActionCreator(actionCreator, dispatch) {\n  return function(...args) {\n    return dispatch(actionCreator.apply(this, args));\n  };\n}\nfunction bindActionCreators(actionCreators, dispatch) {\n  if (typeof actionCreators === \"function\") {\n    return bindActionCreator(actionCreators, dispatch);\n  }\n  if (typeof actionCreators !== \"object\" || actionCreators === null) {\n    throw new Error( false ? 0 : `bindActionCreators expected an object or a function, but instead received: '${kindOf(actionCreators)}'. Did you write \"import ActionCreators from\" instead of \"import * as ActionCreators from\"?`);\n  }\n  const boundActionCreators = {};\n  for (const key in actionCreators) {\n    const actionCreator = actionCreators[key];\n    if (typeof actionCreator === \"function\") {\n      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch);\n    }\n  }\n  return boundActionCreators;\n}\n\n// src/compose.ts\nfunction compose(...funcs) {\n  if (funcs.length === 0) {\n    return (arg) => arg;\n  }\n  if (funcs.length === 1) {\n    return funcs[0];\n  }\n  return funcs.reduce((a, b) => (...args) => a(b(...args)));\n}\n\n// src/applyMiddleware.ts\nfunction applyMiddleware(...middlewares) {\n  return (createStore2) => (reducer, preloadedState) => {\n    const store = createStore2(reducer, preloadedState);\n    let dispatch = () => {\n      throw new Error( false ? 0 : \"Dispatching while constructing your middleware is not allowed. Other middleware would not be applied to this dispatch.\");\n    };\n    const middlewareAPI = {\n      getState: store.getState,\n      dispatch: (action, ...args) => dispatch(action, ...args)\n    };\n    const chain = middlewares.map((middleware) => middleware(middlewareAPI));\n    dispatch = compose(...chain)(store.dispatch);\n    return {\n      ...store,\n      dispatch\n    };\n  };\n}\n\n// src/utils/isAction.ts\nfunction isAction(action) {\n  return isPlainObject(action) && \"type\" in action && typeof action.type === \"string\";\n}\n\n//# sourceMappingURL=redux.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWR1eC9kaXN0L3JlZHV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0Esa0NBQWtDLE9BQU8seUNBQXlDLE1BQU07QUFDeEY7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QiwrQkFBK0I7QUFDdEQsNkJBQTZCLCtCQUErQjtBQUM1RCw2REFBNkQsZUFBZTtBQUM1RTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLElBQXFDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixNQUFxQyxHQUFHLENBQXlCLHNFQUFzRSxnQkFBZ0I7QUFDM0s7QUFDQTtBQUNBLG9CQUFvQixNQUFxQyxHQUFHLENBQXlCO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLE1BQXFDLEdBQUcsQ0FBeUIsa0VBQWtFLGlCQUFpQjtBQUMxSztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLE1BQXFDLEdBQUcsQ0FBeUI7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixNQUFxQyxHQUFHLENBQXlCLGtFQUFrRSxpQkFBaUI7QUFDMUs7QUFDQTtBQUNBLHNCQUFzQixNQUFxQyxHQUFHLENBQXlCO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLE1BQXFDLEdBQUcsQ0FBeUI7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLE1BQXFDLEdBQUcsQ0FBeUIsb0VBQW9FLGVBQWU7QUFDMUs7QUFDQTtBQUNBLHNCQUFzQixNQUFxQyxHQUFHLENBQXlCO0FBQ3ZGO0FBQ0E7QUFDQSxzQkFBc0IsTUFBcUMsR0FBRyxDQUEwQiw4RUFBOEUsb0JBQW9CLGlCQUFpQixZQUFZO0FBQ3ZOO0FBQ0E7QUFDQSxzQkFBc0IsTUFBcUMsR0FBRyxDQUF5QjtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLE1BQXFDLEdBQUcsQ0FBMEIscUVBQXFFLG9CQUFvQjtBQUNqTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLE1BQXFDLEdBQUcsQ0FBMEIsaUVBQWlFLGlCQUFpQjtBQUM5SztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixjQUFjLDBCQUEwQixtQkFBbUIsaUVBQWlFLHlCQUF5QjtBQUN2SztBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsNENBQTRDLEdBQUcsNEJBQTRCLGFBQWEsYUFBYSw2REFBNkQseUJBQXlCO0FBQ3BOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esc0JBQXNCLE1BQXFDLEdBQUcsQ0FBMEIsaUNBQWlDLElBQUk7QUFDN0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLHNCQUFzQixNQUFxQyxHQUFHLENBQTBCLGlDQUFpQyxJQUFJLDRFQUE0RSx5QkFBeUI7QUFDbE87QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isd0JBQXdCO0FBQzFDO0FBQ0EsUUFBUSxJQUFxQztBQUM3QztBQUNBLGdEQUFnRCxJQUFJO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLElBQXFDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQSxRQUFRLElBQXFDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDZCQUE2QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsTUFBcUMsR0FBRyxDQUEwQix5Q0FBeUMsaUJBQWlCLG1CQUFtQixzQkFBc0IsK0JBQStCLElBQUk7QUFDaE87QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE1BQXFDLEdBQUcsQ0FBMEIsa0ZBQWtGLHVCQUF1QjtBQUMvTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLE1BQXFDLEdBQUcsQ0FBMEI7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFXRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWR1eC9kaXN0L3JlZHV4Lm1qcz9lMWQ4Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy91dGlscy9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlLnRzXG5mdW5jdGlvbiBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKGNvZGUpIHtcbiAgcmV0dXJuIGBNaW5pZmllZCBSZWR1eCBlcnJvciAjJHtjb2RlfTsgdmlzaXQgaHR0cHM6Ly9yZWR1eC5qcy5vcmcvRXJyb3JzP2NvZGU9JHtjb2RlfSBmb3IgdGhlIGZ1bGwgbWVzc2FnZSBvciB1c2UgdGhlIG5vbi1taW5pZmllZCBkZXYgZW52aXJvbm1lbnQgZm9yIGZ1bGwgZXJyb3JzLiBgO1xufVxuXG4vLyBzcmMvdXRpbHMvc3ltYm9sLW9ic2VydmFibGUudHNcbnZhciAkJG9ic2VydmFibGUgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wub2JzZXJ2YWJsZSB8fCBcIkBAb2JzZXJ2YWJsZVwiKSgpO1xudmFyIHN5bWJvbF9vYnNlcnZhYmxlX2RlZmF1bHQgPSAkJG9ic2VydmFibGU7XG5cbi8vIHNyYy91dGlscy9hY3Rpb25UeXBlcy50c1xudmFyIHJhbmRvbVN0cmluZyA9ICgpID0+IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZyg3KS5zcGxpdChcIlwiKS5qb2luKFwiLlwiKTtcbnZhciBBY3Rpb25UeXBlcyA9IHtcbiAgSU5JVDogYEBAcmVkdXgvSU5JVCR7LyogQF9fUFVSRV9fICovIHJhbmRvbVN0cmluZygpfWAsXG4gIFJFUExBQ0U6IGBAQHJlZHV4L1JFUExBQ0Ukey8qIEBfX1BVUkVfXyAqLyByYW5kb21TdHJpbmcoKX1gLFxuICBQUk9CRV9VTktOT1dOX0FDVElPTjogKCkgPT4gYEBAcmVkdXgvUFJPQkVfVU5LTk9XTl9BQ1RJT04ke3JhbmRvbVN0cmluZygpfWBcbn07XG52YXIgYWN0aW9uVHlwZXNfZGVmYXVsdCA9IEFjdGlvblR5cGVzO1xuXG4vLyBzcmMvdXRpbHMvaXNQbGFpbk9iamVjdC50c1xuZnVuY3Rpb24gaXNQbGFpbk9iamVjdChvYmopIHtcbiAgaWYgKHR5cGVvZiBvYmogIT09IFwib2JqZWN0XCIgfHwgb2JqID09PSBudWxsKVxuICAgIHJldHVybiBmYWxzZTtcbiAgbGV0IHByb3RvID0gb2JqO1xuICB3aGlsZSAoT2JqZWN0LmdldFByb3RvdHlwZU9mKHByb3RvKSAhPT0gbnVsbCkge1xuICAgIHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHByb3RvKTtcbiAgfVxuICByZXR1cm4gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iaikgPT09IHByb3RvIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmopID09PSBudWxsO1xufVxuXG4vLyBzcmMvdXRpbHMva2luZE9mLnRzXG5mdW5jdGlvbiBtaW5pS2luZE9mKHZhbCkge1xuICBpZiAodmFsID09PSB2b2lkIDApXG4gICAgcmV0dXJuIFwidW5kZWZpbmVkXCI7XG4gIGlmICh2YWwgPT09IG51bGwpXG4gICAgcmV0dXJuIFwibnVsbFwiO1xuICBjb25zdCB0eXBlID0gdHlwZW9mIHZhbDtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgY2FzZSBcIm51bWJlclwiOlxuICAgIGNhc2UgXCJzeW1ib2xcIjpcbiAgICBjYXNlIFwiZnVuY3Rpb25cIjoge1xuICAgICAgcmV0dXJuIHR5cGU7XG4gICAgfVxuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbCkpXG4gICAgcmV0dXJuIFwiYXJyYXlcIjtcbiAgaWYgKGlzRGF0ZSh2YWwpKVxuICAgIHJldHVybiBcImRhdGVcIjtcbiAgaWYgKGlzRXJyb3IodmFsKSlcbiAgICByZXR1cm4gXCJlcnJvclwiO1xuICBjb25zdCBjb25zdHJ1Y3Rvck5hbWUgPSBjdG9yTmFtZSh2YWwpO1xuICBzd2l0Y2ggKGNvbnN0cnVjdG9yTmFtZSkge1xuICAgIGNhc2UgXCJTeW1ib2xcIjpcbiAgICBjYXNlIFwiUHJvbWlzZVwiOlxuICAgIGNhc2UgXCJXZWFrTWFwXCI6XG4gICAgY2FzZSBcIldlYWtTZXRcIjpcbiAgICBjYXNlIFwiTWFwXCI6XG4gICAgY2FzZSBcIlNldFwiOlxuICAgICAgcmV0dXJuIGNvbnN0cnVjdG9yTmFtZTtcbiAgfVxuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbCkuc2xpY2UoOCwgLTEpLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvXFxzL2csIFwiXCIpO1xufVxuZnVuY3Rpb24gY3Rvck5hbWUodmFsKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsLmNvbnN0cnVjdG9yID09PSBcImZ1bmN0aW9uXCIgPyB2YWwuY29uc3RydWN0b3IubmFtZSA6IG51bGw7XG59XG5mdW5jdGlvbiBpc0Vycm9yKHZhbCkge1xuICByZXR1cm4gdmFsIGluc3RhbmNlb2YgRXJyb3IgfHwgdHlwZW9mIHZhbC5tZXNzYWdlID09PSBcInN0cmluZ1wiICYmIHZhbC5jb25zdHJ1Y3RvciAmJiB0eXBlb2YgdmFsLmNvbnN0cnVjdG9yLnN0YWNrVHJhY2VMaW1pdCA9PT0gXCJudW1iZXJcIjtcbn1cbmZ1bmN0aW9uIGlzRGF0ZSh2YWwpIHtcbiAgaWYgKHZhbCBpbnN0YW5jZW9mIERhdGUpXG4gICAgcmV0dXJuIHRydWU7XG4gIHJldHVybiB0eXBlb2YgdmFsLnRvRGF0ZVN0cmluZyA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiB2YWwuZ2V0RGF0ZSA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiB2YWwuc2V0RGF0ZSA9PT0gXCJmdW5jdGlvblwiO1xufVxuZnVuY3Rpb24ga2luZE9mKHZhbCkge1xuICBsZXQgdHlwZU9mVmFsID0gdHlwZW9mIHZhbDtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIHR5cGVPZlZhbCA9IG1pbmlLaW5kT2YodmFsKTtcbiAgfVxuICByZXR1cm4gdHlwZU9mVmFsO1xufVxuXG4vLyBzcmMvY3JlYXRlU3RvcmUudHNcbmZ1bmN0aW9uIGNyZWF0ZVN0b3JlKHJlZHVjZXIsIHByZWxvYWRlZFN0YXRlLCBlbmhhbmNlcikge1xuICBpZiAodHlwZW9mIHJlZHVjZXIgIT09IFwiZnVuY3Rpb25cIikge1xuICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDIpIDogYEV4cGVjdGVkIHRoZSByb290IHJlZHVjZXIgdG8gYmUgYSBmdW5jdGlvbi4gSW5zdGVhZCwgcmVjZWl2ZWQ6ICcke2tpbmRPZihyZWR1Y2VyKX0nYCk7XG4gIH1cbiAgaWYgKHR5cGVvZiBwcmVsb2FkZWRTdGF0ZSA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBlbmhhbmNlciA9PT0gXCJmdW5jdGlvblwiIHx8IHR5cGVvZiBlbmhhbmNlciA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBhcmd1bWVudHNbM10gPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDApIDogXCJJdCBsb29rcyBsaWtlIHlvdSBhcmUgcGFzc2luZyBzZXZlcmFsIHN0b3JlIGVuaGFuY2VycyB0byBjcmVhdGVTdG9yZSgpLiBUaGlzIGlzIG5vdCBzdXBwb3J0ZWQuIEluc3RlYWQsIGNvbXBvc2UgdGhlbSB0b2dldGhlciB0byBhIHNpbmdsZSBmdW5jdGlvbi4gU2VlIGh0dHBzOi8vcmVkdXguanMub3JnL3R1dG9yaWFscy9mdW5kYW1lbnRhbHMvcGFydC00LXN0b3JlI2NyZWF0aW5nLWEtc3RvcmUtd2l0aC1lbmhhbmNlcnMgZm9yIGFuIGV4YW1wbGUuXCIpO1xuICB9XG4gIGlmICh0eXBlb2YgcHJlbG9hZGVkU3RhdGUgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgZW5oYW5jZXIgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBlbmhhbmNlciA9IHByZWxvYWRlZFN0YXRlO1xuICAgIHByZWxvYWRlZFN0YXRlID0gdm9pZCAwO1xuICB9XG4gIGlmICh0eXBlb2YgZW5oYW5jZXIgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBpZiAodHlwZW9mIGVuaGFuY2VyICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDEpIDogYEV4cGVjdGVkIHRoZSBlbmhhbmNlciB0byBiZSBhIGZ1bmN0aW9uLiBJbnN0ZWFkLCByZWNlaXZlZDogJyR7a2luZE9mKGVuaGFuY2VyKX0nYCk7XG4gICAgfVxuICAgIHJldHVybiBlbmhhbmNlcihjcmVhdGVTdG9yZSkocmVkdWNlciwgcHJlbG9hZGVkU3RhdGUpO1xuICB9XG4gIGxldCBjdXJyZW50UmVkdWNlciA9IHJlZHVjZXI7XG4gIGxldCBjdXJyZW50U3RhdGUgPSBwcmVsb2FkZWRTdGF0ZTtcbiAgbGV0IGN1cnJlbnRMaXN0ZW5lcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBsZXQgbmV4dExpc3RlbmVycyA9IGN1cnJlbnRMaXN0ZW5lcnM7XG4gIGxldCBsaXN0ZW5lcklkQ291bnRlciA9IDA7XG4gIGxldCBpc0Rpc3BhdGNoaW5nID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGVuc3VyZUNhbk11dGF0ZU5leHRMaXN0ZW5lcnMoKSB7XG4gICAgaWYgKG5leHRMaXN0ZW5lcnMgPT09IGN1cnJlbnRMaXN0ZW5lcnMpIHtcbiAgICAgIG5leHRMaXN0ZW5lcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgY3VycmVudExpc3RlbmVycy5mb3JFYWNoKChsaXN0ZW5lciwga2V5KSA9PiB7XG4gICAgICAgIG5leHRMaXN0ZW5lcnMuc2V0KGtleSwgbGlzdGVuZXIpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGdldFN0YXRlKCkge1xuICAgIGlmIChpc0Rpc3BhdGNoaW5nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgzKSA6IFwiWW91IG1heSBub3QgY2FsbCBzdG9yZS5nZXRTdGF0ZSgpIHdoaWxlIHRoZSByZWR1Y2VyIGlzIGV4ZWN1dGluZy4gVGhlIHJlZHVjZXIgaGFzIGFscmVhZHkgcmVjZWl2ZWQgdGhlIHN0YXRlIGFzIGFuIGFyZ3VtZW50LiBQYXNzIGl0IGRvd24gZnJvbSB0aGUgdG9wIHJlZHVjZXIgaW5zdGVhZCBvZiByZWFkaW5nIGl0IGZyb20gdGhlIHN0b3JlLlwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGN1cnJlbnRTdGF0ZTtcbiAgfVxuICBmdW5jdGlvbiBzdWJzY3JpYmUobGlzdGVuZXIpIHtcbiAgICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDQpIDogYEV4cGVjdGVkIHRoZSBsaXN0ZW5lciB0byBiZSBhIGZ1bmN0aW9uLiBJbnN0ZWFkLCByZWNlaXZlZDogJyR7a2luZE9mKGxpc3RlbmVyKX0nYCk7XG4gICAgfVxuICAgIGlmIChpc0Rpc3BhdGNoaW5nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSg1KSA6IFwiWW91IG1heSBub3QgY2FsbCBzdG9yZS5zdWJzY3JpYmUoKSB3aGlsZSB0aGUgcmVkdWNlciBpcyBleGVjdXRpbmcuIElmIHlvdSB3b3VsZCBsaWtlIHRvIGJlIG5vdGlmaWVkIGFmdGVyIHRoZSBzdG9yZSBoYXMgYmVlbiB1cGRhdGVkLCBzdWJzY3JpYmUgZnJvbSBhIGNvbXBvbmVudCBhbmQgaW52b2tlIHN0b3JlLmdldFN0YXRlKCkgaW4gdGhlIGNhbGxiYWNrIHRvIGFjY2VzcyB0aGUgbGF0ZXN0IHN0YXRlLiBTZWUgaHR0cHM6Ly9yZWR1eC5qcy5vcmcvYXBpL3N0b3JlI3N1YnNjcmliZWxpc3RlbmVyIGZvciBtb3JlIGRldGFpbHMuXCIpO1xuICAgIH1cbiAgICBsZXQgaXNTdWJzY3JpYmVkID0gdHJ1ZTtcbiAgICBlbnN1cmVDYW5NdXRhdGVOZXh0TGlzdGVuZXJzKCk7XG4gICAgY29uc3QgbGlzdGVuZXJJZCA9IGxpc3RlbmVySWRDb3VudGVyKys7XG4gICAgbmV4dExpc3RlbmVycy5zZXQobGlzdGVuZXJJZCwgbGlzdGVuZXIpO1xuICAgIHJldHVybiBmdW5jdGlvbiB1bnN1YnNjcmliZSgpIHtcbiAgICAgIGlmICghaXNTdWJzY3JpYmVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChpc0Rpc3BhdGNoaW5nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDYpIDogXCJZb3UgbWF5IG5vdCB1bnN1YnNjcmliZSBmcm9tIGEgc3RvcmUgbGlzdGVuZXIgd2hpbGUgdGhlIHJlZHVjZXIgaXMgZXhlY3V0aW5nLiBTZWUgaHR0cHM6Ly9yZWR1eC5qcy5vcmcvYXBpL3N0b3JlI3N1YnNjcmliZWxpc3RlbmVyIGZvciBtb3JlIGRldGFpbHMuXCIpO1xuICAgICAgfVxuICAgICAgaXNTdWJzY3JpYmVkID0gZmFsc2U7XG4gICAgICBlbnN1cmVDYW5NdXRhdGVOZXh0TGlzdGVuZXJzKCk7XG4gICAgICBuZXh0TGlzdGVuZXJzLmRlbGV0ZShsaXN0ZW5lcklkKTtcbiAgICAgIGN1cnJlbnRMaXN0ZW5lcnMgPSBudWxsO1xuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gZGlzcGF0Y2goYWN0aW9uKSB7XG4gICAgaWYgKCFpc1BsYWluT2JqZWN0KGFjdGlvbikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDcpIDogYEFjdGlvbnMgbXVzdCBiZSBwbGFpbiBvYmplY3RzLiBJbnN0ZWFkLCB0aGUgYWN0dWFsIHR5cGUgd2FzOiAnJHtraW5kT2YoYWN0aW9uKX0nLiBZb3UgbWF5IG5lZWQgdG8gYWRkIG1pZGRsZXdhcmUgdG8geW91ciBzdG9yZSBzZXR1cCB0byBoYW5kbGUgZGlzcGF0Y2hpbmcgb3RoZXIgdmFsdWVzLCBzdWNoIGFzICdyZWR1eC10aHVuaycgdG8gaGFuZGxlIGRpc3BhdGNoaW5nIGZ1bmN0aW9ucy4gU2VlIGh0dHBzOi8vcmVkdXguanMub3JnL3R1dG9yaWFscy9mdW5kYW1lbnRhbHMvcGFydC00LXN0b3JlI21pZGRsZXdhcmUgYW5kIGh0dHBzOi8vcmVkdXguanMub3JnL3R1dG9yaWFscy9mdW5kYW1lbnRhbHMvcGFydC02LWFzeW5jLWxvZ2ljI3VzaW5nLXRoZS1yZWR1eC10aHVuay1taWRkbGV3YXJlIGZvciBleGFtcGxlcy5gKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBhY3Rpb24udHlwZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoOCkgOiAnQWN0aW9ucyBtYXkgbm90IGhhdmUgYW4gdW5kZWZpbmVkIFwidHlwZVwiIHByb3BlcnR5LiBZb3UgbWF5IGhhdmUgbWlzc3BlbGxlZCBhbiBhY3Rpb24gdHlwZSBzdHJpbmcgY29uc3RhbnQuJyk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgYWN0aW9uLnR5cGUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDE3KSA6IGBBY3Rpb24gXCJ0eXBlXCIgcHJvcGVydHkgbXVzdCBiZSBhIHN0cmluZy4gSW5zdGVhZCwgdGhlIGFjdHVhbCB0eXBlIHdhczogJyR7a2luZE9mKGFjdGlvbi50eXBlKX0nLiBWYWx1ZSB3YXM6ICcke2FjdGlvbi50eXBlfScgKHN0cmluZ2lmaWVkKWApO1xuICAgIH1cbiAgICBpZiAoaXNEaXNwYXRjaGluZykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoOSkgOiBcIlJlZHVjZXJzIG1heSBub3QgZGlzcGF0Y2ggYWN0aW9ucy5cIik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBpc0Rpc3BhdGNoaW5nID0gdHJ1ZTtcbiAgICAgIGN1cnJlbnRTdGF0ZSA9IGN1cnJlbnRSZWR1Y2VyKGN1cnJlbnRTdGF0ZSwgYWN0aW9uKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaXNEaXNwYXRjaGluZyA9IGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBsaXN0ZW5lcnMgPSBjdXJyZW50TGlzdGVuZXJzID0gbmV4dExpc3RlbmVycztcbiAgICBsaXN0ZW5lcnMuZm9yRWFjaCgobGlzdGVuZXIpID0+IHtcbiAgICAgIGxpc3RlbmVyKCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGFjdGlvbjtcbiAgfVxuICBmdW5jdGlvbiByZXBsYWNlUmVkdWNlcihuZXh0UmVkdWNlcikge1xuICAgIGlmICh0eXBlb2YgbmV4dFJlZHVjZXIgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMTApIDogYEV4cGVjdGVkIHRoZSBuZXh0UmVkdWNlciB0byBiZSBhIGZ1bmN0aW9uLiBJbnN0ZWFkLCByZWNlaXZlZDogJyR7a2luZE9mKG5leHRSZWR1Y2VyKX1gKTtcbiAgICB9XG4gICAgY3VycmVudFJlZHVjZXIgPSBuZXh0UmVkdWNlcjtcbiAgICBkaXNwYXRjaCh7XG4gICAgICB0eXBlOiBhY3Rpb25UeXBlc19kZWZhdWx0LlJFUExBQ0VcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBvYnNlcnZhYmxlKCkge1xuICAgIGNvbnN0IG91dGVyU3Vic2NyaWJlID0gc3Vic2NyaWJlO1xuICAgIHJldHVybiB7XG4gICAgICAvKipcbiAgICAgICAqIFRoZSBtaW5pbWFsIG9ic2VydmFibGUgc3Vic2NyaXB0aW9uIG1ldGhvZC5cbiAgICAgICAqIEBwYXJhbSBvYnNlcnZlciBBbnkgb2JqZWN0IHRoYXQgY2FuIGJlIHVzZWQgYXMgYW4gb2JzZXJ2ZXIuXG4gICAgICAgKiBUaGUgb2JzZXJ2ZXIgb2JqZWN0IHNob3VsZCBoYXZlIGEgYG5leHRgIG1ldGhvZC5cbiAgICAgICAqIEByZXR1cm5zIEFuIG9iamVjdCB3aXRoIGFuIGB1bnN1YnNjcmliZWAgbWV0aG9kIHRoYXQgY2FuXG4gICAgICAgKiBiZSB1c2VkIHRvIHVuc3Vic2NyaWJlIHRoZSBvYnNlcnZhYmxlIGZyb20gdGhlIHN0b3JlLCBhbmQgcHJldmVudCBmdXJ0aGVyXG4gICAgICAgKiBlbWlzc2lvbiBvZiB2YWx1ZXMgZnJvbSB0aGUgb2JzZXJ2YWJsZS5cbiAgICAgICAqL1xuICAgICAgc3Vic2NyaWJlKG9ic2VydmVyKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb2JzZXJ2ZXIgIT09IFwib2JqZWN0XCIgfHwgb2JzZXJ2ZXIgPT09IG51bGwpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgxMSkgOiBgRXhwZWN0ZWQgdGhlIG9ic2VydmVyIHRvIGJlIGFuIG9iamVjdC4gSW5zdGVhZCwgcmVjZWl2ZWQ6ICcke2tpbmRPZihvYnNlcnZlcil9J2ApO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIG9ic2VydmVTdGF0ZSgpIHtcbiAgICAgICAgICBjb25zdCBvYnNlcnZlckFzT2JzZXJ2ZXIgPSBvYnNlcnZlcjtcbiAgICAgICAgICBpZiAob2JzZXJ2ZXJBc09ic2VydmVyLm5leHQpIHtcbiAgICAgICAgICAgIG9ic2VydmVyQXNPYnNlcnZlci5uZXh0KGdldFN0YXRlKCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBvYnNlcnZlU3RhdGUoKTtcbiAgICAgICAgY29uc3QgdW5zdWJzY3JpYmUgPSBvdXRlclN1YnNjcmliZShvYnNlcnZlU3RhdGUpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHVuc3Vic2NyaWJlXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgW3N5bWJvbF9vYnNlcnZhYmxlX2RlZmF1bHRdKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIGRpc3BhdGNoKHtcbiAgICB0eXBlOiBhY3Rpb25UeXBlc19kZWZhdWx0LklOSVRcbiAgfSk7XG4gIGNvbnN0IHN0b3JlID0ge1xuICAgIGRpc3BhdGNoLFxuICAgIHN1YnNjcmliZSxcbiAgICBnZXRTdGF0ZSxcbiAgICByZXBsYWNlUmVkdWNlcixcbiAgICBbc3ltYm9sX29ic2VydmFibGVfZGVmYXVsdF06IG9ic2VydmFibGVcbiAgfTtcbiAgcmV0dXJuIHN0b3JlO1xufVxuZnVuY3Rpb24gbGVnYWN5X2NyZWF0ZVN0b3JlKHJlZHVjZXIsIHByZWxvYWRlZFN0YXRlLCBlbmhhbmNlcikge1xuICByZXR1cm4gY3JlYXRlU3RvcmUocmVkdWNlciwgcHJlbG9hZGVkU3RhdGUsIGVuaGFuY2VyKTtcbn1cblxuLy8gc3JjL3V0aWxzL3dhcm5pbmcudHNcbmZ1bmN0aW9uIHdhcm5pbmcobWVzc2FnZSkge1xuICBpZiAodHlwZW9mIGNvbnNvbGUgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIGNvbnNvbGUuZXJyb3IgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSk7XG4gIH1cbiAgdHJ5IHtcbiAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgfVxufVxuXG4vLyBzcmMvY29tYmluZVJlZHVjZXJzLnRzXG5mdW5jdGlvbiBnZXRVbmV4cGVjdGVkU3RhdGVTaGFwZVdhcm5pbmdNZXNzYWdlKGlucHV0U3RhdGUsIHJlZHVjZXJzLCBhY3Rpb24sIHVuZXhwZWN0ZWRLZXlDYWNoZSkge1xuICBjb25zdCByZWR1Y2VyS2V5cyA9IE9iamVjdC5rZXlzKHJlZHVjZXJzKTtcbiAgY29uc3QgYXJndW1lbnROYW1lID0gYWN0aW9uICYmIGFjdGlvbi50eXBlID09PSBhY3Rpb25UeXBlc19kZWZhdWx0LklOSVQgPyBcInByZWxvYWRlZFN0YXRlIGFyZ3VtZW50IHBhc3NlZCB0byBjcmVhdGVTdG9yZVwiIDogXCJwcmV2aW91cyBzdGF0ZSByZWNlaXZlZCBieSB0aGUgcmVkdWNlclwiO1xuICBpZiAocmVkdWNlcktleXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIFwiU3RvcmUgZG9lcyBub3QgaGF2ZSBhIHZhbGlkIHJlZHVjZXIuIE1ha2Ugc3VyZSB0aGUgYXJndW1lbnQgcGFzc2VkIHRvIGNvbWJpbmVSZWR1Y2VycyBpcyBhbiBvYmplY3Qgd2hvc2UgdmFsdWVzIGFyZSByZWR1Y2Vycy5cIjtcbiAgfVxuICBpZiAoIWlzUGxhaW5PYmplY3QoaW5wdXRTdGF0ZSkpIHtcbiAgICByZXR1cm4gYFRoZSAke2FyZ3VtZW50TmFtZX0gaGFzIHVuZXhwZWN0ZWQgdHlwZSBvZiBcIiR7a2luZE9mKGlucHV0U3RhdGUpfVwiLiBFeHBlY3RlZCBhcmd1bWVudCB0byBiZSBhbiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nIGtleXM6IFwiJHtyZWR1Y2VyS2V5cy5qb2luKCdcIiwgXCInKX1cImA7XG4gIH1cbiAgY29uc3QgdW5leHBlY3RlZEtleXMgPSBPYmplY3Qua2V5cyhpbnB1dFN0YXRlKS5maWx0ZXIoKGtleSkgPT4gIXJlZHVjZXJzLmhhc093blByb3BlcnR5KGtleSkgJiYgIXVuZXhwZWN0ZWRLZXlDYWNoZVtrZXldKTtcbiAgdW5leHBlY3RlZEtleXMuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgdW5leHBlY3RlZEtleUNhY2hlW2tleV0gPSB0cnVlO1xuICB9KTtcbiAgaWYgKGFjdGlvbiAmJiBhY3Rpb24udHlwZSA9PT0gYWN0aW9uVHlwZXNfZGVmYXVsdC5SRVBMQUNFKVxuICAgIHJldHVybjtcbiAgaWYgKHVuZXhwZWN0ZWRLZXlzLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gYFVuZXhwZWN0ZWQgJHt1bmV4cGVjdGVkS2V5cy5sZW5ndGggPiAxID8gXCJrZXlzXCIgOiBcImtleVwifSBcIiR7dW5leHBlY3RlZEtleXMuam9pbignXCIsIFwiJyl9XCIgZm91bmQgaW4gJHthcmd1bWVudE5hbWV9LiBFeHBlY3RlZCB0byBmaW5kIG9uZSBvZiB0aGUga25vd24gcmVkdWNlciBrZXlzIGluc3RlYWQ6IFwiJHtyZWR1Y2VyS2V5cy5qb2luKCdcIiwgXCInKX1cIi4gVW5leHBlY3RlZCBrZXlzIHdpbGwgYmUgaWdub3JlZC5gO1xuICB9XG59XG5mdW5jdGlvbiBhc3NlcnRSZWR1Y2VyU2hhcGUocmVkdWNlcnMpIHtcbiAgT2JqZWN0LmtleXMocmVkdWNlcnMpLmZvckVhY2goKGtleSkgPT4ge1xuICAgIGNvbnN0IHJlZHVjZXIgPSByZWR1Y2Vyc1trZXldO1xuICAgIGNvbnN0IGluaXRpYWxTdGF0ZSA9IHJlZHVjZXIodm9pZCAwLCB7XG4gICAgICB0eXBlOiBhY3Rpb25UeXBlc19kZWZhdWx0LklOSVRcbiAgICB9KTtcbiAgICBpZiAodHlwZW9mIGluaXRpYWxTdGF0ZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMTIpIDogYFRoZSBzbGljZSByZWR1Y2VyIGZvciBrZXkgXCIke2tleX1cIiByZXR1cm5lZCB1bmRlZmluZWQgZHVyaW5nIGluaXRpYWxpemF0aW9uLiBJZiB0aGUgc3RhdGUgcGFzc2VkIHRvIHRoZSByZWR1Y2VyIGlzIHVuZGVmaW5lZCwgeW91IG11c3QgZXhwbGljaXRseSByZXR1cm4gdGhlIGluaXRpYWwgc3RhdGUuIFRoZSBpbml0aWFsIHN0YXRlIG1heSBub3QgYmUgdW5kZWZpbmVkLiBJZiB5b3UgZG9uJ3Qgd2FudCB0byBzZXQgYSB2YWx1ZSBmb3IgdGhpcyByZWR1Y2VyLCB5b3UgY2FuIHVzZSBudWxsIGluc3RlYWQgb2YgdW5kZWZpbmVkLmApO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHJlZHVjZXIodm9pZCAwLCB7XG4gICAgICB0eXBlOiBhY3Rpb25UeXBlc19kZWZhdWx0LlBST0JFX1VOS05PV05fQUNUSU9OKClcbiAgICB9KSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMTMpIDogYFRoZSBzbGljZSByZWR1Y2VyIGZvciBrZXkgXCIke2tleX1cIiByZXR1cm5lZCB1bmRlZmluZWQgd2hlbiBwcm9iZWQgd2l0aCBhIHJhbmRvbSB0eXBlLiBEb24ndCB0cnkgdG8gaGFuZGxlICcke2FjdGlvblR5cGVzX2RlZmF1bHQuSU5JVH0nIG9yIG90aGVyIGFjdGlvbnMgaW4gXCJyZWR1eC8qXCIgbmFtZXNwYWNlLiBUaGV5IGFyZSBjb25zaWRlcmVkIHByaXZhdGUuIEluc3RlYWQsIHlvdSBtdXN0IHJldHVybiB0aGUgY3VycmVudCBzdGF0ZSBmb3IgYW55IHVua25vd24gYWN0aW9ucywgdW5sZXNzIGl0IGlzIHVuZGVmaW5lZCwgaW4gd2hpY2ggY2FzZSB5b3UgbXVzdCByZXR1cm4gdGhlIGluaXRpYWwgc3RhdGUsIHJlZ2FyZGxlc3Mgb2YgdGhlIGFjdGlvbiB0eXBlLiBUaGUgaW5pdGlhbCBzdGF0ZSBtYXkgbm90IGJlIHVuZGVmaW5lZCwgYnV0IGNhbiBiZSBudWxsLmApO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBjb21iaW5lUmVkdWNlcnMocmVkdWNlcnMpIHtcbiAgY29uc3QgcmVkdWNlcktleXMgPSBPYmplY3Qua2V5cyhyZWR1Y2Vycyk7XG4gIGNvbnN0IGZpbmFsUmVkdWNlcnMgPSB7fTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCByZWR1Y2VyS2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGtleSA9IHJlZHVjZXJLZXlzW2ldO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIGlmICh0eXBlb2YgcmVkdWNlcnNba2V5XSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICB3YXJuaW5nKGBObyByZWR1Y2VyIHByb3ZpZGVkIGZvciBrZXkgXCIke2tleX1cImApO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodHlwZW9mIHJlZHVjZXJzW2tleV0gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgZmluYWxSZWR1Y2Vyc1trZXldID0gcmVkdWNlcnNba2V5XTtcbiAgICB9XG4gIH1cbiAgY29uc3QgZmluYWxSZWR1Y2VyS2V5cyA9IE9iamVjdC5rZXlzKGZpbmFsUmVkdWNlcnMpO1xuICBsZXQgdW5leHBlY3RlZEtleUNhY2hlO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgdW5leHBlY3RlZEtleUNhY2hlID0ge307XG4gIH1cbiAgbGV0IHNoYXBlQXNzZXJ0aW9uRXJyb3I7XG4gIHRyeSB7XG4gICAgYXNzZXJ0UmVkdWNlclNoYXBlKGZpbmFsUmVkdWNlcnMpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgc2hhcGVBc3NlcnRpb25FcnJvciA9IGU7XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uIGNvbWJpbmF0aW9uKHN0YXRlID0ge30sIGFjdGlvbikge1xuICAgIGlmIChzaGFwZUFzc2VydGlvbkVycm9yKSB7XG4gICAgICB0aHJvdyBzaGFwZUFzc2VydGlvbkVycm9yO1xuICAgIH1cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICBjb25zdCB3YXJuaW5nTWVzc2FnZSA9IGdldFVuZXhwZWN0ZWRTdGF0ZVNoYXBlV2FybmluZ01lc3NhZ2Uoc3RhdGUsIGZpbmFsUmVkdWNlcnMsIGFjdGlvbiwgdW5leHBlY3RlZEtleUNhY2hlKTtcbiAgICAgIGlmICh3YXJuaW5nTWVzc2FnZSkge1xuICAgICAgICB3YXJuaW5nKHdhcm5pbmdNZXNzYWdlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IGhhc0NoYW5nZWQgPSBmYWxzZTtcbiAgICBjb25zdCBuZXh0U3RhdGUgPSB7fTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZpbmFsUmVkdWNlcktleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGtleSA9IGZpbmFsUmVkdWNlcktleXNbaV07XG4gICAgICBjb25zdCByZWR1Y2VyID0gZmluYWxSZWR1Y2Vyc1trZXldO1xuICAgICAgY29uc3QgcHJldmlvdXNTdGF0ZUZvcktleSA9IHN0YXRlW2tleV07XG4gICAgICBjb25zdCBuZXh0U3RhdGVGb3JLZXkgPSByZWR1Y2VyKHByZXZpb3VzU3RhdGVGb3JLZXksIGFjdGlvbik7XG4gICAgICBpZiAodHlwZW9mIG5leHRTdGF0ZUZvcktleSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBjb25zdCBhY3Rpb25UeXBlID0gYWN0aW9uICYmIGFjdGlvbi50eXBlO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgxNCkgOiBgV2hlbiBjYWxsZWQgd2l0aCBhbiBhY3Rpb24gb2YgdHlwZSAke2FjdGlvblR5cGUgPyBgXCIke1N0cmluZyhhY3Rpb25UeXBlKX1cImAgOiBcIih1bmtub3duIHR5cGUpXCJ9LCB0aGUgc2xpY2UgcmVkdWNlciBmb3Iga2V5IFwiJHtrZXl9XCIgcmV0dXJuZWQgdW5kZWZpbmVkLiBUbyBpZ25vcmUgYW4gYWN0aW9uLCB5b3UgbXVzdCBleHBsaWNpdGx5IHJldHVybiB0aGUgcHJldmlvdXMgc3RhdGUuIElmIHlvdSB3YW50IHRoaXMgcmVkdWNlciB0byBob2xkIG5vIHZhbHVlLCB5b3UgY2FuIHJldHVybiBudWxsIGluc3RlYWQgb2YgdW5kZWZpbmVkLmApO1xuICAgICAgfVxuICAgICAgbmV4dFN0YXRlW2tleV0gPSBuZXh0U3RhdGVGb3JLZXk7XG4gICAgICBoYXNDaGFuZ2VkID0gaGFzQ2hhbmdlZCB8fCBuZXh0U3RhdGVGb3JLZXkgIT09IHByZXZpb3VzU3RhdGVGb3JLZXk7XG4gICAgfVxuICAgIGhhc0NoYW5nZWQgPSBoYXNDaGFuZ2VkIHx8IGZpbmFsUmVkdWNlcktleXMubGVuZ3RoICE9PSBPYmplY3Qua2V5cyhzdGF0ZSkubGVuZ3RoO1xuICAgIHJldHVybiBoYXNDaGFuZ2VkID8gbmV4dFN0YXRlIDogc3RhdGU7XG4gIH07XG59XG5cbi8vIHNyYy9iaW5kQWN0aW9uQ3JlYXRvcnMudHNcbmZ1bmN0aW9uIGJpbmRBY3Rpb25DcmVhdG9yKGFjdGlvbkNyZWF0b3IsIGRpc3BhdGNoKSB7XG4gIHJldHVybiBmdW5jdGlvbiguLi5hcmdzKSB7XG4gICAgcmV0dXJuIGRpc3BhdGNoKGFjdGlvbkNyZWF0b3IuYXBwbHkodGhpcywgYXJncykpO1xuICB9O1xufVxuZnVuY3Rpb24gYmluZEFjdGlvbkNyZWF0b3JzKGFjdGlvbkNyZWF0b3JzLCBkaXNwYXRjaCkge1xuICBpZiAodHlwZW9mIGFjdGlvbkNyZWF0b3JzID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICByZXR1cm4gYmluZEFjdGlvbkNyZWF0b3IoYWN0aW9uQ3JlYXRvcnMsIGRpc3BhdGNoKTtcbiAgfVxuICBpZiAodHlwZW9mIGFjdGlvbkNyZWF0b3JzICE9PSBcIm9iamVjdFwiIHx8IGFjdGlvbkNyZWF0b3JzID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMTYpIDogYGJpbmRBY3Rpb25DcmVhdG9ycyBleHBlY3RlZCBhbiBvYmplY3Qgb3IgYSBmdW5jdGlvbiwgYnV0IGluc3RlYWQgcmVjZWl2ZWQ6ICcke2tpbmRPZihhY3Rpb25DcmVhdG9ycyl9Jy4gRGlkIHlvdSB3cml0ZSBcImltcG9ydCBBY3Rpb25DcmVhdG9ycyBmcm9tXCIgaW5zdGVhZCBvZiBcImltcG9ydCAqIGFzIEFjdGlvbkNyZWF0b3JzIGZyb21cIj9gKTtcbiAgfVxuICBjb25zdCBib3VuZEFjdGlvbkNyZWF0b3JzID0ge307XG4gIGZvciAoY29uc3Qga2V5IGluIGFjdGlvbkNyZWF0b3JzKSB7XG4gICAgY29uc3QgYWN0aW9uQ3JlYXRvciA9IGFjdGlvbkNyZWF0b3JzW2tleV07XG4gICAgaWYgKHR5cGVvZiBhY3Rpb25DcmVhdG9yID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGJvdW5kQWN0aW9uQ3JlYXRvcnNba2V5XSA9IGJpbmRBY3Rpb25DcmVhdG9yKGFjdGlvbkNyZWF0b3IsIGRpc3BhdGNoKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGJvdW5kQWN0aW9uQ3JlYXRvcnM7XG59XG5cbi8vIHNyYy9jb21wb3NlLnRzXG5mdW5jdGlvbiBjb21wb3NlKC4uLmZ1bmNzKSB7XG4gIGlmIChmdW5jcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gKGFyZykgPT4gYXJnO1xuICB9XG4gIGlmIChmdW5jcy5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gZnVuY3NbMF07XG4gIH1cbiAgcmV0dXJuIGZ1bmNzLnJlZHVjZSgoYSwgYikgPT4gKC4uLmFyZ3MpID0+IGEoYiguLi5hcmdzKSkpO1xufVxuXG4vLyBzcmMvYXBwbHlNaWRkbGV3YXJlLnRzXG5mdW5jdGlvbiBhcHBseU1pZGRsZXdhcmUoLi4ubWlkZGxld2FyZXMpIHtcbiAgcmV0dXJuIChjcmVhdGVTdG9yZTIpID0+IChyZWR1Y2VyLCBwcmVsb2FkZWRTdGF0ZSkgPT4ge1xuICAgIGNvbnN0IHN0b3JlID0gY3JlYXRlU3RvcmUyKHJlZHVjZXIsIHByZWxvYWRlZFN0YXRlKTtcbiAgICBsZXQgZGlzcGF0Y2ggPSAoKSA9PiB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgxNSkgOiBcIkRpc3BhdGNoaW5nIHdoaWxlIGNvbnN0cnVjdGluZyB5b3VyIG1pZGRsZXdhcmUgaXMgbm90IGFsbG93ZWQuIE90aGVyIG1pZGRsZXdhcmUgd291bGQgbm90IGJlIGFwcGxpZWQgdG8gdGhpcyBkaXNwYXRjaC5cIik7XG4gICAgfTtcbiAgICBjb25zdCBtaWRkbGV3YXJlQVBJID0ge1xuICAgICAgZ2V0U3RhdGU6IHN0b3JlLmdldFN0YXRlLFxuICAgICAgZGlzcGF0Y2g6IChhY3Rpb24sIC4uLmFyZ3MpID0+IGRpc3BhdGNoKGFjdGlvbiwgLi4uYXJncylcbiAgICB9O1xuICAgIGNvbnN0IGNoYWluID0gbWlkZGxld2FyZXMubWFwKChtaWRkbGV3YXJlKSA9PiBtaWRkbGV3YXJlKG1pZGRsZXdhcmVBUEkpKTtcbiAgICBkaXNwYXRjaCA9IGNvbXBvc2UoLi4uY2hhaW4pKHN0b3JlLmRpc3BhdGNoKTtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uc3RvcmUsXG4gICAgICBkaXNwYXRjaFxuICAgIH07XG4gIH07XG59XG5cbi8vIHNyYy91dGlscy9pc0FjdGlvbi50c1xuZnVuY3Rpb24gaXNBY3Rpb24oYWN0aW9uKSB7XG4gIHJldHVybiBpc1BsYWluT2JqZWN0KGFjdGlvbikgJiYgXCJ0eXBlXCIgaW4gYWN0aW9uICYmIHR5cGVvZiBhY3Rpb24udHlwZSA9PT0gXCJzdHJpbmdcIjtcbn1cbmV4cG9ydCB7XG4gIGFjdGlvblR5cGVzX2RlZmF1bHQgYXMgX19ET19OT1RfVVNFX19BY3Rpb25UeXBlcyxcbiAgYXBwbHlNaWRkbGV3YXJlLFxuICBiaW5kQWN0aW9uQ3JlYXRvcnMsXG4gIGNvbWJpbmVSZWR1Y2VycyxcbiAgY29tcG9zZSxcbiAgY3JlYXRlU3RvcmUsXG4gIGlzQWN0aW9uLFxuICBpc1BsYWluT2JqZWN0LFxuICBsZWdhY3lfY3JlYXRlU3RvcmVcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZWR1eC5tanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/redux/dist/redux.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/reselect/dist/reselect.mjs":
/*!*************************************************!*\
  !*** ./node_modules/reselect/dist/reselect.mjs ***!
  \*************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createSelector: function() { return /* binding */ createSelector; },\n/* harmony export */   createSelectorCreator: function() { return /* binding */ createSelectorCreator; },\n/* harmony export */   createStructuredSelector: function() { return /* binding */ createStructuredSelector; },\n/* harmony export */   lruMemoize: function() { return /* binding */ lruMemoize; },\n/* harmony export */   referenceEqualityCheck: function() { return /* binding */ referenceEqualityCheck; },\n/* harmony export */   setGlobalDevModeChecks: function() { return /* binding */ setGlobalDevModeChecks; },\n/* harmony export */   unstable_autotrackMemoize: function() { return /* binding */ autotrackMemoize; },\n/* harmony export */   weakMapMemoize: function() { return /* binding */ weakMapMemoize; }\n/* harmony export */ });\n// src/devModeChecks/identityFunctionCheck.ts\nvar runIdentityFunctionCheck = (resultFunc, inputSelectorsResults, outputSelectorResult) => {\n  if (inputSelectorsResults.length === 1 && inputSelectorsResults[0] === outputSelectorResult) {\n    let isInputSameAsOutput = false;\n    try {\n      const emptyObject = {};\n      if (resultFunc(emptyObject) === emptyObject)\n        isInputSameAsOutput = true;\n    } catch {\n    }\n    if (isInputSameAsOutput) {\n      let stack = void 0;\n      try {\n        throw new Error();\n      } catch (e) {\n        ;\n        ({ stack } = e);\n      }\n      console.warn(\n        \"The result function returned its own inputs without modification. e.g\\n`createSelector([state => state.todos], todos => todos)`\\nThis could lead to inefficient memoization and unnecessary re-renders.\\nEnsure transformation logic is in the result function, and extraction logic is in the input selectors.\",\n        { stack }\n      );\n    }\n  }\n};\n\n// src/devModeChecks/inputStabilityCheck.ts\nvar runInputStabilityCheck = (inputSelectorResultsObject, options, inputSelectorArgs) => {\n  const { memoize, memoizeOptions } = options;\n  const { inputSelectorResults, inputSelectorResultsCopy } = inputSelectorResultsObject;\n  const createAnEmptyObject = memoize(() => ({}), ...memoizeOptions);\n  const areInputSelectorResultsEqual = createAnEmptyObject.apply(null, inputSelectorResults) === createAnEmptyObject.apply(null, inputSelectorResultsCopy);\n  if (!areInputSelectorResultsEqual) {\n    let stack = void 0;\n    try {\n      throw new Error();\n    } catch (e) {\n      ;\n      ({ stack } = e);\n    }\n    console.warn(\n      \"An input selector returned a different result when passed same arguments.\\nThis means your output selector will likely run more frequently than intended.\\nAvoid returning a new reference inside your input selector, e.g.\\n`createSelector([state => state.todos.map(todo => todo.id)], todoIds => todoIds.length)`\",\n      {\n        arguments: inputSelectorArgs,\n        firstInputs: inputSelectorResults,\n        secondInputs: inputSelectorResultsCopy,\n        stack\n      }\n    );\n  }\n};\n\n// src/devModeChecks/setGlobalDevModeChecks.ts\nvar globalDevModeChecks = {\n  inputStabilityCheck: \"once\",\n  identityFunctionCheck: \"once\"\n};\nvar setGlobalDevModeChecks = (devModeChecks) => {\n  Object.assign(globalDevModeChecks, devModeChecks);\n};\n\n// src/utils.ts\nvar NOT_FOUND = \"NOT_FOUND\";\nfunction assertIsFunction(func, errorMessage = `expected a function, instead received ${typeof func}`) {\n  if (typeof func !== \"function\") {\n    throw new TypeError(errorMessage);\n  }\n}\nfunction assertIsObject(object, errorMessage = `expected an object, instead received ${typeof object}`) {\n  if (typeof object !== \"object\") {\n    throw new TypeError(errorMessage);\n  }\n}\nfunction assertIsArrayOfFunctions(array, errorMessage = `expected all items to be functions, instead received the following types: `) {\n  if (!array.every((item) => typeof item === \"function\")) {\n    const itemTypes = array.map(\n      (item) => typeof item === \"function\" ? `function ${item.name || \"unnamed\"}()` : typeof item\n    ).join(\", \");\n    throw new TypeError(`${errorMessage}[${itemTypes}]`);\n  }\n}\nvar ensureIsArray = (item) => {\n  return Array.isArray(item) ? item : [item];\n};\nfunction getDependencies(createSelectorArgs) {\n  const dependencies = Array.isArray(createSelectorArgs[0]) ? createSelectorArgs[0] : createSelectorArgs;\n  assertIsArrayOfFunctions(\n    dependencies,\n    `createSelector expects all input-selectors to be functions, but received the following types: `\n  );\n  return dependencies;\n}\nfunction collectInputSelectorResults(dependencies, inputSelectorArgs) {\n  const inputSelectorResults = [];\n  const { length } = dependencies;\n  for (let i = 0; i < length; i++) {\n    inputSelectorResults.push(dependencies[i].apply(null, inputSelectorArgs));\n  }\n  return inputSelectorResults;\n}\nvar getDevModeChecksExecutionInfo = (firstRun, devModeChecks) => {\n  const { identityFunctionCheck, inputStabilityCheck } = {\n    ...globalDevModeChecks,\n    ...devModeChecks\n  };\n  return {\n    identityFunctionCheck: {\n      shouldRun: identityFunctionCheck === \"always\" || identityFunctionCheck === \"once\" && firstRun,\n      run: runIdentityFunctionCheck\n    },\n    inputStabilityCheck: {\n      shouldRun: inputStabilityCheck === \"always\" || inputStabilityCheck === \"once\" && firstRun,\n      run: runInputStabilityCheck\n    }\n  };\n};\n\n// src/autotrackMemoize/autotracking.ts\nvar $REVISION = 0;\nvar CURRENT_TRACKER = null;\nvar Cell = class {\n  revision = $REVISION;\n  _value;\n  _lastValue;\n  _isEqual = tripleEq;\n  constructor(initialValue, isEqual = tripleEq) {\n    this._value = this._lastValue = initialValue;\n    this._isEqual = isEqual;\n  }\n  // Whenever a storage value is read, it'll add itself to the current tracker if\n  // one exists, entangling its state with that cache.\n  get value() {\n    CURRENT_TRACKER?.add(this);\n    return this._value;\n  }\n  // Whenever a storage value is updated, we bump the global revision clock,\n  // assign the revision for this storage to the new value, _and_ we schedule a\n  // rerender. This is important, and it's what makes autotracking  _pull_\n  // based. We don't actively tell the caches which depend on the storage that\n  // anything has happened. Instead, we recompute the caches when needed.\n  set value(newValue) {\n    if (this.value === newValue)\n      return;\n    this._value = newValue;\n    this.revision = ++$REVISION;\n  }\n};\nfunction tripleEq(a, b) {\n  return a === b;\n}\nvar TrackingCache = class {\n  _cachedValue;\n  _cachedRevision = -1;\n  _deps = [];\n  hits = 0;\n  fn;\n  constructor(fn) {\n    this.fn = fn;\n  }\n  clear() {\n    this._cachedValue = void 0;\n    this._cachedRevision = -1;\n    this._deps = [];\n    this.hits = 0;\n  }\n  get value() {\n    if (this.revision > this._cachedRevision) {\n      const { fn } = this;\n      const currentTracker = /* @__PURE__ */ new Set();\n      const prevTracker = CURRENT_TRACKER;\n      CURRENT_TRACKER = currentTracker;\n      this._cachedValue = fn();\n      CURRENT_TRACKER = prevTracker;\n      this.hits++;\n      this._deps = Array.from(currentTracker);\n      this._cachedRevision = this.revision;\n    }\n    CURRENT_TRACKER?.add(this);\n    return this._cachedValue;\n  }\n  get revision() {\n    return Math.max(...this._deps.map((d) => d.revision), 0);\n  }\n};\nfunction getValue(cell) {\n  if (!(cell instanceof Cell)) {\n    console.warn(\"Not a valid cell! \", cell);\n  }\n  return cell.value;\n}\nfunction setValue(storage, value) {\n  if (!(storage instanceof Cell)) {\n    throw new TypeError(\n      \"setValue must be passed a tracked store created with `createStorage`.\"\n    );\n  }\n  storage.value = storage._lastValue = value;\n}\nfunction createCell(initialValue, isEqual = tripleEq) {\n  return new Cell(initialValue, isEqual);\n}\nfunction createCache(fn) {\n  assertIsFunction(\n    fn,\n    \"the first parameter to `createCache` must be a function\"\n  );\n  return new TrackingCache(fn);\n}\n\n// src/autotrackMemoize/tracking.ts\nvar neverEq = (a, b) => false;\nfunction createTag() {\n  return createCell(null, neverEq);\n}\nfunction dirtyTag(tag, value) {\n  setValue(tag, value);\n}\nvar consumeCollection = (node) => {\n  let tag = node.collectionTag;\n  if (tag === null) {\n    tag = node.collectionTag = createTag();\n  }\n  getValue(tag);\n};\nvar dirtyCollection = (node) => {\n  const tag = node.collectionTag;\n  if (tag !== null) {\n    dirtyTag(tag, null);\n  }\n};\n\n// src/autotrackMemoize/proxy.ts\nvar REDUX_PROXY_LABEL = Symbol();\nvar nextId = 0;\nvar proto = Object.getPrototypeOf({});\nvar ObjectTreeNode = class {\n  constructor(value) {\n    this.value = value;\n    this.value = value;\n    this.tag.value = value;\n  }\n  proxy = new Proxy(this, objectProxyHandler);\n  tag = createTag();\n  tags = {};\n  children = {};\n  collectionTag = null;\n  id = nextId++;\n};\nvar objectProxyHandler = {\n  get(node, key) {\n    function calculateResult() {\n      const { value } = node;\n      const childValue = Reflect.get(value, key);\n      if (typeof key === \"symbol\") {\n        return childValue;\n      }\n      if (key in proto) {\n        return childValue;\n      }\n      if (typeof childValue === \"object\" && childValue !== null) {\n        let childNode = node.children[key];\n        if (childNode === void 0) {\n          childNode = node.children[key] = createNode(childValue);\n        }\n        if (childNode.tag) {\n          getValue(childNode.tag);\n        }\n        return childNode.proxy;\n      } else {\n        let tag = node.tags[key];\n        if (tag === void 0) {\n          tag = node.tags[key] = createTag();\n          tag.value = childValue;\n        }\n        getValue(tag);\n        return childValue;\n      }\n    }\n    const res = calculateResult();\n    return res;\n  },\n  ownKeys(node) {\n    consumeCollection(node);\n    return Reflect.ownKeys(node.value);\n  },\n  getOwnPropertyDescriptor(node, prop) {\n    return Reflect.getOwnPropertyDescriptor(node.value, prop);\n  },\n  has(node, prop) {\n    return Reflect.has(node.value, prop);\n  }\n};\nvar ArrayTreeNode = class {\n  constructor(value) {\n    this.value = value;\n    this.value = value;\n    this.tag.value = value;\n  }\n  proxy = new Proxy([this], arrayProxyHandler);\n  tag = createTag();\n  tags = {};\n  children = {};\n  collectionTag = null;\n  id = nextId++;\n};\nvar arrayProxyHandler = {\n  get([node], key) {\n    if (key === \"length\") {\n      consumeCollection(node);\n    }\n    return objectProxyHandler.get(node, key);\n  },\n  ownKeys([node]) {\n    return objectProxyHandler.ownKeys(node);\n  },\n  getOwnPropertyDescriptor([node], prop) {\n    return objectProxyHandler.getOwnPropertyDescriptor(node, prop);\n  },\n  has([node], prop) {\n    return objectProxyHandler.has(node, prop);\n  }\n};\nfunction createNode(value) {\n  if (Array.isArray(value)) {\n    return new ArrayTreeNode(value);\n  }\n  return new ObjectTreeNode(value);\n}\nfunction updateNode(node, newValue) {\n  const { value, tags, children } = node;\n  node.value = newValue;\n  if (Array.isArray(value) && Array.isArray(newValue) && value.length !== newValue.length) {\n    dirtyCollection(node);\n  } else {\n    if (value !== newValue) {\n      let oldKeysSize = 0;\n      let newKeysSize = 0;\n      let anyKeysAdded = false;\n      for (const _key in value) {\n        oldKeysSize++;\n      }\n      for (const key in newValue) {\n        newKeysSize++;\n        if (!(key in value)) {\n          anyKeysAdded = true;\n          break;\n        }\n      }\n      const isDifferent = anyKeysAdded || oldKeysSize !== newKeysSize;\n      if (isDifferent) {\n        dirtyCollection(node);\n      }\n    }\n  }\n  for (const key in tags) {\n    const childValue = value[key];\n    const newChildValue = newValue[key];\n    if (childValue !== newChildValue) {\n      dirtyCollection(node);\n      dirtyTag(tags[key], newChildValue);\n    }\n    if (typeof newChildValue === \"object\" && newChildValue !== null) {\n      delete tags[key];\n    }\n  }\n  for (const key in children) {\n    const childNode = children[key];\n    const newChildValue = newValue[key];\n    const childValue = childNode.value;\n    if (childValue === newChildValue) {\n      continue;\n    } else if (typeof newChildValue === \"object\" && newChildValue !== null) {\n      updateNode(childNode, newChildValue);\n    } else {\n      deleteNode(childNode);\n      delete children[key];\n    }\n  }\n}\nfunction deleteNode(node) {\n  if (node.tag) {\n    dirtyTag(node.tag, null);\n  }\n  dirtyCollection(node);\n  for (const key in node.tags) {\n    dirtyTag(node.tags[key], null);\n  }\n  for (const key in node.children) {\n    deleteNode(node.children[key]);\n  }\n}\n\n// src/lruMemoize.ts\nfunction createSingletonCache(equals) {\n  let entry;\n  return {\n    get(key) {\n      if (entry && equals(entry.key, key)) {\n        return entry.value;\n      }\n      return NOT_FOUND;\n    },\n    put(key, value) {\n      entry = { key, value };\n    },\n    getEntries() {\n      return entry ? [entry] : [];\n    },\n    clear() {\n      entry = void 0;\n    }\n  };\n}\nfunction createLruCache(maxSize, equals) {\n  let entries = [];\n  function get(key) {\n    const cacheIndex = entries.findIndex((entry) => equals(key, entry.key));\n    if (cacheIndex > -1) {\n      const entry = entries[cacheIndex];\n      if (cacheIndex > 0) {\n        entries.splice(cacheIndex, 1);\n        entries.unshift(entry);\n      }\n      return entry.value;\n    }\n    return NOT_FOUND;\n  }\n  function put(key, value) {\n    if (get(key) === NOT_FOUND) {\n      entries.unshift({ key, value });\n      if (entries.length > maxSize) {\n        entries.pop();\n      }\n    }\n  }\n  function getEntries() {\n    return entries;\n  }\n  function clear() {\n    entries = [];\n  }\n  return { get, put, getEntries, clear };\n}\nvar referenceEqualityCheck = (a, b) => a === b;\nfunction createCacheKeyComparator(equalityCheck) {\n  return function areArgumentsShallowlyEqual(prev, next) {\n    if (prev === null || next === null || prev.length !== next.length) {\n      return false;\n    }\n    const { length } = prev;\n    for (let i = 0; i < length; i++) {\n      if (!equalityCheck(prev[i], next[i])) {\n        return false;\n      }\n    }\n    return true;\n  };\n}\nfunction lruMemoize(func, equalityCheckOrOptions) {\n  const providedOptions = typeof equalityCheckOrOptions === \"object\" ? equalityCheckOrOptions : { equalityCheck: equalityCheckOrOptions };\n  const {\n    equalityCheck = referenceEqualityCheck,\n    maxSize = 1,\n    resultEqualityCheck\n  } = providedOptions;\n  const comparator = createCacheKeyComparator(equalityCheck);\n  let resultsCount = 0;\n  const cache = maxSize === 1 ? createSingletonCache(comparator) : createLruCache(maxSize, comparator);\n  function memoized() {\n    let value = cache.get(arguments);\n    if (value === NOT_FOUND) {\n      value = func.apply(null, arguments);\n      resultsCount++;\n      if (resultEqualityCheck) {\n        const entries = cache.getEntries();\n        const matchingEntry = entries.find(\n          (entry) => resultEqualityCheck(entry.value, value)\n        );\n        if (matchingEntry) {\n          value = matchingEntry.value;\n          resultsCount !== 0 && resultsCount--;\n        }\n      }\n      cache.put(arguments, value);\n    }\n    return value;\n  }\n  memoized.clearCache = () => {\n    cache.clear();\n    memoized.resetResultsCount();\n  };\n  memoized.resultsCount = () => resultsCount;\n  memoized.resetResultsCount = () => {\n    resultsCount = 0;\n  };\n  return memoized;\n}\n\n// src/autotrackMemoize/autotrackMemoize.ts\nfunction autotrackMemoize(func) {\n  const node = createNode(\n    []\n  );\n  let lastArgs = null;\n  const shallowEqual = createCacheKeyComparator(referenceEqualityCheck);\n  const cache = createCache(() => {\n    const res = func.apply(null, node.proxy);\n    return res;\n  });\n  function memoized() {\n    if (!shallowEqual(lastArgs, arguments)) {\n      updateNode(node, arguments);\n      lastArgs = arguments;\n    }\n    return cache.value;\n  }\n  memoized.clearCache = () => {\n    return cache.clear();\n  };\n  return memoized;\n}\n\n// src/weakMapMemoize.ts\nvar StrongRef = class {\n  constructor(value) {\n    this.value = value;\n  }\n  deref() {\n    return this.value;\n  }\n};\nvar Ref = typeof WeakRef !== \"undefined\" ? WeakRef : StrongRef;\nvar UNTERMINATED = 0;\nvar TERMINATED = 1;\nfunction createCacheNode() {\n  return {\n    s: UNTERMINATED,\n    v: void 0,\n    o: null,\n    p: null\n  };\n}\nfunction weakMapMemoize(func, options = {}) {\n  let fnNode = createCacheNode();\n  const { resultEqualityCheck } = options;\n  let lastResult;\n  let resultsCount = 0;\n  function memoized() {\n    let cacheNode = fnNode;\n    const { length } = arguments;\n    for (let i = 0, l = length; i < l; i++) {\n      const arg = arguments[i];\n      if (typeof arg === \"function\" || typeof arg === \"object\" && arg !== null) {\n        let objectCache = cacheNode.o;\n        if (objectCache === null) {\n          cacheNode.o = objectCache = /* @__PURE__ */ new WeakMap();\n        }\n        const objectNode = objectCache.get(arg);\n        if (objectNode === void 0) {\n          cacheNode = createCacheNode();\n          objectCache.set(arg, cacheNode);\n        } else {\n          cacheNode = objectNode;\n        }\n      } else {\n        let primitiveCache = cacheNode.p;\n        if (primitiveCache === null) {\n          cacheNode.p = primitiveCache = /* @__PURE__ */ new Map();\n        }\n        const primitiveNode = primitiveCache.get(arg);\n        if (primitiveNode === void 0) {\n          cacheNode = createCacheNode();\n          primitiveCache.set(arg, cacheNode);\n        } else {\n          cacheNode = primitiveNode;\n        }\n      }\n    }\n    const terminatedNode = cacheNode;\n    let result;\n    if (cacheNode.s === TERMINATED) {\n      result = cacheNode.v;\n    } else {\n      result = func.apply(null, arguments);\n      resultsCount++;\n    }\n    terminatedNode.s = TERMINATED;\n    if (resultEqualityCheck) {\n      const lastResultValue = lastResult?.deref?.() ?? lastResult;\n      if (lastResultValue != null && resultEqualityCheck(lastResultValue, result)) {\n        result = lastResultValue;\n        resultsCount !== 0 && resultsCount--;\n      }\n      const needsWeakRef = typeof result === \"object\" && result !== null || typeof result === \"function\";\n      lastResult = needsWeakRef ? new Ref(result) : result;\n    }\n    terminatedNode.v = result;\n    return result;\n  }\n  memoized.clearCache = () => {\n    fnNode = createCacheNode();\n    memoized.resetResultsCount();\n  };\n  memoized.resultsCount = () => resultsCount;\n  memoized.resetResultsCount = () => {\n    resultsCount = 0;\n  };\n  return memoized;\n}\n\n// src/createSelectorCreator.ts\nfunction createSelectorCreator(memoizeOrOptions, ...memoizeOptionsFromArgs) {\n  const createSelectorCreatorOptions = typeof memoizeOrOptions === \"function\" ? {\n    memoize: memoizeOrOptions,\n    memoizeOptions: memoizeOptionsFromArgs\n  } : memoizeOrOptions;\n  const createSelector2 = (...createSelectorArgs) => {\n    let recomputations = 0;\n    let dependencyRecomputations = 0;\n    let lastResult;\n    let directlyPassedOptions = {};\n    let resultFunc = createSelectorArgs.pop();\n    if (typeof resultFunc === \"object\") {\n      directlyPassedOptions = resultFunc;\n      resultFunc = createSelectorArgs.pop();\n    }\n    assertIsFunction(\n      resultFunc,\n      `createSelector expects an output function after the inputs, but received: [${typeof resultFunc}]`\n    );\n    const combinedOptions = {\n      ...createSelectorCreatorOptions,\n      ...directlyPassedOptions\n    };\n    const {\n      memoize,\n      memoizeOptions = [],\n      argsMemoize = weakMapMemoize,\n      argsMemoizeOptions = [],\n      devModeChecks = {}\n    } = combinedOptions;\n    const finalMemoizeOptions = ensureIsArray(memoizeOptions);\n    const finalArgsMemoizeOptions = ensureIsArray(argsMemoizeOptions);\n    const dependencies = getDependencies(createSelectorArgs);\n    const memoizedResultFunc = memoize(function recomputationWrapper() {\n      recomputations++;\n      return resultFunc.apply(\n        null,\n        arguments\n      );\n    }, ...finalMemoizeOptions);\n    let firstRun = true;\n    const selector = argsMemoize(function dependenciesChecker() {\n      dependencyRecomputations++;\n      const inputSelectorResults = collectInputSelectorResults(\n        dependencies,\n        arguments\n      );\n      lastResult = memoizedResultFunc.apply(null, inputSelectorResults);\n      if (true) {\n        const { identityFunctionCheck, inputStabilityCheck } = getDevModeChecksExecutionInfo(firstRun, devModeChecks);\n        if (identityFunctionCheck.shouldRun) {\n          identityFunctionCheck.run(\n            resultFunc,\n            inputSelectorResults,\n            lastResult\n          );\n        }\n        if (inputStabilityCheck.shouldRun) {\n          const inputSelectorResultsCopy = collectInputSelectorResults(\n            dependencies,\n            arguments\n          );\n          inputStabilityCheck.run(\n            { inputSelectorResults, inputSelectorResultsCopy },\n            { memoize, memoizeOptions: finalMemoizeOptions },\n            arguments\n          );\n        }\n        if (firstRun)\n          firstRun = false;\n      }\n      return lastResult;\n    }, ...finalArgsMemoizeOptions);\n    return Object.assign(selector, {\n      resultFunc,\n      memoizedResultFunc,\n      dependencies,\n      dependencyRecomputations: () => dependencyRecomputations,\n      resetDependencyRecomputations: () => {\n        dependencyRecomputations = 0;\n      },\n      lastResult: () => lastResult,\n      recomputations: () => recomputations,\n      resetRecomputations: () => {\n        recomputations = 0;\n      },\n      memoize,\n      argsMemoize\n    });\n  };\n  Object.assign(createSelector2, {\n    withTypes: () => createSelector2\n  });\n  return createSelector2;\n}\nvar createSelector = /* @__PURE__ */ createSelectorCreator(weakMapMemoize);\n\n// src/createStructuredSelector.ts\nvar createStructuredSelector = Object.assign(\n  (inputSelectorsObject, selectorCreator = createSelector) => {\n    assertIsObject(\n      inputSelectorsObject,\n      `createStructuredSelector expects first argument to be an object where each property is a selector, instead received a ${typeof inputSelectorsObject}`\n    );\n    const inputSelectorKeys = Object.keys(inputSelectorsObject);\n    const dependencies = inputSelectorKeys.map(\n      (key) => inputSelectorsObject[key]\n    );\n    const structuredSelector = selectorCreator(\n      dependencies,\n      (...inputSelectorResults) => {\n        return inputSelectorResults.reduce((composition, value, index) => {\n          composition[inputSelectorKeys[index]] = value;\n          return composition;\n        }, {});\n      }\n    );\n    return structuredSelector;\n  },\n  { withTypes: () => createStructuredSelector }\n);\n\n//# sourceMappingURL=reselect.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZXNlbGVjdC9kaXN0L3Jlc2VsZWN0Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVUsMEJBQTBCO0FBQ3BDLFVBQVUsaURBQWlEO0FBQzNELCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsU0FBUyxRQUFRO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3RkFBd0YsWUFBWTtBQUNwRztBQUNBO0FBQ0E7QUFDQTtBQUNBLHVGQUF1RixjQUFjO0FBQ3JHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELHVCQUF1QjtBQUNoRjtBQUNBLDJCQUEyQixhQUFhLEdBQUcsVUFBVTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFNBQVM7QUFDbkIsa0JBQWtCLFlBQVk7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsNkNBQTZDO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxLQUFLO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSx3QkFBd0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0JBQWdCO0FBQ2hCLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixZQUFZO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFNBQVM7QUFDckIsb0JBQW9CLFlBQVk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtHQUFrRztBQUNsRztBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0EsVUFBVSxzQkFBc0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFNBQVM7QUFDckIsZ0NBQWdDLE9BQU87QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9GQUFvRixrQkFBa0I7QUFDdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsSUFBcUM7QUFDL0MsZ0JBQWdCLDZDQUE2QztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsZ0RBQWdEO0FBQzlELGNBQWMsOENBQThDO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0hBQStILDRCQUE0QjtBQUMzSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxJQUFJO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILElBQUk7QUFDSjtBQVVFO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3Jlc2VsZWN0L2Rpc3QvcmVzZWxlY3QubWpzPzNiOTEiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL2Rldk1vZGVDaGVja3MvaWRlbnRpdHlGdW5jdGlvbkNoZWNrLnRzXG52YXIgcnVuSWRlbnRpdHlGdW5jdGlvbkNoZWNrID0gKHJlc3VsdEZ1bmMsIGlucHV0U2VsZWN0b3JzUmVzdWx0cywgb3V0cHV0U2VsZWN0b3JSZXN1bHQpID0+IHtcbiAgaWYgKGlucHV0U2VsZWN0b3JzUmVzdWx0cy5sZW5ndGggPT09IDEgJiYgaW5wdXRTZWxlY3RvcnNSZXN1bHRzWzBdID09PSBvdXRwdXRTZWxlY3RvclJlc3VsdCkge1xuICAgIGxldCBpc0lucHV0U2FtZUFzT3V0cHV0ID0gZmFsc2U7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGVtcHR5T2JqZWN0ID0ge307XG4gICAgICBpZiAocmVzdWx0RnVuYyhlbXB0eU9iamVjdCkgPT09IGVtcHR5T2JqZWN0KVxuICAgICAgICBpc0lucHV0U2FtZUFzT3V0cHV0ID0gdHJ1ZTtcbiAgICB9IGNhdGNoIHtcbiAgICB9XG4gICAgaWYgKGlzSW5wdXRTYW1lQXNPdXRwdXQpIHtcbiAgICAgIGxldCBzdGFjayA9IHZvaWQgMDtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICA7XG4gICAgICAgICh7IHN0YWNrIH0gPSBlKTtcbiAgICAgIH1cbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgXCJUaGUgcmVzdWx0IGZ1bmN0aW9uIHJldHVybmVkIGl0cyBvd24gaW5wdXRzIHdpdGhvdXQgbW9kaWZpY2F0aW9uLiBlLmdcXG5gY3JlYXRlU2VsZWN0b3IoW3N0YXRlID0+IHN0YXRlLnRvZG9zXSwgdG9kb3MgPT4gdG9kb3MpYFxcblRoaXMgY291bGQgbGVhZCB0byBpbmVmZmljaWVudCBtZW1vaXphdGlvbiBhbmQgdW5uZWNlc3NhcnkgcmUtcmVuZGVycy5cXG5FbnN1cmUgdHJhbnNmb3JtYXRpb24gbG9naWMgaXMgaW4gdGhlIHJlc3VsdCBmdW5jdGlvbiwgYW5kIGV4dHJhY3Rpb24gbG9naWMgaXMgaW4gdGhlIGlucHV0IHNlbGVjdG9ycy5cIixcbiAgICAgICAgeyBzdGFjayB9XG4gICAgICApO1xuICAgIH1cbiAgfVxufTtcblxuLy8gc3JjL2Rldk1vZGVDaGVja3MvaW5wdXRTdGFiaWxpdHlDaGVjay50c1xudmFyIHJ1bklucHV0U3RhYmlsaXR5Q2hlY2sgPSAoaW5wdXRTZWxlY3RvclJlc3VsdHNPYmplY3QsIG9wdGlvbnMsIGlucHV0U2VsZWN0b3JBcmdzKSA9PiB7XG4gIGNvbnN0IHsgbWVtb2l6ZSwgbWVtb2l6ZU9wdGlvbnMgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IHsgaW5wdXRTZWxlY3RvclJlc3VsdHMsIGlucHV0U2VsZWN0b3JSZXN1bHRzQ29weSB9ID0gaW5wdXRTZWxlY3RvclJlc3VsdHNPYmplY3Q7XG4gIGNvbnN0IGNyZWF0ZUFuRW1wdHlPYmplY3QgPSBtZW1vaXplKCgpID0+ICh7fSksIC4uLm1lbW9pemVPcHRpb25zKTtcbiAgY29uc3QgYXJlSW5wdXRTZWxlY3RvclJlc3VsdHNFcXVhbCA9IGNyZWF0ZUFuRW1wdHlPYmplY3QuYXBwbHkobnVsbCwgaW5wdXRTZWxlY3RvclJlc3VsdHMpID09PSBjcmVhdGVBbkVtcHR5T2JqZWN0LmFwcGx5KG51bGwsIGlucHV0U2VsZWN0b3JSZXN1bHRzQ29weSk7XG4gIGlmICghYXJlSW5wdXRTZWxlY3RvclJlc3VsdHNFcXVhbCkge1xuICAgIGxldCBzdGFjayA9IHZvaWQgMDtcbiAgICB0cnkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgO1xuICAgICAgKHsgc3RhY2sgfSA9IGUpO1xuICAgIH1cbiAgICBjb25zb2xlLndhcm4oXG4gICAgICBcIkFuIGlucHV0IHNlbGVjdG9yIHJldHVybmVkIGEgZGlmZmVyZW50IHJlc3VsdCB3aGVuIHBhc3NlZCBzYW1lIGFyZ3VtZW50cy5cXG5UaGlzIG1lYW5zIHlvdXIgb3V0cHV0IHNlbGVjdG9yIHdpbGwgbGlrZWx5IHJ1biBtb3JlIGZyZXF1ZW50bHkgdGhhbiBpbnRlbmRlZC5cXG5Bdm9pZCByZXR1cm5pbmcgYSBuZXcgcmVmZXJlbmNlIGluc2lkZSB5b3VyIGlucHV0IHNlbGVjdG9yLCBlLmcuXFxuYGNyZWF0ZVNlbGVjdG9yKFtzdGF0ZSA9PiBzdGF0ZS50b2Rvcy5tYXAodG9kbyA9PiB0b2RvLmlkKV0sIHRvZG9JZHMgPT4gdG9kb0lkcy5sZW5ndGgpYFwiLFxuICAgICAge1xuICAgICAgICBhcmd1bWVudHM6IGlucHV0U2VsZWN0b3JBcmdzLFxuICAgICAgICBmaXJzdElucHV0czogaW5wdXRTZWxlY3RvclJlc3VsdHMsXG4gICAgICAgIHNlY29uZElucHV0czogaW5wdXRTZWxlY3RvclJlc3VsdHNDb3B5LFxuICAgICAgICBzdGFja1xuICAgICAgfVxuICAgICk7XG4gIH1cbn07XG5cbi8vIHNyYy9kZXZNb2RlQ2hlY2tzL3NldEdsb2JhbERldk1vZGVDaGVja3MudHNcbnZhciBnbG9iYWxEZXZNb2RlQ2hlY2tzID0ge1xuICBpbnB1dFN0YWJpbGl0eUNoZWNrOiBcIm9uY2VcIixcbiAgaWRlbnRpdHlGdW5jdGlvbkNoZWNrOiBcIm9uY2VcIlxufTtcbnZhciBzZXRHbG9iYWxEZXZNb2RlQ2hlY2tzID0gKGRldk1vZGVDaGVja3MpID0+IHtcbiAgT2JqZWN0LmFzc2lnbihnbG9iYWxEZXZNb2RlQ2hlY2tzLCBkZXZNb2RlQ2hlY2tzKTtcbn07XG5cbi8vIHNyYy91dGlscy50c1xudmFyIE5PVF9GT1VORCA9IFwiTk9UX0ZPVU5EXCI7XG5mdW5jdGlvbiBhc3NlcnRJc0Z1bmN0aW9uKGZ1bmMsIGVycm9yTWVzc2FnZSA9IGBleHBlY3RlZCBhIGZ1bmN0aW9uLCBpbnN0ZWFkIHJlY2VpdmVkICR7dHlwZW9mIGZ1bmN9YCkge1xuICBpZiAodHlwZW9mIGZ1bmMgIT09IFwiZnVuY3Rpb25cIikge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoZXJyb3JNZXNzYWdlKTtcbiAgfVxufVxuZnVuY3Rpb24gYXNzZXJ0SXNPYmplY3Qob2JqZWN0LCBlcnJvck1lc3NhZ2UgPSBgZXhwZWN0ZWQgYW4gb2JqZWN0LCBpbnN0ZWFkIHJlY2VpdmVkICR7dHlwZW9mIG9iamVjdH1gKSB7XG4gIGlmICh0eXBlb2Ygb2JqZWN0ICE9PSBcIm9iamVjdFwiKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihlcnJvck1lc3NhZ2UpO1xuICB9XG59XG5mdW5jdGlvbiBhc3NlcnRJc0FycmF5T2ZGdW5jdGlvbnMoYXJyYXksIGVycm9yTWVzc2FnZSA9IGBleHBlY3RlZCBhbGwgaXRlbXMgdG8gYmUgZnVuY3Rpb25zLCBpbnN0ZWFkIHJlY2VpdmVkIHRoZSBmb2xsb3dpbmcgdHlwZXM6IGApIHtcbiAgaWYgKCFhcnJheS5ldmVyeSgoaXRlbSkgPT4gdHlwZW9mIGl0ZW0gPT09IFwiZnVuY3Rpb25cIikpIHtcbiAgICBjb25zdCBpdGVtVHlwZXMgPSBhcnJheS5tYXAoXG4gICAgICAoaXRlbSkgPT4gdHlwZW9mIGl0ZW0gPT09IFwiZnVuY3Rpb25cIiA/IGBmdW5jdGlvbiAke2l0ZW0ubmFtZSB8fCBcInVubmFtZWRcIn0oKWAgOiB0eXBlb2YgaXRlbVxuICAgICkuam9pbihcIiwgXCIpO1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYCR7ZXJyb3JNZXNzYWdlfVske2l0ZW1UeXBlc31dYCk7XG4gIH1cbn1cbnZhciBlbnN1cmVJc0FycmF5ID0gKGl0ZW0pID0+IHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoaXRlbSkgPyBpdGVtIDogW2l0ZW1dO1xufTtcbmZ1bmN0aW9uIGdldERlcGVuZGVuY2llcyhjcmVhdGVTZWxlY3RvckFyZ3MpIHtcbiAgY29uc3QgZGVwZW5kZW5jaWVzID0gQXJyYXkuaXNBcnJheShjcmVhdGVTZWxlY3RvckFyZ3NbMF0pID8gY3JlYXRlU2VsZWN0b3JBcmdzWzBdIDogY3JlYXRlU2VsZWN0b3JBcmdzO1xuICBhc3NlcnRJc0FycmF5T2ZGdW5jdGlvbnMoXG4gICAgZGVwZW5kZW5jaWVzLFxuICAgIGBjcmVhdGVTZWxlY3RvciBleHBlY3RzIGFsbCBpbnB1dC1zZWxlY3RvcnMgdG8gYmUgZnVuY3Rpb25zLCBidXQgcmVjZWl2ZWQgdGhlIGZvbGxvd2luZyB0eXBlczogYFxuICApO1xuICByZXR1cm4gZGVwZW5kZW5jaWVzO1xufVxuZnVuY3Rpb24gY29sbGVjdElucHV0U2VsZWN0b3JSZXN1bHRzKGRlcGVuZGVuY2llcywgaW5wdXRTZWxlY3RvckFyZ3MpIHtcbiAgY29uc3QgaW5wdXRTZWxlY3RvclJlc3VsdHMgPSBbXTtcbiAgY29uc3QgeyBsZW5ndGggfSA9IGRlcGVuZGVuY2llcztcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGlucHV0U2VsZWN0b3JSZXN1bHRzLnB1c2goZGVwZW5kZW5jaWVzW2ldLmFwcGx5KG51bGwsIGlucHV0U2VsZWN0b3JBcmdzKSk7XG4gIH1cbiAgcmV0dXJuIGlucHV0U2VsZWN0b3JSZXN1bHRzO1xufVxudmFyIGdldERldk1vZGVDaGVja3NFeGVjdXRpb25JbmZvID0gKGZpcnN0UnVuLCBkZXZNb2RlQ2hlY2tzKSA9PiB7XG4gIGNvbnN0IHsgaWRlbnRpdHlGdW5jdGlvbkNoZWNrLCBpbnB1dFN0YWJpbGl0eUNoZWNrIH0gPSB7XG4gICAgLi4uZ2xvYmFsRGV2TW9kZUNoZWNrcyxcbiAgICAuLi5kZXZNb2RlQ2hlY2tzXG4gIH07XG4gIHJldHVybiB7XG4gICAgaWRlbnRpdHlGdW5jdGlvbkNoZWNrOiB7XG4gICAgICBzaG91bGRSdW46IGlkZW50aXR5RnVuY3Rpb25DaGVjayA9PT0gXCJhbHdheXNcIiB8fCBpZGVudGl0eUZ1bmN0aW9uQ2hlY2sgPT09IFwib25jZVwiICYmIGZpcnN0UnVuLFxuICAgICAgcnVuOiBydW5JZGVudGl0eUZ1bmN0aW9uQ2hlY2tcbiAgICB9LFxuICAgIGlucHV0U3RhYmlsaXR5Q2hlY2s6IHtcbiAgICAgIHNob3VsZFJ1bjogaW5wdXRTdGFiaWxpdHlDaGVjayA9PT0gXCJhbHdheXNcIiB8fCBpbnB1dFN0YWJpbGl0eUNoZWNrID09PSBcIm9uY2VcIiAmJiBmaXJzdFJ1bixcbiAgICAgIHJ1bjogcnVuSW5wdXRTdGFiaWxpdHlDaGVja1xuICAgIH1cbiAgfTtcbn07XG5cbi8vIHNyYy9hdXRvdHJhY2tNZW1vaXplL2F1dG90cmFja2luZy50c1xudmFyICRSRVZJU0lPTiA9IDA7XG52YXIgQ1VSUkVOVF9UUkFDS0VSID0gbnVsbDtcbnZhciBDZWxsID0gY2xhc3Mge1xuICByZXZpc2lvbiA9ICRSRVZJU0lPTjtcbiAgX3ZhbHVlO1xuICBfbGFzdFZhbHVlO1xuICBfaXNFcXVhbCA9IHRyaXBsZUVxO1xuICBjb25zdHJ1Y3Rvcihpbml0aWFsVmFsdWUsIGlzRXF1YWwgPSB0cmlwbGVFcSkge1xuICAgIHRoaXMuX3ZhbHVlID0gdGhpcy5fbGFzdFZhbHVlID0gaW5pdGlhbFZhbHVlO1xuICAgIHRoaXMuX2lzRXF1YWwgPSBpc0VxdWFsO1xuICB9XG4gIC8vIFdoZW5ldmVyIGEgc3RvcmFnZSB2YWx1ZSBpcyByZWFkLCBpdCdsbCBhZGQgaXRzZWxmIHRvIHRoZSBjdXJyZW50IHRyYWNrZXIgaWZcbiAgLy8gb25lIGV4aXN0cywgZW50YW5nbGluZyBpdHMgc3RhdGUgd2l0aCB0aGF0IGNhY2hlLlxuICBnZXQgdmFsdWUoKSB7XG4gICAgQ1VSUkVOVF9UUkFDS0VSPy5hZGQodGhpcyk7XG4gICAgcmV0dXJuIHRoaXMuX3ZhbHVlO1xuICB9XG4gIC8vIFdoZW5ldmVyIGEgc3RvcmFnZSB2YWx1ZSBpcyB1cGRhdGVkLCB3ZSBidW1wIHRoZSBnbG9iYWwgcmV2aXNpb24gY2xvY2ssXG4gIC8vIGFzc2lnbiB0aGUgcmV2aXNpb24gZm9yIHRoaXMgc3RvcmFnZSB0byB0aGUgbmV3IHZhbHVlLCBfYW5kXyB3ZSBzY2hlZHVsZSBhXG4gIC8vIHJlcmVuZGVyLiBUaGlzIGlzIGltcG9ydGFudCwgYW5kIGl0J3Mgd2hhdCBtYWtlcyBhdXRvdHJhY2tpbmcgIF9wdWxsX1xuICAvLyBiYXNlZC4gV2UgZG9uJ3QgYWN0aXZlbHkgdGVsbCB0aGUgY2FjaGVzIHdoaWNoIGRlcGVuZCBvbiB0aGUgc3RvcmFnZSB0aGF0XG4gIC8vIGFueXRoaW5nIGhhcyBoYXBwZW5lZC4gSW5zdGVhZCwgd2UgcmVjb21wdXRlIHRoZSBjYWNoZXMgd2hlbiBuZWVkZWQuXG4gIHNldCB2YWx1ZShuZXdWYWx1ZSkge1xuICAgIGlmICh0aGlzLnZhbHVlID09PSBuZXdWYWx1ZSlcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLl92YWx1ZSA9IG5ld1ZhbHVlO1xuICAgIHRoaXMucmV2aXNpb24gPSArKyRSRVZJU0lPTjtcbiAgfVxufTtcbmZ1bmN0aW9uIHRyaXBsZUVxKGEsIGIpIHtcbiAgcmV0dXJuIGEgPT09IGI7XG59XG52YXIgVHJhY2tpbmdDYWNoZSA9IGNsYXNzIHtcbiAgX2NhY2hlZFZhbHVlO1xuICBfY2FjaGVkUmV2aXNpb24gPSAtMTtcbiAgX2RlcHMgPSBbXTtcbiAgaGl0cyA9IDA7XG4gIGZuO1xuICBjb25zdHJ1Y3Rvcihmbikge1xuICAgIHRoaXMuZm4gPSBmbjtcbiAgfVxuICBjbGVhcigpIHtcbiAgICB0aGlzLl9jYWNoZWRWYWx1ZSA9IHZvaWQgMDtcbiAgICB0aGlzLl9jYWNoZWRSZXZpc2lvbiA9IC0xO1xuICAgIHRoaXMuX2RlcHMgPSBbXTtcbiAgICB0aGlzLmhpdHMgPSAwO1xuICB9XG4gIGdldCB2YWx1ZSgpIHtcbiAgICBpZiAodGhpcy5yZXZpc2lvbiA+IHRoaXMuX2NhY2hlZFJldmlzaW9uKSB7XG4gICAgICBjb25zdCB7IGZuIH0gPSB0aGlzO1xuICAgICAgY29uc3QgY3VycmVudFRyYWNrZXIgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgICAgY29uc3QgcHJldlRyYWNrZXIgPSBDVVJSRU5UX1RSQUNLRVI7XG4gICAgICBDVVJSRU5UX1RSQUNLRVIgPSBjdXJyZW50VHJhY2tlcjtcbiAgICAgIHRoaXMuX2NhY2hlZFZhbHVlID0gZm4oKTtcbiAgICAgIENVUlJFTlRfVFJBQ0tFUiA9IHByZXZUcmFja2VyO1xuICAgICAgdGhpcy5oaXRzKys7XG4gICAgICB0aGlzLl9kZXBzID0gQXJyYXkuZnJvbShjdXJyZW50VHJhY2tlcik7XG4gICAgICB0aGlzLl9jYWNoZWRSZXZpc2lvbiA9IHRoaXMucmV2aXNpb247XG4gICAgfVxuICAgIENVUlJFTlRfVFJBQ0tFUj8uYWRkKHRoaXMpO1xuICAgIHJldHVybiB0aGlzLl9jYWNoZWRWYWx1ZTtcbiAgfVxuICBnZXQgcmV2aXNpb24oKSB7XG4gICAgcmV0dXJuIE1hdGgubWF4KC4uLnRoaXMuX2RlcHMubWFwKChkKSA9PiBkLnJldmlzaW9uKSwgMCk7XG4gIH1cbn07XG5mdW5jdGlvbiBnZXRWYWx1ZShjZWxsKSB7XG4gIGlmICghKGNlbGwgaW5zdGFuY2VvZiBDZWxsKSkge1xuICAgIGNvbnNvbGUud2FybihcIk5vdCBhIHZhbGlkIGNlbGwhIFwiLCBjZWxsKTtcbiAgfVxuICByZXR1cm4gY2VsbC52YWx1ZTtcbn1cbmZ1bmN0aW9uIHNldFZhbHVlKHN0b3JhZ2UsIHZhbHVlKSB7XG4gIGlmICghKHN0b3JhZ2UgaW5zdGFuY2VvZiBDZWxsKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICBcInNldFZhbHVlIG11c3QgYmUgcGFzc2VkIGEgdHJhY2tlZCBzdG9yZSBjcmVhdGVkIHdpdGggYGNyZWF0ZVN0b3JhZ2VgLlwiXG4gICAgKTtcbiAgfVxuICBzdG9yYWdlLnZhbHVlID0gc3RvcmFnZS5fbGFzdFZhbHVlID0gdmFsdWU7XG59XG5mdW5jdGlvbiBjcmVhdGVDZWxsKGluaXRpYWxWYWx1ZSwgaXNFcXVhbCA9IHRyaXBsZUVxKSB7XG4gIHJldHVybiBuZXcgQ2VsbChpbml0aWFsVmFsdWUsIGlzRXF1YWwpO1xufVxuZnVuY3Rpb24gY3JlYXRlQ2FjaGUoZm4pIHtcbiAgYXNzZXJ0SXNGdW5jdGlvbihcbiAgICBmbixcbiAgICBcInRoZSBmaXJzdCBwYXJhbWV0ZXIgdG8gYGNyZWF0ZUNhY2hlYCBtdXN0IGJlIGEgZnVuY3Rpb25cIlxuICApO1xuICByZXR1cm4gbmV3IFRyYWNraW5nQ2FjaGUoZm4pO1xufVxuXG4vLyBzcmMvYXV0b3RyYWNrTWVtb2l6ZS90cmFja2luZy50c1xudmFyIG5ldmVyRXEgPSAoYSwgYikgPT4gZmFsc2U7XG5mdW5jdGlvbiBjcmVhdGVUYWcoKSB7XG4gIHJldHVybiBjcmVhdGVDZWxsKG51bGwsIG5ldmVyRXEpO1xufVxuZnVuY3Rpb24gZGlydHlUYWcodGFnLCB2YWx1ZSkge1xuICBzZXRWYWx1ZSh0YWcsIHZhbHVlKTtcbn1cbnZhciBjb25zdW1lQ29sbGVjdGlvbiA9IChub2RlKSA9PiB7XG4gIGxldCB0YWcgPSBub2RlLmNvbGxlY3Rpb25UYWc7XG4gIGlmICh0YWcgPT09IG51bGwpIHtcbiAgICB0YWcgPSBub2RlLmNvbGxlY3Rpb25UYWcgPSBjcmVhdGVUYWcoKTtcbiAgfVxuICBnZXRWYWx1ZSh0YWcpO1xufTtcbnZhciBkaXJ0eUNvbGxlY3Rpb24gPSAobm9kZSkgPT4ge1xuICBjb25zdCB0YWcgPSBub2RlLmNvbGxlY3Rpb25UYWc7XG4gIGlmICh0YWcgIT09IG51bGwpIHtcbiAgICBkaXJ0eVRhZyh0YWcsIG51bGwpO1xuICB9XG59O1xuXG4vLyBzcmMvYXV0b3RyYWNrTWVtb2l6ZS9wcm94eS50c1xudmFyIFJFRFVYX1BST1hZX0xBQkVMID0gU3ltYm9sKCk7XG52YXIgbmV4dElkID0gMDtcbnZhciBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih7fSk7XG52YXIgT2JqZWN0VHJlZU5vZGUgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHZhbHVlKSB7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB0aGlzLnRhZy52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIHByb3h5ID0gbmV3IFByb3h5KHRoaXMsIG9iamVjdFByb3h5SGFuZGxlcik7XG4gIHRhZyA9IGNyZWF0ZVRhZygpO1xuICB0YWdzID0ge307XG4gIGNoaWxkcmVuID0ge307XG4gIGNvbGxlY3Rpb25UYWcgPSBudWxsO1xuICBpZCA9IG5leHRJZCsrO1xufTtcbnZhciBvYmplY3RQcm94eUhhbmRsZXIgPSB7XG4gIGdldChub2RlLCBrZXkpIHtcbiAgICBmdW5jdGlvbiBjYWxjdWxhdGVSZXN1bHQoKSB7XG4gICAgICBjb25zdCB7IHZhbHVlIH0gPSBub2RlO1xuICAgICAgY29uc3QgY2hpbGRWYWx1ZSA9IFJlZmxlY3QuZ2V0KHZhbHVlLCBrZXkpO1xuICAgICAgaWYgKHR5cGVvZiBrZXkgPT09IFwic3ltYm9sXCIpIHtcbiAgICAgICAgcmV0dXJuIGNoaWxkVmFsdWU7XG4gICAgICB9XG4gICAgICBpZiAoa2V5IGluIHByb3RvKSB7XG4gICAgICAgIHJldHVybiBjaGlsZFZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBjaGlsZFZhbHVlID09PSBcIm9iamVjdFwiICYmIGNoaWxkVmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgbGV0IGNoaWxkTm9kZSA9IG5vZGUuY2hpbGRyZW5ba2V5XTtcbiAgICAgICAgaWYgKGNoaWxkTm9kZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgY2hpbGROb2RlID0gbm9kZS5jaGlsZHJlbltrZXldID0gY3JlYXRlTm9kZShjaGlsZFZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hpbGROb2RlLnRhZykge1xuICAgICAgICAgIGdldFZhbHVlKGNoaWxkTm9kZS50YWcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaGlsZE5vZGUucHJveHk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgdGFnID0gbm9kZS50YWdzW2tleV07XG4gICAgICAgIGlmICh0YWcgPT09IHZvaWQgMCkge1xuICAgICAgICAgIHRhZyA9IG5vZGUudGFnc1trZXldID0gY3JlYXRlVGFnKCk7XG4gICAgICAgICAgdGFnLnZhbHVlID0gY2hpbGRWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBnZXRWYWx1ZSh0YWcpO1xuICAgICAgICByZXR1cm4gY2hpbGRWYWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgcmVzID0gY2FsY3VsYXRlUmVzdWx0KCk7XG4gICAgcmV0dXJuIHJlcztcbiAgfSxcbiAgb3duS2V5cyhub2RlKSB7XG4gICAgY29uc3VtZUNvbGxlY3Rpb24obm9kZSk7XG4gICAgcmV0dXJuIFJlZmxlY3Qub3duS2V5cyhub2RlLnZhbHVlKTtcbiAgfSxcbiAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG5vZGUsIHByb3ApIHtcbiAgICByZXR1cm4gUmVmbGVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iobm9kZS52YWx1ZSwgcHJvcCk7XG4gIH0sXG4gIGhhcyhub2RlLCBwcm9wKSB7XG4gICAgcmV0dXJuIFJlZmxlY3QuaGFzKG5vZGUudmFsdWUsIHByb3ApO1xuICB9XG59O1xudmFyIEFycmF5VHJlZU5vZGUgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHZhbHVlKSB7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB0aGlzLnRhZy52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIHByb3h5ID0gbmV3IFByb3h5KFt0aGlzXSwgYXJyYXlQcm94eUhhbmRsZXIpO1xuICB0YWcgPSBjcmVhdGVUYWcoKTtcbiAgdGFncyA9IHt9O1xuICBjaGlsZHJlbiA9IHt9O1xuICBjb2xsZWN0aW9uVGFnID0gbnVsbDtcbiAgaWQgPSBuZXh0SWQrKztcbn07XG52YXIgYXJyYXlQcm94eUhhbmRsZXIgPSB7XG4gIGdldChbbm9kZV0sIGtleSkge1xuICAgIGlmIChrZXkgPT09IFwibGVuZ3RoXCIpIHtcbiAgICAgIGNvbnN1bWVDb2xsZWN0aW9uKG5vZGUpO1xuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0UHJveHlIYW5kbGVyLmdldChub2RlLCBrZXkpO1xuICB9LFxuICBvd25LZXlzKFtub2RlXSkge1xuICAgIHJldHVybiBvYmplY3RQcm94eUhhbmRsZXIub3duS2V5cyhub2RlKTtcbiAgfSxcbiAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKFtub2RlXSwgcHJvcCkge1xuICAgIHJldHVybiBvYmplY3RQcm94eUhhbmRsZXIuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG5vZGUsIHByb3ApO1xuICB9LFxuICBoYXMoW25vZGVdLCBwcm9wKSB7XG4gICAgcmV0dXJuIG9iamVjdFByb3h5SGFuZGxlci5oYXMobm9kZSwgcHJvcCk7XG4gIH1cbn07XG5mdW5jdGlvbiBjcmVhdGVOb2RlKHZhbHVlKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiBuZXcgQXJyYXlUcmVlTm9kZSh2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIG5ldyBPYmplY3RUcmVlTm9kZSh2YWx1ZSk7XG59XG5mdW5jdGlvbiB1cGRhdGVOb2RlKG5vZGUsIG5ld1ZhbHVlKSB7XG4gIGNvbnN0IHsgdmFsdWUsIHRhZ3MsIGNoaWxkcmVuIH0gPSBub2RlO1xuICBub2RlLnZhbHVlID0gbmV3VmFsdWU7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSAmJiBBcnJheS5pc0FycmF5KG5ld1ZhbHVlKSAmJiB2YWx1ZS5sZW5ndGggIT09IG5ld1ZhbHVlLmxlbmd0aCkge1xuICAgIGRpcnR5Q29sbGVjdGlvbihub2RlKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAodmFsdWUgIT09IG5ld1ZhbHVlKSB7XG4gICAgICBsZXQgb2xkS2V5c1NpemUgPSAwO1xuICAgICAgbGV0IG5ld0tleXNTaXplID0gMDtcbiAgICAgIGxldCBhbnlLZXlzQWRkZWQgPSBmYWxzZTtcbiAgICAgIGZvciAoY29uc3QgX2tleSBpbiB2YWx1ZSkge1xuICAgICAgICBvbGRLZXlzU2l6ZSsrO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBrZXkgaW4gbmV3VmFsdWUpIHtcbiAgICAgICAgbmV3S2V5c1NpemUrKztcbiAgICAgICAgaWYgKCEoa2V5IGluIHZhbHVlKSkge1xuICAgICAgICAgIGFueUtleXNBZGRlZCA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IGlzRGlmZmVyZW50ID0gYW55S2V5c0FkZGVkIHx8IG9sZEtleXNTaXplICE9PSBuZXdLZXlzU2l6ZTtcbiAgICAgIGlmIChpc0RpZmZlcmVudCkge1xuICAgICAgICBkaXJ0eUNvbGxlY3Rpb24obm9kZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZvciAoY29uc3Qga2V5IGluIHRhZ3MpIHtcbiAgICBjb25zdCBjaGlsZFZhbHVlID0gdmFsdWVba2V5XTtcbiAgICBjb25zdCBuZXdDaGlsZFZhbHVlID0gbmV3VmFsdWVba2V5XTtcbiAgICBpZiAoY2hpbGRWYWx1ZSAhPT0gbmV3Q2hpbGRWYWx1ZSkge1xuICAgICAgZGlydHlDb2xsZWN0aW9uKG5vZGUpO1xuICAgICAgZGlydHlUYWcodGFnc1trZXldLCBuZXdDaGlsZFZhbHVlKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBuZXdDaGlsZFZhbHVlID09PSBcIm9iamVjdFwiICYmIG5ld0NoaWxkVmFsdWUgIT09IG51bGwpIHtcbiAgICAgIGRlbGV0ZSB0YWdzW2tleV07XG4gICAgfVxuICB9XG4gIGZvciAoY29uc3Qga2V5IGluIGNoaWxkcmVuKSB7XG4gICAgY29uc3QgY2hpbGROb2RlID0gY2hpbGRyZW5ba2V5XTtcbiAgICBjb25zdCBuZXdDaGlsZFZhbHVlID0gbmV3VmFsdWVba2V5XTtcbiAgICBjb25zdCBjaGlsZFZhbHVlID0gY2hpbGROb2RlLnZhbHVlO1xuICAgIGlmIChjaGlsZFZhbHVlID09PSBuZXdDaGlsZFZhbHVlKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBuZXdDaGlsZFZhbHVlID09PSBcIm9iamVjdFwiICYmIG5ld0NoaWxkVmFsdWUgIT09IG51bGwpIHtcbiAgICAgIHVwZGF0ZU5vZGUoY2hpbGROb2RlLCBuZXdDaGlsZFZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlTm9kZShjaGlsZE5vZGUpO1xuICAgICAgZGVsZXRlIGNoaWxkcmVuW2tleV07XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBkZWxldGVOb2RlKG5vZGUpIHtcbiAgaWYgKG5vZGUudGFnKSB7XG4gICAgZGlydHlUYWcobm9kZS50YWcsIG51bGwpO1xuICB9XG4gIGRpcnR5Q29sbGVjdGlvbihub2RlKTtcbiAgZm9yIChjb25zdCBrZXkgaW4gbm9kZS50YWdzKSB7XG4gICAgZGlydHlUYWcobm9kZS50YWdzW2tleV0sIG51bGwpO1xuICB9XG4gIGZvciAoY29uc3Qga2V5IGluIG5vZGUuY2hpbGRyZW4pIHtcbiAgICBkZWxldGVOb2RlKG5vZGUuY2hpbGRyZW5ba2V5XSk7XG4gIH1cbn1cblxuLy8gc3JjL2xydU1lbW9pemUudHNcbmZ1bmN0aW9uIGNyZWF0ZVNpbmdsZXRvbkNhY2hlKGVxdWFscykge1xuICBsZXQgZW50cnk7XG4gIHJldHVybiB7XG4gICAgZ2V0KGtleSkge1xuICAgICAgaWYgKGVudHJ5ICYmIGVxdWFscyhlbnRyeS5rZXksIGtleSkpIHtcbiAgICAgICAgcmV0dXJuIGVudHJ5LnZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIE5PVF9GT1VORDtcbiAgICB9LFxuICAgIHB1dChrZXksIHZhbHVlKSB7XG4gICAgICBlbnRyeSA9IHsga2V5LCB2YWx1ZSB9O1xuICAgIH0sXG4gICAgZ2V0RW50cmllcygpIHtcbiAgICAgIHJldHVybiBlbnRyeSA/IFtlbnRyeV0gOiBbXTtcbiAgICB9LFxuICAgIGNsZWFyKCkge1xuICAgICAgZW50cnkgPSB2b2lkIDA7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlTHJ1Q2FjaGUobWF4U2l6ZSwgZXF1YWxzKSB7XG4gIGxldCBlbnRyaWVzID0gW107XG4gIGZ1bmN0aW9uIGdldChrZXkpIHtcbiAgICBjb25zdCBjYWNoZUluZGV4ID0gZW50cmllcy5maW5kSW5kZXgoKGVudHJ5KSA9PiBlcXVhbHMoa2V5LCBlbnRyeS5rZXkpKTtcbiAgICBpZiAoY2FjaGVJbmRleCA+IC0xKSB7XG4gICAgICBjb25zdCBlbnRyeSA9IGVudHJpZXNbY2FjaGVJbmRleF07XG4gICAgICBpZiAoY2FjaGVJbmRleCA+IDApIHtcbiAgICAgICAgZW50cmllcy5zcGxpY2UoY2FjaGVJbmRleCwgMSk7XG4gICAgICAgIGVudHJpZXMudW5zaGlmdChlbnRyeSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZW50cnkudmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBOT1RfRk9VTkQ7XG4gIH1cbiAgZnVuY3Rpb24gcHV0KGtleSwgdmFsdWUpIHtcbiAgICBpZiAoZ2V0KGtleSkgPT09IE5PVF9GT1VORCkge1xuICAgICAgZW50cmllcy51bnNoaWZ0KHsga2V5LCB2YWx1ZSB9KTtcbiAgICAgIGlmIChlbnRyaWVzLmxlbmd0aCA+IG1heFNpemUpIHtcbiAgICAgICAgZW50cmllcy5wb3AoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZ2V0RW50cmllcygpIHtcbiAgICByZXR1cm4gZW50cmllcztcbiAgfVxuICBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICBlbnRyaWVzID0gW107XG4gIH1cbiAgcmV0dXJuIHsgZ2V0LCBwdXQsIGdldEVudHJpZXMsIGNsZWFyIH07XG59XG52YXIgcmVmZXJlbmNlRXF1YWxpdHlDaGVjayA9IChhLCBiKSA9PiBhID09PSBiO1xuZnVuY3Rpb24gY3JlYXRlQ2FjaGVLZXlDb21wYXJhdG9yKGVxdWFsaXR5Q2hlY2spIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGFyZUFyZ3VtZW50c1NoYWxsb3dseUVxdWFsKHByZXYsIG5leHQpIHtcbiAgICBpZiAocHJldiA9PT0gbnVsbCB8fCBuZXh0ID09PSBudWxsIHx8IHByZXYubGVuZ3RoICE9PSBuZXh0Lmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCB7IGxlbmd0aCB9ID0gcHJldjtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoIWVxdWFsaXR5Q2hlY2socHJldltpXSwgbmV4dFtpXSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGxydU1lbW9pemUoZnVuYywgZXF1YWxpdHlDaGVja09yT3B0aW9ucykge1xuICBjb25zdCBwcm92aWRlZE9wdGlvbnMgPSB0eXBlb2YgZXF1YWxpdHlDaGVja09yT3B0aW9ucyA9PT0gXCJvYmplY3RcIiA/IGVxdWFsaXR5Q2hlY2tPck9wdGlvbnMgOiB7IGVxdWFsaXR5Q2hlY2s6IGVxdWFsaXR5Q2hlY2tPck9wdGlvbnMgfTtcbiAgY29uc3Qge1xuICAgIGVxdWFsaXR5Q2hlY2sgPSByZWZlcmVuY2VFcXVhbGl0eUNoZWNrLFxuICAgIG1heFNpemUgPSAxLFxuICAgIHJlc3VsdEVxdWFsaXR5Q2hlY2tcbiAgfSA9IHByb3ZpZGVkT3B0aW9ucztcbiAgY29uc3QgY29tcGFyYXRvciA9IGNyZWF0ZUNhY2hlS2V5Q29tcGFyYXRvcihlcXVhbGl0eUNoZWNrKTtcbiAgbGV0IHJlc3VsdHNDb3VudCA9IDA7XG4gIGNvbnN0IGNhY2hlID0gbWF4U2l6ZSA9PT0gMSA/IGNyZWF0ZVNpbmdsZXRvbkNhY2hlKGNvbXBhcmF0b3IpIDogY3JlYXRlTHJ1Q2FjaGUobWF4U2l6ZSwgY29tcGFyYXRvcik7XG4gIGZ1bmN0aW9uIG1lbW9pemVkKCkge1xuICAgIGxldCB2YWx1ZSA9IGNhY2hlLmdldChhcmd1bWVudHMpO1xuICAgIGlmICh2YWx1ZSA9PT0gTk9UX0ZPVU5EKSB7XG4gICAgICB2YWx1ZSA9IGZ1bmMuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgIHJlc3VsdHNDb3VudCsrO1xuICAgICAgaWYgKHJlc3VsdEVxdWFsaXR5Q2hlY2spIHtcbiAgICAgICAgY29uc3QgZW50cmllcyA9IGNhY2hlLmdldEVudHJpZXMoKTtcbiAgICAgICAgY29uc3QgbWF0Y2hpbmdFbnRyeSA9IGVudHJpZXMuZmluZChcbiAgICAgICAgICAoZW50cnkpID0+IHJlc3VsdEVxdWFsaXR5Q2hlY2soZW50cnkudmFsdWUsIHZhbHVlKVxuICAgICAgICApO1xuICAgICAgICBpZiAobWF0Y2hpbmdFbnRyeSkge1xuICAgICAgICAgIHZhbHVlID0gbWF0Y2hpbmdFbnRyeS52YWx1ZTtcbiAgICAgICAgICByZXN1bHRzQ291bnQgIT09IDAgJiYgcmVzdWx0c0NvdW50LS07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNhY2hlLnB1dChhcmd1bWVudHMsIHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIG1lbW9pemVkLmNsZWFyQ2FjaGUgPSAoKSA9PiB7XG4gICAgY2FjaGUuY2xlYXIoKTtcbiAgICBtZW1vaXplZC5yZXNldFJlc3VsdHNDb3VudCgpO1xuICB9O1xuICBtZW1vaXplZC5yZXN1bHRzQ291bnQgPSAoKSA9PiByZXN1bHRzQ291bnQ7XG4gIG1lbW9pemVkLnJlc2V0UmVzdWx0c0NvdW50ID0gKCkgPT4ge1xuICAgIHJlc3VsdHNDb3VudCA9IDA7XG4gIH07XG4gIHJldHVybiBtZW1vaXplZDtcbn1cblxuLy8gc3JjL2F1dG90cmFja01lbW9pemUvYXV0b3RyYWNrTWVtb2l6ZS50c1xuZnVuY3Rpb24gYXV0b3RyYWNrTWVtb2l6ZShmdW5jKSB7XG4gIGNvbnN0IG5vZGUgPSBjcmVhdGVOb2RlKFxuICAgIFtdXG4gICk7XG4gIGxldCBsYXN0QXJncyA9IG51bGw7XG4gIGNvbnN0IHNoYWxsb3dFcXVhbCA9IGNyZWF0ZUNhY2hlS2V5Q29tcGFyYXRvcihyZWZlcmVuY2VFcXVhbGl0eUNoZWNrKTtcbiAgY29uc3QgY2FjaGUgPSBjcmVhdGVDYWNoZSgoKSA9PiB7XG4gICAgY29uc3QgcmVzID0gZnVuYy5hcHBseShudWxsLCBub2RlLnByb3h5KTtcbiAgICByZXR1cm4gcmVzO1xuICB9KTtcbiAgZnVuY3Rpb24gbWVtb2l6ZWQoKSB7XG4gICAgaWYgKCFzaGFsbG93RXF1YWwobGFzdEFyZ3MsIGFyZ3VtZW50cykpIHtcbiAgICAgIHVwZGF0ZU5vZGUobm9kZSwgYXJndW1lbnRzKTtcbiAgICAgIGxhc3RBcmdzID0gYXJndW1lbnRzO1xuICAgIH1cbiAgICByZXR1cm4gY2FjaGUudmFsdWU7XG4gIH1cbiAgbWVtb2l6ZWQuY2xlYXJDYWNoZSA9ICgpID0+IHtcbiAgICByZXR1cm4gY2FjaGUuY2xlYXIoKTtcbiAgfTtcbiAgcmV0dXJuIG1lbW9pemVkO1xufVxuXG4vLyBzcmMvd2Vha01hcE1lbW9pemUudHNcbnZhciBTdHJvbmdSZWYgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHZhbHVlKSB7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIGRlcmVmKCkge1xuICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICB9XG59O1xudmFyIFJlZiA9IHR5cGVvZiBXZWFrUmVmICE9PSBcInVuZGVmaW5lZFwiID8gV2Vha1JlZiA6IFN0cm9uZ1JlZjtcbnZhciBVTlRFUk1JTkFURUQgPSAwO1xudmFyIFRFUk1JTkFURUQgPSAxO1xuZnVuY3Rpb24gY3JlYXRlQ2FjaGVOb2RlKCkge1xuICByZXR1cm4ge1xuICAgIHM6IFVOVEVSTUlOQVRFRCxcbiAgICB2OiB2b2lkIDAsXG4gICAgbzogbnVsbCxcbiAgICBwOiBudWxsXG4gIH07XG59XG5mdW5jdGlvbiB3ZWFrTWFwTWVtb2l6ZShmdW5jLCBvcHRpb25zID0ge30pIHtcbiAgbGV0IGZuTm9kZSA9IGNyZWF0ZUNhY2hlTm9kZSgpO1xuICBjb25zdCB7IHJlc3VsdEVxdWFsaXR5Q2hlY2sgfSA9IG9wdGlvbnM7XG4gIGxldCBsYXN0UmVzdWx0O1xuICBsZXQgcmVzdWx0c0NvdW50ID0gMDtcbiAgZnVuY3Rpb24gbWVtb2l6ZWQoKSB7XG4gICAgbGV0IGNhY2hlTm9kZSA9IGZuTm9kZTtcbiAgICBjb25zdCB7IGxlbmd0aCB9ID0gYXJndW1lbnRzO1xuICAgIGZvciAobGV0IGkgPSAwLCBsID0gbGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBjb25zdCBhcmcgPSBhcmd1bWVudHNbaV07XG4gICAgICBpZiAodHlwZW9mIGFyZyA9PT0gXCJmdW5jdGlvblwiIHx8IHR5cGVvZiBhcmcgPT09IFwib2JqZWN0XCIgJiYgYXJnICE9PSBudWxsKSB7XG4gICAgICAgIGxldCBvYmplY3RDYWNoZSA9IGNhY2hlTm9kZS5vO1xuICAgICAgICBpZiAob2JqZWN0Q2FjaGUgPT09IG51bGwpIHtcbiAgICAgICAgICBjYWNoZU5vZGUubyA9IG9iamVjdENhY2hlID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb2JqZWN0Tm9kZSA9IG9iamVjdENhY2hlLmdldChhcmcpO1xuICAgICAgICBpZiAob2JqZWN0Tm9kZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgY2FjaGVOb2RlID0gY3JlYXRlQ2FjaGVOb2RlKCk7XG4gICAgICAgICAgb2JqZWN0Q2FjaGUuc2V0KGFyZywgY2FjaGVOb2RlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYWNoZU5vZGUgPSBvYmplY3ROb2RlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgcHJpbWl0aXZlQ2FjaGUgPSBjYWNoZU5vZGUucDtcbiAgICAgICAgaWYgKHByaW1pdGl2ZUNhY2hlID09PSBudWxsKSB7XG4gICAgICAgICAgY2FjaGVOb2RlLnAgPSBwcmltaXRpdmVDYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJpbWl0aXZlTm9kZSA9IHByaW1pdGl2ZUNhY2hlLmdldChhcmcpO1xuICAgICAgICBpZiAocHJpbWl0aXZlTm9kZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgY2FjaGVOb2RlID0gY3JlYXRlQ2FjaGVOb2RlKCk7XG4gICAgICAgICAgcHJpbWl0aXZlQ2FjaGUuc2V0KGFyZywgY2FjaGVOb2RlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYWNoZU5vZGUgPSBwcmltaXRpdmVOb2RlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHRlcm1pbmF0ZWROb2RlID0gY2FjaGVOb2RlO1xuICAgIGxldCByZXN1bHQ7XG4gICAgaWYgKGNhY2hlTm9kZS5zID09PSBURVJNSU5BVEVEKSB7XG4gICAgICByZXN1bHQgPSBjYWNoZU5vZGUudjtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgcmVzdWx0c0NvdW50Kys7XG4gICAgfVxuICAgIHRlcm1pbmF0ZWROb2RlLnMgPSBURVJNSU5BVEVEO1xuICAgIGlmIChyZXN1bHRFcXVhbGl0eUNoZWNrKSB7XG4gICAgICBjb25zdCBsYXN0UmVzdWx0VmFsdWUgPSBsYXN0UmVzdWx0Py5kZXJlZj8uKCkgPz8gbGFzdFJlc3VsdDtcbiAgICAgIGlmIChsYXN0UmVzdWx0VmFsdWUgIT0gbnVsbCAmJiByZXN1bHRFcXVhbGl0eUNoZWNrKGxhc3RSZXN1bHRWYWx1ZSwgcmVzdWx0KSkge1xuICAgICAgICByZXN1bHQgPSBsYXN0UmVzdWx0VmFsdWU7XG4gICAgICAgIHJlc3VsdHNDb3VudCAhPT0gMCAmJiByZXN1bHRzQ291bnQtLTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG5lZWRzV2Vha1JlZiA9IHR5cGVvZiByZXN1bHQgPT09IFwib2JqZWN0XCIgJiYgcmVzdWx0ICE9PSBudWxsIHx8IHR5cGVvZiByZXN1bHQgPT09IFwiZnVuY3Rpb25cIjtcbiAgICAgIGxhc3RSZXN1bHQgPSBuZWVkc1dlYWtSZWYgPyBuZXcgUmVmKHJlc3VsdCkgOiByZXN1bHQ7XG4gICAgfVxuICAgIHRlcm1pbmF0ZWROb2RlLnYgPSByZXN1bHQ7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBtZW1vaXplZC5jbGVhckNhY2hlID0gKCkgPT4ge1xuICAgIGZuTm9kZSA9IGNyZWF0ZUNhY2hlTm9kZSgpO1xuICAgIG1lbW9pemVkLnJlc2V0UmVzdWx0c0NvdW50KCk7XG4gIH07XG4gIG1lbW9pemVkLnJlc3VsdHNDb3VudCA9ICgpID0+IHJlc3VsdHNDb3VudDtcbiAgbWVtb2l6ZWQucmVzZXRSZXN1bHRzQ291bnQgPSAoKSA9PiB7XG4gICAgcmVzdWx0c0NvdW50ID0gMDtcbiAgfTtcbiAgcmV0dXJuIG1lbW9pemVkO1xufVxuXG4vLyBzcmMvY3JlYXRlU2VsZWN0b3JDcmVhdG9yLnRzXG5mdW5jdGlvbiBjcmVhdGVTZWxlY3RvckNyZWF0b3IobWVtb2l6ZU9yT3B0aW9ucywgLi4ubWVtb2l6ZU9wdGlvbnNGcm9tQXJncykge1xuICBjb25zdCBjcmVhdGVTZWxlY3RvckNyZWF0b3JPcHRpb25zID0gdHlwZW9mIG1lbW9pemVPck9wdGlvbnMgPT09IFwiZnVuY3Rpb25cIiA/IHtcbiAgICBtZW1vaXplOiBtZW1vaXplT3JPcHRpb25zLFxuICAgIG1lbW9pemVPcHRpb25zOiBtZW1vaXplT3B0aW9uc0Zyb21BcmdzXG4gIH0gOiBtZW1vaXplT3JPcHRpb25zO1xuICBjb25zdCBjcmVhdGVTZWxlY3RvcjIgPSAoLi4uY3JlYXRlU2VsZWN0b3JBcmdzKSA9PiB7XG4gICAgbGV0IHJlY29tcHV0YXRpb25zID0gMDtcbiAgICBsZXQgZGVwZW5kZW5jeVJlY29tcHV0YXRpb25zID0gMDtcbiAgICBsZXQgbGFzdFJlc3VsdDtcbiAgICBsZXQgZGlyZWN0bHlQYXNzZWRPcHRpb25zID0ge307XG4gICAgbGV0IHJlc3VsdEZ1bmMgPSBjcmVhdGVTZWxlY3RvckFyZ3MucG9wKCk7XG4gICAgaWYgKHR5cGVvZiByZXN1bHRGdW5jID09PSBcIm9iamVjdFwiKSB7XG4gICAgICBkaXJlY3RseVBhc3NlZE9wdGlvbnMgPSByZXN1bHRGdW5jO1xuICAgICAgcmVzdWx0RnVuYyA9IGNyZWF0ZVNlbGVjdG9yQXJncy5wb3AoKTtcbiAgICB9XG4gICAgYXNzZXJ0SXNGdW5jdGlvbihcbiAgICAgIHJlc3VsdEZ1bmMsXG4gICAgICBgY3JlYXRlU2VsZWN0b3IgZXhwZWN0cyBhbiBvdXRwdXQgZnVuY3Rpb24gYWZ0ZXIgdGhlIGlucHV0cywgYnV0IHJlY2VpdmVkOiBbJHt0eXBlb2YgcmVzdWx0RnVuY31dYFxuICAgICk7XG4gICAgY29uc3QgY29tYmluZWRPcHRpb25zID0ge1xuICAgICAgLi4uY3JlYXRlU2VsZWN0b3JDcmVhdG9yT3B0aW9ucyxcbiAgICAgIC4uLmRpcmVjdGx5UGFzc2VkT3B0aW9uc1xuICAgIH07XG4gICAgY29uc3Qge1xuICAgICAgbWVtb2l6ZSxcbiAgICAgIG1lbW9pemVPcHRpb25zID0gW10sXG4gICAgICBhcmdzTWVtb2l6ZSA9IHdlYWtNYXBNZW1vaXplLFxuICAgICAgYXJnc01lbW9pemVPcHRpb25zID0gW10sXG4gICAgICBkZXZNb2RlQ2hlY2tzID0ge31cbiAgICB9ID0gY29tYmluZWRPcHRpb25zO1xuICAgIGNvbnN0IGZpbmFsTWVtb2l6ZU9wdGlvbnMgPSBlbnN1cmVJc0FycmF5KG1lbW9pemVPcHRpb25zKTtcbiAgICBjb25zdCBmaW5hbEFyZ3NNZW1vaXplT3B0aW9ucyA9IGVuc3VyZUlzQXJyYXkoYXJnc01lbW9pemVPcHRpb25zKTtcbiAgICBjb25zdCBkZXBlbmRlbmNpZXMgPSBnZXREZXBlbmRlbmNpZXMoY3JlYXRlU2VsZWN0b3JBcmdzKTtcbiAgICBjb25zdCBtZW1vaXplZFJlc3VsdEZ1bmMgPSBtZW1vaXplKGZ1bmN0aW9uIHJlY29tcHV0YXRpb25XcmFwcGVyKCkge1xuICAgICAgcmVjb21wdXRhdGlvbnMrKztcbiAgICAgIHJldHVybiByZXN1bHRGdW5jLmFwcGx5KFxuICAgICAgICBudWxsLFxuICAgICAgICBhcmd1bWVudHNcbiAgICAgICk7XG4gICAgfSwgLi4uZmluYWxNZW1vaXplT3B0aW9ucyk7XG4gICAgbGV0IGZpcnN0UnVuID0gdHJ1ZTtcbiAgICBjb25zdCBzZWxlY3RvciA9IGFyZ3NNZW1vaXplKGZ1bmN0aW9uIGRlcGVuZGVuY2llc0NoZWNrZXIoKSB7XG4gICAgICBkZXBlbmRlbmN5UmVjb21wdXRhdGlvbnMrKztcbiAgICAgIGNvbnN0IGlucHV0U2VsZWN0b3JSZXN1bHRzID0gY29sbGVjdElucHV0U2VsZWN0b3JSZXN1bHRzKFxuICAgICAgICBkZXBlbmRlbmNpZXMsXG4gICAgICAgIGFyZ3VtZW50c1xuICAgICAgKTtcbiAgICAgIGxhc3RSZXN1bHQgPSBtZW1vaXplZFJlc3VsdEZ1bmMuYXBwbHkobnVsbCwgaW5wdXRTZWxlY3RvclJlc3VsdHMpO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICBjb25zdCB7IGlkZW50aXR5RnVuY3Rpb25DaGVjaywgaW5wdXRTdGFiaWxpdHlDaGVjayB9ID0gZ2V0RGV2TW9kZUNoZWNrc0V4ZWN1dGlvbkluZm8oZmlyc3RSdW4sIGRldk1vZGVDaGVja3MpO1xuICAgICAgICBpZiAoaWRlbnRpdHlGdW5jdGlvbkNoZWNrLnNob3VsZFJ1bikge1xuICAgICAgICAgIGlkZW50aXR5RnVuY3Rpb25DaGVjay5ydW4oXG4gICAgICAgICAgICByZXN1bHRGdW5jLFxuICAgICAgICAgICAgaW5wdXRTZWxlY3RvclJlc3VsdHMsXG4gICAgICAgICAgICBsYXN0UmVzdWx0XG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5wdXRTdGFiaWxpdHlDaGVjay5zaG91bGRSdW4pIHtcbiAgICAgICAgICBjb25zdCBpbnB1dFNlbGVjdG9yUmVzdWx0c0NvcHkgPSBjb2xsZWN0SW5wdXRTZWxlY3RvclJlc3VsdHMoXG4gICAgICAgICAgICBkZXBlbmRlbmNpZXMsXG4gICAgICAgICAgICBhcmd1bWVudHNcbiAgICAgICAgICApO1xuICAgICAgICAgIGlucHV0U3RhYmlsaXR5Q2hlY2sucnVuKFxuICAgICAgICAgICAgeyBpbnB1dFNlbGVjdG9yUmVzdWx0cywgaW5wdXRTZWxlY3RvclJlc3VsdHNDb3B5IH0sXG4gICAgICAgICAgICB7IG1lbW9pemUsIG1lbW9pemVPcHRpb25zOiBmaW5hbE1lbW9pemVPcHRpb25zIH0sXG4gICAgICAgICAgICBhcmd1bWVudHNcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmaXJzdFJ1bilcbiAgICAgICAgICBmaXJzdFJ1biA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxhc3RSZXN1bHQ7XG4gICAgfSwgLi4uZmluYWxBcmdzTWVtb2l6ZU9wdGlvbnMpO1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHNlbGVjdG9yLCB7XG4gICAgICByZXN1bHRGdW5jLFxuICAgICAgbWVtb2l6ZWRSZXN1bHRGdW5jLFxuICAgICAgZGVwZW5kZW5jaWVzLFxuICAgICAgZGVwZW5kZW5jeVJlY29tcHV0YXRpb25zOiAoKSA9PiBkZXBlbmRlbmN5UmVjb21wdXRhdGlvbnMsXG4gICAgICByZXNldERlcGVuZGVuY3lSZWNvbXB1dGF0aW9uczogKCkgPT4ge1xuICAgICAgICBkZXBlbmRlbmN5UmVjb21wdXRhdGlvbnMgPSAwO1xuICAgICAgfSxcbiAgICAgIGxhc3RSZXN1bHQ6ICgpID0+IGxhc3RSZXN1bHQsXG4gICAgICByZWNvbXB1dGF0aW9uczogKCkgPT4gcmVjb21wdXRhdGlvbnMsXG4gICAgICByZXNldFJlY29tcHV0YXRpb25zOiAoKSA9PiB7XG4gICAgICAgIHJlY29tcHV0YXRpb25zID0gMDtcbiAgICAgIH0sXG4gICAgICBtZW1vaXplLFxuICAgICAgYXJnc01lbW9pemVcbiAgICB9KTtcbiAgfTtcbiAgT2JqZWN0LmFzc2lnbihjcmVhdGVTZWxlY3RvcjIsIHtcbiAgICB3aXRoVHlwZXM6ICgpID0+IGNyZWF0ZVNlbGVjdG9yMlxuICB9KTtcbiAgcmV0dXJuIGNyZWF0ZVNlbGVjdG9yMjtcbn1cbnZhciBjcmVhdGVTZWxlY3RvciA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVTZWxlY3RvckNyZWF0b3Iod2Vha01hcE1lbW9pemUpO1xuXG4vLyBzcmMvY3JlYXRlU3RydWN0dXJlZFNlbGVjdG9yLnRzXG52YXIgY3JlYXRlU3RydWN0dXJlZFNlbGVjdG9yID0gT2JqZWN0LmFzc2lnbihcbiAgKGlucHV0U2VsZWN0b3JzT2JqZWN0LCBzZWxlY3RvckNyZWF0b3IgPSBjcmVhdGVTZWxlY3RvcikgPT4ge1xuICAgIGFzc2VydElzT2JqZWN0KFxuICAgICAgaW5wdXRTZWxlY3RvcnNPYmplY3QsXG4gICAgICBgY3JlYXRlU3RydWN0dXJlZFNlbGVjdG9yIGV4cGVjdHMgZmlyc3QgYXJndW1lbnQgdG8gYmUgYW4gb2JqZWN0IHdoZXJlIGVhY2ggcHJvcGVydHkgaXMgYSBzZWxlY3RvciwgaW5zdGVhZCByZWNlaXZlZCBhICR7dHlwZW9mIGlucHV0U2VsZWN0b3JzT2JqZWN0fWBcbiAgICApO1xuICAgIGNvbnN0IGlucHV0U2VsZWN0b3JLZXlzID0gT2JqZWN0LmtleXMoaW5wdXRTZWxlY3RvcnNPYmplY3QpO1xuICAgIGNvbnN0IGRlcGVuZGVuY2llcyA9IGlucHV0U2VsZWN0b3JLZXlzLm1hcChcbiAgICAgIChrZXkpID0+IGlucHV0U2VsZWN0b3JzT2JqZWN0W2tleV1cbiAgICApO1xuICAgIGNvbnN0IHN0cnVjdHVyZWRTZWxlY3RvciA9IHNlbGVjdG9yQ3JlYXRvcihcbiAgICAgIGRlcGVuZGVuY2llcyxcbiAgICAgICguLi5pbnB1dFNlbGVjdG9yUmVzdWx0cykgPT4ge1xuICAgICAgICByZXR1cm4gaW5wdXRTZWxlY3RvclJlc3VsdHMucmVkdWNlKChjb21wb3NpdGlvbiwgdmFsdWUsIGluZGV4KSA9PiB7XG4gICAgICAgICAgY29tcG9zaXRpb25baW5wdXRTZWxlY3RvcktleXNbaW5kZXhdXSA9IHZhbHVlO1xuICAgICAgICAgIHJldHVybiBjb21wb3NpdGlvbjtcbiAgICAgICAgfSwge30pO1xuICAgICAgfVxuICAgICk7XG4gICAgcmV0dXJuIHN0cnVjdHVyZWRTZWxlY3RvcjtcbiAgfSxcbiAgeyB3aXRoVHlwZXM6ICgpID0+IGNyZWF0ZVN0cnVjdHVyZWRTZWxlY3RvciB9XG4pO1xuZXhwb3J0IHtcbiAgY3JlYXRlU2VsZWN0b3IsXG4gIGNyZWF0ZVNlbGVjdG9yQ3JlYXRvcixcbiAgY3JlYXRlU3RydWN0dXJlZFNlbGVjdG9yLFxuICBscnVNZW1vaXplLFxuICByZWZlcmVuY2VFcXVhbGl0eUNoZWNrLFxuICBzZXRHbG9iYWxEZXZNb2RlQ2hlY2tzLFxuICBhdXRvdHJhY2tNZW1vaXplIGFzIHVuc3RhYmxlX2F1dG90cmFja01lbW9pemUsXG4gIHdlYWtNYXBNZW1vaXplXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVzZWxlY3QubWpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/reselect/dist/reselect.mjs\n"));

/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ var __webpack_exec__ = function(moduleId) { return __webpack_require__(__webpack_require__.s = moduleId); }
/******/ __webpack_require__.O(0, ["main-app"], function() { return __webpack_exec__("(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2FUsers%2Fmartinlacsamana%2FDocuments%2F160%2Fproject%2Fpatent-analyzer%2Fapp%2Fpage.tsx%22%2C%22ids%22%3A%5B%5D%7D&server=false!"); });
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);